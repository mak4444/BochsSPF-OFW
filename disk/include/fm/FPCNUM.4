
[IFNDEF] /STRING : /STRING DUP >R - SWAP R> + SWAP ;
[THEN]

[IFNDEF] 0>  : 0> 0 > ;
[THEN]

[IFNDEF] RDROP : RDROP POSTPONE R>  POSTPONE DROP ; IMMEDIATE
[THEN]

[IFNDEF] DUP>R : DUP>R POSTPONE DUP POSTPONE >R ; IMMEDIATE
[THEN]

[IFNDEF] UPC
: UPC  ( c -- c' )
   DUP [CHAR] Z U>
   IF  0xDF AND
   THEN   ;
[THEN]

\- lit, : lit, compile  (lit) , ;

0 VALUE DOUBLE?

-1 VALUE DP-LOCATION

0 VALUE ?MINUS

: NUMBER?       ( addr len -- d1 f1 )
                FALSE TO DOUBLE?                \ initially not a double #
                -1 TO DP-LOCATION
                OVER C@ [CHAR] - =
                OVER SWAP 0< AND DUP>R
                IF      1 /STRING
                THEN
                DUP 0=
                IF      RDROP      FALSE TO ?MINUS
                        2DROP 0 0 FALSE EXIT   \ always return zero on failure
                THEN
                0 0 2SWAP >NUMBER
                OVER C@ [CHAR] . =              \ next char is a '.'
                OVER SWAP 0< AND                     \ more chars to look at
                IF      DUP 1- TO DP-LOCATION
			BEGIN
                        1 /STRING >NUMBER
                        DUP 0=
                        IF      TRUE TO DOUBLE? \ mark as a double number
                        THEN
  OVER C@ [CHAR] . <>			UNTIL 
                THEN    NIP 0=
                R> ?MINUS XOR
                IF      >R DNEGATE R>
                THEN  FALSE TO ?MINUS
;

: SNUMBER ( addr len -- d1 )
 NUMBER? THROW ;
 

: NUMBER ( a1 -- d1 )
\ Convert count delimited string at a1 into a double number.

\  0 0 ROT COUNT >NUMBER THROW DROP

 COUNT
 NUMBER? 0=
 THROW ;

: XXX-SLITERAL ( addr u -> d true | false ) 
   NUMBER?
 IF DOUBLE? 0= IF DROP THEN TRUE  EXIT
 THEN
   2DROP FALSE
;

: BIN-SLITERAL ( addr u -> d true | false )
  BASE @ >R 2 BASE !
  XXX-SLITERAL
  R> BASE !
;

: HHH-SLITERAL ( addr u -> d true | false )
  BASE @ >R HEX
  2- SWAP 2+ SWAP
  XXX-SLITERAL
  R> BASE !
;

: ?SLITERAL2_H  ( c-addr u -- ... )
  ( расширенный вариант ?SLITERAL1:
    если строка - не число, то пытаемся трактовать её
    как имя файла для авто-INCLUDED)
  DUP 1 >
     IF
	 2DUP 2>R
         OVER C@ [CHAR] - = DUP  TO ?MINUS
         IF    1 /STRING 
         THEN

         OVER W@ h# 7830 ( 0x) = 
         IF     HHH-SLITERAL
		IF RDROP RDROP
		ELSE 2R>
		THEN EXIT
         THEN

          OVER C@ [CHAR] $ = 
         IF 1+ SWAP 1- SWAP HHH-SLITERAL
		IF RDROP RDROP
		ELSE 2R>
		THEN EXIT
         THEN
              2DUP + 1- C@ UPC [CHAR] H =
         IF  1+  SWAP 2- SWAP  HHH-SLITERAL
		IF RDROP RDROP
		ELSE 2R>
		THEN EXIT
         THEN

             2DUP + 1- C@ UPC [CHAR] B = BASE @ h# 10 <> AND
         IF   1- BIN-SLITERAL
		IF RDROP RDROP 
		ELSE 2R>
		THEN EXIT
         THEN

             OVER @ h# FF00FF  AND h# 270027 ( '\0')  = 
             OVER 3 = AND
         IF  DROP @ 8 RSHIFT h# FF AND
\            STATE @ IF LIT, THEN
 RDROP RDROP  EXIT
         THEN 
         2DROP 2R>
  THEN
  2DUP 2>R 
 XXX-SLITERAL 0= \ ['] ?SLITERAL1 CATCH
  IF  2R>
       OVER C@ [CHAR] " = OVER 2 > AND
       IF 2 - SWAP 1+ SWAP THEN ( убрал кавычки, если есть)
       ['] INCLUDED CATCH ?dup
	IF ." fn=<" opened-filename 2@ type ." >"  mark-error  THROW THEN
  ELSE RDROP RDROP
  THEN
;

\ ' ?SLITERAL2_H TO ?SLITERAL

: (spf$handle-literal?)  ( adr len -- handled? )
\ STATE @ >R  STATE OFF
  ?SLITERAL2_H
\ R> STATE !
   DOUBLE? if 2 ELSE 1 then
   do-literal true
\   $dnumber?  dup  if  do-literal true  then
;
: NEWLT ['] (spf$handle-literal?) is $handle-literal? ;
: OLDLT ['] ($handle-literal?) is $handle-literal? ;

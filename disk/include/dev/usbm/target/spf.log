SP-FORTH - ANS FORTH 94 for Win95/98/ME/NT/2000/XP
Open source project at http://spf.sf.net
Russian FIG at http://www.forth.org.ru ; Started by A.Cherezov
Version 4.00 Build 987 at 05.May.2015

WDS isn't unique
CURRENT-VOC isn't unique
SOURCE-CONST isn't unique
SOURCE-LEN isn't unique
ChainOfConst isn't unique
compare_const isn't unique
_SEARCH-CONST isn't unique
SEARCH-CONST isn't unique
ADD-CONST-VOC isn't unique
REMOVE-ALL-CONSTANTS isn't unique
RWIN: isn't unique
cmdDBG isn't unique

9AA0024   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
9AA0034   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
9AA0044   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................R> isn't unique
>R isn't unique
RDROP isn't unique
{ isn't unique
: isn't unique
V_UPPER isn't unique
[ELSE] isn't unique
[IF] isn't unique
[THEN] isn't unique
[DEFINED] isn't unique
[UNDEFINED] isn't unique
[IFDEF] isn't unique
[IFNDEF] isn't unique
is isn't unique
DEFER isn't unique

TI=0 
vocset=575802 1A00280 1A04020 
code-field: docolon 
   \ ??? perhaps we can use "4 [w] ip lea"
   rp adec   ip  0 [rp] mov   w ainc   w ip mov
1A04020 	83 ED  4 89 75  0  5  4 
1A04028 	 0  0  0 8B F0 
c;
1A0402D 	FF E7 

code-field: docreate
1A0402F 	 0 
   w ainc   w push
1A04030 	 5  4  0  0  0 50 
c;
1A04036 	FF E7 

code-field: dovariable
   w ainc   w push
1A04038 	 5  4  0  0  0 50 
c;
1A0403E 	FF E7 

code-field: dolabel
   w ainc   w push
1A04040 	 5  4  0  0  0 50 
c;
1A04046 	FF E7 

code-field: douser
   [apf] ax mov  ?bswap-ax   up ax add   1push
1A04048 	8B 40  4  1 F8 50 
c;
1A0404E 	FF E7 

code-field: dovalue
   [apf] ax mov  ?bswap-ax   up ax add   0 [ax] ax mov  ?bswap-ax
1A04050 	8B 40  4  1 F8 8B  0 
   1push
1A04057 	50 
c;
1A04058 	FF E7 

code-field: dodefer
1A0405A 	 0  0 
   [apf] ax mov  ?bswap-ax   up ax add   0 [ax] w mov   
1A0405C 	8B 40  4  1 
1A04060 	F8 8B  0 
\ Tail of "next"
\+ rel-t  up ax add   0 [ax] bx mov  up bx add   bx jmp
\- rel-t  0 [w] jmp
1A04063 	FF 20 
end-code

code-field: doconstant
1A04065 	 0  0  0 
   [apf] ax mov  ?bswap-ax   1push
1A04068 	8B 40  4 50 
c;
1A0406C 	FF E7 

code-field: do2constant
1A0406E 	 0  0 
   [apf] dx mov
1A04070 	8B 50  4 
[ifdef] big-endian-t
   dx ax mov  ?bswap-ax  ax dx mov
[then]
   /cf /n + [w] ax mov  ?bswap-ax
1A04073 	8B 40  8 
   2push
1A04076 	52 50 
c;
1A04078 	FF E7 

code-field: dodoes
1A0407A 	 0  0 
   rp adec   ip  0 [rp] mov   ip pop
1A0407C 	83 ED  4 89 
1A04080 	75  0 5E 
   w ainc   w push
1A04083 	 5  4  0  0  0 
1A04088 	50 
c;
1A04089 	FF E7 

:-h place-cf-t  ( action-apf -- )  acf-align-t token,-t  ;-h

:-h code-cf       ( -- )  acf-align-t here-t /token-t + token,-t  ;-h
:-h label-cf      ( -- )  dolabel       place-cf-t  align-t  ;-h
:-h colon-cf      ( -- )  docolon       place-cf-t  ;-h
:-h constant-cf   ( -- )  doconstant    place-cf-t  ;-h
:-h create-cf     ( -- )  docreate      place-cf-t  ;-h
:-h variable-cf   ( -- )  dovariable    place-cf-t  ;-h
:-h user-cf       ( -- )  douser        place-cf-t  ;-h
:-h value-cf      ( -- )  dovalue       place-cf-t  ;-h
:-h defer-cf      ( -- )  dodefer       place-cf-t  ;-h
:-h startdoes     ( -- )  
   meta-asm[  ax ax xchg  ax ax xchg  ax ax xchg  dodoes fw-pa + #) call
   ]meta-asm  ;-h	\ need to pad to 8 bytes for decompiler
\ The forward reference will be resolved later by fix-vocabularies
:-h vocabulary-cf ( -- )  compile-t <vocabulary>  ;-h


\ ---- Run-time words compiled by compiling words.
code isdefer  ( xt -- )
1A0408B 	 0 69 73 64 65 
1A04090 	66 65 72 87  0  0 A0  1 
1A04098 	9C 40 A0  1 
   0 [ip]  ax  mov   ip ainc
1A0409C 	8B  6 83 C6 
1A040A0 	 4 
\+ rel-t  up ax add
   /cf [ax] ax mov  ?bswap-ax  up ax add  \ data address in ax
1A040A1 	8B 40  4  1 F8 
[ifdef] big-endian-t
   ax bx mov  ax pop  ?bswap-ax  ax 0 [bx] mov
[else]
   bx pop
1A040A6 	5B 
\+ rel-t  up bx sub
   bx  0 [ax] mov
1A040A7 	89 
1A040A8 	18 
[then]
c;   
1A040A9 	FF E7 

code isvalue  ( n -- )
1A040AB 	 0 69 73 76 61 
1A040B0 	6C 75 65 87 98 40 A0  1 
1A040B8 	BC 40 A0  1 
   0 [ip]  ax  mov   ip ainc
1A040BC 	8B  6 83 C6 
1A040C0 	 4 
\+ rel-t  up ax add
  /cf [ax] ax mov  ?bswap-ax  up ax add  \ data address in ax
1A040C1 	8B 40  4  1 F8 
[ifdef] big-endian-t
   ax bx mov  ax pop  ?bswap-ax  ax 0 [bx] mov
[else]
   bx pop  bx  0 [ax] mov
1A040C6 	5B 89 
1A040C8 	18 
[then]
c;   
1A040C9 	FF E7 
code isuser  ( n -- )
1A040CB 	 0  0 69 73 75 
1A040D0 	73 65 72 86 B8 40 A0  1 
1A040D8 	DC 40 A0  1 
   0 [ip]  ax  mov   ip ainc
1A040DC 	8B  6 83 C6 
1A040E0 	 4 
\+ rel-t  up ax add
   /cf [ax] ax mov  ?bswap-ax  up ax add  \ data address in ax
1A040E1 	8B 40  4  1 F8 
[ifdef] big-endian-t
   ax bx mov  ax pop  ?bswap-ax  ax 0 [bx] mov
[else]
   bx pop  bx  0 [ax] mov
1A040E6 	5B 89 
1A040E8 	18 
[then]
c;   
1A040E9 	FF E7 
code isconstant  ( n -- )
1A040EB 	 0  0 69 73 63 
1A040F0 	6F 6E 73 74 61 6E 74 8A 
1A040F8 	D8 40 A0  1  0 41 A0  1 
   0 [ip]  bx  mov   ip ainc
1A04100 	8B 1E 83 C6  4 
   ax pop  ?bswap-ax
1A04105 	58 
\+ rel-t up bx add
   ax /cf [bx] mov
1A04106 	89 43 
1A04108 	 4 
c;   
1A04109 	FF E7 
code isvariable  ( n -- )
1A0410B 	 0  0 69 73 76 
1A04110 	61 72 69 61 62 6C 65 8A 
1A04118 	FC 40 A0  1 20 41 A0  1 
   0 [ip]  bx  mov   ip ainc
1A04120 	8B 1E 83 C6  4 
   ax pop  ?bswap-ax  
1A04125 	58 
\+ rel-t up bx add
   ax /cf [bx] mov
1A04126 	89 43 
1A04128 	 4 
c;   
1A04129 	FF E7 

code bswap  (s n1 -- n2 )
1A0412B 	 0  0  0 62 73 
1A04130 	77 61 70 85 1C 41 A0  1 
1A04138 	3C 41 A0  1 
   ax pop
1A0413C 	58 

   \ The 486 can do this in 1 instruction (BSWAP), which the 386 doesn't have
   ax bx mov
1A0413D 	8B D8 
   d# 16 # cl mov	\ shift count
1A0413F 	B1 
1A04140 	10 
   bh bl xchg		\ swap low bytes
1A04141 	86 DF 
   bx cl shl		\ move to high word
1A04143 	D3 E3 
   ax cl shr		\ move high bytes to low word
1A04145 	D3 E8 
   ah al xchg		\ swap them
1A04147 	86 
1A04148 	C4 
   bx ax add		\ merge words
1A04149 	 1 D8 

   1push
1A0414B 	50 
c;
1A0414C 	FF E7 

code (lit)   (s -- n )  ax lods  ?bswap-ax  1push  c;
1A0414E 	28 6C 
1A04150 	69 74 29 85 38 41 A0  1 
1A04158 	5C 41 A0  1 AD 50 FF E7 
code (llit)  (s -- l )  ax lods  ?bswap-ax  1push  c;
1A04160 	 0 28 6C 6C 69 74 29 86 
1A04168 	58 41 A0  1 70 41 A0  1 
1A04170 	AD 50 FF E7 
[ifdef] big-endian-t
code (dlit)  (s -- d )  ax lods  ?bswap-ax  ax  bx mov
			ax lods  ?bswap-ax  1push  bx push  c;
[else]
code (dlit)  (s -- d )  ax lods  ?bswap-ax  1push
1A04174 	 0 28 64 6C 
1A04178 	69 74 29 86 6C 41 A0  1 
1A04180 	84 41 A0  1 AD 50 
			ax lods  ?bswap-ax  1push  c;
1A04186 	AD 50 
1A04188 	FF E7 
[then]

\ Execute a Forth word given a code field address
code execute   (s acf -- )
1A0418A 	 0  0 65 78 65 63 
1A04190 	75 74 65 87 80 41 A0  1 
1A04198 	9C 41 A0  1 
   w pop
1A0419C 	58 
\ Partial tail of "next"
\+ rel-t  0 [ax] bx mov  up bx add  bx jmp
\- rel-t  0 [w] jmp
1A0419D 	FF 20 
end-code

\ execute-ip  This word will call a block of Forth words given the address
\ of the first word.  It's used, for example, in try blocks where the
\ a word calls 'try' and then the words that follow it are called repeatedly.
\ This word, execute-ip, is used to transfer control back to the caller of
\ try and execute the words that follow the call to try.

\ see forth/lib/try.fth for more details.

code execute-ip  (s word-list-ip -- )
1A0419F 	 0 
1A041A0 	 0 65 78 65 63 75 74 65 
1A041A8 	2D 69 70 8A 98 41 A0  1 
1A041B0 	B4 41 A0  1 
   rp  adec
1A041B4 	83 ED  4 
   ip  0 [rp] mov
1A041B7 	89 
1A041B8 	75  0 
   ip  pop
1A041BA 	5E 
c;
1A041BB 	FF E7 

\ High level branch.  The branch offset is compiled in-line.
code branch (s -- )
1A041BD 	62 72 61 
1A041C0 	6E 63 68 86 B0 41 A0  1 
1A041C8 	CC 41 A0  1 
mloclabel bran1
[ifdef] big-endian-t
   0 [ip] ax mov  ?bswap-ax  ax ip add
[else]
   0 [ip] ip add
1A041CC 	 3 36 
[then]
c;
1A041CE 	FF E7 

\ May need to change for 16-bit branch offsets
:-h skipbranch  ( -- )  [ assembler ]-h  ip ainc  ;-h

\ High level conditional branch.
code ?branch (s f -- )  \ Takes the branch if the flag is false
1A041D0 	3F 62 72 61 6E 63 68 87 
1A041D8 	C8 41 A0  1 E0 41 A0  1 
   ax pop   ax ax or   bran1 je   skipbranch
1A041E0 	58  9 C0 74 E7 83 C6  4 
c;
1A041E8 	FF E7 

\ Run time word for loop
code (loop)  (s -- )
1A041EA 	 0  0  0 28 6C 6F 
1A041F0 	6F 70 29 86 DC 41 A0  1 
1A041F8 	FC 41 A0  1 
   1 # ax mov
1A041FC 	B8  1  0  0 
1A04200 	 0 
   ax 0 [rp] add   bran1 jno  3 /n* # rp add   skipbranch
1A04201 	 1 45  0 71 C6 83 C5 
1A04208 	 C 83 C6  4 
c;
1A0420C 	FF E7 

\ Run time word for +loop
code (+loop) (s increment -- )
1A0420E 	 0  0 
1A04210 	28 2B 6C 6F 6F 70 29 87 
1A04218 	F8 41 A0  1 20 42 A0  1 
   ax pop
1A04220 	58 
   ax 0 [rp] add   bran1 jno  3 /n* # rp add   skipbranch
1A04221 	 1 45  0 71 A6 83 C5 
1A04228 	 C 83 C6  4 
c;
1A0422C 	FF E7 

code unloop  (s -- )  3 /n* # rp add   c;
1A0422E 	 0  0 
1A04230 	 0 75 6E 6C 6F 6F 70 86 
1A04238 	1C 42 A0  1 40 42 A0  1 
1A04240 	83 C5  C FF E7 

\ Run time word for ?do
code (?do)  (s l i -- )
1A04245 	 0 28 3F 
1A04248 	64 6F 29 85 3C 42 A0  1 
1A04250 	54 42 A0  1 
   ax pop   bx pop   ax bx cmp  = if  bran1 #) jmp  then
1A04254 	58 5B 39 C3 
1A04258 	75  5 E9 6D FF FF FF 
   rp adec   ip 0 [rp] mov
1A0425F 	83 
1A04260 	ED  4 89 75  0 
   ip ainc  80000000 # bx add   rp adec   bx 0 [rp] mov
1A04265 	83 C6  4 
1A04268 	81 C3  0  0  0 80 83 ED 
1A04270 	 4 89 5D  0 
   bx ax sub                    rp adec   ax 0 [rp] mov
1A04274 	29 D8 83 ED 
1A04278 	 4 89 45  0 
\ ??? how about sp rp xchg  ... dx push bx push ax push  sp rp xchg
c;
1A0427C 	FF E7 

\ Run time word for do
code (do)  (s l i -- )
1A0427E 	 0 28 
1A04280 	64 6F 29 84 50 42 A0  1 
1A04288 	8C 42 A0  1 
   ax pop   bx pop      \ i in ax  l in bx
1A0428C 	58 5B 
   rp adec   ip 0 [rp] mov
1A0428E 	83 ED 
1A04290 	 4 89 75  0 

   ip ainc  80000000 # bx add   rp adec   bx 0 [rp] mov
1A04294 	83 C6  4 81 
1A04298 	C3  0  0  0 80 83 ED  4 
1A042A0 	89 5D  0 
   bx ax sub                    rp adec   ax 0 [rp] mov
1A042A3 	29 D8 83 ED  4 
1A042A8 	89 45  0 
\ ??? how about sp rp xchg  ... dx push bx push ax push  sp rp xchg
c;
1A042AB 	FF E7 
meta

\ Loop index for current do loop
code i  (s -- n )   0 [rp] ax mov   /n [rp] ax add   1push  c;
1A042AD 	 0 69 81 
1A042B0 	88 42 A0  1 B8 42 A0  1 
1A042B8 	8B 45  0  3 45  4 50 FF 
1A042C0 	E7 

\ Loop limit for current do loop
code ilimit  ( -- n )  1 /n* [rp] ax mov  80000000 # ax sub  1push  c;
1A042C1 	69 6C 69 6D 69 74 86 
1A042C8 	B4 42 A0  1 D0 42 A0  1 
1A042D0 	8B 45  4 2D  0  0  0 80 
1A042D8 	50 FF E7 

\ Loop index for next enclosing do loop
code j   (s -- n )  3 /n* [rp] ax mov   4 /n* [rp] ax add   1push  c;
1A042DB 	 0  0  0 6A 81 
1A042E0 	CC 42 A0  1 E8 42 A0  1 
1A042E8 	8B 45  C  3 45 10 50 FF 
1A042F0 	E7 

\ Loop limit for next enclosing do loop
code jlimit  ( -- n )  4 /n* [rp] ax mov  80000000 # ax sub  1push  c;
1A042F1 	6A 6C 69 6D 69 74 86 
1A042F8 	E4 42 A0  1  0 43 A0  1 
1A04300 	8B 45 10 2D  0  0  0 80 
1A04308 	50 FF E7 

code (leave)  (s -- )
1A0430B 	 0 28 6C 65 61 
1A04310 	76 65 29 87 FC 42 A0  1 
1A04318 	1C 43 A0  1 
mloclabel pleave
   2 /n* [rp] ip mov
1A0431C 	8B 75  8 
[ifdef] big-endian-t
   0 [ip] ax mov  ?bswap-ax  ax ip add   
[else]
   0 [ip] ip add  
1A0431F 	 3 
1A04320 	36 
[then]
   3 /n* # rp add
1A04321 	83 C5  C 
c;
1A04324 	FF E7 

code (?leave)  (s f -- )   ax pop   ax ax or   pleave jne   c;
1A04326 	 0 28 
1A04328 	3F 6C 65 61 76 65 29 88 
1A04330 	18 43 A0  1 38 43 A0  1 
1A04338 	58  9 C0 75 DF FF E7 

code (of)  ( selector test -- [ selector ] )
1A0433F 	28 
1A04340 	6F 66 29 84 34 43 A0  1 
1A04348 	4C 43 A0  1 
   bx pop  ax pop   \ Test in bx, Selector in ax
1A0434C 	5B 58 
   ax bx cmp  0= if  skipbranch next  then         \ Skip branch; execute code
1A0434E 	39 C3 
1A04350 	75  5 83 C6  4 FF E7 
   ax push  bran1 #) jmp                           \ Jump to next test
1A04357 	50 
1A04358 	E9 6F FE FF FF 
end-code

\ (endof) is the same as branch, and (endcase) is the same as drop,
\ but redefining them this way makes the decompiler much easier.
code (endof)    (s -- )    bran1 #) jmp  end-code
1A0435D 	 0  0  0 
1A04360 	28 65 6E 64 6F 66 29 87 
1A04368 	48 43 A0  1 70 43 A0  1 
1A04370 	E9 57 FE FF FF 
code (endcase)  (s n -- )  ax pop  c;
1A04375 	 0 28 65 
1A04378 	6E 64 63 61 73 65 29 89 
1A04380 	6C 43 A0  1 88 43 A0  1 
1A04388 	58 FF E7 

\ ($endof) is the same as branch, and ($endcase) is a noop,
\ but redefining them this way makes the decompiler much easier.
\ code ($case)  ( $ -- $ )  c;

code ($endof)    (s -- )    bran1 #) jmp  end-code
1A0438B 	28 24 65 6E 64 
1A04390 	6F 66 29 88 84 43 A0  1 
1A04398 	9C 43 A0  1 E9 2B FE FF 
1A043A0 	FF 
code ($endcase)  (s n -- )  c;
1A043A1 	28 24 65 6E 64 63 61 
1A043A8 	73 65 29 8A 98 43 A0  1 
1A043B0 	B4 43 A0  1 FF E7 

mloclabel yes also assembler   true # ax mov   1push   c;
1A043B6 	B8 FF 
1A043B8 	FF FF FF 50 FF E7 
mloclabel no  also assembler  false # ax mov   1push   c;
1A043BE 	B8  0 
1A043C0 	 0  0  0 50 FF E7 

\ Convert a character to a digit according to the current base
mloclabel fail also assembler  ax ax sub   1push  c;
1A043C6 	29 C0 
1A043C8 	50 FF E7 

code digit  (s char base -- digit true | char false )
1A043CB 	 0  0  0 64 69 
1A043D0 	67 69 74 85 B0 43 A0  1 
1A043D8 	DC 43 A0  1 
  dx pop   ax pop   ax push   ascii 0 # al sub   fail jb
1A043DC 	5A 58 50 2C 
1A043E0 	30 72 E3 
  9 # al cmp   > if
1A043E3 	3C  9 7E  E 
     11 # al cmp   fail jb    \ Bad if > '9' and < 'A'
1A043E7 	3C 
1A043E8 	11 72 DB 
     \ if > 'A', subtract 'A'-'0'-10, otherwise subtract 'a'-'0'-10
     30 # al cmp  > if  27 # al sub  else  7 # al sub  then
1A043EB 	3C 30 7E  4 2C 
1A043F0 	27 EB  2 2C  7 
  then
  dl al cmp   fail jae   al dl mov
1A043F5 	38 D0 73 
1A043F8 	CD 8A D0 
  ax pop   true # ax mov   2push
1A043FB 	58 B8 FF FF FF 
1A04400 	FF 52 50 
c;
1A04403 	FF E7 

\ Copy cnt characters starting at from-addr to to-addr.  Copying is done
\ strictly from low to high addresses, so be careful of overlap between the
\ two buffers.

code cmove  ( src dst cnt -- )  \ Copy from bottom to top
1A04405 	 0 63 6D 
1A04408 	6F 76 65 85 D8 43 A0  1 
1A04410 	14 44 A0  1 
  di dx mov
1A04414 	8B D7 
  cld   ip bx mov   ds ax mov   ax es mov
1A04416 	FC 8B 
1A04418 	DE 8C D8 8E C0 
  cx pop   di pop   ip pop
1A0441D 	59 5F 5E 
  rep   byte movs   bx ip mov
1A04420 	F2 A4 8B F3 
  dx di mov
1A04424 	8B FA 
c;
1A04426 	FF E7 

code cmove>  ( src dst cnt -- )  \ Copy from top to bottom
1A04428 	 0 63 6D 6F 76 65 3E 86 
1A04430 	10 44 A0  1 38 44 A0  1 
  di dx mov
1A04438 	8B D7 
  std   ip bx mov   ds ax mov   ax es mov   cx pop
1A0443A 	FD 8B DE 8C D8 8E 
1A04440 	C0 59 
  cx dec   di pop   ip pop   cx di add   cx ip add   cx inc
1A04442 	49 5F 5E  1 CF  1 
1A04448 	CE 41 
  rep   byte movs   bx ip mov   cld
1A0444A 	F2 A4 8B F3 FC 
  dx di mov
1A0444F 	8B 
1A04450 	FA 
c;
1A04451 	FF E7 


code and  (s n1 n2 -- n3 )   bx pop   ax pop   bx ax and   1push c;
1A04453 	 0 61 6E 64 83 
1A04458 	34 44 A0  1 60 44 A0  1 
1A04460 	5B 58 21 D8 50 FF E7 
code or   (s n1 n2 -- n3 )   bx pop   ax pop   bx ax or    1push c;
1A04467 	 0 
1A04468 	 0 6F 72 82 5C 44 A0  1 
1A04470 	74 44 A0  1 5B 58  9 D8 
1A04478 	50 FF E7 
code xor  (s n1 n2 -- n3 )   bx pop   ax pop   bx ax xor   1push c;
1A0447B 	 0 78 6F 72 83 
1A04480 	70 44 A0  1 88 44 A0  1 
1A04488 	5B 58 31 D8 50 FF E7 

code lshift  (s n1 cnt -- n2 )  cx pop   ax pop   ax cl shl   1push c;
1A0448F 	 0 
1A04490 	 0 6C 73 68 69 66 74 86 
1A04498 	84 44 A0  1 A0 44 A0  1 
1A044A0 	59 58 D3 E0 50 FF E7 
code rshift  (s n1 cnt -- n2 )  cx pop   ax pop   ax cl shr   1push c;
1A044A7 	 0 
1A044A8 	 0 72 73 68 69 66 74 86 
1A044B0 	9C 44 A0  1 B8 44 A0  1 
1A044B8 	59 58 D3 E8 50 FF E7 

code <<   (s n1 cnt -- n2 )  cx pop   ax pop   ax cl shl   1push c;
1A044BF 	 0 
1A044C0 	 0 3C 3C 82 B4 44 A0  1 
1A044C8 	CC 44 A0  1 59 58 D3 E0 
1A044D0 	50 FF E7 
code >>   (s n1 cnt -- n2 )  cx pop   ax pop   ax cl shr   1push c;
1A044D3 	 0  0 3E 3E 82 
1A044D8 	C8 44 A0  1 E0 44 A0  1 
1A044E0 	59 58 D3 E8 50 FF E7 
code >>a  (s n1 cnt -- n2 )  cx pop   ax pop   ax cl sar   1push c;
1A044E7 	 0 
1A044E8 	3E 3E 61 83 DC 44 A0  1 
1A044F0 	F4 44 A0  1 59 58 D3 F8 
1A044F8 	50 FF E7 

code +    (s n1 n2 -- n3 )   bx pop   ax pop   bx ax add   1push c;
1A044FB 	 0  0  0 2B 81 
1A04500 	F0 44 A0  1  8 45 A0  1 
1A04508 	5B 58  1 D8 50 FF E7 
code -    (s n1 n2 -- n3 )   bx pop   ax pop   bx ax sub   1push c;
1A0450F 	 0 
1A04510 	 0  0 2D 81  4 45 A0  1 
1A04518 	1C 45 A0  1 5B 58 29 D8 
1A04520 	50 FF E7 

code invert  (s n1 -- n2 )   ax pop   ax not   1push c;
1A04523 	 0  0 69 6E 76 
1A04528 	65 72 74 86 18 45 A0  1 
1A04530 	34 45 A0  1 58 F7 D0 50 
1A04538 	FF E7 
code negate  (s n1 -- n2 )   ax pop   ax neg   1push c;
1A0453A 	 0  0  0 6E 65 67 
1A04540 	61 74 65 86 30 45 A0  1 
1A04548 	4C 45 A0  1 58 F7 D8 50 
1A04550 	FF E7 

code up@  (s -- addr )  up push  c;
1A04552 	 0  0 75 70 40 83 
1A04558 	48 45 A0  1 60 45 A0  1 
1A04560 	57 FF E7 
code sp@  (s -- addr )  sp push  c;
1A04563 	 0 73 70 40 83 
1A04568 	5C 45 A0  1 70 45 A0  1 
1A04570 	54 FF E7 
code rp@  (s -- addr )  rp push  c;
1A04573 	 0 72 70 40 83 
1A04578 	6C 45 A0  1 80 45 A0  1 
1A04580 	55 FF E7 
code up!  (s addr -- )  up pop   c;
1A04583 	 0 75 70 21 83 
1A04588 	7C 45 A0  1 90 45 A0  1 
1A04590 	5F FF E7 
code sp!  (s addr -- )  sp pop   c;
1A04593 	 0 73 70 21 83 
1A04598 	8C 45 A0  1 A0 45 A0  1 
1A045A0 	5C FF E7 
code rp!  (s addr -- )  rp pop   c;
1A045A3 	 0 72 70 21 83 
1A045A8 	9C 45 A0  1 B0 45 A0  1 
1A045B0 	5D FF E7 
code >r   (s n -- )     ax pop   rp adec   ax 0 [rp] mov   c;
1A045B3 	 0  0 3E 72 82 
1A045B8 	AC 45 A0  1 C0 45 A0  1 
1A045C0 	58 83 ED  4 89 45  0 FF 
1A045C8 	E7 
code r>   (s -- n )     0 [rp] ax mov   rp ainc   1push c;
1A045C9 	72 3E 82 BC 45 A0  1 
1A045D0 	D4 45 A0  1 8B 45  0 83 
1A045D8 	C5  4 50 FF E7 
code r@   (s -- n )     0 [rp] ax mov             1push c;
1A045DD 	72 40 82 
1A045E0 	D0 45 A0  1 E8 45 A0  1 
1A045E8 	8B 45  0 50 FF E7 
code 2>r  (s n1 n2 -- )  8 #  rp  sub   0 [rp] pop   4 [rp] pop  c;
1A045EE 	 0  0 
1A045F0 	32 3E 72 83 E4 45 A0  1 
1A045F8 	FC 45 A0  1 83 ED  8 8F 
1A04600 	45  0 8F 45  4 FF E7 
code 2r>  (s -- n1 n2 )  4 [rp] push  0 [rp] push   8 #  rp  add  c;
1A04607 	 0 
1A04608 	32 72 3E 83 F8 45 A0  1 
1A04610 	14 46 A0  1 FF 75  4 FF 
1A04618 	75  0 83 C5  8 FF E7 
code 2r@  (s -- n1 n2 )  4 [rp] push  0 [rp] push   c;
1A0461F 	 0 
1A04620 	32 72 40 83 10 46 A0  1 
1A04628 	2C 46 A0  1 FF 75  4 FF 
1A04630 	75  0 FF E7 

code exit (s -- )       0 [rp] ip mov   rp ainc  c;
1A04634 	 0  0  0 65 
1A04638 	78 69 74 84 28 46 A0  1 
1A04640 	44 46 A0  1 8B 75  0 83 
1A04648 	C5  4 FF E7 
code unnest (s -- )     0 [rp] ip mov   rp ainc  c;
1A0464C 	 0 75 6E 6E 
1A04650 	65 73 74 86 40 46 A0  1 
1A04658 	5C 46 A0  1 8B 75  0 83 
1A04660 	C5  4 FF E7 

code >ip  (s n -- )     ax pop   rp adec   ax 0 [rp] mov   c;
1A04664 	3E 69 70 83 
1A04668 	58 46 A0  1 70 46 A0  1 
1A04670 	58 83 ED  4 89 45  0 FF 
1A04678 	E7 
code ip>  (s -- n )     0 [rp] ax mov   rp ainc   1push c;
1A04679 	 0  0  0 69 70 3E 83 
1A04680 	6C 46 A0  1 88 46 A0  1 
1A04688 	8B 45  0 83 C5  4 50 FF 
1A04690 	E7 
code ip@  (s -- n )     0 [rp] ax mov             1push c;
1A04691 	 0  0  0 69 70 40 83 
1A04698 	84 46 A0  1 A0 46 A0  1 
1A046A0 	8B 45  0 50 FF E7 

/token constant /token
1A046A6 	 0  0 
1A046A8 	 0 2F 74 6F 6B 65 6E 86 
1A046B0 	9C 46 A0  1 68 40 A0  1 
1A046B8 	 4  0  0  0 

: ip>token  ( ip -- token-adr )  /token -  ;
1A046BC 	 0  0  0 69 
1A046C0 	70 3E 74 6F 6B 65 6E 88 
1A046C8 	B4 46 A0  1 20 40 A0  1 
1A046D0 	B4 46 A0  1 18 45 A0  1 
1A046D8 	58 46 A0  1 

code tuck  (s n1 n2 -- n2 n1 n2 )
1A046DC 	 0  0  0 74 
1A046E0 	75 63 6B 84 CC 46 A0  1 
1A046E8 	EC 46 A0  1 
   ax pop   dx pop   ax push   2push
1A046EC 	58 5A 50 52 
1A046F0 	50 
c;
1A046F1 	FF E7 
code nip   (s n1 n2 -- n2 )   ax pop   dx pop   1push c;
1A046F3 	 0 6E 69 70 83 
1A046F8 	E8 46 A0  1  0 47 A0  1 
1A04700 	58 5A 50 FF E7 
code flip  (s w1 -- w2 )   ax pop   ah al xchg   1push c;
1A04705 	 0  0 66 
1A04708 	6C 69 70 84 FC 46 A0  1 
1A04710 	14 47 A0  1 58 86 C4 50 
1A04718 	FF E7 

assembler definitions
:-h leaveflag  (s condition -- )
\ macro to assemble code to leave a flag on the stack
   if
      true  # ax mov
   else
      false # ax mov
   then
   1push
;-h
:-h unary-test  (s condition -- )  ax pop  ax ax or   ( cond ) leaveflag   ;-h
meta definitions


code 0=  (s n -- f )  0=  unary-test  c;
1A0471A 	 0  0  0 30 3D 82 
1A04720 	10 47 A0  1 28 47 A0  1 
1A04728 	58  9 C0 75  7 B8 FF FF 
1A04730 	FF FF EB  5 B8  0  0  0 
1A04738 	 0 50 FF E7 
code 0<> (s n -- f )  0<> unary-test  c;
1A0473C 	30 3C 3E 83 
1A04740 	24 47 A0  1 48 47 A0  1 
1A04748 	58  9 C0 74  7 B8 FF FF 
1A04750 	FF FF EB  5 B8  0  0  0 
1A04758 	 0 50 FF E7 
code 0<  (s n -- f )  0<  unary-test  c;
1A0475C 	 0 30 3C 82 
1A04760 	44 47 A0  1 68 47 A0  1 
1A04768 	58  9 C0 79  7 B8 FF FF 
1A04770 	FF FF EB  5 B8  0  0  0 
1A04778 	 0 50 FF E7 
code 0<= (s n -- f )  <=  unary-test  c;
1A0477C 	30 3C 3D 83 
1A04780 	64 47 A0  1 88 47 A0  1 
1A04788 	58  9 C0 7F  7 B8 FF FF 
1A04790 	FF FF EB  5 B8  0  0  0 
1A04798 	 0 50 FF E7 
code 0>  (s n -- f )  >   unary-test  c;
1A0479C 	 0 30 3E 82 
1A047A0 	84 47 A0  1 A8 47 A0  1 
1A047A8 	58  9 C0 7E  7 B8 FF FF 
1A047B0 	FF FF EB  5 B8  0  0  0 
1A047B8 	 0 50 FF E7 
code 0>= (s n -- f )  0>= unary-test  c;
1A047BC 	30 3E 3D 83 
1A047C0 	A4 47 A0  1 C8 47 A0  1 
1A047C8 	58  9 C0 78  7 B8 FF FF 
1A047D0 	FF FF EB  5 B8  0  0  0 
1A047D8 	 0 50 FF E7 

assembler definitions
:-h compare
   ax pop  bx pop  ax bx cmp
   leaveflag
;-h
meta definitions

code <   (s n1 n2 -- f )  <   compare c;
1A047DC 	 0  0 3C 81 
1A047E0 	C4 47 A0  1 E8 47 A0  1 
1A047E8 	58 5B 39 C3 7D  7 B8 FF 
1A047F0 	FF FF FF EB  5 B8  0  0 
1A047F8 	 0  0 50 FF E7 
code >   (s n1 n2 -- f )  >   compare c;
1A047FD 	 0 3E 81 
1A04800 	E4 47 A0  1  8 48 A0  1 
1A04808 	58 5B 39 C3 7E  7 B8 FF 
1A04810 	FF FF FF EB  5 B8  0  0 
1A04818 	 0  0 50 FF E7 
code =   (s n1 n2 -- f )  0=  compare c;
1A0481D 	 0 3D 81 
1A04820 	 4 48 A0  1 28 48 A0  1 
1A04828 	58 5B 39 C3 75  7 B8 FF 
1A04830 	FF FF FF EB  5 B8  0  0 
1A04838 	 0  0 50 FF E7 
code <>  (s n1 n2 -- f )  <>  compare c;
1A0483D 	3C 3E 82 
1A04840 	24 48 A0  1 48 48 A0  1 
1A04848 	58 5B 39 C3 74  7 B8 FF 
1A04850 	FF FF FF EB  5 B8  0  0 
1A04858 	 0  0 50 FF E7 
code u>  (s n1 n2 -- f )  u>  compare c;
1A0485D 	75 3E 82 
1A04860 	44 48 A0  1 68 48 A0  1 
1A04868 	58 5B 39 C3 76  7 B8 FF 
1A04870 	FF FF FF EB  5 B8  0  0 
1A04878 	 0  0 50 FF E7 
code u<= (s n1 n2 -- f )  u<= compare c;
1A0487D 	 0  0  0 
1A04880 	75 3C 3D 83 64 48 A0  1 
1A04888 	8C 48 A0  1 58 5B 39 C3 
1A04890 	77  7 B8 FF FF FF FF EB 
1A04898 	 5 B8  0  0  0  0 50 FF 
1A048A0 	E7 
code u<  (s n1 n2 -- f )  u<  compare c;
1A048A1 	75 3C 82 88 48 A0  1 
1A048A8 	AC 48 A0  1 58 5B 39 C3 
1A048B0 	73  7 B8 FF FF FF FF EB 
1A048B8 	 5 B8  0  0  0  0 50 FF 
1A048C0 	E7 
code u>= (s n1 n2 -- f )  u>= compare c;
1A048C1 	 0  0  0 75 3E 3D 83 
1A048C8 	A8 48 A0  1 D0 48 A0  1 
1A048D0 	58 5B 39 C3 72  7 B8 FF 
1A048D8 	FF FF FF EB  5 B8  0  0 
1A048E0 	 0  0 50 FF E7 
code >=  (s n1 n2 -- f )  >=  compare c;
1A048E5 	3E 3D 82 
1A048E8 	CC 48 A0  1 F0 48 A0  1 
1A048F0 	58 5B 39 C3 7C  7 B8 FF 
1A048F8 	FF FF FF EB  5 B8  0  0 
1A04900 	 0  0 50 FF E7 
code <=  (s n1 n2 -- f )  <=  compare c;
1A04905 	3C 3D 82 
1A04908 	EC 48 A0  1 10 49 A0  1 
1A04910 	58 5B 39 C3 7F  7 B8 FF 
1A04918 	FF FF FF EB  5 B8  0  0 
1A04920 	 0  0 50 FF E7 


code drop (s n -- )      ax pop    c;
1A04925 	 0  0 64 
1A04928 	72 6F 70 84  C 49 A0  1 
1A04930 	34 49 A0  1 58 FF E7 
code dup  (s n -- n n )  ax pop   ax push  1push c;
1A04937 	 0 
1A04938 	64 75 70 83 30 49 A0  1 
1A04940 	44 49 A0  1 58 50 50 FF 
1A04948 	E7 
code over (s n1 n2 -- n1 n2 n1 )  dx pop   ax pop   ax push  2push c;
1A04949 	 0  0 6F 76 65 72 84 
1A04950 	40 49 A0  1 58 49 A0  1 
1A04958 	5A 58 50 52 50 FF E7 
code swap (s n1 n2 -- n2 n1 )     dx pop   ax pop   2push c;
1A0495F 	73 
1A04960 	77 61 70 84 54 49 A0  1 
1A04968 	6C 49 A0  1 5A 58 52 50 
1A04970 	FF E7 
code rot  (s n1 n2 n3 -- n2 n3 n1 )  dx pop  bx pop  ax pop  bx push  2push c;
1A04972 	 0  0 72 6F 74 83 
1A04978 	68 49 A0  1 80 49 A0  1 
1A04980 	5A 5B 58 53 52 50 FF E7 
code -rot (s n1 n2 n3 -- n3 n1 n2 )  bx pop  ax pop  dx pop  bx push  2push c;
1A04988 	 0  0  0 2D 72 6F 74 84 
1A04990 	7C 49 A0  1 98 49 A0  1 
1A04998 	5B 58 5A 53 52 50 FF E7 
code 2drop  (s d -- )  ax pop  ax pop  c;
1A049A0 	 0  0 32 64 72 6F 70 85 
1A049A8 	94 49 A0  1 B0 49 A0  1 
1A049B0 	58 58 FF E7 
code 2dup   (s d -- d d )    ax pop   dx pop   dx push   ax push   2push c;
1A049B4 	 0  0  0 32 
1A049B8 	64 75 70 84 AC 49 A0  1 
1A049C0 	C4 49 A0  1 58 5A 52 50 
1A049C8 	52 50 FF E7 
code 2over  (s d1 d2 -- d1 d2 d1 )
1A049CC 	 0  0 32 6F 
1A049D0 	76 65 72 85 C0 49 A0  1 
1A049D8 	DC 49 A0  1 
   cx pop   bx pop   ax pop   dx pop   dx push   ax push
1A049DC 	59 5B 58 5A 
1A049E0 	52 50 
   bx push  cx push  2push
1A049E2 	53 51 52 50 
c;
1A049E6 	FF E7 
code 2swap  (s d1 d2 -- d2 d1 )
1A049E8 	 0  0 32 73 77 61 70 85 
1A049F0 	D8 49 A0  1 F8 49 A0  1 
   cx pop   bx pop   ax pop   dx pop
1A049F8 	59 5B 58 5A 
   bx push  cx push  2push
1A049FC 	53 51 52 50 
c;
1A04A00 	FF E7 
\ ??? Here is one of the few places where we could use the scaled indexing mode
code pick   (s nm ... n1 n0 k -- nm ... n2 n0 nk )
1A04A02 	 0 70 69 63 6B 84 
1A04A08 	F4 49 A0  1 10 4A A0  1 
   bx pop   bx shl  bx shl  sp bx add   0 [bx] ax mov   1push
1A04A10 	5B D1 E3 D1 E3  1 E3 8B 
1A04A18 	 3 50 
c;  
1A04A1A 	FF E7 
 

: abs   (s n1 -- n2 )  dup 0<  if  negate  then   ;
1A04A1C 	61 62 73 83 
1A04A20 	 C 4A A0  1 20 40 A0  1 
1A04A28 	40 49 A0  1 64 47 A0  1 
1A04A30 	DC 41 A0  1  8  0  0  0 
1A04A38 	48 45 A0  1 58 46 A0  1 

: umin (s u1 u2 -- u3 )  2dup u>  if  swap  then  drop  ;
1A04A40 	 0  0  0 75 6D 69 6E 84 
1A04A48 	24 4A A0  1 20 40 A0  1 
1A04A50 	C0 49 A0  1 64 48 A0  1 
1A04A58 	DC 41 A0  1  8  0  0  0 
1A04A60 	68 49 A0  1 30 49 A0  1 
1A04A68 	58 46 A0  1 
: min  (s n1 n2 -- n3 )  2dup  >  if  swap  then  drop  ;
1A04A6C 	6D 69 6E 83 
1A04A70 	4C 4A A0  1 20 40 A0  1 
1A04A78 	C0 49 A0  1  4 48 A0  1 
1A04A80 	DC 41 A0  1  8  0  0  0 
1A04A88 	68 49 A0  1 30 49 A0  1 
1A04A90 	58 46 A0  1 
: max  (s n1 n2 -- n3 )  2dup  <  if  swap  then  drop  ;
1A04A94 	6D 61 78 83 
1A04A98 	74 4A A0  1 20 40 A0  1 
1A04AA0 	C0 49 A0  1 E4 47 A0  1 
1A04AA8 	DC 41 A0  1  8  0  0  0 
1A04AB0 	68 49 A0  1 30 49 A0  1 
1A04AB8 	58 46 A0  1 
: umax (s u1 u2 -- u3 )  2dup u<  if  swap  then  drop  ;
1A04ABC 	 0  0  0 75 
1A04AC0 	6D 61 78 84 9C 4A A0  1 
1A04AC8 	20 40 A0  1 C0 49 A0  1 
1A04AD0 	A8 48 A0  1 DC 41 A0  1 
1A04AD8 	 8  0  0  0 68 49 A0  1 
1A04AE0 	30 49 A0  1 58 46 A0  1 

: move   ( from to len -- )
1A04AE8 	 0  0  0 6D 6F 76 65 84 
1A04AF0 	C8 4A A0  1 20 40 A0  1 
   -rot   2dup u< if   rot cmove>   else   rot cmove   then
1A04AF8 	94 49 A0  1 C0 49 A0  1 
1A04B00 	A8 48 A0  1 DC 41 A0  1 
1A04B08 	14  0  0  0 7C 49 A0  1 
1A04B10 	34 44 A0  1 C8 41 A0  1 
1A04B18 	 C  0  0  0 7C 49 A0  1 
1A04B20 	10 44 A0  1 
;
1A04B24 	58 46 A0  1 

code 1+  (s n1 -- n2 )  ax pop   ax inc            1push c;
1A04B28 	 0 31 2B 82 F4 4A A0  1 
1A04B30 	34 4B A0  1 58 40 50 FF 
1A04B38 	E7 
code 2+  (s n1 -- n2 )  ax pop   ax inc   ax inc   1push c;
1A04B39 	32 2B 82 30 4B A0  1 
1A04B40 	44 4B A0  1 58 40 40 50 
1A04B48 	FF E7 
code 1-  (s n1 -- n2 )  ax pop   ax dec            1push c;
1A04B4A 	 0  0  0 31 2D 82 
1A04B50 	40 4B A0  1 58 4B A0  1 
1A04B58 	58 48 50 FF E7 
code 2-  (s n1 -- n2 )  ax pop   ax dec   ax dec   1push c;
1A04B5D 	32 2D 82 
1A04B60 	54 4B A0  1 68 4B A0  1 
1A04B68 	58 48 48 50 FF E7 

code 2/  (s n1 -- n2 )  ax pop   ax sar            1push c;
1A04B6E 	 0  0 
1A04B70 	 0 32 2F 82 64 4B A0  1 
1A04B78 	7C 4B A0  1 58 D1 F8 50 
1A04B80 	FF E7 
code u2/ (s n1 -- n2 )  ax pop   ax shr            1push c;
1A04B82 	 0  0 75 32 2F 83 
1A04B88 	78 4B A0  1 90 4B A0  1 
1A04B90 	58 D1 E8 50 FF E7 
code 2*  (s n1 -- n2 )  ax pop   ax shl            1push c;
1A04B96 	 0  0 
1A04B98 	 0 32 2A 82 8C 4B A0  1 
1A04BA0 	A4 4B A0  1 58 D1 E0 50 
1A04BA8 	FF E7 
code 4*  (s n1 -- n2 )  ax pop   ax shl   ax shl   1push c;
1A04BAA 	 0  0  0 34 2A 82 
1A04BB0 	A0 4B A0  1 B8 4B A0  1 
1A04BB8 	58 D1 E0 D1 E0 50 FF E7 
code 8*  (s n1 -- n2 )  ax pop   ax shl   ax shl   ax shl   1push c;
1A04BC0 	 0 38 2A 82 B4 4B A0  1 
1A04BC8 	CC 4B A0  1 58 D1 E0 D1 
1A04BD0 	E0 D1 E0 50 FF E7 

code on  (s addr -- )   bx pop   true # 0 [bx] mov   c;
1A04BD6 	 0  0 
1A04BD8 	 0 6F 6E 82 C8 4B A0  1 
1A04BE0 	E4 4B A0  1 5B C7  3 FF 
1A04BE8 	FF FF FF FF E7 
code off (s addr -- )   bx pop  false # 0 [bx] mov   c;
1A04BED 	 0  0  0 
1A04BF0 	6F 66 66 83 E0 4B A0  1 
1A04BF8 	FC 4B A0  1 5B C7  3  0 
1A04C00 	 0  0  0 FF E7 

[ifdef] big-endian-t
: +! (s n addr -- )  tuck @ + swap !  ;

\ requires alignment on a word boundary

code d@     (s addr -- n )   bx pop   0 [bx] push   4 [bx] push  c;
code le-@   (s addr -- n )   bx pop   0 [bx] push   c;
code le-l@  (s addr -- l )   bx pop   0 [bx] push   c;
code @      (s addr -- n )   bx pop   0 [bx] ax mov  ?bswap-ax  1push   c;
code l@     (s addr -- n )   bx pop   0 [bx] ax mov  ?bswap-ax  1push   c;
code le-w@  (s addr -- w )  bx pop   ax ax sub   op: 0 [bx] ax mov   1push  c;
code w@  (s addr -- w )
   bx pop   ax ax sub   op: 0 [bx] ax mov   ah al xchg  1push
c;
code <w@  (s addr -- sw )
   bx pop   ax ax sub   op: 0 [bx] ax mov   ah al xchg  cwde  1push
c;
code c@  (s addr -- c )   bx pop   ax ax sub   0 [bx] al mov  1push c;

: unaligned-@   (s addr -- n )  @  ;
: unaligned-l@  (s addr -- l )  l@ ;
: unaligned-w@  (s addr -- w )  w@  ;

\ 16-bit token version doesn't require alignment on a word boundary
code le-!   (s n addr -- )   bx pop   0 [bx] pop  c;
code le-l!  (s l addr -- )   bx pop   0 [bx] pop  c;

code !      (s n addr -- )   dx pop   ax pop  ?bswap-ax  ax 0 [dx] mov  c;
code d!     (s low high addr -- )  
   dx pop   ax pop  ?bswap-ax  ax 4 [dx] mov  ax pop  ?bswap-ax  ax 0 [dx] mov
c;
code l!     (s n addr -- )   dx pop   ax pop  ?bswap-ax  ax 0 [dx] mov  c;
code le-w!  (s w addr -- )  bx pop   ax pop  op: ax 0 [bx] mov  c;
code w!  (s w addr -- )
   bx pop   ax pop  ah al xchg  op: ax 0 [bx] mov
c;


code c!  (s c addr -- )   bx pop   ax pop       al 0 [bx] mov   c;
code le-2@  (s addr -- d )   bx pop   4 [bx] dx mov  0 [bx] ax mov  2push c;
: 2@  (s addr -- d )  le-2@  swap bswap swap bswap  ;
code le-2!  (s d addr -- )   bx pop   0 [bx] pop   4 [bx] pop   c;
: 2!  (s addr -- d )  >r  swap bswap swap bswap  r> le-2!  ;

: unaligned-!   (s n addr -- )   !  ;
: unaligned-l!  (s n addr -- )   !  ;
: unaligned-w!  (s w addr -- )   w!  ;

[else]
code +! (s n addr -- )  bx pop   ax pop   ax 0 [bx] add   c;
1A04C05 	2B 21 82 
1A04C08 	F8 4B A0  1 10 4C A0  1 
1A04C10 	5B 58  1  3 FF E7 

\ requires alignment on a word boundary
code d@     (s addr -- n )   bx pop   0 [bx] push   4 [bx] push  c;
1A04C16 	 0  0 
1A04C18 	 0 64 40 82  C 4C A0  1 
1A04C20 	24 4C A0  1 5B FF 33 FF 
1A04C28 	73  4 FF E7 
code le-@   (s addr -- n )   bx pop   0 [bx] push   c;
1A04C2C 	 0  0  0 6C 
1A04C30 	65 2D 40 84 20 4C A0  1 
1A04C38 	3C 4C A0  1 5B FF 33 FF 
1A04C40 	E7 
code le-l@  (s addr -- l )   bx pop   0 [bx] push   c;
1A04C41 	 0 6C 65 2D 6C 40 85 
1A04C48 	38 4C A0  1 50 4C A0  1 
1A04C50 	5B FF 33 FF E7 
code @   (s addr -- n )  bx pop   0 [bx] push   c;
1A04C55 	 0 40 81 
1A04C58 	4C 4C A0  1 60 4C A0  1 
1A04C60 	5B FF 33 FF E7 
code l@  (s addr -- l )  bx pop   0 [bx] push   c;
1A04C65 	6C 40 82 
1A04C68 	5C 4C A0  1 70 4C A0  1 
1A04C70 	5B FF 33 FF E7 
code le-w@  (s addr -- w )  bx pop   ax ax sub   op: 0 [bx] ax mov   1push  c;
1A04C75 	 0 6C 65 
1A04C78 	2D 77 40 85 6C 4C A0  1 
1A04C80 	84 4C A0  1 5B 29 C0 66 
1A04C88 	8B  3 50 FF E7 
code w@  (s addr -- w )  bx pop   ax ax sub   op: 0 [bx] ax mov   1push c;
1A04C8D 	77 40 82 
1A04C90 	80 4C A0  1 98 4C A0  1 
1A04C98 	5B 29 C0 66 8B  3 50 FF 
1A04CA0 	E7 
code <w@ (s addr -- w )  bx pop   ax ax sub   op: 0 [bx] ax mov  cwde  1push c;
1A04CA1 	 0  0  0 3C 77 40 83 
1A04CA8 	94 4C A0  1 B0 4C A0  1 
1A04CB0 	5B 29 C0 66 8B  3 98 50 
1A04CB8 	FF E7 
code c@  (s addr -- c )  bx pop   ax ax sub   0 [bx] al mov  1push c;
1A04CBA 	 0  0  0 63 40 82 
1A04CC0 	AC 4C A0  1 C8 4C A0  1 
1A04CC8 	5B 29 C0 8A  3 50 FF E7 

code unaligned-@   (s addr -- n )   bx pop   0 [bx] push   c;
1A04CD0 	75 6E 61 6C 69 67 6E 65 
1A04CD8 	64 2D 40 8B C4 4C A0  1 
1A04CE0 	E4 4C A0  1 5B FF 33 FF 
1A04CE8 	E7 
code unaligned-l@  (s addr -- l )   bx pop   0 [bx] push   c;
1A04CE9 	 0  0 75 6E 61 6C 69 
1A04CF0 	67 6E 65 64 2D 6C 40 8C 
1A04CF8 	E0 4C A0  1  0 4D A0  1 
1A04D00 	5B FF 33 FF E7 
code unaligned-w@  (s addr -- w )   bx pop   ax ax sub   op: 0 [bx] ax mov   1push c;
1A04D05 	 0  0 75 
1A04D08 	6E 61 6C 69 67 6E 65 64 
1A04D10 	2D 77 40 8C FC 4C A0  1 
1A04D18 	1C 4D A0  1 5B 29 C0 66 
1A04D20 	8B  3 50 FF E7 

\ 16-bit token version doesn't require alignment on a word boundary
code le-!   (s n addr -- )   bx pop   0 [bx] pop  c;
1A04D25 	 0  0 6C 
1A04D28 	65 2D 21 84 18 4D A0  1 
1A04D30 	34 4D A0  1 5B 8F  3 FF 
1A04D38 	E7 
code le-l!  (s l addr -- )   bx pop   0 [bx] pop  c;
1A04D39 	 0 6C 65 2D 6C 21 85 
1A04D40 	30 4D A0  1 48 4D A0  1 
1A04D48 	5B 8F  3 FF E7 
code !   (s n addr -- )   bx pop   0 [bx] pop   c;
1A04D4D 	 0 21 81 
1A04D50 	44 4D A0  1 58 4D A0  1 
1A04D58 	5B 8F  3 FF E7 
code d!     (s low high addr -- )
1A04D5D 	64 21 82 
1A04D60 	54 4D A0  1 68 4D A0  1 
   dx pop   ax pop  ax 4 [dx] mov  ax pop  ax 0 [dx] mov
1A04D68 	5A 58 89 42  4 58 89  2 
c;
1A04D70 	FF E7 
code l!  (s l addr -- )   bx pop   0 [bx] pop   c;
1A04D72 	 0  0  0 6C 21 82 
1A04D78 	64 4D A0  1 80 4D A0  1 
1A04D80 	5B 8F  3 FF E7 
code le-w!  (s w addr -- )  bx pop   ax pop  op: ax 0 [bx] mov  c;
1A04D85 	 0 6C 65 
1A04D88 	2D 77 21 85 7C 4D A0  1 
1A04D90 	94 4D A0  1 5B 58 66 89 
1A04D98 	 3 FF E7 
code w!  (s w addr -- )   bx pop   ax pop   op: ax 0 [bx] mov   c;
1A04D9B 	 0  0 77 21 82 
1A04DA0 	90 4D A0  1 A8 4D A0  1 
1A04DA8 	5B 58 66 89  3 FF E7 
code c!  (s c addr -- )   bx pop   ax pop       al 0 [bx] mov   c;
1A04DAF 	 0 
1A04DB0 	 0 63 21 82 A4 4D A0  1 
1A04DB8 	BC 4D A0  1 5B 58 88  3 
1A04DC0 	FF E7 
code 2@  (s addr -- d )   bx pop   4 [bx] dx mov  0 [bx] ax mov  2push c;
1A04DC2 	 0  0  0 32 40 82 
1A04DC8 	B8 4D A0  1 D0 4D A0  1 
1A04DD0 	5B 8B 53  4 8B  3 52 50 
1A04DD8 	FF E7 
code 2!  (s d addr -- )   bx pop   0 [bx] pop   4 [bx] pop   c;
1A04DDA 	 0  0  0 32 21 82 
1A04DE0 	CC 4D A0  1 E8 4D A0  1 
1A04DE8 	5B 8F  3 8F 43  4 FF E7 

code unaligned-d!  (s d addr -- )   bx pop   4 [bx] pop   0 [bx] pop   c;
1A04DF0 	 0  0  0 75 6E 61 6C 69 
1A04DF8 	67 6E 65 64 2D 64 21 8C 
1A04E00 	E4 4D A0  1  8 4E A0  1 
1A04E08 	5B 8F 43  4 8F  3 FF E7 
code unaligned-!   (s n addr -- )   bx pop   0 [bx] pop   c;
1A04E10 	75 6E 61 6C 69 67 6E 65 
1A04E18 	64 2D 21 8B  4 4E A0  1 
1A04E20 	24 4E A0  1 5B 8F  3 FF 
1A04E28 	E7 
code unaligned-l!  (s n addr -- )   bx pop   0 [bx] pop   c;
1A04E29 	 0  0 75 6E 61 6C 69 
1A04E30 	67 6E 65 64 2D 6C 21 8C 
1A04E38 	20 4E A0  1 40 4E A0  1 
1A04E40 	5B 8F  3 FF E7 
code unaligned-w!  (s w addr -- )   bx pop   ax pop   op: ax 0 [bx] mov   c;
1A04E45 	 0  0 75 
1A04E48 	6E 61 6C 69 67 6E 65 64 
1A04E50 	2D 77 21 8C 3C 4E A0  1 
1A04E58 	5C 4E A0  1 5B 58 66 89 
1A04E60 	 3 FF E7 
[then]

: instruction!  (s n adr -- )  !  ;
1A04E63 	69 6E 73 74 72 
1A04E68 	75 63 74 69 6F 6E 21 8C 
1A04E70 	58 4E A0  1 20 40 A0  1 
1A04E78 	54 4D A0  1 58 46 A0  1 

code fill  (s start-addr count char -- )
1A04E80 	 0  0  0 66 69 6C 6C 84 
1A04E88 	74 4E A0  1 90 4E A0  1 
   di dx mov
1A04E90 	8B D7 
   cld   ds ax mov   ax es mov   ax pop   cx pop   di pop
1A04E92 	FC 8C D8 8E C0 58 
1A04E98 	59 5F 
   rep   al stos
1A04E9A 	F2 AA 
   dx di mov
1A04E9C 	8B FA 
c;
1A04E9E 	FF E7 

code wfill  (s start-addr count char -- )
1A04EA0 	 0  0 77 66 69 6C 6C 85 
1A04EA8 	8C 4E A0  1 B0 4E A0  1 
   di dx mov
1A04EB0 	8B D7 
   cld   ds ax mov   ax es mov   ax pop   cx pop  1 # cx shr  di pop
1A04EB2 	FC 8C D8 8E C0 58 
1A04EB8 	59 C1 E9  1 5F 
   rep   ax op: stos
1A04EBD 	F2 66 AB 
   dx di mov
1A04EC0 	8B FA 
c;
1A04EC2 	FF E7 

code lfill  (s start-addr count char -- )
1A04EC4 	 0  0 6C 66 
1A04EC8 	69 6C 6C 85 AC 4E A0  1 
1A04ED0 	D4 4E A0  1 
   di dx mov
1A04ED4 	8B D7 
   cld   ds ax mov   ax es mov   ax pop   cx pop  2 # cx shr  di pop
1A04ED6 	FC 8C 
1A04ED8 	D8 8E C0 58 59 C1 E9  2 
1A04EE0 	5F 
   rep   ax stos
1A04EE1 	F2 AB 
   dx di mov
1A04EE3 	8B FA 
c;
1A04EE5 	FF E7 

\ Skip initial occurrences of bvalue, returning the residual length
code bskip  ( adr len bvalue -- residue )
1A04EE7 	 0 
1A04EE8 	 0  0 62 73 6B 69 70 85 
1A04EF0 	D0 4E A0  1 F8 4E A0  1 
   di dx mov
1A04EF8 	8B D7 
   ax pop         \ BX: compare value
1A04EFA 	58 
   cx pop         \ CX: Length
1A04EFB 	59 
   di pop         \ SI: address
1A04EFC 	5F 
   cld  repz byte scas
1A04EFD 	FC F3 AE 
   <>  if  cx inc  then
1A04F00 	74  1 41 
   dx di mov
1A04F03 	8B FA 
   cx push
1A04F05 	51 
c;
1A04F06 	FF E7 

\ Skip initial occurrences of lvalue, returning the residual length
code lskip  ( adr len lvalue -- residue )
1A04F08 	 0  0 6C 73 6B 69 70 85 
1A04F10 	F4 4E A0  1 18 4F A0  1 
   di dx mov
1A04F18 	8B D7 
   ax pop         \ BX: compare value
1A04F1A 	58 
   cx pop         \ CX: Length
1A04F1B 	59 
   2 # cx shr     \ Convert CX to longword count
1A04F1C 	C1 E9  2 
   di pop         \ SI: address
1A04F1F 	5F 
   cld  repz scas
1A04F20 	FC F3 AF 
   <>  if  cx inc  then
1A04F23 	74  1 41 
   dx di mov
1A04F26 	8B FA 
   2 # cx shl  cx push
1A04F28 	C1 E1  2 51 
c;
1A04F2C 	FF E7 

\ Find the first occurence of bvalue, returning the residual string
code bscan  ( adr1 len1 char -- adr' len' )
1A04F2E 	62 73 
1A04F30 	63 61 6E 85 14 4F A0  1 
1A04F38 	3C 4F A0  1 
   si dx mov
1A04F3C 	8B D6 
   cld
1A04F3E 	FC 
   bx pop                  \ bx: char
1A04F3F 	5B 
   cx pop                  \ cx: count
1A04F40 	59 
   si pop                  \ si: adr
1A04F41 	5E 
   cx cx or  0<>  if
1A04F42 	 9 C9 74  F 
      begin
         al lods
1A04F46 	AC 
         bl al cmp
1A04F47 	38 
1A04F48 	D8 
      loopne
1A04F49 	E0 FB 
      =  if                
1A04F4B 	75  8 
         si dec si push    ( adr' )
1A04F4D 	4E 56 
         cx inc cx push    ( adr' len' )
1A04F4F 	41 
1A04F50 	51 
         dx si mov
1A04F51 	8B F2 
         next
1A04F53 	FF E7 
      then
   then
   si push                 ( adr' )
1A04F55 	56 
   cx push                 ( adr' len' )
1A04F56 	51 
   dx si mov
1A04F57 	8B 
1A04F58 	F2 
c;
1A04F59 	FF E7 

code noop (s -- )  c;
1A04F5B 	6E 6F 6F 70 84 
1A04F60 	38 4F A0  1 68 4F A0  1 
1A04F68 	FF E7 

code n->l (s n.unsigned -- l ) c;
1A04F6A 	 0 6E 2D 3E 6C 84 
1A04F70 	64 4F A0  1 78 4F A0  1 
1A04F78 	FF E7 
: s>d  (s n -- d )  dup 0<  ;  \ Depends on  true=-1, false=0
1A04F7A 	 0  0 73 3E 64 83 
1A04F80 	74 4F A0  1 20 40 A0  1 
1A04F88 	40 49 A0  1 64 47 A0  1 
1A04F90 	58 46 A0  1 

: lwsplit (s l -- w.low w.high )  \ split a long into two words
1A04F94 	6C 77 73 70 
1A04F98 	6C 69 74 87 84 4F A0  1 
1A04FA0 	20 40 A0  1 
   dup  ffff and  swap 10 >>  
1A04FA4 	40 49 A0  1 
1A04FA8 	58 41 A0  1 FF FF  0  0 
1A04FB0 	5C 44 A0  1 68 49 A0  1 
1A04FB8 	58 41 A0  1 10  0  0  0 
1A04FC0 	DC 44 A0  1 
;
1A04FC4 	58 46 A0  1 
: wljoin (s w.low w.high -- l )  10 <<  swap  ffff and  or  ;
1A04FC8 	 0 77 6C 6A 6F 69 6E 86 
1A04FD0 	A0 4F A0  1 20 40 A0  1 
1A04FD8 	58 41 A0  1 10  0  0  0 
1A04FE0 	C8 44 A0  1 68 49 A0  1 
1A04FE8 	58 41 A0  1 FF FF  0  0 
1A04FF0 	5C 44 A0  1 70 44 A0  1 
1A04FF8 	58 46 A0  1 

code ca+  (s addr index -- addr+index*/c )
1A04FFC 	63 61 2B 83 
1A05000 	D4 4F A0  1  8 50 A0  1 
   bx pop   ax pop   bx ax add   1push
1A05008 	5B 58  1 D8 50 
c;
1A0500D 	FF E7 
code wa+  (s addr index -- addr+index*/w )
1A0500F 	 0 
1A05010 	77 61 2B 83  4 50 A0  1 
1A05018 	1C 50 A0  1 
   bx pop  bx shl  ax pop   bx ax add   1push
1A0501C 	5B D1 E3 58 
1A05020 	 1 D8 50 
c;
1A05023 	FF E7 
code la+  (s addr index -- addr+index*/l )
1A05025 	 0  0  0 
1A05028 	6C 61 2B 83 18 50 A0  1 
1A05030 	34 50 A0  1 
   bx pop  bx shl  bx shl  ax pop   bx ax add   1push
1A05034 	5B D1 E3 D1 
1A05038 	E3 58  1 D8 50 
c;
1A0503D 	FF E7 
code na+  (s addr index -- addr+index*/n )
1A0503F 	 0 
1A05040 	6E 61 2B 83 30 50 A0  1 
1A05048 	4C 50 A0  1 
   bx pop  bx shl  bx shl  ax pop   bx ax add   1push
1A0504C 	5B D1 E3 D1 
1A05050 	E3 58  1 D8 50 
c;
1A05055 	FF E7 
code ta+  (s addr index -- addr+index*/t )
1A05057 	 0 
1A05058 	74 61 2B 83 48 50 A0  1 
1A05060 	64 50 A0  1 
   bx pop  bx shl  bx shl  ax pop   bx ax add   1push
1A05064 	5B D1 E3 D1 
1A05068 	E3 58  1 D8 50 
c;
1A0506D 	FF E7 

code ca1+  (s addr -- addr+/c )       ax pop   ax inc            1push c;
1A0506F 	63 
1A05070 	61 31 2B 84 60 50 A0  1 
1A05078 	7C 50 A0  1 58 40 50 FF 
1A05080 	E7 
code char+ (s addr -- addr+/c )       ax pop   ax inc            1push c;
1A05081 	 0 63 68 61 72 2B 85 
1A05088 	78 50 A0  1 90 50 A0  1 
1A05090 	58 40 50 FF E7 
code wa1+  (s addr -- addr+/w )       ax pop   ax inc   ax inc   1push c;
1A05095 	 0  0 77 
1A05098 	61 31 2B 84 8C 50 A0  1 
1A050A0 	A4 50 A0  1 58 40 40 50 
1A050A8 	FF E7 
code la1+  (s addr -- addr+/l )       ax pop   ax ainc           1push c;
1A050AA 	 0 6C 61 31 2B 84 
1A050B0 	A0 50 A0  1 B8 50 A0  1 
1A050B8 	58  5  4  0  0  0 50 FF 
1A050C0 	E7 
code na1+  (s addr -- addr+/n )       ax pop   ax ainc           1push c;
1A050C1 	 0  0 6E 61 31 2B 84 
1A050C8 	B4 50 A0  1 D0 50 A0  1 
1A050D0 	58  5  4  0  0  0 50 FF 
1A050D8 	E7 
code cell+ (s addr -- addr+/n )       ax pop   ax ainc           1push c;
1A050D9 	 0 63 65 6C 6C 2B 85 
1A050E0 	CC 50 A0  1 E8 50 A0  1 
1A050E8 	58  5  4  0  0  0 50 FF 
1A050F0 	E7 
code ta1+  (s addr -- addr+/token )   ax pop   ax ainc           1push c;
1A050F1 	 0  0 74 61 31 2B 84 
1A050F8 	E4 50 A0  1  0 51 A0  1 
1A05100 	58  5  4  0  0  0 50 FF 
1A05108 	E7 

1 constant /c
1A05109 	2F 63 82 FC 50 A0  1 
1A05110 	68 40 A0  1  1  0  0  0 
2 constant /w
1A05118 	 0 2F 77 82 10 51 A0  1 
1A05120 	68 40 A0  1  2  0  0  0 
4 constant /l
1A05128 	 0 2F 6C 82 20 51 A0  1 
1A05130 	68 40 A0  1  4  0  0  0 
/l constant /n
1A05138 	 0 2F 6E 82 30 51 A0  1 
1A05140 	68 40 A0  1  4  0  0  0 

code /c*   (s n -- n*/c )   c;
1A05148 	2F 63 2A 83 40 51 A0  1 
1A05150 	54 51 A0  1 FF E7 
code chars (s n -- n*/c )   c;
1A05156 	63 68 
1A05158 	61 72 73 85 50 51 A0  1 
1A05160 	64 51 A0  1 FF E7 
code /w*   (s n -- n*/w )   ax pop   ax shl   1push c;
1A05166 	 0  0 
1A05168 	2F 77 2A 83 60 51 A0  1 
1A05170 	74 51 A0  1 58 D1 E0 50 
1A05178 	FF E7 
code /l*   (s n -- n*/l )   ax pop   ax shl   ax shl   1push c;
1A0517A 	 0  0 2F 6C 2A 83 
1A05180 	70 51 A0  1 88 51 A0  1 
1A05188 	58 D1 E0 D1 E0 50 FF E7 
code /n*   (s n -- n*/n )   ax pop   ax shl   ax shl   1push c;
1A05190 	2F 6E 2A 83 84 51 A0  1 
1A05198 	9C 51 A0  1 58 D1 E0 D1 
1A051A0 	E0 50 FF E7 
code cells (s n -- n*/n )   ax pop   ax shl   ax shl   1push c;
1A051A4 	 0  0 63 65 
1A051A8 	6C 6C 73 85 98 51 A0  1 
1A051B0 	B4 51 A0  1 58 D1 E0 D1 
1A051B8 	E0 50 FF E7 

mloclabel >upper also assembler
   ascii a # al cmp  0>=  if
1A051BC 	3C 61 78  6 
      ascii z 1+ # al cmp   0< if   ascii a ascii A - # al sub   then
1A051C0 	3C 7B 79  2 2C 20 
   then
   ret
1A051C6 	C3 
end-code

code upc (s char -- upper-case-char )   ax pop   >upper #) call   1push c;
1A051C7 	 0 
1A051C8 	75 70 63 83 B0 51 A0  1 
1A051D0 	D4 51 A0  1 58 E8 E2 FF 
1A051D8 	FF FF 50 FF E7 

mloclabel >lower  also assembler
   ascii A # al cmp  0>=  if
1A051DD 	3C 41 78 
1A051E0 	 6 
      ascii Z 1+ # al cmp   0< if   ascii a ascii A - # al add   then
1A051E1 	3C 5B 79  2  4 20 
   then
   ret
1A051E7 	C3 
end-code

code lcc  (s char -- lower-case-char )  ax pop  >lower #) call  1push c;
1A051E8 	6C 63 63 83 D0 51 A0  1 
1A051F0 	F4 51 A0  1 58 E8 E3 FF 
1A051F8 	FF FF 50 FF E7 

code c@+  (s addr -- addr+1 len )
1A051FD 	 0  0  0 
1A05200 	63 40 2B 83 F0 51 A0  1 
1A05208 	 C 52 A0  1 
   bx pop   ax ax sub   0 [bx] al mov   bx inc   bx push  1push
1A0520C 	5B 29 C0 8A 
1A05210 	 3 43 53 50 
c;
1A05214 	FF E7 

mloclabel nomore   also assembler   dx si mov   bx di mov   cx push   next end-code
1A05216 	8B F2 
1A05218 	8B FB 51 FF E7 

mloclabel mismatch  also assembler
   0< if  -1 # cx mov  else  1 # cx mov  then  nomore #) jmp
1A0521D 	79  7 B9 
1A05220 	FF FF FF FF EB  5 B9  1 
1A05228 	 0  0  0 EB E9 
end-code

\ string compare - case sensitive
code comp      (s addr1 addr2 len -- -1 | 0 | 1 )
1A0522D 	 0  0 63 
1A05230 	6F 6D 70 84  8 52 A0  1 
1A05238 	3C 52 A0  1 
   si dx mov   di bx mov   cx pop   di pop   si pop   nomore jcxz
1A0523C 	8B D6 8B DF 
1A05240 	59 5F 5E E3 D1 
   ds ax mov  ax es mov   repz   byte cmps   nomore je  mismatch jne
1A05245 	8C D8 8E 
1A05248 	C0 F3 A6 74 C9 75 CE 
   \ We don't put "mismatch" in-line here because mlabel aligns
   \ the dictionary pointer
end-code

\ string compare - case insensitive
code caps-comp  (s addr1 addr2 len -- -1 | 0 | 1 )
1A0524F 	 0 
1A05250 	 0  0 63 61 70 73 2D 63 
1A05258 	6F 6D 70 89 38 52 A0  1 
1A05260 	64 52 A0  1 
   si dx mov   di bx mov   cx pop   di pop   si pop
1A05264 	8B D6 8B DF 
1A05268 	59 5F 5E 
   begin
      nomore jcxz   0 [si] al mov  >upper #) call  si inc
1A0526B 	E3 A9 8A  6 E8 
1A05270 	48 FF FF FF 46 
        al ah mov   0 [di] al mov  >upper #) call  di inc
1A05275 	8A E0 8A 
1A05278 	 7 E8 3E FF FF FF 47 
      al ah cmp  mismatch jne   cx dec
1A0527F 	38 
1A05280 	C4 75 9A 49 
   again
1A05284 	EB E5 
end-code

code 3drop  ( n1 n2 n3 -- )  ax pop  ax pop  ax pop  c;
1A05286 	33 64 
1A05288 	72 6F 70 85 60 52 A0  1 
1A05290 	94 52 A0  1 58 58 58 FF 
1A05298 	E7 
: 3dup   ( a b c -- a b c a b c )  2 pick  2 pick  2 pick  ;
1A05299 	 0  0 33 64 75 70 84 
1A052A0 	90 52 A0  1 20 40 A0  1 
1A052A8 	58 41 A0  1  2  0  0  0 
1A052B0 	 C 4A A0  1 58 41 A0  1 
1A052B8 	 2  0  0  0  C 4A A0  1 
1A052C0 	58 41 A0  1  2  0  0  0 
1A052C8 	 C 4A A0  1 58 46 A0  1 
: pack  (s str-addr len to -- to )
1A052D0 	 0  0  0 70 61 63 6B 84 
1A052D8 	A4 52 A0  1 20 40 A0  1 
   2dup >r >r
1A052E0 	C0 49 A0  1 BC 45 A0  1 
1A052E8 	BC 45 A0  1 
   3dup  1+ swap move  c! drop
1A052EC 	A4 52 A0  1 
1A052F0 	30 4B A0  1 68 49 A0  1 
1A052F8 	F4 4A A0  1 B8 4D A0  1 
1A05300 	30 49 A0  1 
   r> r>  tuck + 1+ 0 swap c!
1A05304 	D0 45 A0  1 
1A05308 	D0 45 A0  1 E8 46 A0  1 
1A05310 	 4 45 A0  1 30 4B A0  1 
1A05318 	58 41 A0  1  0  0  0  0 
1A05320 	68 49 A0  1 B8 4D A0  1 
;
1A05328 	58 46 A0  1 
code 4drop  (s n1 n2 n3 n4 -- )
1A0532C 	 0  0 34 64 
1A05330 	72 6F 70 85 DC 52 A0  1 
1A05338 	3C 53 A0  1 
   ax pop  ax pop  ax pop  ax pop
1A0533C 	58 58 58 58 
c;
1A05340 	FF E7 
code 5drop  (s n1 n2 n3 n4 n5 -- )
1A05342 	35 64 72 6F 70 85 
1A05348 	38 53 A0  1 50 53 A0  1 
   ax pop  ax pop  ax pop  ax pop  ax pop
1A05350 	58 58 58 58 58 
c;
1A05355 	FF E7 

code (')  (s -- acf )
1A05357 	 0 
1A05358 	28 27 29 83 4C 53 A0  1 
1A05360 	64 53 A0  1 
   ax lods   
1A05364 	AD 
\+ rel-t  up ax add   
   1push
1A05365 	50 
c;
1A05366 	FF E7 

\ Modifies caller's ip to skip over an in-line string
code skipstr (s -- addr len)
1A05368 	73 6B 69 70 73 74 72 87 
1A05370 	60 53 A0  1 78 53 A0  1 
   0 [rp] bx mov       \ Get string address in bx
1A05378 	8B 5D  0 
   ax ax sub
1A0537B 	29 C0 
   0 [bx] al mov       \ Get length byte in ax
1A0537D 	8A  3 

   bx inc              \ Address of data bytes
1A0537F 	43 
   bx push             \ Put addr on stack
1A05380 	53 

   ax push             \ Put len on stack
1A05381 	50 

   bx ax add           \ Skip the string
1A05382 	 1 D8 
   #talign-t #  ax add   \ Round up to token boundary + null byte
1A05384 	 5  4  0  0 
1A05388 	 0 
   #talign-t negate #  ax  and	\ Align
1A05389 	25 FC FF FF FF 
   ax 0 [rp] mov       \ Put the modified ip back
1A0538E 	89 45 
1A05390 	 0 
c;
1A05391 	FF E7 
code (")  (s -- addr len)
1A05393 	 0 28 22 29 83 
1A05398 	74 53 A0  1 A0 53 A0  1 
   ax ax xor	       \ Clear high bytes
1A053A0 	31 C0 
   al lodsb            \ Get length byte in al
1A053A2 	AC 
   ip push             \ Push address of data bytes
1A053A3 	56 
   ax push             \ Push length
1A053A4 	50 
   ax ip add           \ Skip the string
1A053A5 	 1 C6 
   #talign-t #  ip add   \ Round up to token boundary + null byte
1A053A7 	83 
1A053A8 	C6  4 
   #talign-t negate #  ip and	\ Align
1A053AA 	83 E6 FC 
c;
1A053AD 	FF E7 
code count  (s addr -- addr+1 len )
1A053AF 	 0 
1A053B0 	 0  0 63 6F 75 6E 74 85 
1A053B8 	9C 53 A0  1 C0 53 A0  1 
   bx pop   ax ax xor   0 [bx] al mov   bx inc   bx push  1push
1A053C0 	5B 31 C0 8A  3 43 53 50 
c;
1A053C8 	FF E7 
code (n")  (s -- addr len)
1A053CA 	 0 28 6E 22 29 84 
1A053D0 	BC 53 A0  1 D8 53 A0  1 
   ax lods             \ Get length in ax
1A053D8 	AD 
   ip push             \ Push address of data bytes
1A053D9 	56 
   ax push             \ Push length
1A053DA 	50 
   ax ip add           \ Skip the string
1A053DB 	 1 C6 
   #talign-t #  ip add   \ Round up to token boundary + null byte
1A053DD 	83 C6  4 
   #talign-t negate #  ip and	\ Align
1A053E0 	83 E6 FC 
c;
1A053E3 	FF E7 
code ncount  (s addr -- addr+/n len )
1A053E5 	6E 63 6F 
1A053E8 	75 6E 74 86 D4 53 A0  1 
1A053F0 	F4 53 A0  1 
   bx pop   0 [bx] ax mov   /n [bx] bx lea   bx push  1push
1A053F4 	5B 8B  3 8D 
1A053F8 	5B  4 53 50 
c;
1A053FC 	FF E7 

code token@ (s addr -- cfa )
1A053FE 	 0  0 
1A05400 	 0 74 6F 6B 65 6E 40 86 
1A05408 	F0 53 A0  1 10 54 A0  1 
   ax pop
1A05410 	58 
\+ rel-t   0 [ax] ax mov  up ax add  ax push
\- rel-t   0 [ax] push
1A05411 	FF 30 
c;
1A05413 	FF E7 
\ [ifdef] big-endian-t
\+ rel-t code token!  ( xt adr -- )  bx pop  ax pop  up ax sub  ax 0 [bx] mov  c;
\- rel-t : token!  ( adr1 adr2 -- ) ( set-relocation-bit )  le-!  ;
1A05415 	74 6F 6B 
1A05418 	65 6E 21 86  C 54 A0  1 
1A05420 	20 40 A0  1 30 4D A0  1 
1A05428 	58 46 A0  1 
\ [else]
\ code token! (s cfa addr -- )   bx pop   0 [bx] pop    c;
\ [then]


nuser state        \ compilation or interpretation
1A0542C 	 0  0 73 74 
1A05430 	61 74 65 85 20 54 A0  1 
1A05438 	48 40 A0  1 20  0  0  0 
nuser dp           \ dictionary pointer
1A05440 	 0 64 70 82 38 54 A0  1 
1A05448 	48 40 A0  1 24  0  0  0 
h# fffffffc value limit
1A05450 	 0  0 6C 69 6D 69 74 85 
1A05458 	48 54 A0  1 50 40 A0  1 
1A05460 	28  0  0  0 

\ This can't use token@ and token! because the dictionary pointer
\ needs to temporarily contain odd byte offset because of c,
: here  (s -- addr )  dp @  ;
1A05464 	 0  0  0 68 
1A05468 	65 72 65 84 5C 54 A0  1 
1A05470 	20 40 A0  1 48 54 A0  1 
1A05478 	5C 4C A0  1 58 46 A0  1 
: pad        (s -- adr )       here 300 +   ;
1A05480 	70 61 64 83 70 54 A0  1 
1A05488 	20 40 A0  1 70 54 A0  1 
1A05490 	58 41 A0  1  0  3  0  0 
1A05498 	 4 45 A0  1 58 46 A0  1 

: unused  ( -- #bytes )  limit here -  ;
1A054A0 	 0 75 6E 75 73 65 64 86 
1A054A8 	88 54 A0  1 20 40 A0  1 
1A054B0 	5C 54 A0  1 70 54 A0  1 
1A054B8 	18 45 A0  1 58 46 A0  1 

defer allot-error
1A054C0 	61 6C 6C 6F 74 2D 65 72 
1A054C8 	72 6F 72 8B AC 54 A0  1 
1A054D0 	5C 40 A0  1 2C  0  0  0 
: allot  (s n -- )
1A054D8 	 0  0 61 6C 6C 6F 74 85 
1A054E0 	D0 54 A0  1 20 40 A0  1 
   dup pad + d# 100 + limit  u>  if  allot-error  then
1A054E8 	40 49 A0  1 88 54 A0  1 
1A054F0 	 4 45 A0  1 58 41 A0  1 
1A054F8 	64  0  0  0  4 45 A0  1 
1A05500 	5C 54 A0  1 64 48 A0  1 
1A05508 	DC 41 A0  1  8  0  0  0 
1A05510 	D0 54 A0  1 
   dp +!   ( n )
1A05514 	48 54 A0  1 
1A05518 	 C 4C A0  1 
;
1A0551C 	58 46 A0  1 

: token,  (s cfa -- )  here  /token allot  token!  ;
1A05520 	 0 74 6F 6B 65 6E 2C 86 
1A05528 	E4 54 A0  1 20 40 A0  1 
1A05530 	70 54 A0  1 B4 46 A0  1 
1A05538 	E4 54 A0  1 20 54 A0  1 
1A05540 	58 46 A0  1 

\+ rel-t code origin  (s -- addr )  up push  c;
\- rel-t origin-t constant origin
1A05544 	 0 6F 72 69 
1A05548 	67 69 6E 86 2C 55 A0  1 
1A05550 	68 40 A0  1  0  0 A0  1 
\- rel-t    /n negate allot-t  origin-t token,-t  ( make origin relocatable )

\ code origin  (s -- addr )   ax ax sub   1push c;
\ origin is defined later as a constant
\ code origin+  (s offset -- addr )   c;
\ code origin-  (s offset -- addr )   c;
\ for now, use high-level...
: origin+  (s offset -- addr )   origin +  ;
1A05558 	6F 72 69 67 69 6E 2B 87 
1A05560 	50 55 A0  1 20 40 A0  1 
1A05568 	50 55 A0  1  4 45 A0  1 
1A05570 	58 46 A0  1 
: origin-  (s offset -- addr )   origin -  ;
1A05574 	6F 72 69 67 
1A05578 	69 6E 2D 87 64 55 A0  1 
1A05580 	20 40 A0  1 50 55 A0  1 
1A05588 	18 45 A0  1 58 46 A0  1 

\ ---- Support words for the incremental compiler


: ,      (s n -- )       here   /n allot   unaligned-!   ;
1A05590 	 0  0 2C 81 80 55 A0  1 
1A05598 	20 40 A0  1 70 54 A0  1 
1A055A0 	40 51 A0  1 E4 54 A0  1 
1A055A8 	20 4E A0  1 58 46 A0  1 
: c,     (s char -- )    here   /c allot   c!   ;
1A055B0 	 0 63 2C 82 98 55 A0  1 
1A055B8 	20 40 A0  1 70 54 A0  1 
1A055C0 	10 51 A0  1 E4 54 A0  1 
1A055C8 	B8 4D A0  1 58 46 A0  1 
: w,     (s w -- )       here   /w allot   w!   ;
1A055D0 	 0 77 2C 82 B8 55 A0  1 
1A055D8 	20 40 A0  1 70 54 A0  1 
1A055E0 	20 51 A0  1 E4 54 A0  1 
1A055E8 	A4 4D A0  1 58 46 A0  1 
: l,     (s l -- )       here   /l allot   unaligned-l!   ;
1A055F0 	 0 6C 2C 82 D8 55 A0  1 
1A055F8 	20 40 A0  1 70 54 A0  1 
1A05600 	30 51 A0  1 E4 54 A0  1 
1A05608 	3C 4E A0  1 58 46 A0  1 

: next  ( -- )  h# ff c,  h# e7 c,  ;	\ up jmp
1A05610 	 0  0  0 6E 65 78 74 84 
1A05618 	F8 55 A0  1 20 40 A0  1 
1A05620 	58 41 A0  1 FF  0  0  0 
1A05628 	B8 55 A0  1 58 41 A0  1 
1A05630 	E7  0  0  0 B8 55 A0  1 
1A05638 	58 46 A0  1 


\ place-does compiles a "dodoes #) call" instruction
[ifdef] big-endian-t
: place-does   (s -- )
   \ Three noops, so the following call instruction will end 4-byte-aligned
   90 c,  90 c,  90 c,
   e8 c,  dodoes  here 4 allot  swap here - swap  le-!
;
[else]               \ 1 noop for word-alignment (for relocation)
: place-does   (s -- )
1A0563C 	 0 70 6C 61 
1A05640 	63 65 2D 64 6F 65 73 8A 
1A05648 	1C 56 A0  1 20 40 A0  1 
   \ Add enough noops to force the following 5-byte call instruction
   \ to end at a token alignment boundary
\   #talign-t 1  ?do  90 c,  loop
   90 c,  90 c,  90 c,
1A05650 	58 41 A0  1 90  0  0  0 
1A05658 	B8 55 A0  1 58 41 A0  1 
1A05660 	90  0  0  0 B8 55 A0  1 
1A05668 	58 41 A0  1 90  0  0  0 
1A05670 	B8 55 A0  1 
   e8 c,  dodoes  origin+  here 4 + - ,
1A05674 	58 41 A0  1 
1A05678 	E8  0  0  0 B8 55 A0  1 
1A05680 	58 41 A0  1 7C 40  0  0 
1A05688 	64 55 A0  1 70 54 A0  1 
1A05690 	58 41 A0  1  4  0  0  0 
1A05698 	 4 45 A0  1 18 45 A0  1 
1A056A0 	98 55 A0  1 
;
1A056A4 	58 46 A0  1 
[then]

: place-;code  (s -- )  ;
1A056A8 	70 6C 61 63 65 2D 3B 63 
1A056B0 	6F 64 65 8B 4C 56 A0  1 
1A056B8 	20 40 A0  1 58 46 A0  1 

-1 constant true  0 constant false
1A056C0 	 0  0  0 74 72 75 65 84 
1A056C8 	B8 56 A0  1 68 40 A0  1 
1A056D0 	FF FF FF FF  0  0 66 61 
1A056D8 	6C 73 65 85 CC 56 A0  1 
1A056E0 	68 40 A0  1  0  0  0  0 

\ Ip is assumed to point to (;code .  flag is true if
\ the code at ip is a does> clause as opposed to a ;code clause.
: does-ip?   (s ip -- ip' flag )
1A056E8 	 0  0  0 64 6F 65 73 2D 
1A056F0 	69 70 3F 88 E0 56 A0  1 
1A056F8 	20 40 A0  1 
   ta1+     \ Skip past the (;code token
1A056FC 	FC 50 A0  1 
   dup c@  h# e8  =  if    \ is a DOES> clause
1A05700 	40 49 A0  1 C4 4C A0  1 
1A05708 	58 41 A0  1 E8  0  0  0 
1A05710 	24 48 A0  1 DC 41 A0  1 
1A05718 	1C  0  0  0 
      5 +   true           \ Skip the   DODOES #) CALL  instruction
1A0571C 	58 41 A0  1 
1A05720 	 5  0  0  0  4 45 A0  1 
1A05728 	CC 56 A0  1 
   else
1A0572C 	C8 41 A0  1 
1A05730 	3C  0  0  0 
      dup  c@  h# 90  =  if   \ is an aligned DOES> clause
1A05734 	40 49 A0  1 
1A05738 	C4 4C A0  1 58 41 A0  1 
1A05740 	90  0  0  0 24 48 A0  1 
1A05748 	DC 41 A0  1 1C  0  0  0 
         8 +  true
1A05750 	58 41 A0  1  8  0  0  0 
1A05758 	 4 45 A0  1 CC 56 A0  1 
      else                 \ is a ;CODE clause
1A05760 	C8 41 A0  1  8  0  0  0 
         false
1A05768 	E0 56 A0  1 
      then
   then
;
1A0576C 	58 46 A0  1 

: put-cf  (s action-clause-addr where -- )  token!  ;
1A05770 	 0 70 75 74 2D 63 66 86 
1A05778 	F8 56 A0  1 20 40 A0  1 
1A05780 	20 54 A0  1 58 46 A0  1 

nuser 'lastacf
1A05788 	 0  0  0 27 6C 61 73 74 
1A05790 	61 63 66 88 7C 57 A0  1 
1A05798 	48 40 A0  1 30  0  0  0 
: lastacf  ( -- acf )  'lastacf token@  ;
1A057A0 	6C 61 73 74 61 63 66 87 
1A057A8 	98 57 A0  1 20 40 A0  1 
1A057B0 	98 57 A0  1  C 54 A0  1 
1A057B8 	58 46 A0  1 

\ uses  sets the code field of the indicated word so that
\ it will execute the code at action-clause-adr
: uses  ( action-clause-adr xt -- )  put-cf  ;
1A057BC 	 0  0  0 75 
1A057C0 	73 65 73 84 AC 57 A0  1 
1A057C8 	20 40 A0  1 7C 57 A0  1 
1A057D0 	58 46 A0  1 


\ used  sets the code field of the most-recently-defined word so that
\ it executes the code at action-clause-adr
: used  ( action-clause-adr -- )  lastacf  uses  ;
1A057D4 	 0  0  0 75 
1A057D8 	73 65 64 84 C8 57 A0  1 
1A057E0 	20 40 A0  1 AC 57 A0  1 
1A057E8 	C8 57 A0  1 58 46 A0  1 

\t16 2 constant /branch
\t32 4 constant /branch
1A057F0 	2F 62 72 61 6E 63 68 87 
1A057F8 	E0 57 A0  1 68 40 A0  1 
1A05800 	 4  0  0  0 
: branch, ( offset -- )
1A05804 	62 72 61 6E 
1A05808 	63 68 2C 87 FC 57 A0  1 
1A05810 	20 40 A0  1 
\t32 ,
1A05814 	98 55 A0  1 
\t16 w,
;
1A05818 	58 46 A0  1 
: branch@  ( -- offset )
1A0581C 	62 72 61 6E 
1A05820 	63 68 40 87 10 58 A0  1 
1A05828 	20 40 A0  1 
\t16 w@
\t32 @
1A0582C 	5C 4C A0  1 
;
1A05830 	58 46 A0  1 
: branch! ( offset where -- )
1A05834 	62 72 61 6E 
1A05838 	63 68 21 87 28 58 A0  1 
1A05840 	20 40 A0  1 
\t16 w!
\t32 !
1A05844 	54 4D A0  1 
;
1A05848 	58 46 A0  1 
\ >target depends on the way that branches are compiled
: >target  ( ip-of-branch-instruction -- target )  ta1+ dup branch@ +  ;
1A0584C 	3E 74 61 72 
1A05850 	67 65 74 87 40 58 A0  1 
1A05858 	20 40 A0  1 FC 50 A0  1 
1A05860 	40 49 A0  1 28 58 A0  1 
1A05868 	 4 45 A0  1 58 46 A0  1 

\+ rel-t create rel

headerless
/a constant /a
1A05870 	 0 2F 61 82 58 58 A0  1 
1A05878 	68 40 A0  1  4  0  0  0 
code a@ (s addr -- cfa )
1A05880 	 0 61 40 82 78 58 A0  1 
1A05888 	8C 58 A0  1 
   ax pop
1A0588C 	58 
\+ rel-t   0 [ax] ax mov   up ax add  ax push
\- rel-t   0 [ax] push
1A0588D 	FF 30 
c;
1A0588F 	FF 
1A05890 	E7 
\ [ifdef] big-endian-t
\+ rel-t code a!  ( xt adr -- )  bx pop  ax pop  up ax sub  ax 0 [bx] mov  c;
\- rel-t : a!  ( adr1 adr2 -- ) ( set-relocation-bit )  le-!  ;
1A05891 	61 21 82 88 58 A0  1 
1A05898 	20 40 A0  1 30 4D A0  1 
1A058A0 	58 46 A0  1 
\ [else]
\ code a!  ( adr1 adr2 -- )   bx pop   0 [bx] pop    c;
\ [then]
: a,  ( adr -- )  here  /a allot  a!  ;
1A058A4 	 0 61 2C 82 
1A058A8 	98 58 A0  1 20 40 A0  1 
1A058B0 	70 54 A0  1 78 58 A0  1 
1A058B8 	E4 54 A0  1 98 58 A0  1 
1A058C0 	58 46 A0  1 

: null  ( -- link )  origin  ;
1A058C4 	 0  0  0 6E 
1A058C8 	75 6C 6C 84 AC 58 A0  1 
1A058D0 	20 40 A0  1 50 55 A0  1 
1A058D8 	58 46 A0  1 
: !null-link   ( adr -- )  origin swap a!  ;
1A058DC 	 0 21 6E 75 
1A058E0 	6C 6C 2D 6C 69 6E 6B 8A 
1A058E8 	D0 58 A0  1 20 40 A0  1 
1A058F0 	50 55 A0  1 68 49 A0  1 
1A058F8 	98 58 A0  1 58 46 A0  1 
: !null-token  ( adr -- )  origin swap token!  ;
1A05900 	21 6E 75 6C 6C 2D 74 6F 
1A05908 	6B 65 6E 8B EC 58 A0  1 
1A05910 	20 40 A0  1 50 55 A0  1 
1A05918 	68 49 A0  1 20 54 A0  1 
1A05920 	58 46 A0  1 
: non-null?  ( link -- false | link true )
1A05924 	 0  0 6E 6F 
1A05928 	6E 2D 6E 75 6C 6C 3F 89 
1A05930 	10 59 A0  1 20 40 A0  1 
   dup origin <>  dup  0=  if  nip  then
1A05938 	40 49 A0  1 50 55 A0  1 
1A05940 	44 48 A0  1 40 49 A0  1 
1A05948 	24 47 A0  1 DC 41 A0  1 
1A05950 	 8  0  0  0 FC 46 A0  1 
;
1A05958 	58 46 A0  1 

: get-token?     ( adr -- false | acf  true )  token@ non-null?  ;
1A0595C 	 0 67 65 74 
1A05960 	2D 74 6F 6B 65 6E 3F 8A 
1A05968 	34 59 A0  1 20 40 A0  1 
1A05970 	 C 54 A0  1 34 59 A0  1 
1A05978 	58 46 A0  1 
: another-link?  ( adr -- false | link true )  a@  non-null?  ;
1A0597C 	 0  0 61 6E 
1A05980 	6F 74 68 65 72 2D 6C 69 
1A05988 	6E 6B 3F 8D 6C 59 A0  1 
1A05990 	20 40 A0  1 88 58 A0  1 
1A05998 	34 59 A0  1 58 46 A0  1 

\ The "word type" is a number which distinguishes one type of word
\ from another.  This is highly implementation-dependent.

\ For the i386 implementation, the magic number returned by word-type
\ is the absolute address of the action code.

: word-type  (s acf -- word-type )  token@  ;
1A059A0 	 0  0 77 6F 72 64 2D 74 
1A059A8 	79 70 65 89 90 59 A0  1 
1A059B0 	20 40 A0  1  C 54 A0  1 
1A059B8 	58 46 A0  1 

: body>  (s pfa -- cfa )   /token -  ;
1A059BC 	 0  0 62 6F 
1A059C0 	64 79 3E 85 B0 59 A0  1 
1A059C8 	20 40 A0  1 B4 46 A0  1 
1A059D0 	18 45 A0  1 58 46 A0  1 
: >body  (s cfa -- pfa )   /token +  ;
1A059D8 	 0  0 3E 62 6F 64 79 85 
1A059E0 	C8 59 A0  1 20 40 A0  1 
1A059E8 	B4 46 A0  1  4 45 A0  1 
1A059F0 	58 46 A0  1 

: >code  ( acf-of-code-word -- address-of-start-of-machine-code )  >body  ;
1A059F4 	 0  0 3E 63 
1A059F8 	6F 64 65 85 E4 59 A0  1 
1A05A00 	20 40 A0  1 E4 59 A0  1 
1A05A08 	58 46 A0  1 
: code?  ( acf -- f )  \ True if the acf is for a code word
1A05A0C 	 0  0 63 6F 
1A05A10 	64 65 3F 85  0 5A A0  1 
1A05A18 	20 40 A0  1 
   dup token@  swap >body  =
1A05A1C 	40 49 A0  1 
1A05A20 	 C 54 A0  1 68 49 A0  1 
1A05A28 	E4 59 A0  1 24 48 A0  1 
;
1A05A30 	58 46 A0  1 


\t16 2 constant /user#
\t32 4 constant /user#
1A05A34 	 0 2F 75 73 
1A05A38 	65 72 23 86 18 5A A0  1 
1A05A40 	68 40 A0  1  4  0  0  0 

\ Move to a machine alignment boundary.
\ i386 allows arbitrary alignment

[ifdef] big-endian-t
create big-endian
[then]

#align-t     constant #align
1A05A48 	 0 23 61 6C 69 67 6E 86 
1A05A50 	40 5A A0  1 68 40 A0  1 
1A05A58 	 4  0  0  0 
#talign-t    constant #talign
1A05A5C 	23 74 61 6C 
1A05A60 	69 67 6E 87 54 5A A0  1 
1A05A68 	68 40 A0  1  4  0  0  0 
#acf-align-t constant #acf-align
1A05A70 	 0 23 61 63 66 2D 61 6C 
1A05A78 	69 67 6E 8A 68 5A A0  1 
1A05A80 	68 40 A0  1  4  0  0  0 

: acf-align  (s -- )
1A05A88 	 0  0 61 63 66 2D 61 6C 
1A05A90 	69 67 6E 89 80 5A A0  1 
1A05A98 	20 40 A0  1 
   begin  here #acf-align 1- and  while  0 c,  repeat
1A05A9C 	70 54 A0  1 
1A05AA0 	80 5A A0  1 54 4B A0  1 
1A05AA8 	5C 44 A0  1 DC 41 A0  1 
1A05AB0 	18  0  0  0 58 41 A0  1 
1A05AB8 	 0  0  0  0 B8 55 A0  1 
1A05AC0 	C8 41 A0  1 D8 FF FF FF 
   here 'lastacf token!
1A05AC8 	70 54 A0  1 98 57 A0  1 
1A05AD0 	20 54 A0  1 
;
1A05AD4 	58 46 A0  1 

\ Place the code field
: place-cf  (s action-adr -- )  origin+ acf-align  token,  ;
1A05AD8 	 0  0  0 70 6C 61 63 65 
1A05AE0 	2D 63 66 88 98 5A A0  1 
1A05AE8 	20 40 A0  1 64 55 A0  1 
1A05AF0 	98 5A A0  1 2C 55 A0  1 
1A05AF8 	58 46 A0  1 

: code-cf  (s -- )   acf-align  here ta1+ token,  ;
1A05AFC 	63 6F 64 65 
1A05B00 	2D 63 66 87 E8 5A A0  1 
1A05B08 	20 40 A0  1 98 5A A0  1 
1A05B10 	70 54 A0  1 FC 50 A0  1 
1A05B18 	2C 55 A0  1 58 46 A0  1 

: create-cf    (s -- )  docreate   place-cf  ;
1A05B20 	 0  0 63 72 65 61 74 65 
1A05B28 	2D 63 66 89  8 5B A0  1 
1A05B30 	20 40 A0  1 58 41 A0  1 
1A05B38 	30 40  0  0 E8 5A A0  1 
1A05B40 	58 46 A0  1 
: variable-cf  (s -- )  dovariable place-cf  ;
1A05B44 	76 61 72 69 
1A05B48 	61 62 6C 65 2D 63 66 8B 
1A05B50 	30 5B A0  1 20 40 A0  1 
1A05B58 	58 41 A0  1 38 40  0  0 
1A05B60 	E8 5A A0  1 58 46 A0  1 

: colon-cf      (s -- )  docolon    place-cf  ;
1A05B68 	 0  0  0 63 6F 6C 6F 6E 
1A05B70 	2D 63 66 88 54 5B A0  1 
1A05B78 	20 40 A0  1 58 41 A0  1 
1A05B80 	20 40  0  0 E8 5A A0  1 
1A05B88 	58 46 A0  1 
: colon-cf?     (s possible-acf -- flag )
1A05B8C 	 0  0 63 6F 
1A05B90 	6C 6F 6E 2D 63 66 3F 89 
1A05B98 	78 5B A0  1 20 40 A0  1 
   word-type  ['] colon-cf  word-type =
1A05BA0 	B0 59 A0  1 60 53 A0  1 
1A05BA8 	78 5B A0  1 B0 59 A0  1 
1A05BB0 	24 48 A0  1 
;
1A05BB4 	58 46 A0  1 

: user-cf       (s -- )  douser      place-cf  ;
1A05BB8 	75 73 65 72 2D 63 66 87 
1A05BC0 	9C 5B A0  1 20 40 A0  1 
1A05BC8 	58 41 A0  1 48 40  0  0 
1A05BD0 	E8 5A A0  1 58 46 A0  1 
: value-cf      (s -- )  dovalue     place-cf  ;
1A05BD8 	 0  0  0 76 61 6C 75 65 
1A05BE0 	2D 63 66 88 C4 5B A0  1 
1A05BE8 	20 40 A0  1 58 41 A0  1 
1A05BF0 	50 40  0  0 E8 5A A0  1 
1A05BF8 	58 46 A0  1 
: constant-cf   (s -- )  doconstant  place-cf  ;
1A05BFC 	63 6F 6E 73 
1A05C00 	74 61 6E 74 2D 63 66 8B 
1A05C08 	E8 5B A0  1 20 40 A0  1 
1A05C10 	58 41 A0  1 68 40  0  0 
1A05C18 	E8 5A A0  1 58 46 A0  1 
: defer-cf      (s -- )  dodefer     place-cf  ;
1A05C20 	 0  0  0 64 65 66 65 72 
1A05C28 	2D 63 66 88  C 5C A0  1 
1A05C30 	20 40 A0  1 58 41 A0  1 
1A05C38 	5C 40  0  0 E8 5A A0  1 
1A05C40 	58 46 A0  1 
: 2constant-cf  (s -- )  do2constant place-cf  ;
1A05C44 	 0  0  0 32 
1A05C48 	63 6F 6E 73 74 61 6E 74 
1A05C50 	2D 63 66 8C 30 5C A0  1 
1A05C58 	20 40 A0  1 58 41 A0  1 
1A05C60 	70 40  0  0 E8 5A A0  1 
1A05C68 	58 46 A0  1 

: round-up  ( adr granularity -- adr' )  1-  tuck +  swap invert and  ;
1A05C6C 	 0  0  0 72 
1A05C70 	6F 75 6E 64 2D 75 70 88 
1A05C78 	58 5C A0  1 20 40 A0  1 
1A05C80 	54 4B A0  1 E8 46 A0  1 
1A05C88 	 4 45 A0  1 68 49 A0  1 
1A05C90 	30 45 A0  1 5C 44 A0  1 
1A05C98 	58 46 A0  1 
: (align)  ( size granularity -- )
1A05C9C 	28 61 6C 69 
1A05CA0 	67 6E 29 87 7C 5C A0  1 
1A05CA8 	20 40 A0  1 
   1-  begin  dup here and  while  0 c,  repeat  drop
1A05CAC 	54 4B A0  1 
1A05CB0 	40 49 A0  1 70 54 A0  1 
1A05CB8 	5C 44 A0  1 DC 41 A0  1 
1A05CC0 	18  0  0  0 58 41 A0  1 
1A05CC8 	 0  0  0  0 B8 55 A0  1 
1A05CD0 	C8 41 A0  1 DC FF FF FF 
1A05CD8 	30 49 A0  1 
;
1A05CDC 	58 46 A0  1 


: aligned  (s adr -- adr' )  #align round-up  ;
1A05CE0 	61 6C 69 67 6E 65 64 87 
1A05CE8 	A8 5C A0  1 20 40 A0  1 
1A05CF0 	54 5A A0  1 7C 5C A0  1 
1A05CF8 	58 46 A0  1 
: acf-aligned  (s adr -- adr' )  #acf-align round-up  ;
1A05CFC 	61 63 66 2D 
1A05D00 	61 6C 69 67 6E 65 64 8B 
1A05D08 	EC 5C A0  1 20 40 A0  1 
1A05D10 	80 5A A0  1 7C 5C A0  1 
1A05D18 	58 46 A0  1 
: acf-align  (s -- )  #acf-align (align)   here 'lastacf token!  ;
1A05D1C 	 0  0 61 63 
1A05D20 	66 2D 61 6C 69 67 6E 89 
1A05D28 	 C 5D A0  1 20 40 A0  1 
1A05D30 	80 5A A0  1 A8 5C A0  1 
1A05D38 	70 54 A0  1 98 57 A0  1 
1A05D40 	20 54 A0  1 58 46 A0  1 

code um*  (s n1 n2 -- d )  ax pop   bx pop   bx  mul   dx ax xchg   2push c;
1A05D48 	75 6D 2A 83 2C 5D A0  1 
1A05D50 	54 5D A0  1 58 5B F7 E3 
1A05D58 	92 52 50 FF E7 
code m*   (s n1 n2 -- d )  ax pop   bx pop   bx imul   dx ax xchg   2push c;
1A05D5D 	6D 2A 82 
1A05D60 	50 5D A0  1 68 5D A0  1 
1A05D68 	58 5B F7 EB 92 52 50 FF 
1A05D70 	E7 

code um/mod  (s d1 n1 -- rem quot )
1A05D71 	75 6D 2F 6D 6F 64 86 
1A05D78 	64 5D A0  1 80 5D A0  1 
   bx pop   dx pop   ax pop   bx  div   2push
1A05D80 	5B 5A 58 F7 F3 52 50 
c;
1A05D87 	FF 
1A05D88 	E7 
code sm/rem  (s d1 n1 -- rem quot )
1A05D89 	73 6D 2F 72 65 6D 86 
1A05D90 	7C 5D A0  1 98 5D A0  1 
   bx pop   dx pop   ax pop   bx idiv   2push
1A05D98 	5B 5A 58 F7 FB 52 50 
c;
1A05D9F 	FF 
1A05DA0 	E7 

code dnegate  (s d# -- d#' )
1A05DA1 	 0  0  0 64 6E 65 67 
1A05DA8 	61 74 65 87 94 5D A0  1 
1A05DB0 	B4 5D A0  1 
   bx pop   cx pop   ax ax sub   ax dx mov
1A05DB4 	5B 59 29 C0 
1A05DB8 	8B D0 
   cx dx sub   bx ax sbb   2push
1A05DBA 	29 CA 19 D8 52 50 
c;
1A05DC0 	FF E7 

code 2nip  ( d1 d2 -- d2 )  ax pop  bx pop  dx pop  dx pop  bx push  1push c;
1A05DC2 	 0 32 6E 69 70 84 
1A05DC8 	B0 5D A0  1 D0 5D A0  1 
1A05DD0 	58 5B 5A 5A 53 50 FF E7 

code d+  ( x1 x2 -- x3 )
1A05DD8 	 0 64 2B 82 CC 5D A0  1 
1A05DE0 	E4 5D A0  1 
   ax pop  bx pop  cx pop  dx pop
1A05DE4 	58 5B 59 5A 
   bx dx add
1A05DE8 	 1 DA 
   cx ax adc
1A05DEA 	11 C8 
   dx push
1A05DEC 	52 
   ax push
1A05DED 	50 
c;
1A05DEE 	FF E7 
code d-  ( x1 x2 -- x3 )
1A05DF0 	 0 64 2D 82 E0 5D A0  1 
1A05DF8 	FC 5D A0  1 
   bx pop  cx pop  ax pop  dx pop
1A05DFC 	5B 59 58 5A 
   cx dx sub
1A05E00 	29 CA 
   bx ax sbb
1A05E02 	19 D8 
   dx push
1A05E04 	52 
   ax push
1A05E05 	50 
c;
1A05E06 	FF E7 

: dabs  ( d# -- d# )  dup 0<  if  dnegate  then  ;
1A05E08 	 0  0  0 64 61 62 73 84 
1A05E10 	F8 5D A0  1 20 40 A0  1 
1A05E18 	40 49 A0  1 64 47 A0  1 
1A05E20 	DC 41 A0  1  8  0  0  0 
1A05E28 	B0 5D A0  1 58 46 A0  1 
: dmax  ( d1 d2 -- d3 )  2over 2over  d-  nip 0<  if  2swap  then  2drop  ;
1A05E30 	 0  0  0 64 6D 61 78 84 
1A05E38 	14 5E A0  1 20 40 A0  1 
1A05E40 	D8 49 A0  1 D8 49 A0  1 
1A05E48 	F8 5D A0  1 FC 46 A0  1 
1A05E50 	64 47 A0  1 DC 41 A0  1 
1A05E58 	 8  0  0  0 F4 49 A0  1 
1A05E60 	AC 49 A0  1 58 46 A0  1 

: m/mod  (s d# n1 -- rem quot )
1A05E68 	 0  0 6D 2F 6D 6F 64 85 
1A05E70 	3C 5E A0  1 20 40 A0  1 
   dup >r  2dup xor >r  >r dabs r@ abs  um/mod
1A05E78 	40 49 A0  1 BC 45 A0  1 
1A05E80 	C0 49 A0  1 84 44 A0  1 
1A05E88 	BC 45 A0  1 BC 45 A0  1 
1A05E90 	14 5E A0  1 E4 45 A0  1 
1A05E98 	24 4A A0  1 7C 5D A0  1 
   swap r>  0< if  negate  then
1A05EA0 	68 49 A0  1 D0 45 A0  1 
1A05EA8 	64 47 A0  1 DC 41 A0  1 
1A05EB0 	 8  0  0  0 48 45 A0  1 
   swap r> 0< if
1A05EB8 	68 49 A0  1 D0 45 A0  1 
1A05EC0 	64 47 A0  1 DC 41 A0  1 
1A05EC8 	28  0  0  0 
      negate over if  1- r@ rot - swap  then
1A05ECC 	48 45 A0  1 
1A05ED0 	54 49 A0  1 DC 41 A0  1 
1A05ED8 	18  0  0  0 54 4B A0  1 
1A05EE0 	E4 45 A0  1 7C 49 A0  1 
1A05EE8 	18 45 A0  1 68 49 A0  1 
   then
   r> drop
1A05EF0 	D0 45 A0  1 30 49 A0  1 
;
1A05EF8 	58 46 A0  1 
: fm/mod  ( d# n1 -- rem quot )  m/mod  ;
1A05EFC 	 0 66 6D 2F 
1A05F00 	6D 6F 64 86 74 5E A0  1 
1A05F08 	20 40 A0  1 74 5E A0  1 
1A05F10 	58 46 A0  1 
: *      (s n1 n2 -- n3 )   m* drop   ;
1A05F14 	 0  0 2A 81 
1A05F18 	 8 5F A0  1 20 40 A0  1 
1A05F20 	64 5D A0  1 30 49 A0  1 
1A05F28 	58 46 A0  1 
: u*     (s n1 n2 -- n3 )  um* drop   ;
1A05F2C 	 0 75 2A 82 
1A05F30 	1C 5F A0  1 20 40 A0  1 
1A05F38 	50 5D A0  1 30 49 A0  1 
1A05F40 	58 46 A0  1 
: /mod   (s n1 n2 -- rem quot )   >r  s>d  r>  m/mod  ;
1A05F44 	 0  0  0 2F 
1A05F48 	6D 6F 64 84 34 5F A0  1 
1A05F50 	20 40 A0  1 BC 45 A0  1 
1A05F58 	84 4F A0  1 D0 45 A0  1 
1A05F60 	74 5E A0  1 58 46 A0  1 
: u/mod  (s n1 n2 -- rem quot )   >r    0  r>  m/mod  ;
1A05F68 	 0  0 75 2F 6D 6F 64 85 
1A05F70 	50 5F A0  1 20 40 A0  1 
1A05F78 	BC 45 A0  1 58 41 A0  1 
1A05F80 	 0  0  0  0 D0 45 A0  1 
1A05F88 	74 5E A0  1 58 46 A0  1 
: /      (s n1 n2 -- quot )   /mod  nip   ;
1A05F90 	 0  0 2F 81 74 5F A0  1 
1A05F98 	20 40 A0  1 50 5F A0  1 
1A05FA0 	FC 46 A0  1 58 46 A0  1 
: mod    (s n1 n2 -- rem )    /mod  drop  ;
1A05FA8 	6D 6F 64 83 98 5F A0  1 
1A05FB0 	20 40 A0  1 50 5F A0  1 
1A05FB8 	30 49 A0  1 58 46 A0  1 
: */mod  (s n1 n2 n3 -- rem quot )  >r  m*  r>  m/mod  ;
1A05FC0 	 0  0 2A 2F 6D 6F 64 85 
1A05FC8 	B0 5F A0  1 20 40 A0  1 
1A05FD0 	BC 45 A0  1 64 5D A0  1 
1A05FD8 	D0 45 A0  1 74 5E A0  1 
1A05FE0 	58 46 A0  1 
: */     (s n1 n2 n3 -- n1*n2/n3 )   */mod  nip  ;
1A05FE4 	 0 2A 2F 82 
1A05FE8 	CC 5F A0  1 20 40 A0  1 
1A05FF0 	CC 5F A0  1 FC 46 A0  1 
1A05FF8 	58 46 A0  1 

: ul*    (s ul u  -- ul.prod )  *  ;
1A05FFC 	75 6C 2A 83 
1A06000 	EC 5F A0  1 20 40 A0  1 
1A06008 	1C 5F A0  1 58 46 A0  1 

\ : /mod  (s dividend divisor -- remainder quotient )
\   \ Check if either factor is negative
\     2dup               ( n1 n2 n1 n2)
\     or 0< if           ( n1 n2)
\     
\         \ Both factors not non-negative do division by:
\         \ Take absolute value and do unsigned division
\         \ Convert to truncated signed divide by:
\         \  if dividend is negative then negate the remainder
\         \  if dividend and divisor have opposite signs then negate the quotient
\         \ Then convert to floored signed divide by:
\         \  if quotient is negative and remainder is non-zero
\         \    add divisor to remainder and decrement quotient
\ 
\         2dup swap abs swap abs  ( n1 n2 u1 u2)     \ Absolute values
\ 
\         u/mod              ( n1 n2 urem uqout)     \ Unsigned divide
\         >r >r              ( n1 n2) ( uquot urem)
\ 
\         over 0< if         ( n1 n2) ( uquot urem)  
\             r> negate >r                   \ Negative dividend; negate remainder
\         then               ( n1 n2) ( uquot trem)
\    
\         swap over          ( n2 n1 n2) ( uquot trem)
\         xor 0< if          ( n2) ( uquot trem)
\             r> r>
\             negate         ( n2 trem tquot)  \ Opposite signs; negate quotient
\            -rot            ( tquot n2 trem)
\             dup 0<> if 
\                 +          ( tquot rem) \ Negative quotient & non-zero remainder
\                 swap 1-    ( rem quot)  \ add divisor to rem. & decrement  quot.
\             else
\                 nip swap   ( rem quot)
\             then
\         else
\             drop r> r>     ( rem quot)
\         then
\ 
\     else   \ Both factors non-negative
\ 
\         u/mod          ( rem quot)
\     then
\ ;

userarea-t constant init-user-area
1A06010 	 0 69 6E 69 74 2D 75 73 
1A06018 	65 72 2D 61 72 65 61 8E 
1A06020 	 4 60 A0  1 68 40 A0  1 
1A06028 	20  0  0  0 

\ Execute a Forth word given a pointer to a code field address
: perform   (s addr-of-acf -- )  token@ execute  ;
1A0602C 	70 65 72 66 
1A06030 	6F 72 6D 87 24 60 A0  1 
1A06038 	20 40 A0  1  C 54 A0  1 
1A06040 	98 41 A0  1 58 46 A0  1 

\ Select a vocabulary thread by hashing the lookup name.
code hash  (s str-addr voc-ptr -- thread )
1A06048 	 0  0  0 68 61 73 68 84 
1A06050 	38 60 A0  1 58 60 A0  1 
   ax pop
1A06058 	58 
   \ The next line is equivalent to ">threads", which in this
   \ implementation happens to be the same as ">body >user"
   /cf [ax] ax mov   ?bswap-ax   up ax add
1A06059 	8B 40  4  1 F8 

   dx pop
1A0605E 	5A 
[ifdef] big-endian-t
   bx bx xor
   1 [dx] bl mov		\ Get count byte
   #threads-t 1- #  bx  and	\ Modulo number of threads
   bx shl  bx shl		\ Convert to longword index
   bx ax add
[then]
   1push
1A0605F 	50 
c;
1A06060 	FF E7 

\ Search a vocabulary thread (link) for a name matching string.
\ If found, return its code field address and -1 if immediate, 1 if not
\ immediate.  If not found, return the string and 0.

\ Name field:
\     name: forth-style packed string, no tag bits
\     flag: 40 bit is immediate bit
\ Padding is optionally inserted between the name and the flags
\ so that the byte after the flag byte is on an even boundary.

code ($find-next)  (s adr len link -- adr len alf true  |  adr len false )
1A06062 	 0 28 24 66 69 6E 
1A06068 	64 2D 6E 65 78 74 29 8C 
1A06070 	54 60 A0  1 78 60 A0  1 
\ Registers:
\ ax     alf of word being tested
\ bx     string
\ si     anf of word being tested
\ dx     scratch
\ cx	 used as count for rep instruction

   ds ax mov  ax es mov	\ Ensure es is correct
1A06078 	8C D8 8E C0 

   ax		pop	\ link
1A0607C 	58 
   0 [sp]  dx	mov	\ string length (not consumed)
1A0607D 	8B 14 24 
   4 [sp]  bx	mov	\ string address (not consumed)
1A06080 	8B 5C 24  4 
   bp           push	\ Save RP
1A06084 	55 
   si		push	\ Save IP
1A06085 	56 
   di		push	\ Save UP
1A06086 	57 
   cx      cx   xor	\ Clear high bytes
1A06087 	31 
1A06088 	C9 

\+ rel-t   up bp mov            \ up (==di) is the origin, but we need to use di for string compare

\- rel-t   here-t 5 + #)  call	\ Figure out the origin address
1A06089 	E8  0  0  0  0 
\- rel-t   here-t
\- rel-t   bp pop
1A0608E 	5D 
\- rel-t   origin-t - #  bp  sub
1A0608F 	81 
1A06090 	ED 8E 60  0  0 

   ahead
1A06095 	EB 2A 
   begin

      /link #  ax  sub	\ >link
1A06097 	2D 
1A06098 	 4  0  0  0 
      ax       si  mov	\ Link address of word to test
1A0609C 	8B F0 

      si           dec  \ >length-byte
1A0609E 	4E 
      0 [si]   cl  mov	\ Get count/tag byte
1A0609F 	8A 
1A060A0 	 E 
      h# 1f #  cl  and	\ remove tag bits, leaving the word length in cl
1A060A1 	80 E1 1F 
      cx       si  sub	\ Skip back to beginning of name field
1A060A4 	29 CE 

      bx       di  mov	\ Get string address into compare register
1A060A6 	8B FB 
      repz byte cmps	\ Compare strings
1A060A8 	F3 A6 
      0= if		\ If the strings match, the Z bit will be set
1A060AA 	75 15 
                        \ Are the strings are the same length?
         0 [si]  cl  mov	\ Count/tag byte
1A060AC 	8A  E 
	 h# 1f # cl  and	\ remove tag bits
1A060AE 	80 E1 
1A060B0 	1F 
         dl      cl  cmp         
1A060B1 	38 D1 
         =  if			\ We found it ...
1A060B3 	75  C 
	    di       pop	\ Restore UP
1A060B5 	5F 
	    si	     pop	\ Restore IP
1A060B6 	5E 
	    bp       pop	\ Restore RP
1A060B7 	5D 

            ax       push	\ Push alf above pstr
1A060B8 	50 
            true #   ax  mov
1A060B9 	B8 FF FF FF FF 
	    1push  		\ True on top of stack means "found"
1A060BE 	50 
	    next
1A060BF 	FF 
1A060C0 	E7 
         then
      then

   but then
      \ The names did not match, so check the next name in the list
      0 [ax]  ax  mov	\ Fetch next link
1A060C1 	8B  0 
\+ rel-t bp ax add
   ax  bp  cmp	\ Test for end of list
1A060C3 	39 C5 
   0= until
1A060C5 	75 D0 

   \ If we get here, we've checked all the names with no luck
   di           pop     \ Restore UP
1A060C7 	5F 
   si		pop	\ Restore IP
1A060C8 	5E 
   bp           pop	\ Restore RP
1A060C9 	5D 
   ax       ax  xor
1A060CA 	31 C0 
   1push        	\ Return 0 for "not found"
1A060CC 	50 
c;
1A060CD 	FF E7 

: ?negate  (s n1 n2 -- n3 )  if  negate  then  ;
1A060CF 	 0 
1A060D0 	3F 6E 65 67 61 74 65 87 
1A060D8 	74 60 A0  1 20 40 A0  1 
1A060E0 	DC 41 A0  1  8  0  0  0 
1A060E8 	48 45 A0  1 58 46 A0  1 
: wflip  (s l1 -- l2 )  lwsplit swap wljoin  ;  \ word swap
1A060F0 	 0  0 77 66 6C 69 70 85 
1A060F8 	DC 60 A0  1 20 40 A0  1 
1A06100 	A0 4F A0  1 68 49 A0  1 
1A06108 	D4 4F A0  1 58 46 A0  1 

code cset    (s byte-mask addr -- )  bx pop  ax pop           al 0 [bx] or   c;
1A06110 	 0  0  0 63 73 65 74 84 
1A06118 	FC 60 A0  1 20 61 A0  1 
1A06120 	5B 58  8  3 FF E7 
code creset  (s byte-mask addr -- )  bx pop  ax pop  ax not   al 0 [bx] and  c;
1A06126 	 0  0 
1A06128 	 0 63 72 65 73 65 74 86 
1A06130 	1C 61 A0  1 38 61 A0  1 
1A06138 	5B 58 F7 D0 20  3 FF E7 
code ctoggle (s b addr -- )          bx pop  ax pop           al 0 [bx] xor  c;
1A06140 	63 74 6F 67 67 6C 65 87 
1A06148 	34 61 A0  1 50 61 A0  1 
1A06150 	5B 58 30  3 FF E7 
code toggle  (s addr byte-mask -- )  ax pop  bx pop           al 0 [bx] xor  c;
1A06156 	 0  0 
1A06158 	 0 74 6F 67 67 6C 65 86 
1A06160 	4C 61 A0  1 68 61 A0  1 
1A06168 	58 5B 30  3 FF E7 

code s->l (s n.signed -- l )   c;
1A0616E 	 0 73 
1A06170 	2D 3E 6C 84 64 61 A0  1 
1A06178 	7C 61 A0  1 FF E7 
code l->n (s l -- n )  c;
1A0617E 	 0 6C 
1A06180 	2D 3E 6E 84 78 61 A0  1 
1A06188 	8C 61 A0  1 FF E7 
code n->a (s n -- a )  c;
1A0618E 	 0 6E 
1A06190 	2D 3E 61 84 88 61 A0  1 
1A06198 	9C 61 A0  1 FF E7 
code l->w (s l -- w )  bx pop  ax ax xor  op: bx ax mov  1push c;
1A0619E 	 0 6C 
1A061A0 	2D 3E 77 84 98 61 A0  1 
1A061A8 	AC 61 A0  1 5B 31 C0 66 
1A061B0 	8B C3 50 FF E7 
code n->w (s n -- w )  bx pop  ax ax xor  op: bx ax mov  1push c;
1A061B5 	 0  0 6E 
1A061B8 	2D 3E 77 84 A8 61 A0  1 
1A061C0 	C4 61 A0  1 5B 31 C0 66 
1A061C8 	8B C3 50 FF E7 

code l>r  (s l -- )   ax pop   rp adec   ax 0 [rp] mov   c;
1A061CD 	 0  0  0 
1A061D0 	6C 3E 72 83 C0 61 A0  1 
1A061D8 	DC 61 A0  1 58 83 ED  4 
1A061E0 	89 45  0 FF E7 
code lr>  (s -- l )   0 [rp] ax mov   rp ainc   1push c;
1A061E5 	 0  0  0 
1A061E8 	6C 72 3E 83 D8 61 A0  1 
1A061F0 	F4 61 A0  1 8B 45  0 83 
1A061F8 	C5  4 50 FF E7 
code lr@  (s -- l )   0 [rp] ax mov             1push c;  
1A061FD 	 0  0  0 
1A06200 	6C 72 40 83 F0 61 A0  1 
1A06208 	 C 62 A0  1 8B 45  0 50 
1A06210 	FF E7 

code /t*  (s n -- n*/t )   ax pop   ax shl   ax shl   1push c;
1A06212 	 0  0 2F 74 2A 83 
1A06218 	 8 62 A0  1 20 62 A0  1 
1A06220 	58 D1 E0 D1 E0 50 FF E7 

: align  (s -- )  #align (align)  ;
1A06228 	 0  0 61 6C 69 67 6E 85 
1A06230 	1C 62 A0  1 20 40 A0  1 
1A06238 	54 5A A0  1 A8 5C A0  1 
1A06240 	58 46 A0  1 
: taligned  (s adr -- adr' )  #talign round-up  ;
1A06244 	 0  0  0 74 
1A06248 	61 6C 69 67 6E 65 64 88 
1A06250 	34 62 A0  1 20 40 A0  1 
1A06258 	68 5A A0  1 7C 5C A0  1 
1A06260 	58 46 A0  1 
: talign  (s -- )  #talign (align)  ;
1A06264 	 0 74 61 6C 
1A06268 	69 67 6E 86 54 62 A0  1 
1A06270 	20 40 A0  1 68 5A A0  1 
1A06278 	A8 5C A0  1 58 46 A0  1 

true constant in-little-endian?
1A06280 	 0  0 69 6E 2D 6C 69 74 
1A06288 	74 6C 65 2D 65 6E 64 69 
1A06290 	61 6E 3F 91 70 62 A0  1 
1A06298 	68 40 A0  1 FF FF FF FF 

\ [ifdef] big-endian-t
\ : >name   ( acf -- anf )
\    1- begin  1-  dup c@  bl >  until	\ Find the end of the name
\    /token 1- invert and		\ Move to token boundary
\    begin  dup c@  bl >=  while  /token -  repeat
\ ;
\ [then]

code lmove  ( src dst len -- )
1A062A0 	 0  0 6C 6D 6F 76 65 85 
1A062A8 	98 62 A0  1 B0 62 A0  1 
   di dx mov
1A062B0 	8B D7 
   cld
1A062B2 	FC 
   si bx mov
1A062B3 	8B DE 
   ds ax mov
1A062B5 	8C D8 
   ax es mov
1A062B7 	8E 
1A062B8 	C0 
   cx pop     \ Len
1A062B9 	59 
   di pop     \ dst
1A062BA 	5F 
   si pop     \ src
1A062BB 	5E 
   2 #  cx  shr  \ longword count
1A062BC 	C1 E9  2 
   repnz  movs
1A062BF 	F2 
1A062C0 	A5 
   bx si mov
1A062C1 	8B F3 
   dx di mov
1A062C3 	8B FA 
c;
1A062C5 	FF E7 

\ Code words to support the file system interface

\ signed mixed mode addition (same as + on 32-bit machines)
: ln+   (s n1 n2 -- n3 )  +  ;
1A062C7 	 0 
1A062C8 	6C 6E 2B 83 AC 62 A0  1 
1A062D0 	20 40 A0  1  4 45 A0  1 
1A062D8 	58 46 A0  1 

\ &ptr is the address of a pointer.  fetch the pointed-to
\ character and post-increment the pointer
 
[ifdef] big-endian-t
: @c@++  ( &ptr -- char )  dup @ c@  1 rot +!  ;
[else]
code @c@++ ( &ptr -- char )
1A062DC 	 0  0 40 63 
1A062E0 	40 2B 2B 85 D0 62 A0  1 
1A062E8 	EC 62 A0  1 
   bx pop   0 [bx] cx mov   ax ax sub  0 [cx] al mov
1A062EC 	5B 8B  B 29 
1A062F0 	C0 8A  1 
   cx inc   cx 0 [bx] mov   1push
1A062F3 	41 89  B 50 
c;
1A062F7 	FF 
1A062F8 	E7 
[then]
 
\ &ptr is the address of a pointer.  store the character into
\ the pointed-to location and post-increment the pointer

[ifdef] big-endian-t
: @c!++  ( char &ptr -- )  tuck @ c!  1 swap +!  ;
[else]
code @c!++ ( char &ptr -- )
1A062F9 	 0 40 63 21 2B 2B 85 
1A06300 	E8 62 A0  1  8 63 A0  1 
   bx pop   0 [bx] cx mov   ax pop   al 0 [cx] mov
1A06308 	5B 8B  B 58 88  1 
   cx inc   cx 0 [bx] mov
1A0630E 	41 89 
1A06310 	 B 
c;
1A06311 	FF E7 
[then]

\ Low-level character processing routines:
\ skipbl   -   skip leading white space     ( interpreter )
\ scanbl   -   collect non-white characters ( interpreter )
\ skipto   -   skip to next occurrence of a character ( comments )
\ scanto   -   collect characters until next occurrence of a character ( word )
\
\ These routines, used solely by getword, getcword, and skipcword,
\ are not intended to be called by the user.  They are written in code
\ so the compiler will be fast.
\
\ These perform roughly the same function as EXPECT in Fig-Forth, except
\ that they do the "right things":
\ a) They allow words to span buffer boundaries
\ b) If the delimiter is not blank, leading delimiters are NOT skipped.
\ c) If the delimiter is blank, leading delimiters are skipped,
\    furthermore all control characters are treated as delimiters.
\    Carriage returns, linefeeds, tabs, form-feeds, etc can thus be
\    included in files.
\ d) A separate word (skipcword) is used for skipping comments.
\    It does not store the characters it scans, so the comment can be
\    arbitrarily long without worry of overflowing the word buffer.

\ Nonblanks from the buffer starting at addr are appended to the end of str
code scanbl  ( endaddr addr str -- endaddr [ addr' ] delimiter )
1A06313 	 0  0 73 63 61 
1A06318 	6E 62 6C 86  4 63 A0  1 
1A06320 	24 63 A0  1 
   \ di - str   si - addr   bx - endaddr   ax - byte   cx - scr   dx - save
   si      dx   mov		\ Save IP
1A06324 	8B D6 
   ds      ax   mov   ax es mov \ Ensure es points to the right place
1A06326 	8C D8 
1A06328 	8E C0 
   ax           pop		\ destination string
1A0632A 	58 
   si           pop		\ buffer address (source string)
1A0632B 	5E 
   bx           pop		\ buffer end address
1A0632C 	5B 
\ cx pop cx push
   bx           push		\ end address is not consumed   
1A0632D 	53 
   di           push		\ Save UP
1A0632E 	57 
   ax      di   mov		\ Destination string
1A0632F 	8B 
1A06330 	F8 
   di	        push		\ temporarily store str start address on stack
1A06331 	57 
   ax      ax   sub		\ clear high bytes
1A06332 	29 C0 
   0 [di]  al   mov		\ Length byte of destination string
1A06334 	8A  7 
   di           inc		\ Address of destination string data
1A06336 	47 
   ax      di   add		\ End address of destination string
1A06337 	 1 
1A06338 	C7 
   begin
      bx   si   cmp		\ while not end of buffer
1A06339 	39 DE 
   u< while			\ Continue while more buffered bytes
1A0633B 	73 1A 
      al        lodsb		\ get the next character
1A0633D 	AC 
      \ The next line can't use "bl" because that looks like a register!
      h# 20 #  al  cmp		\ Look for a terminating white character
1A0633E 	3C 20 
      <= if			\ Exit if delimiter found
1A06340 	7F 12 
         0 #  0 [di]  movb	\ Null-terminate the string for jollies
1A06342 	C6  7  0 
	 cx           pop	\ Start address of destination string
1A06345 	59 
	 cx      di   sub	\ Calculate string length
1A06346 	29 CF 
	 di           dec	\ Don't count length byte in string length
1A06348 	4F 
         di      bx   mov
1A06349 	8B DF 
	 bl   0 [cx]  movb	\ Store string length
1A0634B 	88 19 
         di	      pop	\ Restore UP
1A0634D 	5F 
         si           push	\ Push addr'
1A0634E 	56 
         dx      si   mov	\ Restore IP
1A0634F 	8B 
1A06350 	F2 
	 1push			\ Actual delimiter on top of stack
1A06351 	50 
	 next
1A06352 	FF E7 
      then
      al        stosb		\ Append non-delimiter to destination string
1A06354 	AA 
      \ Haven't found the delimiter yet.
   repeat
1A06355 	EB E2 

   \ Ran out of buffer
   cx           pop	\ Start address of destination string
1A06357 	59 
   cx      di   sub	\ Calculate string length
1A06358 	29 CF 
   di           dec	\ Don't count length byte in string length
1A0635A 	4F 
   di      bx   mov
1A0635B 	8B DF 
   bl   0 [cx]  movb	\ Store string length
1A0635D 	88 19 

   dx      si   mov	\ Restore IP
1A0635F 	8B 
1A06360 	F2 
   -1 #    ax   mov
1A06361 	B8 FF FF FF FF 
   di           pop	\ Restore UP
1A06366 	5F 
   1push        	\ Return -1 as delimiter
1A06367 	50 
c;
1A06368 	FF E7 

code skipbl ( endaddr addr -- endaddr [ addr' ] delimiter )
1A0636A 	 0  0  0 73 6B 69 
1A06370 	70 62 6C 86 20 63 A0  1 
1A06378 	7C 63 A0  1 
   \ si - addr   bx - endaddr   ax - byte
   si      dx   mov     \ Save IP
1A0637C 	8B D6 
   si		pop	\ addr
1A0637E 	5E 
   bx		pop	\ endaddr
1A0637F 	5B 
   bx		push	\ endaddr is not consumed
1A06380 	53 
   ax      ax   sub     \ Clear high bits
1A06381 	29 C0 

   begin
      bx   si	cmp	\ while not end of buffer
1A06383 	39 DE 
   u< while
1A06385 	73  E 
      al	lodsb	\ get the next character (Delay slot)
1A06387 	AC 
      \ The next line can't use "bl" because that looks like a register!
      h# 20 #  al  cmp	\ Look for a terminating non-white character
1A06388 	3C 20 
      >  if
1A0638A 	7E  7 
         si	dec	\ Undo the extra increment (don't consume the char)
1A0638C 	4E 
         si	push	\ Push addr'
1A0638D 	56 
         dx  si mov     \ Restore IP
1A0638E 	8B F2 
	 1push		\ Actual delimiter on top of stack
1A06390 	50 
         next
1A06391 	FF E7 
      then
   \ Haven't found the delimiter yet.
   repeat
1A06393 	EB EE 
   \ Ran out of buffer
   dx       si  mov     \ Restore IP
1A06395 	8B F2 
   -1 #	    ax  mov
1A06397 	B8 
1A06398 	FF FF FF FF 
   1push        	\ Return -1 as delimiter
1A0639C 	50 
c;
1A0639D 	FF E7 

code scanto ( char endaddr addr str -- char endaddr [ addr' ] delimiter )
1A0639F 	 0 
1A063A0 	 0 73 63 61 6E 74 6F 86 
1A063A8 	78 63 A0  1 B0 63 A0  1 
   \ di - str   si - addr   bx - endaddr   ax - byte   cx - char   dx - save
   si      dx   mov		\ Save IP
1A063B0 	8B D6 
   ds      ax   mov   ax es mov \ Ensure es points to the right place
1A063B2 	8C D8 8E C0 
   ax           pop		\ destination string
1A063B6 	58 
   si           pop		\ buffer address (source string)
1A063B7 	5E 
   bx           pop		\ buffer end address
1A063B8 	5B 
   cx		pop		\ char
1A063B9 	59 
   cx		push		\ char is not consumed
1A063BA 	51 
   bx           push		\ end address is not consumed   
1A063BB 	53 
   di           push		\ Save UP
1A063BC 	57 
   ax      di   mov		\ destination string
1A063BD 	8B F8 
   di	        push		\ temporarily store str start address on stack
1A063BF 	57 
   ax      ax   sub		\ clear high bytes
1A063C0 	29 C0 
   0 [di]  al   mov		\ Length byte of destination string
1A063C2 	8A  7 
   di           inc		\ Address of destination string data
1A063C4 	47 
   ax      di   add		\ End address of destination string
1A063C5 	 1 C7 
   begin
      bx   si   cmp		\ while not end of buffer
1A063C7 	39 
1A063C8 	DE 
   u< while			\ Continue while more buffered bytes
1A063C9 	73 1A 
      al        lodsb		\ get the next character
1A063CB 	AC 
      cl    al  cmp		\ Look for a terminating delimiter character
1A063CC 	38 C8 
      = if			\ Exit if delimiter found
1A063CE 	75 12 
         0 #  0 [di]  movb	\ Null-terminate the string for jollies
1A063D0 	C6  7  0 
	 cx           pop	\ Start address of destination string
1A063D3 	59 
	 cx      di   sub	\ Calculate string length
1A063D4 	29 CF 
	 di           dec	\ Don't count length byte in string length
1A063D6 	4F 
         di      ax   mov
1A063D7 	8B 
1A063D8 	C7 
	 al   0 [cx]  movb	\ Store string length
1A063D9 	88  1 
         di           pop	\ Restore UP
1A063DB 	5F 
         si           push	\ Push addr'
1A063DC 	56 
         dx      si   mov	\ Restore IP
1A063DD 	8B F2 
	 1push			\ Actual delimiter on top of stack
1A063DF 	50 
	 next
1A063E0 	FF E7 
      then
      al        stosb		\ Append non-delimiter to destination string
1A063E2 	AA 
      \ Haven't found the delimiter yet.
   repeat
1A063E3 	EB E2 

   \ Ran out of buffer
   cx           pop	\ Start address of destination string
1A063E5 	59 
   cx      di   sub	\ Calculate string length
1A063E6 	29 CF 
   di           dec	\ Don't count length byte in string length
1A063E8 	4F 
   di      ax   mov
1A063E9 	8B C7 
   al   0 [cx]  movb	\ Store string length
1A063EB 	88  1 

   dx      si   mov	\ Restore IP
1A063ED 	8B F2 
   di           pop	\ Restore UP
1A063EF 	5F 
   -1 #    ax   mov
1A063F0 	B8 FF FF FF FF 
   1push        	\ Return -1 as delimiter
1A063F5 	50 
c;
1A063F6 	FF E7 

code skipto ( char endaddr addr -- char endaddr [ addr' ] delimiter )
1A063F8 	 0 73 6B 69 70 74 6F 86 
1A06400 	AC 63 A0  1  8 64 A0  1 
   \ di - addr   cx - endaddr-addr   ax - char
   ds ax mov  ax es mov \ Ensure es points to the right place
1A06408 	8C D8 8E C0 
   di      dx   mov	\ Save UP
1A0640C 	8B D7 
   di		pop	\ addr
1A0640E 	5F 
   cx		pop	\ endaddr
1A0640F 	59 
   ax		pop	\ char
1A06410 	58 
   ax		push	\ char is not consumed
1A06411 	50 
   cx		push	\ endaddr is not consumed
1A06412 	51 
   di      cx	sub	\ max count = endaddr-addr
1A06413 	29 F9 
   0<> if		\ Pre-test for max count = 0
1A06415 	74  A 
      repnz byte scas	\ Skip non-delimiters
1A06417 	F2 
1A06418 	AE 
      0= if		\ Did repnz terminate by finding a delimiter?
1A06419 	75  6 
         di	push	\ Push addr'
1A0641B 	57 
         dx  di mov	\ Restore UP
1A0641C 	8B FA 
         1push		\ Return actual delimiter (== char !)
1A0641E 	50 
         next
1A0641F 	FF 
1A06420 	E7 
      then
   \ Haven't found the delimiter yet.
   then

   \ Ran out of buffer
   dx     di mov	\ Restore UP
1A06421 	8B FA 
   -1 #	  ax mov
1A06423 	B8 FF FF FF FF 
   1push                \ Return -1 as delimiter
1A06428 	50 
c;
1A06429 	FF E7 
\ "adr1 len2" is the longest initial substring of the string "adr1 len1"
\ that does not contain the character "char".  "adr2 len1-len2" is the
\ trailing substring of "adr1 len1" that is not included in "adr1 len2".
\ Accordingly, if there are no occurrences of that character in "adr1 len1",
\ "len2" equals "len1", so the return values are "adr1 len1  adr1+len1 0"

code split-string  ( adr1 len1 char -- adr1 len2  adr1+len2 len1-len2 )
1A0642B 	73 70 6C 69 74 
1A06430 	2D 73 74 72 69 6E 67 8C 
1A06438 	 4 64 A0  1 40 64 A0  1 
   si dx mov		\ Save
1A06440 	8B D6 
   bx pop		\ char
1A06442 	5B 
   0 [sp] cx mov	\ len1
1A06443 	8B  C 24 
   4 [sp] si mov	\ adr1
1A06446 	8B 74 
1A06448 	24  4 

   ahead begin
1A0644A 	EB 10 
      al      lodsb	\ Get the next character
1A0644C 	AC 
      bl  al  cmp	\ Compare to delimiter
1A0644D 	38 D8 
      = if		\ Exit if delimiter found
1A0644F 	75 
1A06450 	 B 
         cx   inc	\ Account for pre-decrement of count
1A06451 	41 
	 cx 0 [sp] sub	\ len2
1A06452 	29  C 24 
	 si   dec	\ Account for incremented address
1A06455 	4E 
	 si   push	\ adr2
1A06456 	56 
	 cx   push	\ len1-len2
1A06457 	51 
         dx   si  mov	\ Restore
1A06458 	8B F2 
	 next
1A0645A 	FF E7 
      then
   but then
      cx dec
1A0645C 	49 
   0< until
1A0645D 	79 ED 

   \ The test character is not present in the input string

   si   push
1A0645F 	56 
   cx   inc		\ Account for pre-decrement of count
1A06460 	41 
   cx   push
1A06461 	51 

   dx si mov		\ Restore
1A06462 	8B F2 
c;
1A06464 	FF E7 

\ Splits a buffer into two parts around the first line delimiter
\ sequence.  A line delimiter sequence is either CR, LF, CR followed by LF,
\ or LF followed by CR.
\ adr1 len2 is the initial substring before, but not including,
\ the first line delimiter sequence.
\ adr2 len3 is the trailing substring after, but not including,
\ the first line delimiter sequence.

code parse-line  ( adr1 len1 -- adr1 len2  adr1+len2 len1-len2 )
1A06466 	 0  0 
1A06468 	 0 70 61 72 73 65 2D 6C 
1A06470 	69 6E 65 8A 3C 64 A0  1 
1A06478 	7C 64 A0  1 
   si dx mov		\ Save
1A0647C 	8B D6 
   0 [sp] cx mov	\ len1
1A0647E 	8B  C 
1A06480 	24 
   4 [sp] si mov	\ adr1
1A06481 	8B 74 24  4 
   h# 0a #  bh  mov	\ Delimiter 1
1A06485 	B7  A 
   h# 0d #  bl  mov	\ Delimiter 2
1A06487 	B3 
1A06488 	 D 

   ahead begin
1A06489 	EB 26 
      al      lodsb	\ Get the next character
1A0648B 	AC 
      bh al cmp  <> if  bl al cmp  then  \ Compare to delimiters
1A0648C 	38 F8 74  2 
1A06490 	38 D8 

      = if		\ Exit if delimiter found
1A06492 	75 1D 
         cx inc			\ len2 doesn't include the delimiter
1A06494 	41 
	 cx  0 [sp]  sub	\ len2
1A06495 	29  C 24 
         cx dec
1A06498 	49 
         \ Check next character too, unless we're at the end of the buffer
         0<>  if
1A06499 	74 10 
            0 [si]  ah  mov	\ Get next character
1A0649B 	8A 26 
            bh al cmp  = if	\ Compare it to the other delimiter
1A0649D 	38 F8 75 
1A064A0 	 4 
	       bl ah cmp
1A064A1 	38 DC 
            else
1A064A3 	EB  2 
	       bh ah cmp
1A064A5 	38 FC 
            then
	    =  if
1A064A7 	75 
1A064A8 	 2 
               cx   dec		\ Consume the second delimiter too
1A064A9 	49 
	       si   inc		\ Consume the second delimiter too
1A064AA 	46 
            then
         then
	 si   push	\ adr2
1A064AB 	56 
	 cx   push	\ len1-len2
1A064AC 	51 
         dx   si  mov	\ Restore
1A064AD 	8B F2 
	 next
1A064AF 	FF 
1A064B0 	E7 
      then
   but then
      cx dec
1A064B1 	49 
   0< until
1A064B2 	79 D7 

   \ There is no line delimiter in the input string

   si   push
1A064B4 	56 
   cx   inc		\ Account for pre-decrement of count
1A064B5 	41 
   cx   push
1A064B6 	51 

   dx si mov		\ Restore
1A064B7 	8B 
1A064B8 	F2 
c;
1A064B9 	FF E7 

code skipwhite  ( adr len -- adr' len' )
1A064BB 	 0  0  0 73 6B 
1A064C0 	69 70 77 68 69 74 65 89 
1A064C8 	78 64 A0  1 D0 64 A0  1 
   si dx mov
1A064D0 	8B D6 
   cld
1A064D2 	FC 
   cx pop
1A064D3 	59 
   cx cx or  0<>  if
1A064D4 	 9 C9 74 10 
      si pop
1A064D8 	5E 
      begin
         al lods
1A064D9 	AC 
         h# 20 # al cmp  >  if
1A064DA 	3C 20 7E  7 
            si dec  si push
1A064DE 	4E 56 
            cx push  dx si mov
1A064E0 	51 8B F2 
            next
1A064E3 	FF E7 
         then
      loopa
1A064E5 	E2 F2 
      si push
1A064E7 	56 
   then
   cx push
1A064E8 	51 
   dx si mov
1A064E9 	8B F2 
c;
1A064EB 	FF E7 

\ Adr2 points to the delimiter or to the end of the buffer
\ Adr3 points to the character after the delimiter or to the end of the buffer
code scantowhite  ( adr1 len1 -- adr1 adr2 adr3 )
1A064ED 	 0  0  0 
1A064F0 	73 63 61 6E 74 6F 77 68 
1A064F8 	69 74 65 8B CC 64 A0  1 
1A06500 	 4 65 A0  1 
   si dx mov
1A06504 	8B D6 
   cld
1A06506 	FC 
   cx pop
1A06507 	59 
   0 [sp] si mov
1A06508 	8B 34 24 
   cx cx or  0<>  if
1A0650B 	 9 C9 74  F 
      begin
         al lods
1A0650F 	AC 
         h# 20 # al cmp  <=  if
1A06510 	3C 20 7F  8 
            si dec si push
1A06514 	4E 56 
            si inc si push
1A06516 	46 56 
            dx si mov
1A06518 	8B F2 
            next
1A0651A 	FF E7 
         then
      loopa
1A0651C 	E2 F1 
   then
   si push
1A0651E 	56 
   si push
1A0651F 	56 
   dx si mov
1A06520 	8B F2 
c;
1A06522 	FF E7 

code skipchar  ( adr len char -- adr' len' )
1A06524 	 0  0  0 73 
1A06528 	6B 69 70 63 68 61 72 88 
1A06530 	 0 65 A0  1 38 65 A0  1 
   si dx mov
1A06538 	8B D6 
   cld
1A0653A 	FC 
   bx pop         \ char in bx
1A0653B 	5B 
   cx pop
1A0653C 	59 
   cx cx or  0<>  if
1A0653D 	 9 C9 74 
1A06540 	 B 
      si pop
1A06541 	5E 
      begin
         al lods
1A06542 	AC 
         bl al cmp
1A06543 	38 D8 
      loope
1A06545 	E1 FB 
      0<>  if  cx inc  si dec  then
1A06547 	74 
1A06548 	 2 41 4E 
      si push
1A0654B 	56 
   then
   cx push
1A0654C 	51 
   dx si mov
1A0654D 	8B F2 
c;
1A0654F 	FF 
1A06550 	E7 

\ Adr2 points to the delimiter or to the end of the buffer
\ Adr3 points to the character after the delimiter or to the end of the buffer
code scantochar  ( adr1 len1 char -- adr1 adr2 adr3 )
1A06551 	73 63 61 6E 74 6F 63 
1A06558 	68 61 72 8A 34 65 A0  1 
1A06560 	64 65 A0  1 
   si dx mov
1A06564 	8B D6 
   cld
1A06566 	FC 
   bx pop
1A06567 	5B 
   cx pop
1A06568 	59 
   0 [sp] si mov
1A06569 	8B 34 24 
   cx cx or  0<>  if
1A0656C 	 9 C9 74  F 
      begin
         al lods
1A06570 	AC 
         bl al cmp
1A06571 	38 D8 
      loopne
1A06573 	E0 FB 
      =  if
1A06575 	75  8 
         si dec si push
1A06577 	4E 
1A06578 	56 
         si inc si push
1A06579 	46 56 
         dx si mov
1A0657B 	8B F2 
         next
1A0657D 	FF E7 
      then
   then
   si push
1A0657F 	56 
   si push
1A06580 	56 
   dx si mov
1A06581 	8B F2 
c;
1A06583 	FF E7 

/n-t 8 * constant bits/cell
1A06585 	 0 62 69 
1A06588 	74 73 2F 63 65 6C 6C 89 
1A06590 	60 65 A0  1 68 40 A0  1 
1A06598 	20  0  0  0 

defer (is
1A0659C 	28 69 73 83 
1A065A0 	94 65 A0  1 5C 40 A0  1 
1A065A8 	34  0  0  0 

: (is)  ( acf -- )  ip> dup ta1+ >ip  token@ (is  ;
1A065AC 	 0  0  0 28 
1A065B0 	69 73 29 84 A4 65 A0  1 
1A065B8 	20 40 A0  1 84 46 A0  1 
1A065C0 	40 49 A0  1 FC 50 A0  1 
1A065C8 	6C 46 A0  1  C 54 A0  1 
1A065D0 	A4 65 A0  1 58 46 A0  1 

OpenFirmware/cpu/x86/kerncode.fth_AL	25B8 1A065D8 

decimal

user-size-t constant user-size
1A065D8 	 0  0 75 73 65 72 2D 73 
1A065E0 	69 7A 65 89 B8 65 A0  1 
1A065E8 	68 40 A0  1  0 40  0  0 

\ Initial user number


nuser link       \ link to next task
1A065F0 	 0  0  0 6C 69 6E 6B 84 
1A065F8 	E8 65 A0  1 48 40 A0  1 
1A06600 	38  0  0  0 
nuser entry      \ entry address for this task
1A06604 	 0  0 65 6E 
1A06608 	74 72 79 85 FC 65 A0  1 
1A06610 	48 40 A0  1 3C  0  0  0 
nuser saved-ip
1A06618 	 0  0  0 73 61 76 65 64 
1A06620 	2D 69 70 88 10 66 A0  1 
1A06628 	48 40 A0  1 40  0  0  0 
nuser saved-rp
1A06630 	 0  0  0 73 61 76 65 64 
1A06638 	2D 72 70 88 28 66 A0  1 
1A06640 	48 40 A0  1 44  0  0  0 
nuser saved-sp
1A06648 	 0  0  0 73 61 76 65 64 
1A06650 	2D 73 70 88 40 66 A0  1 
1A06658 	48 40 A0  1 48  0  0  0 
\ next 2 user variables are used for booting
nuser up0     \ initial up
1A06660 	75 70 30 83 58 66 A0  1 
1A06668 	48 40 A0  1 4C  0  0  0 
nuser #user   \ next available user location
1A06670 	 0  0 23 75 73 65 72 85 
1A06678 	68 66 A0  1 48 40 A0  1 
1A06680 	50  0  0  0 
nuser sp0          \ initial parameter stack
1A06684 	73 70 30 83 
1A06688 	7C 66 A0  1 48 40 A0  1 
1A06690 	54  0  0  0 
nuser rp0          \ initial return stack
1A06694 	72 70 30 83 
1A06698 	8C 66 A0  1 48 40 A0  1 
1A066A0 	58  0  0  0 

\ This is the beginning of the initialization chain
: init  ( -- )  up@ link !  ;	\ Initially, only one task is active
1A066A4 	 0  0  0 69 
1A066A8 	6E 69 74 84 9C 66 A0  1 
1A066B0 	20 40 A0  1 5C 45 A0  1 
1A066B8 	FC 65 A0  1 54 4D A0  1 
1A066C0 	58 46 A0  1 

/n constant #ualign
1A066C4 	23 75 61 6C 
1A066C8 	69 67 6E 87 B0 66 A0  1 
1A066D0 	68 40 A0  1  4  0  0  0 
: ualigned  ( n -- n' )  #ualign round-up  ;
1A066D8 	 0  0  0 75 61 6C 69 67 
1A066E0 	6E 65 64 88 D0 66 A0  1 
1A066E8 	20 40 A0  1 D0 66 A0  1 
1A066F0 	7C 5C A0  1 58 46 A0  1 



OpenFirmware/forth/kernel/uservars.fth_AL	288 1A066F8 purpose: Double number primitives

headers

: d0=   ( d -- flag )  or  0=  ;
1A066F8 	64 30 3D 83 E8 66 A0  1 
1A06700 	20 40 A0  1 70 44 A0  1 
1A06708 	24 47 A0  1 58 46 A0  1 
: d0<>  ( d -- flag )  or  0<>  ;
1A06710 	 0  0  0 64 30 3C 3E 84 
1A06718 	 0 67 A0  1 20 40 A0  1 
1A06720 	70 44 A0  1 44 47 A0  1 
1A06728 	58 46 A0  1 
: d0<   ( d -- flag )  nip 0<  ;
1A0672C 	64 30 3C 83 
1A06730 	1C 67 A0  1 20 40 A0  1 
1A06738 	FC 46 A0  1 64 47 A0  1 
1A06740 	58 46 A0  1 
: d=    ( d1 d2 -- flag )  d- d0=  ;
1A06744 	 0 64 3D 82 
1A06748 	34 67 A0  1 20 40 A0  1 
1A06750 	F8 5D A0  1  0 67 A0  1 
1A06758 	58 46 A0  1 
: d<>   ( d1 d2 -- flag )  d=  0=  ;
1A0675C 	64 3C 3E 83 
1A06760 	4C 67 A0  1 20 40 A0  1 
1A06768 	4C 67 A0  1 24 47 A0  1 
1A06770 	58 46 A0  1 
: du<   ( ud1 ud2 -- flag )  rot  swap  2dup <>  if  2swap  then  2drop u<  ;
1A06774 	64 75 3C 83 
1A06778 	64 67 A0  1 20 40 A0  1 
1A06780 	7C 49 A0  1 68 49 A0  1 
1A06788 	C0 49 A0  1 44 48 A0  1 
1A06790 	DC 41 A0  1  8  0  0  0 
1A06798 	F4 49 A0  1 AC 49 A0  1 
1A067A0 	A8 48 A0  1 58 46 A0  1 
: d<    ( d1 d2 -- flag )  2 pick over = if drop nip u< else nip < nip then  ;
1A067A8 	 0 64 3C 82 7C 67 A0  1 
1A067B0 	20 40 A0  1 58 41 A0  1 
1A067B8 	 2  0  0  0  C 4A A0  1 
1A067C0 	54 49 A0  1 24 48 A0  1 
1A067C8 	DC 41 A0  1 18  0  0  0 
1A067D0 	30 49 A0  1 FC 46 A0  1 
1A067D8 	A8 48 A0  1 C8 41 A0  1 
1A067E0 	10  0  0  0 FC 46 A0  1 
1A067E8 	E4 47 A0  1 FC 46 A0  1 
1A067F0 	58 46 A0  1 
: d>=   ( d1 d2 -- flag )  d< 0=  ;
1A067F4 	64 3E 3D 83 
1A067F8 	B0 67 A0  1 20 40 A0  1 
1A06800 	B0 67 A0  1 24 47 A0  1 
1A06808 	58 46 A0  1 
: d>    ( d1 d2 -- flag )  2swap d<  ;
1A0680C 	 0 64 3E 82 
1A06810 	FC 67 A0  1 20 40 A0  1 
1A06818 	F4 49 A0  1 B0 67 A0  1 
1A06820 	58 46 A0  1 
: d<=   ( d1 d2 -- flag )  2swap d< 0=  ;
1A06824 	64 3C 3D 83 
1A06828 	14 68 A0  1 20 40 A0  1 
1A06830 	F4 49 A0  1 B0 67 A0  1 
1A06838 	24 47 A0  1 58 46 A0  1 
: dnegate  ( d -- -d )  0 0  2swap  d-  ;
1A06840 	64 6E 65 67 61 74 65 87 
1A06848 	2C 68 A0  1 20 40 A0  1 
1A06850 	58 41 A0  1  0  0  0  0 
1A06858 	58 41 A0  1  0  0  0  0 
1A06860 	F4 49 A0  1 F8 5D A0  1 
1A06868 	58 46 A0  1 
: dabs     ( d -- +d )  2dup  d0<  if  dnegate  then  ;
1A0686C 	 0  0  0 64 
1A06870 	61 62 73 84 4C 68 A0  1 
1A06878 	20 40 A0  1 C0 49 A0  1 
1A06880 	34 67 A0  1 DC 41 A0  1 
1A06888 	 8  0  0  0 4C 68 A0  1 
1A06890 	58 46 A0  1 

: s>d   ( n -- d )  dup 0<  ;
1A06894 	73 3E 64 83 
1A06898 	78 68 A0  1 20 40 A0  1 
1A068A0 	40 49 A0  1 64 47 A0  1 
1A068A8 	58 46 A0  1 
: u>d   ( u -- d )  0  ;
1A068AC 	75 3E 64 83 
1A068B0 	9C 68 A0  1 20 40 A0  1 
1A068B8 	58 41 A0  1  0  0  0  0 
1A068C0 	58 46 A0  1 
: d>s   ( d -- n )  drop  ;
1A068C4 	64 3E 73 83 
1A068C8 	B4 68 A0  1 20 40 A0  1 
1A068D0 	30 49 A0  1 58 46 A0  1 

: d2*   ( xd1 -- xd2 )  2*  over 0<  if  1+  then  swap  2*  swap  ;
1A068D8 	64 32 2A 83 CC 68 A0  1 
1A068E0 	20 40 A0  1 A0 4B A0  1 
1A068E8 	54 49 A0  1 64 47 A0  1 
1A068F0 	DC 41 A0  1  8  0  0  0 
1A068F8 	30 4B A0  1 68 49 A0  1 
1A06900 	A0 4B A0  1 68 49 A0  1 
1A06908 	58 46 A0  1 
: d2/   ( xd1 -- xd2 )
1A0690C 	64 32 2F 83 
1A06910 	E0 68 A0  1 20 40 A0  1 
   dup 2/  swap 1 and  rot 1 rshift  swap
1A06918 	40 49 A0  1 78 4B A0  1 
1A06920 	68 49 A0  1 58 41 A0  1 
1A06928 	 1  0  0  0 5C 44 A0  1 
1A06930 	7C 49 A0  1 58 41 A0  1 
1A06938 	 1  0  0  0 B4 44 A0  1 
1A06940 	68 49 A0  1 
64\ d# 63
32\ d# 31
1A06944 	58 41 A0  1 
1A06948 	1F  0  0  0 
16\ d# 15
   lshift  or  swap
1A0694C 	9C 44 A0  1 
1A06950 	70 44 A0  1 68 49 A0  1 
;
1A06958 	58 46 A0  1 

: dmax  ( xd1 xd2 -- )  2over 2over d<  if  2swap  then  2drop  ;
1A0695C 	 0  0  0 64 
1A06960 	6D 61 78 84 14 69 A0  1 
1A06968 	20 40 A0  1 D8 49 A0  1 
1A06970 	D8 49 A0  1 B0 67 A0  1 
1A06978 	DC 41 A0  1  8  0  0  0 
1A06980 	F4 49 A0  1 AC 49 A0  1 
1A06988 	58 46 A0  1 
: dmin  ( xd1 xd2 -- )  2over 2over d<  0=  if  2swap  then  2drop  ;
1A0698C 	 0  0  0 64 
1A06990 	6D 69 6E 84 68 69 A0  1 
1A06998 	20 40 A0  1 D8 49 A0  1 
1A069A0 	D8 49 A0  1 B0 67 A0  1 
1A069A8 	24 47 A0  1 DC 41 A0  1 
1A069B0 	 8  0  0  0 F4 49 A0  1 
1A069B8 	AC 49 A0  1 58 46 A0  1 

: m+    ( d1|ud1 n -- )  s>d  d+  ;
1A069C0 	 0 6D 2B 82 98 69 A0  1 
1A069C8 	20 40 A0  1 9C 68 A0  1 
1A069D0 	E0 5D A0  1 58 46 A0  1 
: 2rot  ( d1 d2 d3 -- d2 d3 d1 )  2>r 2swap 2r> 2swap  ;
1A069D8 	 0  0  0 32 72 6F 74 84 
1A069E0 	C8 69 A0  1 20 40 A0  1 
1A069E8 	F8 45 A0  1 F4 49 A0  1 
1A069F0 	10 46 A0  1 F4 49 A0  1 
1A069F8 	58 46 A0  1 
: 2nip  ( $1 $2 -- $2 )  2swap 2drop  ;
1A069FC 	 0  0  0 32 
1A06A00 	6E 69 70 84 E4 69 A0  1 
1A06A08 	20 40 A0  1 F4 49 A0  1 
1A06A10 	AC 49 A0  1 58 46 A0  1 

: drot  ( d1 d2 d3 -- d2 d3 d1 )  2>r 2swap 2r> 2swap  ;
1A06A18 	 0  0  0 64 72 6F 74 84 
1A06A20 	 8 6A A0  1 20 40 A0  1 
1A06A28 	F8 45 A0  1 F4 49 A0  1 
1A06A30 	10 46 A0  1 F4 49 A0  1 
1A06A38 	58 46 A0  1 
: -drot ( d1 d2 d3 -- d3 d1 d2 )  drot drot  ;
1A06A3C 	 0  0 2D 64 
1A06A40 	72 6F 74 85 24 6A A0  1 
1A06A48 	20 40 A0  1 24 6A A0  1 
1A06A50 	24 6A A0  1 58 46 A0  1 
: dinvert  ( d1 -- d2 )  swap invert  swap invert  ;
1A06A58 	64 69 6E 76 65 72 74 87 
1A06A60 	48 6A A0  1 20 40 A0  1 
1A06A68 	68 49 A0  1 30 45 A0  1 
1A06A70 	68 49 A0  1 30 45 A0  1 
1A06A78 	58 46 A0  1 
\ EOF
: dlshift  ( d1 n -- d2 )
1A06A7C 	64 6C 73 68 
1A06A80 	69 66 74 87 64 6A A0  1 
1A06A88 	20 40 A0  1 
   tuck lshift >r                           ( low n  r: high2 )
1A06A8C 	E8 46 A0  1 
1A06A90 	9C 44 A0  1 BC 45 A0  1 
   2dup bits/cell  swap - rshift  r> or >r  ( low n  r: high2' )
1A06A98 	C0 49 A0  1 94 65 A0  1 
1A06AA0 	68 49 A0  1 18 45 A0  1 
1A06AA8 	B4 44 A0  1 D0 45 A0  1 
1A06AB0 	70 44 A0  1 BC 45 A0  1 
   lshift r>                                ( d2 )
1A06AB8 	9C 44 A0  1 D0 45 A0  1 
;
1A06AC0 	58 46 A0  1 
: drshift  ( d1 n -- d2 )
1A06AC4 	64 72 73 68 
1A06AC8 	69 66 74 87 88 6A A0  1 
1A06AD0 	20 40 A0  1 
   2dup rshift >r                           ( low high n  r: high2 )
1A06AD4 	C0 49 A0  1 
1A06AD8 	B4 44 A0  1 BC 45 A0  1 
   tuck  bits/cell swap - lshift            ( low n low2  r: high2 )
1A06AE0 	E8 46 A0  1 94 65 A0  1 
1A06AE8 	68 49 A0  1 18 45 A0  1 
1A06AF0 	9C 44 A0  1 
   -rot  rshift  or                         ( low2  r: high2 )
1A06AF4 	94 49 A0  1 
1A06AF8 	B4 44 A0  1 70 44 A0  1 
   r>                                       ( d2 )
1A06B00 	D0 45 A0  1 
;
1A06B04 	58 46 A0  1 
: d>>a  ( d1 n -- d2 )
1A06B08 	 0  0  0 64 3E 3E 61 84 
1A06B10 	D0 6A A0  1 20 40 A0  1 
   2dup rshift >r                           ( low high n  r: high2 )
1A06B18 	C0 49 A0  1 B4 44 A0  1 
1A06B20 	BC 45 A0  1 
   tuck  bits/cell swap - lshift            ( low n low2  r: high2 )
1A06B24 	E8 46 A0  1 
1A06B28 	94 65 A0  1 68 49 A0  1 
1A06B30 	18 45 A0  1 9C 44 A0  1 
   -rot  >>a  or                            ( low2  r: high2 )
1A06B38 	94 49 A0  1 F0 44 A0  1 
1A06B40 	70 44 A0  1 
   r>                                       ( d2 )
1A06B44 	D0 45 A0  1 
;
1A06B48 	58 46 A0  1 
: du*  ( d1 u -- d2 )  \ Double result
1A06B4C 	64 75 2A 83 
1A06B50 	14 6B A0  1 20 40 A0  1 
   tuck u* >r     ( d1.lo u r: d2.hi )
1A06B58 	E8 46 A0  1 34 5F A0  1 
1A06B60 	BC 45 A0  1 
   um*  r> +      ( d2 )
1A06B64 	50 5D A0  1 
1A06B68 	D0 45 A0  1  4 45 A0  1 
;
1A06B70 	58 46 A0  1 
: du*t  ( ud.lo ud.hi u -- res.lo res.mid res.hi )  \ Triple result
1A06B74 	 0  0  0 64 
1A06B78 	75 2A 74 84 54 6B A0  1 
1A06B80 	20 40 A0  1 
   tuck um*  2>r  ( ud.lo u          r: res.mid0 res.hi0 )
1A06B84 	E8 46 A0  1 
1A06B88 	50 5D A0  1 F8 45 A0  1 
   um*            ( res.lo res.mid1  r: res.mid0 res.hi0 )
1A06B90 	50 5D A0  1 
   0  2r> d+      ( res.lo res.mid res.hi )
1A06B94 	58 41 A0  1 
1A06B98 	 0  0  0  0 10 46 A0  1 
1A06BA0 	E0 5D A0  1 
;
1A06BA4 	58 46 A0  1 

OpenFirmware/forth/kernel/double.fth_AL	1200 1A06BA8 \ Relocation table.  
\ Keeps a bitmap identifying longwords that need to be relocated
\ if they are saved to a file.

variable memtop
1A06BA8 	 0 6D 65 6D 74 6F 70 86 
1A06BB0 	80 6B A0  1 48 40 A0  1 
1A06BB8 	5C  0  0  0 

: max-image  ( -- #bytes )  memtop @  origin -  ;
1A06BBC 	 0  0 6D 61 
1A06BC0 	78 2D 69 6D 61 67 65 89 
1A06BC8 	B4 6B A0  1 20 40 A0  1 
1A06BD0 	B4 6B A0  1 5C 4C A0  1 
1A06BD8 	50 55 A0  1 18 45 A0  1 
1A06BE0 	58 46 A0  1 

OpenFirmware/cpu/x86/kernrel.fth_AL	60 1A06BE4 
vocset=5D87AD 1A0024C 1A0C1A4 \ From io.fth

decimal

\ Emit is a two-level vector.
\ The low level is (emit and the high level is emit.
\ The low-level vector just selects the output device.
\ The high-level vector performs other processing such as keeping
\ track of the current position on the line, pausing, etc.
\ Terminal control with escape sequences should use the low-level vector
\ to prevent a pause from garbling the escape sequence.
\ Key is a two-level vector.
\ The low level is (key and the high level is key.
\ The low-level vector just selects the output device.
\ The high-level vector performs other processing such as switching
\ the input stream between different windows.

defer (type  ( adr len -- ) \ Low-level type; just outputs characters
1A06BE4 	 0  0 28 74 
1A06BE8 	79 70 65 85 CC 6B A0  1 
1A06BF0 	5C 40 A0  1 60  0  0  0 
defer type   ( adr len -- ) \ High-level type
1A06BF8 	 0  0  0 74 79 70 65 84 
1A06C00 	F0 6B A0  1 5C 40 A0  1 
1A06C08 	64  0  0  0 
defer (emit ( c -- )   \ Low level emit; just puts out the character
1A06C0C 	 0  0 28 65 
1A06C10 	6D 69 74 85  4 6C A0  1 
1A06C18 	5C 40 A0  1 68  0  0  0 
defer emit  ( c -- )   \ Higher level; keeps track of position on the line, etc
1A06C20 	 0  0  0 65 6D 69 74 84 
1A06C28 	18 6C A0  1 5C 40 A0  1 
1A06C30 	6C  0  0  0 
defer (key  ( -- c )   \ Low level key; just gets key
1A06C34 	 0  0  0 28 
1A06C38 	6B 65 79 84 2C 6C A0  1 
1A06C40 	5C 40 A0  1 70  0  0  0 
defer key   ( -- c )   \ Higher level; may do other nonsense
1A06C48 	6B 65 79 83 40 6C A0  1 
1A06C50 	5C 40 A0  1 74  0  0  0 
defer key?   ( -- f )   \ Is a character waiting?
1A06C58 	 0  0  0 6B 65 79 3F 84 
1A06C60 	50 6C A0  1 5C 40 A0  1 
1A06C68 	78  0  0  0 
defer bye    ( -- )     \ Exit to the operating system, if any
1A06C6C 	62 79 65 83 
1A06C70 	64 6C A0  1 5C 40 A0  1 
1A06C78 	7C  0  0  0 
defer error-exit  ( -- )  \ Error exit to the operating system
1A06C7C 	 0 65 72 72 
1A06C80 	6F 72 2D 65 78 69 74 8A 
1A06C88 	74 6C A0  1 5C 40 A0  1 
1A06C90 	80  0  0  0 
defer (interactive? ( -- f ) \ Is input coming from the keyboard?
1A06C94 	 0  0 28 69 
1A06C98 	6E 74 65 72 61 63 74 69 
1A06CA0 	76 65 3F 8D 8C 6C A0  1 
1A06CA8 	5C 40 A0  1 84  0  0  0 
defer interactive? ( -- f ) \ Is input coming from the keyboard?
1A06CB0 	 0  0  0 69 6E 74 65 72 
1A06CB8 	61 63 74 69 76 65 3F 8C 
1A06CC0 	A8 6C A0  1 5C 40 A0  1 
1A06CC8 	88  0  0  0 
' (interactive? is interactive?

defer accept  ( adr len -- )	\ Read up to len characters from keyboard
1A06CCC 	 0 61 63 63 
1A06CD0 	65 70 74 86 C4 6C A0  1 
1A06CD8 	5C 40 A0  1 8C  0  0  0 

defer alloc-mem  ( #bytes -- address )
1A06CE0 	 0  0 61 6C 6C 6F 63 2D 
1A06CE8 	6D 65 6D 89 D8 6C A0  1 
1A06CF0 	5C 40 A0  1 90  0  0  0 
defer free-mem   ( adr #bytes -- )
1A06CF8 	 0  0  0 66 72 65 65 2D 
1A06D00 	6D 65 6D 88 F0 6C A0  1 
1A06D08 	5C 40 A0  1 94  0  0  0 
defer resize     ( adr #bytes -- adr' ior )
1A06D10 	 0 72 65 73 69 7A 65 86 
1A06D18 	 8 6D A0  1 5C 40 A0  1 
1A06D20 	98  0  0  0 

defer sync-cache  ( adr len -- )  ' 2drop is sync-cache
1A06D24 	 0 73 79 6E 
1A06D28 	63 2D 63 61 63 68 65 8A 
1A06D30 	1C 6D A0  1 5C 40 A0  1 
1A06D38 	9C  0  0  0 
defer $getenv     ( adr len -- false | adr' len' true )
1A06D3C 	24 67 65 74 
1A06D40 	65 6E 76 87 34 6D A0  1 
1A06D48 	5C 40 A0  1 A0  0  0  0 

defer #out   ( -- adr )
1A06D50 	 0  0  0 23 6F 75 74 84 
1A06D58 	48 6D A0  1 5C 40 A0  1 
1A06D60 	A4  0  0  0 
defer #line  ( -- adr )
1A06D64 	 0  0 23 6C 
1A06D68 	69 6E 65 85 5C 6D A0  1 
1A06D70 	5C 40 A0  1 A8  0  0  0 
defer cr     ( -- )
1A06D78 	 0 63 72 82 70 6D A0  1 
1A06D80 	5C 40 A0  1 AC  0  0  0 

defer [ immediate
1A06D88 	 0  0 5B C1 80 6D A0  1 
1A06D90 	5C 40 A0  1 B0  0  0  0 
defer ]
1A06D98 	 0  0 5D 81 90 6D A0  1 
1A06DA0 	5C 40 A0  1 B4  0  0  0 

defer pause  \ for multitasking
1A06DA8 	 0  0 70 61 75 73 65 85 
1A06DB0 	A0 6D A0  1 5C 40 A0  1 
1A06DB8 	B8  0  0  0 

defer $header
1A06DBC 	24 68 65 61 
1A06DC0 	64 65 72 87 B4 6D A0  1 
1A06DC8 	5C 40 A0  1 BC  0  0  0 

defer header		\ Create a new word
1A06DD0 	 0 68 65 61 64 65 72 86 
1A06DD8 	C8 6D A0  1 5C 40 A0  1 
1A06DE0 	C0  0  0  0 

: bounds  (s adr len -- adr+len adr )  over + swap  ;
1A06DE4 	 0 62 6F 75 
1A06DE8 	6E 64 73 86 DC 6D A0  1 
1A06DF0 	20 40 A0  1 54 49 A0  1 
1A06DF8 	 4 45 A0  1 68 49 A0  1 
1A06E00 	58 46 A0  1 

\ Default actions
: key1  ( -- char )  begin  pause key?  until  (key  ;
1A06E04 	 0  0  0 6B 
1A06E08 	65 79 31 84 F0 6D A0  1 
1A06E10 	20 40 A0  1 B4 6D A0  1 
1A06E18 	64 6C A0  1 DC 41 A0  1 
1A06E20 	F4 FF FF FF 40 6C A0  1 
1A06E28 	58 46 A0  1 
: emit1  ( char -- )  pause (emit 1 #out +!  ;
1A06E2C 	 0  0 65 6D 
1A06E30 	69 74 31 85 10 6E A0  1 
1A06E38 	20 40 A0  1 B4 6D A0  1 
1A06E40 	18 6C A0  1 58 41 A0  1 
1A06E48 	 1  0  0  0 5C 6D A0  1 
1A06E50 	 C 4C A0  1 58 46 A0  1 
: type1  ( adr len -- )  pause  dup #out +!  (type  ;
1A06E58 	 0  0 74 79 70 65 31 85 
1A06E60 	38 6E A0  1 20 40 A0  1 
1A06E68 	B4 6D A0  1 40 49 A0  1 
1A06E70 	5C 6D A0  1  C 4C A0  1 
1A06E78 	F0 6B A0  1 58 46 A0  1 
: default-type  ( adr len -- )
1A06E80 	 0  0  0 64 65 66 61 75 
1A06E88 	6C 74 2D 74 79 70 65 8C 
1A06E90 	64 6E A0  1 20 40 A0  1 
   0 max  bounds ?do  pause  i c@ (emit  loop
1A06E98 	58 41 A0  1  0  0  0  0 
1A06EA0 	9C 4A A0  1 F0 6D A0  1 
1A06EA8 	50 42 A0  1 1C  0  0  0 
1A06EB0 	B4 6D A0  1 B4 42 A0  1 
1A06EB8 	C4 4C A0  1 18 6C A0  1 
1A06EC0 	F8 41 A0  1 EC FF FF FF 
;
1A06EC8 	58 46 A0  1 
: null-$getenv  ( adr len -- true )  2drop true  ;
1A06ECC 	 0  0  0 6E 
1A06ED0 	75 6C 6C 2D 24 67 65 74 
1A06ED8 	65 6E 76 8C 94 6E A0  1 
1A06EE0 	20 40 A0  1 AC 49 A0  1 
1A06EE8 	CC 56 A0  1 58 46 A0  1 

\ headerless		\ from campus version
nuser (#out        \ number of characters emitted
1A06EF0 	 0  0 28 23 6F 75 74 85 
1A06EF8 	E0 6E A0  1 48 40 A0  1 
1A06F00 	C4  0  0  0 
\ headers		\ from campus version
nuser (#line       \ the number of lines sent so far
1A06F04 	 0 28 23 6C 
1A06F08 	69 6E 65 86 FC 6E A0  1 
1A06F10 	48 40 A0  1 C8  0  0  0 


\ Install defaults
' emit1       is emit
' type1       is type
' key1        is key
' (#out       is #out
' (#line      is #line
' null-$getenv  is $getenv

decimal

 7 constant bell
1A06F18 	 0  0  0 62 65 6C 6C 84 
1A06F20 	10 6F A0  1 68 40 A0  1 
1A06F28 	 7  0  0  0 
 8 constant bs
1A06F2C 	 0 62 73 82 
1A06F30 	24 6F A0  1 68 40 A0  1 
1A06F38 	 8  0  0  0 
10 constant linefeed
1A06F3C 	 0  0  0 6C 
1A06F40 	69 6E 65 66 65 65 64 88 
1A06F48 	34 6F A0  1 68 40 A0  1 
1A06F50 	 A  0  0  0 
13 constant carret
1A06F54 	 0 63 61 72 
1A06F58 	72 65 74 86 4C 6F A0  1 
1A06F60 	68 40 A0  1  D  0  0  0 


\ Kernel colon definitions
decimal
 0 constant 0     1 constant 1      2 constant 2      3 constant 3
1A06F68 	 0  0 30 81 60 6F A0  1 
1A06F70 	68 40 A0  1  0  0  0  0 
1A06F78 	 0  0 31 81 70 6F A0  1 
1A06F80 	68 40 A0  1  1  0  0  0 
1A06F88 	 0  0 32 81 80 6F A0  1 
1A06F90 	68 40 A0  1  2  0  0  0 
1A06F98 	 0  0 33 81 90 6F A0  1 
1A06FA0 	68 40 A0  1  3  0  0  0 
 4 constant 4     5 constant 5      6 constant 6      7 constant 7
1A06FA8 	 0  0 34 81 A0 6F A0  1 
1A06FB0 	68 40 A0  1  4  0  0  0 
1A06FB8 	 0  0 35 81 B0 6F A0  1 
1A06FC0 	68 40 A0  1  5  0  0  0 
1A06FC8 	 0  0 36 81 C0 6F A0  1 
1A06FD0 	68 40 A0  1  6  0  0  0 
1A06FD8 	 0  0 37 81 D0 6F A0  1 
1A06FE0 	68 40 A0  1  7  0  0  0 
 8 constant 8
1A06FE8 	 0  0 38 81 E0 6F A0  1 
1A06FF0 	68 40 A0  1  8  0  0  0 
-1 constant true  0 constant false \ mmo
1A06FF8 	 0  0  0 74 72 75 65 84 
1A07000 	F0 6F A0  1 68 40 A0  1 
1A07008 	FF FF FF FF  0  0 66 61 
1A07010 	6C 73 65 85  4 70 A0  1 
1A07018 	68 40 A0  1  0  0  0  0 
32 constant bl
1A07020 	 0 62 6C 82 18 70 A0  1 
1A07028 	68 40 A0  1 20  0  0  0 
\ 64 constant c/l

d# 1024 constant /tib
1A07030 	 0  0  0 2F 74 69 62 84 
1A07038 	28 70 A0  1 68 40 A0  1 
1A07040 	 0  4  0  0 

: roll    (s nk nk-1 ... n1 n0 k -- nk-1 ... n1 n0 nk )
1A07044 	 0  0  0 72 
1A07048 	6F 6C 6C 84 3C 70 A0  1 
1A07050 	20 40 A0  1 
   >r  r@ pick   sp@ dup  na1+
1A07054 	BC 45 A0  1 
1A07058 	E4 45 A0  1  C 4A A0  1 
1A07060 	6C 45 A0  1 40 49 A0  1 
1A07068 	CC 50 A0  1 
   r> 1+ /n*
1A0706C 	D0 45 A0  1 
1A07070 	30 4B A0  1 98 51 A0  1 
   cmove> drop
1A07078 	34 44 A0  1 30 49 A0  1 
;
1A07080 	58 46 A0  1 

: 2rot  (s a b c d e f -- c d e f a b )  5 roll  5 roll  ;
1A07084 	 0  0  0 32 
1A07088 	72 6F 74 84 50 70 A0  1 
1A07090 	20 40 A0  1 C0 6F A0  1 
1A07098 	50 70 A0  1 C0 6F A0  1 
1A070A0 	50 70 A0  1 58 46 A0  1 

: ?dup   (s n -- [n] n )  dup if   dup   then   ;
1A070A8 	 0  0  0 3F 64 75 70 84 
1A070B0 	90 70 A0  1 20 40 A0  1 
1A070B8 	40 49 A0  1 DC 41 A0  1 
1A070C0 	 8  0  0  0 40 49 A0  1 
1A070C8 	58 46 A0  1 
: between (s n min max -- f )  >r over <= swap r> <= and  ;
1A070CC 	62 65 74 77 
1A070D0 	65 65 6E 87 B4 70 A0  1 
1A070D8 	20 40 A0  1 BC 45 A0  1 
1A070E0 	54 49 A0  1  C 49 A0  1 
1A070E8 	68 49 A0  1 D0 45 A0  1 
1A070F0 	 C 49 A0  1 5C 44 A0  1 
1A070F8 	58 46 A0  1 
: within  (s n1 min max+1 -- f )  over -  >r - r> u<  ;
1A070FC 	 0 77 69 74 
1A07100 	68 69 6E 86 D8 70 A0  1 
1A07108 	20 40 A0  1 54 49 A0  1 
1A07110 	18 45 A0  1 BC 45 A0  1 
1A07118 	18 45 A0  1 D0 45 A0  1 
1A07120 	A8 48 A0  1 58 46 A0  1 

\ Obsolescent, but required by the IEEE 1275 device interface
nuser span			\ number of characters received by expect
1A07128 	 0  0  0 73 70 61 6E 84 
1A07130 	 8 71 A0  1 48 40 A0  1 
1A07138 	CC  0  0  0 
: expect  ( adr len -- )  accept span !  ;
1A0713C 	 0 65 78 70 
1A07140 	65 63 74 86 34 71 A0  1 
1A07148 	20 40 A0  1 D8 6C A0  1 
1A07150 	34 71 A0  1 54 4D A0  1 
1A07158 	58 46 A0  1 

defer newline-pstring
1A0715C 	6E 65 77 6C 
1A07160 	69 6E 65 2D 70 73 74 72 
1A07168 	69 6E 67 8F 48 71 A0  1 
1A07170 	5C 40 A0  1 D0  0  0  0 
: newline-string  ( -- adr len )  newline-pstring count  ;
1A07178 	 0 6E 65 77 6C 69 6E 65 
1A07180 	2D 73 74 72 69 6E 67 8E 
1A07188 	70 71 A0  1 20 40 A0  1 
1A07190 	70 71 A0  1 BC 53 A0  1 
1A07198 	58 46 A0  1 
: newline  ( -- char )  newline-string + 1-  c@  ; \ Last character
1A0719C 	6E 65 77 6C 
1A071A0 	69 6E 65 87 8C 71 A0  1 
1A071A8 	20 40 A0  1 8C 71 A0  1 
1A071B0 	 4 45 A0  1 54 4B A0  1 
1A071B8 	C4 4C A0  1 58 46 A0  1 

: space  (s -- )   bl emit   ;
1A071C0 	 0  0 73 70 61 63 65 85 
1A071C8 	A8 71 A0  1 20 40 A0  1 
1A071D0 	28 70 A0  1 2C 6C A0  1 
1A071D8 	58 46 A0  1 
: spaces   (s n -- )   0  max  0 ?do  space  loop  ;
1A071DC 	 0 73 70 61 
1A071E0 	63 65 73 86 CC 71 A0  1 
1A071E8 	20 40 A0  1 70 6F A0  1 
1A071F0 	9C 4A A0  1 70 6F A0  1 
1A071F8 	50 42 A0  1 10  0  0  0 
1A07200 	CC 71 A0  1 F8 41 A0  1 
1A07208 	F8 FF FF FF 58 46 A0  1 
: backspaces  (s n -- )  dup negate #out +!  0 ?do bs (emit loop  ;
1A07210 	 0 62 61 63 6B 73 70 61 
1A07218 	63 65 73 8A E8 71 A0  1 
1A07220 	20 40 A0  1 40 49 A0  1 
1A07228 	48 45 A0  1 5C 6D A0  1 
1A07230 	 C 4C A0  1 70 6F A0  1 
1A07238 	50 42 A0  1 14  0  0  0 
1A07240 	34 6F A0  1 18 6C A0  1 
1A07248 	F8 41 A0  1 F4 FF FF FF 
1A07250 	58 46 A0  1 
: beep  (s -- )  bell (emit  ;
1A07254 	 0  0  0 62 
1A07258 	65 65 70 84 20 72 A0  1 
1A07260 	20 40 A0  1 24 6F A0  1 
1A07268 	18 6C A0  1 58 46 A0  1 
: (lf  (s -- )  1 #line +!  linefeed (emit  ;
1A07270 	28 6C 66 83 60 72 A0  1 
1A07278 	20 40 A0  1 80 6F A0  1 
1A07280 	70 6D A0  1  C 4C A0  1 
1A07288 	4C 6F A0  1 18 6C A0  1 
1A07290 	58 46 A0  1 
: (cr  (s -- )  carret (emit  ;
1A07294 	28 63 72 83 
1A07298 	78 72 A0  1 20 40 A0  1 
1A072A0 	60 6F A0  1 18 6C A0  1 
1A072A8 	58 46 A0  1 
: lf   (s -- )  #out off  (lf  ;
1A072AC 	 0 6C 66 82 
1A072B0 	9C 72 A0  1 20 40 A0  1 
1A072B8 	5C 6D A0  1 F8 4B A0  1 
1A072C0 	78 72 A0  1 58 46 A0  1 
: crlf   (s -- )  (cr lf  ;
1A072C8 	 0  0  0 63 72 6C 66 84 
1A072D0 	B4 72 A0  1 20 40 A0  1 
1A072D8 	9C 72 A0  1 B4 72 A0  1 
1A072E0 	58 46 A0  1 


: erase      (s adr len -- )   0 fill   ;
1A072E4 	 0  0 65 72 
1A072E8 	61 73 65 85 D4 72 A0  1 
1A072F0 	20 40 A0  1 70 6F A0  1 
1A072F8 	8C 4E A0  1 58 46 A0  1 
: blank      (s adr len -- )   bl fill   ;
1A07300 	 0  0 62 6C 61 6E 6B 85 
1A07308 	F0 72 A0  1 20 40 A0  1 
1A07310 	28 70 A0  1 8C 4E A0  1 
1A07318 	58 46 A0  1 
: depth      (s -- n )         sp@ sp0 @ swap - /n /   ;
1A0731C 	 0  0 64 65 
1A07320 	70 74 68 85  C 73 A0  1 
1A07328 	20 40 A0  1 6C 45 A0  1 
1A07330 	8C 66 A0  1 5C 4C A0  1 
1A07338 	68 49 A0  1 18 45 A0  1 
1A07340 	40 51 A0  1 98 5F A0  1 
1A07348 	58 46 A0  1 
: clear      (s ?? -- Empty )  sp0 @ sp!  ;
1A0734C 	 0  0 63 6C 
1A07350 	65 61 72 85 28 73 A0  1 
1A07358 	20 40 A0  1 8C 66 A0  1 
1A07360 	5C 4C A0  1 9C 45 A0  1 
1A07368 	58 46 A0  1 

/a constant /link
1A0736C 	 0  0 2F 6C 
1A07370 	69 6E 6B 85 58 73 A0  1 
1A07378 	68 40 A0  1  4  0  0  0 

\ Address conversion operators
: n>link   ( anf -- alf )  1+  ;
1A07380 	 0 6E 3E 6C 69 6E 6B 86 
1A07388 	78 73 A0  1 20 40 A0  1 
1A07390 	30 4B A0  1 58 46 A0  1 
: l>name   ( alf -- anf )  1- ;
1A07398 	 0 6C 3E 6E 61 6D 65 86 
1A073A0 	8C 73 A0  1 20 40 A0  1 
1A073A8 	54 4B A0  1 58 46 A0  1 
: n>flags  ( anf -- aff )  ;
1A073B0 	6E 3E 66 6C 61 67 73 87 
1A073B8 	A4 73 A0  1 20 40 A0  1 
1A073C0 	58 46 A0  1 
: link>    ( alf -- acf )  /link +  ;
1A073C4 	 0  0 6C 69 
1A073C8 	6E 6B 3E 85 BC 73 A0  1 
1A073D0 	20 40 A0  1 78 73 A0  1 
1A073D8 	 4 45 A0  1 58 46 A0  1 
: >link    ( acf -- alf )  /link -  ;
1A073E0 	 0  0 3E 6C 69 6E 6B 85 
1A073E8 	D0 73 A0  1 20 40 A0  1 
1A073F0 	78 73 A0  1 18 45 A0  1 
1A073F8 	58 46 A0  1 
: name>    ( anf -- acf )  n>link link>  ;
1A073FC 	 0  0 6E 61 
1A07400 	6D 65 3E 85 EC 73 A0  1 
1A07408 	20 40 A0  1 8C 73 A0  1 
1A07410 	D0 73 A0  1 58 46 A0  1 
defer >name
1A07418 	 0  0 3E 6E 61 6D 65 85 
1A07420 	 8 74 A0  1 5C 40 A0  1 
1A07428 	D4  0  0  0 
: >flags   ( acf -- aff )  >name n>flags  ;
1A0742C 	 0 3E 66 6C 
1A07430 	61 67 73 86 24 74 A0  1 
1A07438 	20 40 A0  1 24 74 A0  1 
1A07440 	BC 73 A0  1 58 46 A0  1 
: name>string  ( anf -- adr len )  dup c@ h# 1f and  tuck - swap  ;
1A07448 	6E 61 6D 65 3E 73 74 72 
1A07450 	69 6E 67 8B 38 74 A0  1 
1A07458 	20 40 A0  1 40 49 A0  1 
1A07460 	C4 4C A0  1 58 41 A0  1 
1A07468 	1F  0  0  0 5C 44 A0  1 
1A07470 	E8 46 A0  1 18 45 A0  1 
1A07478 	68 49 A0  1 58 46 A0  1 
: l>beginning  ( alf -- adr )  l>name name>string drop  ;
1A07480 	6C 3E 62 65 67 69 6E 6E 
1A07488 	69 6E 67 8B 58 74 A0  1 
1A07490 	20 40 A0  1 A4 73 A0  1 
1A07498 	58 74 A0  1 30 49 A0  1 
1A074A0 	58 46 A0  1 
: @user#  (s apf -- user# )
1A074A4 	 0 40 75 73 
1A074A8 	65 72 23 86 90 74 A0  1 
1A074B0 	20 40 A0  1 
\t32  l@
1A074B4 	6C 4C A0  1 
\t16  w@
;
1A074B8 	58 46 A0  1 
: >user  (s pfa -- addr-of-user-var )  @user# up@ +  ;
1A074BC 	 0  0 3E 75 
1A074C0 	73 65 72 85 B0 74 A0  1 
1A074C8 	20 40 A0  1 B0 74 A0  1 
1A074D0 	5C 45 A0  1  4 45 A0  1 
1A074D8 	58 46 A0  1 
: >threads  ( acf -- ath )  >body >user  ;
1A074DC 	 0  0  0 3E 
1A074E0 	74 68 72 65 61 64 73 88 
1A074E8 	C8 74 A0  1 20 40 A0  1 
1A074F0 	E4 59 A0  1 C8 74 A0  1 
1A074F8 	58 46 A0  1 

0 value tib
1A074FC 	74 69 62 83 
1A07500 	EC 74 A0  1 50 40 A0  1 
1A07508 	D8  0  0  0 

0 value #-buf
1A0750C 	 0  0 23 2D 
1A07510 	62 75 66 85  4 75 A0  1 
1A07518 	50 40 A0  1 DC  0  0  0 
headerless
: init  ( -- )  init
1A07520 	 0  0  0 69 6E 69 74 84 
1A07528 	18 75 A0  1 20 40 A0  1 
1A07530 	B0 66 A0  1 
   [ /n h# 10 * 8 + ] literal dup alloc-mem + is #-buf
1A07534 	58 41 A0  1 
1A07538 	48  0  0  0 40 49 A0  1 
1A07540 	F0 6C A0  1  4 45 A0  1 
1A07548 	B8 65 A0  1 18 75 A0  1 
   /tib    alloc-mem   is tib
1A07550 	3C 70 A0  1 F0 6C A0  1 
1A07558 	B8 65 A0  1  4 75 A0  1 
;
1A07560 	58 46 A0  1 
headers

: compile,  (s cfa -- )  token, ;
1A07564 	 0  0  0 63 
1A07568 	6F 6D 70 69 6C 65 2C 88 
1A07570 	2C 75 A0  1 20 40 A0  1 
1A07578 	2C 55 A0  1 58 46 A0  1 
: compile  (s -- )   ip> dup ta1+ >ip   token@ compile,  ;
1A07580 	63 6F 6D 70 69 6C 65 87 
1A07588 	74 75 A0  1 20 40 A0  1 
1A07590 	84 46 A0  1 40 49 A0  1 
1A07598 	FC 50 A0  1 6C 46 A0  1 
1A075A0 	 C 54 A0  1 74 75 A0  1 
1A075A8 	58 46 A0  1 

nuser base         \ for numeric input and output
1A075AC 	 0  0  0 62 
1A075B0 	61 73 65 84 8C 75 A0  1 
1A075B8 	48 40 A0  1 E0  0  0  0 

nuser hld          \ points to last character held in #-buf
1A075C0 	68 6C 64 83 B8 75 A0  1 
1A075C8 	48 40 A0  1 E4  0  0  0 
: hold   (s char -- )   -1 hld +!   hld @ c!   ;
1A075D0 	 0  0  0 68 6F 6C 64 84 
1A075D8 	C8 75 A0  1 20 40 A0  1 
1A075E0 	58 41 A0  1 FF FF FF FF 
1A075E8 	C8 75 A0  1  C 4C A0  1 
1A075F0 	C8 75 A0  1 5C 4C A0  1 
1A075F8 	B8 4D A0  1 58 46 A0  1 
: <#     (s -- )     #-buf  hld  !  ;
1A07600 	 0 3C 23 82 DC 75 A0  1 
1A07608 	20 40 A0  1 18 75 A0  1 
1A07610 	C8 75 A0  1 54 4D A0  1 
1A07618 	58 46 A0  1 
: sign   (s n -- )  0< if  ascii -  hold  then  ;
1A0761C 	 0  0  0 73 
1A07620 	69 67 6E 84  8 76 A0  1 
1A07628 	20 40 A0  1 64 47 A0  1 
1A07630 	DC 41 A0  1 10  0  0  0 
1A07638 	58 41 A0  1 2D  0  0  0 
1A07640 	DC 75 A0  1 58 46 A0  1 
\ for upper case hex output, change 39 to 7
: >digit (s n -- char )  dup 9 >  if  39 +  then  48 +  ;
1A07648 	 0 3E 64 69 67 69 74 86 
1A07650 	28 76 A0  1 20 40 A0  1 
1A07658 	40 49 A0  1 58 41 A0  1 
1A07660 	 9  0  0  0  4 48 A0  1 
1A07668 	DC 41 A0  1 10  0  0  0 
1A07670 	58 41 A0  1 27  0  0  0 
1A07678 	 4 45 A0  1 58 41 A0  1 
1A07680 	30  0  0  0  4 45 A0  1 
1A07688 	58 46 A0  1 
: u#     (s u1 -- u2 )
1A0768C 	 0 75 23 82 
1A07690 	54 76 A0  1 20 40 A0  1 
   base @ u/mod  ( nrem u2 )   swap  >digit  hold    ( u2 )
1A07698 	B8 75 A0  1 5C 4C A0  1 
1A076A0 	74 5F A0  1 68 49 A0  1 
1A076A8 	54 76 A0  1 DC 75 A0  1 
;
1A076B0 	58 46 A0  1 
: u#s    (s u -- 0 )     begin  u#  dup   0=  until  ;
1A076B4 	75 23 73 83 
1A076B8 	94 76 A0  1 20 40 A0  1 
1A076C0 	94 76 A0  1 40 49 A0  1 
1A076C8 	24 47 A0  1 DC 41 A0  1 
1A076D0 	F0 FF FF FF 58 46 A0  1 
: u#>    (s u -- addr len )    drop  hld  @  #-buf  over  -  ;
1A076D8 	75 23 3E 83 BC 76 A0  1 
1A076E0 	20 40 A0  1 30 49 A0  1 
1A076E8 	C8 75 A0  1 5C 4C A0  1 
1A076F0 	18 75 A0  1 54 49 A0  1 
1A076F8 	18 45 A0  1 58 46 A0  1 

: mu/mod (s d n1 -- rem d.quot )
1A07700 	 0 6D 75 2F 6D 6F 64 86 
1A07708 	E0 76 A0  1 20 40 A0  1 
   >r  0  r@  um/mod  r>  swap  >r  um/mod  r>
1A07710 	BC 45 A0  1 70 6F A0  1 
1A07718 	E4 45 A0  1 7C 5D A0  1 
1A07720 	D0 45 A0  1 68 49 A0  1 
1A07728 	BC 45 A0  1 7C 5D A0  1 
1A07730 	D0 45 A0  1 
;
1A07734 	58 46 A0  1 

: #      (s ud1 -- ud2 )
1A07738 	 0  0 23 81  C 77 A0  1 
1A07740 	20 40 A0  1 
   base @ mu/mod ( nrem ud2 )  rot     >digit  hold    ( ud2 )
1A07744 	B8 75 A0  1 
1A07748 	5C 4C A0  1  C 77 A0  1 
1A07750 	7C 49 A0  1 54 76 A0  1 
1A07758 	DC 75 A0  1 
;
1A0775C 	58 46 A0  1 
: #s     (s ud -- 0 0 )  begin   #  2dup or  0=  until  ;
1A07760 	 0 23 73 82 40 77 A0  1 
1A07768 	20 40 A0  1 40 77 A0  1 
1A07770 	C0 49 A0  1 70 44 A0  1 
1A07778 	24 47 A0  1 DC 41 A0  1 
1A07780 	EC FF FF FF 58 46 A0  1 
: #>     (s ud -- addr len )     drop  u#>  ;
1A07788 	 0 23 3E 82 68 77 A0  1 
1A07790 	20 40 A0  1 30 49 A0  1 
1A07798 	E0 76 A0  1 58 46 A0  1 

: (u.)  (s u -- a len )  <# u#s u#>   ;
1A077A0 	 0  0  0 28 75 2E 29 84 
1A077A8 	90 77 A0  1 20 40 A0  1 
1A077B0 	 8 76 A0  1 BC 76 A0  1 
1A077B8 	E0 76 A0  1 58 46 A0  1 
: u.    (s u -- )       (u.)   type space   ;
1A077C0 	 0 75 2E 82 AC 77 A0  1 
1A077C8 	20 40 A0  1 AC 77 A0  1 
1A077D0 	 4 6C A0  1 CC 71 A0  1 
1A077D8 	58 46 A0  1 
: u.r   (s u len -- )     >r   (u.)   r> over - spaces   type   ;
1A077DC 	75 2E 72 83 
1A077E0 	C8 77 A0  1 20 40 A0  1 
1A077E8 	BC 45 A0  1 AC 77 A0  1 
1A077F0 	D0 45 A0  1 54 49 A0  1 
1A077F8 	18 45 A0  1 E8 71 A0  1 
1A07800 	 4 6C A0  1 58 46 A0  1 
: (.)   (s n -- a len )   dup abs  <# u#s   swap sign   u#>   ;
1A07808 	28 2E 29 83 E4 77 A0  1 
1A07810 	20 40 A0  1 40 49 A0  1 
1A07818 	24 4A A0  1  8 76 A0  1 
1A07820 	BC 76 A0  1 68 49 A0  1 
1A07828 	28 76 A0  1 E0 76 A0  1 
1A07830 	58 46 A0  1 
: s.    (s n -- )       (.)   type space   ;
1A07834 	 0 73 2E 82 
1A07838 	10 78 A0  1 20 40 A0  1 
1A07840 	10 78 A0  1  4 6C A0  1 
1A07848 	CC 71 A0  1 58 46 A0  1 
: .r    (s n l -- )     >r   (.)   r> over - spaces   type   ;
1A07850 	 0 2E 72 82 3C 78 A0  1 
1A07858 	20 40 A0  1 BC 45 A0  1 
1A07860 	10 78 A0  1 D0 45 A0  1 
1A07868 	54 49 A0  1 18 45 A0  1 
1A07870 	E8 71 A0  1  4 6C A0  1 
1A07878 	58 46 A0  1 
: 0.r   (s n l -- )     >r (u.) r> over - 0 max  0  ?do  ascii 0 emit  loop  type ;
1A0787C 	30 2E 72 83 
1A07880 	58 78 A0  1 20 40 A0  1 
1A07888 	BC 45 A0  1 AC 77 A0  1 
1A07890 	D0 45 A0  1 54 49 A0  1 
1A07898 	18 45 A0  1 70 6F A0  1 
1A078A0 	9C 4A A0  1 70 6F A0  1 
1A078A8 	50 42 A0  1 18  0  0  0 
1A078B0 	58 41 A0  1 30  0  0  0 
1A078B8 	2C 6C A0  1 F8 41 A0  1 
1A078C0 	F0 FF FF FF  4 6C A0  1 
1A078C8 	58 46 A0  1 

: (.2)  (s u -- a len )  <# u# u# u#>   ;
1A078CC 	 0  0  0 28 
1A078D0 	2E 32 29 84 84 78 A0  1 
1A078D8 	20 40 A0  1  8 76 A0  1 
1A078E0 	94 76 A0  1 94 76 A0  1 
1A078E8 	E0 76 A0  1 58 46 A0  1 
: (.4)  (s u -- a len )  <# u# u# u# u# u#>   ;
1A078F0 	 0  0  0 28 2E 34 29 84 
1A078F8 	D8 78 A0  1 20 40 A0  1 
1A07900 	 8 76 A0  1 94 76 A0  1 
1A07908 	94 76 A0  1 94 76 A0  1 
1A07910 	94 76 A0  1 E0 76 A0  1 
1A07918 	58 46 A0  1 
: (.8)  (s u -- a len )  <# u# u# u# u# u# u# u# u# u#>   ;
1A0791C 	 0  0  0 28 
1A07920 	2E 38 29 84 FC 78 A0  1 
1A07928 	20 40 A0  1  8 76 A0  1 
1A07930 	94 76 A0  1 94 76 A0  1 
1A07938 	94 76 A0  1 94 76 A0  1 
1A07940 	94 76 A0  1 94 76 A0  1 
1A07948 	94 76 A0  1 94 76 A0  1 
1A07950 	E0 76 A0  1 58 46 A0  1 
: .2   (s n -- )   (.2)  type space  ;
1A07958 	 0 2E 32 82 28 79 A0  1 
1A07960 	20 40 A0  1 D8 78 A0  1 
1A07968 	 4 6C A0  1 CC 71 A0  1 
1A07970 	58 46 A0  1 

[ifndef] run-time
headerless
: (ul.) (s ul -- a l )  n->l  <# u#s u#>   ;
1A07974 	 0  0 28 75 
1A07978 	6C 2E 29 85 60 79 A0  1 
1A07980 	20 40 A0  1 74 4F A0  1 
1A07988 	 8 76 A0  1 BC 76 A0  1 
1A07990 	E0 76 A0  1 58 46 A0  1 
headers
: ul.   (s ul -- )      (ul.)   type space   ;
1A07998 	75 6C 2E 83 80 79 A0  1 
1A079A0 	20 40 A0  1 80 79 A0  1 
1A079A8 	 4 6C A0  1 CC 71 A0  1 
1A079B0 	58 46 A0  1 
headerless
: ul.r  (s ul l -- )    >r   (ul.)   r> over - spaces   type  ;
1A079B4 	 0  0  0 75 
1A079B8 	6C 2E 72 84 A0 79 A0  1 
1A079C0 	20 40 A0  1 BC 45 A0  1 
1A079C8 	80 79 A0  1 D0 45 A0  1 
1A079D0 	54 49 A0  1 18 45 A0  1 
1A079D8 	E8 71 A0  1  4 6C A0  1 
1A079E0 	58 46 A0  1 

: (l.)  (s l -- a l )   dup l->n swap  abs   <# u#s   swap sign  u#>   ;
1A079E4 	 0  0  0 28 
1A079E8 	6C 2E 29 84 C0 79 A0  1 
1A079F0 	20 40 A0  1 40 49 A0  1 
1A079F8 	88 61 A0  1 68 49 A0  1 
1A07A00 	24 4A A0  1  8 76 A0  1 
1A07A08 	BC 76 A0  1 68 49 A0  1 
1A07A10 	28 76 A0  1 E0 76 A0  1 
1A07A18 	58 46 A0  1 
headers
: l.    (s l -- )       base @ d# 10 = if (l.) else (ul.) then type space   ;
1A07A1C 	 0 6C 2E 82 
1A07A20 	F0 79 A0  1 20 40 A0  1 
1A07A28 	B8 75 A0  1 5C 4C A0  1 
1A07A30 	58 41 A0  1  A  0  0  0 
1A07A38 	24 48 A0  1 DC 41 A0  1 
1A07A40 	10  0  0  0 F0 79 A0  1 
1A07A48 	C8 41 A0  1  8  0  0  0 
1A07A50 	80 79 A0  1  4 6C A0  1 
1A07A58 	CC 71 A0  1 58 46 A0  1 
headerless
: l.r   (s l l -- )     >r   (l.)   r> over - spaces   type   ;
1A07A60 	6C 2E 72 83 24 7A A0  1 
1A07A68 	20 40 A0  1 BC 45 A0  1 
1A07A70 	F0 79 A0  1 D0 45 A0  1 
1A07A78 	54 49 A0  1 18 45 A0  1 
1A07A80 	E8 71 A0  1  4 6C A0  1 
1A07A88 	58 46 A0  1 
headers
[then]

\ smart print that knows that signed hex numbers are uninteresting
: .    (s n -- ) base @ 10 = if s. else u. then  ;
1A07A8C 	 0  0 2E 81 
1A07A90 	68 7A A0  1 20 40 A0  1 
1A07A98 	B8 75 A0  1 5C 4C A0  1 
1A07AA0 	58 41 A0  1  A  0  0  0 
1A07AA8 	24 48 A0  1 DC 41 A0  1 
1A07AB0 	10  0  0  0 3C 78 A0  1 
1A07AB8 	C8 41 A0  1  8  0  0  0 
1A07AC0 	C8 77 A0  1 58 46 A0  1 
: n.   (s n -- ) base @ 10 = if s. else u. then  ;
1A07AC8 	 0 6E 2E 82 94 7A A0  1 
1A07AD0 	20 40 A0  1 B8 75 A0  1 
1A07AD8 	5C 4C A0  1 58 41 A0  1 
1A07AE0 	 A  0  0  0 24 48 A0  1 
1A07AE8 	DC 41 A0  1 10  0  0  0 
1A07AF0 	3C 78 A0  1 C8 41 A0  1 
1A07AF8 	 8  0  0  0 C8 77 A0  1 
1A07B00 	58 46 A0  1 
\ : .     (s n -- )       (.)   type space   ;

: (d.)  (  d -- adr len )  tuck dabs <# #s rot sign #>  ;
1A07B04 	 0  0  0 28 
1A07B08 	64 2E 29 84 D0 7A A0  1 
1A07B10 	20 40 A0  1 E8 46 A0  1 
1A07B18 	78 68 A0  1  8 76 A0  1 
1A07B20 	68 77 A0  1 7C 49 A0  1 
1A07B28 	28 76 A0  1 90 77 A0  1 
1A07B30 	58 46 A0  1 
: (ud.) ( ud -- adr len )  <# #s #>  ;
1A07B34 	 0  0 28 75 
1A07B38 	64 2E 29 85 10 7B A0  1 
1A07B40 	20 40 A0  1  8 76 A0  1 
1A07B48 	68 77 A0  1 90 77 A0  1 
1A07B50 	58 46 A0  1 

: d.    (  d -- )     (d.) type space  ;
1A07B54 	 0 64 2E 82 
1A07B58 	40 7B A0  1 20 40 A0  1 
1A07B60 	10 7B A0  1  4 6C A0  1 
1A07B68 	CC 71 A0  1 58 46 A0  1 
: ud.   ( ud -- )    (ud.) type space  ;
1A07B70 	75 64 2E 83 5C 7B A0  1 
1A07B78 	20 40 A0  1 40 7B A0  1 
1A07B80 	 4 6C A0  1 CC 71 A0  1 
1A07B88 	58 46 A0  1 
: ud.r  ( ud n -- )  >r (ud.) r> over - spaces type  ;
1A07B8C 	 0  0  0 75 
1A07B90 	64 2E 72 84 78 7B A0  1 
1A07B98 	20 40 A0  1 BC 45 A0  1 
1A07BA0 	40 7B A0  1 D0 45 A0  1 
1A07BA8 	54 49 A0  1 18 45 A0  1 
1A07BB0 	E8 71 A0  1  4 6C A0  1 
1A07BB8 	58 46 A0  1 


: ?     (s addr -- )    @  n.  ;
1A07BBC 	 0  0 3F 81 
1A07BC0 	98 7B A0  1 20 40 A0  1 
1A07BC8 	5C 4C A0  1 D0 7A A0  1 
1A07BD0 	58 46 A0  1 

: (.s        (s -- )
1A07BD4 	28 2E 73 83 
1A07BD8 	C4 7B A0  1 20 40 A0  1 
   depth 0 ?do  depth i - 1- pick n.  loop
1A07BE0 	28 73 A0  1 70 6F A0  1 
1A07BE8 	50 42 A0  1 24  0  0  0 
1A07BF0 	28 73 A0  1 B4 42 A0  1 
1A07BF8 	18 45 A0  1 54 4B A0  1 
1A07C00 	 C 4A A0  1 D0 7A A0  1 
1A07C08 	F8 41 A0  1 E4 FF FF FF 
;
1A07C10 	58 46 A0  1 

: (.")  (s -- )           skipstr type  ;
1A07C14 	 0  0  0 28 
1A07C18 	2E 22 29 84 DC 7B A0  1 
1A07C20 	20 40 A0  1 74 53 A0  1 
1A07C28 	 4 6C A0  1 58 46 A0  1 

: .s         (s -- )
1A07C30 	 0 2E 73 82 20 7C A0  1 
1A07C38 	20 40 A0  1 
   depth 0<
1A07C3C 	28 73 A0  1 
1A07C40 	64 47 A0  1 
   if   ." Stack Underflow "  sp0 @ sp!
1A07C44 	DC 41 A0  1 
1A07C48 	30  0  0  0 20 7C A0  1 
1A07C50 	10 53 74 61 63 6B 20 55 
1A07C58 	6E 64 65 72 66 6C 6F 77 
1A07C60 	20  0  0  0 8C 66 A0  1 
1A07C68 	5C 4C A0  1 9C 45 A0  1 
   else depth
1A07C70 	C8 41 A0  1 28  0  0  0 
1A07C78 	28 73 A0  1 
        if (.s else ." Empty " then
1A07C7C 	DC 41 A0  1 
1A07C80 	10  0  0  0 DC 7B A0  1 
1A07C88 	C8 41 A0  1 10  0  0  0 
1A07C90 	20 7C A0  1  6 45 6D 70 
1A07C98 	74 79 20  0 
   then
;
1A07C9C 	58 46 A0  1 
: ".  (s pstr -- )  count type  ;
1A07CA0 	 0 22 2E 82 38 7C A0  1 
1A07CA8 	20 40 A0  1 BC 53 A0  1 
1A07CB0 	 4 6C A0  1 58 46 A0  1 

\ From stresc.fth

\ These words use the string-scanning routines to get strings out of
\ the input stream.

\ ",  --> given string, emplace the string at here and allot space
\ ,"  --> accept a "-terminated string and emplace it.
\ "   --> accept a "-terminated string and leave addr len on the stack
\ ""  --> accept a blank delimited string and leave it's address on the stac

\  The improvements allow control characters and 8-bit binary numbers to
\  be embedded into string literals.  This is similar in principle to the
\  "\n" convention in C, but syntactically tuned for Forth.
\
\  The escape character is '"'.  Here is the list of escapes:
\
\     ""	"
\     "n	newline
\     "r	carret
\     "t	tab
\     "f	formfeed
\     "l	linefeed
\     "b	backspace
\     "!	bell
\     "^x	control x, where x is any printable character
\     "(HhHh)   Sequence of bytes, one byte for each pair of hex digits Hh
\               Non-hex characters will be ignored
\
\     "<whitespace> terminates the string, as usual
\
\     " followed by any other printable character not mentioned above is
\          equivalent to that character.
\
\  This new syntax is completely backwards compatible with old code, since
\  the only legal previous usage was "<whitespace>
\
\  Contrived example:
\
\  	" This is "(01,328e)"nA test xyzzy "!"! abcdefg""hijk"^bl"
\
\                   ^^^^^^  ^              ^ ^         ^     ^
\                  3 bytes  newline      2 bells       "     control b
\
\  The "(HhHhHhHh) should come in particularly handy.
\
\  Note: "n (newline) happens to be the same as "l (linefeed) under Unix,
\  but this is not true for all operating systems.


[ifndef] run-time
0 value "temp
1A07CB8 	 0  0 22 74 65 6D 70 85 
1A07CC0 	A8 7C A0  1 50 40 A0  1 
1A07CC8 	E8  0  0  0 
headerless
d# 1024 1+ /n-t +  aligned-t  constant /stringbuf  \ 1024 bytes + /n for length + 1 for null
1A07CCC 	 0 2F 73 74 
1A07CD0 	72 69 6E 67 62 75 66 8A 
1A07CD8 	C4 7C A0  1 68 40 A0  1 
1A07CE0 	 8  4  0  0 
0 value stringbuf
1A07CE4 	 0  0 73 74 
1A07CE8 	72 69 6E 67 62 75 66 89 
1A07CF0 	DC 7C A0  1 50 40 A0  1 
1A07CF8 	EC  0  0  0 
0 value $buf
1A07CFC 	 0  0  0 24 
1A07D00 	62 75 66 84 F4 7C A0  1 
1A07D08 	50 40 A0  1 F0  0  0  0 
: init  ( -- )
1A07D10 	 0  0  0 69 6E 69 74 84 
1A07D18 	 8 7D A0  1 20 40 A0  1 
   init
1A07D20 	2C 75 A0  1 
   /stringbuf 2* alloc-mem dup is stringbuf  is "temp
1A07D24 	DC 7C A0  1 
1A07D28 	A0 4B A0  1 F0 6C A0  1 
1A07D30 	40 49 A0  1 B8 65 A0  1 
1A07D38 	F4 7C A0  1 B8 65 A0  1 
1A07D40 	C4 7C A0  1 
   /stringbuf alloc-mem is $buf
1A07D44 	DC 7C A0  1 
1A07D48 	F0 6C A0  1 B8 65 A0  1 
1A07D50 	 8 7D A0  1 
;
1A07D54 	58 46 A0  1 

headers
: switch-string  ( -- )
1A07D58 	 0  0 73 77 69 74 63 68 
1A07D60 	2D 73 74 72 69 6E 67 8D 
1A07D68 	1C 7D A0  1 20 40 A0  1 
   stringbuf  dup "temp =  if  /stringbuf +  then  is "temp
1A07D70 	F4 7C A0  1 40 49 A0  1 
1A07D78 	C4 7C A0  1 24 48 A0  1 
1A07D80 	DC 41 A0  1  C  0  0  0 
1A07D88 	DC 7C A0  1  4 45 A0  1 
1A07D90 	B8 65 A0  1 C4 7C A0  1 
;
1A07D98 	58 46 A0  1 

: npack  (s str-addr len to -- to )
1A07D9C 	 0  0 6E 70 
1A07DA0 	61 63 6B 85 6C 7D A0  1 
1A07DA8 	20 40 A0  1 
   tuck !                  ( str-adr to )
1A07DAC 	E8 46 A0  1 
1A07DB0 	54 4D A0  1 
   tuck ncount move        ( to )
1A07DB4 	E8 46 A0  1 
1A07DB8 	F0 53 A0  1 F4 4A A0  1 
   0  over ncount +  c!    ( to )
1A07DC0 	70 6F A0  1 54 49 A0  1 
1A07DC8 	F0 53 A0  1  4 45 A0  1 
1A07DD0 	B8 4D A0  1 
;
1A07DD4 	58 46 A0  1 

: $nsave  ( adr1 len1 adr2 -- adr2 len1 )  npack ncount  ;
1A07DD8 	 0 24 6E 73 61 76 65 86 
1A07DE0 	A8 7D A0  1 20 40 A0  1 
1A07DE8 	A8 7D A0  1 F0 53 A0  1 
1A07DF0 	58 46 A0  1 

: $ncat  ( adr len  npstr -- )  \ Append adr len to the end of npstr
1A07DF4 	 0  0 24 6E 
1A07DF8 	63 61 74 85 E4 7D A0  1 
1A07E00 	20 40 A0  1 
   >r  r@ ncount +     ( adr len end-adr )  ( r: npstr )
1A07E04 	BC 45 A0  1 
1A07E08 	E4 45 A0  1 F0 53 A0  1 
1A07E10 	 4 45 A0  1 
   swap dup >r         ( adr endadr len )  ( r: npstr len )
1A07E14 	68 49 A0  1 
1A07E18 	40 49 A0  1 BC 45 A0  1 
   cmove  r> r>        ( len npstr )
1A07E20 	10 44 A0  1 D0 45 A0  1 
1A07E28 	D0 45 A0  1 
   dup @ rot + over !  ( npstr )
1A07E2C 	40 49 A0  1 
1A07E30 	5C 4C A0  1 7C 49 A0  1 
1A07E38 	 4 45 A0  1 54 49 A0  1 
1A07E40 	54 4D A0  1 
   ncount +  0 swap c! \ Null-terminate the end for later convenience
1A07E44 	F0 53 A0  1 
1A07E48 	 4 45 A0  1 70 6F A0  1 
1A07E50 	68 49 A0  1 B8 4D A0  1 
;
1A07E58 	58 46 A0  1 


: $save  ( adr1 len1 adr2 -- adr2 len1 )  pack count  ;
1A07E5C 	 0  0 24 73 
1A07E60 	61 76 65 85  0 7E A0  1 
1A07E68 	20 40 A0  1 DC 52 A0  1 
1A07E70 	BC 53 A0  1 58 46 A0  1 

: $cat  ( adr len  pstr -- )  \ Append adr len to the end of pstr
1A07E78 	 0  0  0 24 63 61 74 84 
1A07E80 	68 7E A0  1 20 40 A0  1 
   >r  r@ count +   ( adr len end-adr )  ( r: pstr )
1A07E88 	BC 45 A0  1 E4 45 A0  1 
1A07E90 	BC 53 A0  1  4 45 A0  1 
   swap dup >r      ( adr endadr len )  ( r: pstr len )
1A07E98 	68 49 A0  1 40 49 A0  1 
1A07EA0 	BC 45 A0  1 
   cmove  r> r>     ( len pstr )
1A07EA4 	10 44 A0  1 
1A07EA8 	D0 45 A0  1 D0 45 A0  1 
   dup c@ rot + over c!  ( pstr )
1A07EB0 	40 49 A0  1 C4 4C A0  1 
1A07EB8 	7C 49 A0  1  4 45 A0  1 
1A07EC0 	54 49 A0  1 B8 4D A0  1 
   count +  0 swap c!     \ Always keep a null terminator at the end
1A07EC8 	BC 53 A0  1  4 45 A0  1 
1A07ED0 	70 6F A0  1 68 49 A0  1 
1A07ED8 	B8 4D A0  1 
;
1A07EDC 	58 46 A0  1 

\ From catchsel.fth

\ Special version of catch and throw for Open Firmware.  This version
\ saves and restores the "my-self" current package instance variable.

0 value my-self
1A07EE0 	6D 79 2D 73 65 6C 66 87 
1A07EE8 	84 7E A0  1 50 40 A0  1 
1A07EF0 	F4  0  0  0 

nuser handler   \ Most recent exception handler
1A07EF4 	68 61 6E 64 
1A07EF8 	6C 65 72 87 EC 7E A0  1 
1A07F00 	48 40 A0  1 F8  0  0  0 

: catch  ( execution-token -- error# | 0 )
1A07F08 	 0  0 63 61 74 63 68 85 
1A07F10 	 0 7F A0  1 20 40 A0  1 
                        ( token )  \ Return address is already on the stack
   sp@ >r               ( token )  \ Save data stack pointer
1A07F18 	6C 45 A0  1 BC 45 A0  1 
   my-self >r           ( token )  \ Save current package instance handle
1A07F20 	EC 7E A0  1 BC 45 A0  1 
   handler @ >r         ( token )  \ Previous handler
1A07F28 	 0 7F A0  1 5C 4C A0  1 
1A07F30 	BC 45 A0  1 
   rp@ handler !        ( token )  \ Set current handler to this one
1A07F34 	7C 45 A0  1 
1A07F38 	 0 7F A0  1 54 4D A0  1 
   execute              ( )        \ Execute the word passed in on the stack
1A07F40 	98 41 A0  1 
   r> handler ! ( )                \ Restore previous handler
1A07F44 	D0 45 A0  1 
1A07F48 	 0 7F A0  1 54 4D A0  1 
   r> drop              ( )        \ Discard saved package instance handle
1A07F50 	D0 45 A0  1 30 49 A0  1 
   r> drop              ( )        \ Discard saved stack pointer
1A07F58 	D0 45 A0  1 30 49 A0  1 
   0                    ( 0 )      \ Signify normal completion
1A07F60 	70 6F A0  1 
;
1A07F64 	58 46 A0  1 

: throw  ( ??? error# -- ??? error# )  \ Returns in saved context
1A07F68 	 0  0 74 68 72 6F 77 85 
1A07F70 	14 7F A0  1 20 40 A0  1 
   dup  0=  if  drop exit  then        \ Don't throw 0
1A07F78 	40 49 A0  1 24 47 A0  1 
1A07F80 	DC 41 A0  1  C  0  0  0 
1A07F88 	30 49 A0  1 40 46 A0  1 
   handler @ rp!        ( err# )       \ Return to saved return stack context
1A07F90 	 0 7F A0  1 5C 4C A0  1 
1A07F98 	AC 45 A0  1 
   r> handler !         ( err# )       \ Restore previous handler
1A07F9C 	D0 45 A0  1 
1A07FA0 	 0 7F A0  1 54 4D A0  1 
   r> is my-self        ( err# )       \ Restore package instance handle
1A07FA8 	D0 45 A0  1 B8 65 A0  1 
1A07FB0 	EC 7E A0  1 
                        ( err# )       \ Remember error# on return stack
                        ( err# )       \ before changing data stack pointer
   r> swap >r           ( saved-sp )   \ err# is on return stack
1A07FB4 	D0 45 A0  1 
1A07FB8 	68 49 A0  1 BC 45 A0  1 
   sp! drop r>          ( err# )       \ Change stack pointer
1A07FC0 	9C 45 A0  1 30 49 A0  1 
1A07FC8 	D0 45 A0  1 
   \ This return will return to the caller of catch, because the return
   \ stack has been restored to the state that existed when CATCH began
   \ execution .
;
1A07FCC 	58 46 A0  1 

defer mark-error
1A07FD0 	 0 6D 61 72 6B 2D 65 72 
1A07FD8 	72 6F 72 8A 74 7F A0  1 
1A07FE0 	5C 40 A0  1 FC  0  0  0 
defer show-error
1A07FE8 	 0 73 68 6F 77 2D 65 72 
1A07FF0 	72 6F 72 8A E0 7F A0  1 
1A07FF8 	5C 40 A0  1  0  1  0  0 


nuser abort"-adr
1A08000 	 0 61 62 6F 72 74 22 2D 
1A08008 	61 64 72 8A F8 7F A0  1 
1A08010 	48 40 A0  1  4  1  0  0 
nuser abort"-len
1A08018 	 0 61 62 6F 72 74 22 2D 
1A08020 	6C 65 6E 8A 10 80 A0  1 
1A08028 	48 40 A0  1  8  1  0  0 
nuser show-aborts
1A08030 	73 68 6F 77 2D 61 62 6F 
1A08038 	72 74 73 8B 28 80 A0  1 
1A08040 	48 40 A0  1  C  1  0  0 
: set-abort-message  ( adr len -- )
1A08048 	 0  0 73 65 74 2D 61 62 
1A08050 	6F 72 74 2D 6D 65 73 73 
1A08058 	61 67 65 91 40 80 A0  1 
1A08060 	20 40 A0  1 
   show-aborts @  if  ." Abort: " 2dup type cr  then
1A08064 	40 80 A0  1 
1A08068 	5C 4C A0  1 DC 41 A0  1 
1A08070 	20  0  0  0 20 7C A0  1 
1A08078 	 7 41 62 6F 72 74 3A 20 
1A08080 	 0  0  0  0 C0 49 A0  1 
1A08088 	 4 6C A0  1 80 6D A0  1 
   abort"-len !  abort"-adr !  mark-error
1A08090 	28 80 A0  1 54 4D A0  1 
1A08098 	10 80 A0  1 54 4D A0  1 
1A080A0 	E0 7F A0  1 
;
1A080A4 	58 46 A0  1 
: abort-message  ( -- adr len )  abort"-adr @  abort"-len @  ;
1A080A8 	 0  0 61 62 6F 72 74 2D 
1A080B0 	6D 65 73 73 61 67 65 8D 
1A080B8 	60 80 A0  1 20 40 A0  1 
1A080C0 	10 80 A0  1 5C 4C A0  1 
1A080C8 	28 80 A0  1 5C 4C A0  1 
1A080D0 	58 46 A0  1 
: $abort  ( adr len -- )  set-abort-message  -2 throw  ;
1A080D4 	 0 24 61 62 
1A080D8 	6F 72 74 86 BC 80 A0  1 
1A080E0 	20 40 A0  1 60 80 A0  1 
1A080E8 	58 41 A0  1 FE FF FF FF 
1A080F0 	74 7F A0  1 58 46 A0  1 
: (abort")   (s f -- )
1A080F8 	 0  0  0 28 61 62 6F 72 
1A08100 	74 22 29 88 E0 80 A0  1 
1A08108 	20 40 A0  1 
   if  skipstr $abort  else  skipstr 2drop  then
1A0810C 	DC 41 A0  1 
1A08110 	14  0  0  0 74 53 A0  1 
1A08118 	E0 80 A0  1 C8 41 A0  1 
1A08120 	 C  0  0  0 74 53 A0  1 
1A08128 	AC 49 A0  1 
;
1A0812C 	58 46 A0  1 


nuser 'source
1A08130 	27 73 6F 75 72 63 65 87 
1A08138 	 8 81 A0  1 48 40 A0  1 
1A08140 	10  1  0  0 
nuser #source
1A08144 	23 73 6F 75 
1A08148 	72 63 65 87 3C 81 A0  1 
1A08150 	48 40 A0  1 14  1  0  0 
: source-adr  ( -- adr )  'source @  ;
1A08158 	 0 73 6F 75 72 63 65 2D 
1A08160 	61 64 72 8A 50 81 A0  1 
1A08168 	20 40 A0  1 3C 81 A0  1 
1A08170 	5C 4C A0  1 58 46 A0  1 
: source      ( -- adr len )  source-adr  #source @  ;
1A08178 	 0 73 6F 75 72 63 65 86 
1A08180 	68 81 A0  1 20 40 A0  1 
1A08188 	68 81 A0  1 50 81 A0  1 
1A08190 	5C 4C A0  1 58 46 A0  1 
: set-source  ( adr len -- )  #source !  'source !  ;
1A08198 	 0 73 65 74 2D 73 6F 75 
1A081A0 	72 63 65 8A 84 81 A0  1 
1A081A8 	20 40 A0  1 50 81 A0  1 
1A081B0 	54 4D A0  1 3C 81 A0  1 
1A081B8 	54 4D A0  1 58 46 A0  1 

\ Control Structures

decimal
headerless
nuser saved-dp
1A081C0 	 0  0  0 73 61 76 65 64 
1A081C8 	2D 64 70 88 A8 81 A0  1 
1A081D0 	48 40 A0  1 18  1  0  0 
nuser saved-limit
1A081D8 	73 61 76 65 64 2D 6C 69 
1A081E0 	6D 69 74 8B D0 81 A0  1 
1A081E8 	48 40 A0  1 1C  1  0  0 
nuser level
1A081F0 	 0  0 6C 65 76 65 6C 85 
1A081F8 	E8 81 A0  1 48 40 A0  1 
1A08200 	20  1  0  0 
headers
[ifdef] run-time
: +level  ( -- )  ;
: -level  ( -- )  ;
[else]
headerless
h# 400 /token-t * constant /compile-buffer
1A08204 	2F 63 6F 6D 
1A08208 	70 69 6C 65 2D 62 75 66 
1A08210 	66 65 72 8F FC 81 A0  1 
1A08218 	68 40 A0  1  0 10  0  0 
nuser 'compile-buffer
1A08220 	27 63 6F 6D 70 69 6C 65 
1A08228 	2D 62 75 66 66 65 72 8F 
1A08230 	18 82 A0  1 48 40 A0  1 
1A08238 	24  1  0  0 
: compile-buffer  ( -- adr )  'compile-buffer @  ;
1A0823C 	 0 63 6F 6D 
1A08240 	70 69 6C 65 2D 62 75 66 
1A08248 	66 65 72 8E 34 82 A0  1 
1A08250 	20 40 A0  1 34 82 A0  1 
1A08258 	5C 4C A0  1 58 46 A0  1 
: init  ( -- )
1A08260 	 0  0  0 69 6E 69 74 84 
1A08268 	50 82 A0  1 20 40 A0  1 
   init
1A08270 	1C 7D A0  1 
   level off   /compile-buffer alloc-mem 'compile-buffer !
1A08274 	FC 81 A0  1 
1A08278 	F8 4B A0  1 18 82 A0  1 
1A08280 	F0 6C A0  1 34 82 A0  1 
1A08288 	54 4D A0  1 
;
1A0828C 	58 46 A0  1 
: reset-dp  ( -- )  saved-dp @ dp !  saved-limit @ is limit  ;
1A08290 	 0  0  0 72 65 73 65 74 
1A08298 	2D 64 70 88 6C 82 A0  1 
1A082A0 	20 40 A0  1 D0 81 A0  1 
1A082A8 	5C 4C A0  1 48 54 A0  1 
1A082B0 	54 4D A0  1 E8 81 A0  1 
1A082B8 	5C 4C A0  1 B8 65 A0  1 
1A082C0 	5C 54 A0  1 58 46 A0  1 

headers
: 0level  ( -- )  level @  if  level off  reset-dp  then  ;
1A082C8 	 0 30 6C 65 76 65 6C 86 
1A082D0 	A0 82 A0  1 20 40 A0  1 
1A082D8 	FC 81 A0  1 5C 4C A0  1 
1A082E0 	DC 41 A0  1 10  0  0  0 
1A082E8 	FC 81 A0  1 F8 4B A0  1 
1A082F0 	A0 82 A0  1 58 46 A0  1 

: +level  ( -- )
1A082F8 	 0 2B 6C 65 76 65 6C 86 
1A08300 	D4 82 A0  1 20 40 A0  1 
   level @  if
1A08308 	FC 81 A0  1 5C 4C A0  1 
1A08310 	DC 41 A0  1 18  0  0  0 
      1 level +!
1A08318 	80 6F A0  1 FC 81 A0  1 
1A08320 	 C 4C A0  1 
   else
1A08324 	C8 41 A0  1 
1A08328 	60  0  0  0 
      state @ 0=  if	\ If interpreting, begin temporary compilation
1A0832C 	38 54 A0  1 
1A08330 	5C 4C A0  1 24 47 A0  1 
1A08338 	DC 41 A0  1 4C  0  0  0 
         1 level !  here saved-dp !  limit saved-limit !
1A08340 	80 6F A0  1 FC 81 A0  1 
1A08348 	54 4D A0  1 70 54 A0  1 
1A08350 	D0 81 A0  1 54 4D A0  1 
1A08358 	5C 54 A0  1 E8 81 A0  1 
1A08360 	54 4D A0  1 
	 compile-buffer dp !  compile-buffer /compile-buffer +  is limit
1A08364 	50 82 A0  1 
1A08368 	48 54 A0  1 54 4D A0  1 
1A08370 	50 82 A0  1 18 82 A0  1 
1A08378 	 4 45 A0  1 B8 65 A0  1 
1A08380 	5C 54 A0  1 
	 ]
1A08384 	A0 6D A0  1 
      then
   then
;
1A08388 	58 46 A0  1 
: -level  ( -- )
1A0838C 	 0 2D 6C 65 
1A08390 	76 65 6C 86  4 83 A0  1 
1A08398 	20 40 A0  1 
   state @ 0= ( -22 ) abort" Control structure mismatch"
1A0839C 	38 54 A0  1 
1A083A0 	5C 4C A0  1 24 47 A0  1 
1A083A8 	 8 81 A0  1 1A 43 6F 6E 
1A083B0 	74 72 6F 6C 20 73 74 72 
1A083B8 	75 63 74 75 72 65 20 6D 
1A083C0 	69 73 6D 61 74 63 68  0 
   level @  if
1A083C8 	FC 81 A0  1 5C 4C A0  1 
1A083D0 	DC 41 A0  1 40  0  0  0 
      -1 level +!
1A083D8 	58 41 A0  1 FF FF FF FF 
1A083E0 	FC 81 A0  1  C 4C A0  1 
      level @ 0=  if
1A083E8 	FC 81 A0  1 5C 4C A0  1 
1A083F0 	24 47 A0  1 DC 41 A0  1 
1A083F8 	1C  0  0  0 
         \ If back to level 0, execute the temporary definition
         compile unnest  reset-dp
1A083FC 	8C 75 A0  1 
1A08400 	58 46 A0  1 A0 82 A0  1 
         [compile] [  compile-buffer >ip
1A08408 	90 6D A0  1 50 82 A0  1 
1A08410 	6C 46 A0  1 
      then
   then
;
1A08414 	58 46 A0  1 
[then]

headerless
: add-char  ( char -- )  $buf ncount + c!  $buf @ 1+ $buf !  ;
1A08418 	 0  0  0 61 64 64 2D 63 
1A08420 	68 61 72 88 98 83 A0  1 
1A08428 	20 40 A0  1  8 7D A0  1 
1A08430 	F0 53 A0  1  4 45 A0  1 
1A08438 	B8 4D A0  1  8 7D A0  1 
1A08440 	5C 4C A0  1 30 4B A0  1 
1A08448 	 8 7D A0  1 54 4D A0  1 
1A08450 	58 46 A0  1 

: nextchar  ( adr len -- false | adr' len' char true )
1A08454 	 0  0  0 6E 
1A08458 	65 78 74 63 68 61 72 88 
1A08460 	28 84 A0  1 20 40 A0  1 
   dup  0=  if  nip exit  then   ( adr len )
1A08468 	40 49 A0  1 24 47 A0  1 
1A08470 	DC 41 A0  1  C  0  0  0 
1A08478 	FC 46 A0  1 40 46 A0  1 
   over c@ >r  swap 1+ swap 1-  r> true
1A08480 	54 49 A0  1 C4 4C A0  1 
1A08488 	BC 45 A0  1 68 49 A0  1 
1A08490 	30 4B A0  1 68 49 A0  1 
1A08498 	54 4B A0  1 D0 45 A0  1 
1A084A0 	 4 70 A0  1 
;
1A084A4 	58 46 A0  1 

: nexthex  ( adr len -- false | adr' len' digit true )
1A084A8 	6E 65 78 74 68 65 78 87 
1A084B0 	64 84 A0  1 20 40 A0  1 
   begin
      nextchar  if         ( adr' len' char )
1A084B8 	64 84 A0  1 DC 41 A0  1 
1A084C0 	38  0  0  0 
	 d# 16 digit  if   ( adr' len' digit )
1A084C4 	58 41 A0  1 
1A084C8 	10  0  0  0 D8 43 A0  1 
1A084D0 	DC 41 A0  1 14  0  0  0 
	    true true      ( adr' len' digit true done )
1A084D8 	 4 70 A0  1  4 70 A0  1 
	 else              ( adr' len' char )
1A084E0 	C8 41 A0  1  C  0  0  0 
	    drop false     ( adr' len' notdone )
1A084E8 	30 49 A0  1 18 70 A0  1 
	 then              ( adr' len' digit true done | adr' len' notdone )
      else                 (  )
1A084F0 	C8 41 A0  1  C  0  0  0 
	 false true        ( false done )
1A084F8 	18 70 A0  1  4 70 A0  1 
      then
   until
1A08500 	DC 41 A0  1 B4 FF FF FF 
;
1A08508 	58 46 A0  1 

nuser caps
1A0850C 	 0  0  0 63 
1A08510 	61 70 73 84 B4 84 A0  1 
1A08518 	48 40 A0  1 28  1  0  0 
variable >in
1A08520 	3E 69 6E 83 18 85 A0  1 
1A08528 	48 40 A0  1 2C  1  0  0 

: /string  ( adr len cnt -- adr' len' )  tuck - -rot + swap  ;
1A08530 	2F 73 74 72 69 6E 67 87 
1A08538 	28 85 A0  1 20 40 A0  1 
1A08540 	E8 46 A0  1 18 45 A0  1 
1A08548 	94 49 A0  1  4 45 A0  1 
1A08550 	68 49 A0  1 58 46 A0  1 

: upper  (s adr len -- )  bounds  ?do i dup c@ upc swap c!  loop  ;
1A08558 	 0  0 75 70 70 65 72 85 
1A08560 	3C 85 A0  1 20 40 A0  1 
1A08568 	F0 6D A0  1 50 42 A0  1 
1A08570 	24  0  0  0 B4 42 A0  1 
1A08578 	40 49 A0  1 C4 4C A0  1 
1A08580 	D0 51 A0  1 68 49 A0  1 
1A08588 	B8 4D A0  1 F8 41 A0  1 
1A08590 	E4 FF FF FF 58 46 A0  1 
: lower  (s adr len -- )  bounds  ?do i dup c@ lcc swap c!  loop  ;
1A08598 	 0  0 6C 6F 77 65 72 85 
1A085A0 	64 85 A0  1 20 40 A0  1 
1A085A8 	F0 6D A0  1 50 42 A0  1 
1A085B0 	24  0  0  0 B4 42 A0  1 
1A085B8 	40 49 A0  1 C4 4C A0  1 
1A085C0 	F0 51 A0  1 68 49 A0  1 
1A085C8 	B8 4D A0  1 F8 41 A0  1 
1A085D0 	E4 FF FF FF 58 46 A0  1 

: parse  ( delim -- adr len )
1A085D8 	 0  0 70 61 72 73 65 85 
1A085E0 	A4 85 A0  1 20 40 A0  1 
   source >in @ /string  over >r   ( delim adr1 len1 )  ( r: adr1 )
1A085E8 	84 81 A0  1 28 85 A0  1 
1A085F0 	5C 4C A0  1 3C 85 A0  1 
1A085F8 	54 49 A0  1 BC 45 A0  1 
   rot scantochar                  ( adr1 adr2 adr3 )  ( r: adr1 )
1A08600 	7C 49 A0  1 60 65 A0  1 
   r> - >in +!                     ( adr1 adr2 ) ( r: )
1A08608 	D0 45 A0  1 18 45 A0  1 
1A08610 	28 85 A0  1  C 4C A0  1 
   over -                          ( adr1 len )
1A08618 	54 49 A0  1 18 45 A0  1 
;
1A08620 	58 46 A0  1 

: get-hex-bytes  ( -- )
1A08624 	 0  0 67 65 
1A08628 	74 2D 68 65 78 2D 62 79 
1A08630 	74 65 73 8D E4 85 A0  1 
1A08638 	20 40 A0  1 
   ascii ) parse                    ( adr len )
1A0863C 	58 41 A0  1 
1A08640 	29  0  0  0 E4 85 A0  1 
   caps @  if  2dup lower  then     ( adr len )
1A08648 	18 85 A0  1 5C 4C A0  1 
1A08650 	DC 41 A0  1  C  0  0  0 
1A08658 	C0 49 A0  1 A4 85 A0  1 
   begin  nexthex  while            ( adr' len' digit1 )
1A08660 	B4 84 A0  1 DC 41 A0  1 
1A08668 	54  0  0  0 
      >r  nexthex  0= ( ?? ) abort" Odd number of hex digits in string"
1A0866C 	BC 45 A0  1 
1A08670 	B4 84 A0  1 24 47 A0  1 
1A08678 	 8 81 A0  1 22 4F 64 64 
1A08680 	20 6E 75 6D 62 65 72 20 
1A08688 	6F 66 20 68 65 78 20 64 
1A08690 	69 67 69 74 73 20 69 6E 
1A08698 	20 73 74 72 69 6E 67  0 
      r>                            ( adr'' len'' digit2 digit1 )
1A086A0 	D0 45 A0  1 
      4 << +  add-char              ( adr'' len'' )
1A086A4 	B0 6F A0  1 
1A086A8 	C8 44 A0  1  4 45 A0  1 
1A086B0 	28 84 A0  1 
   repeat
1A086B4 	C8 41 A0  1 
1A086B8 	A8 FF FF FF 
;
1A086BC 	58 46 A0  1 


\ : get-char  ( -- char )  input-file @ fgetc  ;


: get-char  ( -- char|-1 )
1A086C0 	 0  0  0 67 65 74 2D 63 
1A086C8 	68 61 72 88 38 86 A0  1 
1A086D0 	20 40 A0  1 
   source  >in @  /string  if  c@  1 >in +!  else  drop -1  then
1A086D4 	84 81 A0  1 
1A086D8 	28 85 A0  1 5C 4C A0  1 
1A086E0 	3C 85 A0  1 DC 41 A0  1 
1A086E8 	1C  0  0  0 C4 4C A0  1 
1A086F0 	80 6F A0  1 28 85 A0  1 
1A086F8 	 C 4C A0  1 C8 41 A0  1 
1A08700 	10  0  0  0 30 49 A0  1 
1A08708 	58 41 A0  1 FF FF FF FF 
;
1A08710 	58 46 A0  1 

headers
: get-escaped-string  ( -- adr len )
1A08714 	 0 67 65 74 
1A08718 	2D 65 73 63 61 70 65 64 
1A08720 	2D 73 74 72 69 6E 67 92 
1A08728 	D0 86 A0  1 20 40 A0  1 
   0 $buf !
1A08730 	70 6F A0  1  8 7D A0  1 
1A08738 	54 4D A0  1 
   begin
      ascii " parse   $buf $ncat
1A0873C 	58 41 A0  1 
1A08740 	22  0  0  0 E4 85 A0  1 
1A08748 	 8 7D A0  1  0 7E A0  1 
      get-char  dup bl <=  if  drop $buf ncount exit  then  ( char )
1A08750 	D0 86 A0  1 40 49 A0  1 
1A08758 	28 70 A0  1  C 49 A0  1 
1A08760 	DC 41 A0  1 14  0  0  0 
1A08768 	30 49 A0  1  8 7D A0  1 
1A08770 	F0 53 A0  1 40 46 A0  1 
      case
         ascii n of  newline            add-char  endof
1A08778 	58 41 A0  1 6E  0  0  0 
1A08780 	48 43 A0  1 14  0  0  0 
1A08788 	A8 71 A0  1 28 84 A0  1 
1A08790 	6C 43 A0  1 24  1  0  0 
         ascii r of  carret             add-char  endof
1A08798 	58 41 A0  1 72  0  0  0 
1A087A0 	48 43 A0  1 14  0  0  0 
1A087A8 	60 6F A0  1 28 84 A0  1 
1A087B0 	6C 43 A0  1  4  1  0  0 
         ascii t of  control I          add-char  endof
1A087B8 	58 41 A0  1 74  0  0  0 
1A087C0 	48 43 A0  1 18  0  0  0 
1A087C8 	58 41 A0  1  9  0  0  0 
1A087D0 	28 84 A0  1 6C 43 A0  1 
1A087D8 	E0  0  0  0 
         ascii f of  control L          add-char  endof
1A087DC 	58 41 A0  1 
1A087E0 	66  0  0  0 48 43 A0  1 
1A087E8 	18  0  0  0 58 41 A0  1 
1A087F0 	 C  0  0  0 28 84 A0  1 
1A087F8 	6C 43 A0  1 BC  0  0  0 
         ascii l of  linefeed           add-char  endof
1A08800 	58 41 A0  1 6C  0  0  0 
1A08808 	48 43 A0  1 14  0  0  0 
1A08810 	4C 6F A0  1 28 84 A0  1 
1A08818 	6C 43 A0  1 9C  0  0  0 
         ascii b of  control H          add-char  endof
1A08820 	58 41 A0  1 62  0  0  0 
1A08828 	48 43 A0  1 18  0  0  0 
1A08830 	58 41 A0  1  8  0  0  0 
1A08838 	28 84 A0  1 6C 43 A0  1 
1A08840 	78  0  0  0 
         ascii ! of  bell               add-char  endof
1A08844 	58 41 A0  1 
1A08848 	21  0  0  0 48 43 A0  1 
1A08850 	14  0  0  0 24 6F A0  1 
1A08858 	28 84 A0  1 6C 43 A0  1 
1A08860 	58  0  0  0 
         ascii ^ of  get-char h# 1f and add-char  endof
1A08864 	58 41 A0  1 
1A08868 	5E  0  0  0 48 43 A0  1 
1A08870 	20  0  0  0 D0 86 A0  1 
1A08878 	58 41 A0  1 1F  0  0  0 
1A08880 	5C 44 A0  1 28 84 A0  1 
1A08888 	6C 43 A0  1 2C  0  0  0 
         ascii ( of  get-hex-bytes                endof
1A08890 	58 41 A0  1 28  0  0  0 
1A08898 	48 43 A0  1 10  0  0  0 
1A088A0 	38 86 A0  1 6C 43 A0  1 
1A088A8 	10  0  0  0 
         ( default ) dup                add-char
1A088AC 	40 49 A0  1 
1A088B0 	28 84 A0  1 
      endcase
1A088B4 	84 43 A0  1 
   again
1A088B8 	C8 41 A0  1 80 FE FF FF 
;
1A088C0 	58 46 A0  1 

: .(  \ string)  (s -- )
1A088C4 	 0 2E 28 C2 
1A088C8 	2C 87 A0  1 20 40 A0  1 
   ascii ) parse type
1A088D0 	58 41 A0  1 29  0  0  0 
1A088D8 	E4 85 A0  1  4 6C A0  1 
; immediate
1A088E0 	58 46 A0  1 

\ : (   \ string  (s -- )  \ Skips to next )
\    ascii ) parse 2drop
\ ; immediate
[then]

\ Words for copying strings
\ Places a series of bytes in memory at to as a packed string
: place     (s adr len to-adr -- )  pack drop  ;
1A088E4 	 0  0 70 6C 
1A088E8 	61 63 65 85 CC 88 A0  1 
1A088F0 	20 40 A0  1 DC 52 A0  1 
1A088F8 	30 49 A0  1 58 46 A0  1 
: nplace    (s adr len to-adr -- )  npack drop  ;
1A08900 	 0 6E 70 6C 61 63 65 86 
1A08908 	F0 88 A0  1 20 40 A0  1 
1A08910 	A8 7D A0  1 30 49 A0  1 
1A08918 	58 46 A0  1 


: ",    (s adr len -- )
1A0891C 	 0 22 2C 82 
1A08920 	 C 89 A0  1 20 40 A0  1 
   dup 2+ taligned  here swap  noop  allot  place
1A08928 	40 49 A0  1 40 4B A0  1 
1A08930 	54 62 A0  1 70 54 A0  1 
1A08938 	68 49 A0  1 64 4F A0  1 
1A08940 	E4 54 A0  1 F0 88 A0  1 
;
1A08948 	58 46 A0  1 

: n",    (s adr len -- )
1A0894C 	6E 22 2C 83 
1A08950 	24 89 A0  1 20 40 A0  1 
   dup 1+ na1+ taligned  here swap  noop  allot  nplace
1A08958 	40 49 A0  1 30 4B A0  1 
1A08960 	CC 50 A0  1 54 62 A0  1 
1A08968 	70 54 A0  1 68 49 A0  1 
1A08970 	64 4F A0  1 E4 54 A0  1 
1A08978 	 C 89 A0  1 
;
1A0897C 	58 46 A0  1 

[ifndef] run-time
: ,"  \ string"  (s -- )
1A08980 	 0 2C 22 82 54 89 A0  1 
1A08988 	20 40 A0  1 
   get-escaped-string  ",
1A0898C 	2C 87 A0  1 
1A08990 	24 89 A0  1 
;
1A08994 	58 46 A0  1 

: ."  \ string"  (s -- )
1A08998 	 0 2E 22 C2 88 89 A0  1 
1A089A0 	20 40 A0  1 
   +level compile (.")   ," -level
1A089A4 	 4 83 A0  1 
1A089A8 	8C 75 A0  1 20 7C A0  1 
1A089B0 	88 89 A0  1 98 83 A0  1 
; immediate
1A089B8 	58 46 A0  1 


: compile-string  ( adr len -- )
1A089BC 	 0 63 6F 6D 
1A089C0 	70 69 6C 65 2D 73 74 72 
1A089C8 	69 6E 67 8E A0 89 A0  1 
1A089D0 	20 40 A0  1 
   state @  if
1A089D4 	38 54 A0  1 
1A089D8 	5C 4C A0  1 DC 41 A0  1 
1A089E0 	44  0  0  0 
      dup  d# 255 >  if
1A089E4 	40 49 A0  1 
1A089E8 	58 41 A0  1 FF  0  0  0 
1A089F0 	 4 48 A0  1 DC 41 A0  1 
1A089F8 	18  0  0  0 
         compile (n") n",
1A089FC 	8C 75 A0  1 
1A08A00 	D4 53 A0  1 54 89 A0  1 
      else
1A08A08 	C8 41 A0  1 10  0  0  0 
         compile (") ",
1A08A10 	8C 75 A0  1 9C 53 A0  1 
1A08A18 	24 89 A0  1 
      then
   else
1A08A1C 	C8 41 A0  1 
1A08A20 	10  0  0  0 
      switch-string "temp $nsave
1A08A24 	6C 7D A0  1 
1A08A28 	C4 7C A0  1 E4 7D A0  1 
   then
;
1A08A30 	58 46 A0  1 
: s"  \ string   (s -- adr len )
1A08A34 	 0 73 22 C2 
1A08A38 	D0 89 A0  1 20 40 A0  1 
   ascii " parse compile-string
1A08A40 	58 41 A0  1 22  0  0  0 
1A08A48 	E4 85 A0  1 D0 89 A0  1 
; immediate
1A08A50 	58 46 A0  1 

: "   \ string"  (s -- adr len )
1A08A54 	 0  0 22 C1 
1A08A58 	3C 8A A0  1 20 40 A0  1 
   get-escaped-string compile-string
1A08A60 	2C 87 A0  1 D0 89 A0  1 
; immediate
1A08A68 	58 46 A0  1 

: \  \ rest-of-line  (s -- )      \ skips rest of line
1A08A6C 	 0  0 5C C1 
1A08A70 	5C 8A A0  1 20 40 A0  1 
   -1 parse 2drop
1A08A78 	58 41 A0  1 FF FF FF FF 
1A08A80 	E4 85 A0  1 AC 49 A0  1 
; immediate
1A08A88 	58 46 A0  1 
[then]

create nullstring 0 c, 0 c,
1A08A8C 	 0 6E 75 6C 
1A08A90 	6C 73 74 72 69 6E 67 8A 
1A08A98 	74 8A A0  1 30 40 A0  1 
1A08AA0 	 0  0 


: place-cstr  ( adr len cstr-adr -- cstr-adr )
1A08AA2 	 0  0  0 70 6C 61 
1A08AA8 	63 65 2D 63 73 74 72 8A 
1A08AB0 	9C 8A A0  1 20 40 A0  1 
   >r  tuck r@ swap cmove  ( len ) r@ +  0 swap c!  r>
1A08AB8 	BC 45 A0  1 E8 46 A0  1 
1A08AC0 	E4 45 A0  1 68 49 A0  1 
1A08AC8 	10 44 A0  1 E4 45 A0  1 
1A08AD0 	 4 45 A0  1 70 6F A0  1 
1A08AD8 	68 49 A0  1 B8 4D A0  1 
1A08AE0 	D0 45 A0  1 
;
1A08AE4 	58 46 A0  1 

: even      (s n -- n | n+1 )  dup 1 and +  ;
1A08AE8 	 0  0  0 65 76 65 6E 84 
1A08AF0 	B4 8A A0  1 20 40 A0  1 
1A08AF8 	40 49 A0  1 80 6F A0  1 
1A08B00 	5C 44 A0  1  4 45 A0  1 
1A08B08 	58 46 A0  1 

\ Nullfix
: +str  (s pstr -- adr )     count + 1+ taligned ;
1A08B0C 	 0  0  0 2B 
1A08B10 	73 74 72 84 F4 8A A0  1 
1A08B18 	20 40 A0  1 BC 53 A0  1 
1A08B20 	 4 45 A0  1 30 4B A0  1 
1A08B28 	54 62 A0  1 58 46 A0  1 

: +nstr  (s pstr -- adr )     ncount + 1+ taligned ;
1A08B30 	 0  0 2B 6E 73 74 72 85 
1A08B38 	18 8B A0  1 20 40 A0  1 
1A08B40 	F0 53 A0  1  4 45 A0  1 
1A08B48 	30 4B A0  1 54 62 A0  1 
1A08B50 	58 46 A0  1 

\ Copy a packed string from "from-pstr" to "to-pstr"
: "copy (s from-pstr to-pstr -- )      >r count r> place ;
1A08B54 	 0  0 22 63 
1A08B58 	6F 70 79 85 3C 8B A0  1 
1A08B60 	20 40 A0  1 BC 45 A0  1 
1A08B68 	BC 53 A0  1 D0 45 A0  1 
1A08B70 	F0 88 A0  1 58 46 A0  1 

\ Copy a packed string from "from-pstr" to "to-pstr", returning "to-pstr"
: "move (s from-pstr to-pstr -- to-pstr )   >r count r> pack  ;
1A08B78 	 0  0 22 6D 6F 76 65 85 
1A08B80 	60 8B A0  1 20 40 A0  1 
1A08B88 	BC 45 A0  1 BC 53 A0  1 
1A08B90 	D0 45 A0  1 DC 52 A0  1 
1A08B98 	58 46 A0  1 

\ : count      (s adr -- adr+1 len )  dup 1+   swap c@   ;

: printable?  ( n -- flag ) \ true if n is a printable ascii character
1A08B9C 	 0 70 72 69 
1A08BA0 	6E 74 61 62 6C 65 3F 8A 
1A08BA8 	84 8B A0  1 20 40 A0  1 
   dup bl th 7f within  swap  th 80  th ff  between  or
1A08BB0 	40 49 A0  1 28 70 A0  1 
1A08BB8 	58 41 A0  1 7F  0  0  0 
1A08BC0 	 8 71 A0  1 68 49 A0  1 
1A08BC8 	58 41 A0  1 80  0  0  0 
1A08BD0 	58 41 A0  1 FF  0  0  0 
1A08BD8 	D8 70 A0  1 70 44 A0  1 
;
1A08BE0 	58 46 A0  1 
: white-space? ( n -- flag ) \ true is n is non-printable? or a blank
1A08BE4 	 0  0  0 77 
1A08BE8 	68 69 74 65 2D 73 70 61 
1A08BF0 	63 65 3F 8C AC 8B A0  1 
1A08BF8 	20 40 A0  1 
   dup printable? 0=  swap  bl =  or
1A08BFC 	40 49 A0  1 
1A08C00 	AC 8B A0  1 24 47 A0  1 
1A08C08 	68 49 A0  1 28 70 A0  1 
1A08C10 	24 48 A0  1 70 44 A0  1 
;
1A08C18 	58 46 A0  1 

: -leading  ( adr len -- adr' len' )
1A08C1C 	 0  0  0 2D 
1A08C20 	6C 65 61 64 69 6E 67 88 
1A08C28 	F8 8B A0  1 20 40 A0  1 
   begin  dup  while   ( adr' len' )
1A08C30 	40 49 A0  1 DC 41 A0  1 
1A08C38 	38  0  0  0 
      over c@  white-space? 0=  if  exit  then
1A08C3C 	54 49 A0  1 
1A08C40 	C4 4C A0  1 F8 8B A0  1 
1A08C48 	24 47 A0  1 DC 41 A0  1 
1A08C50 	 8  0  0  0 40 46 A0  1 
      swap 1+ swap 1-
1A08C58 	68 49 A0  1 30 4B A0  1 
1A08C60 	68 49 A0  1 54 4B A0  1 
   repeat
1A08C68 	C8 41 A0  1 C4 FF FF FF 
;
1A08C70 	58 46 A0  1 

: -trailing  (s adr len -- adr len' )
1A08C74 	 0  0 2D 74 
1A08C78 	72 61 69 6C 69 6E 67 89 
1A08C80 	2C 8C A0  1 20 40 A0  1 
   dup  0  ?do   2dup + 1- c@   white-space? 0=  ?leave  1-    loop
1A08C88 	40 49 A0  1 70 6F A0  1 
1A08C90 	50 42 A0  1 2C  0  0  0 
1A08C98 	C0 49 A0  1  4 45 A0  1 
1A08CA0 	54 4B A0  1 C4 4C A0  1 
1A08CA8 	F8 8B A0  1 24 47 A0  1 
1A08CB0 	34 43 A0  1 54 4B A0  1 
1A08CB8 	F8 41 A0  1 DC FF FF FF 
;
1A08CC0 	58 46 A0  1 

: f83-compare  (s adr adr2 len -- -1 | 0 | 1 )
1A08CC4 	66 38 33 2D 
1A08CC8 	63 6F 6D 70 61 72 65 8B 
1A08CD0 	84 8C A0  1 20 40 A0  1 
   caps @  if  caps-comp  else  comp  then
1A08CD8 	18 85 A0  1 5C 4C A0  1 
1A08CE0 	DC 41 A0  1 10  0  0  0 
1A08CE8 	60 52 A0  1 C8 41 A0  1 
1A08CF0 	 8  0  0  0 38 52 A0  1 
;
1A08CF8 	58 46 A0  1 
headers
\ Unpacked string comparison
: +-1  ( n -- -1|0|+1 )  0< 2* 1+  ;
1A08CFC 	2B 2D 31 83 
1A08D00 	D4 8C A0  1 20 40 A0  1 
1A08D08 	64 47 A0  1 A0 4B A0  1 
1A08D10 	30 4B A0  1 58 46 A0  1 
: compare  (s adr1 len1 adr2 len2 -- same? )
1A08D18 	63 6F 6D 70 61 72 65 87 
1A08D20 	 4 8D A0  1 20 40 A0  1 
   rot 2dup 2>r min             ( adr1 adr2 min-len )  ( r: len2 len1 )
1A08D28 	7C 49 A0  1 C0 49 A0  1 
1A08D30 	F8 45 A0  1 74 4A A0  1 
   comp dup  if                 ( +-1 )
1A08D38 	38 52 A0  1 40 49 A0  1 
1A08D40 	DC 41 A0  1 14  0  0  0 
      2r> 2drop                 ( +-1 )  \ Initial substrings differ
1A08D48 	10 46 A0  1 AC 49 A0  1 
   else                         ( 0 )
1A08D50 	C8 41 A0  1 28  0  0  0 
      drop  2r> -               ( diff ) \ Initial substrings are the same
1A08D58 	30 49 A0  1 10 46 A0  1 
1A08D60 	18 45 A0  1 
      \ This is tricky.  We want to convert zero to zero, positive
      \ numbers to -1, and negative numbers to +1.  Here's how it works:
      \ "dup  if  ..  then" leave 0 unchanged, and nonzero number are
      \ transformed as follows:
      \       +n  -n
      \ 0>    -1   0
      \ 2*    -2   0
      \ 1+    -1   1
      dup  if  0> 2* 1+  then
1A08D64 	40 49 A0  1 
1A08D68 	DC 41 A0  1 10  0  0  0 
1A08D70 	A4 47 A0  1 A0 4B A0  1 
1A08D78 	30 4B A0  1 
   then
;
1A08D7C 	58 46 A0  1 
\ $= can be defined as "compare 0=", but $= is used much more often,
\ and doesn't require all the tricky argument fixups, so it makes
\ sense to define $= directly, so it runs quite a bit faster.
: $=  (s adr1 len1 adr2 len2 -- same? )
1A08D80 	 0 24 3D 82 24 8D A0  1 
1A08D88 	20 40 A0  1 
   rot tuck  <>  if  3drop false exit  then   ( adr1 adr2 len1 )
1A08D8C 	7C 49 A0  1 
1A08D90 	E8 46 A0  1 44 48 A0  1 
1A08D98 	DC 41 A0  1 10  0  0  0 
1A08DA0 	90 52 A0  1 18 70 A0  1 
1A08DA8 	40 46 A0  1 
   comp 0=    
1A08DAC 	38 52 A0  1 
1A08DB0 	24 47 A0  1 
;
1A08DB4 	58 46 A0  1 


\ From kernel2.fth

: hex        (s -- )   16 base !  ;
1A08DB8 	68 65 78 83 88 8D A0  1 
1A08DC0 	20 40 A0  1 58 41 A0  1 
1A08DC8 	10  0  0  0 B8 75 A0  1 
1A08DD0 	54 4D A0  1 58 46 A0  1 
: decimal    (s -- )   10 base !  ;
1A08DD8 	64 65 63 69 6D 61 6C 87 
1A08DE0 	C0 8D A0  1 20 40 A0  1 
1A08DE8 	58 41 A0  1  A  0  0  0 
1A08DF0 	B8 75 A0  1 54 4D A0  1 
1A08DF8 	58 46 A0  1 
: octal      (s -- )    8 base !  ;
1A08DFC 	 0  0 6F 63 
1A08E00 	74 61 6C 85 E4 8D A0  1 
1A08E08 	20 40 A0  1 F0 6F A0  1 
1A08E10 	B8 75 A0  1 54 4D A0  1 
1A08E18 	58 46 A0  1 
: binary     (s -- )    2 base !  ;
1A08E1C 	 0 62 69 6E 
1A08E20 	61 72 79 86  8 8E A0  1 
1A08E28 	20 40 A0  1 90 6F A0  1 
1A08E30 	B8 75 A0  1 54 4D A0  1 
1A08E38 	58 46 A0  1 

: ?enough   (s n -- )  depth 1- >   ( -4 ) abort" Not enough Parameters"  ;
1A08E3C 	3F 65 6E 6F 
1A08E40 	75 67 68 87 28 8E A0  1 
1A08E48 	20 40 A0  1 28 73 A0  1 
1A08E50 	54 4B A0  1  4 48 A0  1 
1A08E58 	 8 81 A0  1 15 4E 6F 74 
1A08E60 	20 65 6E 6F 75 67 68 20 
1A08E68 	50 61 72 61 6D 65 74 65 
1A08E70 	72 73  0  0 58 46 A0  1 

hex
ps-size-t constant ps-size
1A08E78 	70 73 2D 73 69 7A 65 87 
1A08E80 	48 8E A0  1 68 40 A0  1 
1A08E88 	 0  8  0  0 
rs-size-t constant rs-size
1A08E8C 	72 73 2D 73 
1A08E90 	69 7A 65 87 84 8E A0  1 
1A08E98 	68 40 A0  1  0  8  0  0 

: dump-chars  ( adr -- )
1A08EA0 	 0 64 75 6D 70 2D 63 68 
1A08EA8 	61 72 73 8A 98 8E A0  1 
1A08EB0 	20 40 A0  1 
   h# 10  bounds  do
1A08EB4 	58 41 A0  1 
1A08EB8 	10  0  0  0 F0 6D A0  1 
1A08EC0 	88 42 A0  1 48  0  0  0 
     i c@  dup  bl h# 80 within  if  emit  else  drop ." ."  then
1A08EC8 	B4 42 A0  1 C4 4C A0  1 
1A08ED0 	40 49 A0  1 28 70 A0  1 
1A08ED8 	58 41 A0  1 80  0  0  0 
1A08EE0 	 8 71 A0  1 DC 41 A0  1 
1A08EE8 	10  0  0  0 2C 6C A0  1 
1A08EF0 	C8 41 A0  1 10  0  0  0 
1A08EF8 	30 49 A0  1 20 7C A0  1 
1A08F00 	 1 2E  0  0 
   loop
1A08F04 	F8 41 A0  1 
1A08F08 	C0 FF FF FF 
;
1A08F0C 	58 46 A0  1 
: bdump  (s adr len -- )
1A08F10 	 0  0 62 64 75 6D 70 85 
1A08F18 	B0 8E A0  1 20 40 A0  1 
   base @ >r  hex
1A08F20 	B8 75 A0  1 5C 4C A0  1 
1A08F28 	BC 45 A0  1 C0 8D A0  1 
   bounds  ?do
1A08F30 	F0 6D A0  1 50 42 A0  1 
1A08F38 	84  0  0  0 
      i 8 u.r  ." : "  i  h# 10  bounds  do
1A08F3C 	B4 42 A0  1 
1A08F40 	F0 6F A0  1 E4 77 A0  1 
1A08F48 	20 7C A0  1  2 3A 20  0 
1A08F50 	B4 42 A0  1 58 41 A0  1 
1A08F58 	10  0  0  0 F0 6D A0  1 
1A08F60 	88 42 A0  1 3C  0  0  0 
         i /l bounds  do  i c@ .2  loop  space
1A08F68 	B4 42 A0  1 30 51 A0  1 
1A08F70 	F0 6D A0  1 88 42 A0  1 
1A08F78 	18  0  0  0 B4 42 A0  1 
1A08F80 	C4 4C A0  1 60 79 A0  1 
1A08F88 	F8 41 A0  1 F0 FF FF FF 
1A08F90 	CC 71 A0  1 
      /l +loop
1A08F94 	30 51 A0  1 
1A08F98 	1C 42 A0  1 CC FF FF FF 
      i  dump-chars
1A08FA0 	B4 42 A0  1 B0 8E A0  1 
      cr
1A08FA8 	80 6D A0  1 
   h# 10 +loop
1A08FAC 	58 41 A0  1 
1A08FB0 	10  0  0  0 1C 42 A0  1 
1A08FB8 	84 FF FF FF 
   r> base !
1A08FBC 	D0 45 A0  1 
1A08FC0 	B8 75 A0  1 54 4D A0  1 
;
1A08FC8 	58 46 A0  1 
: wdump  (s adr len -- )
1A08FCC 	 0  0 77 64 
1A08FD0 	75 6D 70 85 1C 8F A0  1 
1A08FD8 	20 40 A0  1 
   base @ >r  hex
1A08FDC 	B8 75 A0  1 
1A08FE0 	5C 4C A0  1 BC 45 A0  1 
1A08FE8 	C0 8D A0  1 
   bounds  ?do
1A08FEC 	F0 6D A0  1 
1A08FF0 	50 42 A0  1 70  0  0  0 
      i 8 u.r  ." : "  i  h# 10  bounds  do
1A08FF8 	B4 42 A0  1 F0 6F A0  1 
1A09000 	E4 77 A0  1 20 7C A0  1 
1A09008 	 2 3A 20  0 B4 42 A0  1 
1A09010 	58 41 A0  1 10  0  0  0 
1A09018 	F0 6D A0  1 88 42 A0  1 
1A09020 	28  0  0  0 
         i w@ 4 u.r space space
1A09024 	B4 42 A0  1 
1A09028 	94 4C A0  1 B0 6F A0  1 
1A09030 	E4 77 A0  1 CC 71 A0  1 
1A09038 	CC 71 A0  1 
      /w +loop
1A0903C 	20 51 A0  1 
1A09040 	1C 42 A0  1 E0 FF FF FF 
      i  dump-chars
1A09048 	B4 42 A0  1 B0 8E A0  1 
      cr
1A09050 	80 6D A0  1 
   h# 10 +loop
1A09054 	58 41 A0  1 
1A09058 	10  0  0  0 1C 42 A0  1 
1A09060 	98 FF FF FF 
   r> base !
1A09064 	D0 45 A0  1 
1A09068 	B8 75 A0  1 54 4D A0  1 
;
1A09070 	58 46 A0  1 
: ldump  (s adr len -- )
1A09074 	 0  0 6C 64 
1A09078 	75 6D 70 85 D8 8F A0  1 
1A09080 	20 40 A0  1 
   base @ >r  hex
1A09084 	B8 75 A0  1 
1A09088 	5C 4C A0  1 BC 45 A0  1 
1A09090 	C0 8D A0  1 
   bounds  ?do
1A09094 	F0 6D A0  1 
1A09098 	50 42 A0  1 70  0  0  0 
      i 8 u.r  ." : "  i  h# 10  bounds  do
1A090A0 	B4 42 A0  1 F0 6F A0  1 
1A090A8 	E4 77 A0  1 20 7C A0  1 
1A090B0 	 2 3A 20  0 B4 42 A0  1 
1A090B8 	58 41 A0  1 10  0  0  0 
1A090C0 	F0 6D A0  1 88 42 A0  1 
1A090C8 	28  0  0  0 
         i l@ 8 u.r space space
1A090CC 	B4 42 A0  1 
1A090D0 	6C 4C A0  1 F0 6F A0  1 
1A090D8 	E4 77 A0  1 CC 71 A0  1 
1A090E0 	CC 71 A0  1 
      /l +loop
1A090E4 	30 51 A0  1 
1A090E8 	1C 42 A0  1 E0 FF FF FF 
      i  dump-chars
1A090F0 	B4 42 A0  1 B0 8E A0  1 
      cr
1A090F8 	80 6D A0  1 
   h# 10 +loop
1A090FC 	58 41 A0  1 
1A09100 	10  0  0  0 1C 42 A0  1 
1A09108 	98 FF FF FF 
   r> base !
1A0910C 	D0 45 A0  1 
1A09110 	B8 75 A0  1 54 4D A0  1 
;
1A09118 	58 46 A0  1 


: abort  (s ?? -- )  mark-error  -1 throw  ;
1A0911C 	 0  0 61 62 
1A09120 	6F 72 74 85 80 90 A0  1 
1A09128 	20 40 A0  1 E0 7F A0  1 
1A09130 	58 41 A0  1 FF FF FF FF 
1A09138 	74 7F A0  1 58 46 A0  1 

\ Run-time words used by the compiler; also used by metacompiled programs
\ even if the interactive compiler is not present

: ?throw  ( flag throw-code -- )  swap  if  throw  else  drop  then  ;
1A09140 	 0 3F 74 68 72 6F 77 86 
1A09148 	28 91 A0  1 20 40 A0  1 
1A09150 	68 49 A0  1 DC 41 A0  1 
1A09158 	10  0  0  0 74 7F A0  1 
1A09160 	C8 41 A0  1  8  0  0  0 
1A09168 	30 49 A0  1 58 46 A0  1 

\ [ifndef] round-down
: round-down  ( adr granularity -- adr' )  1- invert and  ;
1A09170 	 0 72 6F 75 6E 64 2D 64 
1A09178 	6F 77 6E 8A 4C 91 A0  1 
1A09180 	20 40 A0  1 54 4B A0  1 
1A09188 	30 45 A0  1 5C 44 A0  1 
1A09190 	58 46 A0  1 
\ [then]
: round-up  ( adr granularity -- adr' )  1-  tuck +  swap invert and  ;
1A09194 	 0  0  0 72 
1A09198 	6F 75 6E 64 2D 75 70 88 
1A091A0 	80 91 A0  1 20 40 A0  1 
1A091A8 	54 4B A0  1 E8 46 A0  1 
1A091B0 	 4 45 A0  1 68 49 A0  1 
1A091B8 	30 45 A0  1 5C 44 A0  1 
1A091C0 	58 46 A0  1 
: (align)  ( size granularity -- )
1A091C4 	28 61 6C 69 
1A091C8 	67 6E 29 87 A4 91 A0  1 
1A091D0 	20 40 A0  1 
   1-  begin  dup here and  while  0 c,  repeat  drop
1A091D4 	54 4B A0  1 
1A091D8 	40 49 A0  1 70 54 A0  1 
1A091E0 	5C 44 A0  1 DC 41 A0  1 
1A091E8 	14  0  0  0 70 6F A0  1 
1A091F0 	B8 55 A0  1 C8 41 A0  1 
1A091F8 	E0 FF FF FF 30 49 A0  1 
;
1A09200 	58 46 A0  1 

\ From compiler.fth

hex


[ifdef] run-time

:-h immediate ( -- )
\ Don't fix the target header because there isn't one!
\   lastacf-t @ 1-  th 40 toggle-t       \ fix target header
   \ We can't do this with immediate-h because the symbol we need to make
   \ immediate isn't necessarily the last one for which a header was
   \ created.  It could have been a forward reference, with the header
   \ created long ago.
   lastacf-s @ >flags  th 40 toggle        \ fix symbol table
;-h

: allot-abort  (s size -- size )
   ." Dictionary overflow - here "  here .  ." limit " limit .  cr
   ( -8 ) abort
;

[else]

: allot-abort  (s size -- size )
1A09204 	61 6C 6C 6F 
1A09208 	74 2D 61 62 6F 72 74 8B 
1A09210 	D0 91 A0  1 20 40 A0  1 
   ." Dictionary overflow - here "  here .  ." limit " limit .  cr
1A09218 	20 7C A0  1 1B 44 69 63 
1A09220 	74 69 6F 6E 61 72 79 20 
1A09228 	6F 76 65 72 66 6C 6F 77 
1A09230 	20 2D 20 68 65 72 65 20 
1A09238 	 0  0  0  0 70 54 A0  1 
1A09240 	94 7A A0  1 20 7C A0  1 
1A09248 	 6 6C 69 6D 69 74 20  0 
1A09250 	5C 54 A0  1 94 7A A0  1 
1A09258 	80 6D A0  1 
   ( -8 ) abort
1A0925C 	28 91 A0  1 
;
1A09260 	58 46 A0  1 

[then]

' allot-abort is allot-error


64\ : x,     (s x -- )       here   /x allot   unaligned-!   ;
[ifdef] big-endian-t
: d,     (s d -- )       here   2 /n* allot   2!   ;
[else]
: d,     (s d -- )       swap , ,   ;
1A09264 	 0 64 2C 82 
1A09268 	14 92 A0  1 20 40 A0  1 
1A09270 	68 49 A0  1 98 55 A0  1 
1A09278 	98 55 A0  1 58 46 A0  1 
[then]


: ?pairs  (s n1 n2 -- )   <>  ( -22 ) abort" Control structure mismatch" ;
1A09280 	 0 3F 70 61 69 72 73 86 
1A09288 	6C 92 A0  1 20 40 A0  1 
1A09290 	44 48 A0  1  8 81 A0  1 
1A09298 	1A 43 6F 6E 74 72 6F 6C 
1A092A0 	20 73 74 72 75 63 74 75 
1A092A8 	72 65 20 6D 69 73 6D 61 
1A092B0 	74 63 68  0 58 46 A0  1 

[ifndef] run-time

\ Compiler and state error checking
: ?comp   (s -- )  state @  0= ( -14 ) abort" Compilation Only " ;
1A092B8 	 0  0 3F 63 6F 6D 70 85 
1A092C0 	8C 92 A0  1 20 40 A0  1 
1A092C8 	38 54 A0  1 5C 4C A0  1 
1A092D0 	24 47 A0  1  8 81 A0  1 
1A092D8 	11 43 6F 6D 70 69 6C 61 
1A092E0 	74 69 6F 6E 20 4F 6E 6C 
1A092E8 	79 20  0  0 58 46 A0  1 
: ?exec   (s -- )  state @     ( -29 ) abort" Execution Only " ;
1A092F0 	 0  0 3F 65 78 65 63 85 
1A092F8 	C4 92 A0  1 20 40 A0  1 
1A09300 	38 54 A0  1 5C 4C A0  1 
1A09308 	 8 81 A0  1  F 45 78 65 
1A09310 	63 75 74 69 6F 6E 20 4F 
1A09318 	6E 6C 79 20  0  0  0  0 
1A09320 	58 46 A0  1 

: parse-word  ( -- adr len )
1A09324 	 0 70 61 72 
1A09328 	73 65 2D 77 6F 72 64 8A 
1A09330 	FC 92 A0  1 20 40 A0  1 
   source >in @ /string  over >r   ( adr1 len1 )  ( r: adr1 )
1A09338 	84 81 A0  1 28 85 A0  1 
1A09340 	5C 4C A0  1 3C 85 A0  1 
1A09348 	54 49 A0  1 BC 45 A0  1 
   skipwhite                       ( adr2 len2 )
1A09350 	CC 64 A0  1 
   scantowhite                     ( adr2 adr3 adr4 )
1A09354 	 0 65 A0  1 
   r> - >in +!                     ( adr2 adr3 ) ( r: )
1A09358 	D0 45 A0  1 18 45 A0  1 
1A09360 	28 85 A0  1  C 4C A0  1 
   over -                          ( adr1 len )
1A09368 	54 49 A0  1 18 45 A0  1 
;
1A09370 	58 46 A0  1 

: safe-parse-word  ( -- adr len )
1A09374 	73 61 66 65 
1A09378 	2D 70 61 72 73 65 2D 77 
1A09380 	6F 72 64 8F 34 93 A0  1 
1A09388 	20 40 A0  1 
   parse-word dup 0=  ( -16 ) abort" Unexpected end-of-line"
1A0938C 	34 93 A0  1 
1A09390 	40 49 A0  1 24 47 A0  1 
1A09398 	 8 81 A0  1 16 55 6E 65 
1A093A0 	78 70 65 63 74 65 64 20 
1A093A8 	65 6E 64 2D 6F 66 2D 6C 
1A093B0 	69 6E 65  0 
;
1A093B4 	58 46 A0  1 

defer $find
1A093B8 	 0  0 24 66 69 6E 64 85 
1A093C0 	88 93 A0  1 5C 40 A0  1 
1A093C8 	30  1  0  0 

: defined?  ( "name" -- flag )
1A093CC 	 0  0  0 64 
1A093D0 	65 66 69 6E 65 64 3F 88 
1A093D8 	C4 93 A0  1 20 40 A0  1 
   safe-parse-word  $find  dup  if  nip  else  nip nip  then
1A093E0 	88 93 A0  1 C4 93 A0  1 
1A093E8 	40 49 A0  1 DC 41 A0  1 
1A093F0 	10  0  0  0 FC 46 A0  1 
1A093F8 	C8 41 A0  1  C  0  0  0 
1A09400 	FC 46 A0  1 FC 46 A0  1 
;
1A09408 	58 46 A0  1 
: $defined   (s -- adr len 0 | xt +-1 )  safe-parse-word $find  ;
1A0940C 	 0  0  0 24 
1A09410 	64 65 66 69 6E 65 64 88 
1A09418 	DC 93 A0  1 20 40 A0  1 
1A09420 	88 93 A0  1 C4 93 A0  1 
1A09428 	58 46 A0  1 
  ' noop is mark-error
  ' noop is show-error
: where  ( -- )  mark-error show-error  ;
1A0942C 	 0  0 77 68 
1A09430 	65 72 65 85 1C 94 A0  1 
1A09438 	20 40 A0  1 E0 7F A0  1 
1A09440 	F8 7F A0  1 58 46 A0  1 

: .not-found  ( adr len -- )  where  type ."  ?" cr  ;
1A09448 	 0 2E 6E 6F 74 2D 66 6F 
1A09450 	75 6E 64 8A 38 94 A0  1 
1A09458 	20 40 A0  1 38 94 A0  1 
1A09460 	 4 6C A0  1 20 7C A0  1 
1A09468 	 2 20 3F  0 80 6D A0  1 
1A09470 	58 46 A0  1 
: $?missing  ( +-1 | adr len 0 -- +-1 )
1A09474 	 0  0 24 3F 
1A09478 	6D 69 73 73 69 6E 67 89 
1A09480 	58 94 A0  1 20 40 A0  1 
   dup 0=  if  drop  .not-found  ( -13 ) abort  then
1A09488 	40 49 A0  1 24 47 A0  1 
1A09490 	DC 41 A0  1 10  0  0  0 
1A09498 	30 49 A0  1 58 94 A0  1 
1A094A0 	28 91 A0  1 
;
1A094A4 	58 46 A0  1 
: 'i  ( "name" -- xt +-1 )  $defined $?missing  ;
1A094A8 	 0 27 69 82 84 94 A0  1 
1A094B0 	20 40 A0  1 1C 94 A0  1 
1A094B8 	84 94 A0  1 58 46 A0  1 
: literal     (s n -- )
1A094C0 	6C 69 74 65 72 61 6C C7 
1A094C8 	B0 94 A0  1 20 40 A0  1 
\t16   dup -1  h# fffe  between  if
\t16      compile (wlit) 1+ w,
\t16   else
\t16      compile  (lit)  ,
\t16   then

64\ \t32   dup -1 h# 0.ffff.fffe n->l between  if
64\ \t32      compile (llit) 1+ l,
64\ \t32   else
    \t32      compile (lit) ,
1A094D0 	8C 75 A0  1 58 41 A0  1 
1A094D8 	98 55 A0  1 
64\ \t32   then
;  immediate
1A094DC 	58 46 A0  1 
: lliteral  (s l -- )  compile (llit) l,  ; immediate
1A094E0 	 0  0  0 6C 6C 69 74 65 
1A094E8 	72 61 6C C8 CC 94 A0  1 
1A094F0 	20 40 A0  1 8C 75 A0  1 
1A094F8 	6C 41 A0  1 F8 55 A0  1 
1A09500 	58 46 A0  1 
: dliteral  (s l -- )  compile (dlit) d,  ; immediate
1A09504 	 0  0  0 64 
1A09508 	6C 69 74 65 72 61 6C C8 
1A09510 	F0 94 A0  1 20 40 A0  1 
1A09518 	8C 75 A0  1 80 41 A0  1 
1A09520 	6C 92 A0  1 58 46 A0  1 

: 2literal   ( d -- )  swap  [compile] literal  [compile] literal  ; immediate
1A09528 	 0  0  0 32 6C 69 74 65 
1A09530 	72 61 6C C8 14 95 A0  1 
1A09538 	20 40 A0  1 68 49 A0  1 
1A09540 	CC 94 A0  1 CC 94 A0  1 
1A09548 	58 46 A0  1 

: char  \ char (s -- n )
1A0954C 	 0  0  0 63 
1A09550 	68 61 72 84 38 95 A0  1 
1A09558 	20 40 A0  1 
   safe-parse-word drop c@
1A0955C 	88 93 A0  1 
1A09560 	30 49 A0  1 C4 4C A0  1 
;
1A09568 	58 46 A0  1 

defer do-literal
1A0956C 	 0 64 6F 2D 
1A09570 	6C 69 74 65 72 61 6C 8A 
1A09578 	58 95 A0  1 5C 40 A0  1 
1A09580 	34  1  0  0 

: [char]  \ char  (s -- )
1A09584 	 0 5B 63 68 
1A09588 	61 72 5D C6 7C 95 A0  1 
1A09590 	20 40 A0  1 
   char  1 do-literal
1A09594 	58 95 A0  1 
1A09598 	80 6F A0  1 7C 95 A0  1 
; immediate
1A095A0 	58 46 A0  1 
: ascii  \ char (s -- n )
1A095A4 	 0  0 61 73 
1A095A8 	63 69 69 C5 90 95 A0  1 
1A095B0 	20 40 A0  1 
   char  1 do-literal
1A095B4 	58 95 A0  1 
1A095B8 	80 6F A0  1 7C 95 A0  1 
; immediate
1A095C0 	58 46 A0  1 
: control  \ char  (s -- n )
1A095C4 	63 6F 6E 74 
1A095C8 	72 6F 6C C7 B0 95 A0  1 
1A095D0 	20 40 A0  1 
   char  bl 1- and  1 do-literal
1A095D4 	58 95 A0  1 
1A095D8 	28 70 A0  1 54 4B A0  1 
1A095E0 	5C 44 A0  1 80 6F A0  1 
1A095E8 	7C 95 A0  1 
; immediate
1A095EC 	58 46 A0  1 

: '   \ name  (s -- cfa )
1A095F0 	 0  0 27 81 D0 95 A0  1 
1A095F8 	20 40 A0  1 
   'i drop
1A095FC 	B0 94 A0  1 
1A09600 	30 49 A0  1 
;
1A09604 	58 46 A0  1 
: [']  \ name  (s -- )  ( Run time: -- acf )
1A09608 	5B 27 5D C3 F8 95 A0  1 
1A09610 	20 40 A0  1 
   +level ' compile (') compile, -level
1A09614 	 4 83 A0  1 
1A09618 	F8 95 A0  1 8C 75 A0  1 
1A09620 	60 53 A0  1 74 75 A0  1 
1A09628 	98 83 A0  1 
; immediate
1A0962C 	58 46 A0  1 
: [compile]  \ name  (s -- )
1A09630 	 0  0 5B 63 6F 6D 70 69 
1A09638 	6C 65 5D C9 10 96 A0  1 
1A09640 	20 40 A0  1 
   ' compile,
1A09644 	F8 95 A0  1 
1A09648 	74 75 A0  1 
; immediate
1A0964C 	58 46 A0  1 
: postpone  \ name  (s -- )
1A09650 	 0  0  0 70 6F 73 74 70 
1A09658 	6F 6E 65 C8 40 96 A0  1 
1A09660 	20 40 A0  1 
   'i  0<  if  compile compile  then  compile,
1A09664 	B0 94 A0  1 
1A09668 	64 47 A0  1 DC 41 A0  1 
1A09670 	 C  0  0  0 8C 75 A0  1 
1A09678 	8C 75 A0  1 74 75 A0  1 
; immediate
1A09680 	58 46 A0  1 

: recurse  (s -- )  lastacf compile,  ; immediate
1A09684 	72 65 63 75 
1A09688 	72 73 65 C7 60 96 A0  1 
1A09690 	20 40 A0  1 AC 57 A0  1 
1A09698 	74 75 A0  1 58 46 A0  1 

\ : dumpx  \ name  (s -- )
\   blword 10 dump
\ ;

: abort"  \ string"  (s -- )
1A096A0 	 0 61 62 6F 72 74 22 C6 
1A096A8 	90 96 A0  1 20 40 A0  1 
   +level  compile (abort")  ,"  -level
1A096B0 	 4 83 A0  1 8C 75 A0  1 
1A096B8 	 8 81 A0  1 88 89 A0  1 
1A096C0 	98 83 A0  1 
; immediate
1A096C4 	58 46 A0  1 

[then]


headerless
: +>mark    (s acf -- >mark )  +level compile,  here 0 branch,  ;
1A096C8 	 0 2B 3E 6D 61 72 6B 86 
1A096D0 	AC 96 A0  1 20 40 A0  1 
1A096D8 	 4 83 A0  1 74 75 A0  1 
1A096E0 	70 54 A0  1 70 6F A0  1 
1A096E8 	10 58 A0  1 58 46 A0  1 
: +<mark    (s -- <mark )      +level  here  ;
1A096F0 	 0 2B 3C 6D 61 72 6B 86 
1A096F8 	D4 96 A0  1 20 40 A0  1 
1A09700 	 4 83 A0  1 70 54 A0  1 
1A09708 	58 46 A0  1 
: ->resolve (s >mark -- )      here over - swap branch!  -level  ;
1A0970C 	 0  0 2D 3E 
1A09710 	72 65 73 6F 6C 76 65 89 
1A09718 	FC 96 A0  1 20 40 A0  1 
1A09720 	70 54 A0  1 54 49 A0  1 
1A09728 	18 45 A0  1 68 49 A0  1 
1A09730 	40 58 A0  1 98 83 A0  1 
1A09738 	58 46 A0  1 
: -<resolve (s <mark acf -- )  compile,  here - branch,  -level  ;
1A0973C 	 0  0 2D 3C 
1A09740 	72 65 73 6F 6C 76 65 89 
1A09748 	1C 97 A0  1 20 40 A0  1 
1A09750 	74 75 A0  1 70 54 A0  1 
1A09758 	18 45 A0  1 10 58 A0  1 
1A09760 	98 83 A0  1 58 46 A0  1 
headers

: but      ( m1 m2 -- m2 m1 )  swap  ;
1A09768 	62 75 74 83 4C 97 A0  1 
1A09770 	20 40 A0  1 68 49 A0  1 
1A09778 	58 46 A0  1 
: yet      ( m -- m m )  dup  ;
1A0977C 	79 65 74 83 
1A09780 	70 97 A0  1 20 40 A0  1 
1A09788 	40 49 A0  1 58 46 A0  1 
: cs-pick  ( mn .. m0 n -- mn .. m0 mn )  pick  ;
1A09790 	63 73 2D 70 69 63 6B 87 
1A09798 	84 97 A0  1 20 40 A0  1 
1A097A0 	 C 4A A0  1 58 46 A0  1 
: cs-roll  ( mn .. m0 n -- mn-1 .. m0 mn )  roll  ;
1A097A8 	63 73 2D 72 6F 6C 6C 87 
1A097B0 	9C 97 A0  1 20 40 A0  1 
1A097B8 	50 70 A0  1 58 46 A0  1 

: begin   ( -- <m )        +<mark				; immediate
1A097C0 	 0  0 62 65 67 69 6E C5 
1A097C8 	B4 97 A0  1 20 40 A0  1 
1A097D0 	FC 96 A0  1 58 46 A0  1 
: until   ( <m -- )        ['] ?branch -<resolve		; immediate
1A097D8 	 0  0 75 6E 74 69 6C C5 
1A097E0 	CC 97 A0  1 20 40 A0  1 
1A097E8 	60 53 A0  1 DC 41 A0  1 
1A097F0 	4C 97 A0  1 58 46 A0  1 
: again   ( <m -- )        ['] branch  -<resolve		; immediate
1A097F8 	 0  0 61 67 61 69 6E C5 
1A09800 	E4 97 A0  1 20 40 A0  1 
1A09808 	60 53 A0  1 C8 41 A0  1 
1A09810 	4C 97 A0  1 58 46 A0  1 

: if      ( -- >m )        ['] ?branch +>mark			; immediate
1A09818 	 0 69 66 C2  4 98 A0  1 
1A09820 	20 40 A0  1 60 53 A0  1 
1A09828 	DC 41 A0  1 D4 96 A0  1 
1A09830 	58 46 A0  1 
: ahead   ( -- >m )        ['] branch  +>mark			; immediate
1A09834 	 0  0 61 68 
1A09838 	65 61 64 C5 20 98 A0  1 
1A09840 	20 40 A0  1 60 53 A0  1 
1A09848 	C8 41 A0  1 D4 96 A0  1 
1A09850 	58 46 A0  1 
: then    ( >m -- )        ->resolve				; immediate
1A09854 	 0  0  0 74 
1A09858 	68 65 6E C4 40 98 A0  1 
1A09860 	20 40 A0  1 1C 97 A0  1 
1A09868 	58 46 A0  1 

: repeat  ( >m <m -- )     [compile] again      [compile] then	; immediate
1A0986C 	 0 72 65 70 
1A09870 	65 61 74 C6 60 98 A0  1 
1A09878 	20 40 A0  1  4 98 A0  1 
1A09880 	60 98 A0  1 58 46 A0  1 
: else	  ( >m1 -- >m2 )   [compile] ahead  but [compile] then	; immediate
1A09888 	 0  0  0 65 6C 73 65 C4 
1A09890 	78 98 A0  1 20 40 A0  1 
1A09898 	40 98 A0  1 70 97 A0  1 
1A098A0 	60 98 A0  1 58 46 A0  1 
: while   ( <m -- >m <m )  [compile] if     but			; immediate
1A098A8 	 0  0 77 68 69 6C 65 C5 
1A098B0 	94 98 A0  1 20 40 A0  1 
1A098B8 	20 98 A0  1 70 97 A0  1 
1A098C0 	58 46 A0  1 

: do      ( -- >m <m )     ['] (do)    +>mark     +<mark	; immediate
1A098C4 	 0 64 6F C2 
1A098C8 	B4 98 A0  1 20 40 A0  1 
1A098D0 	60 53 A0  1 88 42 A0  1 
1A098D8 	D4 96 A0  1 FC 96 A0  1 
1A098E0 	58 46 A0  1 
: ?do     ( -- >m <m )     ['] (?do)   +>mark     +<mark	; immediate
1A098E4 	3F 64 6F C3 
1A098E8 	CC 98 A0  1 20 40 A0  1 
1A098F0 	60 53 A0  1 50 42 A0  1 
1A098F8 	D4 96 A0  1 FC 96 A0  1 
1A09900 	58 46 A0  1 
: loop    ( >m <m -- )     ['] (loop)  -<resolve  ->resolve	; immediate
1A09904 	 0  0  0 6C 
1A09908 	6F 6F 70 C4 EC 98 A0  1 
1A09910 	20 40 A0  1 60 53 A0  1 
1A09918 	F8 41 A0  1 4C 97 A0  1 
1A09920 	1C 97 A0  1 58 46 A0  1 
: +loop   ( >m <m -- )     ['] (+loop) -<resolve  ->resolve	; immediate
1A09928 	 0  0 2B 6C 6F 6F 70 C5 
1A09930 	10 99 A0  1 20 40 A0  1 
1A09938 	60 53 A0  1 1C 42 A0  1 
1A09940 	4C 97 A0  1 1C 97 A0  1 
1A09948 	58 46 A0  1 

\ XXX According to ANS Forth, LEAVE and ?LEAVE no longer have to be immediate
: leave   ( -- )   compile (leave)                              ; immediate
1A0994C 	 0  0 6C 65 
1A09950 	61 76 65 C5 34 99 A0  1 
1A09958 	20 40 A0  1 8C 75 A0  1 
1A09960 	18 43 A0  1 58 46 A0  1 
: ?leave  ( -- )   compile (?leave)                             ; immediate
1A09968 	 0 3F 6C 65 61 76 65 C6 
1A09970 	58 99 A0  1 20 40 A0  1 
1A09978 	8C 75 A0  1 34 43 A0  1 
1A09980 	58 46 A0  1 


: ualloc  ( #bytes -- new-user-number )  \ allocates user space
1A09984 	 0 75 61 6C 
1A09988 	6C 6F 63 86 74 99 A0  1 
1A09990 	20 40 A0  1 
   #user @ user-size >=  ( ?? ) abort" User area used up!"   ( #bytes )
1A09994 	7C 66 A0  1 
1A09998 	5C 4C A0  1 E8 65 A0  1 
1A099A0 	EC 48 A0  1  8 81 A0  1 
1A099A8 	12 55 73 65 72 20 61 72 
1A099B0 	65 61 20 75 73 65 64 20 
1A099B8 	75 70 21  0 

   \ If we are allocating fewer bytes than the alignment granularity,
   \ it is safe to assume that strict alignment is not required.
   \ For example, a 2-byte token doesn't have to be aligned on a 4-byte
   \ boundary.
   ( #bytes )
   #user @  over #ualign >=  if  ualigned dup #user !  then  ( #bytes user# )
1A099BC 	7C 66 A0  1 
1A099C0 	5C 4C A0  1 54 49 A0  1 
1A099C8 	D0 66 A0  1 EC 48 A0  1 
1A099D0 	DC 41 A0  1 14  0  0  0 
1A099D8 	E8 66 A0  1 40 49 A0  1 
1A099E0 	7C 66 A0  1 54 4D A0  1 

   swap #user +!
1A099E8 	68 49 A0  1 7C 66 A0  1 
1A099F0 	 C 4C A0  1 
;
1A099F4 	58 46 A0  1 

: user  \ name  (s user# -- )
1A099F8 	 0  0  0 75 73 65 72 84 
1A09A00 	90 99 A0  1 20 40 A0  1 
   header user-cf
1A09A08 	DC 6D A0  1 C4 5B A0  1 
\t32  l,
1A09A10 	F8 55 A0  1 
\t16  w,
;
1A09A14 	58 46 A0  1 

[ifndef] run-time
: nuser  \ name  ( -- )  \ like user but automatically allocates space
1A09A18 	 0  0 6E 75 73 65 72 85 
1A09A20 	 4 9A A0  1 20 40 A0  1 
   /n ualloc user
1A09A28 	40 51 A0  1 90 99 A0  1 
1A09A30 	 4 9A A0  1 
;
1A09A34 	58 46 A0  1 
: tuser  \ name  ( -- )  \ like user but automatically allocates space
1A09A38 	 0  0 74 75 73 65 72 85 
1A09A40 	24 9A A0  1 20 40 A0  1 
   /token ualloc user
1A09A48 	B4 46 A0  1 90 99 A0  1 
1A09A50 	 4 9A A0  1 
;
1A09A54 	58 46 A0  1 
: auser  \ name  ( -- )  \ like user but automatically allocates space
1A09A58 	 0  0 61 75 73 65 72 85 
1A09A60 	44 9A A0  1 20 40 A0  1 
   /a ualloc user
1A09A68 	78 58 A0  1 90 99 A0  1 
1A09A70 	 4 9A A0  1 
;
1A09A74 	58 46 A0  1 
[then]

: user#,  ( #bytes -- user-var-adr )
1A09A78 	 0 75 73 65 72 23 2C 86 
1A09A80 	64 9A A0  1 20 40 A0  1 
   here swap ualloc
1A09A88 	70 54 A0  1 68 49 A0  1 
1A09A90 	90 99 A0  1 
\t32   l,
1A09A94 	F8 55 A0  1 
\t16   w,
   >user
1A09A98 	C8 74 A0  1 
;
1A09A9C 	58 46 A0  1 

[ifndef] run-time
: .id     (s anf -- )  name>string type space  ;
1A09AA0 	2E 69 64 83 84 9A A0  1 
1A09AA8 	20 40 A0  1 58 74 A0  1 
1A09AB0 	 4 6C A0  1 CC 71 A0  1 
1A09AB8 	58 46 A0  1 
: .name   (s acf -- )  >name .id  ;
1A09ABC 	 0  0 2E 6E 
1A09AC0 	61 6D 65 85 A8 9A A0  1 
1A09AC8 	20 40 A0  1 24 74 A0  1 
1A09AD0 	A8 9A A0  1 58 46 A0  1 
[then]

nuser warning      \ control of warning messages
1A09AD8 	77 61 72 6E 69 6E 67 87 
1A09AE0 	C8 9A A0  1 48 40 A0  1 
1A09AE8 	38  1  0  0 
-1       is warning

[ifndef] run-time

\ Dr. Charles Eaker's case statement
\ Example of use:
\ : foo ( selector -- )
\   case
\     0  of  ." It was 0"   endof
\     1  of  ." It was 1"   endof
\     2  of  ." It was 2"   endof
\     ( selector) ." **** It was " dup u.
\   endcase
\ ;
\ The default clause is optional.
\ When an of clause is executed, the selector is NOT on the stack
\ When a default clause is executed, the selector IS on the stack.
\ The default clause may use the selector, but must not remove it
\ from the stack (it will be automatically removed just before the endcase)

\ At run time, (of) tests the top of the stack against the selector.
\ If they are the same, the selector is dropped and the following
\ forth code is executed.  If they are not the same, execution continues
\ at the point just following the the matching ENDOF

: case   ( -- 0 )   +level  0                            ; immediate
1A09AEC 	 0  0  0 63 
1A09AF0 	61 73 65 C4 E4 9A A0  1 
1A09AF8 	20 40 A0  1  4 83 A0  1 
1A09B00 	70 6F A0  1 58 46 A0  1 
: of     ( -- >m )  ['] (of)     +>mark                  ; immediate
1A09B08 	 0 6F 66 C2 F8 9A A0  1 
1A09B10 	20 40 A0  1 60 53 A0  1 
1A09B18 	48 43 A0  1 D4 96 A0  1 
1A09B20 	58 46 A0  1 
: endof  ( >m -- )  ['] (endof)  +>mark  but  ->resolve  ; immediate
1A09B24 	 0  0 65 6E 
1A09B28 	64 6F 66 C5 10 9B A0  1 
1A09B30 	20 40 A0  1 60 53 A0  1 
1A09B38 	6C 43 A0  1 D4 96 A0  1 
1A09B40 	70 97 A0  1 1C 97 A0  1 
1A09B48 	58 46 A0  1 

: endcase  ( 0 [ >m ... ] -- )
1A09B4C 	65 6E 64 63 
1A09B50 	61 73 65 C7 30 9B A0  1 
1A09B58 	20 40 A0  1 
   compile (endcase)
1A09B5C 	8C 75 A0  1 
1A09B60 	84 43 A0  1 
   begin  ?dup  while  ->resolve  repeat
1A09B64 	B4 70 A0  1 
1A09B68 	DC 41 A0  1 10  0  0  0 
1A09B70 	1C 97 A0  1 C8 41 A0  1 
1A09B78 	EC FF FF FF 
   -level
1A09B7C 	98 83 A0  1 
; immediate
1A09B80 	58 46 A0  1 

[then]

\ From interp.fth

\ The Text Interpreter

\ Input stream parsing

\ Error reporting

: lose  (s -- ) true ( -13) abort" Undefined word encountered "  ;
1A09B84 	 0  0  0 6C 
1A09B88 	6F 73 65 84 58 9B A0  1 
1A09B90 	20 40 A0  1  4 70 A0  1 
1A09B98 	 8 81 A0  1 1B 55 6E 64 
1A09BA0 	65 66 69 6E 65 64 20 77 
1A09BA8 	6F 72 64 20 65 6E 63 6F 
1A09BB0 	75 6E 74 65 72 65 64 20 
1A09BB8 	 0  0  0  0 58 46 A0  1 

\ Number parsing
hex
: >number  (s ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
1A09BC0 	3E 6E 75 6D 62 65 72 87 
1A09BC8 	90 9B A0  1 20 40 A0  1 
  \ convert double number, leaving address of first unconverted byte
   begin  dup  while                  ( ud adr len )
1A09BD0 	40 49 A0  1 DC 41 A0  1 
1A09BD8 	74  0  0  0 
      over c@  base @  digit          ( ud adr len  digit true  |  char false )
1A09BDC 	54 49 A0  1 
1A09BE0 	C4 4C A0  1 B8 75 A0  1 
1A09BE8 	5C 4C A0  1 D8 43 A0  1 
      0=  if  drop exit  then         ( ud adr len  digit )
1A09BF0 	24 47 A0  1 DC 41 A0  1 
1A09BF8 	 C  0  0  0 30 49 A0  1 
1A09C00 	40 46 A0  1 
      >r  2swap  r>                   ( adr len ud  digit )
1A09C04 	BC 45 A0  1 
1A09C08 	F4 49 A0  1 D0 45 A0  1 
      swap base @ um*  drop           ( adr len ud.low  digit ud.high' )
1A09C10 	68 49 A0  1 B8 75 A0  1 
1A09C18 	5C 4C A0  1 50 5D A0  1 
1A09C20 	30 49 A0  1 
      rot base @ um*  d+              ( adr len  ud' )
1A09C24 	7C 49 A0  1 
1A09C28 	B8 75 A0  1 5C 4C A0  1 
1A09C30 	50 5D A0  1 E0 5D A0  1 
      2swap  1 /string                ( ud' adr len )
1A09C38 	F4 49 A0  1 80 6F A0  1 
1A09C40 	3C 85 A0  1 
   repeat                             ( ud' adr len )
1A09C44 	C8 41 A0  1 
1A09C48 	88 FF FF FF 
;
1A09C4C 	58 46 A0  1 
: numdelim?  ( char -- flag )  dup ascii . =  swap ascii , =  or  ;
1A09C50 	 0  0 6E 75 6D 64 65 6C 
1A09C58 	69 6D 3F 89 CC 9B A0  1 
1A09C60 	20 40 A0  1 40 49 A0  1 
1A09C68 	58 41 A0  1 2E  0  0  0 
1A09C70 	24 48 A0  1 68 49 A0  1 
1A09C78 	58 41 A0  1 2C  0  0  0 
1A09C80 	24 48 A0  1 70 44 A0  1 
1A09C88 	58 46 A0  1 
: $dnumber?  ( adr len -- [ n .. ] #cells )
1A09C8C 	 0  0 24 64 
1A09C90 	6E 75 6D 62 65 72 3F 89 
1A09C98 	60 9C A0  1 20 40 A0  1 
   0 0  2swap                                         ( ud $ )
1A09CA0 	70 6F A0  1 70 6F A0  1 
1A09CA8 	F4 49 A0  1 
   dup  0=  if  4drop  0  exit  then            ( ud $ )
1A09CAC 	40 49 A0  1 
1A09CB0 	24 47 A0  1 DC 41 A0  1 
1A09CB8 	10  0  0  0 38 53 A0  1 
1A09CC0 	70 6F A0  1 40 46 A0  1 
   over c@ ascii - =                                  ( ud $ neg? )
1A09CC8 	54 49 A0  1 C4 4C A0  1 
1A09CD0 	58 41 A0  1 2D  0  0  0 
1A09CD8 	24 48 A0  1 
   dup  >r  negate /string                            ( ud $' )  ( r: neg? )
1A09CDC 	40 49 A0  1 
1A09CE0 	BC 45 A0  1 48 45 A0  1 
1A09CE8 	3C 85 A0  1 

   \ Convert groups of digits possibly separated by periods or commas
   begin  >number  dup 1 >  while                     ( ud' $' )
1A09CEC 	CC 9B A0  1 
1A09CF0 	40 49 A0  1 80 6F A0  1 
1A09CF8 	 4 48 A0  1 DC 41 A0  1 
1A09D00 	3C  0  0  0 
      over c@ numdelim?  0=  if                       ( ud' $' )
1A09D04 	54 49 A0  1 
1A09D08 	C4 4C A0  1 60 9C A0  1 
1A09D10 	24 47 A0  1 DC 41 A0  1 
1A09D18 	14  0  0  0 
         r> 5drop  0  exit				( ud' $' )
1A09D1C 	D0 45 A0  1 
1A09D20 	4C 53 A0  1 70 6F A0  1 
1A09D28 	40 46 A0  1 
      then                                            ( ud' $' )
      1 /string                                       ( ud' $' )
1A09D2C 	80 6F A0  1 
1A09D30 	3C 85 A0  1 
   repeat                                             ( ud' $' )
1A09D34 	C8 41 A0  1 
1A09D38 	B4 FF FF FF 

   if                                                 ( ud adr )
1A09D3C 	DC 41 A0  1 
1A09D40 	40  0  0  0 
      \ Do not accept a trailing comma, thus preventing,
      \ for example, "c," from being interpreted as a number
      c@  ascii . =  if                               ( ud )
1A09D44 	C4 4C A0  1 
1A09D48 	58 41 A0  1 2E  0  0  0 
1A09D50 	24 48 A0  1 DC 41 A0  1 
1A09D58 	10  0  0  0 
         true                                         ( ud dbl? )
1A09D5C 	 4 70 A0  1 
      else                                            ( ud )
1A09D60 	C8 41 A0  1 14  0  0  0 
         r> 3drop  0  exit
1A09D68 	D0 45 A0  1 90 52 A0  1 
1A09D70 	70 6F A0  1 40 46 A0  1 
      then                                            ( ud dbl? )
   else                                               ( ud adr )
1A09D78 	C8 41 A0  1  C  0  0  0 
      drop false                                      ( ud dbl? )
1A09D80 	30 49 A0  1 18 70 A0  1 
   then                                               ( ud dbl? )

   over or  if                                        ( ud )
1A09D88 	54 49 A0  1 70 44 A0  1 
1A09D90 	DC 41 A0  1 20  0  0  0 
      r>  if  dnegate  then  2
1A09D98 	D0 45 A0  1 DC 41 A0  1 
1A09DA0 	 8  0  0  0 4C 68 A0  1 
1A09DA8 	90 6F A0  1 
   else
1A09DAC 	C8 41 A0  1 
1A09DB0 	1C  0  0  0 
      drop  r>  if  negate  then  1
1A09DB4 	30 49 A0  1 
1A09DB8 	D0 45 A0  1 DC 41 A0  1 
1A09DC0 	 8  0  0  0 48 45 A0  1 
1A09DC8 	80 6F A0  1 
   then
;
1A09DCC 	58 46 A0  1 

defer do-defined    ( cfa -1 | cfa 1  -- ?? )
1A09DD0 	 0 64 6F 2D 64 65 66 69 
1A09DD8 	6E 65 64 8A 9C 9C A0  1 
1A09DE0 	5C 40 A0  1 3C  1  0  0 
defer $do-undefined  ( adr len -- )
1A09DE8 	 0  0 24 64 6F 2D 75 6E 
1A09DF0 	64 65 66 69 6E 65 64 8D 
1A09DF8 	E0 9D A0  1 5C 40 A0  1 
1A09E00 	40  1  0  0 

headers
: (do-literal)  ( n 1 | d 2 -- n | d | )
1A09E04 	 0  0  0 28 
1A09E08 	64 6F 2D 6C 69 74 65 72 
1A09E10 	61 6C 29 8C FC 9D A0  1 
1A09E18 	20 40 A0  1 
   state @  if
1A09E1C 	38 54 A0  1 
1A09E20 	5C 4C A0  1 DC 41 A0  1 
1A09E28 	2C  0  0  0 
      2 =  if  [compile] dliteral  else  [compile] literal  then
1A09E2C 	90 6F A0  1 
1A09E30 	24 48 A0  1 DC 41 A0  1 
1A09E38 	10  0  0  0 14 95 A0  1 
1A09E40 	C8 41 A0  1  8  0  0  0 
1A09E48 	CC 94 A0  1 
   else
1A09E4C 	C8 41 A0  1 
1A09E50 	 8  0  0  0 
      drop
1A09E54 	30 49 A0  1 
   then
;
1A09E58 	58 46 A0  1 
' (do-literal) is do-literal
defer $handle-literal?  ( adr len -- handled? )
1A09E5C 	 0  0  0 24 
1A09E60 	68 61 6E 64 6C 65 2D 6C 
1A09E68 	69 74 65 72 61 6C 3F 90 
1A09E70 	18 9E A0  1 5C 40 A0  1 
1A09E78 	44  1  0  0 
: ($handle-literal?)  ( adr len -- handled? )
1A09E7C 	 0 28 24 68 
1A09E80 	61 6E 64 6C 65 2D 6C 69 
1A09E88 	74 65 72 61 6C 3F 29 92 
1A09E90 	74 9E A0  1 20 40 A0  1 
   $dnumber?  dup  if  do-literal true  then
1A09E98 	9C 9C A0  1 40 49 A0  1 
1A09EA0 	DC 41 A0  1  C  0  0  0 
1A09EA8 	7C 95 A0  1  4 70 A0  1 
;
1A09EB0 	58 46 A0  1 
' ($handle-literal?) is $handle-literal?

headers
: $compile  ( adr len -- ?? )
1A09EB4 	 0  0  0 24 
1A09EB8 	63 6F 6D 70 69 6C 65 88 
1A09EC0 	94 9E A0  1 20 40 A0  1 
   2dup  2>r                        ( adr len )  ( r: adr len )
1A09EC8 	C0 49 A0  1 F8 45 A0  1 
   $find  dup  if                   ( xt +-1 )
1A09ED0 	C4 93 A0  1 40 49 A0  1 
1A09ED8 	DC 41 A0  1 18  0  0  0 
      2r> 2drop do-defined          ( )
1A09EE0 	10 46 A0  1 AC 49 A0  1 
1A09EE8 	E0 9D A0  1 
   else                             ( adr' len' 0 )
1A09EEC 	C8 41 A0  1 
1A09EF0 	2C  0  0  0 
      3drop                         ( )
1A09EF4 	90 52 A0  1 
      2r@ $handle-literal?  0=  if  ( )
1A09EF8 	28 46 A0  1 74 9E A0  1 
1A09F00 	24 47 A0  1 DC 41 A0  1 
1A09F08 	 C  0  0  0 
         2r@  $do-undefined         ( )
1A09F0C 	28 46 A0  1 
1A09F10 	FC 9D A0  1 
      then
      2r> 2drop
1A09F14 	10 46 A0  1 
1A09F18 	AC 49 A0  1 
  then
;
1A09F1C 	58 46 A0  1 
headerless
: interpret-do-defined  ( cfa -1 | cfa 1 -- ?? )  drop execute  ;
1A09F20 	 0  0  0 69 6E 74 65 72 
1A09F28 	70 72 65 74 2D 64 6F 2D 
1A09F30 	64 65 66 69 6E 65 64 94 
1A09F38 	C4 9E A0  1 20 40 A0  1 
1A09F40 	30 49 A0  1 98 41 A0  1 
1A09F48 	58 46 A0  1 
: compile-do-defined    ( cfa -1 | cfa 1 -- )
1A09F4C 	 0 63 6F 6D 
1A09F50 	70 69 6C 65 2D 64 6F 2D 
1A09F58 	64 65 66 69 6E 65 64 92 
1A09F60 	3C 9F A0  1 20 40 A0  1 
  0> if    execute   \ if immediate
1A09F68 	A4 47 A0  1 DC 41 A0  1 
1A09F70 	10  0  0  0 98 41 A0  1 
     else  compile,  \ if not immediate
1A09F78 	C8 41 A0  1  8  0  0  0 
1A09F80 	74 75 A0  1 
     then
;
1A09F84 	58 46 A0  1 
headers
0 value 'error-word
1A09F88 	27 65 72 72 6F 72 2D 77 
1A09F90 	6F 72 64 8B 64 9F A0  1 
1A09F98 	50 40 A0  1 48  1  0  0 
\ Abort after an undefined word in interpret state
: $interpret-do-undefined  ( adr len -- )
1A09FA0 	24 69 6E 74 65 72 70 72 
1A09FA8 	65 74 2D 64 6F 2D 75 6E 
1A09FB0 	64 65 66 69 6E 65 64 97 
1A09FB8 	98 9F A0  1 20 40 A0  1 
   d# 32 min 'error-word pack  count
1A09FC0 	58 41 A0  1 20  0  0  0 
1A09FC8 	74 4A A0  1 98 9F A0  1 
1A09FD0 	DC 52 A0  1 BC 53 A0  1 
   set-abort-message  d# -13 throw
1A09FD8 	60 80 A0  1 58 41 A0  1 
1A09FE0 	F3 FF FF FF 74 7F A0  1 
;
1A09FE8 	58 46 A0  1 
\ Compile a surrogate for an undefined word in compile state
: $compile-do-undefined    ( adr len -- )  .not-found  compile lose  ;
1A09FEC 	 0  0 24 63 
1A09FF0 	6F 6D 70 69 6C 65 2D 64 
1A09FF8 	6F 2D 75 6E 64 65 66 69 
1A0A000 	6E 65 64 95 BC 9F A0  1 
1A0A008 	20 40 A0  1 58 94 A0  1 
1A0A010 	8C 75 A0  1 90 9B A0  1 
1A0A018 	58 46 A0  1 

headers
\ Run-time error checking
: ?stack  (s ?? -- )
1A0A01C 	 0 3F 73 74 
1A0A020 	61 63 6B 86  8 A0 A0  1 
1A0A028 	20 40 A0  1 
   sp@  sp0 @  swap       u<  ( -4 ) abort" Stack Underflow"
1A0A02C 	6C 45 A0  1 
1A0A030 	8C 66 A0  1 5C 4C A0  1 
1A0A038 	68 49 A0  1 A8 48 A0  1 
1A0A040 	 8 81 A0  1  F 53 74 61 
1A0A048 	63 6B 20 55 6E 64 65 72 
1A0A050 	66 6C 6F 77  0  0  0  0 
   sp@  sp0 @  ps-size -  u<  ( -3 ) abort" Stack Overflow"
1A0A058 	6C 45 A0  1 8C 66 A0  1 
1A0A060 	5C 4C A0  1 84 8E A0  1 
1A0A068 	18 45 A0  1 A8 48 A0  1 
1A0A070 	 8 81 A0  1  E 53 74 61 
1A0A078 	63 6B 20 4F 76 65 72 66 
1A0A080 	6C 6F 77  0 
;
1A0A084 	58 46 A0  1 

defer ?permitted  ' noop is ?permitted
1A0A088 	 0 3F 70 65 72 6D 69 74 
1A0A090 	74 65 64 8A 28 A0 A0  1 
1A0A098 	5C 40 A0  1 4C  1  0  0 

defer interpret
1A0A0A0 	 0  0 69 6E 74 65 72 70 
1A0A0A8 	72 65 74 89 98 A0 A0  1 
1A0A0B0 	5C 40 A0  1 50  1  0  0 
: (interpret  (s -- )
1A0A0B8 	 0 28 69 6E 74 65 72 70 
1A0A0C0 	72 65 74 8A B0 A0 A0  1 
1A0A0C8 	20 40 A0  1 
   begin
\     ?stack
      parse-word dup
1A0A0CC 	34 93 A0  1 
1A0A0D0 	40 49 A0  1 
   while
1A0A0D4 	DC 41 A0  1 
1A0A0D8 	14  0  0  0 
      ?permitted
1A0A0DC 	98 A0 A0  1 
      $compile
1A0A0E0 	C4 9E A0  1 
   repeat
1A0A0E4 	C8 41 A0  1 
1A0A0E8 	E4 FF FF FF 
   2drop
1A0A0EC 	AC 49 A0  1 
;
1A0A0F0 	58 46 A0  1 
' (interpret  is interpret

\ Ensure that the cursor in on an empty line.
: ??cr  ( -- )  #out @  if  cr  then  ;
1A0A0F4 	 0  0  0 3F 
1A0A0F8 	3F 63 72 84 C8 A0 A0  1 
1A0A100 	20 40 A0  1 5C 6D A0  1 
1A0A108 	5C 4C A0  1 DC 41 A0  1 
1A0A110 	 8  0  0  0 80 6D A0  1 
1A0A118 	58 46 A0  1 

\ This hack is for users of window systems.  If you pick up with the
\ mouse an entire previous command line, including the prompt, then
\ paste it into the current line, Forth will ignore the prompt.
: ok  ( -- )  ;
1A0A11C 	 0 6F 6B 82 
1A0A120 	 0 A1 A0  1 20 40 A0  1 
1A0A128 	58 46 A0  1 

defer status  ( -- )  ' noop is status
1A0A12C 	 0 73 74 61 
1A0A130 	74 75 73 86 24 A1 A0  1 
1A0A138 	5C 40 A0  1 54  1  0  0 


\ A hook for automatic pagination

defer mark-output  ( -- )  ' noop is mark-output
1A0A140 	6D 61 72 6B 2D 6F 75 74 
1A0A148 	70 75 74 8B 38 A1 A0  1 
1A0A150 	5C 40 A0  1 58  1  0  0 


\ Prompts the user for another line of input.  Executed only if the input
\ stream is coming from a terminal.

defer (ok) ( -- )
1A0A158 	 0  0  0 28 6F 6B 29 84 
1A0A160 	50 A1 A0  1 5C 40 A0  1 
1A0A168 	5C  1  0  0 
: "ok" ." ok " ;
1A0A16C 	 0  0  0 22 
1A0A170 	6F 6B 22 84 64 A1 A0  1 
1A0A178 	20 40 A0  1 20 7C A0  1 
1A0A180 	 3 6F 6B 20  0  0  0  0 
1A0A188 	58 46 A0  1 
' "ok" is (ok)

defer reset-page
1A0A18C 	 0 72 65 73 
1A0A190 	65 74 2D 70 61 67 65 8A 
1A0A198 	78 A1 A0  1 5C 40 A0  1 
1A0A1A0 	60  1  0  0 
' noop is reset-page

\ From kernport.fth


[ifndef] run-time

\itc : \itc ; immediate
\itc : \dtc  [compile] \ ; immediate
\itc : \ttc  [compile] \ ; immediate
\dtc : \itc  [compile] \ ; immediate
1A0A1A4 	 0  0  0 5C 
1A0A1A8 	69 74 63 C4 9C A1 A0  1 
1A0A1B0 	20 40 A0  1 74 8A A0  1 
1A0A1B8 	58 46 A0  1 
\dtc : \dtc ; immediate
1A0A1BC 	 0  0  0 5C 
1A0A1C0 	64 74 63 C4 B0 A1 A0  1 
1A0A1C8 	20 40 A0  1 58 46 A0  1 
\dtc : \ttc  [compile] \ ; immediate
1A0A1D0 	 0  0  0 5C 74 74 63 C4 
1A0A1D8 	C8 A1 A0  1 20 40 A0  1 
1A0A1E0 	74 8A A0  1 58 46 A0  1 
\ttc : \itc  [compile] \ ; immediate
\ttc : \dtc  [compile] \ ; immediate
\ttc : \ttc ; immediate
\t8  : \t8  ; immediate
\t8  : \t16  [compile] \ ; immediate
\t8  : \t32  [compile] \ ; immediate
\t16 : \t8   [compile] \ ; immediate
\t16 : \t16 ; immediate
\t16 : \t32  [compile] \ ; immediate
\t32 : \t8   [compile] \ ; immediate
1A0A1E8 	5C 74 38 C3 DC A1 A0  1 
1A0A1F0 	20 40 A0  1 74 8A A0  1 
1A0A1F8 	58 46 A0  1 
\t32 : \t16  [compile] \ ; immediate
1A0A1FC 	 0  0  0 5C 
1A0A200 	74 31 36 C4 F0 A1 A0  1 
1A0A208 	20 40 A0  1 74 8A A0  1 
1A0A210 	58 46 A0  1 
\t32 : \t32 ; immediate
1A0A214 	 0  0  0 5C 
1A0A218 	74 33 32 C4  8 A2 A0  1 
1A0A220 	20 40 A0  1 58 46 A0  1 
16\ : 16\  ; immediate
16\ : 32\  [compile] \  ; immediate
16\ : 64\  [compile] \  ; immediate
32\ : 16\  [compile] \  ; immediate
1A0A228 	31 36 5C C3 20 A2 A0  1 
1A0A230 	20 40 A0  1 74 8A A0  1 
1A0A238 	58 46 A0  1 
32\ : 32\  ; immediate
1A0A23C 	33 32 5C C3 
1A0A240 	30 A2 A0  1 20 40 A0  1 
1A0A248 	58 46 A0  1 
32\ : 64\  [compile] \  ; immediate
1A0A24C 	36 34 5C C3 
1A0A250 	44 A2 A0  1 20 40 A0  1 
1A0A258 	74 8A A0  1 58 46 A0  1 
64\ : 16\  [compile] \  ; immediate
64\ : 32\  [compile] \  ; immediate
64\ : 64\  ; immediate
[then]

\ From definers.fth

\ Extensible Layer            Defining Words
headers

: (header)  \ name  ( -- )
1A0A260 	 0  0  0 28 68 65 61 64 
1A0A268 	65 72 29 88 54 A2 A0  1 
1A0A270 	20 40 A0  1 
   safe-parse-word $header
1A0A274 	88 93 A0  1 
1A0A278 	C8 6D A0  1 
;
1A0A27C 	58 46 A0  1 

' (header) is header

: $create  ( adr len -- )  $header  create-cf  ;
1A0A280 	24 63 72 65 61 74 65 87 
1A0A288 	70 A2 A0  1 20 40 A0  1 
1A0A290 	C8 6D A0  1 30 5B A0  1 
1A0A298 	58 46 A0  1 

: create  \ name  (s -- )
1A0A29C 	 0 63 72 65 
1A0A2A0 	61 74 65 86 8C A2 A0  1 
1A0A2A8 	20 40 A0  1 
   header create-cf
1A0A2AC 	DC 6D A0  1 
1A0A2B0 	30 5B A0  1 
;
1A0A2B4 	58 46 A0  1 

nuser csp          \ for stack position error checking
1A0A2B8 	63 73 70 83 A8 A2 A0  1 
1A0A2C0 	48 40 A0  1 64  1  0  0 
: !csp   (s -- )   sp@ csp !   ;
1A0A2C8 	 0  0  0 21 63 73 70 84 
1A0A2D0 	C0 A2 A0  1 20 40 A0  1 
1A0A2D8 	6C 45 A0  1 C0 A2 A0  1 
1A0A2E0 	54 4D A0  1 58 46 A0  1 
: ?csp   (s -- )   sp@ csp @ <>   ( -22 ) abort" Stack Changed "  ;
1A0A2E8 	 0  0  0 3F 63 73 70 84 
1A0A2F0 	D4 A2 A0  1 20 40 A0  1 
1A0A2F8 	6C 45 A0  1 C0 A2 A0  1 
1A0A300 	5C 4C A0  1 44 48 A0  1 
1A0A308 	 8 81 A0  1  E 53 74 61 
1A0A310 	63 6B 20 43 68 61 6E 67 
1A0A318 	65 64 20  0 58 46 A0  1 

: (;code)   (s -- )  ip>  aligned acf-aligned  used   ;
1A0A320 	28 3B 63 6F 64 65 29 87 
1A0A328 	F4 A2 A0  1 20 40 A0  1 
1A0A330 	84 46 A0  1 EC 5C A0  1 
1A0A338 	 C 5D A0  1 E0 57 A0  1 
1A0A340 	58 46 A0  1 
: (does>)   (s -- )  ip>  acf-aligned  used   ;
1A0A344 	28 64 6F 65 
1A0A348 	73 3E 29 87 2C A3 A0  1 
1A0A350 	20 40 A0  1 84 46 A0  1 
1A0A358 	 C 5D A0  1 E0 57 A0  1 
1A0A360 	58 46 A0  1 

defer do-entercode
1A0A364 	 0  0  0 64 
1A0A368 	6F 2D 65 6E 74 65 72 63 
1A0A370 	6F 64 65 8C 50 A3 A0  1 
1A0A378 	5C 40 A0  1 68  1  0  0 
' noop is do-entercode

: code  \ name  (s -- )
1A0A380 	 0  0  0 63 6F 64 65 84 
1A0A388 	78 A3 A0  1 20 40 A0  1 
   header  code-cf  !csp  do-entercode
1A0A390 	DC 6D A0  1  8 5B A0  1 
1A0A398 	D4 A2 A0  1 78 A3 A0  1 
;
1A0A3A0 	58 46 A0  1 

defer do-exitcode
1A0A3A4 	64 6F 2D 65 
1A0A3A8 	78 69 74 63 6F 64 65 8B 
1A0A3B0 	8C A3 A0  1 5C 40 A0  1 
1A0A3B8 	6C  1  0  0 
' noop is do-exitcode


decimal
32 equ nvocs
nvocs constant #vocs	\ The # of vocabularies that can be in the search path
1A0A3BC 	 0  0 23 76 
1A0A3C0 	6F 63 73 85 B4 A3 A0  1 
1A0A3C8 	68 40 A0  1 20  0  0  0 

nvocs /token-t * ualloc-t user context   \ vocabulary searched first
1A0A3D0 	63 6F 6E 74 65 78 74 87 
1A0A3D8 	C8 A3 A0  1 48 40 A0  1 
1A0A3E0 	70  1  0  0 
tuser current      \ vocabulary which gets new definitions
1A0A3E4 	63 75 72 72 
1A0A3E8 	65 6E 74 87 DC A3 A0  1 
1A0A3F0 	48 40 A0  1 F0  1  0  0 
nuser last
1A0A3F8 	 0  0  0 6C 61 73 74 84 
1A0A400 	F0 A3 A0  1 48 40 A0  1 
1A0A408 	F4  1  0  0 
tuser hidden-voc
1A0A40C 	 0 68 69 64 
1A0A410 	64 65 6E 2D 76 6F 63 8A 
1A0A418 	 4 A4 A0  1 48 40 A0  1 
1A0A420 	F8  1  0  0 

: current-voc  ( -- voc-xt )  current token@  ;
1A0A424 	63 75 72 72 
1A0A428 	65 6E 74 2D 76 6F 63 8B 
1A0A430 	1C A4 A0  1 20 40 A0  1 
1A0A438 	F0 A3 A0  1  C 54 A0  1 
1A0A440 	58 46 A0  1 

: remove-word  ( new-alf voc-acf -- )
1A0A444 	72 65 6D 6F 
1A0A448 	76 65 2D 77 6F 72 64 8B 
1A0A450 	34 A4 A0  1 20 40 A0  1 
   >threads                                   ( new-alf prev-link )
1A0A458 	EC 74 A0  1 
   swap link> swap link>                      ( new-acf prev-link )
1A0A45C 	68 49 A0  1 
1A0A460 	D0 73 A0  1 68 49 A0  1 
1A0A468 	D0 73 A0  1 
   begin                                      ( acf prev-link )
      >link
1A0A46C 	EC 73 A0  1 
      2dup a@ =  if                        ( acf prev-link )
1A0A470 	C0 49 A0  1 88 58 A0  1 
1A0A478 	24 48 A0  1 DC 41 A0  1 
1A0A480 	1C  0  0  0 
         swap >link a@ swap a!  exit    (  )
1A0A484 	68 49 A0  1 
1A0A488 	EC 73 A0  1 88 58 A0  1 
1A0A490 	68 49 A0  1 98 58 A0  1 
1A0A498 	40 46 A0  1 
      then                                    ( acf prev-link )
      another-link? 0=                  ( acf [ next-link ] end? )
1A0A49C 	90 59 A0  1 
1A0A4A0 	24 47 A0  1 
   until
1A0A4A4 	DC 41 A0  1 
1A0A4A8 	C4 FF FF FF 
   drop
1A0A4AC 	30 49 A0  1 
;
1A0A4B0 	58 46 A0  1 

: >ptr  ( alf voc-acf -- ptr )
1A0A4B4 	 0  0  0 3E 
1A0A4B8 	70 74 72 84 54 A4 A0  1 
1A0A4C0 	20 40 A0  1 
   over  if  drop  else  nip >threads  then
1A0A4C4 	54 49 A0  1 
1A0A4C8 	DC 41 A0  1 10  0  0  0 
1A0A4D0 	30 49 A0  1 C8 41 A0  1 
1A0A4D8 	 C  0  0  0 FC 46 A0  1 
1A0A4E0 	EC 74 A0  1 
;
1A0A4E4 	58 46 A0  1 

: insert-word  ( new-alf old-alf voc-ptr -- )
1A0A4E8 	69 6E 73 65 72 74 2D 77 
1A0A4F0 	6F 72 64 8B C0 A4 A0  1 
1A0A4F8 	20 40 A0  1 
   >ptr              ( new-alf alf )
1A0A4FC 	C0 A4 A0  1 
   swap link> swap   ( new-acf alf )
1A0A500 	68 49 A0  1 D0 73 A0  1 
1A0A508 	68 49 A0  1 
   2dup a@        ( new-acf alf  new-acf next-acf )
1A0A50C 	C0 49 A0  1 
1A0A510 	88 58 A0  1 
   swap >link a! a!
1A0A514 	68 49 A0  1 
1A0A518 	EC 73 A0  1 98 58 A0  1 
1A0A520 	98 58 A0  1 
;
1A0A524 	58 46 A0  1 

: not-hidden  ( -- )  hidden-voc !null-token  ;
1A0A528 	 0 6E 6F 74 2D 68 69 64 
1A0A530 	64 65 6E 8A F8 A4 A0  1 
1A0A538 	20 40 A0  1 1C A4 A0  1 
1A0A540 	10 59 A0  1 58 46 A0  1 

: hide   (s -- )
1A0A548 	 0  0  0 68 69 64 65 84 
1A0A550 	38 A5 A0  1 20 40 A0  1 
   current-voc hidden-voc token!
1A0A558 	34 A4 A0  1 1C A4 A0  1 
1A0A560 	20 54 A0  1 
   last @ n>link current-voc remove-word
1A0A564 	 4 A4 A0  1 
1A0A568 	5C 4C A0  1 8C 73 A0  1 
1A0A570 	34 A4 A0  1 54 A4 A0  1 
;
1A0A578 	58 46 A0  1 

: reveal  (s -- )
1A0A57C 	 0 72 65 76 
1A0A580 	65 61 6C 86 54 A5 A0  1 
1A0A588 	20 40 A0  1 
   hidden-voc get-token?  if             ( xt )
1A0A58C 	1C A4 A0  1 
1A0A590 	6C 59 A0  1 DC 41 A0  1 
1A0A598 	20  0  0  0 
      last @ n>link 0  rot  insert-word  ( )
1A0A59C 	 4 A4 A0  1 
1A0A5A0 	5C 4C A0  1 8C 73 A0  1 
1A0A5A8 	70 6F A0  1 7C 49 A0  1 
1A0A5B0 	F8 A4 A0  1 
      not-hidden
1A0A5B4 	38 A5 A0  1 
   then
;
1A0A5B8 	58 46 A0  1 

: end-code  ( -- )
1A0A5BC 	 0  0  0 65 
1A0A5C0 	6E 64 2D 63 6F 64 65 88 
1A0A5C8 	88 A5 A0  1 20 40 A0  1 
   do-exitcode  ?csp
1A0A5D0 	B4 A3 A0  1 F4 A2 A0  1 
;
1A0A5D8 	58 46 A0  1 
: c;  ( -- )  next  end-code  ;
1A0A5DC 	 0 63 3B 82 
1A0A5E0 	CC A5 A0  1 20 40 A0  1 
1A0A5E8 	1C 56 A0  1 CC A5 A0  1 
1A0A5F0 	58 46 A0  1 

: ;code     (s -- )
1A0A5F4 	 0  0 3B 63 
1A0A5F8 	6F 64 65 C5 E4 A5 A0  1 
1A0A600 	20 40 A0  1 
   ?csp   compile  (;code)  align acf-align  place-;code
1A0A604 	F4 A2 A0  1 
1A0A608 	8C 75 A0  1 2C A3 A0  1 
1A0A610 	34 62 A0  1 2C 5D A0  1 
1A0A618 	B8 56 A0  1 
   [compile] [   reveal   do-entercode
1A0A61C 	90 6D A0  1 
1A0A620 	88 A5 A0  1 78 A3 A0  1 
; immediate
1A0A628 	58 46 A0  1 


origin-t is hidden-voc


: does>   (s -- )
1A0A62C 	 0  0 64 6F 
1A0A630 	65 73 3E C5  0 A6 A0  1 
1A0A638 	20 40 A0  1 
   state @  if
1A0A63C 	38 54 A0  1 
1A0A640 	5C 4C A0  1 DC 41 A0  1 
1A0A648 	14  0  0  0 
     compile (does>)
1A0A64C 	8C 75 A0  1 
1A0A650 	50 A3 A0  1 
   else
1A0A654 	C8 41 A0  1 
1A0A658 	20  0  0  0 
     here  aligned acf-aligned  used  !csp not-hidden  ]
1A0A65C 	70 54 A0  1 
1A0A660 	EC 5C A0  1  C 5D A0  1 
1A0A668 	E0 57 A0  1 D4 A2 A0  1 
1A0A670 	38 A5 A0  1 A0 6D A0  1 
   then
   align acf-align  place-does
1A0A678 	34 62 A0  1 2C 5D A0  1 
1A0A680 	4C 56 A0  1 
; immediate
1A0A684 	58 46 A0  1 



: :        (s -- )  ?exec  !csp   header  hide   ]  colon-cf  ;
1A0A688 	 0  0 3A 81 38 A6 A0  1 
1A0A690 	20 40 A0  1 FC 92 A0  1 
1A0A698 	D4 A2 A0  1 DC 6D A0  1 
1A0A6A0 	54 A5 A0  1 A0 6D A0  1 
1A0A6A8 	78 5B A0  1 58 46 A0  1 
: :noname  (s -- xt )  ?exec  not-hidden     ]  colon-cf  lastacf  !csp  ;
1A0A6B0 	3A 6E 6F 6E 61 6D 65 87 
1A0A6B8 	90 A6 A0  1 20 40 A0  1 
1A0A6C0 	FC 92 A0  1 38 A5 A0  1 
1A0A6C8 	A0 6D A0  1 78 5B A0  1 
1A0A6D0 	AC 57 A0  1 D4 A2 A0  1 
1A0A6D8 	58 46 A0  1 
: ;        (s -- )
1A0A6DC 	 0  0 3B C1 
1A0A6E0 	BC A6 A0  1 20 40 A0  1 
   ?comp  ?csp   compile unnest   reveal   [compile] [
1A0A6E8 	C4 92 A0  1 F4 A2 A0  1 
1A0A6F0 	8C 75 A0  1 58 46 A0  1 
1A0A6F8 	88 A5 A0  1 90 6D A0  1 
; immediate
1A0A700 	58 46 A0  1 

: recursive  (s -- )   reveal  ; immediate
1A0A704 	 0  0 72 65 
1A0A708 	63 75 72 73 69 76 65 C9 
1A0A710 	E4 A6 A0  1 20 40 A0  1 
1A0A718 	88 A5 A0  1 58 46 A0  1 

: constant  \ name  (s n -- )
1A0A720 	 0  0  0 63 6F 6E 73 74 
1A0A728 	61 6E 74 88 14 A7 A0  1 
1A0A730 	20 40 A0  1 
   header constant-cf  ,
1A0A734 	DC 6D A0  1 
1A0A738 	 C 5C A0  1 98 55 A0  1 
;
1A0A740 	58 46 A0  1 

: value  \ name  (s value -- )
1A0A744 	 0  0 76 61 
1A0A748 	6C 75 65 85 30 A7 A0  1 
1A0A750 	20 40 A0  1 
   header value-cf  /n user#,  !
1A0A754 	DC 6D A0  1 
1A0A758 	E8 5B A0  1 40 51 A0  1 
1A0A760 	84 9A A0  1 54 4D A0  1 
;
1A0A768 	58 46 A0  1 
: variable  \ name  (s -- )
1A0A76C 	 0  0  0 76 
1A0A770 	61 72 69 61 62 6C 65 88 
1A0A778 	50 A7 A0  1 20 40 A0  1 
   header variable-cf  0 ,
1A0A780 	DC 6D A0  1 54 5B A0  1 
1A0A788 	70 6F A0  1 98 55 A0  1 
;
1A0A790 	58 46 A0  1 
: wvariable  \ name  (s -- )
1A0A794 	 0  0 77 76 
1A0A798 	61 72 69 61 62 6C 65 89 
1A0A7A0 	7C A7 A0  1 20 40 A0  1 
   create variable-cf 0 w,
1A0A7A8 	A8 A2 A0  1 54 5B A0  1 
1A0A7B0 	70 6F A0  1 D8 55 A0  1 
;
1A0A7B8 	58 46 A0  1 

\ defer (is is
\ Also known as execution vectors.
\ Usage:   defer bar
\ : foo ." Hello" ;  ' foo is bar
\ Alternatively: ' foo ' bar (is

\ Since the execution of an execution vector doesn't leave around
\ information about which deferred word was used, we have to try
\ to find it by looking on the return stack
\ if the vector was EXECUTE'd, we don't know what it was.  This
\ will be the case if the deferred word was interpreted from the
\ input stream

: crash ( -- )  \ unitialized execution vector routine
1A0A7BC 	 0  0 63 72 
1A0A7C0 	61 73 68 85 A4 A7 A0  1 
1A0A7C8 	20 40 A0  1 
   \ The following line may not always work right for token-threaded code
   \ with variable-length tokens
   ip@ /token - token@         \ use the return stack to see who called us
1A0A7CC 	9C 46 A0  1 
1A0A7D0 	B4 46 A0  1 18 45 A0  1 
1A0A7D8 	 C 54 A0  1 
   dup word-type  ['] emit word-type =  if  .name  ." <--"  then
1A0A7DC 	40 49 A0  1 
1A0A7E0 	B0 59 A0  1 60 53 A0  1 
1A0A7E8 	2C 6C A0  1 B0 59 A0  1 
1A0A7F0 	24 48 A0  1 DC 41 A0  1 
1A0A7F8 	14  0  0  0 C8 9A A0  1 
1A0A800 	20 7C A0  1  3 3C 2D 2D 
1A0A808 	 0  0  0  0 
   ." deferred word not initialized" abort
1A0A80C 	20 7C A0  1 
1A0A810 	1D 64 65 66 65 72 72 65 
1A0A818 	64 20 77 6F 72 64 20 6E 
1A0A820 	6F 74 20 69 6E 69 74 69 
1A0A828 	61 6C 69 7A 65 64  0  0 
1A0A830 	28 91 A0  1 
;
1A0A834 	58 46 A0  1 

\ Allocates a user area location to hold the vector
: defer  \ name  (s -- )
1A0A838 	 0  0 64 65 66 65 72 85 
1A0A840 	C8 A7 A0  1 20 40 A0  1 
   header  defer-cf
1A0A848 	DC 6D A0  1 30 5C A0  1 
   ['] crash   /token user#,   token!	\ Allocate user location
1A0A850 	60 53 A0  1 C8 A7 A0  1 
1A0A858 	B4 46 A0  1 84 9A A0  1 
1A0A860 	20 54 A0  1 
;
1A0A864 	58 46 A0  1 

: 2constant  \ name  (s d# -- )
1A0A868 	 0  0 32 63 6F 6E 73 74 
1A0A870 	61 6E 74 89 44 A8 A0  1 
1A0A878 	20 40 A0  1 
   header 2constant-cf  swap  , ,
1A0A87C 	DC 6D A0  1 
1A0A880 	58 5C A0  1 68 49 A0  1 
1A0A888 	98 55 A0  1 98 55 A0  1 
;
1A0A890 	58 46 A0  1 
: 2variable  \ name (s -- )
1A0A894 	 0  0 32 76 
1A0A898 	61 72 69 61 62 6C 65 89 
1A0A8A0 	78 A8 A0  1 20 40 A0  1 
   create 0 , 0 ,   (s -- apf )
1A0A8A8 	A8 A2 A0  1 70 6F A0  1 
1A0A8B0 	98 55 A0  1 70 6F A0  1 
1A0A8B8 	98 55 A0  1 
;
1A0A8BC 	58 46 A0  1 

\ buffer:  \ name  ( size -- )
\       Defines a word which returns the address of a buffer of the
\       requested size.  The buffer is allocated at initialization
\       time from free memory, not from the dictionary.

auser buffer-link
1A0A8C0 	62 75 66 66 65 72 2D 6C 
1A0A8C8 	69 6E 6B 8B A4 A8 A0  1 
1A0A8D0 	48 40 A0  1 FC  1  0  0 
0   is buffer-link

headerless
: make-buffer  ( size -- )
1A0A8D8 	6D 61 6B 65 2D 62 75 66 
1A0A8E0 	66 65 72 8B D0 A8 A0  1 
1A0A8E8 	20 40 A0  1 
   here body> swap     ( acf size )
1A0A8EC 	70 54 A0  1 
1A0A8F0 	C8 59 A0  1 68 49 A0  1 
   0 /n user#,  !      ( acf size )
1A0A8F8 	70 6F A0  1 40 51 A0  1 
1A0A900 	84 9A A0  1 54 4D A0  1 
   ,                   ( acf )
1A0A908 	98 55 A0  1 
   buffer-link a@  a,  buffer-link a!
1A0A90C 	D0 A8 A0  1 
1A0A910 	88 58 A0  1 AC 58 A0  1 
1A0A918 	D0 A8 A0  1 98 58 A0  1 
;
1A0A920 	58 46 A0  1 

headers
: do-buffer  ( apf -- adr )
1A0A924 	 0  0 64 6F 
1A0A928 	2D 62 75 66 66 65 72 89 
1A0A930 	E8 A8 A0  1 20 40 A0  1 
   dup >user @  if          ( apf )
1A0A938 	40 49 A0  1 C8 74 A0  1 
1A0A940 	5C 4C A0  1 DC 41 A0  1 
1A0A948 	14  0  0  0 
      >user @               ( adr )
1A0A94C 	C8 74 A0  1 
1A0A950 	5C 4C A0  1 
   else                     ( apf )
1A0A954 	C8 41 A0  1 
1A0A958 	38  0  0  0 
      dup /user# + @        ( apf size )
1A0A95C 	40 49 A0  1 
1A0A960 	40 5A A0  1  4 45 A0  1 
1A0A968 	5C 4C A0  1 
      dup alloc-mem         ( apf size adr )
1A0A96C 	40 49 A0  1 
1A0A970 	F0 6C A0  1 
      dup rot erase         ( apf adr )
1A0A974 	40 49 A0  1 
1A0A978 	7C 49 A0  1 F0 72 A0  1 
      dup rot >user !       ( adr )
1A0A980 	40 49 A0  1 7C 49 A0  1 
1A0A988 	C8 74 A0  1 54 4D A0  1 
   then
;
1A0A990 	58 46 A0  1 
: (buffer:)  ( size -- )
1A0A994 	 0  0 28 62 
1A0A998 	75 66 66 65 72 3A 29 89 
1A0A9A0 	34 A9 A0  1 20 40 A0  1 
   create-cf  make-buffer  does> do-buffer
1A0A9A8 	30 5B A0  1 E8 A8 A0  1 
1A0A9B0 	50 A3 A0  1 90 90 90 E8 
1A0A9B8 	C0 96 FF FF 34 A9 A0  1 
;
1A0A9C0 	58 46 A0  1 

doestarget @ IS DOBUFFER: \ mmo
headers
: buffer:  \ name  ( size -- )
1A0A9C4 	62 75 66 66 
1A0A9C8 	65 72 3A 87 A4 A9 A0  1 
1A0A9D0 	20 40 A0  1 
   header (buffer:)
1A0A9D4 	DC 6D A0  1 
1A0A9D8 	A4 A9 A0  1 
;
1A0A9DC 	58 46 A0  1 

: >buffer-link ( acf -- link-adr )  >body /user# + 1 na+  ;
1A0A9E0 	 0  0  0 3E 62 75 66 66 
1A0A9E8 	65 72 2D 6C 69 6E 6B 8C 
1A0A9F0 	D0 A9 A0  1 20 40 A0  1 
1A0A9F8 	E4 59 A0  1 40 5A A0  1 
1A0AA00 	 4 45 A0  1 80 6F A0  1 
1A0AA08 	48 50 A0  1 58 46 A0  1 

headerless
: clear-buffer:s ( -- )
1A0AA10 	 0 63 6C 65 61 72 2D 62 
1A0AA18 	75 66 66 65 72 3A 73 8E 
1A0AA20 	F4 A9 A0  1 20 40 A0  1 
   buffer-link                         ( next-buffer-word )
1A0AA28 	D0 A8 A0  1 
   begin  another-link?  while         ( acf )
1A0AA2C 	90 59 A0  1 
1A0AA30 	DC 41 A0  1 20  0  0  0 
      dup >body  >user  off            ( acf )
1A0AA38 	40 49 A0  1 E4 59 A0  1 
1A0AA40 	C8 74 A0  1 F8 4B A0  1 
      >buffer-link                     ( prev-buffer:-acf )
1A0AA48 	F4 A9 A0  1 
   repeat                              ( )
1A0AA4C 	C8 41 A0  1 
1A0AA50 	DC FF FF FF 
;
1A0AA54 	58 46 A0  1 

: init  ( -- )  init  clear-buffer:s  ;
1A0AA58 	 0  0  0 69 6E 69 74 84 
1A0AA60 	24 AA A0  1 20 40 A0  1 
1A0AA68 	6C 82 A0  1 24 AA A0  1 
1A0AA70 	58 46 A0  1 
headers

\ From tagvoc.fth

\ Implementation of vocabularies.  Vocabularies are lists of word names.
\ The following operations may be performed on vocabularies:
\    find-word  - Search for a given word
\    "header    - Create a new word in the "current" vocabulary
\    trim       - Remove all words in a vocabulary created after an address
\    another?   - Enumerate all the the words
\
\ Each word name in a vocabulary has the following attributes:
\    immediate flag  - Controls compilation of that word
\

\ Find a potential name field address
: find-name  ( acf -- anf )  >link l>name  ;
1A0AA74 	 0  0 66 69 
1A0AA78 	6E 64 2D 6E 61 6D 65 89 
1A0AA80 	64 AA A0  1 20 40 A0  1 
1A0AA88 	EC 73 A0  1 A4 73 A0  1 
1A0AA90 	58 46 A0  1 

\ The test for a valid header searches backward for the first byte
\ that appears to be a name length byte.  Then the length of the
\ name field implied by the length byte is compared with the actual
\ length, calculated by subtracting anf from acf.  Finally, the characters
\ in the name are checked to make sure that the name contains only printable
\ characters.

: >name?  ( acf -- anf good-name? )
1A0AA94 	 0 3E 6E 61 
1A0AA98 	6D 65 3F 86 84 AA A0  1 
1A0AAA0 	20 40 A0  1 
   dup  find-name                      ( acf anf )
1A0AAA4 	40 49 A0  1 
1A0AAA8 	84 AA A0  1 
   tuck name>string                    ( anf acf name-adr name-len )
1A0AAAC 	E8 46 A0  1 
1A0AAB0 	58 74 A0  1 
   dup 0=  if  3drop false exit  then  ( anf acf name-adr name-len )
1A0AAB4 	40 49 A0  1 
1A0AAB8 	24 47 A0  1 DC 41 A0  1 
1A0AAC0 	10  0  0  0 90 52 A0  1 
1A0AAC8 	18 70 A0  1 40 46 A0  1 
   + /link + acf-aligned               ( anf acf test-acf )
1A0AAD0 	 4 45 A0  1 78 73 A0  1 
1A0AAD8 	 4 45 A0  1  C 5D A0  1 
   <>  if  false exit  then            ( anf )
1A0AAE0 	44 48 A0  1 DC 41 A0  1 
1A0AAE8 	 C  0  0  0 18 70 A0  1 
1A0AAF0 	40 46 A0  1 

   \ Check for bogus (non-printable) characters in the name.
   dup name>string                     ( anf adr len )
1A0AAF4 	40 49 A0  1 
1A0AAF8 	58 74 A0  1 
   true -rot  bounds ?do               ( anf true )
1A0AAFC 	 4 70 A0  1 
1A0AB00 	94 49 A0  1 F0 6D A0  1 
1A0AB08 	50 42 A0  1 38  0  0  0 
      i c@  bl  h# 7f  between  0=  if  0= leave  then
1A0AB10 	B4 42 A0  1 C4 4C A0  1 
1A0AB18 	28 70 A0  1 58 41 A0  1 
1A0AB20 	7F  0  0  0 D8 70 A0  1 
1A0AB28 	24 47 A0  1 DC 41 A0  1 
1A0AB30 	 C  0  0  0 24 47 A0  1 
1A0AB38 	18 43 A0  1 
   loop                                ( anf good-name? )
1A0AB3C 	F8 41 A0  1 
1A0AB40 	D0 FF FF FF 
;
1A0AB44 	58 46 A0  1 



nuser tag-file
1A0AB48 	 0  0  0 74 61 67 2D 66 
1A0AB50 	69 6C 65 88 A0 AA A0  1 
1A0AB58 	48 40 A0  1  0  2  0  0 
nuser 'source-id
1A0AB60 	 0 27 73 6F 75 72 63 65 
1A0AB68 	2D 69 64 8A 58 AB A0  1 
1A0AB70 	48 40 A0  1  4  2  0  0 
nuser file
1A0AB78 	 0  0  0 66 69 6C 65 84 
1A0AB80 	70 AB A0  1 48 40 A0  1 
1A0AB88 	 8  2  0  0 


\ field creates words which return their address within the structure
\ pointed-to by the contents of file

\ The file descriptor structure describes an open file.
\ There is a pool of several of these structures.  When a file is opened,
\ a structure is allocated and initialized.  While performing an io
\ operation, the user variable "file" contains a pointer to the file
\ on which the operation is being performed.

: bfbase    file @  0 na+  ;   \ starting address of the buffer for this file
1A0AB8C 	 0 62 66 62 
1A0AB90 	61 73 65 86 84 AB A0  1 
1A0AB98 	20 40 A0  1 84 AB A0  1 
1A0ABA0 	5C 4C A0  1 70 6F A0  1 
1A0ABA8 	48 50 A0  1 58 46 A0  1 
: bflimit   file @  1 na+  ;   \ ending address of the buffer for this file
1A0ABB0 	62 66 6C 69 6D 69 74 87 
1A0ABB8 	98 AB A0  1 20 40 A0  1 
1A0ABC0 	84 AB A0  1 5C 4C A0  1 
1A0ABC8 	80 6F A0  1 48 50 A0  1 
1A0ABD0 	58 46 A0  1 
headerless
: bftop     file @  2 na+  ;   \ address past last valid character in the buffer
1A0ABD4 	 0  0 62 66 
1A0ABD8 	74 6F 70 85 BC AB A0  1 
1A0ABE0 	20 40 A0  1 84 AB A0  1 
1A0ABE8 	5C 4C A0  1 90 6F A0  1 
1A0ABF0 	48 50 A0  1 58 46 A0  1 
: bfend     file @  3 na+  ;   \ address past last place to write in the buffer
1A0ABF8 	 0  0 62 66 65 6E 64 85 
1A0AC00 	E0 AB A0  1 20 40 A0  1 
1A0AC08 	84 AB A0  1 5C 4C A0  1 
1A0AC10 	A0 6F A0  1 48 50 A0  1 
1A0AC18 	58 46 A0  1 
: bfcurrent file @  4 na+  ;   \ address of the current character in the buffer
1A0AC1C 	 0  0 62 66 
1A0AC20 	63 75 72 72 65 6E 74 89 
1A0AC28 	 4 AC A0  1 20 40 A0  1 
1A0AC30 	84 AB A0  1 5C 4C A0  1 
1A0AC38 	B0 6F A0  1 48 50 A0  1 
1A0AC40 	58 46 A0  1 
: bfdirty   file @  5 na+  ;   \ contains true if the buffer has been modified
1A0AC44 	62 66 64 69 
1A0AC48 	72 74 79 87 2C AC A0  1 
1A0AC50 	20 40 A0  1 84 AB A0  1 
1A0AC58 	5C 4C A0  1 C0 6F A0  1 
1A0AC60 	48 50 A0  1 58 46 A0  1 
: fmode     file @  6 na+  ;   \ not-open, read, write, or modify
1A0AC68 	 0  0 66 6D 6F 64 65 85 
1A0AC70 	50 AC A0  1 20 40 A0  1 
1A0AC78 	84 AB A0  1 5C 4C A0  1 
1A0AC80 	D0 6F A0  1 48 50 A0  1 
1A0AC88 	58 46 A0  1 
: fstart    file @  7 na+  ;   \ Position in file of the first byte in buffer
1A0AC8C 	 0 66 73 74 
1A0AC90 	61 72 74 86 74 AC A0  1 
1A0AC98 	20 40 A0  1 84 AB A0  1 
1A0ACA0 	5C 4C A0  1 E0 6F A0  1 
1A0ACA8 	48 50 A0  1 58 46 A0  1 
: fid       file @  9 na+  ;   \ File handle for underlying operating system
1A0ACB0 	66 69 64 83 98 AC A0  1 
1A0ACB8 	20 40 A0  1 84 AB A0  1 
1A0ACC0 	5C 4C A0  1 58 41 A0  1 
1A0ACC8 	 9  0  0  0 48 50 A0  1 
1A0ACD0 	58 46 A0  1 
: seekop    file @ 10 na+  ;   \ Points to system routine to set the file position
1A0ACD4 	 0 73 65 65 
1A0ACD8 	6B 6F 70 86 B8 AC A0  1 
1A0ACE0 	20 40 A0  1 84 AB A0  1 
1A0ACE8 	5C 4C A0  1 58 41 A0  1 
1A0ACF0 	 A  0  0  0 48 50 A0  1 
1A0ACF8 	58 46 A0  1 
: readop    file @ 11 na+  ;   \ Points to system routine to read blocks
1A0ACFC 	 0 72 65 61 
1A0AD00 	64 6F 70 86 E0 AC A0  1 
1A0AD08 	20 40 A0  1 84 AB A0  1 
1A0AD10 	5C 4C A0  1 58 41 A0  1 
1A0AD18 	 B  0  0  0 48 50 A0  1 
1A0AD20 	58 46 A0  1 
: writeop   file @ 12 na+  ;   \ Points to system routine to write blocks
1A0AD24 	77 72 69 74 
1A0AD28 	65 6F 70 87  8 AD A0  1 
1A0AD30 	20 40 A0  1 84 AB A0  1 
1A0AD38 	5C 4C A0  1 58 41 A0  1 
1A0AD40 	 C  0  0  0 48 50 A0  1 
1A0AD48 	58 46 A0  1 
: closeop   file @ 13 na+  ;   \ Points to system routine to close file
1A0AD4C 	63 6C 6F 73 
1A0AD50 	65 6F 70 87 30 AD A0  1 
1A0AD58 	20 40 A0  1 84 AB A0  1 
1A0AD60 	5C 4C A0  1 58 41 A0  1 
1A0AD68 	 D  0  0  0 48 50 A0  1 
1A0AD70 	58 46 A0  1 
: alignop   file @ 14 na+  ;   \ Points to system routine to align to block boundary
1A0AD74 	61 6C 69 67 
1A0AD78 	6E 6F 70 87 58 AD A0  1 
1A0AD80 	20 40 A0  1 84 AB A0  1 
1A0AD88 	5C 4C A0  1 58 41 A0  1 
1A0AD90 	 E  0  0  0 48 50 A0  1 
1A0AD98 	58 46 A0  1 
: sizeop    file @ 15 na+  ;   \ Points to system routine to return the file size
1A0AD9C 	 0 73 69 7A 
1A0ADA0 	65 6F 70 86 80 AD A0  1 
1A0ADA8 	20 40 A0  1 84 AB A0  1 
1A0ADB0 	5C 4C A0  1 58 41 A0  1 
1A0ADB8 	 F  0  0  0 48 50 A0  1 
1A0ADC0 	58 46 A0  1 
: (file-line)    file @ 16 na+  ;   \ Number of line delims that read-line has consumed
1A0ADC4 	28 66 69 6C 
1A0ADC8 	65 2D 6C 69 6E 65 29 8B 
1A0ADD0 	A8 AD A0  1 20 40 A0  1 
1A0ADD8 	84 AB A0  1 5C 4C A0  1 
1A0ADE0 	58 41 A0  1 10  0  0  0 
1A0ADE8 	48 50 A0  1 58 46 A0  1 
: line-delimiter file @ 17 na+  ;   \ The last delimiter at the end of each line
1A0ADF0 	 0 6C 69 6E 65 2D 64 65 
1A0ADF8 	6C 69 6D 69 74 65 72 8E 
1A0AE00 	D4 AD A0  1 20 40 A0  1 
1A0AE08 	84 AB A0  1 5C 4C A0  1 
1A0AE10 	58 41 A0  1 11  0  0  0 
1A0AE18 	48 50 A0  1 58 46 A0  1 
: pre-delimiter  file @ 18 na+  ;   \ The first line delimiter (if any)
1A0AE20 	 0  0 70 72 65 2D 64 65 
1A0AE28 	6C 69 6D 69 74 65 72 8D 
1A0AE30 	 4 AE A0  1 20 40 A0  1 
1A0AE38 	84 AB A0  1 5C 4C A0  1 
1A0AE40 	58 41 A0  1 12  0  0  0 
1A0AE48 	48 50 A0  1 58 46 A0  1 
: (file-name)    file @ 19 na+  ;   \ The name of the file
1A0AE50 	28 66 69 6C 65 2D 6E 61 
1A0AE58 	6D 65 29 8B 34 AE A0  1 
1A0AE60 	20 40 A0  1 84 AB A0  1 
1A0AE68 	5C 4C A0  1 58 41 A0  1 
1A0AE70 	13  0  0  0 48 50 A0  1 
1A0AE78 	58 46 A0  1 


: source-id  ( -- fid )  'source-id @  ;
1A0AE7C 	 0  0 73 6F 
1A0AE80 	75 72 63 65 2D 69 64 89 
1A0AE88 	60 AE A0  1 20 40 A0  1 
1A0AE90 	70 AB A0  1 5C 4C A0  1 
1A0AE98 	58 46 A0  1 

\ An implementation factor which
\ ensures that the bftop is >= the bfcurrent variable.  bfcurrent
\ can temporarily advance beyond bftop while a file is being extended.

: sync  ( -- )  \ if current > top, move up top
1A0AE9C 	 0  0  0 73 
1A0AEA0 	79 6E 63 84 8C AE A0  1 
1A0AEA8 	20 40 A0  1 
   bftop @ bfcurrent @ u<   if    bfcurrent @  bftop !    then
1A0AEAC 	E0 AB A0  1 
1A0AEB0 	5C 4C A0  1 2C AC A0  1 
1A0AEB8 	5C 4C A0  1 A8 48 A0  1 
1A0AEC0 	DC 41 A0  1 14  0  0  0 
1A0AEC8 	2C AC A0  1 5C 4C A0  1 
1A0AED0 	E0 AB A0  1 54 4D A0  1 
;
1A0AED8 	58 46 A0  1 


\ If the current file's buffer is modified, write it out
\ Need to better handle the case where the file can't be extended,
\ for instance if the file is a memory array
: ?flushbuf  ( -- )
1A0AEDC 	 0  0 3F 66 
1A0AEE0 	6C 75 73 68 62 75 66 89 
1A0AEE8 	A8 AE A0  1 20 40 A0  1 
   bfdirty @   if
1A0AEF0 	50 AC A0  1 5C 4C A0  1 
1A0AEF8 	DC 41 A0  1 94  0  0  0 
      sync
1A0AF00 	A8 AE A0  1 
      fstart 2@  fid @  seekop @ execute  ( )
1A0AF04 	98 AC A0  1 
1A0AF08 	CC 4D A0  1 B8 AC A0  1 
1A0AF10 	5C 4C A0  1 E0 AC A0  1 
1A0AF18 	5C 4C A0  1 98 41 A0  1 
      bftop @ bfbase @  -                 ( #bytes-to-write)
1A0AF20 	E0 AB A0  1 5C 4C A0  1 
1A0AF28 	98 AB A0  1 5C 4C A0  1 
1A0AF30 	18 45 A0  1 
      bfbase @  over                      ( #bytes adr #bytes )
1A0AF34 	98 AB A0  1 
1A0AF38 	5C 4C A0  1 54 49 A0  1 
      fid @ writeop @ execute             ( #bytes-to-write #bytes-written )
1A0AF40 	B8 AC A0  1 5C 4C A0  1 
1A0AF48 	30 AD A0  1 5C 4C A0  1 
1A0AF50 	98 41 A0  1 
      u>  ( -37 ) abort" Flushbuf error"
1A0AF54 	64 48 A0  1 
1A0AF58 	 8 81 A0  1  E 46 6C 75 
1A0AF60 	73 68 62 75 66 20 65 72 
1A0AF68 	72 6F 72  0 
      bfdirty off
1A0AF6C 	50 AC A0  1 
1A0AF70 	F8 4B A0  1 
      bfbase @   dup bftop !  bfcurrent !
1A0AF74 	98 AB A0  1 
1A0AF78 	5C 4C A0  1 40 49 A0  1 
1A0AF80 	E0 AB A0  1 54 4D A0  1 
1A0AF88 	2C AC A0  1 54 4D A0  1 
   then
;
1A0AF90 	58 46 A0  1 

: align-byte#  ( d.byte# -- d.aln-byte# )  fid @ alignop @ execute  ;
1A0AF94 	61 6C 69 67 
1A0AF98 	6E 2D 62 79 74 65 23 8B 
1A0AFA0 	EC AE A0  1 20 40 A0  1 
1A0AFA8 	B8 AC A0  1 5C 4C A0  1 
1A0AFB0 	80 AD A0  1 5C 4C A0  1 
1A0AFB8 	98 41 A0  1 58 46 A0  1 

\ An implementation factor which
\ fills the buffer with a block from the current file.  The block will
\ be chosen so that the file address "d.byte#" is somewhere within that
\ block.

: fillbuf  ( d.byte# -- )
1A0AFC0 	66 69 6C 6C 62 75 66 87 
1A0AFC8 	A4 AF A0  1 20 40 A0  1 
   align-byte#              ( d.byte# ) \ Aligns position to a buffer boundary
1A0AFD0 	A4 AF A0  1 
   2dup fstart 2!           ( d.byte# )
1A0AFD4 	C0 49 A0  1 
1A0AFD8 	98 AC A0  1 E4 4D A0  1 
   fid @ seekop @ execute               ( )
1A0AFE0 	B8 AC A0  1 5C 4C A0  1 
1A0AFE8 	E0 AC A0  1 5C 4C A0  1 
1A0AFF0 	98 41 A0  1 
   bfbase @   bflimit @ over -          ( adr #bytes-to-read )
1A0AFF4 	98 AB A0  1 
1A0AFF8 	5C 4C A0  1 BC AB A0  1 
1A0B000 	5C 4C A0  1 54 49 A0  1 
1A0B008 	18 45 A0  1 
   fid @ readop @ execute               ( #bytes-read )
1A0B00C 	B8 AC A0  1 
1A0B010 	5C 4C A0  1  8 AD A0  1 
1A0B018 	5C 4C A0  1 98 41 A0  1 
   bfbase @ +   bftop !
1A0B020 	98 AB A0  1 5C 4C A0  1 
1A0B028 	 4 45 A0  1 E0 AB A0  1 
1A0B030 	54 4D A0  1 
   bflimit @  bfend !
1A0B034 	BC AB A0  1 
1A0B038 	5C 4C A0  1  4 AC A0  1 
1A0B040 	54 4D A0  1 
;
1A0B044 	58 46 A0  1 

\ An implementation factor which
\ returns the address within the buffer corresponding to the
\ selected position "d.byte#" within the current file.

: bufaddr>  ( bufaddr -- d.byte# )  bfbase @ - s>d  fstart 2@ d+  ;
1A0B048 	 0  0  0 62 75 66 61 64 
1A0B050 	64 72 3E 88 CC AF A0  1 
1A0B058 	20 40 A0  1 98 AB A0  1 
1A0B060 	5C 4C A0  1 18 45 A0  1 
1A0B068 	9C 68 A0  1 98 AC A0  1 
1A0B070 	CC 4D A0  1 E0 5D A0  1 
1A0B078 	58 46 A0  1 
: >bufaddr  ( d.byte# -- bufaddr )  fstart 2@ d- drop  bfbase @ +  ;
1A0B07C 	 0  0  0 3E 
1A0B080 	62 75 66 61 64 64 72 88 
1A0B088 	58 B0 A0  1 20 40 A0  1 
1A0B090 	98 AC A0  1 CC 4D A0  1 
1A0B098 	F8 5D A0  1 30 49 A0  1 
1A0B0A0 	98 AB A0  1 5C 4C A0  1 
1A0B0A8 	 4 45 A0  1 58 46 A0  1 

\ An implementation factor which
\ advances to the next block in the file.  This is used when accesses
\ to the file are sequential (the most common case).

\ Assumes the byte is not already in the buffer!
: shortseek  ( bufaddr -- )
1A0B0B0 	 0  0 73 68 6F 72 74 73 
1A0B0B8 	65 65 6B 89 8C B0 A0  1 
1A0B0C0 	20 40 A0  1 
   ?flushbuf                             ( bufaddr )
1A0B0C4 	EC AE A0  1 
   bfbase @ - s>d  fstart 2@  d+         ( d.byte# )
1A0B0C8 	98 AB A0  1 5C 4C A0  1 
1A0B0D0 	18 45 A0  1 9C 68 A0  1 
1A0B0D8 	98 AC A0  1 CC 4D A0  1 
1A0B0E0 	E0 5D A0  1 
   2dup fillbuf                          ( d.byte# )
1A0B0E4 	C0 49 A0  1 
1A0B0E8 	CC AF A0  1 
   >bufaddr  bftop @  umin  bfcurrent !
1A0B0EC 	8C B0 A0  1 
1A0B0F0 	E0 AB A0  1 5C 4C A0  1 
1A0B0F8 	4C 4A A0  1 2C AC A0  1 
1A0B100 	54 4D A0  1 
;
1A0B104 	58 46 A0  1 

\ An implementation factor
\ Copyin copies bytes starting at current into the file buffer at
\ bfcurrent.  The number of bytes copied is either all the bytes from
\ current to end, if the buffer has enough room, or all the bytes the
\ buffer will hold, if not.
\ newcurrent is left pointing to the first byte not copied.
headerless
: copyin  ( end current -- end newcurrent )
1A0B108 	 0 63 6F 70 79 69 6E 86 
1A0B110 	C0 B0 A0  1 20 40 A0  1 
   2dup -                      ( end current remaining )
1A0B118 	C0 49 A0  1 18 45 A0  1 
   bfend @  bfcurrent @  -     ( end current remaining bfremaining )
1A0B120 	 4 AC A0  1 5C 4C A0  1 
1A0B128 	2C AC A0  1 5C 4C A0  1 
1A0B130 	18 45 A0  1 
   min                         ( end current #bytes-to-copy )
1A0B134 	74 4A A0  1 
   dup if  bfdirty on  then    ( end current #bytes-to-copy )
1A0B138 	40 49 A0  1 DC 41 A0  1 
1A0B140 	 C  0  0  0 50 AC A0  1 
1A0B148 	E0 4B A0  1 
   2dup  bfcurrent @ swap      ( end current #bytes  current bfcurrent #bytes)
1A0B14C 	C0 49 A0  1 
1A0B150 	2C AC A0  1 5C 4C A0  1 
1A0B158 	68 49 A0  1 
   move                        ( end current #bytes )
1A0B15C 	F4 4A A0  1 
   dup bfcurrent +!            ( end current #bytes )
1A0B160 	40 49 A0  1 2C AC A0  1 
1A0B168 	 C 4C A0  1 
   +                           ( end newcurrent)
1A0B16C 	 4 45 A0  1 
;
1A0B170 	58 46 A0  1 

: byte#-aligned?  ( d.byte# -- flag )  2dup align-byte#  d=  ;
1A0B174 	 0 62 79 74 
1A0B178 	65 23 2D 61 6C 69 67 6E 
1A0B180 	65 64 3F 8E 14 B1 A0  1 
1A0B188 	20 40 A0  1 C0 49 A0  1 
1A0B190 	A4 AF A0  1 4C 67 A0  1 
1A0B198 	58 46 A0  1 

\ This is called from fputs to open up space in the buffer for block-sized
\ chunks, avoiding prefills that would be completely overwritten.
: prefill?  ( endaddr curaddr -- endaddr curraddr flag )
1A0B19C 	 0  0  0 70 
1A0B1A0 	72 65 66 69 6C 6C 3F 88 
1A0B1A8 	88 B1 A0  1 20 40 A0  1 

   \ If the current buffer pointer is not block-aligned, must prefill
   bfcurrent @  bufaddr>  byte#-aligned?  0=  if  true  exit  then  ( end curr )
1A0B1B0 	2C AC A0  1 5C 4C A0  1 
1A0B1B8 	58 B0 A0  1 88 B1 A0  1 
1A0B1C0 	24 47 A0  1 DC 41 A0  1 
1A0B1C8 	 C  0  0  0  4 70 A0  1 
1A0B1D0 	40 46 A0  1 

   2dup -  0 align-byte# drop           ( end curr aln-size )
1A0B1D4 	C0 49 A0  1 
1A0B1D8 	18 45 A0  1 70 6F A0  1 
1A0B1E0 	A4 AF A0  1 30 49 A0  1 

   \ If the incoming data won't fill a block, must prefill
   ?dup  0=  if  true exit  then        ( end curr aln-size )
1A0B1E8 	B4 70 A0  1 24 47 A0  1 
1A0B1F0 	DC 41 A0  1  C  0  0  0 
1A0B1F8 	 4 70 A0  1 40 46 A0  1 

   \ If there is still space in the buffer, just open it up for copyin
   bflimit @ bfend @ -  ?dup  if        ( end curr aln-len buffer-avail )
1A0B200 	BC AB A0  1 5C 4C A0  1 
1A0B208 	 4 AC A0  1 5C 4C A0  1 
1A0B210 	18 45 A0  1 B4 70 A0  1 
1A0B218 	DC 41 A0  1 18  0  0  0 
      min  bfend +!  false exit
1A0B220 	74 4A A0  1  4 AC A0  1 
1A0B228 	 C 4C A0  1 18 70 A0  1 
1A0B230 	40 46 A0  1 
   then                                 ( end curr aln-len )

   \ Save current on stack because ?flushbuf clears it
   bfcurrent @                          ( end curr aln-len current )
1A0B234 	2C AC A0  1 
1A0B238 	5C 4C A0  1 

   \ The buffer is full; clear out its old contents
   ?flushbuf                            ( end curr aln-len )
1A0B23C 	EC AE A0  1 

   \ Advance the file pointer to the new buffer starting position
   bufaddr> fstart 2!                   ( end curr aln-len )
1A0B240 	58 B0 A0  1 98 AC A0  1 
1A0B248 	E4 4D A0  1 

   bfbase @ + bflimit @ min  bfend !    ( end curr )  \ Room for new bytes
1A0B24C 	98 AB A0  1 
1A0B250 	5C 4C A0  1  4 45 A0  1 
1A0B258 	BC AB A0  1 5C 4C A0  1 
1A0B260 	74 4A A0  1  4 AC A0  1 
1A0B268 	54 4D A0  1 
   bfbase @  dup bftop !  bfcurrent !   ( end curr )  \ No valid bytes yet
1A0B26C 	98 AB A0  1 
1A0B270 	5C 4C A0  1 40 49 A0  1 
1A0B278 	E0 AB A0  1 54 4D A0  1 
1A0B280 	2C AC A0  1 54 4D A0  1 
   false
1A0B288 	18 70 A0  1 
;
1A0B28C 	58 46 A0  1 


\ Stores a byte into the current file at the next position
: fputc  ( byte fd -- )
1A0B290 	 0  0 66 70 75 74 63 85 
1A0B298 	AC B1 A0  1 20 40 A0  1 
   file @ >r  file !
1A0B2A0 	84 AB A0  1 5C 4C A0  1 
1A0B2A8 	BC 45 A0  1 84 AB A0  1 
1A0B2B0 	54 4D A0  1 
   bfcurrent @   bfend @ u>=     ( byte flag )  \ Is the buffer full?
1A0B2B4 	2C AC A0  1 
1A0B2B8 	5C 4C A0  1  4 AC A0  1 
1A0B2C0 	5C 4C A0  1 CC 48 A0  1 
   if  bfcurrent @ shortseek  then     ( byte ) \ If so advance to next buffer
1A0B2C8 	DC 41 A0  1 10  0  0  0 
1A0B2D0 	2C AC A0  1 5C 4C A0  1 
1A0B2D8 	C0 B0 A0  1 
   bfcurrent @c!++  bfdirty on
1A0B2DC 	2C AC A0  1 
1A0B2E0 	 4 63 A0  1 50 AC A0  1 
1A0B2E8 	E0 4B A0  1 
   r> file !
1A0B2EC 	D0 45 A0  1 
1A0B2F0 	84 AB A0  1 54 4D A0  1 
;
1A0B2F8 	58 46 A0  1 

\ Writes count bytes from memory starting at "adr" to the current file
: fputs  ( adr count fd -- )
1A0B2FC 	 0  0 66 70 
1A0B300 	75 74 73 85 9C B2 A0  1 
1A0B308 	20 40 A0  1 
   file @ >r  file !
1A0B30C 	84 AB A0  1 
1A0B310 	5C 4C A0  1 BC 45 A0  1 
1A0B318 	84 AB A0  1 54 4D A0  1 
   over + swap                    ( endaddr startaddr )
1A0B320 	54 49 A0  1  4 45 A0  1 
1A0B328 	68 49 A0  1 
   begin  copyin  2dup u>  while  ( endaddr curraddr )
1A0B32C 	14 B1 A0  1 
1A0B330 	C0 49 A0  1 64 48 A0  1 
1A0B338 	DC 41 A0  1 28  0  0  0 
      sync                        ( endaddr curraddr )
1A0B340 	A8 AE A0  1 
      \ Prefill? tries to avoid unnecessary reads by opening up space
      \ in the buffer for chunks that will completely fill a block.
      prefill?  if                ( endaddr curraddr )
1A0B344 	AC B1 A0  1 
1A0B348 	DC 41 A0  1 10  0  0  0 
         bfcurrent @ shortseek    ( endaddr curraddr )
1A0B350 	2C AC A0  1 5C 4C A0  1 
1A0B358 	C0 B0 A0  1 
      then
   repeat
1A0B35C 	C8 41 A0  1 
1A0B360 	CC FF FF FF 
   2drop
1A0B364 	AC 49 A0  1 
   r> file !
1A0B368 	D0 45 A0  1 84 AB A0  1 
1A0B370 	54 4D A0  1 
;
1A0B374 	58 46 A0  1 


: file-name  ( fd -- adr len )
1A0B378 	 0  0 66 69 6C 65 2D 6E 
1A0B380 	61 6D 65 89  8 B3 A0  1 
1A0B388 	20 40 A0  1 
   file @ >r  file !  (file-name) count  r> file !
1A0B38C 	84 AB A0  1 
1A0B390 	5C 4C A0  1 BC 45 A0  1 
1A0B398 	84 AB A0  1 54 4D A0  1 
1A0B3A0 	60 AE A0  1 BC 53 A0  1 
1A0B3A8 	D0 45 A0  1 84 AB A0  1 
1A0B3B0 	54 4D A0  1 
;
1A0B3B4 	58 46 A0  1 

: file-line  ( fd -- n )  file @ >r  file !  (file-line) @  r> file !  ;
1A0B3B8 	 0  0 66 69 6C 65 2D 6C 
1A0B3C0 	69 6E 65 89 88 B3 A0  1 
1A0B3C8 	20 40 A0  1 84 AB A0  1 
1A0B3D0 	5C 4C A0  1 BC 45 A0  1 
1A0B3D8 	84 AB A0  1 54 4D A0  1 
1A0B3E0 	D4 AD A0  1 5C 4C A0  1 
1A0B3E8 	D0 45 A0  1 84 AB A0  1 
1A0B3F0 	54 4D A0  1 58 46 A0  1 

decimal
[ifdef] omit-files
: $tagout 2drop ;
[else]
: $tag-field  ( $ -- )  tag-file @ fputs  ;
1A0B3F8 	 0 24 74 61 67 2D 66 69 
1A0B400 	65 6C 64 8A C8 B3 A0  1 
1A0B408 	20 40 A0  1 58 AB A0  1 
1A0B410 	5C 4C A0  1  8 B3 A0  1 
1A0B418 	58 46 A0  1 
: tag-char  ( char -- )  tag-file @ fputc  ;
1A0B41C 	 0  0  0 74 
1A0B420 	61 67 2D 63 68 61 72 88 
1A0B428 	 8 B4 A0  1 20 40 A0  1 
1A0B430 	58 AB A0  1 5C 4C A0  1 
1A0B438 	9C B2 A0  1 58 46 A0  1 

: $tagout  ( name$ -- )
1A0B440 	24 74 61 67 6F 75 74 87 
1A0B448 	2C B4 A0  1 20 40 A0  1 
   tag-file @ 0=  if  2drop exit  then
1A0B450 	58 AB A0  1 5C 4C A0  1 
1A0B458 	24 47 A0  1 DC 41 A0  1 
1A0B460 	 C  0  0  0 AC 49 A0  1 
1A0B468 	40 46 A0  1 
   source-id -1 =  if  2drop exit  then
1A0B46C 	8C AE A0  1 
1A0B470 	58 41 A0  1 FF FF FF FF 
1A0B478 	24 48 A0  1 DC 41 A0  1 
1A0B480 	 C  0  0  0 AC 49 A0  1 
1A0B488 	40 46 A0  1 
   $tag-field  9 tag-char
1A0B48C 	 8 B4 A0  1 
1A0B490 	58 41 A0  1  9  0  0  0 
1A0B498 	2C B4 A0  1 
   source-id file-name  $tag-field  9 tag-char
1A0B49C 	8C AE A0  1 
1A0B4A0 	88 B3 A0  1  8 B4 A0  1 
1A0B4A8 	58 41 A0  1  9  0  0  0 
1A0B4B0 	2C B4 A0  1 
   base @ decimal  source-id file-line (.) $tag-field  base !
1A0B4B4 	B8 75 A0  1 
1A0B4B8 	5C 4C A0  1 E4 8D A0  1 
1A0B4C0 	8C AE A0  1 C8 B3 A0  1 
1A0B4C8 	10 78 A0  1  8 B4 A0  1 
1A0B4D0 	B8 75 A0  1 54 4D A0  1 
   newline-string $tag-field
1A0B4D8 	8C 71 A0  1  8 B4 A0  1 
;
1A0B4E0 	58 46 A0  1 
[then]

: $make-header  ( adr len voc-acf -- )
1A0B4E4 	 0  0  0 24 
1A0B4E8 	6D 61 6B 65 2D 68 65 61 
1A0B4F0 	64 65 72 8C 4C B4 A0  1 
1A0B4F8 	20 40 A0  1 
   -rot                        ( voc-acf adr,len )
1A0B4FC 	94 49 A0  1 
   2dup $tagout
1A0B500 	C0 49 A0  1 4C B4 A0  1 
   dup 1+ /link +              ( voc-acf adr,len hdr-len )
1A0B508 	40 49 A0  1 30 4B A0  1 
1A0B510 	78 73 A0  1  4 45 A0  1 

   here +                       ( voc-acf adr,len  addr' )
1A0B518 	70 54 A0  1  4 45 A0  1 
   dup acf-aligned swap - allot ( voc-acf adr,len )
1A0B520 	40 49 A0  1  C 5D A0  1 
1A0B528 	68 49 A0  1 18 45 A0  1 
1A0B530 	E4 54 A0  1 
   tuck here over 1+  noop  allot     ( voc-acf len adr,len anf )
1A0B534 	E8 46 A0  1 
1A0B538 	70 54 A0  1 54 49 A0  1 
1A0B540 	30 4B A0  1 64 4F A0  1 
1A0B548 	E4 54 A0  1 
   place-cstr                  ( voc-acf len anf )
1A0B54C 	B4 8A A0  1 
   over + c!                   ( voc-acf )
1A0B550 	54 49 A0  1  4 45 A0  1 
1A0B558 	B8 4D A0  1 
   here 1- last !              ( voc-acf )
1A0B55C 	70 54 A0  1 
1A0B560 	54 4B A0  1  4 A4 A0  1 
1A0B568 	54 4D A0  1 
   >threads                    ( threads-adr )
1A0B56C 	EC 74 A0  1 
   /link allot here            ( threads-adr acf )
1A0B570 	78 73 A0  1 E4 54 A0  1 
1A0B578 	70 54 A0  1 

   swap 2dup a@             ( acf threads-adr acf succ-acf )
1A0B57C 	68 49 A0  1 
1A0B580 	C0 49 A0  1 88 58 A0  1 
   swap >link a! a!      (  )
1A0B588 	68 49 A0  1 EC 73 A0  1 
1A0B590 	98 58 A0  1 98 58 A0  1 

   last @ c@  h# 80 or  last @ c!
1A0B598 	 4 A4 A0  1 5C 4C A0  1 
1A0B5A0 	C4 4C A0  1 58 41 A0  1 
1A0B5A8 	80  0  0  0 70 44 A0  1 
1A0B5B0 	 4 A4 A0  1 5C 4C A0  1 
1A0B5B8 	B8 4D A0  1 
;
1A0B5BC 	58 46 A0  1 

headers
: >first  ( voc-acf -- first-alf )  >threads  ;
1A0B5C0 	 0 3E 66 69 72 73 74 86 
1A0B5C8 	F8 B4 A0  1 20 40 A0  1 
1A0B5D0 	EC 74 A0  1 58 46 A0  1 

defer $find-next
1A0B5D8 	 0 24 66 69 6E 64 2D 6E 
1A0B5E0 	65 78 74 8A CC B5 A0  1 
1A0B5E8 	5C 40 A0  1  C  2  0  0 


headerless

: next-word  ( alf voc-acf -- false  |  alf' true )
1A0B5F0 	 0  0 6E 65 78 74 2D 77 
1A0B5F8 	6F 72 64 89 E8 B5 A0  1 
1A0B600 	20 40 A0  1 
   >ptr another-link?  if  >link  true  else  false  then
1A0B604 	C0 A4 A0  1 
1A0B608 	90 59 A0  1 DC 41 A0  1 
1A0B610 	14  0  0  0 EC 73 A0  1 
1A0B618 	 4 70 A0  1 C8 41 A0  1 
1A0B620 	 8  0  0  0 18 70 A0  1 
;
1A0B628 	58 46 A0  1 


\ Makes a sealed vocabulary with the top-of-voc pointer in user area
\ parameter field of vocabularies contains:
\ user-#-of-voc-pointer ,  voc-link ,

\ For navigating inside a vocabulary's data structure.
\ A vocabulary's parameter field contains:
\   user#  link
\ The threads are stored in the user area.

: voc>      (s voc-link-adr -- acf )
1A0B62C 	 0  0  0 76 
1A0B630 	6F 63 3E 84  0 B6 A0  1 
1A0B638 	20 40 A0  1 
\   /user# -  body>
;
1A0B63C 	58 46 A0  1 

: >voc-link ( voc-acf -- voc-link-adr )  >body /user# +  ;
1A0B640 	 0  0 3E 76 6F 63 2D 6C 
1A0B648 	69 6E 6B 89 38 B6 A0  1 
1A0B650 	20 40 A0  1 E4 59 A0  1 
1A0B658 	40 5A A0  1  4 45 A0  1 
1A0B660 	58 46 A0  1 


auser voc-link     \ points to newest vocabulary
1A0B664 	 0  0  0 76 
1A0B668 	6F 63 2D 6C 69 6E 6B 88 
1A0B670 	50 B6 A0  1 48 40 A0  1 
1A0B678 	10  2  0  0 

: voc-link,  (s -- )  \ links this vocabulary to the chain
1A0B67C 	 0  0 76 6F 
1A0B680 	63 2D 6C 69 6E 6B 2C 89 
1A0B688 	74 B6 A0  1 20 40 A0  1 
   lastacf  voc-link a@  a,   voc-link a!
1A0B690 	AC 57 A0  1 74 B6 A0  1 
1A0B698 	88 58 A0  1 AC 58 A0  1 
1A0B6A0 	74 B6 A0  1 98 58 A0  1 
;
1A0B6A8 	58 46 A0  1 


: (wordlist)  ( -- )
1A0B6AC 	 0 28 77 6F 
1A0B6B0 	72 64 6C 69 73 74 29 8A 
1A0B6B8 	8C B6 A0  1 20 40 A0  1 
   create-cf
1A0B6C0 	30 5B A0  1 
   /link user#,  !null-link   ( )
1A0B6C4 	78 73 A0  1 
1A0B6C8 	84 9A A0  1 EC 58 A0  1 
   voc-link,
1A0B6D0 	8C B6 A0  1 
   0 ,				\ Space for additional information
1A0B6D4 	70 6F A0  1 
1A0B6D8 	98 55 A0  1 
   does> body> context token!
1A0B6DC 	50 A3 A0  1 
1A0B6E0 	90 90 90 E8 94 89 FF FF 
1A0B6E8 	C8 59 A0  1 DC A3 A0  1 
1A0B6F0 	20 54 A0  1 
; resolves <vocabulary>
1A0B6F4 	58 46 A0  1 

headers

\ From voccom.fth

\ Common routines for vocabularies, independent of name field
\ implementation details

headers
: wordlist  ( -- wid )  (wordlist) lastacf  ;
1A0B6F8 	 0  0  0 77 6F 72 64 6C 
1A0B700 	69 73 74 88 BC B6 A0  1 
1A0B708 	20 40 A0  1 BC B6 A0  1 
1A0B710 	AC 57 A0  1 58 46 A0  1 
: vocabulary  ( "name" -- )  header (wordlist)  ;
1A0B718 	 0 76 6F 63 61 62 75 6C 
1A0B720 	61 72 79 8A  8 B7 A0  1 
1A0B728 	20 40 A0  1 DC 6D A0  1 
1A0B730 	BC B6 A0  1 58 46 A0  1 

' ($find-next) is $find-next


#threads-t constant #threads
1A0B738 	 0  0  0 23 74 68 72 65 
1A0B740 	61 64 73 88 28 B7 A0  1 
1A0B748 	68 40 A0  1  1  0  0  0 


: find-voc ( xt - voc-node|false )
1A0B750 	 0  0  0 66 69 6E 64 2D 
1A0B758 	76 6F 63 88 48 B7 A0  1 
1A0B760 	20 40 A0  1 
   >r voc-link  			( voc-node )
1A0B764 	BC 45 A0  1 
1A0B768 	74 B6 A0  1 
   begin
      another-link? false = if          ( - | voc-node )
1A0B76C 	90 59 A0  1 
1A0B770 	18 70 A0  1 24 48 A0  1 
1A0B778 	DC 41 A0  1 14  0  0  0 
         false true			( false loop-flag )
1A0B780 	18 70 A0  1  4 70 A0  1 
      else				( voc-node )
1A0B788 	C8 41 A0  1 20  0  0  0 
	 dup voc> 			( voc-node voc-xt )
1A0B790 	40 49 A0  1 38 B6 A0  1 
	 swap >voc-link swap            ( voc-node' voc-xt )
1A0B798 	68 49 A0  1 50 B6 A0  1 
1A0B7A0 	68 49 A0  1 
         r@ execute	     		( voc-node' flag )
1A0B7A4 	E4 45 A0  1 
1A0B7A8 	98 41 A0  1 
      then				( voc-node'|false loop-flag )
   until				( voc-node' )
1A0B7AC 	DC 41 A0  1 
1A0B7B0 	BC FF FF FF 
   r> drop				( voc-node|false )
1A0B7B4 	D0 45 A0  1 
1A0B7B8 	30 49 A0  1 
;
1A0B7BC 	58 46 A0  1 

headerless
hex
0 value fake-name-buf
1A0B7C0 	 0  0 66 61 6B 65 2D 6E 
1A0B7C8 	61 6D 65 2D 62 75 66 8D 
1A0B7D0 	60 B7 A0  1 50 40 A0  1 
1A0B7D8 	14  2  0  0 

: fake-name  ( xt -- anf )
1A0B7DC 	 0  0 66 61 
1A0B7E0 	6B 65 2D 6E 61 6D 65 89 
1A0B7E8 	D4 B7 A0  1 20 40 A0  1 
   base @ >r hex
1A0B7F0 	B8 75 A0  1 5C 4C A0  1 
1A0B7F8 	BC 45 A0  1 C0 8D A0  1 
   <#  0 hold ascii ) hold  u#s  ascii ( hold  u#>   ( adr len )
1A0B800 	 8 76 A0  1 70 6F A0  1 
1A0B808 	DC 75 A0  1 58 41 A0  1 
1A0B810 	29  0  0  0 DC 75 A0  1 
1A0B818 	BC 76 A0  1 58 41 A0  1 
1A0B820 	28  0  0  0 DC 75 A0  1 
1A0B828 	E0 76 A0  1 
   fake-name-buf $save       ( adr len )
1A0B82C 	D4 B7 A0  1 
1A0B830 	68 7E A0  1 
   tuck + 1- tuck            ( anf len adr+len )
1A0B834 	E8 46 A0  1 
1A0B838 	 4 45 A0  1 54 4B A0  1 
1A0B840 	E8 46 A0  1 
   swap 1- h# 80 or swap c!  ( adr )
1A0B844 	68 49 A0  1 
1A0B848 	54 4B A0  1 58 41 A0  1 
1A0B850 	80  0  0  0 70 44 A0  1 
1A0B858 	68 49 A0  1 B8 4D A0  1 
   r> base !
1A0B860 	D0 45 A0  1 B8 75 A0  1 
1A0B868 	54 4D A0  1 
;
1A0B86C 	58 46 A0  1 

\ Returns the name field address, or if the word is headerless, the
\ address of a numeric string representing the xt in parentheses.
: >name-do  ( xt -- anf )
1A0B870 	 0  0  0 3E 6E 61 6D 65 
1A0B878 	2D 64 6F 88 EC B7 A0  1 
1A0B880 	20 40 A0  1 
   dup >name?  if  nip  else  drop fake-name  then
1A0B884 	40 49 A0  1 
1A0B888 	A0 AA A0  1 DC 41 A0  1 
1A0B890 	10  0  0  0 FC 46 A0  1 
1A0B898 	C8 41 A0  1  C  0  0  0 
1A0B8A0 	30 49 A0  1 EC B7 A0  1 
;
1A0B8A8 	58 46 A0  1 

' >name-do is >name

: immediate  (s -- )  last @  n>flags  dup c@  40 or  swap c!  ;
1A0B8AC 	 0  0 69 6D 
1A0B8B0 	6D 65 64 69 61 74 65 89 
1A0B8B8 	80 B8 A0  1 20 40 A0  1 
1A0B8C0 	 4 A4 A0  1 5C 4C A0  1 
1A0B8C8 	BC 73 A0  1 40 49 A0  1 
1A0B8D0 	C4 4C A0  1 58 41 A0  1 
1A0B8D8 	40  0  0  0 70 44 A0  1 
1A0B8E0 	68 49 A0  1 B8 4D A0  1 
1A0B8E8 	58 46 A0  1 
: immediate?  (s xt -- flag )  >flags c@  40 and  0<>  ;
1A0B8EC 	 0 69 6D 6D 
1A0B8F0 	65 64 69 61 74 65 3F 8A 
1A0B8F8 	BC B8 A0  1 20 40 A0  1 
1A0B900 	38 74 A0  1 C4 4C A0  1 
1A0B908 	58 41 A0  1 40  0  0  0 
1A0B910 	5C 44 A0  1 44 47 A0  1 
1A0B918 	58 46 A0  1 
: flagalias  (s -- )  last @  n>flags  dup c@  20 or  swap c!  ;
1A0B91C 	 0  0 66 6C 
1A0B920 	61 67 61 6C 69 61 73 89 
1A0B928 	FC B8 A0  1 20 40 A0  1 
1A0B930 	 4 A4 A0  1 5C 4C A0  1 
1A0B938 	BC 73 A0  1 40 49 A0  1 
1A0B940 	C4 4C A0  1 58 41 A0  1 
1A0B948 	20  0  0  0 70 44 A0  1 
1A0B950 	68 49 A0  1 B8 4D A0  1 
1A0B958 	58 46 A0  1 
: .last  (s -- )  last @ .id  ;
1A0B95C 	 0  0 2E 6C 
1A0B960 	61 73 74 85 2C B9 A0  1 
1A0B968 	20 40 A0  1  4 A4 A0  1 
1A0B970 	5C 4C A0  1 A8 9A A0  1 
1A0B978 	58 46 A0  1 


0 value canonical-word
1A0B97C 	 0 63 61 6E 
1A0B980 	6F 6E 69 63 61 6C 2D 77 
1A0B988 	6F 72 64 8E 68 B9 A0  1 
1A0B990 	50 40 A0  1 18  2  0  0 
headerless
: init  ( -- )
1A0B998 	 0  0  0 69 6E 69 74 84 
1A0B9A0 	90 B9 A0  1 20 40 A0  1 
   init
1A0B9A8 	64 AA A0  1 
   d# 20 alloc-mem  is fake-name-buf
1A0B9AC 	58 41 A0  1 
1A0B9B0 	14  0  0  0 F0 6C A0  1 
1A0B9B8 	B8 65 A0  1 D4 B7 A0  1 
   d# 32 alloc-mem  is canonical-word
1A0B9C0 	58 41 A0  1 20  0  0  0 
1A0B9C8 	F0 6C A0  1 B8 65 A0  1 
1A0B9D0 	90 B9 A0  1 
   d# 34 alloc-mem  is 'error-word
1A0B9D4 	58 41 A0  1 
1A0B9D8 	22  0  0  0 F0 6C A0  1 
1A0B9E0 	B8 65 A0  1 98 9F A0  1 
;
1A0B9E8 	58 46 A0  1 
headers

: $canonical  ( adr len -- adr' len' )
1A0B9EC 	 0 24 63 61 
1A0B9F0 	6E 6F 6E 69 63 61 6C 8A 
1A0B9F8 	A4 B9 A0  1 20 40 A0  1 
   caps @  if  d# 31 min  canonical-word $save  2dup lower  then
1A0BA00 	18 85 A0  1 5C 4C A0  1 
1A0BA08 	DC 41 A0  1 20  0  0  0 
1A0BA10 	58 41 A0  1 1F  0  0  0 
1A0BA18 	74 4A A0  1 90 B9 A0  1 
1A0BA20 	68 7E A0  1 C0 49 A0  1 
1A0BA28 	A4 85 A0  1 
;
1A0BA2C 	58 46 A0  1 


: find-fixup  ( adr len alf true  |  adr len false -- xt +-1  |  adr len 0 )
1A0BA30 	 0 66 69 6E 64 2D 66 69 
1A0BA38 	78 75 70 8A FC B9 A0  1 
1A0BA40 	20 40 A0  1 
   dup  if                                        ( adr len alf true )
1A0BA44 	40 49 A0  1 
1A0BA48 	DC 41 A0  1 74  0  0  0 
      drop nip nip                                ( alf )
1A0BA50 	30 49 A0  1 FC 46 A0  1 
1A0BA58 	FC 46 A0  1 
      dup link> swap l>name n>flags c@            ( xt flags )
1A0BA5C 	40 49 A0  1 
1A0BA60 	D0 73 A0  1 68 49 A0  1 
1A0BA68 	A4 73 A0  1 BC 73 A0  1 
1A0BA70 	C4 4C A0  1 
      dup  h# 20 and  if  swap token@ swap  then  ( xt' flags )  \ alias?
1A0BA74 	40 49 A0  1 
1A0BA78 	58 41 A0  1 20  0  0  0 
1A0BA80 	5C 44 A0  1 DC 41 A0  1 
1A0BA88 	10  0  0  0 68 49 A0  1 
1A0BA90 	 C 54 A0  1 68 49 A0  1 
      h# 40 and  if  1  else  -1  then                           \ immediate?
1A0BA98 	58 41 A0  1 40  0  0  0 
1A0BAA0 	5C 44 A0  1 DC 41 A0  1 
1A0BAA8 	10  0  0  0 80 6F A0  1 
1A0BAB0 	C8 41 A0  1  C  0  0  0 
1A0BAB8 	58 41 A0  1 FF FF FF FF 
   then
;
1A0BAC0 	58 46 A0  1 

: $find-word  ( adr len voc-acf -- adr len   false | xt +-1 )
1A0BAC4 	 0 24 66 69 
1A0BAC8 	6E 64 2D 77 6F 72 64 8A 
1A0BAD0 	40 BA A0  1 20 40 A0  1 
   >first  $find-next  find-fixup
1A0BAD8 	CC B5 A0  1 E8 B5 A0  1 
1A0BAE0 	40 BA A0  1 
;
1A0BAE4 	58 46 A0  1 


: (search-wordlist)  ( adr len vocabulary -- false | xt +-1 )
1A0BAE8 	 0  0 28 73 65 61 72 63 
1A0BAF0 	68 2D 77 6F 72 64 6C 69 
1A0BAF8 	73 74 29 91 D4 BA A0  1 
1A0BB00 	20 40 A0  1 
   $find-word  dup  0=  if  nip nip  then
1A0BB04 	D4 BA A0  1 
1A0BB08 	40 49 A0  1 24 47 A0  1 
1A0BB10 	DC 41 A0  1  C  0  0  0 
1A0BB18 	FC 46 A0  1 FC 46 A0  1 
;
1A0BB20 	58 46 A0  1 
: search-wordlist  ( adr len vocabulary -- false | xt +-1 )
1A0BB24 	73 65 61 72 
1A0BB28 	63 68 2D 77 6F 72 64 6C 
1A0BB30 	69 73 74 8F  0 BB A0  1 
1A0BB38 	20 40 A0  1 
   >r $canonical r> (search-wordlist)
1A0BB3C 	BC 45 A0  1 
1A0BB40 	FC B9 A0  1 D0 45 A0  1 
1A0BB48 	 0 BB A0  1 
;
1A0BB4C 	58 46 A0  1 

: $vfind  ( adr len vocabulary -- adr len false | xt +-1 )
1A0BB50 	 0 24 76 66 69 6E 64 86 
1A0BB58 	38 BB A0  1 20 40 A0  1 
   >r $canonical r> $find-word
1A0BB60 	BC 45 A0  1 FC B9 A0  1 
1A0BB68 	D0 45 A0  1 D4 BA A0  1 
;
1A0BB70 	58 46 A0  1 

: $create-word  ( adr len voc-xt -- )
1A0BB74 	 0  0  0 24 
1A0BB78 	63 72 65 61 74 65 2D 77 
1A0BB80 	6F 72 64 8C 5C BB A0  1 
1A0BB88 	20 40 A0  1 
   >r $canonical r>
1A0BB8C 	BC 45 A0  1 
1A0BB90 	FC B9 A0  1 D0 45 A0  1 
   warning @  if
1A0BB98 	E4 9A A0  1 5C 4C A0  1 
1A0BBA0 	DC 41 A0  1 4C  0  0  0 
      3dup  $find-word  if   ( adr len voc-xt  xt )
1A0BBA8 	A4 52 A0  1 D4 BA A0  1 
1A0BBB0 	DC 41 A0  1 38  0  0  0 
         drop
1A0BBB8 	30 49 A0  1 
	 >r 2dup type r> ."  isn't unique " cr
1A0BBBC 	BC 45 A0  1 
1A0BBC0 	C0 49 A0  1  4 6C A0  1 
1A0BBC8 	D0 45 A0  1 20 7C A0  1 
1A0BBD0 	 E 20 69 73 6E 27 74 20 
1A0BBD8 	75 6E 69 71 75 65 20  0 
1A0BBE0 	80 6D A0  1 
      else                   ( adr len voc-xt  adr len )
1A0BBE4 	C8 41 A0  1 
1A0BBE8 	 8  0  0  0 
         2drop
1A0BBEC 	AC 49 A0  1 
      then
   then                      ( adr len voc-xt )
   $make-header
1A0BBF0 	F8 B4 A0  1 
;
1A0BBF4 	58 46 A0  1 

: ($header)  (s adr len -- )  current-voc $create-word  ;
1A0BBF8 	 0  0 28 24 68 65 61 64 
1A0BC00 	65 72 29 89 88 BB A0  1 
1A0BC08 	20 40 A0  1 34 A4 A0  1 
1A0BC10 	88 BB A0  1 58 46 A0  1 

' ($header) is $header

headerless
2 /n-t * ualloc-t user tbuf
1A0BC18 	 0  0  0 74 62 75 66 84 
1A0BC20 	 8 BC A0  1 48 40 A0  1 
1A0BC28 	1C  2  0  0 
headers
: follow  ( voc-acf -- )  tbuf token!  0 tbuf na1+ !  ;
1A0BC2C 	 0 66 6F 6C 
1A0BC30 	6C 6F 77 86 24 BC A0  1 
1A0BC38 	20 40 A0  1 24 BC A0  1 
1A0BC40 	20 54 A0  1 70 6F A0  1 
1A0BC48 	24 BC A0  1 CC 50 A0  1 
1A0BC50 	54 4D A0  1 58 46 A0  1 

: another?  ( -- false  |  anf true )
1A0BC58 	 0  0  0 61 6E 6F 74 68 
1A0BC60 	65 72 3F 88 38 BC A0  1 
1A0BC68 	20 40 A0  1 
   tbuf na1+ @  tbuf token@  next-word  ( 0 | alf true )
1A0BC6C 	24 BC A0  1 
1A0BC70 	CC 50 A0  1 5C 4C A0  1 
1A0BC78 	24 BC A0  1  C 54 A0  1 
1A0BC80 	 0 B6 A0  1 
   if  dup tbuf na1+ !  l>name  true  else  false  then
1A0BC84 	DC 41 A0  1 
1A0BC88 	24  0  0  0 40 49 A0  1 
1A0BC90 	24 BC A0  1 CC 50 A0  1 
1A0BC98 	54 4D A0  1 A4 73 A0  1 
1A0BCA0 	 4 70 A0  1 C8 41 A0  1 
1A0BCA8 	 8  0  0  0 18 70 A0  1 
;
1A0BCB0 	58 46 A0  1 

\ Forget

headerless
: trim   (s alf voc-acf -- )
1A0BCB4 	 0  0  0 74 
1A0BCB8 	72 69 6D 84 68 BC A0  1 
1A0BCC0 	20 40 A0  1 
   >r 0                                       ( adr 0 )
1A0BCC4 	BC 45 A0  1 
1A0BCC8 	70 6F A0  1 
   begin  r@ next-word   while                ( adr alf )
1A0BCCC 	E4 45 A0  1 
1A0BCD0 	 0 B6 A0  1 DC 41 A0  1 
1A0BCD8 	28  0  0  0 
      2dup <=  if  dup r@ remove-word  then   ( adr alf )
1A0BCDC 	C0 49 A0  1 
1A0BCE0 	 C 49 A0  1 DC 41 A0  1 
1A0BCE8 	10  0  0  0 40 49 A0  1 
1A0BCF0 	E4 45 A0  1 54 A4 A0  1 
   repeat                                     ( adr )
1A0BCF8 	C8 41 A0  1 D0 FF FF FF 
   r> 2drop
1A0BD00 	D0 45 A0  1 AC 49 A0  1 
;
1A0BD08 	58 46 A0  1 

\ From order.fth

\ Search order.  Maintains the list of vocabularies which are
\ searched while interpreting Forth code.

#vocs /token * constant /context
1A0BD0C 	 0  0  0 2F 
1A0BD10 	63 6F 6E 74 65 78 74 88 
1A0BD18 	C0 BC A0  1 68 40 A0  1 
1A0BD20 	80  0  0  0 
: context-bounds  ( -- end start )  context /context bounds  ;
1A0BD24 	 0 63 6F 6E 
1A0BD28 	74 65 78 74 2D 62 6F 75 
1A0BD30 	6E 64 73 8E 1C BD A0  1 
1A0BD38 	20 40 A0  1 DC A3 A0  1 
1A0BD40 	1C BD A0  1 F0 6D A0  1 
1A0BD48 	58 46 A0  1 

headerless
: shuffle-down  ( adr -- finished? )
1A0BD4C 	 0  0  0 73 
1A0BD50 	68 75 66 66 6C 65 2D 64 
1A0BD58 	6F 77 6E 8C 38 BD A0  1 
1A0BD60 	20 40 A0  1 
   \ The loop goes from the next location after adr to the end of the
   \ context array.
   context-bounds drop  over /token +  ?do    ( adr )
1A0BD64 	38 BD A0  1 
1A0BD68 	30 49 A0  1 54 49 A0  1 
1A0BD70 	B4 46 A0  1  4 45 A0  1 
1A0BD78 	50 42 A0  1 34  0  0  0 
       \ Look for a non-null entry, replace the current entry with that one,
       \ and replace that one with null
       i get-token?  if                       ( adr acf )
1A0BD80 	B4 42 A0  1 6C 59 A0  1 
1A0BD88 	DC 41 A0  1 18  0  0  0 
          over token!   i !null-token  leave  ( adr )
1A0BD90 	54 49 A0  1 20 54 A0  1 
1A0BD98 	B4 42 A0  1 10 59 A0  1 
1A0BDA0 	18 43 A0  1 
       then                                   ( adr )
   /token +loop
1A0BDA4 	B4 46 A0  1 
1A0BDA8 	1C 42 A0  1 D4 FF FF FF 
   drop
1A0BDB0 	30 49 A0  1 
;
1A0BDB4 	58 46 A0  1 
headers
: clear-context  ( -- )
1A0BDB8 	 0  0 63 6C 65 61 72 2D 
1A0BDC0 	63 6F 6E 74 65 78 74 8D 
1A0BDC8 	60 BD A0  1 20 40 A0  1 
   context-bounds  ?do  i !null-token  /token +loop
1A0BDD0 	38 BD A0  1 50 42 A0  1 
1A0BDD8 	18  0  0  0 B4 42 A0  1 
1A0BDE0 	10 59 A0  1 B4 46 A0  1 
1A0BDE8 	1C 42 A0  1 F0 FF FF FF 
;
1A0BDF0 	58 46 A0  1 
headerless
: compact-search-order  ( -- )
1A0BDF4 	 0  0  0 63 
1A0BDF8 	6F 6D 70 61 63 74 2D 73 
1A0BE00 	65 61 72 63 68 2D 6F 72 
1A0BE08 	64 65 72 94 CC BD A0  1 
1A0BE10 	20 40 A0  1 
   context-bounds  ?do
1A0BE14 	38 BD A0  1 
1A0BE18 	50 42 A0  1 38  0  0  0 
      i get-token? 0=  if   i shuffle-down  else  drop  then
1A0BE20 	B4 42 A0  1 6C 59 A0  1 
1A0BE28 	24 47 A0  1 DC 41 A0  1 
1A0BE30 	14  0  0  0 B4 42 A0  1 
1A0BE38 	60 BD A0  1 C8 41 A0  1 
1A0BE40 	 8  0  0  0 30 49 A0  1 
   /token +loop
1A0BE48 	B4 46 A0  1 1C 42 A0  1 
1A0BE50 	D0 FF FF FF 
;
1A0BE54 	58 46 A0  1 
headers
: (except  ( voc-acf -- )   \ Remove a vocabulary from the search order
1A0BE58 	28 65 78 63 65 70 74 87 
1A0BE60 	10 BE A0  1 20 40 A0  1 
   context-bounds  ?do
1A0BE68 	38 BD A0  1 50 42 A0  1 
1A0BE70 	30  0  0  0 
      dup  i token@  =  if  i  !null-token  then
1A0BE74 	40 49 A0  1 
1A0BE78 	B4 42 A0  1  C 54 A0  1 
1A0BE80 	24 48 A0  1 DC 41 A0  1 
1A0BE88 	 C  0  0  0 B4 42 A0  1 
1A0BE90 	10 59 A0  1 
   /token +loop
1A0BE94 	B4 46 A0  1 
1A0BE98 	1C 42 A0  1 D8 FF FF FF 
   drop compact-search-order
1A0BEA0 	30 49 A0  1 10 BE A0  1 
;
1A0BEA8 	58 46 A0  1 

auser fence        \ barrier for forgetting
1A0BEAC 	 0  0 66 65 
1A0BEB0 	6E 63 65 85 64 BE A0  1 
1A0BEB8 	48 40 A0  1 24  2  0  0 

: (forget)   (s adr -- )	\ reclaim dictionary space above "adr"
1A0BEC0 	 0  0  0 28 66 6F 72 67 
1A0BEC8 	65 74 29 88 B8 BE A0  1 
1A0BED0 	20 40 A0  1 

   dup fence a@ u< ( -15 ) abort" below fence"  ( adr )
1A0BED4 	40 49 A0  1 
1A0BED8 	B8 BE A0  1 88 58 A0  1 
1A0BEE0 	A8 48 A0  1  8 81 A0  1 
1A0BEE8 	 B 62 65 6C 6F 77 20 66 
1A0BEF0 	65 6E 63 65  0  0  0  0 

   \ Forget any entire vocabularies defined after "adr"

   voc-link                          ( adr first-voc )
1A0BEF8 	74 B6 A0  1 
   begin                             ( adr voc )
      \ XXX this may not work with a mixed RAM/ROM system where
      \ RAM is at a lower address than ROM
      a@ 2dup  u<                 ( adr voc' more? )
1A0BEFC 	88 58 A0  1 
1A0BF00 	C0 49 A0  1 A8 48 A0  1 
   while                             ( adr voc )
1A0BF08 	DC 41 A0  1 58  0  0  0 
      dup voc> current-voc =         ( adr voc error? )
1A0BF10 	40 49 A0  1 38 B6 A0  1 
1A0BF18 	34 A4 A0  1 24 48 A0  1 
      ( -15 ) abort" I can't forget the current vocabulary."
1A0BF20 	 8 81 A0  1 26 49 20 63 
1A0BF28 	61 6E 27 74 20 66 6F 72 
1A0BF30 	67 65 74 20 74 68 65 20 
1A0BF38 	63 75 72 72 65 6E 74 20 
1A0BF40 	76 6F 63 61 62 75 6C 61 
1A0BF48 	72 79 2E  0 
      \ Remove the voc from the search order
      dup voc> (except               ( adr voc )
1A0BF4C 	40 49 A0  1 
1A0BF50 	38 B6 A0  1 64 BE A0  1 
      >voc-link                      ( adr voc-link )
1A0BF58 	50 B6 A0  1 
   repeat                            ( adr voc )
1A0BF5C 	C8 41 A0  1 
1A0BF60 	9C FF FF FF 
   dup voc-link a!                ( adr voc )
1A0BF64 	40 49 A0  1 
1A0BF68 	74 B6 A0  1 98 58 A0  1 

   \ For all remaining vocabularies, unlink words defined after "adr"

   \ We assume that we haven't forgotten all the vocabularies;
   \ otherwise this will fail.  Forgetting all the vocabularies would
   \ crash the system anyway, so we don't worry about it.
   begin                             ( adr voc )
      2dup voc> trim                 ( adr voc )
1A0BF70 	C0 49 A0  1 38 B6 A0  1 
1A0BF78 	C0 BC A0  1 
      >voc-link                      ( adr voc-link-adr )
1A0BF7C 	50 B6 A0  1 
      another-link? 0=               ( adr voc' )
1A0BF80 	90 59 A0  1 24 47 A0  1 
   until                             ( adr )
1A0BF88 	DC 41 A0  1 E4 FF FF FF 
   l>beginning  here - allot     \ Reclaim dictionary space
1A0BF90 	90 74 A0  1 70 54 A0  1 
1A0BF98 	18 45 A0  1 E4 54 A0  1 
;
1A0BFA0 	58 46 A0  1 

: forget   (s -- )
1A0BFA4 	 0 66 6F 72 
1A0BFA8 	67 65 74 86 D0 BE A0  1 
1A0BFB0 	20 40 A0  1 
   safe-parse-word   current-voc $vfind  $?missing  drop
1A0BFB4 	88 93 A0  1 
1A0BFB8 	34 A4 A0  1 5C BB A0  1 
1A0BFC0 	84 94 A0  1 30 49 A0  1 
   >link  (forget)
1A0BFC8 	EC 73 A0  1 D0 BE A0  1 
;
1A0BFD0 	58 46 A0  1 

: marker  ( "name" -- )
1A0BFD4 	 0 6D 61 72 
1A0BFD8 	6B 65 72 86 B0 BF A0  1 
1A0BFE0 	20 40 A0  1 
   create  #user @ ,
1A0BFE4 	A8 A2 A0  1 
1A0BFE8 	7C 66 A0  1 5C 4C A0  1 
1A0BFF0 	98 55 A0  1 
   does> dup @  #user !  body> >link  (forget)
1A0BFF4 	50 A3 A0  1 
1A0BFF8 	90 90 90 E8 7C 80 FF FF 
1A0C000 	40 49 A0  1 5C 4C A0  1 
1A0C008 	7C 66 A0  1 54 4D A0  1 
1A0C010 	C8 59 A0  1 EC 73 A0  1 
1A0C018 	D0 BE A0  1 
;
1A0C01C 	58 46 A0  1 
headerless
: init ( -- )  init  ['] ($find-next) is $find-next  ;
1A0C020 	 0  0  0 69 6E 69 74 84 
1A0C028 	E0 BF A0  1 20 40 A0  1 
1A0C030 	A4 B9 A0  1 60 53 A0  1 
1A0C038 	74 60 A0  1 B8 65 A0  1 
1A0C040 	E8 B5 A0  1 58 46 A0  1 
headers


nuser prior        \ used for dictionary searches
1A0C048 	 0  0 70 72 69 6F 72 85 
1A0C050 	2C C0 A0  1 48 40 A0  1 
1A0C058 	28  2  0  0 
: $find-do   (s adr len -- xt +-1 | adr len 0 )
1A0C05C 	 0  0  0 24 
1A0C060 	66 69 6E 64 2D 64 6F 88 
1A0C068 	54 C0 A0  1 20 40 A0  1 
   2dup 2>r
1A0C070 	C0 49 A0  1 F8 45 A0  1 
   $canonical        ( adr' len' )
1A0C078 	FC B9 A0  1 
   prior off         ( adr len )
1A0C07C 	54 C0 A0  1 
1A0C080 	F8 4B A0  1 
   false             ( adr len found? )
1A0C084 	18 70 A0  1 
   context-bounds  ?do
1A0C088 	38 BD A0  1 50 42 A0  1 
1A0C090 	70  0  0  0 
      drop
1A0C094 	30 49 A0  1 
      i get-token?  if                    ( adr len voc )
1A0C098 	B4 42 A0  1 6C 59 A0  1 
1A0C0A0 	DC 41 A0  1 4C  0  0  0 

         \ Don't search the vocabulary again if we just searched it.
         dup prior @ over prior !  =  if  ( adr len voc )
1A0C0A8 	40 49 A0  1 54 C0 A0  1 
1A0C0B0 	5C 4C A0  1 54 49 A0  1 
1A0C0B8 	54 C0 A0  1 54 4D A0  1 
1A0C0C0 	24 48 A0  1 DC 41 A0  1 
1A0C0C8 	14  0  0  0 
            drop false                    ( adr len false )
1A0C0CC 	30 49 A0  1 
1A0C0D0 	18 70 A0  1 
         else                             ( adr len voc )
1A0C0D4 	C8 41 A0  1 
1A0C0D8 	10  0  0  0 
	    $find-word  dup ?leave        ( adr len false )
1A0C0DC 	D4 BA A0  1 
1A0C0E0 	40 49 A0  1 34 43 A0  1 
         then                             ( adr len false )

      else                                ( adr len voc )
1A0C0E8 	C8 41 A0  1  8  0  0  0 
         false                            ( adr len false )
1A0C0F0 	18 70 A0  1 
      then                                ( adr len false )
   /token +loop                           ( adr len false  |  xt +-1 )
1A0C0F4 	B4 46 A0  1 
1A0C0F8 	1C 42 A0  1 98 FF FF FF 
   ?dup  if
1A0C100 	B4 70 A0  1 DC 41 A0  1 
1A0C108 	14  0  0  0 
      2r> 2drop
1A0C10C 	10 46 A0  1 
1A0C110 	AC 49 A0  1 
   else
1A0C114 	C8 41 A0  1 
1A0C118 	10  0  0  0 
      2drop  2r> false
1A0C11C 	AC 49 A0  1 
1A0C120 	10 46 A0  1 18 70 A0  1 
   then
;
1A0C128 	58 46 A0  1 
' $find-do is $find
: find  ( pstr -- pstr false  |  xt +-1 )
1A0C12C 	 0  0  0 66 
1A0C130 	69 6E 64 84 6C C0 A0  1 
1A0C138 	20 40 A0  1 
   dup >r count $find  dup  0=  if  nip nip  r> swap  else  r> drop  then
1A0C13C 	40 49 A0  1 
1A0C140 	BC 45 A0  1 BC 53 A0  1 
1A0C148 	C4 93 A0  1 40 49 A0  1 
1A0C150 	24 47 A0  1 DC 41 A0  1 
1A0C158 	1C  0  0  0 FC 46 A0  1 
1A0C160 	FC 46 A0  1 D0 45 A0  1 
1A0C168 	68 49 A0  1 C8 41 A0  1 
1A0C170 	 C  0  0  0 D0 45 A0  1 
1A0C178 	30 49 A0  1 
;
1A0C17C 	58 46 A0  1 

\ The also/only vocabulary search order scheme

decimal
: >voc  ( n -- adr )  /token *  context +  ;
1A0C180 	 0  0  0 3E 76 6F 63 84 
1A0C188 	38 C1 A0  1 20 40 A0  1 
1A0C190 	B4 46 A0  1 1C 5F A0  1 
1A0C198 	DC A3 A0  1  4 45 A0  1 
1A0C1A0 	58 46 A0  1 

vocabulary root   root definitions
1A0C1A4 	 0  0  0 72 
1A0C1A8 	6F 6F 74 84 8C C1 A0  1 
1A0C1B0 	E0 B6 A0  1 2C  2  0  0 
1A0C1B8 	 0  0 A0  1 

: also  (s -- )  context  1 >voc   #vocs 2- /token *  cmove>  ;
1A0C1BC 	 0  0  0 61 
1A0C1C0 	6C 73 6F 84  0  0 A0  1 
1A0C1C8 	20 40 A0  1 DC A3 A0  1 
1A0C1D0 	80 6F A0  1 8C C1 A0  1 
1A0C1D8 	C8 A3 A0  1 64 4B A0  1 
1A0C1E0 	B4 46 A0  1 1C 5F A0  1 
1A0C1E8 	34 44 A0  1 58 46 A0  1 

: (min-search)  root also  ;
1A0C1F0 	 0  0  0 28 6D 69 6E 2D 
1A0C1F8 	73 65 61 72 63 68 29 8C 
1A0C200 	C8 C1 A0  1 20 40 A0  1 
1A0C208 	B0 C1 A0  1 C8 C1 A0  1 
1A0C210 	58 46 A0  1 
defer minimum-search-order  ' (min-search) is minimum-search-order
1A0C214 	 0  0  0 6D 
1A0C218 	69 6E 69 6D 75 6D 2D 73 
1A0C220 	65 61 72 63 68 2D 6F 72 
1A0C228 	64 65 72 94  4 C2 A0  1 
1A0C230 	5C 40 A0  1 30  2  0  0 
: forth-wordlist  ( -- wid )  ['] forth  ;
1A0C238 	 0 66 6F 72 74 68 2D 77 
1A0C240 	6F 72 64 6C 69 73 74 8E 
1A0C248 	30 C2 A0  1 20 40 A0  1 
1A0C250 	60 53 A0  1 97 87 5D  0 
1A0C258 	58 46 A0  1 
: get-current  ( -- )  current token@  ;
1A0C25C 	67 65 74 2D 
1A0C260 	63 75 72 72 65 6E 74 8B 
1A0C268 	4C C2 A0  1 20 40 A0  1 
1A0C270 	F0 A3 A0  1  C 54 A0  1 
1A0C278 	58 46 A0  1 
: set-current  ( -- )  current token!  ;
1A0C27C 	73 65 74 2D 
1A0C280 	63 75 72 72 65 6E 74 8B 
1A0C288 	6C C2 A0  1 20 40 A0  1 
1A0C290 	F0 A3 A0  1 20 54 A0  1 
1A0C298 	58 46 A0  1 

: get-order  ( -- vocn .. voc1 n )
1A0C29C 	 0  0 67 65 
1A0C2A0 	74 2D 6F 72 64 65 72 89 
1A0C2A8 	8C C2 A0  1 20 40 A0  1 
   0  0  #vocs 1-  do
1A0C2B0 	70 6F A0  1 70 6F A0  1 
1A0C2B8 	C8 A3 A0  1 54 4B A0  1 
1A0C2C0 	88 42 A0  1 34  0  0  0 
      i >voc token@ non-null?  if  swap 1+  then
1A0C2C8 	B4 42 A0  1 8C C1 A0  1 
1A0C2D0 	 C 54 A0  1 34 59 A0  1 
1A0C2D8 	DC 41 A0  1  C  0  0  0 
1A0C2E0 	68 49 A0  1 30 4B A0  1 
   -1 +loop
1A0C2E8 	58 41 A0  1 FF FF FF FF 
1A0C2F0 	1C 42 A0  1 D4 FF FF FF 
;
1A0C2F8 	58 46 A0  1 
: set-order  ( vocn .. voc1 n -- )
1A0C2FC 	 0  0 73 65 
1A0C300 	74 2D 6F 72 64 65 72 89 
1A0C308 	AC C2 A0  1 20 40 A0  1 
   dup #vocs >  abort" Too many vocabularies in requested search order"
1A0C310 	40 49 A0  1 C8 A3 A0  1 
1A0C318 	 4 48 A0  1  8 81 A0  1 
1A0C320 	2F 54 6F 6F 20 6D 61 6E 
1A0C328 	79 20 76 6F 63 61 62 75 
1A0C330 	6C 61 72 69 65 73 20 69 
1A0C338 	6E 20 72 65 71 75 65 73 
1A0C340 	74 65 64 20 73 65 61 72 
1A0C348 	63 68 20 6F 72 64 65 72 
1A0C350 	 0  0  0  0 
   clear-context
1A0C354 	CC BD A0  1 
   0  ?do  i >voc token!  loop
1A0C358 	70 6F A0  1 50 42 A0  1 
1A0C360 	18  0  0  0 B4 42 A0  1 
1A0C368 	8C C1 A0  1 20 54 A0  1 
1A0C370 	F8 41 A0  1 F0 FF FF FF 
;
1A0C378 	58 46 A0  1 

: only  (s -- )
1A0C37C 	 0  0  0 6F 
1A0C380 	6E 6C 79 84  C C3 A0  1 
1A0C388 	20 40 A0  1 
   clear-context
1A0C38C 	CC BD A0  1 
\   ['] root  #vocs 1- >voc  token!
   minimum-search-order
1A0C390 	30 C2 A0  1 
;
1A0C394 	58 46 A0  1 

: except  \ vocabulary-name  ( -- )
1A0C398 	 0 65 78 63 65 70 74 86 
1A0C3A0 	88 C3 A0  1 20 40 A0  1 
   ' (except
1A0C3A8 	F8 95 A0  1 64 BE A0  1 
;
1A0C3B0 	58 46 A0  1 
: seal  (s -- )  ['] root (except  ;
1A0C3B4 	 0  0  0 73 
1A0C3B8 	65 61 6C 84 A4 C3 A0  1 
1A0C3C0 	20 40 A0  1 60 53 A0  1 
1A0C3C8 	B0 C1 A0  1 64 BE A0  1 
1A0C3D0 	58 46 A0  1 
: previous   (s -- )
1A0C3D4 	 0  0  0 70 
1A0C3D8 	72 65 76 69 6F 75 73 88 
1A0C3E0 	C0 C3 A0  1 20 40 A0  1 
   1 >voc  context  #vocs 2- /token *  cmove
1A0C3E8 	80 6F A0  1 8C C1 A0  1 
1A0C3F0 	DC A3 A0  1 C8 A3 A0  1 
1A0C3F8 	64 4B A0  1 B4 46 A0  1 
1A0C400 	1C 5F A0  1 10 44 A0  1 
   #vocs 2- >voc  !null-token
1A0C408 	C8 A3 A0  1 64 4B A0  1 
1A0C410 	8C C1 A0  1 10 59 A0  1 
;
1A0C418 	58 46 A0  1 

: definitions  ( -- )  context token@ set-current  ;
1A0C41C 	64 65 66 69 
1A0C420 	6E 69 74 69 6F 6E 73 8B 
1A0C428 	E4 C3 A0  1 20 40 A0  1 
1A0C430 	DC A3 A0  1  C 54 A0  1 
1A0C438 	8C C2 A0  1 58 46 A0  1 

: order   (s -- )
1A0C440 	 0  0 6F 72 64 65 72 85 
1A0C448 	2C C4 A0  1 20 40 A0  1 
   ." context: "
1A0C450 	20 7C A0  1  9 63 6F 6E 
1A0C458 	74 65 78 74 3A 20  0  0 
   get-order  0  ?do  .name  loop
1A0C460 	AC C2 A0  1 70 6F A0  1 
1A0C468 	50 42 A0  1 10  0  0  0 
1A0C470 	C8 9A A0  1 F8 41 A0  1 
1A0C478 	F8 FF FF FF 
   4 spaces  ." current: "  get-current .name
1A0C47C 	B0 6F A0  1 
1A0C480 	E8 71 A0  1 20 7C A0  1 
1A0C488 	 9 63 75 72 72 65 6E 74 
1A0C490 	3A 20  0  0 6C C2 A0  1 
1A0C498 	C8 9A A0  1 
;
1A0C49C 	58 46 A0  1 
: vocs   (s -- )
1A0C4A0 	 0  0  0 76 6F 63 73 84 
1A0C4A8 	4C C4 A0  1 20 40 A0  1 
   voc-link  begin  another-link?  while  ( link )
1A0C4B0 	74 B6 A0  1 90 59 A0  1 
1A0C4B8 	DC 41 A0  1 3C  0  0  0 
      #out @ 64 >  if  cr  then
1A0C4C0 	5C 6D A0  1 5C 4C A0  1 
1A0C4C8 	58 41 A0  1 40  0  0  0 
1A0C4D0 	 4 48 A0  1 DC 41 A0  1 
1A0C4D8 	 8  0  0  0 80 6D A0  1 
      dup  voc>  .name
1A0C4E0 	40 49 A0  1 38 B6 A0  1 
1A0C4E8 	C8 9A A0  1 
      >voc-link
1A0C4EC 	50 B6 A0  1 
   repeat
1A0C4F0 	C8 41 A0  1 C0 FF FF FF 
;
1A0C4F8 	58 46 A0  1 

forthusadr fw-pa userarea-t + - #user-t !

vocabulary forth forth definitions
1A0C4FC 	 0  0 66 6F 
1A0C500 	72 74 68 85 AC C4 A0  1 
1A0C508 	E0 B6 A0  1 60  2  0  0 
1A0C510 	B0 C1 A0  1 



\ only forth also definitions
\ : (cold-hook   ( -- )   (cold-hook  only forth also definitions  ;
\ headers

headerless
also root
: init  ( -- )  init  only forth also definitions  ;
1A0C514 	 0  0  0 69 
1A0C518 	6E 69 74 84 B0 C1 A0  1 
1A0C520 	20 40 A0  1 2C C0 A0  1 
1A0C528 	88 C3 A0  1  8 C5 A0  1 
1A0C530 	C8 C1 A0  1 2C C4 A0  1 
1A0C538 	58 46 A0  1 
[p]
headers


variable isvar
1A0C53C 	 0  0 69 73 
1A0C540 	76 61 72 85 20 C5 A0  1 
1A0C548 	48 40 A0  1 64  2  0  0 
0 value isval
1A0C550 	 0  0 69 73 76 61 6C 85 
1A0C558 	48 C5 A0  1 50 40 A0  1 
1A0C560 	68  2  0  0 

headerless

[ifdef] run-time
: is-error  ( data acf -- )  true ( -32 ) abort" inappropriate use of `is'"  ;
[else]
: is-error  ( data acf -- )  ." Can't use is with " .name cr ( -32 ) abort  ;
1A0C564 	 0  0  0 69 
1A0C568 	73 2D 65 72 72 6F 72 88 
1A0C570 	5C C5 A0  1 20 40 A0  1 
1A0C578 	20 7C A0  1 12 43 61 6E 
1A0C580 	27 74 20 75 73 65 20 69 
1A0C588 	73 20 77 69 74 68 20  0 
1A0C590 	C8 9A A0  1 80 6D A0  1 
1A0C598 	28 91 A0  1 58 46 A0  1 
[then]

headers

defer to-hook
1A0C5A0 	74 6F 2D 68 6F 6F 6B 87 
1A0C5A8 	74 C5 A0  1 5C 40 A0  1 
1A0C5B0 	6C  2  0  0 
' is-error is to-hook

headerless

: >bu  ( acf -- data-adr )  >body >user  ;
1A0C5B4 	3E 62 75 83 
1A0C5B8 	AC C5 A0  1 20 40 A0  1 
1A0C5C0 	E4 59 A0  1 C8 74 A0  1 
1A0C5C8 	58 46 A0  1 

create word-types
1A0C5CC 	 0 77 6F 72 
1A0C5D0 	64 2D 74 79 70 65 73 8A 
1A0C5D8 	BC C5 A0  1 30 40 A0  1 
   ' key    token,-t	\ defer
1A0C5E0 	50 6C A0  1 
   ' #user  token,-t	\ user variable
1A0C5E4 	7C 66 A0  1 
   ' isval  token,-t	\ value
1A0C5E8 	5C C5 A0  1 
   ' bl     token,-t	\ constant
1A0C5EC 	28 70 A0  1 
   ' isvar  token,-t	\ variable
1A0C5F0 	48 C5 A0  1 
   origin   token,-t	\ END   \ origin should be null
1A0C5F4 	 0  0 A0  1 

create data-locs
1A0C5F8 	 0  0 64 61 74 61 2D 6C 
1A0C600 	6F 63 73 89 DC C5 A0  1 
1A0C608 	30 40 A0  1 
   ' >bu    token,-t	\ defer
1A0C60C 	BC C5 A0  1 
   ' >bu    token,-t	\ user variable
1A0C610 	BC C5 A0  1 
   ' >bu    token,-t	\ value
1A0C614 	BC C5 A0  1 
   ' >body  token,-t	\ constant
1A0C618 	E4 59 A0  1 
   ' >body  token,-t	\ variable
1A0C61C 	E4 59 A0  1 

create !ops
1A0C620 	 0  0  0 21 6F 70 73 84 
1A0C628 	 8 C6 A0  1 30 40 A0  1 
   ' token! token,-t	\ defer
1A0C630 	20 54 A0  1 
   ' !      token,-t	\ user variable
1A0C634 	54 4D A0  1 
   ' !      token,-t	\ value
1A0C638 	54 4D A0  1 
   ' !      token,-t	\ constant
1A0C63C 	54 4D A0  1 
   ' !      token,-t	\ variable
1A0C640 	54 4D A0  1 

create is-ops
1A0C644 	 0 69 73 2D 
1A0C648 	6F 70 73 86 2C C6 A0  1 
1A0C650 	30 40 A0  1 
   ' isdefer    token,-t	\ defer
1A0C654 	98 40 A0  1 
   ' isuser     token,-t	\ user variable
1A0C658 	D8 40 A0  1 
   ' isvalue    token,-t	\ value
1A0C65C 	B8 40 A0  1 
   ' isconstant token,-t	\ constant
1A0C660 	FC 40 A0  1 
   ' isvariable token,-t	\ variable
1A0C664 	1C 41 A0  1 

: associate  ( acf -- true  |  index false )
1A0C668 	 0  0 61 73 73 6F 63 69 
1A0C670 	61 74 65 89 50 C6 A0  1 
1A0C678 	20 40 A0  1 
   word-type  ( n )
1A0C67C 	B0 59 A0  1 
   word-types  begin              ( n adr )
1A0C680 	DC C5 A0  1 
      2dup get-token?             ( n adr n  false | acf true )
1A0C684 	C0 49 A0  1 
1A0C688 	6C 59 A0  1 
   while                          ( n adr n acf )
1A0C68C 	DC 41 A0  1 
1A0C690 	3C  0  0  0 
      word-type  = if             ( n adr )
1A0C694 	B0 59 A0  1 
1A0C698 	24 48 A0  1 DC 41 A0  1 
1A0C6A0 	20  0  0  0 
         word-types -  /token /   ( n index )
1A0C6A4 	DC C5 A0  1 
1A0C6A8 	18 45 A0  1 B4 46 A0  1 
1A0C6B0 	98 5F A0  1 
	 nip false  exit          ( index false )
1A0C6B4 	FC 46 A0  1 
1A0C6B8 	18 70 A0  1 40 46 A0  1 
      then                        ( n adr )
      ta1+                        ( n adr' )
1A0C6C0 	FC 50 A0  1 
   repeat                         ( n adr n )
1A0C6C4 	C8 41 A0  1 
1A0C6C8 	BC FF FF FF 
   3drop true                     ( true )
1A0C6CC 	90 52 A0  1 
1A0C6D0 	 4 70 A0  1 
;
1A0C6D4 	58 46 A0  1 

: +execute  ( index table -- )
1A0C6D8 	 0  0  0 2B 65 78 65 63 
1A0C6E0 	75 74 65 88 78 C6 A0  1 
1A0C6E8 	20 40 A0  1 
   swap ta+ token@ execute        ( )
1A0C6EC 	68 49 A0  1 
1A0C6F0 	60 50 A0  1  C 54 A0  1 
1A0C6F8 	98 41 A0  1 
;
1A0C6FC 	58 46 A0  1 

headers
: behavior  ( defer-acf -- acf2 )  >bu token@  ;
1A0C700 	 0  0  0 62 65 68 61 76 
1A0C708 	69 6F 72 88 E8 C6 A0  1 
1A0C710 	20 40 A0  1 BC C5 A0  1 
1A0C718 	 C 54 A0  1 58 46 A0  1 


: (is-do
1A0C720 	 0 28 69 73 2D 64 6F 86 
1A0C728 	10 C7 A0  1 20 40 A0  1 
   dup  associate  if  is-error  then   ( data acf index )
1A0C730 	40 49 A0  1 78 C6 A0  1 
1A0C738 	DC 41 A0  1  8  0  0  0 
1A0C740 	74 C5 A0  1 
   tuck data-locs +execute              ( data index data-adr )
1A0C744 	E8 46 A0  1 
1A0C748 	 8 C6 A0  1 E8 C6 A0  1 
   swap !ops +execute                   ( )
1A0C750 	68 49 A0  1 2C C6 A0  1 
1A0C758 	E8 C6 A0  1 
;
1A0C75C 	58 46 A0  1 
' (is-do is (is

: >data  ( acf -- data-adr )
1A0C760 	 0  0 3E 64 61 74 61 85 
1A0C768 	2C C7 A0  1 20 40 A0  1 
   dup associate  if        ( acf )
1A0C770 	40 49 A0  1 78 C6 A0  1 
1A0C778 	DC 41 A0  1 10  0  0  0 
      >body                 ( data-adr )
1A0C780 	E4 59 A0  1 
   else                     ( acf index )
1A0C784 	C8 41 A0  1 
1A0C788 	 C  0  0  0 
      data-locs +execute    ( data-adr )
1A0C78C 	 8 C6 A0  1 
1A0C790 	E8 C6 A0  1 
   then                     ( data-adr )
;
1A0C794 	58 46 A0  1 

\ (is) is a run-time word that is compiled into definitions


: ([)  (s -- )
1A0C798 	28 5B 29 83 6C C7 A0  1 
1A0C7A0 	20 40 A0  1 
  ['] interpret-do-defined    ['] do-defined    (is
1A0C7A4 	60 53 A0  1 
1A0C7A8 	3C 9F A0  1 60 53 A0  1 
1A0C7B0 	E0 9D A0  1 A4 65 A0  1 
  ['] $interpret-do-undefined ['] $do-undefined (is
1A0C7B8 	60 53 A0  1 BC 9F A0  1 
1A0C7C0 	60 53 A0  1 FC 9D A0  1 
1A0C7C8 	A4 65 A0  1 
  state off
1A0C7CC 	38 54 A0  1 
1A0C7D0 	F8 4B A0  1 
;
1A0C7D4 	58 46 A0  1 
' ([) is [

: (])  (s -- )
1A0C7D8 	28 5D 29 83 A0 C7 A0  1 
1A0C7E0 	20 40 A0  1 
  ['] compile-do-defined     ['] do-defined    (is
1A0C7E4 	60 53 A0  1 
1A0C7E8 	64 9F A0  1 60 53 A0  1 
1A0C7F0 	E0 9D A0  1 A4 65 A0  1 
  ['] $compile-do-undefined  ['] $do-undefined (is
1A0C7F8 	60 53 A0  1  8 A0 A0  1 
1A0C800 	60 53 A0  1 FC 9D A0  1 
1A0C808 	A4 65 A0  1 
  state on
1A0C80C 	38 54 A0  1 
1A0C810 	E0 4B A0  1 
;
1A0C814 	58 46 A0  1 
' (]) is ]

[ifndef] run-time

: do-is  ( data acf -- )
1A0C818 	 0  0 64 6F 2D 69 73 85 
1A0C820 	E0 C7 A0  1 20 40 A0  1 
   dup associate  if              ( [data] acf )
1A0C828 	40 49 A0  1 78 C6 A0  1 
1A0C830 	DC 41 A0  1 10  0  0  0 
      to-hook
1A0C838 	AC C5 A0  1 
   else                           ( [data] acf index )
1A0C83C 	C8 41 A0  1 
1A0C840 	4C  0  0  0 
      state @  if                 ( acf index )
1A0C844 	38 54 A0  1 
1A0C848 	5C 4C A0  1 DC 41 A0  1 
1A0C850 	24  0  0  0 
         is-ops swap ta+ token@   ( acf is-token )
1A0C854 	50 C6 A0  1 
1A0C858 	68 49 A0  1 60 50 A0  1 
1A0C860 	 C 54 A0  1 
         token, token,            ( )
1A0C864 	2C 55 A0  1 
1A0C868 	2C 55 A0  1 
      else                        ( data acf index )
1A0C86C 	C8 41 A0  1 
1A0C870 	1C  0  0  0 
         tuck data-locs +execute  ( data index data-adr )
1A0C874 	E8 46 A0  1 
1A0C878 	 8 C6 A0  1 E8 C6 A0  1 
         swap !ops +execute       ( )
1A0C880 	68 49 A0  1 2C C6 A0  1 
1A0C888 	E8 C6 A0  1 
      then                        ( )
   then                           ( )
;
1A0C88C 	58 46 A0  1 
\ is is the word that is actually used by applications
: is  \ name  ( data -- )
1A0C890 	 0 69 73 C2 24 C8 A0  1 
1A0C898 	20 40 A0  1 
   ' do-is
1A0C89C 	F8 95 A0  1 
1A0C8A0 	24 C8 A0  1 
; immediate
1A0C8A4 	58 46 A0  1 
\ only forth also definitions

[then]

\ A place to put the last word returned by blword
0 value 'word
1A0C8A8 	 0  0 27 77 6F 72 64 85 
1A0C8B0 	98 C8 A0  1 50 40 A0  1 
1A0C8B8 	70  2  0  0 

[ifndef] omit-files
\ From filecomm.fth

decimal

\ buffered i/o  constants
-1 constant eof
1A0C8BC 	65 6F 66 83 
1A0C8C0 	B4 C8 A0  1 68 40 A0  1 
1A0C8C8 	FF FF FF FF 

nuser delimiter  \ delimiter actually found at end of word
1A0C8CC 	 0  0 64 65 
1A0C8D0 	6C 69 6D 69 74 65 72 89 
1A0C8D8 	C4 C8 A0  1 48 40 A0  1 
1A0C8E0 	74  2  0  0 

/n round-up
headers
20 /n-t * d# 68 +  constant /fd
1A0C8E4 	2F 66 64 83 
1A0C8E8 	DC C8 A0  1 68 40 A0  1 
1A0C8F0 	94  0  0  0 

: set-name  ( adr len -- )
1A0C8F4 	 0  0  0 73 
1A0C8F8 	65 74 2D 6E 61 6D 65 88 
1A0C900 	EC C8 A0  1 20 40 A0  1 
   \ If the name is too long, cut off initial characters (because the
   \ latter ones are more likely to be interesting), and replace the
   \ first character with "?".
   dup d# 64 -  0 max  dup >r  /string  (file-name) place
1A0C908 	40 49 A0  1 58 41 A0  1 
1A0C910 	40  0  0  0 18 45 A0  1 
1A0C918 	70 6F A0  1 9C 4A A0  1 
1A0C920 	40 49 A0  1 BC 45 A0  1 
1A0C928 	3C 85 A0  1 60 AE A0  1 
1A0C930 	F0 88 A0  1 
   r>  if  ascii ? (file-name) 1+ c!  then
1A0C934 	D0 45 A0  1 
1A0C938 	DC 41 A0  1 18  0  0  0 
1A0C940 	58 41 A0  1 3F  0  0  0 
1A0C948 	60 AE A0  1 30 4B A0  1 
1A0C950 	B8 4D A0  1 
;
1A0C954 	58 46 A0  1 

: setupfd  ( fid fmode sizeop alignop closeop seekop writeop readop -- )
1A0C958 	73 65 74 75 70 66 64 87 
1A0C960 	 4 C9 A0  1 20 40 A0  1 
   readop !  writeop !  seekop !  closeop !  alignop !  sizeop !
1A0C968 	 8 AD A0  1 54 4D A0  1 
1A0C970 	30 AD A0  1 54 4D A0  1 
1A0C978 	E0 AC A0  1 54 4D A0  1 
1A0C980 	58 AD A0  1 54 4D A0  1 
1A0C988 	80 AD A0  1 54 4D A0  1 
1A0C990 	A8 AD A0  1 54 4D A0  1 
   fmode !  fid !  0 (file-line) !  0 0 set-name
1A0C998 	74 AC A0  1 54 4D A0  1 
1A0C9A0 	B8 AC A0  1 54 4D A0  1 
1A0C9A8 	70 6F A0  1 D4 AD A0  1 
1A0C9B0 	54 4D A0  1 70 6F A0  1 
1A0C9B8 	70 6F A0  1  4 C9 A0  1 
;
1A0C9C0 	58 46 A0  1 

headerless
\ values for mode field
-1  constant not-open
1A0C9C4 	 0  0  0 6E 
1A0C9C8 	6F 74 2D 6F 70 65 6E 88 
1A0C9D0 	64 C9 A0  1 68 40 A0  1 
1A0C9D8 	FF FF FF FF 
headers
 0  constant read
1A0C9DC 	 0  0  0 72 
1A0C9E0 	65 61 64 84 D4 C9 A0  1 
1A0C9E8 	68 40 A0  1  0  0  0  0 
 1  constant write
1A0C9F0 	 0  0 77 72 69 74 65 85 
1A0C9F8 	E8 C9 A0  1 68 40 A0  1 
1A0CA00 	 1  0  0  0 
 2  constant modify
1A0CA04 	 0 6D 6F 64 
1A0CA08 	69 66 79 86 FC C9 A0  1 
1A0CA10 	68 40 A0  1  2  0  0  0 
headerless
modify constant read-write  ( for old programs )
1A0CA18 	 0 72 65 61 64 2D 77 72 
1A0CA20 	69 74 65 8A 10 CA A0  1 
1A0CA28 	68 40 A0  1  2  0  0  0 

\ Stub routines for readop and writeop
headers
\ These return 0 for the number of bytes actually transferred.
: nullwrite  ( adr count fd -- 0 )  3drop 0  ;
1A0CA30 	 0  0 6E 75 6C 6C 77 72 
1A0CA38 	69 74 65 89 28 CA A0  1 
1A0CA40 	20 40 A0  1 90 52 A0  1 
1A0CA48 	70 6F A0  1 58 46 A0  1 
: fakewrite  ( adr count fd -- count )  drop nip  ;
1A0CA50 	 0  0 66 61 6B 65 77 72 
1A0CA58 	69 74 65 89 40 CA A0  1 
1A0CA60 	20 40 A0  1 30 49 A0  1 
1A0CA68 	FC 46 A0  1 58 46 A0  1 
: nullalign  ( d.position fd -- d.position' )  drop  ;
1A0CA70 	 0  0 6E 75 6C 6C 61 6C 
1A0CA78 	69 67 6E 89 60 CA A0  1 
1A0CA80 	20 40 A0  1 30 49 A0  1 
1A0CA88 	58 46 A0  1 
: nullread  ( adr count fd -- 0 )  3drop 0  ;
1A0CA8C 	 0  0  0 6E 
1A0CA90 	75 6C 6C 72 65 61 64 88 
1A0CA98 	80 CA A0  1 20 40 A0  1 
1A0CAA0 	90 52 A0  1 70 6F A0  1 
1A0CAA8 	58 46 A0  1 
: nullseek  ( d.byte# fd -- )  3drop  ;
1A0CAAC 	 0  0  0 6E 
1A0CAB0 	75 6C 6C 73 65 65 6B 88 
1A0CAB8 	9C CA A0  1 20 40 A0  1 
1A0CAC0 	90 52 A0  1 58 46 A0  1 
headerless
\ This one pretends to have transferred the requested number of bytes
: fakeread  ( adr count fd -- count )  drop nip  ;
1A0CAC8 	 0  0  0 66 61 6B 65 72 
1A0CAD0 	65 61 64 88 BC CA A0  1 
1A0CAD8 	20 40 A0  1 30 49 A0  1 
1A0CAE0 	FC 46 A0  1 58 46 A0  1 

headers
\ Initializes the current descriptor to use the buffer "bufstart,buflen"
: initbuf  ( bufstart buflen -- )
1A0CAE8 	69 6E 69 74 62 75 66 87 
1A0CAF0 	D8 CA A0  1 20 40 A0  1 
   0 0 fstart 2!   over + bflimit !  ( bufstart )
1A0CAF8 	70 6F A0  1 70 6F A0  1 
1A0CB00 	98 AC A0  1 E4 4D A0  1 
1A0CB08 	54 49 A0  1  4 45 A0  1 
1A0CB10 	BC AB A0  1 54 4D A0  1 
   dup bfbase ! dup bfcurrent ! dup bfend !  bftop !
1A0CB18 	40 49 A0  1 98 AB A0  1 
1A0CB20 	54 4D A0  1 40 49 A0  1 
1A0CB28 	2C AC A0  1 54 4D A0  1 
1A0CB30 	40 49 A0  1  4 AC A0  1 
1A0CB38 	54 4D A0  1 E0 AB A0  1 
1A0CB40 	54 4D A0  1 
   bfdirty off
1A0CB44 	50 AC A0  1 
1A0CB48 	F8 4B A0  1 
;
1A0CB4C 	58 46 A0  1 

\ "unallocate" a file descriptor
: release-fd  ( fd -- )  file @ >r  file !  not-open fmode !  r> file !  ;
1A0CB50 	 0 72 65 6C 65 61 73 65 
1A0CB58 	2D 66 64 8A F4 CA A0  1 
1A0CB60 	20 40 A0  1 84 AB A0  1 
1A0CB68 	5C 4C A0  1 BC 45 A0  1 
1A0CB70 	84 AB A0  1 54 4D A0  1 
1A0CB78 	D4 C9 A0  1 74 AC A0  1 
1A0CB80 	54 4D A0  1 D0 45 A0  1 
1A0CB88 	84 AB A0  1 54 4D A0  1 
1A0CB90 	58 46 A0  1 
headerless

\ An implementation factor which returns true if the file descriptor fd
\ is not currently in use
: fdavail?  ( fd -- f )  file @ >r  file !  fmode @ not-open =  r> file !  ;
1A0CB94 	 0  0  0 66 
1A0CB98 	64 61 76 61 69 6C 3F 88 
1A0CBA0 	60 CB A0  1 20 40 A0  1 
1A0CBA8 	84 AB A0  1 5C 4C A0  1 
1A0CBB0 	BC 45 A0  1 84 AB A0  1 
1A0CBB8 	54 4D A0  1 74 AC A0  1 
1A0CBC0 	5C 4C A0  1 D4 C9 A0  1 
1A0CBC8 	24 48 A0  1 D0 45 A0  1 
1A0CBD0 	84 AB A0  1 54 4D A0  1 
1A0CBD8 	58 46 A0  1 

\ These are the words that a program uses to read and write to/from a file.



\ Buffer boundaries are transparent
\ end-of-file conditions work correctly
\ The actual delimiter encountered is stored in delimiter.

headers
\ input-file contains the file descriptor which defines the input stream.
nuser input-file
1A0CBDC 	 0 69 6E 70 
1A0CBE0 	75 74 2D 66 69 6C 65 8A 
1A0CBE8 	A4 CB A0  1 48 40 A0  1 
1A0CBF0 	78  2  0  0 

headerless

\ ?fillbuf is called by the string scanning routines after skipbl, scanbl,
\ skipto, or scanto has returned.  ?fillbuf determines whether or not
\ the end of a buffer has been reached.  If so, the buffer is refilled and
\ end? is set to false so that the skip/scan routine will be called again,
\ (unless the end of the file is reached).

: ?fillbuf  ( endaddr [ adr ]  delimiter -- endaddr' addr' end? )
1A0CBF4 	 0  0  0 3F 
1A0CBF8 	66 69 6C 6C 62 75 66 88 
1A0CC00 	EC CB A0  1 20 40 A0  1 
    dup delimiter !  eof =  if ( endaddr )
1A0CC08 	40 49 A0  1 DC C8 A0  1 
1A0CC10 	54 4D A0  1 C4 C8 A0  1 
1A0CC18 	24 48 A0  1 DC 41 A0  1 
1A0CC20 	28  0  0  0 
       shortseek
1A0CC24 	C0 B0 A0  1 
       bftop @  bfcurrent @    ( endaddr'  addr' )
1A0CC28 	E0 AB A0  1 5C 4C A0  1 
1A0CC30 	2C AC A0  1 5C 4C A0  1 
       2dup u<=                ( endaddr'  addr' end-of-file? )
1A0CC38 	C0 49 A0  1 88 48 A0  1 
    else                       ( endaddr addr )
1A0CC40 	C8 41 A0  1  8  0  0  0 
       true            \ True so we'll exit the loop
1A0CC48 	 4 70 A0  1 
    then
;
1A0CC4C 	58 46 A0  1 

headers
\ Closes the file.
: fclose  ( fd -- )
1A0CC50 	 0 66 63 6C 6F 73 65 86 
1A0CC58 	 4 CC A0  1 20 40 A0  1 
   file @ >r  file !
1A0CC60 	84 AB A0  1 5C 4C A0  1 
1A0CC68 	BC 45 A0  1 84 AB A0  1 
1A0CC70 	54 4D A0  1 
   file @  fdavail?  0=  if
1A0CC74 	84 AB A0  1 
1A0CC78 	5C 4C A0  1 A4 CB A0  1 
1A0CC80 	24 47 A0  1 DC 41 A0  1 
1A0CC88 	28  0  0  0 
      ?flushbuf  fid @ closeop @ execute
1A0CC8C 	EC AE A0  1 
1A0CC90 	B8 AC A0  1 5C 4C A0  1 
1A0CC98 	58 AD A0  1 5C 4C A0  1 
1A0CCA0 	98 41 A0  1 
      file @  release-fd
1A0CCA4 	84 AB A0  1 
1A0CCA8 	5C 4C A0  1 60 CB A0  1 
   then
   r> file !
1A0CCB0 	D0 45 A0  1 84 AB A0  1 
1A0CCB8 	54 4D A0  1 
;
1A0CCBC 	58 46 A0  1 
: close-file  ( fd -- ior )  fclose 0  ;
1A0CCC0 	 0 63 6C 6F 73 65 2D 66 
1A0CCC8 	69 6C 65 8A 5C CC A0  1 
1A0CCD0 	20 40 A0  1 5C CC A0  1 
1A0CCD8 	70 6F A0  1 58 46 A0  1 

headerless
\ File descriptor allocation


32         constant #fds
1A0CCE0 	 0  0  0 23 66 64 73 84 
1A0CCE8 	D0 CC A0  1 68 40 A0  1 
1A0CCF0 	20  0  0  0 
#fds /fd * constant /fds
1A0CCF4 	 0  0  0 2F 
1A0CCF8 	66 64 73 84 EC CC A0  1 
1A0CD00 	68 40 A0  1 80 12  0  0 

nuser fds
1A0CD08 	66 64 73 83  0 CD A0  1 
1A0CD10 	48 40 A0  1 7C  2  0  0 

headerless
\ Initialize pool of file descriptors
: init  ( -- )
1A0CD18 	 0  0  0 69 6E 69 74 84 
1A0CD20 	10 CD A0  1 20 40 A0  1 
   init
1A0CD28 	20 C5 A0  1 
   /stringbuf alloc-mem is 'word
1A0CD2C 	DC 7C A0  1 
1A0CD30 	F0 6C A0  1 B8 65 A0  1 
1A0CD38 	B4 C8 A0  1 
   /fds alloc-mem  ( base-address )  fds !
1A0CD3C 	 0 CD A0  1 
1A0CD40 	F0 6C A0  1 10 CD A0  1 
1A0CD48 	54 4D A0  1 
   fds @  /fds   bounds   do   i release-fd   /fd +loop
1A0CD4C 	10 CD A0  1 
1A0CD50 	5C 4C A0  1  0 CD A0  1 
1A0CD58 	F0 6D A0  1 88 42 A0  1 
1A0CD60 	18  0  0  0 B4 42 A0  1 
1A0CD68 	60 CB A0  1 EC C8 A0  1 
1A0CD70 	1C 42 A0  1 F0 FF FF FF 
;
1A0CD78 	58 46 A0  1 

headers
\ Allocates a file descriptor if possible
: (get-fd  ( -- fd | 0 )
1A0CD7C 	28 67 65 74 
1A0CD80 	2D 66 64 87 24 CD A0  1 
1A0CD88 	20 40 A0  1 
   0
1A0CD8C 	70 6F A0  1 
   fds @  /fds  bounds  ?do               ( 0 )
1A0CD90 	10 CD A0  1 5C 4C A0  1 
1A0CD98 	 0 CD A0  1 F0 6D A0  1 
1A0CDA0 	50 42 A0  1 2C  0  0  0 
      i fdavail?  if  drop i leave  then  ( 0 )
1A0CDA8 	B4 42 A0  1 A4 CB A0  1 
1A0CDB0 	DC 41 A0  1 10  0  0  0 
1A0CDB8 	30 49 A0  1 B4 42 A0  1 
1A0CDC0 	18 43 A0  1 
   /fd +loop                              ( fd | 0 )
1A0CDC4 	EC C8 A0  1 
1A0CDC8 	1C 42 A0  1 DC FF FF FF 
;
1A0CDD0 	58 46 A0  1 

: string-sizeop  ( fhandle -- d.length )  drop  bflimit @  bfbase @ -  0  ;
1A0CDD4 	 0  0 73 74 
1A0CDD8 	72 69 6E 67 2D 73 69 7A 
1A0CDE0 	65 6F 70 8D 88 CD A0  1 
1A0CDE8 	20 40 A0  1 30 49 A0  1 
1A0CDF0 	BC AB A0  1 5C 4C A0  1 
1A0CDF8 	98 AB A0  1 5C 4C A0  1 
1A0CE00 	18 45 A0  1 70 6F A0  1 
1A0CE08 	58 46 A0  1 
: hold$  ( adr len -- )
1A0CE0C 	 0  0 68 6F 
1A0CE10 	6C 64 24 85 E8 CD A0  1 
1A0CE18 	20 40 A0  1 
   dup  if
1A0CE1C 	40 49 A0  1 
1A0CE20 	DC 41 A0  1 3C  0  0  0 
      1- bounds swap  do  i c@ hold  -1 +loop
1A0CE28 	54 4B A0  1 F0 6D A0  1 
1A0CE30 	68 49 A0  1 88 42 A0  1 
1A0CE38 	20  0  0  0 B4 42 A0  1 
1A0CE40 	C4 4C A0  1 DC 75 A0  1 
1A0CE48 	58 41 A0  1 FF FF FF FF 
1A0CE50 	1C 42 A0  1 E8 FF FF FF 
   else
1A0CE58 	C8 41 A0  1  8  0  0  0 
      2drop
1A0CE60 	AC 49 A0  1 
   then
;
1A0CE64 	58 46 A0  1 

: init-delims   ( -- )
1A0CE68 	69 6E 69 74 2D 64 65 6C 
1A0CE70 	69 6D 73 8B 18 CE A0  1 
1A0CE78 	20 40 A0  1 
   \ initialize the delimiters to the default values for the
   \ underlying operating system, in case the file is initially empty.
   newline-string  case
1A0CE7C 	8C 71 A0  1 
      1 of  c@         0        endof
1A0CE80 	80 6F A0  1 48 43 A0  1 
1A0CE88 	14  0  0  0 C4 4C A0  1 
1A0CE90 	70 6F A0  1 6C 43 A0  1 
1A0CE98 	3C  0  0  0 
      2 of  dup 1+ c@  swap c@  endof
1A0CE9C 	90 6F A0  1 
1A0CEA0 	48 43 A0  1 20  0  0  0 
1A0CEA8 	40 49 A0  1 30 4B A0  1 
1A0CEB0 	C4 4C A0  1 68 49 A0  1 
1A0CEB8 	C4 4C A0  1 6C 43 A0  1 
1A0CEC0 	14  0  0  0 
      ( default )  linefeed carret rot
1A0CEC4 	4C 6F A0  1 
1A0CEC8 	60 6F A0  1 7C 49 A0  1 
   endcase   pre-delimiter c!  line-delimiter c!
1A0CED0 	84 43 A0  1 34 AE A0  1 
1A0CED8 	B8 4D A0  1  4 AE A0  1 
1A0CEE0 	B8 4D A0  1 
;
1A0CEE4 	58 46 A0  1 

[then]

headerless
\ A version that knows about multi-segment dictionaries can be installed
\ if such dictionaries exist.
: (in-dictionary?  ( adr -- )  origin here between  ;
1A0CEE8 	28 69 6E 2D 64 69 63 74 
1A0CEF0 	69 6F 6E 61 72 79 3F 8F 
1A0CEF8 	78 CE A0  1 20 40 A0  1 
1A0CF00 	50 55 A0  1 70 54 A0  1 
1A0CF08 	D8 70 A0  1 58 46 A0  1 
headers
defer in-dictionary? ' (in-dictionary? is in-dictionary?
1A0CF10 	 0 69 6E 2D 64 69 63 74 
1A0CF18 	69 6F 6E 61 72 79 3F 8E 
1A0CF20 	FC CE A0  1 5C 40 A0  1 
1A0CF28 	80  2  0  0 

defer .error#
1A0CF2C 	2E 65 72 72 
1A0CF30 	6F 72 23 87 24 CF A0  1 
1A0CF38 	5C 40 A0  1 84  2  0  0 

: .abort  ( -- )
1A0CF40 	 0 2E 61 62 6F 72 74 86 
1A0CF48 	38 CF A0  1 20 40 A0  1 
   show-error
1A0CF50 	F8 7F A0  1 
   drop abort-message type
1A0CF54 	30 49 A0  1 
1A0CF58 	BC 80 A0  1  4 6C A0  1 
;
1A0CF60 	58 46 A0  1 


defer .error
1A0CF64 	 0 2E 65 72 
1A0CF68 	72 6F 72 86 4C CF A0  1 
1A0CF70 	5C 40 A0  1 88  2  0  0 
: (.error)  ( error# -- )
1A0CF78 	 0  0  0 28 2E 65 72 72 
1A0CF80 	6F 72 29 88 70 CF A0  1 
1A0CF88 	20 40 A0  1 
   dup  -13  =  if
1A0CF8C 	40 49 A0  1 
1A0CF90 	58 41 A0  1 F3 FF FF FF 
1A0CF98 	24 48 A0  1 DC 41 A0  1 
1A0CFA0 	1C  0  0  0 
      .abort  ."  ?"  cr
1A0CFA4 	4C CF A0  1 
1A0CFA8 	20 7C A0  1  2 20 3F  0 
1A0CFB0 	80 6D A0  1 
   else  dup  -2 =  if
1A0CFB4 	C8 41 A0  1 
1A0CFB8 	7C  0  0  0 40 49 A0  1 
1A0CFC0 	58 41 A0  1 FE FF FF FF 
1A0CFC8 	24 48 A0  1 DC 41 A0  1 
1A0CFD0 	14  0  0  0 
      .abort  cr
1A0CFD4 	4C CF A0  1 
1A0CFD8 	80 6D A0  1 
   else  dup -1 =  if
1A0CFDC 	C8 41 A0  1 
1A0CFE0 	54  0  0  0 40 49 A0  1 
1A0CFE8 	58 41 A0  1 FF FF FF FF 
1A0CFF0 	24 48 A0  1 DC 41 A0  1 
1A0CFF8 	10  0  0  0 
      drop
1A0CFFC 	30 49 A0  1 
   else
1A0D000 	C8 41 A0  1 30  0  0  0 
      show-error
1A0D008 	F8 7F A0  1 
      dup in-dictionary?  if  count type  else  .error#  then cr
1A0D00C 	40 49 A0  1 
1A0D010 	24 CF A0  1 DC 41 A0  1 
1A0D018 	14  0  0  0 BC 53 A0  1 
1A0D020 	 4 6C A0  1 C8 41 A0  1 
1A0D028 	 8  0  0  0 38 CF A0  1 
1A0D030 	80 6D A0  1 
   then
   then
   then
;
1A0D034 	58 46 A0  1 
' (.error) is .error

: guarded  ( acf -- )  catch  ?dup  if  .error  then  ;
1A0D038 	67 75 61 72 64 65 64 87 
1A0D040 	88 CF A0  1 20 40 A0  1 
1A0D048 	14 7F A0  1 B4 70 A0  1 
1A0D050 	DC 41 A0  1  8  0  0  0 
1A0D058 	70 CF A0  1 58 46 A0  1 

\ From cold.fth

\ Some hooks for multitasking
\ Main task points to the initial task.  This usage is currently not ROM-able
\ since the user area address has to be later stored in the parameter field
\ of main-task.  It could be made ROM-able by allocating the user area
\ at a fixed location and storing that address in main-task at compile time.

' noop  is pause

defer init-io    ( -- )
1A0D060 	69 6E 69 74 2D 69 6F 87 
1A0D068 	44 D0 A0  1 5C 40 A0  1 
1A0D070 	8C  2  0  0 
defer do-init    ( -- )
1A0D074 	64 6F 2D 69 
1A0D078 	6E 69 74 87 6C D0 A0  1 
1A0D080 	5C 40 A0  1 90  2  0  0 
defer cold-hook  ( -- )
1A0D088 	 0  0 63 6F 6C 64 2D 68 
1A0D090 	6F 6F 6B 89 80 D0 A0  1 
1A0D098 	5C 40 A0  1 94  2  0  0 
defer init-environment  ( -- )
1A0D0A0 	 0  0  0 69 6E 69 74 2D 
1A0D0A8 	65 6E 76 69 72 6F 6E 6D 
1A0D0B0 	65 6E 74 90 98 D0 A0  1 
1A0D0B8 	5C 40 A0  1 98  2  0  0 

[ifndef] run-time
: (cold-hook  (s -- )
1A0D0C0 	 0 28 63 6F 6C 64 2D 68 
1A0D0C8 	6F 6F 6B 8A B8 D0 A0  1 
1A0D0D0 	20 40 A0  1 
   [compile] [
1A0D0D4 	90 6D A0  1 
;
1A0D0D8 	58 46 A0  1 

' (cold-hook  is cold-hook
[then]

defer title  ' noop is title
1A0D0DC 	 0  0 74 69 
1A0D0E0 	74 6C 65 85 D0 D0 A0  1 
1A0D0E8 	5C 40 A0  1 9C  2  0  0 
defer quit
1A0D0F0 	 0  0  0 71 75 69 74 84 
1A0D0F8 	E8 D0 A0  1 5C 40 A0  1 
1A0D100 	A0  2  0  0 
[ifndef] run-time
headerless
: single  (s -- )  \ Turns off multitasking
1A0D104 	 0 73 69 6E 
1A0D108 	67 6C 65 86 FC D0 A0  1 
1A0D110 	20 40 A0  1 
   ['] noop ['] pause (is
1A0D114 	60 53 A0  1 
1A0D118 	64 4F A0  1 60 53 A0  1 
1A0D120 	B4 6D A0  1 A4 65 A0  1 
;
1A0D128 	58 46 A0  1 
headers
: warm   (s -- )  single  sp0 @ sp!  quit  ;
1A0D12C 	 0  0  0 77 
1A0D130 	61 72 6D 84 10 D1 A0  1 
1A0D138 	20 40 A0  1 10 D1 A0  1 
1A0D140 	8C 66 A0  1 5C 4C A0  1 
1A0D148 	9C 45 A0  1 FC D0 A0  1 
1A0D150 	58 46 A0  1 
[then]

[ifdef] omit-files
: read-line  ( adr len fd -- actual not-eof? error? )  3drop 0 true  ;
: .file-open-error  ( -- )  ;
[else]
\ From disk.fth

\ High level interface to disk files.

headerless

\ If the underlying operating system requires that files be accessed
\ in fixed-length records, then /fbuf must be a multiple of that length.
\ Even if the system allows arbitrary length file accesses, there is probably
\ a length that is particularly efficient, and /fbuf should be a multiple
\ of that length for best performance.  1K works well for many systems.

td 1024 constant /fbuf
1A0D154 	 0  0 2F 66 
1A0D158 	62 75 66 85 38 D1 A0  1 
1A0D160 	68 40 A0  1  0  4  0  0 

headerless

\ An implementation factor which gets a file descriptor and attaches a
\ file buffer to it
headerless
: get-fd  ( -- )
1A0D168 	 0 67 65 74 2D 66 64 86 
1A0D170 	60 D1 A0  1 20 40 A0  1 
   (get-fd  dup 0= ( ?? ) abort" all fds used "  ( fd )
1A0D178 	88 CD A0  1 40 49 A0  1 
1A0D180 	24 47 A0  1  8 81 A0  1 
1A0D188 	 D 61 6C 6C 20 66 64 73 
1A0D190 	20 75 73 65 64 20  0  0 
   file !
1A0D198 	84 AB A0  1 54 4D A0  1 
   /fbuf alloc-mem  /fbuf initbuf     ( )
1A0D1A0 	60 D1 A0  1 F0 6C A0  1 
1A0D1A8 	60 D1 A0  1 F4 CA A0  1 
;
1A0D1B0 	58 46 A0  1 
headers
\ Amount of space needed:
\   #fds * /fd     for automatically allocated file descriptors
\   1 * /fd        for "accept" descriptor
\   tib            for "accept" buffer
\
\ #fds = 8, so total of 9 * /fd  = 9 * 56 = 486 for fds
\ 8 * 1024 +  3 * 128  +  tib
\ Total is ~9K

\ Updates the disk copy of the file to match the buffer
headerless
: fflush  ( fd -- )  file @ >r  file !  ?flushbuf  r> file !  ;
1A0D1B4 	 0 66 66 6C 
1A0D1B8 	75 73 68 86 74 D1 A0  1 
1A0D1C0 	20 40 A0  1 84 AB A0  1 
1A0D1C8 	5C 4C A0  1 BC 45 A0  1 
1A0D1D0 	84 AB A0  1 54 4D A0  1 
1A0D1D8 	EC AE A0  1 D0 45 A0  1 
1A0D1E0 	84 AB A0  1 54 4D A0  1 
1A0D1E8 	58 46 A0  1 
headers
\ Starting here, some stuff doesn't have to be in the kernel

\ Sets the position within the current file to "d.byte#".
: dfseek  ( d.byte# fd -- )
1A0D1EC 	 0 64 66 73 
1A0D1F0 	65 65 6B 86 C0 D1 A0  1 
1A0D1F8 	20 40 A0  1 
   file @ >r  file !
1A0D1FC 	84 AB A0  1 
1A0D200 	5C 4C A0  1 BC 45 A0  1 
1A0D208 	84 AB A0  1 54 4D A0  1 
   sync
1A0D210 	A8 AE A0  1 

   \ See if the desired byte is in the buffer
   \ The byte is in the buffer iff offset.high is 0 and offset.low
   \ is less than the number of bytes in the buffer
   2dup fstart 2@ d-                   ( d.byte# offset.low offset.high )
1A0D214 	C0 49 A0  1 
1A0D218 	98 AC A0  1 CC 4D A0  1 
1A0D220 	F8 5D A0  1 
   over bfend @ bfbase @ -  u>= or  if ( d.byte# offset )
1A0D224 	54 49 A0  1 
1A0D228 	 4 AC A0  1 5C 4C A0  1 
1A0D230 	98 AB A0  1 5C 4C A0  1 
1A0D238 	18 45 A0  1 CC 48 A0  1 
1A0D240 	70 44 A0  1 DC 41 A0  1 
1A0D248 	60  0  0  0 
      \ Not in buffer
      \ Flush the buffer and get the one containing the desired byte.
      drop ?flushbuf                         ( d.byte# )
1A0D24C 	30 49 A0  1 
1A0D250 	EC AE A0  1 
      2dup byte#-aligned?  if                ( d.byte# )
1A0D254 	C0 49 A0  1 
1A0D258 	88 B1 A0  1 DC 41 A0  1 
1A0D260 	34  0  0  0 
         \ If the new offset is on a block boundary, don't read yet,
         \ because the next op could be a large write that fills the buffer.
         fstart 2!                           ( )
1A0D264 	98 AC A0  1 
1A0D268 	E4 4D A0  1 
         bfbase @  dup bftop !  dup bfend !  ( bufaddr )
1A0D26C 	98 AB A0  1 
1A0D270 	5C 4C A0  1 40 49 A0  1 
1A0D278 	E0 AB A0  1 54 4D A0  1 
1A0D280 	40 49 A0  1  4 AC A0  1 
1A0D288 	54 4D A0  1 
      else
1A0D28C 	C8 41 A0  1 
1A0D290 	10  0  0  0 
         2dup fillbuf                        ( d.byte# )
1A0D294 	C0 49 A0  1 
1A0D298 	CC AF A0  1 
         >bufaddr                            ( bufaddr )
1A0D29C 	8C B0 A0  1 
      then                                   ( bufaddr )
   else
1A0D2A0 	C8 41 A0  1 18  0  0  0 
      \ The desired byte is already in the buffer.
      nip nip  bfbase @ +           ( bufaddr )
1A0D2A8 	FC 46 A0  1 FC 46 A0  1 
1A0D2B0 	98 AB A0  1 5C 4C A0  1 
1A0D2B8 	 4 45 A0  1 
   then

   \ Seeking past end of file actually goes to the end of the file
   bftop @  umin   bfcurrent !
1A0D2BC 	E0 AB A0  1 
1A0D2C0 	5C 4C A0  1 4C 4A A0  1 
1A0D2C8 	2C AC A0  1 54 4D A0  1 
   r> file !
1A0D2D0 	D0 45 A0  1 84 AB A0  1 
1A0D2D8 	54 4D A0  1 
;
1A0D2DC 	58 46 A0  1 
: fseek  ( byte# fd -- )  0 swap dfseek  ;
1A0D2E0 	 0  0 66 73 65 65 6B 85 
1A0D2E8 	F8 D1 A0  1 20 40 A0  1 
1A0D2F0 	70 6F A0  1 68 49 A0  1 
1A0D2F8 	F8 D1 A0  1 58 46 A0  1 

\ Returns true if the current file has reached the end.
\ XXX This may only be valid after fseek or shortseek
headerless
: (feof?  ( -- f )   bfcurrent @  bftop @  u>=  ;
1A0D300 	 0 28 66 65 6F 66 3F 86 
1A0D308 	EC D2 A0  1 20 40 A0  1 
1A0D310 	2C AC A0  1 5C 4C A0  1 
1A0D318 	E0 AB A0  1 5C 4C A0  1 
1A0D320 	CC 48 A0  1 58 46 A0  1 

headers
\ Gets the next byte from the current file
: fgetc  ( fd -- byte )
1A0D328 	 0  0 66 67 65 74 63 85 
1A0D330 	 C D3 A0  1 20 40 A0  1 
   file @ >r  file !   bfcurrent @  bftop @  u<
1A0D338 	84 AB A0  1 5C 4C A0  1 
1A0D340 	BC 45 A0  1 84 AB A0  1 
1A0D348 	54 4D A0  1 2C AC A0  1 
1A0D350 	5C 4C A0  1 E0 AB A0  1 
1A0D358 	5C 4C A0  1 A8 48 A0  1 
   if   \ desired character is in the buffer
1A0D360 	DC 41 A0  1 14  0  0  0 
      bfcurrent @c@++
1A0D368 	2C AC A0  1 E8 62 A0  1 
   else \ end of buffer has been reached
1A0D370 	C8 41 A0  1 30  0  0  0 
      bfcurrent @ shortseek
1A0D378 	2C AC A0  1 5C 4C A0  1 
1A0D380 	C0 B0 A0  1 
      (feof?  if  eof  else  bfcurrent @c@++  then
1A0D384 	 C D3 A0  1 
1A0D388 	DC 41 A0  1 10  0  0  0 
1A0D390 	C4 C8 A0  1 C8 41 A0  1 
1A0D398 	 C  0  0  0 2C AC A0  1 
1A0D3A0 	E8 62 A0  1 
   then
   r> file !
1A0D3A4 	D0 45 A0  1 
1A0D3A8 	84 AB A0  1 54 4D A0  1 
;
1A0D3B0 	58 46 A0  1 


\ Copyout copies bytes from the file buffer into memory starting at current.
\ The number of bytes copied is either enough to fill memory up to end,
\ if the buffer has enough characters, or all the bytes the
\ buffer has left, if not.
\ newcurrent is left pointing to the first byte not filled.
headerless
: copyout  ( end current -- end newcurrent )
1A0D3B4 	63 6F 70 79 
1A0D3B8 	6F 75 74 87 34 D3 A0  1 
1A0D3C0 	20 40 A0  1 
   2dup -                      ( end current remaining )
1A0D3C4 	C0 49 A0  1 
1A0D3C8 	18 45 A0  1 
   bftop @  bfcurrent @  -     ( end current remaining bfrem )
1A0D3CC 	E0 AB A0  1 
1A0D3D0 	5C 4C A0  1 2C AC A0  1 
1A0D3D8 	5C 4C A0  1 18 45 A0  1 
   min                         ( end current #bytes-to-copy)
1A0D3E0 	74 4A A0  1 
   2dup bfcurrent @ rot rot    ( end current #bytes  current bfcurrent #bytes)
1A0D3E4 	C0 49 A0  1 
1A0D3E8 	2C AC A0  1 5C 4C A0  1 
1A0D3F0 	7C 49 A0  1 7C 49 A0  1 
   move                        ( end current #bytes)
1A0D3F8 	F4 4A A0  1 
   dup  bfcurrent +!           ( end current #bytes)
1A0D3FC 	40 49 A0  1 
1A0D400 	2C AC A0  1  C 4C A0  1 
   +                           ( end newcurrent )
1A0D408 	 4 45 A0  1 
;
1A0D40C 	58 46 A0  1 

\ Reads up to count characters from the file into memory starting
\ at "adr"

: fgets  ( adr count fd -- #read )
1A0D410 	 0  0 66 67 65 74 73 85 
1A0D418 	C0 D3 A0  1 20 40 A0  1 
   file @ >r  file !
1A0D420 	84 AB A0  1 5C 4C A0  1 
1A0D428 	BC 45 A0  1 84 AB A0  1 
1A0D430 	54 4D A0  1 
   sync
1A0D434 	A8 AE A0  1 
   over + over  ( startaddr endaddr startaddr )
1A0D438 	54 49 A0  1  4 45 A0  1 
1A0D440 	54 49 A0  1 
   begin  copyout  2dup u>
1A0D444 	C0 D3 A0  1 
1A0D448 	C0 49 A0  1 64 48 A0  1 
   while
1A0D450 	DC 41 A0  1 40  0  0  0 
      \ Here there should be some code to see if there are enough remaining
      \ bytes in the request to justify bypassing the file buffer and reading
      \ directly to the user's buffer.  'Enough' = more than one file buffer
      bfcurrent @ shortseek ( startaddr endaddr curraddr )
1A0D458 	2C AC A0  1 5C 4C A0  1 
1A0D460 	C0 B0 A0  1 
      (feof?  if  nip swap -  r> file !  exit then
1A0D464 	 C D3 A0  1 
1A0D468 	DC 41 A0  1 20  0  0  0 
1A0D470 	FC 46 A0  1 68 49 A0  1 
1A0D478 	18 45 A0  1 D0 45 A0  1 
1A0D480 	84 AB A0  1 54 4D A0  1 
1A0D488 	40 46 A0  1 
   repeat
1A0D48C 	C8 41 A0  1 
1A0D490 	B4 FF FF FF 
   nip swap -
1A0D494 	FC 46 A0  1 
1A0D498 	68 49 A0  1 18 45 A0  1 
   r> file !
1A0D4A0 	D0 45 A0  1 84 AB A0  1 
1A0D4A8 	54 4D A0  1 
;
1A0D4AC 	58 46 A0  1 

\ Returns the current length of the file
: dfsize  ( fd -- d.size )
1A0D4B0 	 0 64 66 73 69 7A 65 86 
1A0D4B8 	1C D4 A0  1 20 40 A0  1 
   file @ >r  file !
1A0D4C0 	84 AB A0  1 5C 4C A0  1 
1A0D4C8 	BC 45 A0  1 84 AB A0  1 
1A0D4D0 	54 4D A0  1 
   sync
1A0D4D4 	A8 AE A0  1 
   fstart 2@  bftop @  bfbase @  -  0 d+  ( buffered-position )
1A0D4D8 	98 AC A0  1 CC 4D A0  1 
1A0D4E0 	E0 AB A0  1 5C 4C A0  1 
1A0D4E8 	98 AB A0  1 5C 4C A0  1 
1A0D4F0 	18 45 A0  1 70 6F A0  1 
1A0D4F8 	E0 5D A0  1 
   fid @  sizeop @  execute               ( buffered-position file-size )
1A0D4FC 	B8 AC A0  1 
1A0D500 	5C 4C A0  1 A8 AD A0  1 
1A0D508 	5C 4C A0  1 98 41 A0  1 
   dmax
1A0D510 	68 69 A0  1 
   r> file !
1A0D514 	D0 45 A0  1 
1A0D518 	84 AB A0  1 54 4D A0  1 
;
1A0D520 	58 46 A0  1 
: fsize  ( fd -- size )  dfsize drop  ;
1A0D524 	 0  0 66 73 
1A0D528 	69 7A 65 85 BC D4 A0  1 
1A0D530 	20 40 A0  1 BC D4 A0  1 
1A0D538 	30 49 A0  1 58 46 A0  1 


\ End of stuff that doesn't have to be in the kernel

defer do-fopen
1A0D540 	 0  0  0 64 6F 2D 66 6F 
1A0D548 	70 65 6E 88 30 D5 A0  1 
1A0D550 	5C 40 A0  1 A4  2  0  0 

\ Prepares a file for later access, returning "fd" which is subsequently
\ used to refer to the file.

: fopen  ( name mode -- fd )
1A0D558 	 0  0 66 6F 70 65 6E 85 
1A0D560 	50 D5 A0  1 20 40 A0  1 
   2 ?enough
1A0D568 	90 6F A0  1 48 8E A0  1 
   get-fd   ( name mode )  over >r  ( name mode )
1A0D570 	74 D1 A0  1 54 49 A0  1 
1A0D578 	BC 45 A0  1 
   dup fmode !          \ Make descriptor busy now, in case of re-entry
1A0D57C 	40 49 A0  1 
1A0D580 	74 AC A0  1 54 4D A0  1 
   do-fopen  if
1A0D588 	50 D5 A0  1 DC 41 A0  1 
1A0D590 	24  0  0  0 
      setupfd  file @  r> count set-name
1A0D594 	64 C9 A0  1 
1A0D598 	84 AB A0  1 5C 4C A0  1 
1A0D5A0 	D0 45 A0  1 BC 53 A0  1 
1A0D5A8 	 4 C9 A0  1 
   else
1A0D5AC 	C8 41 A0  1 
1A0D5B0 	1C  0  0  0 
      not-open fmode !  0  r> drop
1A0D5B4 	D4 C9 A0  1 
1A0D5B8 	74 AC A0  1 54 4D A0  1 
1A0D5C0 	70 6F A0  1 D0 45 A0  1 
1A0D5C8 	30 49 A0  1 
   then
;
1A0D5CC 	58 46 A0  1 

headers

\ Closes all the open files and reclaims their file descriptors.
\ Use this if you see an "all fds used" message.

: close-files ( -- )  fds @  /fds  bounds   do   i fclose   /fd +loop  ;
1A0D5D0 	63 6C 6F 73 65 2D 66 69 
1A0D5D8 	6C 65 73 8B 64 D5 A0  1 
1A0D5E0 	20 40 A0  1 10 CD A0  1 
1A0D5E8 	5C 4C A0  1  0 CD A0  1 
1A0D5F0 	F0 6D A0  1 88 42 A0  1 
1A0D5F8 	18  0  0  0 B4 42 A0  1 
1A0D600 	5C CC A0  1 EC C8 A0  1 
1A0D608 	1C 42 A0  1 F0 FF FF FF 
1A0D610 	58 46 A0  1 


\ From readline.fth

headers
0 constant r/o
1A0D614 	72 2F 6F 83 
1A0D618 	E0 D5 A0  1 68 40 A0  1 
1A0D620 	 0  0  0  0 
1 constant w/o
1A0D624 	77 2F 6F 83 
1A0D628 	1C D6 A0  1 68 40 A0  1 
1A0D630 	 1  0  0  0 
2 constant r/w
1A0D634 	72 2F 77 83 
1A0D638 	2C D6 A0  1 68 40 A0  1 
1A0D640 	 2  0  0  0 
4 constant bin
1A0D644 	62 69 6E 83 
1A0D648 	3C D6 A0  1 68 40 A0  1 
1A0D650 	 4  0  0  0 
8 constant create-flag
1A0D654 	63 72 65 61 
1A0D658 	74 65 2D 66 6C 61 67 8B 
1A0D660 	4C D6 A0  1 68 40 A0  1 
1A0D668 	 8  0  0  0 

headerless
2 /n-t * ualloc-t user opened-filename
1A0D66C 	6F 70 65 6E 
1A0D670 	65 64 2D 66 69 6C 65 6E 
1A0D678 	61 6D 65 8F 64 D6 A0  1 
1A0D680 	48 40 A0  1 A8  2  0  0 
headers


: .file-open-error  ( -- )
1A0D688 	 0  0  0 2E 66 69 6C 65 
1A0D690 	2D 6F 70 65 6E 2D 65 72 
1A0D698 	72 6F 72 90 80 D6 A0  1 
1A0D6A0 	20 40 A0  1 
   ." The file '"  opened-filename 2@ type  ." ' cannot be opened."
1A0D6A4 	20 7C A0  1 
1A0D6A8 	 A 54 68 65 20 66 69 6C 
1A0D6B0 	65 20 27  0 80 D6 A0  1 
1A0D6B8 	CC 4D A0  1  4 6C A0  1 
1A0D6C0 	20 7C A0  1 13 27 20 63 
1A0D6C8 	61 6E 6E 6F 74 20 62 65 
1A0D6D0 	20 6F 70 65 6E 65 64 2E 
1A0D6D8 	 0  0  0  0 
;
1A0D6DC 	58 46 A0  1 

: (.error#)  ( error# -- )
1A0D6E0 	 0  0 28 2E 65 72 72 6F 
1A0D6E8 	72 23 29 89 A0 D6 A0  1 
1A0D6F0 	20 40 A0  1 
   dup d# -38  =  if  .file-open-error  else  ." Error " .  then
1A0D6F4 	40 49 A0  1 
1A0D6F8 	58 41 A0  1 DA FF FF FF 
1A0D700 	24 48 A0  1 DC 41 A0  1 
1A0D708 	10  0  0  0 A0 D6 A0  1 
1A0D710 	C8 41 A0  1 14  0  0  0 
1A0D718 	20 7C A0  1  6 45 72 72 
1A0D720 	6F 72 20  0 94 7A A0  1 
;
1A0D728 	58 46 A0  1 

' (.error#) is .error#


: left-parse-string  ( adr len delim -- tail$ head$ )
1A0D72C 	 0  0 6C 65 
1A0D730 	66 74 2D 70 61 72 73 65 
1A0D738 	2D 73 74 72 69 6E 67 91 
1A0D740 	F0 D6 A0  1 20 40 A0  1 
   split-string  dup if  1 /string  then  2swap
1A0D748 	3C 64 A0  1 40 49 A0  1 
1A0D750 	DC 41 A0  1  C  0  0  0 
1A0D758 	80 6F A0  1 3C 85 A0  1 
1A0D760 	F4 49 A0  1 
;
1A0D764 	58 46 A0  1 

headerless
: remaining$  ( -- adr len )  bfcurrent @  bftop @ over -  ;
1A0D768 	 0 72 65 6D 61 69 6E 69 
1A0D770 	6E 67 24 8A 44 D7 A0  1 
1A0D778 	20 40 A0  1 2C AC A0  1 
1A0D780 	5C 4C A0  1 E0 AB A0  1 
1A0D788 	5C 4C A0  1 54 49 A0  1 
1A0D790 	18 45 A0  1 58 46 A0  1 

: $set-line-delimiter  ( adr len -- )
1A0D798 	24 73 65 74 2D 6C 69 6E 
1A0D7A0 	65 2D 64 65 6C 69 6D 69 
1A0D7A8 	74 65 72 93 78 D7 A0  1 
1A0D7B0 	20 40 A0  1 
   carret split-string  dup  if           ( head-adr,len tail-adr,len )
1A0D7B4 	60 6F A0  1 
1A0D7B8 	3C 64 A0  1 40 49 A0  1 
1A0D7C0 	DC 41 A0  1 5C  0  0  0 
      carret line-delimiter c!            ( head-adr,len tail-adr,len )
1A0D7C8 	60 6F A0  1  4 AE A0  1 
1A0D7D0 	B8 4D A0  1 
      1 >  if                             ( head-adr,len tail-adr )
1A0D7D4 	80 6F A0  1 
1A0D7D8 	 4 48 A0  1 DC 41 A0  1 
1A0D7E0 	38  0  0  0 
         dup 1+ c@ linefeed  =  if        ( head-adr,len tail-adr )
1A0D7E4 	40 49 A0  1 
1A0D7E8 	30 4B A0  1 C4 4C A0  1 
1A0D7F0 	4C 6F A0  1 24 48 A0  1 
1A0D7F8 	DC 41 A0  1 1C  0  0  0 
            carret pre-delimiter c!       ( head-adr,len tail-adr )
1A0D800 	60 6F A0  1 34 AE A0  1 
1A0D808 	B8 4D A0  1 
            linefeed line-delimiter c!    ( head-adr,len tail-adr )
1A0D80C 	4C 6F A0  1 
1A0D810 	 4 AE A0  1 B8 4D A0  1 
         then                             ( head-adr,len tail-adr )
      then                                ( head-adr,len tail-adr )
   else                                   ( adr,len tail-adr,0 )
1A0D818 	C8 41 A0  1 30  0  0  0 
      2drop  linefeed split-string  if    ( head-adr,len tail-adr )
1A0D820 	AC 49 A0  1 4C 6F A0  1 
1A0D828 	3C 64 A0  1 DC 41 A0  1 
1A0D830 	1C  0  0  0 
         0 pre-delimiter c!               ( head-adr,len tail-adr )
1A0D834 	70 6F A0  1 
1A0D838 	34 AE A0  1 B8 4D A0  1 
         linefeed line-delimiter c!       ( head-adr,len tail-adr )
1A0D840 	4C 6F A0  1  4 AE A0  1 
1A0D848 	B8 4D A0  1 
      then                                ( head-adr,len tail-adr )
   then                                   ( head-adr,len tail-adr )
   3drop                                  ( )
1A0D84C 	90 52 A0  1 
;
1A0D850 	58 46 A0  1 
: set-line-delimiter  ( fd -- )
1A0D854 	 0 73 65 74 
1A0D858 	2D 6C 69 6E 65 2D 64 65 
1A0D860 	6C 69 6D 69 74 65 72 92 
1A0D868 	B0 D7 A0  1 20 40 A0  1 
   file @ >r  file !  0 0 fillbuf  remaining$  $set-line-delimiter  r> file !
1A0D870 	84 AB A0  1 5C 4C A0  1 
1A0D878 	BC 45 A0  1 84 AB A0  1 
1A0D880 	54 4D A0  1 70 6F A0  1 
1A0D888 	70 6F A0  1 CC AF A0  1 
1A0D890 	78 D7 A0  1 B0 D7 A0  1 
1A0D898 	D0 45 A0  1 84 AB A0  1 
1A0D8A0 	54 4D A0  1 
;
1A0D8A4 	58 46 A0  1 

0 value cstrbuf		\ Initialized in
1A0D8A8 	63 73 74 72 62 75 66 87 
1A0D8B0 	6C D8 A0  1 50 40 A0  1 
1A0D8B8 	B0  2  0  0 

: open-file  ( adr len mode -- fd ior )
1A0D8BC 	 0  0 6F 70 
1A0D8C0 	65 6E 2D 66 69 6C 65 89 
1A0D8C8 	B4 D8 A0  1 20 40 A0  1 
   file @ >r		\ Guard against re-entrancy
1A0D8D0 	84 AB A0  1 5C 4C A0  1 
1A0D8D8 	BC 45 A0  1 

   >r 2dup opened-filename 2! cstrbuf pack r@ fopen   ( fd )  ( r: mode )
1A0D8DC 	BC 45 A0  1 
1A0D8E0 	C0 49 A0  1 80 D6 A0  1 
1A0D8E8 	E4 4D A0  1 B4 D8 A0  1 
1A0D8F0 	DC 52 A0  1 E4 45 A0  1 
1A0D8F8 	64 D5 A0  1 

   \ Bail out now if the open failed
   dup  0=  if  d# -38  r> drop  r> file !  exit  then
1A0D8FC 	40 49 A0  1 
1A0D900 	24 47 A0  1 DC 41 A0  1 
1A0D908 	24  0  0  0 58 41 A0  1 
1A0D910 	DA FF FF FF D0 45 A0  1 
1A0D918 	30 49 A0  1 D0 45 A0  1 
1A0D920 	84 AB A0  1 54 4D A0  1 
1A0D928 	40 46 A0  1 

   \ First initialize the delimiters to the default values for the
   \ underlying operating system, in case the file is initially empty.
   init-delims
1A0D92C 	78 CE A0  1 

   \ If the mode is neither "w/o" nor "binary", and the file isn't
   \ being newly created, establish the line delimiter(s) by looking
   \ for the first carriage return or line feed

   dup  r@ bin create-flag or  and 0=  and  r> w/o <> and  if
1A0D930 	40 49 A0  1 E4 45 A0  1 
1A0D938 	4C D6 A0  1 64 D6 A0  1 
1A0D940 	70 44 A0  1 5C 44 A0  1 
1A0D948 	24 47 A0  1 5C 44 A0  1 
1A0D950 	D0 45 A0  1 2C D6 A0  1 
1A0D958 	44 48 A0  1 5C 44 A0  1 
1A0D960 	DC 41 A0  1  C  0  0  0 
      dup set-line-delimiter
1A0D968 	40 49 A0  1 6C D8 A0  1 
   then                                           ( fd )
   0                                              ( fd ior )
1A0D970 	70 6F A0  1 
   r> file !
1A0D974 	D0 45 A0  1 
1A0D978 	84 AB A0  1 54 4D A0  1 
;
1A0D980 	58 46 A0  1 

: create-file  ( name$ mode -- fileid ior )  8 or  open-file  ;
1A0D984 	63 72 65 61 
1A0D988 	74 65 2D 66 69 6C 65 8B 
1A0D990 	CC D8 A0  1 20 40 A0  1 
1A0D998 	F0 6F A0  1 70 44 A0  1 
1A0D9A0 	CC D8 A0  1 58 46 A0  1 

: make  ( name-pstr -- flag )	\ Creates an empty file
1A0D9A8 	 0  0  0 6D 61 6B 65 84 
1A0D9B0 	94 D9 A0  1 20 40 A0  1 
   count  r/w  create-file  if  drop false  else  close-file drop true  then
1A0D9B8 	BC 53 A0  1 3C D6 A0  1 
1A0D9C0 	94 D9 A0  1 DC 41 A0  1 
1A0D9C8 	14  0  0  0 30 49 A0  1 
1A0D9D0 	18 70 A0  1 C8 41 A0  1 
1A0D9D8 	10  0  0  0 D0 CC A0  1 
1A0D9E0 	30 49 A0  1  4 70 A0  1 
;
1A0D9E8 	58 46 A0  1 

: close-file  ( fd -- ior )
1A0D9EC 	 0 63 6C 6F 
1A0D9F0 	73 65 2D 66 69 6C 65 8A 
1A0D9F8 	B4 D9 A0  1 20 40 A0  1 
   ?dup  0=  if  0  exit  then
1A0DA00 	B4 70 A0  1 24 47 A0  1 
1A0DA08 	DC 41 A0  1  C  0  0  0 
1A0DA10 	70 6F A0  1 40 46 A0  1 
   dup -1 =  if  drop 0  exit  then
1A0DA18 	40 49 A0  1 58 41 A0  1 
1A0DA20 	FF FF FF FF 24 48 A0  1 
1A0DA28 	DC 41 A0  1 10  0  0  0 
1A0DA30 	30 49 A0  1 70 6F A0  1 
1A0DA38 	40 46 A0  1 
   ['] fclose catch  ?dup  if  nip  else  0  then
1A0DA3C 	60 53 A0  1 
1A0DA40 	5C CC A0  1 14 7F A0  1 
1A0DA48 	B4 70 A0  1 DC 41 A0  1 
1A0DA50 	10  0  0  0 FC 46 A0  1 
1A0DA58 	C8 41 A0  1  8  0  0  0 
1A0DA60 	70 6F A0  1 
;
1A0DA64 	58 46 A0  1 

: -pre-delimiter  ( adr len -- adr' len' )
1A0DA68 	 0 2D 70 72 65 2D 64 65 
1A0DA70 	6C 69 6D 69 74 65 72 8E 
1A0DA78 	FC D9 A0  1 20 40 A0  1 
   pre-delimiter c@  if
1A0DA80 	34 AE A0  1 C4 4C A0  1 
1A0DA88 	DC 41 A0  1 38  0  0  0 
      dup  if
1A0DA90 	40 49 A0  1 DC 41 A0  1 
1A0DA98 	2C  0  0  0 
         2dup + 1- c@  pre-delimiter c@  =  if
1A0DA9C 	C0 49 A0  1 
1A0DAA0 	 4 45 A0  1 54 4B A0  1 
1A0DAA8 	C4 4C A0  1 34 AE A0  1 
1A0DAB0 	C4 4C A0  1 24 48 A0  1 
1A0DAB8 	DC 41 A0  1  8  0  0  0 
            1-
1A0DAC0 	54 4B A0  1 
         then
      then
   then
;
1A0DAC4 	58 46 A0  1 

: parse-line-piece  ( adr len #so-far -- actual retry? )
1A0DAC8 	 0  0  0 70 61 72 73 65 
1A0DAD0 	2D 6C 69 6E 65 2D 70 69 
1A0DAD8 	65 63 65 90 7C DA A0  1 
1A0DAE0 	20 40 A0  1 
   >r  2>r  ( r: #so-far adr len )
1A0DAE4 	BC 45 A0  1 
1A0DAE8 	F8 45 A0  1 

   remaining$                          ( fbuf$ )
1A0DAEC 	78 D7 A0  1 
   line-delimiter c@ split-string      ( head$ tail$ )  ( r: # adr len )
1A0DAF0 	 4 AE A0  1 C4 4C A0  1 
1A0DAF8 	3C 64 A0  1 

   2swap -pre-delimiter                ( tail$ head$')  ( r: # adr len )
1A0DAFC 	F4 49 A0  1 
1A0DB00 	7C DA A0  1 

   dup r@  u>=  if                     ( tail$ head$ )  ( r: # adr len )
1A0DB04 	40 49 A0  1 
1A0DB08 	E4 45 A0  1 CC 48 A0  1 
1A0DB10 	DC 41 A0  1 44  0  0  0 
      \ The parsed line doesn't fit into the buffer, so we consume
      \ from the file buffer only the portion that we copy into the
      \ buffer.
      over r@ +  bfcurrent !           ( tail$ head$ )
1A0DB18 	54 49 A0  1 E4 45 A0  1 
1A0DB20 	 4 45 A0  1 2C AC A0  1 
1A0DB28 	54 4D A0  1 
      drop nip nip                     ( head-adr )  ( r: # adr len )
1A0DB2C 	30 49 A0  1 
1A0DB30 	FC 46 A0  1 FC 46 A0  1 
      2r> dup >r  move                 ( )           ( r: # len )
1A0DB38 	10 46 A0  1 40 49 A0  1 
1A0DB40 	BC 45 A0  1 F4 4A A0  1 
      2r> + false                      ( actual don't-retry )
1A0DB48 	10 46 A0  1  4 45 A0  1 
1A0DB50 	18 70 A0  1 
      exit
1A0DB54 	40 46 A0  1 
   then                                ( tail$ head$ )  ( r: # adr len )

   \ The parsed line fits into the buffer, so we copy it all in
   tuck  2r> drop  swap  move          ( tail$ head-len )  ( r: # )
1A0DB58 	E8 46 A0  1 10 46 A0  1 
1A0DB60 	30 49 A0  1 68 49 A0  1 
1A0DB68 	F4 4A A0  1 
   r> +  -rot                          ( actual tail$ )
1A0DB6C 	D0 45 A0  1 
1A0DB70 	 4 45 A0  1 94 49 A0  1 

   \ Consume the parsed line from the file buffer, including the
   \ delimiter if one was found (as indicated by nonzero tail-len)
   tuck  if  1+  then  bfcurrent !     ( actual tail-len )
1A0DB78 	E8 46 A0  1 DC 41 A0  1 
1A0DB80 	 8  0  0  0 30 4B A0  1 
1A0DB88 	2C AC A0  1 54 4D A0  1 

   \ If a delimiter was found, increment the line number the next time.
   dup if  1 (file-line) +!  then
1A0DB90 	40 49 A0  1 DC 41 A0  1 
1A0DB98 	10  0  0  0 80 6F A0  1 
1A0DBA0 	D4 AD A0  1  C 4C A0  1 

   \ If a delimiter was found, we need not retry.
   0=                                  ( actual retry? )
1A0DBA8 	24 47 A0  1 
;
1A0DBAC 	58 46 A0  1 

headers
: read-line  ( adr len fd -- actual not-eof? error? )
1A0DBB0 	 0  0 72 65 61 64 2D 6C 
1A0DBB8 	69 6E 65 89 E0 DA A0  1 
1A0DBC0 	20 40 A0  1 
   file @ >r  file !
1A0DBC4 	84 AB A0  1 
1A0DBC8 	5C 4C A0  1 BC 45 A0  1 
1A0DBD0 	84 AB A0  1 54 4D A0  1 
   0
1A0DBD8 	70 6F A0  1 
   begin  >r 2dup r>  parse-line-piece  while   ( adr len actual )
1A0DBDC 	BC 45 A0  1 
1A0DBE0 	C0 49 A0  1 D0 45 A0  1 
1A0DBE8 	E0 DA A0  1 DC 41 A0  1 
1A0DBF0 	98  0  0  0 

      \ The end of the file buffer was reached without filling the
      \ argument buffer, so we refill the file buffer and try again.

      bftop @  ['] shortseek catch  ?dup  if  ( adr len actual x error-code )
1A0DBF4 	E0 AB A0  1 
1A0DBF8 	5C 4C A0  1 60 53 A0  1 
1A0DC00 	C0 B0 A0  1 14 7F A0  1 
1A0DC08 	B4 70 A0  1 DC 41 A0  1 
1A0DC10 	28  0  0  0 
         \ A file read error (more serious than end-of-file) occurred
         drop 2swap 2drop  false swap         ( actual false ior )
1A0DC14 	30 49 A0  1 
1A0DC18 	F4 49 A0  1 AC 49 A0  1 
1A0DC20 	18 70 A0  1 68 49 A0  1 
	 r> file !  exit
1A0DC28 	D0 45 A0  1 84 AB A0  1 
1A0DC30 	54 4D A0  1 40 46 A0  1 
      then                                    ( adr len actual )
      remaining$  nip 0=  if                  ( adr len actual )
1A0DC38 	78 D7 A0  1 FC 46 A0  1 
1A0DC40 	24 47 A0  1 DC 41 A0  1 
1A0DC48 	28  0  0  0 

         \ Shortseek did not put any more characters into the file buffer,
         \ so we return the number of characters that were copied into the
	 \ argument buffer before shortseek was called and a flag.
         \ If no characters were copied into the argument buffer, the
         \ flag is false, indicating end-of-file

         nip  nip  dup 0<>  0                ( #copied not-eof? 0 )
1A0DC4C 	FC 46 A0  1 
1A0DC50 	FC 46 A0  1 40 49 A0  1 
1A0DC58 	44 47 A0  1 70 6F A0  1 
         r> file !  exit
1A0DC60 	D0 45 A0  1 84 AB A0  1 
1A0DC68 	54 4D A0  1 40 46 A0  1 
      then                                   ( adr len #copied )
      \ There are more characters in the file buffer, so we update
      \ adr len to reflect the portion of the buffer that has
      \ already been filled.
      dup >r /string r>                     ( adr' len' actual' )
1A0DC70 	40 49 A0  1 BC 45 A0  1 
1A0DC78 	3C 85 A0  1 D0 45 A0  1 
   repeat                                   ( adr len actual )
1A0DC80 	C8 41 A0  1 58 FF FF FF 
   nip nip true 0                           ( actual true 0 )
1A0DC88 	FC 46 A0  1 FC 46 A0  1 
1A0DC90 	 4 70 A0  1 70 6F A0  1 
   r> file !
1A0DC98 	D0 45 A0  1 84 AB A0  1 
1A0DCA0 	54 4D A0  1 
;
1A0DCA4 	58 46 A0  1 
\ Some more ANS Forth versions of file operations
: reposition-file  ( d.position fd -- ior )
1A0DCA8 	72 65 70 6F 73 69 74 69 
1A0DCB0 	6F 6E 2D 66 69 6C 65 8F 
1A0DCB8 	C0 DB A0  1 20 40 A0  1 
   ['] dfseek catch  dup  if  nip nip nip  then
1A0DCC0 	60 53 A0  1 F8 D1 A0  1 
1A0DCC8 	14 7F A0  1 40 49 A0  1 
1A0DCD0 	DC 41 A0  1 10  0  0  0 
1A0DCD8 	FC 46 A0  1 FC 46 A0  1 
1A0DCE0 	FC 46 A0  1 
;
1A0DCE4 	58 46 A0  1 
: file-size  ( fd -- d.size ior )
1A0DCE8 	 0  0 66 69 6C 65 2D 73 
1A0DCF0 	69 7A 65 89 BC DC A0  1 
1A0DCF8 	20 40 A0  1 
   ['] dfsize catch  dup if  0 0 rot  then
1A0DCFC 	60 53 A0  1 
1A0DD00 	BC D4 A0  1 14 7F A0  1 
1A0DD08 	40 49 A0  1 DC 41 A0  1 
1A0DD10 	10  0  0  0 70 6F A0  1 
1A0DD18 	70 6F A0  1 7C 49 A0  1 
;
1A0DD20 	58 46 A0  1 
: read-file  ( adr len fd -- actual ior )
1A0DD24 	 0  0 72 65 
1A0DD28 	61 64 2D 66 69 6C 65 89 
1A0DD30 	F8 DC A0  1 20 40 A0  1 
   ['] fgets catch  dup  if  >r 3drop 0 r>  then
1A0DD38 	60 53 A0  1 1C D4 A0  1 
1A0DD40 	14 7F A0  1 40 49 A0  1 
1A0DD48 	DC 41 A0  1 14  0  0  0 
1A0DD50 	BC 45 A0  1 90 52 A0  1 
1A0DD58 	70 6F A0  1 D0 45 A0  1 
;
1A0DD60 	58 46 A0  1 
: write-file  ( adr len fd -- actual ior )
1A0DD64 	 0 77 72 69 
1A0DD68 	74 65 2D 66 69 6C 65 8A 
1A0DD70 	34 DD A0  1 20 40 A0  1 
   over >r  ['] fputs catch  dup  if   ( x x x ior )  ( r: len )
1A0DD78 	54 49 A0  1 BC 45 A0  1 
1A0DD80 	60 53 A0  1  8 B3 A0  1 
1A0DD88 	14 7F A0  1 40 49 A0  1 
1A0DD90 	DC 41 A0  1 24  0  0  0 
      r> drop  >r 3drop 0 r>           ( 0 ior )
1A0DD98 	D0 45 A0  1 30 49 A0  1 
1A0DDA0 	BC 45 A0  1 90 52 A0  1 
1A0DDA8 	70 6F A0  1 D0 45 A0  1 
   else                                ( ior )        ( r: len )
1A0DDB0 	C8 41 A0  1  C  0  0  0 
      r> swap                          ( len ior )
1A0DDB8 	D0 45 A0  1 68 49 A0  1 
   then                                ( actual ior )
;
1A0DDC0 	58 46 A0  1 
: flush-file  ( fd -- ior )  ['] fflush  catch  dup  if  nip  then  ;
1A0DDC4 	 0 66 6C 75 
1A0DDC8 	73 68 2D 66 69 6C 65 8A 
1A0DDD0 	74 DD A0  1 20 40 A0  1 
1A0DDD8 	60 53 A0  1 C0 D1 A0  1 
1A0DDE0 	14 7F A0  1 40 49 A0  1 
1A0DDE8 	DC 41 A0  1  8  0  0  0 
1A0DDF0 	FC 46 A0  1 58 46 A0  1 
: write-line  ( adr len fd -- ior )
1A0DDF8 	 0 77 72 69 74 65 2D 6C 
1A0DE00 	69 6E 65 8A D4 DD A0  1 
1A0DE08 	20 40 A0  1 
   dup >r ['] fputs catch  ?dup  if  nip nip nip  r> drop exit  then  ( )
1A0DE0C 	40 49 A0  1 
1A0DE10 	BC 45 A0  1 60 53 A0  1 
1A0DE18 	 8 B3 A0  1 14 7F A0  1 
1A0DE20 	B4 70 A0  1 DC 41 A0  1 
1A0DE28 	1C  0  0  0 FC 46 A0  1 
1A0DE30 	FC 46 A0  1 FC 46 A0  1 
1A0DE38 	D0 45 A0  1 30 49 A0  1 
1A0DE40 	40 46 A0  1 
   pre-delimiter c@  if
1A0DE44 	34 AE A0  1 
1A0DE48 	C4 4C A0  1 DC 41 A0  1 
1A0DE50 	3C  0  0  0 
      pre-delimiter c@  r@  ['] fputc catch  ?dup  if  ( x x ior )
1A0DE54 	34 AE A0  1 
1A0DE58 	C4 4C A0  1 E4 45 A0  1 
1A0DE60 	60 53 A0  1 9C B2 A0  1 
1A0DE68 	14 7F A0  1 B4 70 A0  1 
1A0DE70 	DC 41 A0  1 18  0  0  0 
         nip nip  r> drop exit
1A0DE78 	FC 46 A0  1 FC 46 A0  1 
1A0DE80 	D0 45 A0  1 30 49 A0  1 
1A0DE88 	40 46 A0  1 
      then                                             ( )
   then
   line-delimiter c@  r>  ['] fputc catch  dup  if     ( x x ior )
1A0DE8C 	 4 AE A0  1 
1A0DE90 	C4 4C A0  1 D0 45 A0  1 
1A0DE98 	60 53 A0  1 9C B2 A0  1 
1A0DEA0 	14 7F A0  1 40 49 A0  1 
1A0DEA8 	DC 41 A0  1 10  0  0  0 
      nip nip exit
1A0DEB0 	FC 46 A0  1 FC 46 A0  1 
1A0DEB8 	40 46 A0  1 
   then                                                ( ior )
;
1A0DEBC 	58 46 A0  1 
\ Missing: file-status, create-file, delete-file, resize-file, rename-file
[then]

\ From cstrings.fth

\ Conversion between Forth-style strings and C-style null-terminated strings.
\ cstrlen and cscount are defined in cmdline.fth

decimal

headerless
: init  ( -- )  init  102 alloc-mem is cstrbuf  ;
1A0DEC0 	 0  0  0 69 6E 69 74 84 
1A0DEC8 	 8 DE A0  1 20 40 A0  1 
1A0DED0 	24 CD A0  1 58 41 A0  1 
1A0DED8 	66  0  0  0 F0 6C A0  1 
1A0DEE0 	B8 65 A0  1 B4 D8 A0  1 
1A0DEE8 	58 46 A0  1 

headers
\ Convert an unpacked string to a C string
: $cstr  ( adr len -- c-string-adr )
1A0DEEC 	 0  0 24 63 
1A0DEF0 	73 74 72 85 CC DE A0  1 
1A0DEF8 	20 40 A0  1 
   \ If, as is usually the case, there is already a null byte at the end,
   \ we can avoid the copy.
   2dup +  c@  0=  if  drop exit  then
1A0DEFC 	C0 49 A0  1 
1A0DF00 	 4 45 A0  1 C4 4C A0  1 
1A0DF08 	24 47 A0  1 DC 41 A0  1 
1A0DF10 	 C  0  0  0 30 49 A0  1 
1A0DF18 	40 46 A0  1 
   >r   cstrbuf r@  cmove  0 cstrbuf r> + c!  cstrbuf
1A0DF1C 	BC 45 A0  1 
1A0DF20 	B4 D8 A0  1 E4 45 A0  1 
1A0DF28 	10 44 A0  1 70 6F A0  1 
1A0DF30 	B4 D8 A0  1 D0 45 A0  1 
1A0DF38 	 4 45 A0  1 B8 4D A0  1 
1A0DF40 	B4 D8 A0  1 
;
1A0DF44 	58 46 A0  1 

\ Convert a packed string to a C string
: cstr  ( forth-pstring -- c-string-adr )  count $cstr  ;
1A0DF48 	 0  0  0 63 73 74 72 84 
1A0DF50 	F8 DE A0  1 20 40 A0  1 
1A0DF58 	BC 53 A0  1 F8 DE A0  1 
1A0DF60 	58 46 A0  1 

\ Find the length of a C string, not counting the null byte
: cstrlen  ( c-string -- length )
1A0DF64 	63 73 74 72 
1A0DF68 	6C 65 6E 87 54 DF A0  1 
1A0DF70 	20 40 A0  1 
   dup  begin  dup c@  while  ca1+  repeat  swap -
1A0DF74 	40 49 A0  1 
1A0DF78 	40 49 A0  1 C4 4C A0  1 
1A0DF80 	DC 41 A0  1 10  0  0  0 
1A0DF88 	78 50 A0  1 C8 41 A0  1 
1A0DF90 	E8 FF FF FF 68 49 A0  1 
1A0DF98 	18 45 A0  1 
;
1A0DF9C 	58 46 A0  1 
\ Convert a null-terminated C string to an unpacked string
: cscount  ( cstr -- adr len )  dup cstrlen  ;
1A0DFA0 	63 73 63 6F 75 6E 74 87 
1A0DFA8 	70 DF A0  1 20 40 A0  1 
1A0DFB0 	40 49 A0  1 70 DF A0  1 
1A0DFB8 	58 46 A0  1 

headers

\ From alias.fth

\ Alias makes a new word which behaves exactly like an existing
\ word.  This works whether the new word is encountered during
\ compilation or interpretation, and does the right thing even
\  if the old word is immediate.

decimal

: setalias  ( xt +-1 -- )
1A0DFBC 	 0  0  0 73 
1A0DFC0 	65 74 61 6C 69 61 73 88 
1A0DFC8 	AC DF A0  1 20 40 A0  1 
   0> if  immediate  then                ( acf )
1A0DFD0 	A4 47 A0  1 DC 41 A0  1 
1A0DFD8 	 8  0  0  0 BC B8 A0  1 
   flagalias
1A0DFE0 	2C B9 A0  1 
   lastacf  here - allot   token,
1A0DFE4 	AC 57 A0  1 
1A0DFE8 	70 54 A0  1 18 45 A0  1 
1A0DFF0 	E4 54 A0  1 2C 55 A0  1 
;
1A0DFF8 	58 46 A0  1 
: alias  \ new-name old-name  ( -- )
1A0DFFC 	 0  0 61 6C 
1A0E000 	69 61 73 85 CC DF A0  1 
1A0E008 	20 40 A0  1 
   create  hide  'i  reveal  setalias
1A0E00C 	A8 A2 A0  1 
1A0E010 	54 A5 A0  1 B0 94 A0  1 
1A0E018 	88 A5 A0  1 CC DF A0  1 
;
1A0E020 	58 46 A0  1 

\ From ansio.fth

headers
: allocate  ( size -- adr ior )  alloc-mem  dup 0=  ;
1A0E024 	 0  0  0 61 
1A0E028 	6C 6C 6F 63 61 74 65 88 
1A0E030 	 8 E0 A0  1 20 40 A0  1 
1A0E038 	F0 6C A0  1 40 49 A0  1 
1A0E040 	24 47 A0  1 58 46 A0  1 

\ Assumes free-mem doesn't really need the size parameter; usually true
: free  ( adr -- ior )  0 free-mem 0  ;
1A0E048 	 0  0  0 66 72 65 65 84 
1A0E050 	34 E0 A0  1 20 40 A0  1 
1A0E058 	70 6F A0  1  8 6D A0  1 
1A0E060 	70 6F A0  1 58 46 A0  1 

headerless
nuser insane
1A0E068 	 0 69 6E 73 61 6E 65 86 
1A0E070 	54 E0 A0  1 48 40 A0  1 
1A0E078 	B4  2  0  0 

headers
0 value exit-interact?
1A0E07C 	 0 65 78 69 
1A0E080 	74 2D 69 6E 74 65 72 61 
1A0E088 	63 74 3F 8E 74 E0 A0  1 
1A0E090 	50 40 A0  1 B8  2  0  0 

headerless
\ XXX check for EOF on keyboard stream
: more-input?  ( -- flag )  insane off  true  ;
1A0E098 	6D 6F 72 65 2D 69 6E 70 
1A0E0A0 	75 74 3F 8B 90 E0 A0  1 
1A0E0A8 	20 40 A0  1 74 E0 A0  1 
1A0E0B0 	F8 4B A0  1  4 70 A0  1 
1A0E0B8 	58 46 A0  1 

headers

variable blk
1A0E0BC 	62 6C 6B 83 
1A0E0C0 	A8 E0 A0  1 48 40 A0  1 
1A0E0C8 	BC  2  0  0 

headerless
defer ?block-valid  ( -- flag )  ' false is ?block-valid
1A0E0CC 	 0  0  0 3F 
1A0E0D0 	62 6C 6F 63 6B 2D 76 61 
1A0E0D8 	6C 69 64 8C C4 E0 A0  1 
1A0E0E0 	5C 40 A0  1 C0  2  0  0 

headers
variable #tib
1A0E0E8 	 0  0  0 23 74 69 62 84 
1A0E0F0 	E0 E0 A0  1 48 40 A0  1 
1A0E0F8 	C4  2  0  0 


: save-input  ( -- source-adr source-len source-id >in blk 5 )
1A0E0FC 	 0 73 61 76 
1A0E100 	65 2D 69 6E 70 75 74 8A 
1A0E108 	F4 E0 A0  1 20 40 A0  1 
   source  source-id  >in @  blk @  5
1A0E110 	84 81 A0  1 8C AE A0  1 
1A0E118 	28 85 A0  1 5C 4C A0  1 
1A0E120 	C4 E0 A0  1 5C 4C A0  1 
1A0E128 	C0 6F A0  1 
;
1A0E12C 	58 46 A0  1 
: restore-input  ( source-adr source-len source-id >in blk 5 -- flag )
1A0E130 	 0  0 72 65 73 74 6F 72 
1A0E138 	65 2D 69 6E 70 75 74 8D 
1A0E140 	 C E1 A0  1 20 40 A0  1 
   drop
1A0E148 	30 49 A0  1 
   blk !  >in !  'source-id !  set-source
1A0E14C 	C4 E0 A0  1 
1A0E150 	54 4D A0  1 28 85 A0  1 
1A0E158 	54 4D A0  1 70 AB A0  1 
1A0E160 	54 4D A0  1 A8 81 A0  1 
   false
1A0E168 	18 70 A0  1 
;
1A0E16C 	58 46 A0  1 
: set-input  ( source-adr source-len source-id -- )
1A0E170 	 0  0 73 65 74 2D 69 6E 
1A0E178 	70 75 74 89 44 E1 A0  1 
1A0E180 	20 40 A0  1 
   0 0 5 restore-input drop
1A0E184 	70 6F A0  1 
1A0E188 	70 6F A0  1 C0 6F A0  1 
1A0E190 	44 E1 A0  1 30 49 A0  1 
;
1A0E198 	58 46 A0  1 

: word  ( delim -- pstr )
1A0E19C 	 0  0  0 77 
1A0E1A0 	6F 72 64 84 80 E1 A0  1 
1A0E1A8 	20 40 A0  1 
   source >in @ /string  over >r   ( delim adr1 len1 )  ( r: adr1 )
1A0E1AC 	84 81 A0  1 
1A0E1B0 	28 85 A0  1 5C 4C A0  1 
1A0E1B8 	3C 85 A0  1 54 49 A0  1 
1A0E1C0 	BC 45 A0  1 
   rot >r r@ skipchar              ( adr2 len2 )        ( r: adr1 delim )
1A0E1C4 	7C 49 A0  1 
1A0E1C8 	BC 45 A0  1 E4 45 A0  1 
1A0E1D0 	34 65 A0  1 
   r> scantochar                   ( adr2 adr3 adr4 )   ( r: adr1 )
1A0E1D4 	D0 45 A0  1 
1A0E1D8 	60 65 A0  1 
   r> - >in +!                     ( adr2 adr3 ) ( r: )
1A0E1DC 	D0 45 A0  1 
1A0E1E0 	18 45 A0  1 28 85 A0  1 
1A0E1E8 	 C 4C A0  1 
   over -                          ( adr1 len )
1A0E1EC 	54 49 A0  1 
1A0E1F0 	18 45 A0  1 
   dup d# 255 >  ( -18 ) abort" Parsed string overflow"
1A0E1F4 	40 49 A0  1 
1A0E1F8 	58 41 A0  1 FF  0  0  0 
1A0E200 	 4 48 A0  1  8 81 A0  1 
1A0E208 	16 50 61 72 73 65 64 20 
1A0E210 	73 74 72 69 6E 67 20 6F 
1A0E218 	76 65 72 66 6C 6F 77  0 
   'word pack                      ( pstr )
1A0E220 	B4 C8 A0  1 DC 52 A0  1 
;
1A0E228 	58 46 A0  1 

: refill  ( -- more? )
1A0E22C 	 0 72 65 66 
1A0E230 	69 6C 6C 86 A8 E1 A0  1 
1A0E238 	20 40 A0  1 
   blk @  if  1 blk +!  ?block-valid  exit  then
1A0E23C 	C4 E0 A0  1 
1A0E240 	5C 4C A0  1 DC 41 A0  1 
1A0E248 	18  0  0  0 80 6F A0  1 
1A0E250 	C4 E0 A0  1  C 4C A0  1 
1A0E258 	E0 E0 A0  1 40 46 A0  1 

   source-id  -1 =  if  false exit  then
1A0E260 	8C AE A0  1 58 41 A0  1 
1A0E268 	FF FF FF FF 24 48 A0  1 
1A0E270 	DC 41 A0  1  C  0  0  0 
1A0E278 	18 70 A0  1 40 46 A0  1 
   source-adr					     ( adr )
1A0E280 	68 81 A0  1 
   source-id  if                                     ( adr )
1A0E284 	8C AE A0  1 
1A0E288 	DC 41 A0  1 64  0  0  0 
      /tib source-id read-line
1A0E290 	3C 70 A0  1 8C AE A0  1 
1A0E298 	C0 DB A0  1 
      ( -37 ) abort" Read error in refill"  ( cnt more? )
1A0E29C 	 8 81 A0  1 
1A0E2A0 	14 52 65 61 64 20 65 72 
1A0E2A8 	72 6F 72 20 69 6E 20 72 
1A0E2B0 	65 66 69 6C 6C  0  0  0 
      over /tib = ( -18 ) abort" line too long in input file"  ( cnt more? )
1A0E2B8 	54 49 A0  1 3C 70 A0  1 
1A0E2C0 	24 48 A0  1  8 81 A0  1 
1A0E2C8 	1B 6C 69 6E 65 20 74 6F 
1A0E2D0 	6F 20 6C 6F 6E 67 20 69 
1A0E2D8 	6E 20 69 6E 70 75 74 20 
1A0E2E0 	66 69 6C 65  0  0  0  0 
   else                                              ( adr )
1A0E2E8 	C8 41 A0  1 30  0  0  0 
      \ The ANS Forth standard does not mention the possibility
      \ that ACCEPT might not be able to deliver any more input,
      \ but in this implementation, the `keyboard' can be redirected
      \ to a file via the command line, so it is indeed possible for
      \ ACCEPT to have no more characters to deliver.  Furthermore,
      \ we also provide a "finished" flag that can be set to force an
      \ exit from the interpreter loop.
      /tib accept  insane off                        ( cnt )
1A0E2F0 	3C 70 A0  1 D8 6C A0  1 
1A0E2F8 	74 E0 A0  1 F8 4B A0  1 
      dup  if  true  else  more-input?  then         ( cnt more? )
1A0E300 	40 49 A0  1 DC 41 A0  1 
1A0E308 	10  0  0  0  4 70 A0  1 
1A0E310 	C8 41 A0  1  8  0  0  0 
1A0E318 	A8 E0 A0  1 
   then                                              ( cnt more? )
   swap  #source !  0 >in !                          ( more? )
1A0E31C 	68 49 A0  1 
1A0E320 	50 81 A0  1 54 4D A0  1 
1A0E328 	70 6F A0  1 28 85 A0  1 
1A0E330 	54 4D A0  1 
;
1A0E334 	58 46 A0  1 

defer prompt
1A0E338 	 0 70 72 6F 6D 70 74 86 
1A0E340 	38 E2 A0  1 5C 40 A0  1 
1A0E348 	C8  2  0  0 

: do-prompt  ( -- )  reset-page prompt  ;
1A0E34C 	 0  0 64 6F 
1A0E350 	2D 70 72 6F 6D 70 74 89 
1A0E358 	44 E3 A0  1 20 40 A0  1 
1A0E360 	9C A1 A0  1 44 E3 A0  1 
1A0E368 	58 46 A0  1 

: (prompt)  ( -- )
1A0E36C 	 0  0  0 28 
1A0E370 	70 72 6F 6D 70 74 29 88 
1A0E378 	5C E3 A0  1 20 40 A0  1 
   interactive?  if	\ Suppress prompt if input is redirected to a file
1A0E380 	C4 6C A0  1 DC 41 A0  1 
1A0E388 	60  0  0  0 
      ??cr status
1A0E38C 	 0 A1 A0  1 
1A0E390 	38 A1 A0  1 
      state @  if
1A0E394 	38 54 A0  1 
1A0E398 	5C 4C A0  1 DC 41 A0  1 
1A0E3A0 	40  0  0  0 
         level @  ?dup if  1 .r  else  ."  "  then  ." ] "
1A0E3A4 	FC 81 A0  1 
1A0E3A8 	5C 4C A0  1 B4 70 A0  1 
1A0E3B0 	DC 41 A0  1 14  0  0  0 
1A0E3B8 	80 6F A0  1 58 78 A0  1 
1A0E3C0 	C8 41 A0  1  C  0  0  0 
1A0E3C8 	20 7C A0  1  1 20  0  0 
1A0E3D0 	20 7C A0  1  2 5D 20  0 
      else
1A0E3D8 	C8 41 A0  1  8  0  0  0 
         (ok)
1A0E3E0 	64 A1 A0  1 
      then
      mark-output
1A0E3E4 	50 A1 A0  1 
   then
;
1A0E3E8 	58 46 A0  1 

: (interact)  ( -- )
1A0E3EC 	 0 28 69 6E 
1A0E3F0 	74 65 72 61 63 74 29 8A 
1A0E3F8 	7C E3 A0  1 20 40 A0  1 
   tib /tib 0 set-input
1A0E400 	 4 75 A0  1 3C 70 A0  1 
1A0E408 	70 6F A0  1 80 E1 A0  1 
   [compile] [
1A0E410 	90 6D A0  1 
   begin
      depth 0<  if  ." Stack Underflow" cr  clear  then
1A0E414 	28 73 A0  1 
1A0E418 	64 47 A0  1 DC 41 A0  1 
1A0E420 	24  0  0  0 20 7C A0  1 
1A0E428 	 F 53 74 61 63 6B 20 55 
1A0E430 	6E 64 65 72 66 6C 6F 77 
1A0E438 	 0  0  0  0 80 6D A0  1 
1A0E440 	58 73 A0  1 
      sp@  sp0 @  ps-size -  u<  if  ." Stack Overflow" cr  clear  then
1A0E444 	6C 45 A0  1 
1A0E448 	8C 66 A0  1 5C 4C A0  1 
1A0E450 	84 8E A0  1 18 45 A0  1 
1A0E458 	A8 48 A0  1 DC 41 A0  1 
1A0E460 	20  0  0  0 20 7C A0  1 
1A0E468 	 E 53 74 61 63 6B 20 4F 
1A0E470 	76 65 72 66 6C 6F 77  0 
1A0E478 	80 6D A0  1 58 73 A0  1 
      do-prompt
1A0E480 	5C E3 A0  1 
   refill  while
1A0E484 	38 E2 A0  1 
1A0E488 	DC 41 A0  1 34  0  0  0 
      ['] interpret catch  ??cr  ?dup if
1A0E490 	60 53 A0  1 B0 A0 A0  1 
1A0E498 	14 7F A0  1  0 A1 A0  1 
1A0E4A0 	B4 70 A0  1 DC 41 A0  1 
1A0E4A8 	 C  0  0  0 
         [compile] [  .error
1A0E4AC 	90 6D A0  1 
1A0E4B0 	70 CF A0  1 
	 \ ANS Forth sort of requires the following "clear", but it's a
	 \ real pain and doesn't affect programs, so we don't do it
\        clear
      then
   exit-interact? until then
1A0E4B4 	90 E0 A0  1 
1A0E4B8 	DC 41 A0  1 58 FF FF FF 
   false is exit-interact?
1A0E4C0 	18 70 A0  1 B8 65 A0  1 
1A0E4C8 	90 E0 A0  1 
;
1A0E4CC 	58 46 A0  1 
: interact  ( -- )
1A0E4D0 	 0  0  0 69 6E 74 65 72 
1A0E4D8 	61 63 74 88 FC E3 A0  1 
1A0E4E0 	20 40 A0  1 
   save-input  2>r 2>r 2>r
1A0E4E4 	 C E1 A0  1 
1A0E4E8 	F8 45 A0  1 F8 45 A0  1 
1A0E4F0 	F8 45 A0  1 
   (interact)
1A0E4F4 	FC E3 A0  1 
   2r> 2r> 2r> restore-input  throw
1A0E4F8 	10 46 A0  1 10 46 A0  1 
1A0E500 	10 46 A0  1 44 E1 A0  1 
1A0E508 	74 7F A0  1 
;
1A0E50C 	58 46 A0  1 
: (quit)  ( -- )
1A0E510 	 0 28 71 75 69 74 29 86 
1A0E518 	E0 E4 A0  1 20 40 A0  1 
   \ XXX We really should clean up any open input files here...
   0 level !  ]
1A0E520 	70 6F A0  1 FC 81 A0  1 
1A0E528 	54 4D A0  1 A0 6D A0  1 
   rp0 @ rp!
1A0E530 	9C 66 A0  1 5C 4C A0  1 
1A0E538 	AC 45 A0  1 
   interact
1A0E53C 	E0 E4 A0  1 
   bye
1A0E540 	74 6C A0  1 
;
1A0E544 	58 46 A0  1 

: interpret-lines  ( -- )  begin  refill  while  interpret  repeat  ;
1A0E548 	69 6E 74 65 72 70 72 65 
1A0E550 	74 2D 6C 69 6E 65 73 8F 
1A0E558 	1C E5 A0  1 20 40 A0  1 
1A0E560 	38 E2 A0  1 DC 41 A0  1 
1A0E568 	10  0  0  0 B0 A0 A0  1 
1A0E570 	C8 41 A0  1 EC FF FF FF 
1A0E578 	58 46 A0  1 

: (evaluate)  ( adr len -- )
1A0E57C 	 0 28 65 76 
1A0E580 	61 6C 75 61 74 65 29 8A 
1A0E588 	5C E5 A0  1 20 40 A0  1 
   begin  dup  while         ( adr len )
1A0E590 	40 49 A0  1 DC 41 A0  1 
1A0E598 	28  0  0  0 
      parse-line  2>r        ( head$ )    ( r: tail$ )
1A0E59C 	78 64 A0  1 
1A0E5A0 	F8 45 A0  1 
      -1 set-input           ( )          ( r: tail$ )
1A0E5A4 	58 41 A0  1 
1A0E5A8 	FF FF FF FF 80 E1 A0  1 
      interpret              ( )          ( r: tail$ )
1A0E5B0 	B0 A0 A0  1 
      2r>                    ( adr len )
1A0E5B4 	10 46 A0  1 
   repeat                    ( adr len )
1A0E5B8 	C8 41 A0  1 D4 FF FF FF 
   2drop
1A0E5C0 	AC 49 A0  1 
;
1A0E5C4 	58 46 A0  1 

: evaluate  ( adr len -- )
1A0E5C8 	 0  0  0 65 76 61 6C 75 
1A0E5D0 	61 74 65 88 8C E5 A0  1 
1A0E5D8 	20 40 A0  1 
   save-input  2>r 2>r 2>r   ( adr len )
1A0E5DC 	 C E1 A0  1 
1A0E5E0 	F8 45 A0  1 F8 45 A0  1 
1A0E5E8 	F8 45 A0  1 
   ['] (evaluate) catch  dup  if  nip nip  then   ( error# )
1A0E5EC 	60 53 A0  1 
1A0E5F0 	8C E5 A0  1 14 7F A0  1 
1A0E5F8 	40 49 A0  1 DC 41 A0  1 
1A0E600 	 C  0  0  0 FC 46 A0  1 
1A0E608 	FC 46 A0  1 
   2r> 2r> 2r> restore-input  throw               ( error# )
1A0E60C 	10 46 A0  1 
1A0E610 	10 46 A0  1 10 46 A0  1 
1A0E618 	44 E1 A0  1 74 7F A0  1 
   throw
1A0E620 	74 7F A0  1 
;
1A0E624 	58 46 A0  1 

' (prompt) is prompt

' (quit) is quit

: include-file  ( fid -- )
1A0E628 	 0  0  0 69 6E 63 6C 75 
1A0E630 	64 65 2D 66 69 6C 65 8C 
1A0E638 	D8 E5 A0  1 20 40 A0  1 
   /tib 4 + allocate throw	( fid adr )
1A0E640 	3C 70 A0  1 B0 6F A0  1 
1A0E648 	 4 45 A0  1 34 E0 A0  1 
1A0E650 	74 7F A0  1 
   save-input 2>r 2>r 2>r       ( fid adr )
1A0E654 	 C E1 A0  1 
1A0E658 	F8 45 A0  1 F8 45 A0  1 
1A0E660 	F8 45 A0  1 

   /tib rot set-input
1A0E664 	3C 70 A0  1 
1A0E668 	7C 49 A0  1 80 E1 A0  1 

   ['] interpret-lines catch    ( error# )
1A0E670 	60 53 A0  1 5C E5 A0  1 
1A0E678 	14 7F A0  1 
   source-id close-file drop    ( error# )
1A0E67C 	8C AE A0  1 
1A0E680 	FC D9 A0  1 30 49 A0  1 

   source-adr free drop         ( error# )
1A0E688 	68 81 A0  1 54 E0 A0  1 
1A0E690 	30 49 A0  1 

   2r> 2r> 2r> restore-input  throw  ( error# )
1A0E694 	10 46 A0  1 
1A0E698 	10 46 A0  1 10 46 A0  1 
1A0E6A0 	44 E1 A0  1 74 7F A0  1 
   throw
1A0E6A8 	74 7F A0  1 
;
1A0E6AC 	58 46 A0  1 
defer $open-error        ' noop is $open-error
1A0E6B0 	24 6F 70 65 6E 2D 65 72 
1A0E6B8 	72 6F 72 8B 3C E6 A0  1 
1A0E6C0 	5C 40 A0  1 CC  2  0  0 
defer include-hook       ' noop is include-hook
1A0E6C8 	 0  0  0 69 6E 63 6C 75 
1A0E6D0 	64 65 2D 68 6F 6F 6B 8C 
1A0E6D8 	C0 E6 A0  1 5C 40 A0  1 
1A0E6E0 	D0  2  0  0 
defer include-exit-hook  ' noop is include-exit-hook
1A0E6E4 	 0  0 69 6E 
1A0E6E8 	63 6C 75 64 65 2D 65 78 
1A0E6F0 	69 74 2D 68 6F 6F 6B 91 
1A0E6F8 	DC E6 A0  1 5C 40 A0  1 
1A0E700 	D4  2  0  0 

: open-buffer  ( adr len -- fd ior )
1A0E704 	6F 70 65 6E 
1A0E708 	2D 62 75 66 66 65 72 8B 
1A0E710 	FC E6 A0  1 20 40 A0  1 
   2 ?enough
1A0E718 	90 6F A0  1 48 8E A0  1 
   \ XXX we need a "throw" code for "no more fds"
   (get-fd  ?dup 0=  if  0 true exit  then	( adr len fd )
1A0E720 	88 CD A0  1 B4 70 A0  1 
1A0E728 	24 47 A0  1 DC 41 A0  1 
1A0E730 	10  0  0  0 70 6F A0  1 
1A0E738 	 4 70 A0  1 40 46 A0  1 
   file !
1A0E740 	84 AB A0  1 54 4D A0  1 
   2dup						( adr len )
1A0E748 	C0 49 A0  1 
   initbuf  init-delims				( adr len )
1A0E74C 	F4 CA A0  1 
1A0E750 	78 CE A0  1 
   bflimit @  dup bfend !  bftop !		( adr len )
1A0E754 	BC AB A0  1 
1A0E758 	5C 4C A0  1 40 49 A0  1 
1A0E760 	 4 AC A0  1 54 4D A0  1 
1A0E768 	E0 AB A0  1 54 4D A0  1 

   0  modify
1A0E770 	70 6F A0  1 10 CA A0  1 
   ['] string-sizeop  ['] drop  ['] drop
1A0E778 	60 53 A0  1 E8 CD A0  1 
1A0E780 	60 53 A0  1 30 49 A0  1 
1A0E788 	60 53 A0  1 30 49 A0  1 
   ['] nullseek  ['] fakewrite  ['] nullread   setupfd  ( adr len )
1A0E790 	60 53 A0  1 BC CA A0  1 
1A0E798 	60 53 A0  1 60 CA A0  1 
1A0E7A0 	60 53 A0  1 9C CA A0  1 
1A0E7A8 	64 C9 A0  1 
   $set-line-delimiter
1A0E7AC 	B0 D7 A0  1 

   \ Set the file name field to "<buffer@ADDRESS>"
   base @ >r hex
1A0E7B0 	B8 75 A0  1 5C 4C A0  1 
1A0E7B8 	BC 45 A0  1 C0 8D A0  1 
   bfbase @ <#  ascii > hold  u#s " <buffer@" hold$ u#> set-name
1A0E7C0 	98 AB A0  1 5C 4C A0  1 
1A0E7C8 	 8 76 A0  1 58 41 A0  1 
1A0E7D0 	3E  0  0  0 DC 75 A0  1 
1A0E7D8 	BC 76 A0  1 9C 53 A0  1 
1A0E7E0 	 8 3C 62 75 66 66 65 72 
1A0E7E8 	40  0  0  0 18 CE A0  1 
1A0E7F0 	E0 76 A0  1  4 C9 A0  1 
   r> base !
1A0E7F8 	D0 45 A0  1 B8 75 A0  1 
1A0E800 	54 4D A0  1 

   file @  false
1A0E804 	84 AB A0  1 
1A0E808 	5C 4C A0  1 18 70 A0  1 
;
1A0E810 	58 46 A0  1 

: include-buffer  ( adr len -- )
1A0E814 	 0 69 6E 63 
1A0E818 	6C 75 64 65 2D 62 75 66 
1A0E820 	66 65 72 8E 14 E7 A0  1 
1A0E828 	20 40 A0  1 
   open-buffer  ?dup  if  " <buffer>" $open-error  then  include-file
1A0E82C 	14 E7 A0  1 
1A0E830 	B4 70 A0  1 DC 41 A0  1 
1A0E838 	18  0  0  0 9C 53 A0  1 
1A0E840 	 8 3C 62 75 66 66 65 72 
1A0E848 	3E  0  0  0 C0 E6 A0  1 
1A0E850 	3C E6 A0  1 
;
1A0E854 	58 46 A0  1 

: $abort-include  ( error# filename$ -- )  2drop  throw  ;
1A0E858 	 0 24 61 62 6F 72 74 2D 
1A0E860 	69 6E 63 6C 75 64 65 8E 
1A0E868 	28 E8 A0  1 20 40 A0  1 
1A0E870 	AC 49 A0  1 74 7F A0  1 
1A0E878 	58 46 A0  1 
' $abort-include is $open-error

: (included)  ( adr len -- )
1A0E87C 	 0 28 69 6E 
1A0E880 	63 6C 75 64 65 64 29 8A 
1A0E888 	6C E8 A0  1 20 40 A0  1 
   r/o open-file  ?dup  if
1A0E890 	1C D6 A0  1 CC D8 A0  1 
1A0E898 	B4 70 A0  1 DC 41 A0  1 
1A0E8A0 	10  0  0  0 
      opened-filename 2@ $open-error
1A0E8A4 	80 D6 A0  1 
1A0E8A8 	CC 4D A0  1 C0 E6 A0  1 
   then                 ( fid )
   include-file
1A0E8B0 	3C E6 A0  1 
;
1A0E8B4 	58 46 A0  1 
: included  ( adr len -- )
1A0E8B8 	 0  0  0 69 6E 63 6C 75 
1A0E8C0 	64 65 64 88 8C E8 A0  1 
1A0E8C8 	20 40 A0  1 
   include-hook          ( adr len )
1A0E8CC 	DC E6 A0  1 
   ['] (included) catch  ( error# )
1A0E8D0 	60 53 A0  1 8C E8 A0  1 
1A0E8D8 	14 7F A0  1 
   include-exit-hook     ( error# )
1A0E8DC 	FC E6 A0  1 
   throw
1A0E8E0 	74 7F A0  1 
;
1A0E8E4 	58 46 A0  1 
: including  ( "name" -- )  safe-parse-word included  ;
1A0E8E8 	 0  0 69 6E 63 6C 75 64 
1A0E8F0 	69 6E 67 89 C8 E8 A0  1 
1A0E8F8 	20 40 A0  1 88 93 A0  1 
1A0E900 	C8 E8 A0  1 58 46 A0  1 
: fl  ( "name" -- )  including  ;
1A0E908 	 0 66 6C 82 F8 E8 A0  1 
1A0E910 	20 40 A0  1 F8 E8 A0  1 
1A0E918 	58 46 A0  1 

0 value error-file
1A0E91C 	 0 65 72 72 
1A0E920 	6F 72 2D 66 69 6C 65 8A 
1A0E928 	10 E9 A0  1 50 40 A0  1 
1A0E930 	D8  2  0  0 
: init  ( -- )  init  d# 128 alloc-mem  is error-file  ;
1A0E934 	 0  0  0 69 
1A0E938 	6E 69 74 84 2C E9 A0  1 
1A0E940 	20 40 A0  1 CC DE A0  1 
1A0E948 	58 41 A0  1 80  0  0  0 
1A0E950 	F0 6C A0  1 B8 65 A0  1 
1A0E958 	2C E9 A0  1 58 46 A0  1 
nuser error-line#
1A0E960 	65 72 72 6F 72 2D 6C 69 
1A0E968 	6E 65 23 8B 40 E9 A0  1 
1A0E970 	48 40 A0  1 DC  2  0  0 
nuser error-source-id
1A0E978 	65 72 72 6F 72 2D 73 6F 
1A0E980 	75 72 63 65 2D 69 64 8F 
1A0E988 	70 E9 A0  1 48 40 A0  1 
1A0E990 	E0  2  0  0 
nuser error-source-adr
1A0E994 	 0  0  0 65 
1A0E998 	72 72 6F 72 2D 73 6F 75 
1A0E9A0 	72 63 65 2D 61 64 72 90 
1A0E9A8 	8C E9 A0  1 48 40 A0  1 
1A0E9B0 	E4  2  0  0 
nuser error-#source
1A0E9B4 	 0  0 65 72 
1A0E9B8 	72 6F 72 2D 23 73 6F 75 
1A0E9C0 	72 63 65 8D AC E9 A0  1 
1A0E9C8 	48 40 A0  1 E8  2  0  0 
: (mark-error)  ( -- )
1A0E9D0 	 0  0  0 28 6D 61 72 6B 
1A0E9D8 	2D 65 72 72 6F 72 29 8C 
1A0E9E0 	C8 E9 A0  1 20 40 A0  1 
   \ Suppress message if input is interactive or from "evaluate"
   source-id  error-source-id !
1A0E9E8 	8C AE A0  1 8C E9 A0  1 
1A0E9F0 	54 4D A0  1 
   source-id  0<>  if
1A0E9F4 	8C AE A0  1 
1A0E9F8 	44 47 A0  1 DC 41 A0  1 
1A0EA00 	58  0  0  0 
      source-id  -1 =  if
1A0EA04 	8C AE A0  1 
1A0EA08 	58 41 A0  1 FF FF FF FF 
1A0EA10 	24 48 A0  1 DC 41 A0  1 
1A0EA18 	20  0  0  0 
         source error-#source !  error-source-adr !
1A0EA1C 	84 81 A0  1 
1A0EA20 	C8 E9 A0  1 54 4D A0  1 
1A0EA28 	AC E9 A0  1 54 4D A0  1 
      else
1A0EA30 	C8 41 A0  1 24  0  0  0 
         source-id file-name error-file place
1A0EA38 	8C AE A0  1 88 B3 A0  1 
1A0EA40 	2C E9 A0  1 F0 88 A0  1 
         source-id file-line error-line# !
1A0EA48 	8C AE A0  1 C8 B3 A0  1 
1A0EA50 	70 E9 A0  1 54 4D A0  1 
      then
   then
;
1A0EA58 	58 46 A0  1 
' (mark-error) is mark-error
: (show-error)  ( -- )
1A0EA5C 	 0  0  0 28 
1A0EA60 	73 68 6F 77 2D 65 72 72 
1A0EA68 	6F 72 29 8C E4 E9 A0  1 
1A0EA70 	20 40 A0  1 
   ??cr
1A0EA74 	 0 A1 A0  1 
   error-source-id @  if
1A0EA78 	8C E9 A0  1 5C 4C A0  1 
1A0EA80 	DC 41 A0  1 9C  0  0  0 
      error-source-id @ -1  =  if
1A0EA88 	8C E9 A0  1 5C 4C A0  1 
1A0EA90 	58 41 A0  1 FF FF FF FF 
1A0EA98 	24 48 A0  1 DC 41 A0  1 
1A0EAA0 	38  0  0  0 
         ." Evaluating: " error-source-adr @ error-#source @  type cr
1A0EAA4 	20 7C A0  1 
1A0EAA8 	 C 45 76 61 6C 75 61 74 
1A0EAB0 	69 6E 67 3A 20  0  0  0 
1A0EAB8 	AC E9 A0  1 5C 4C A0  1 
1A0EAC0 	C8 E9 A0  1 5C 4C A0  1 
1A0EAC8 	 4 6C A0  1 80 6D A0  1 
      else
1A0EAD0 	C8 41 A0  1 4C  0  0  0 
         error-file count type  ." :"
1A0EAD8 	2C E9 A0  1 BC 53 A0  1 
1A0EAE0 	 4 6C A0  1 20 7C A0  1 
1A0EAE8 	 1 3A  0  0 
         base @ >r decimal  error-line# @ (.) type  r> base !
1A0EAEC 	B8 75 A0  1 
1A0EAF0 	5C 4C A0  1 BC 45 A0  1 
1A0EAF8 	E4 8D A0  1 70 E9 A0  1 
1A0EB00 	5C 4C A0  1 10 78 A0  1 
1A0EB08 	 4 6C A0  1 D0 45 A0  1 
1A0EB10 	B8 75 A0  1 54 4D A0  1 
         ." : "
1A0EB18 	20 7C A0  1  2 3A 20  0 
      then
   then
;
1A0EB20 	58 46 A0  1 
' (show-error) is show-error

\ Environment?

defer environment?
1A0EB24 	 0  0  0 65 
1A0EB28 	6E 76 69 72 6F 6E 6D 65 
1A0EB30 	6E 74 3F 8C 70 EA A0  1 
1A0EB38 	5C 40 A0  1 EC  2  0  0 
: null-environment?  ( c-addr u -- false | i*x true )  2drop false  ;
1A0EB40 	 0  0 6E 75 6C 6C 2D 65 
1A0EB48 	6E 76 69 72 6F 6E 6D 65 
1A0EB50 	6E 74 3F 91 38 EB A0  1 
1A0EB58 	20 40 A0  1 AC 49 A0  1 
1A0EB60 	18 70 A0  1 58 46 A0  1 
' null-environment? is environment?

: fload fl ;
1A0EB68 	 0  0 66 6C 6F 61 64 85 
1A0EB70 	58 EB A0  1 20 40 A0  1 
1A0EB78 	10 E9 A0  1 58 46 A0  1 

: $report-name  ( name$ -- name$ )
1A0EB80 	 0  0  0 24 72 65 70 6F 
1A0EB88 	72 74 2D 6E 61 6D 65 8C 
1A0EB90 	74 EB A0  1 20 40 A0  1 
   ." Loading " 2dup type cr
1A0EB98 	20 7C A0  1  8 4C 6F 61 
1A0EBA0 	64 69 6E 67 20  0  0  0 
1A0EBA8 	C0 49 A0  1  4 6C A0  1 
1A0EBB0 	80 6D A0  1 
;
1A0EBB4 	58 46 A0  1 
: fexit ( -- )  source-id close-file drop -1 'source-id !  ;
1A0EBB8 	 0  0 66 65 78 69 74 85 
1A0EBC0 	94 EB A0  1 20 40 A0  1 
1A0EBC8 	8C AE A0  1 FC D9 A0  1 
1A0EBD0 	30 49 A0  1 58 41 A0  1 
1A0EBD8 	FF FF FF FF 70 AB A0  1 
1A0EBE0 	54 4D A0  1 58 46 A0  1 

\ From copyright.fth

: id: [compile] \ ;
1A0EBE8 	69 64 3A 83 C4 EB A0  1 
1A0EBF0 	20 40 A0  1 74 8A A0  1 
1A0EBF8 	58 46 A0  1 
: copyright: [compile] \ ;
1A0EBFC 	 0 63 6F 70 
1A0EC00 	79 72 69 67 68 74 3A 8A 
1A0EC08 	F0 EB A0  1 20 40 A0  1 
1A0EC10 	74 8A A0  1 58 46 A0  1 
: purpose: [compile] \ ;
1A0EC18 	 0  0  0 70 75 72 70 6F 
1A0EC20 	73 65 3A 88  C EC A0  1 
1A0EC28 	20 40 A0  1 74 8A A0  1 
1A0EC30 	58 46 A0  1 
: build-now ;
1A0EC34 	 0  0 62 75 
1A0EC38 	69 6C 64 2D 6E 6F 77 89 
1A0EC40 	28 EC A0  1 20 40 A0  1 
1A0EC48 	58 46 A0  1 
: command: [compile] \ ;
1A0EC4C 	 0  0  0 63 
1A0EC50 	6F 6D 6D 61 6E 64 3A 88 
1A0EC58 	44 EC A0  1 20 40 A0  1 
1A0EC60 	74 8A A0  1 58 46 A0  1 
: in: [compile] \ ;
1A0EC68 	69 6E 3A 83 5C EC A0  1 
1A0EC70 	20 40 A0  1 74 8A A0  1 
1A0EC78 	58 46 A0  1 
: dictionary: [compile] \ ;
1A0EC7C 	64 69 63 74 
1A0EC80 	69 6F 6E 61 72 79 3A 8B 
1A0EC88 	70 EC A0  1 20 40 A0  1 
1A0EC90 	74 8A A0  1 58 46 A0  1 
: fixme:  ." FIXME: "  opened-filename 2@ type  ." : "  -1 parse type cr  ;
1A0EC98 	 0 66 69 78 6D 65 3A 86 
1A0ECA0 	8C EC A0  1 20 40 A0  1 
1A0ECA8 	20 7C A0  1  7 46 49 58 
1A0ECB0 	4D 45 3A 20  0  0  0  0 
1A0ECB8 	80 D6 A0  1 CC 4D A0  1 
1A0ECC0 	 4 6C A0  1 20 7C A0  1 
1A0ECC8 	 2 3A 20  0 58 41 A0  1 
1A0ECD0 	FF FF FF FF E4 85 A0  1 
1A0ECD8 	 4 6C A0  1 80 6D A0  1 
1A0ECE0 	58 46 A0  1 

\ From cmdline.fth

\ Get the arguments passed from the program


defer time&date  ( -- s m h d m y )
1A0ECE4 	 0  0 74 69 
1A0ECE8 	6D 65 26 64 61 74 65 89 
1A0ECF0 	A4 EC A0  1 5C 40 A0  1 
1A0ECF8 	F0  2  0  0 
: now  ( -- s m h )  time&date 3drop  ;
1A0ECFC 	6E 6F 77 83 
1A0ED00 	F4 EC A0  1 20 40 A0  1 
1A0ED08 	F4 EC A0  1 90 52 A0  1 
1A0ED10 	58 46 A0  1 
: today  ( -- d m y )  time&date >r >r >r  3drop  r> r> r>  ;
1A0ED14 	 0  0 74 6F 
1A0ED18 	64 61 79 85  4 ED A0  1 
1A0ED20 	20 40 A0  1 F4 EC A0  1 
1A0ED28 	BC 45 A0  1 BC 45 A0  1 
1A0ED30 	BC 45 A0  1 90 52 A0  1 
1A0ED38 	D0 45 A0  1 D0 45 A0  1 
1A0ED40 	D0 45 A0  1 58 46 A0  1 

: cold  (s -- )
1A0ED48 	 0  0  0 63 6F 6C 64 84 
1A0ED50 	20 ED A0  1 20 40 A0  1 
   decimal
1A0ED58 	E4 8D A0  1 
   init-io			  \ Memory allocator and character I/O
1A0ED5C 	6C D0 A0  1 
   do-init			  \ Kernel
1A0ED60 	80 D0 A0  1 
   ['] init-environment guarded	  \ Environmental dependencies
1A0ED64 	60 53 A0  1 
1A0ED68 	B8 D0 A0  1 44 D0 A0  1 
   ['] cold-hook        guarded	  \ Last-minute stuff
1A0ED70 	60 53 A0  1 98 D0 A0  1 
1A0ED78 	44 D0 A0  1 

;
1A0ED7C 	58 46 A0  1 

\ From comment.fth

\ Comments that span multiple lines

\ Turn this variable on to make long comments apply to the keyboard too.
\ This is useful for cutting and pasting bits of code into a Forth
\ system.
variable long-comments
1A0ED80 	 0  0 6C 6F 6E 67 2D 63 
1A0ED88 	6F 6D 6D 65 6E 74 73 8D 
1A0ED90 	54 ED A0  1 48 40 A0  1 
1A0ED98 	F4  2  0  0 
: (  \ "comments)"  ( -- )
1A0ED9C 	 0  0 28 C1 
1A0EDA0 	94 ED A0  1 20 40 A0  1 
   begin
      >in @  [char] ) parse       ( >in adr len )
1A0EDA8 	28 85 A0  1 5C 4C A0  1 
1A0EDB0 	58 41 A0  1 29  0  0  0 
1A0EDB8 	E4 85 A0  1 
      nip +  >in @  =             ( delimiter-not-found? )
1A0EDBC 	FC 46 A0  1 
1A0EDC0 	 4 45 A0  1 28 85 A0  1 
1A0EDC8 	5C 4C A0  1 24 48 A0  1 
      long-comments @  source-id  -1 0 between  0=  or  and  ( more? )
1A0EDD0 	94 ED A0  1 5C 4C A0  1 
1A0EDD8 	8C AE A0  1 58 41 A0  1 
1A0EDE0 	FF FF FF FF 70 6F A0  1 
1A0EDE8 	D8 70 A0  1 24 47 A0  1 
1A0EDF0 	70 44 A0  1 5C 44 A0  1 
   while                          ( )
1A0EDF8 	DC 41 A0  1 14  0  0  0 
      refill  0=
1A0EE00 	38 E2 A0  1 24 47 A0  1 
   until  then
1A0EE08 	DC 41 A0  1 9C FF FF FF 
; immediate
1A0EE10 	58 46 A0  1 
[then]


OpenFirmware/forth/kernel/kernel.fth_AL	MEG=33328 1A0EE14 purpose: structures and fields

: struct  ( -- initial-offset )  0  ;
1A0EE14 	 0 73 74 72 
1A0EE18 	75 63 74 86 A4 ED A0  1 
1A0EE20 	20 40 A0  1 70 6F A0  1 
1A0EE28 	58 46 A0  1 

: field  		\ name  ( offset size -- offset' )
1A0EE2C 	 0  0 66 69 
1A0EE30 	65 6C 64 85 20 EE A0  1 
1A0EE38 	20 40 A0  1 
   create  over  ,  +
1A0EE3C 	A8 A2 A0  1 
1A0EE40 	54 49 A0  1 98 55 A0  1 
1A0EE48 	 4 45 A0  1 
   does> @ +	 	( base -- addr )
1A0EE4C 	50 A3 A0  1 
1A0EE50 	90 90 90 E8 24 52 FF FF 
1A0EE58 	5C 4C A0  1  4 45 A0  1 
;
1A0EE60 	58 46 A0  1 

\ Create two name fields with the same offset and size
: 2field 		\ name  name  ( offset size -- offset' )
1A0EE64 	 0 32 66 69 
1A0EE68 	65 6C 64 86 38 EE A0  1 
1A0EE70 	20 40 A0  1 
   2dup field drop
1A0EE74 	C0 49 A0  1 
1A0EE78 	38 EE A0  1 30 49 A0  1 
   field
1A0EE80 	38 EE A0  1 
;
1A0EE84 	58 46 A0  1 

OpenFirmware/forth/lib/struct.fth_AL	116 1A0EE88 
[ifndef] omit-files
hex
\ Aligns to a 512-byte boundary; this is okay for most systems.
: _falign  ( l.byte# fd -- l.aligned )  drop  1ff invert and  ;
1A0EEA0 	5F 66 61 6C 69 67 6E 87 
1A0EEA8 	98 EE A0  1 20 40 A0  1 
1A0EEB0 	30 49 A0  1 58 41 A0  1 
1A0EEB8 	FF  1  0  0 30 45 A0  1 
1A0EEC0 	5C 44 A0  1 58 46 A0  1 
: _dfalign  ( d.byte# fd -- d.aligned )  drop  swap 1ff invert and swap	;
1A0EEC8 	 0  0  0 5F 64 66 61 6C 
1A0EED0 	69 67 6E 88 AC EE A0  1 
1A0EED8 	20 40 A0  1 30 49 A0  1 
1A0EEE0 	68 49 A0  1 58 41 A0  1 
1A0EEE8 	FF  1  0  0 30 45 A0  1 
1A0EEF0 	5C 44 A0  1 68 49 A0  1 
1A0EEF8 	58 46 A0  1 
[then]


headers
\ Line terminators for various operating systems
create lf-pstr    1 c, linefeed c,               \ Unix
1A0EEFC 	6C 66 2D 70 
1A0EF00 	73 74 72 87 D8 EE A0  1 
1A0EF08 	30 40 A0  1  1  A 
create cr-pstr    1 c, carret   c,               \ Macintosh, OS-9
1A0EF0E 	 0  0 
1A0EF10 	63 72 2D 70 73 74 72 87 
1A0EF18 	 8 EF A0  1 30 40 A0  1 
1A0EF20 	 1  D 
create crlf-pstr  2 c, carret   c,  linefeed c,  \ DOS
1A0EF22 	63 72 6C 66 2D 70 
1A0EF28 	73 74 72 89 1C EF A0  1 
1A0EF30 	30 40 A0  1  2  D  A 
[then]


OpenFirmware/forth/kernel/sysio.fth_AL	97 1A0EF37 

\ True if we are running in a "flat" memory space with all segment
\ selectors referring to the same address range.  This is generally
\ the case when running under Win32 or Unix, but not when running
\ native or under DOS, VCPI, or DPMI.
false value flat?
1A0EF37 	 0 
1A0EF38 	 0  0 66 6C 61 74 3F 85 
1A0EF40 	30 EF A0  1 50 40 A0  1 
1A0EF48 	F8  2  0  0 


\ Later, when Forth takes over interrupt vector 13, the following
\ defer words should be set to save and restore vector 13.
\ Typically, that would be done in catchexc.fth

defer wrapper-vectors  ' noop is wrapper-vectors
1A0EF4C 	77 72 61 70 
1A0EF50 	70 65 72 2D 76 65 63 74 
1A0EF58 	6F 72 73 8F 44 EF A0  1 
1A0EF60 	5C 40 A0  1 FC  2  0  0 
defer forth-vectors    ' noop is forth-vectors
1A0EF68 	 0  0 66 6F 72 74 68 2D 
1A0EF70 	76 65 63 74 6F 72 73 8D 
1A0EF78 	60 EF A0  1 5C 40 A0  1 
1A0EF80 	 0  3  0  0 


OpenFirmware/cpu/x86/syscall.fth_AL	4D 1A0EF84 
\ Boot code (cold start).  The cold start code is executed
\ when Forth is initially started.  Its job is to initialize the Forth
\ virtual machine registers.

hex

\ only forth also labels also meta also definitions

0 constant main-task
1A0EF84 	 0  0 6D 61 
1A0EF88 	69 6E 2D 74 61 73 6B 89 
1A0EF90 	7C EF A0  1 68 40 A0  1 
1A0EF98 	 0  0  0  0 


: init-user  (s -- )  ;
1A0EF9C 	 0  0 69 6E 
1A0EFA0 	69 74 2D 75 73 65 72 89 
1A0EFA8 	94 EF A0  1 20 40 A0  1 
1A0EFB0 	58 46 A0  1 



[ifdef] big-endian-t
\ Byte swap the pointers in the argument array
: bswap-args  ( -- )  #args 0  ?do  args i na+  dup @  swap le-l!  loop  ;
: (cold-hook  ( -- )  (cold-hook  bswap-args  ;
' (cold-hook is cold-hook
[then]

create cold-code  ( -- )  assembler
1A0EFB4 	 0  0 63 6F 
1A0EFB8 	6C 64 2D 63 6F 64 65 89 
1A0EFC0 	AC EF A0  1 30 40 A0  1 
mlabel cold-code

forth-h
\- rel-t h# e9 origin-t c!-t			   \ Relative jump with 32-bit offset
\- rel-t here-t  origin-t 5 +  -  origin-t 1+  !-t \ Offset relative to instruction end
\+ rel-t h# e9 jmp-header c!			          \ Relative jump with 32-bit offset
\+ rel-t here-t /jmp-header +   5 -  jmp-header 1+  le-l! \ Offset relative to instruction end
assembler

\ The segment registers are set correctly, and the stack pointer is
\ at the top of the memory region reserved for Forth

\ Get the origin address
   here-t 5 + #) call   here-t origin-t -  ( offset )
1A0EFC8 	E8  0  0  0  0 
\- rel-t   bx  pop
1A0EFCD 	5B 
\- rel-t   ( offset ) #  bx  sub	\ Origin in bx
1A0EFCE 	81 EB 
1A0EFD0 	CD EF  0  0 

\+ rel-t   up  pop
\+ rel-t   ( offset ) #  up  sub	\ Origin in up
   
\- rel-t   20 [bx] up lea
1A0EFD4 	8D 7B 20 
\- rel-t   up 'user up0 mov      \ initialize up0 (needed for future relocation)
1A0EFD7 	89 
1A0EFD8 	7F 4C 
\+ rel-t   up 'user up0 mov      \ initialize up0 (needed for future relocation)

\ Set the value of flat? so later code can determine whether or
\ not it is safe to do things like setting the stack segment descriptor,
\ intercepting exceptions, probing for a DPMI server, etc.

  8 [sp]  ax  mov	\ Caller's CS, or 0 if we are unsegmented
1A0EFDA 	8B 44 24  8 
  ax  ax  or
1A0EFDE 	 9 C0 
  0<>  if
1A0EFE0 	74  7 
     false #  ax  mov	\ CS not zero - we are running segmented
1A0EFE2 	B8  0  0  0  0 
  else
1A0EFE7 	EB 
1A0EFE8 	 5 
     true #  ax  mov	\ CS zero - we are running flat
1A0EFE9 	B8 FF FF FF FF 
  then
  ax  'user flat?  mov
1A0EFEE 	89 87 
1A0EFF0 	F8  2  0  0 

\ Prepare to allocate high memory for the stacks and stuff
\ Allocate buffers from image_end down Hi-RAM allocation pointer

   sp  ax mov
1A0EFF4 	8B C4 

[ifdef] notdef
\ this version is ROMable - and is incompatible with relative addressing
\ Allocate the RAM copy of the User Area
   user-size-t #   sp	sub

\ Copy the initial User Area image to the RAM copy
   rel-t  userarea-t [bx]  si   lea	\ Source address for copy
   sp		    di   mov	\ Destination of copy
   user-size-t #    cx   mov	\ Number of bytes to copy
   cld   rep byte movs

   sp               up   mov	\ Set user pointer
[else]
\- rel-t   userarea-t [bx]  up   lea	\ User pointer
1A0EFF6 	8D 7B 
1A0EFF8 	20 
\+ rel-t   userarea-t [up]  up   lea	\ User pointer
[then]

\ XXX need to swap bytes
\ Set main-task so the exception handler can find the user area
\- rel-t  up   'body main-task [bx]  mov
1A0EFF9 	89 BB 98 EF  0  0 
\+ rel-t  up   'body main-task [up]  mov

   ?bswap-ax
   ax     'user memtop   mov     \ Set heap pointer
1A0EFFF 	89 
1A0F000 	47 5C 


\ At this point, the stack pointer has been set to the top of the stack area
\ and the user pointer has been set to the bottom of the initial user area
\ image.

\ Establish the return stack and set the rp0 user variable
   sp        rp          mov	\ Set rp
1A0F002 	8B EC 
[ifdef] big-endian-t
   rp ax mov
   ?bswap-ax
   ax        'user rp0   mov
[else]
   rp        'user rp0   mov
1A0F004 	89 6F 58 
[then]
   rs-size-t #  sp       sub    \ allocate space for the return stack
1A0F007 	81 
1A0F008 	EC  0  8  0  0 

\ Establish the Parameter Stack
[ifdef] big-endian-t
   sp ax mov
   ?bswap-ax
   ax        'user sp0   mov
[else]
   sp        'user sp0   mov
1A0F00D 	89 67 54 
[then]
   sp           ax       mov
1A0F010 	8B C4 
   ps-size-t #  ax       sub    \ allocate space for the data stack
1A0F012 	2D  0  8  0  0 
   ax      'user limit   mov	\ Set dictionary limit
1A0F017 	89 
1A0F018 	47 28 

\+ rel-t   'user dp  ax  mov
\+ rel-t   up        ax  add
\+ rel-t   ax  'user dp  mov

\ Enter Forth
\- rel-t  'body cold [bx]  ip   lea
1A0F01A 	8D B3 58 ED  0  0 
\+ rel-t  'body cold [up]  ip   lea
also
c;
1A0F020 	FF E7 

OpenFirmware/cpu/x86/boot.fth_AL	9E 1A0F022 
\ Adapted from the version published in the ANS Forth spec.
\ That version was originally developed by Mitch Bradley.

defer headerless
1A0F03C 	 0 68 65 61 
1A0F040 	64 65 72 6C 65 73 73 8A 
1A0F048 	38 F0 A0  1 5C 40 A0  1 
1A0F050 	 4  3  0  0 
defer headers
1A0F054 	68 65 61 64 
1A0F058 	65 72 73 87 4C F0 A0  1 
1A0F060 	5C 40 A0  1  8  3  0  0 


: [else]  ( -- )
1A0F068 	 0 5B 65 6C 73 65 5D C6 
1A0F070 	60 F0 A0  1 20 40 A0  1 
   1  begin						( level )
1A0F078 	80 6F A0  1 
      begin  parse-word dup  while			( level adr len )
1A0F07C 	34 93 A0  1 
1A0F080 	40 49 A0  1 DC 41 A0  1 
1A0F088 	F0  0  0  0 
         $canonical               			( level adr len )
1A0F08C 	FC B9 A0  1 
         2dup s" [if]"     $=        >r			( level adr len )
1A0F090 	C0 49 A0  1 9C 53 A0  1 
1A0F098 	 4 5B 69 66 5D  0  0  0 
1A0F0A0 	88 8D A0  1 BC 45 A0  1 
         2dup s" [ifdef]"  $=  r> or >r			( level adr len )
1A0F0A8 	C0 49 A0  1 9C 53 A0  1 
1A0F0B0 	 7 5B 69 66 64 65 66 5D 
1A0F0B8 	 0  0  0  0 88 8D A0  1 
1A0F0C0 	D0 45 A0  1 70 44 A0  1 
1A0F0C8 	BC 45 A0  1 
         2dup s" [ifndef]" $=  r> or     if		( level adr len )
1A0F0CC 	C0 49 A0  1 
1A0F0D0 	9C 53 A0  1  8 5B 69 66 
1A0F0D8 	6E 64 65 66 5D  0  0  0 
1A0F0E0 	88 8D A0  1 D0 45 A0  1 
1A0F0E8 	70 44 A0  1 DC 41 A0  1 
1A0F0F0 	14  0  0  0 
	    2drop 1+					( level' )
1A0F0F4 	AC 49 A0  1 
1A0F0F8 	30 4B A0  1 
         else						( level adr len )
1A0F0FC 	C8 41 A0  1 
1A0F100 	70  0  0  0 
	    2dup  s" [else]"  $=  if			( level adr len )
1A0F104 	C0 49 A0  1 
1A0F108 	9C 53 A0  1  6 5B 65 6C 
1A0F110 	73 65 5D  0 88 8D A0  1 
1A0F118 	DC 41 A0  1 24  0  0  0 
	       2drop 1- dup  if  1+  then		( level' )
1A0F120 	AC 49 A0  1 54 4B A0  1 
1A0F128 	40 49 A0  1 DC 41 A0  1 
1A0F130 	 8  0  0  0 30 4B A0  1 
	    else					( level adr len )
1A0F138 	C8 41 A0  1 20  0  0  0 
	       s" [then]"  $=  if  1-  then		( level')
1A0F140 	9C 53 A0  1  6 5B 74 68 
1A0F148 	65 6E 5D  0 88 8D A0  1 
1A0F150 	DC 41 A0  1  8  0  0  0 
1A0F158 	54 4B A0  1 
            then					( level' )
	    ?dup 0=  if  exit  then			( level' )
1A0F15C 	B4 70 A0  1 
1A0F160 	24 47 A0  1 DC 41 A0  1 
1A0F168 	 8  0  0  0 40 46 A0  1 
         then						( level' )
      repeat						( level adr len )
1A0F170 	C8 41 A0  1  8 FF FF FF 
      2drop						( level' )
1A0F178 	AC 49 A0  1 
   refill 0= until					( level' )
1A0F17C 	38 E2 A0  1 
1A0F180 	24 47 A0  1 DC 41 A0  1 
1A0F188 	F4 FE FF FF 
   drop
1A0F18C 	30 49 A0  1 
; immediate
1A0F190 	58 46 A0  1 

: [if]  ( flag -- )  0=  if  postpone [else]  then  ; immediate
1A0F194 	 0  0  0 5B 
1A0F198 	69 66 5D C4 74 F0 A0  1 
1A0F1A0 	20 40 A0  1 24 47 A0  1 
1A0F1A8 	DC 41 A0  1  8  0  0  0 
1A0F1B0 	74 F0 A0  1 58 46 A0  1 

: [then]  ( -- )  ;  immediate
1A0F1B8 	 0 5B 74 68 65 6E 5D C6 
1A0F1C0 	A0 F1 A0  1 20 40 A0  1 
1A0F1C8 	58 46 A0  1 

: [ifdef]   ( "name" -- )  defined?      postpone [if]  ; immediate
1A0F1CC 	5B 69 66 64 
1A0F1D0 	65 66 5D C7 C4 F1 A0  1 
1A0F1D8 	20 40 A0  1 DC 93 A0  1 
1A0F1E0 	A0 F1 A0  1 58 46 A0  1 
: [ifndef]  ( "name" -- )  defined?  0=  postpone [if]  ; immediate
1A0F1E8 	 0  0  0 5B 69 66 6E 64 
1A0F1F0 	65 66 5D C8 D8 F1 A0  1 
1A0F1F8 	20 40 A0  1 DC 93 A0  1 
1A0F200 	24 47 A0  1 A0 F1 A0  1 
1A0F208 	58 46 A0  1 

: \+  ( "name" "rest of line" -- )  defined?  0=  if   postpone \  then  ; immediate
1A0F20C 	 0 5C 2B C2 
1A0F210 	F8 F1 A0  1 20 40 A0  1 
1A0F218 	DC 93 A0  1 24 47 A0  1 
1A0F220 	DC 41 A0  1  8  0  0  0 
1A0F228 	74 8A A0  1 58 46 A0  1 
: \-  ( "name" "rest of line" -- )  defined?  if  postpone \  then  ; immediate
1A0F230 	 0 5C 2D C2 14 F2 A0  1 
1A0F238 	20 40 A0  1 DC 93 A0  1 
1A0F240 	DC 41 A0  1  8  0  0  0 
1A0F248 	74 8A A0  1 58 46 A0  1 


OpenFirmware/forth/lib/brackif.fth_AL	214 1A0F250 
\ Warns about stores into the dictionary to help catch non-ROMable code.
forth definitions
: variable   nuser  ;
1A0F284 	 0  0  0 76 
1A0F288 	61 72 69 61 62 6C 65 88 
1A0F290 	7C F2 A0  1 20 40 A0  1 
1A0F298 	24 9A A0  1 58 46 A0  1 
: 2variable  2 /n* ualloc user  ;
1A0F2A0 	 0  0 32 76 61 72 69 61 
1A0F2A8 	62 6C 65 89 94 F2 A0  1 
1A0F2B0 	20 40 A0  1 90 6F A0  1 
1A0F2B8 	98 51 A0  1 90 99 A0  1 
1A0F2C0 	 4 9A A0  1 58 46 A0  1 
: lvariable  /l ualloc user  ;
1A0F2C8 	 0  0 6C 76 61 72 69 61 
1A0F2D0 	62 6C 65 89 B0 F2 A0  1 
1A0F2D8 	20 40 A0  1 30 51 A0  1 
1A0F2E0 	90 99 A0  1  4 9A A0  1 
1A0F2E8 	58 46 A0  1 
: shared-variable  nuser  ;
1A0F2EC 	73 68 61 72 
1A0F2F0 	65 64 2D 76 61 72 69 61 
1A0F2F8 	62 6C 65 8F D8 F2 A0  1 
1A0F300 	20 40 A0  1 24 9A A0  1 
1A0F308 	58 46 A0  1 

OpenFirmware/forth/lib/romable.fth_AL	88 1A0F30C 
vocset=5D8878 1A00334 1A0F30C 
\ This is a vocabulary that can be used to contain implementation words
\ that shouldn't appear in the forth dictionary.  It would nice to have
\ the option to compile such words headerless to save space, but that
\ feature will have to wait till later.  (Besides, headerless words make
\ the decompiler less useful).

only forth also definitions
vocabulary hidden
1A0F30C 	 0 68 69 64 
1A0F310 	64 65 6E 86  0 F3 A0  1 
1A0F318 	E0 B6 A0  1 14  3  0  0 
1A0F320 	 8 C5 A0  1  0  0  0  0 


OpenFirmware/forth/lib/hidden.fth_AL	1C 1A0F328 
\ Temporary hex, and temporary decimal.  "h#" interprets the next word
\ as though the base were hex, regardless of what the base happens to be.
\ "d#" interprets the next word as though the base were decimal.
\ "o#" interprets the next word as though the base were octal.
\ "b#" interprets the next word as though the base were binary.

\  Also, words to stash and set, and retrieve, the base during execution
\     of a word in which they're used.  The words of the form  push-<base>
\     (where <base> is hex, decimal, etcetera) does the equivalent of
\     base @ >r <base>     The word  pop-base  recovers the old base...

decimal
headerless 

: #:  \ name  ( base -- )  \ Define a temporary-numeric-mode word
1A0F328 	 0 23 3A 82 18 F3 A0  1 
1A0F330 	20 40 A0  1 
   create c, immediate
1A0F334 	A8 A2 A0  1 
1A0F338 	B8 55 A0  1 BC B8 A0  1 
   does>
1A0F340 	50 A3 A0  1 90 90 90 E8 
1A0F348 	30 4D FF FF 
   base @ >r  c@ base !
1A0F34C 	B8 75 A0  1 
1A0F350 	5C 4C A0  1 BC 45 A0  1 
1A0F358 	C4 4C A0  1 B8 75 A0  1 
1A0F360 	54 4D A0  1 
   parse-word
1A0F364 	34 93 A0  1 
   2dup 2>r  $handle-literal?  0=  if
1A0F368 	C0 49 A0  1 F8 45 A0  1 
1A0F370 	74 9E A0  1 24 47 A0  1 
1A0F378 	DC 41 A0  1  C  0  0  0 
      2r@  $do-undefined
1A0F380 	28 46 A0  1 FC 9D A0  1 
   then
   2r> 2drop
1A0F388 	10 46 A0  1 AC 49 A0  1 
   r> base !
1A0F390 	D0 45 A0  1 B8 75 A0  1 
1A0F398 	54 4D A0  1 
;
1A0F39C 	58 46 A0  1 

headerless

\ The old names; use h# and d# instead
10 #: td
1A0F3A0 	 0 74 64 C2 30 F3 A0  1 
1A0F3A8 	44 F3 A0  1  A 
16 #: th
1A0F3AD 	74 68 C2 
1A0F3B0 	A8 F3 A0  1 44 F3 A0  1 
1A0F3B8 	10 

headers 

 2 #: b#	\ Binary number
1A0F3B9 	62 23 C2 B4 F3 A0  1 
1A0F3C0 	44 F3 A0  1  2 
 8 #: o#	\ Octal number
1A0F3C5 	6F 23 C2 
1A0F3C8 	C0 F3 A0  1 44 F3 A0  1 
1A0F3D0 	 8 
10 #: d#	\ Decimal number
1A0F3D1 	64 23 C2 CC F3 A0  1 
1A0F3D8 	44 F3 A0  1  A 
16 #: h#	\ Hex number
1A0F3DD 	68 23 C2 
1A0F3E0 	D8 F3 A0  1 44 F3 A0  1 
1A0F3E8 	10 

headerless 

: push-base:  \ name   ( base -- )  \  Define a base stash-and-set word
1A0F3E9 	70 75 73 68 2D 62 61 
1A0F3F0 	73 65 3A 8A E4 F3 A0  1 
1A0F3F8 	20 40 A0  1 
   create c,
1A0F3FC 	A8 A2 A0  1 
1A0F400 	B8 55 A0  1 
   does>  r> base @ >r >r c@ base !
1A0F404 	50 A3 A0  1 
1A0F408 	90 90 90 E8 6C 4C FF FF 
1A0F410 	D0 45 A0  1 B8 75 A0  1 
1A0F418 	5C 4C A0  1 BC 45 A0  1 
1A0F420 	BC 45 A0  1 C4 4C A0  1 
1A0F428 	B8 75 A0  1 54 4D A0  1 
;
1A0F430 	58 46 A0  1 

headers 

\  Stash the old base on the return stack and set the base to ...
10 push-base:  push-decimal
1A0F434 	 0  0  0 70 
1A0F438 	75 73 68 2D 64 65 63 69 
1A0F440 	6D 61 6C 8C F8 F3 A0  1 
1A0F448 	 8 F4 A0  1  A 
16 push-base:  push-hex
1A0F44D 	 0  0 70 
1A0F450 	75 73 68 2D 68 65 78 88 
1A0F458 	48 F4 A0  1  8 F4 A0  1 
1A0F460 	10 

 2 push-base:  push-binary
1A0F461 	 0  0  0 70 75 73 68 
1A0F468 	2D 62 69 6E 61 72 79 8B 
1A0F470 	5C F4 A0  1  8 F4 A0  1 
1A0F478 	 2 
 8 push-base:  push-octal
1A0F479 	70 75 73 68 2D 6F 63 
1A0F480 	74 61 6C 8A 74 F4 A0  1 
1A0F488 	 8 F4 A0  1  8 

\  Retrieve the old base from the return stack

: pop-base ( -- )  r> r> base ! >r ;
1A0F48D 	 0  0 70 
1A0F490 	6F 70 2D 62 61 73 65 88 
1A0F498 	88 F4 A0  1 20 40 A0  1 
1A0F4A0 	D0 45 A0  1 D0 45 A0  1 
1A0F4A8 	B8 75 A0  1 54 4D A0  1 
1A0F4B0 	BC 45 A0  1 58 46 A0  1 

OpenFirmware/forth/lib/th.fth_AL	400 1A0F4B8 purpose: Terminal control for ANSI terminals

headerless
: .esc[        ( -- )     control [ (emit  [char] [ (emit  ;
1A0F4B8 	 0  0 2E 65 73 63 5B 85 
1A0F4C0 	9C F4 A0  1 20 40 A0  1 
1A0F4C8 	58 41 A0  1 1B  0  0  0 
1A0F4D0 	18 6C A0  1 58 41 A0  1 
1A0F4D8 	5B  0  0  0 18 6C A0  1 
1A0F4E0 	58 46 A0  1 
: .esc[x       ( c -- )   .esc[ (emit  ;
1A0F4E4 	 0 2E 65 73 
1A0F4E8 	63 5B 78 86 C4 F4 A0  1 
1A0F4F0 	20 40 A0  1 C4 F4 A0  1 
1A0F4F8 	18 6C A0  1 58 46 A0  1 
: put-n        ( n -- )   push-decimal  (.) (type  pop-base  ;
1A0F500 	 0  0 70 75 74 2D 6E 85 
1A0F508 	F0 F4 A0  1 20 40 A0  1 
1A0F510 	48 F4 A0  1 10 78 A0  1 
1A0F518 	F0 6B A0  1 9C F4 A0  1 
1A0F520 	58 46 A0  1 
: .esc[nx      ( n c -- n )  .esc[ over put-n (emit  ;
1A0F524 	2E 65 73 63 
1A0F528 	5B 6E 78 87  C F5 A0  1 
1A0F530 	20 40 A0  1 C4 F4 A0  1 
1A0F538 	54 49 A0  1  C F5 A0  1 
1A0F540 	18 6C A0  1 58 46 A0  1 
headers

: left         ( -- )     [char] D .esc[x  -1 #out  +!  ;
1A0F548 	 0  0  0 6C 65 66 74 84 
1A0F550 	30 F5 A0  1 20 40 A0  1 
1A0F558 	58 41 A0  1 44  0  0  0 
1A0F560 	F0 F4 A0  1 58 41 A0  1 
1A0F568 	FF FF FF FF 5C 6D A0  1 
1A0F570 	 C 4C A0  1 58 46 A0  1 
: right        ( -- )     [char] C .esc[x   1 #out  +!  ;
1A0F578 	 0  0 72 69 67 68 74 85 
1A0F580 	54 F5 A0  1 20 40 A0  1 
1A0F588 	58 41 A0  1 43  0  0  0 
1A0F590 	F0 F4 A0  1 80 6F A0  1 
1A0F598 	5C 6D A0  1  C 4C A0  1 
1A0F5A0 	58 46 A0  1 
: up           ( -- )     [char] A .esc[x  -1 #line +!  ;
1A0F5A4 	 0 75 70 82 
1A0F5A8 	84 F5 A0  1 20 40 A0  1 
1A0F5B0 	58 41 A0  1 41  0  0  0 
1A0F5B8 	F0 F4 A0  1 58 41 A0  1 
1A0F5C0 	FF FF FF FF 70 6D A0  1 
1A0F5C8 	 C 4C A0  1 58 46 A0  1 
: down         ( -- )     [char] B .esc[x   1 #line +!  ;
1A0F5D0 	 0  0  0 64 6F 77 6E 84 
1A0F5D8 	AC F5 A0  1 20 40 A0  1 
1A0F5E0 	58 41 A0  1 42  0  0  0 
1A0F5E8 	F0 F4 A0  1 80 6F A0  1 
1A0F5F0 	70 6D A0  1  C 4C A0  1 
1A0F5F8 	58 46 A0  1 
: insert-char  ( c -- )   [char] @ .esc[x  (emit ;
1A0F5FC 	69 6E 73 65 
1A0F600 	72 74 2D 63 68 61 72 8B 
1A0F608 	DC F5 A0  1 20 40 A0  1 
1A0F610 	58 41 A0  1 40  0  0  0 
1A0F618 	F0 F4 A0  1 18 6C A0  1 
1A0F620 	58 46 A0  1 
: delete-char  ( -- )     [char] P .esc[x  ;
1A0F624 	64 65 6C 65 
1A0F628 	74 65 2D 63 68 61 72 8B 
1A0F630 	 C F6 A0  1 20 40 A0  1 
1A0F638 	58 41 A0  1 50  0  0  0 
1A0F640 	F0 F4 A0  1 58 46 A0  1 
: kill-line    ( -- )     [char] K .esc[x  ;
1A0F648 	 0  0 6B 69 6C 6C 2D 6C 
1A0F650 	69 6E 65 89 34 F6 A0  1 
1A0F658 	20 40 A0  1 58 41 A0  1 
1A0F660 	4B  0  0  0 F0 F4 A0  1 
1A0F668 	58 46 A0  1 
: kill-screen  ( -- )     [char] J .esc[x  ;
1A0F66C 	6B 69 6C 6C 
1A0F670 	2D 73 63 72 65 65 6E 8B 
1A0F678 	58 F6 A0  1 20 40 A0  1 
1A0F680 	58 41 A0  1 4A  0  0  0 
1A0F688 	F0 F4 A0  1 58 46 A0  1 
: insert-line  ( -- )     [char] L .esc[x  ;
1A0F690 	69 6E 73 65 72 74 2D 6C 
1A0F698 	69 6E 65 8B 7C F6 A0  1 
1A0F6A0 	20 40 A0  1 58 41 A0  1 
1A0F6A8 	4C  0  0  0 F0 F4 A0  1 
1A0F6B0 	58 46 A0  1 
: delete-line  ( -- )     [char] M .esc[x  ;
1A0F6B4 	64 65 6C 65 
1A0F6B8 	74 65 2D 6C 69 6E 65 8B 
1A0F6C0 	A0 F6 A0  1 20 40 A0  1 
1A0F6C8 	58 41 A0  1 4D  0  0  0 
1A0F6D0 	F0 F4 A0  1 58 46 A0  1 
: inverse-video ( -- )    [char] 7 .esc[x  [char] m (emit  ;
1A0F6D8 	 0  0 69 6E 76 65 72 73 
1A0F6E0 	65 2D 76 69 64 65 6F 8D 
1A0F6E8 	C4 F6 A0  1 20 40 A0  1 
1A0F6F0 	58 41 A0  1 37  0  0  0 
1A0F6F8 	F0 F4 A0  1 58 41 A0  1 
1A0F700 	6D  0  0  0 18 6C A0  1 
1A0F708 	58 46 A0  1 

: lefts        ( n -- )   [char] D .esc[nx  negate #out  +!  ;
1A0F70C 	 0  0 6C 65 
1A0F710 	66 74 73 85 EC F6 A0  1 
1A0F718 	20 40 A0  1 58 41 A0  1 
1A0F720 	44  0  0  0 30 F5 A0  1 
1A0F728 	48 45 A0  1 5C 6D A0  1 
1A0F730 	 C 4C A0  1 58 46 A0  1 
: rights       ( n -- )   [char] C .esc[nx         #out  +!  ;
1A0F738 	 0 72 69 67 68 74 73 86 
1A0F740 	18 F7 A0  1 20 40 A0  1 
1A0F748 	58 41 A0  1 43  0  0  0 
1A0F750 	30 F5 A0  1 5C 6D A0  1 
1A0F758 	 C 4C A0  1 58 46 A0  1 
: ups          ( n -- )   [char] A .esc[nx  negate #line +!  ;
1A0F760 	75 70 73 83 44 F7 A0  1 
1A0F768 	20 40 A0  1 58 41 A0  1 
1A0F770 	41  0  0  0 30 F5 A0  1 
1A0F778 	48 45 A0  1 70 6D A0  1 
1A0F780 	 C 4C A0  1 58 46 A0  1 
: downs        ( n -- )   [char] B .esc[nx         #line +!  ;
1A0F788 	 0  0 64 6F 77 6E 73 85 
1A0F790 	68 F7 A0  1 20 40 A0  1 
1A0F798 	58 41 A0  1 42  0  0  0 
1A0F7A0 	30 F5 A0  1 70 6D A0  1 
1A0F7A8 	 C 4C A0  1 58 46 A0  1 

\ Cancel all character attributes - boldness, underline, reverse video, etc.
: cancel       ( -- )     [char] m .esc[x  ;
1A0F7B0 	 0 63 61 6E 63 65 6C 86 
1A0F7B8 	94 F7 A0  1 20 40 A0  1 
1A0F7C0 	58 41 A0  1 6D  0  0  0 
1A0F7C8 	F0 F4 A0  1 58 46 A0  1 

\ Cancel inverse video.  This sequence is not universally supported.
: not-dark     ( -- )     [char] 2 .esc[x  [char] 7 (emit  [char] m (emit  ;
1A0F7D0 	 0  0  0 6E 6F 74 2D 64 
1A0F7D8 	61 72 6B 88 BC F7 A0  1 
1A0F7E0 	20 40 A0  1 58 41 A0  1 
1A0F7E8 	32  0  0  0 F0 F4 A0  1 
1A0F7F0 	58 41 A0  1 37  0  0  0 
1A0F7F8 	18 6C A0  1 58 41 A0  1 
1A0F800 	6D  0  0  0 18 6C A0  1 
1A0F808 	58 46 A0  1 

defer light  ' cancel is light
1A0F80C 	 0  0 6C 69 
1A0F810 	67 68 74 85 E0 F7 A0  1 
1A0F818 	5C 40 A0  1 18  3  0  0 
defer dark   ' inverse-video is dark
1A0F820 	 0  0  0 64 61 72 6B 84 
1A0F828 	18 F8 A0  1 5C 40 A0  1 
1A0F830 	1C  3  0  0 

: at-xy  ( col row -- )
1A0F834 	 0  0 61 74 
1A0F838 	2D 78 79 85 2C F8 A0  1 
1A0F840 	20 40 A0  1 
    2dup #line !  #out !
1A0F844 	C0 49 A0  1 
1A0F848 	70 6D A0  1 54 4D A0  1 
1A0F850 	5C 6D A0  1 54 4D A0  1 
    .esc[   1+ put-n  [char] ; (emit  1+ put-n  [char] H (emit
1A0F858 	C4 F4 A0  1 30 4B A0  1 
1A0F860 	 C F5 A0  1 58 41 A0  1 
1A0F868 	3B  0  0  0 18 6C A0  1 
1A0F870 	30 4B A0  1  C F5 A0  1 
1A0F878 	58 41 A0  1 48  0  0  0 
1A0F880 	18 6C A0  1 
;
1A0F884 	58 46 A0  1 
: page         ( -- )  0 0 at-xy  kill-screen  ;
1A0F888 	 0  0  0 70 61 67 65 84 
1A0F890 	40 F8 A0  1 20 40 A0  1 
1A0F898 	70 6F A0  1 70 6F A0  1 
1A0F8A0 	40 F8 A0  1 7C F6 A0  1 
1A0F8A8 	58 46 A0  1 

true value ansi-colors?
1A0F8AC 	 0  0  0 61 
1A0F8B0 	6E 73 69 2D 63 6F 6C 6F 
1A0F8B8 	72 73 3F 8C 94 F8 A0  1 
1A0F8C0 	50 40 A0  1 20  3  0  0 

headerless
: color:  ( adr len "name" -- )
1A0F8C8 	 0 63 6F 6C 6F 72 3A 86 
1A0F8D0 	C0 F8 A0  1 20 40 A0  1 
   create ",
1A0F8D8 	A8 A2 A0  1 24 89 A0  1 
   does> ansi-colors? if  .esc[  count (type  [char] m (emit  else  drop  then
1A0F8E0 	50 A3 A0  1 90 90 90 E8 
1A0F8E8 	90 47 FF FF C0 F8 A0  1 
1A0F8F0 	DC 41 A0  1 24  0  0  0 
1A0F8F8 	C4 F4 A0  1 BC 53 A0  1 
1A0F900 	F0 6B A0  1 58 41 A0  1 
1A0F908 	6D  0  0  0 18 6C A0  1 
1A0F910 	C8 41 A0  1  8  0  0  0 
1A0F918 	30 49 A0  1 
;
1A0F91C 	58 46 A0  1 
headers
" 0"    color: default-colors
1A0F920 	 0 64 65 66 61 75 6C 74 
1A0F928 	2D 63 6F 6C 6F 72 73 8E 
1A0F930 	D4 F8 A0  1 E4 F8 A0  1 
1A0F938 	 1 30  0  0 
" 1"    color: bright
1A0F93C 	 0 62 72 69 
1A0F940 	67 68 74 86 34 F9 A0  1 
1A0F948 	E4 F8 A0  1  1 31  0  0 
" 2"    color: dim
1A0F950 	64 69 6D 83 48 F9 A0  1 
1A0F958 	E4 F8 A0  1  1 32  0  0 
" 4"	color: underline
1A0F960 	 0  0 75 6E 64 65 72 6C 
1A0F968 	69 6E 65 89 58 F9 A0  1 
1A0F970 	E4 F8 A0  1  1 34  0  0 
" 30"   color: black-letters
1A0F978 	 0  0 62 6C 61 63 6B 2D 
1A0F980 	6C 65 74 74 65 72 73 8D 
1A0F988 	70 F9 A0  1 E4 F8 A0  1 
1A0F990 	 2 33 30  0 
" 31"   color: red-letters
1A0F994 	72 65 64 2D 
1A0F998 	6C 65 74 74 65 72 73 8B 
1A0F9A0 	8C F9 A0  1 E4 F8 A0  1 
1A0F9A8 	 2 33 31  0 
" 32"   color: green-letters
1A0F9AC 	 0  0 67 72 
1A0F9B0 	65 65 6E 2D 6C 65 74 74 
1A0F9B8 	65 72 73 8D A4 F9 A0  1 
1A0F9C0 	E4 F8 A0  1  2 33 32  0 
" 33"   color: yellow-letters
1A0F9C8 	 0 79 65 6C 6C 6F 77 2D 
1A0F9D0 	6C 65 74 74 65 72 73 8E 
1A0F9D8 	C0 F9 A0  1 E4 F8 A0  1 
1A0F9E0 	 2 33 33  0 
" 34"   color: blue-letters
1A0F9E4 	 0  0  0 62 
1A0F9E8 	6C 75 65 2D 6C 65 74 74 
1A0F9F0 	65 72 73 8C DC F9 A0  1 
1A0F9F8 	E4 F8 A0  1  2 33 34  0 
" 35"   color: magenta-letters
1A0FA00 	6D 61 67 65 6E 74 61 2D 
1A0FA08 	6C 65 74 74 65 72 73 8F 
1A0FA10 	F8 F9 A0  1 E4 F8 A0  1 
1A0FA18 	 2 33 35  0 
" 36"   color: cyan-letters
1A0FA1C 	 0  0  0 63 
1A0FA20 	79 61 6E 2D 6C 65 74 74 
1A0FA28 	65 72 73 8C 14 FA A0  1 
1A0FA30 	E4 F8 A0  1  2 33 36  0 
" 37"   color: white-letters
1A0FA38 	 0  0 77 68 69 74 65 2D 
1A0FA40 	6C 65 74 74 65 72 73 8D 
1A0FA48 	30 FA A0  1 E4 F8 A0  1 
1A0FA50 	 2 33 37  0 
" 40"   color: black-screen
1A0FA54 	 0  0  0 62 
1A0FA58 	6C 61 63 6B 2D 73 63 72 
1A0FA60 	65 65 6E 8C 4C FA A0  1 
1A0FA68 	E4 F8 A0  1  2 34 30  0 
" 41"   color: red-screen
1A0FA70 	 0 72 65 64 2D 73 63 72 
1A0FA78 	65 65 6E 8A 68 FA A0  1 
1A0FA80 	E4 F8 A0  1  2 34 31  0 
" 42"   color: green-screen
1A0FA88 	 0  0  0 67 72 65 65 6E 
1A0FA90 	2D 73 63 72 65 65 6E 8C 
1A0FA98 	80 FA A0  1 E4 F8 A0  1 
1A0FAA0 	 2 34 32  0 
" 43"   color: yellow-screen
1A0FAA4 	 0  0 79 65 
1A0FAA8 	6C 6C 6F 77 2D 73 63 72 
1A0FAB0 	65 65 6E 8D 9C FA A0  1 
1A0FAB8 	E4 F8 A0  1  2 34 33  0 
" 44"   color: blue-screen
1A0FAC0 	62 6C 75 65 2D 73 63 72 
1A0FAC8 	65 65 6E 8B B8 FA A0  1 
1A0FAD0 	E4 F8 A0  1  2 34 34  0 
" 45"   color: magenta-screen
1A0FAD8 	 0 6D 61 67 65 6E 74 61 
1A0FAE0 	2D 73 63 72 65 65 6E 8E 
1A0FAE8 	D0 FA A0  1 E4 F8 A0  1 
1A0FAF0 	 2 34 35  0 
" 46"   color: cyan-screen
1A0FAF4 	63 79 61 6E 
1A0FAF8 	2D 73 63 72 65 65 6E 8B 
1A0FB00 	EC FA A0  1 E4 F8 A0  1 
1A0FB08 	 2 34 36  0 
" 47"   color: white-screen
1A0FB0C 	 0  0  0 77 
1A0FB10 	68 69 74 65 2D 73 63 72 
1A0FB18 	65 65 6E 8C  4 FB A0  1 
1A0FB20 	E4 F8 A0  1  2 34 37  0 


OpenFirmware/forth/lib/ansiterm.fth_AL	1648 1A0FB28 purpose: split and join operators

[ifndef] lowbyte
: lowbyte   h# ff and  ;
1A0FB28 	6C 6F 77 62 79 74 65 87 
1A0FB30 	20 FB A0  1 20 40 A0  1 
1A0FB38 	58 41 A0  1 FF  0  0  0 
1A0FB40 	5C 44 A0  1 58 46 A0  1 
[then]

[ifndef] lwsplit
: lwsplit ( l -- w.low w.high )   dup n->w  swap  d# 16 rshift n->w  ;
[then]
[ifndef] wbsplit
: wbsplit ( w -- b.low b.high )   dup lowbyte  swap  d# 8 rshift lowbyte  ;
1A0FB48 	77 62 73 70 6C 69 74 87 
1A0FB50 	34 FB A0  1 20 40 A0  1 
1A0FB58 	40 49 A0  1 34 FB A0  1 
1A0FB60 	68 49 A0  1 58 41 A0  1 
1A0FB68 	 8  0  0  0 B4 44 A0  1 
1A0FB70 	34 FB A0  1 58 46 A0  1 
[then]
[ifndef] bwjoin
: bwjoin  ( b.low b.high -- w )   lowbyte d# 8 lshift swap lowbyte or  ;
1A0FB78 	 0 62 77 6A 6F 69 6E 86 
1A0FB80 	54 FB A0  1 20 40 A0  1 
1A0FB88 	34 FB A0  1 58 41 A0  1 
1A0FB90 	 8  0  0  0 9C 44 A0  1 
1A0FB98 	68 49 A0  1 34 FB A0  1 
1A0FBA0 	70 44 A0  1 58 46 A0  1 
[then]
[ifndef] wljoin
: wljoin  ( w.low w.high -- l )   n->w d# 16 lshift swap n->w or  ;
[then]

64\ : xlsplit ( x -- l.low l.high )   dup n->l  swap  d# 32 rshift n->l  ;
64\ : lxjoin  ( l.low l.high -- x )   n->l d# 32 lshift swap n->l or  ;

: lbsplit ( l -- b.low b.lowmid b.highmid b.high )
1A0FBA8 	6C 62 73 70 6C 69 74 87 
1A0FBB0 	84 FB A0  1 20 40 A0  1 
   lwsplit >r  wbsplit  r>  wbsplit  
1A0FBB8 	A0 4F A0  1 BC 45 A0  1 
1A0FBC0 	54 FB A0  1 D0 45 A0  1 
1A0FBC8 	54 FB A0  1 
;
1A0FBCC 	58 46 A0  1 
: bljoin  ( b.low b.lowmid b.highmid b.high -- l )
1A0FBD0 	 0 62 6C 6A 6F 69 6E 86 
1A0FBD8 	B4 FB A0  1 20 40 A0  1 
   bwjoin >r  bwjoin  r>  wljoin
1A0FBE0 	84 FB A0  1 BC 45 A0  1 
1A0FBE8 	84 FB A0  1 D0 45 A0  1 
1A0FBF0 	D4 4F A0  1 
;
1A0FBF4 	58 46 A0  1 


OpenFirmware/forth/kernel/splits.fth_AL	208 1A0FBF8 purpose: endian-specific operators

[ifndef] le-w@
: le-w@   ( a -- w )   dup    c@ swap ca1+    c@ bwjoin  ;
[then]
[ifndef] be-w@
: be-w@   ( a -- w )   dup ca1+    c@ swap    c@ bwjoin  ;
1A0FBF8 	 0  0 62 65 2D 77 40 85 
1A0FC00 	DC FB A0  1 20 40 A0  1 
1A0FC08 	40 49 A0  1 78 50 A0  1 
1A0FC10 	C4 4C A0  1 68 49 A0  1 
1A0FC18 	C4 4C A0  1 84 FB A0  1 
1A0FC20 	58 46 A0  1 
[then]
[ifndef] le-l@
: le-l@   ( a -- l )   dup le-w@ swap wa1+ le-w@ wljoin  ;
[then]
[ifndef] be-l@
: be-l@   ( a -- l )   dup wa1+ be-w@ swap be-w@ wljoin  ;
1A0FC24 	 0  0 62 65 
1A0FC28 	2D 6C 40 85  4 FC A0  1 
1A0FC30 	20 40 A0  1 40 49 A0  1 
1A0FC38 	A0 50 A0  1  4 FC A0  1 
1A0FC40 	68 49 A0  1  4 FC A0  1 
1A0FC48 	D4 4F A0  1 58 46 A0  1 
[then]

[ifndef] le-w!
: le-w!   ( w a -- )   >r wbsplit r@ ca1+    c! r>    c!  ;
[then]
[ifndef] be-w!
: be-w!   ( w a -- )   >r wbsplit r@    c! r> ca1+    c!  ;
1A0FC50 	 0  0 62 65 2D 77 21 85 
1A0FC58 	30 FC A0  1 20 40 A0  1 
1A0FC60 	BC 45 A0  1 54 FB A0  1 
1A0FC68 	E4 45 A0  1 B8 4D A0  1 
1A0FC70 	D0 45 A0  1 78 50 A0  1 
1A0FC78 	B8 4D A0  1 58 46 A0  1 
[then]
[ifndef] le-l!
: le-l!   ( l a -- )   >r lwsplit r@ wa1+ le-w! r> le-w!  ;
[then]
[ifndef] be-l!
: be-l!   ( l a -- )   >r lwsplit r@ be-w! r> wa1+ be-w!  ;
1A0FC80 	 0  0 62 65 2D 6C 21 85 
1A0FC88 	5C FC A0  1 20 40 A0  1 
1A0FC90 	BC 45 A0  1 A0 4F A0  1 
1A0FC98 	E4 45 A0  1 5C FC A0  1 
1A0FCA0 	D0 45 A0  1 A0 50 A0  1 
1A0FCA8 	5C FC A0  1 58 46 A0  1 
[then]

: le-l,   ( l -- )     here /l allot le-l!  ;
1A0FCB0 	 0  0 6C 65 2D 6C 2C 85 
1A0FCB8 	8C FC A0  1 20 40 A0  1 
1A0FCC0 	70 54 A0  1 30 51 A0  1 
1A0FCC8 	E4 54 A0  1 44 4D A0  1 
1A0FCD0 	58 46 A0  1 
: be-l,   ( l -- )     here /l allot be-l!  ;
1A0FCD4 	 0  0 62 65 
1A0FCD8 	2D 6C 2C 85 BC FC A0  1 
1A0FCE0 	20 40 A0  1 70 54 A0  1 
1A0FCE8 	30 51 A0  1 E4 54 A0  1 
1A0FCF0 	8C FC A0  1 58 46 A0  1 

[ifndef] /x
8 constant /x
1A0FCF8 	 0 2F 78 82 E0 FC A0  1 
1A0FD00 	68 40 A0  1  8  0  0  0 
[then]

32\ : le-x@  ( adr -- d )  dup le-l@  swap la1+ le-l@  ;
1A0FD08 	 0  0 6C 65 2D 78 40 85 
1A0FD10 	 0 FD A0  1 20 40 A0  1 
1A0FD18 	40 49 A0  1 4C 4C A0  1 
1A0FD20 	68 49 A0  1 B4 50 A0  1 
1A0FD28 	4C 4C A0  1 58 46 A0  1 
32\ : be-x@  ( adr -- d )  dup la1+ be-l@  swap be-l@  ;
1A0FD30 	 0  0 62 65 2D 78 40 85 
1A0FD38 	14 FD A0  1 20 40 A0  1 
1A0FD40 	40 49 A0  1 B4 50 A0  1 
1A0FD48 	30 FC A0  1 68 49 A0  1 
1A0FD50 	30 FC A0  1 58 46 A0  1 
32\ : le-x!  ( d adr -- )  tuck la1+ le-l!  le-l!  ;
1A0FD58 	 0  0 6C 65 2D 78 21 85 
1A0FD60 	3C FD A0  1 20 40 A0  1 
1A0FD68 	E8 46 A0  1 B4 50 A0  1 
1A0FD70 	44 4D A0  1 44 4D A0  1 
1A0FD78 	58 46 A0  1 
32\ : be-x!  ( d adr -- )  tuck be-l!  la1+ be-l!  ;
1A0FD7C 	 0  0 62 65 
1A0FD80 	2D 78 21 85 64 FD A0  1 
1A0FD88 	20 40 A0  1 E8 46 A0  1 
1A0FD90 	8C FC A0  1 B4 50 A0  1 
1A0FD98 	8C FC A0  1 58 46 A0  1 

64\ : le-x@   ( a -- l )   dup le-l@  swap la1+ le-l@ lxjoin  ;
64\ : be-x@   ( a -- l )   dup la1+ be-l@  swap be-l@ lxjoin  ;
64\ : le-x!   ( l a -- )   >r xlsplit r@ la1+ le-l! r> le-l!  ;
64\ : be-x!   ( l a -- )   >r xlsplit r@ be-l! r> la1+ be-l!  ;

: le-x,   ( x -- )  here /x allot le-x!  ;
1A0FDA0 	 0  0 6C 65 2D 78 2C 85 
1A0FDA8 	88 FD A0  1 20 40 A0  1 
1A0FDB0 	70 54 A0  1  0 FD A0  1 
1A0FDB8 	E4 54 A0  1 64 FD A0  1 
1A0FDC0 	58 46 A0  1 
: be-x,   ( x -- )  here /x allot be-x!  ;
1A0FDC4 	 0  0 62 65 
1A0FDC8 	2D 78 2C 85 AC FD A0  1 
1A0FDD0 	20 40 A0  1 70 54 A0  1 
1A0FDD8 	 0 FD A0  1 E4 54 A0  1 
1A0FDE0 	88 FD A0  1 58 46 A0  1 

32\ alias be-n@ be-l@
1A0FDE8 	 0  0 62 65 2D 6E 40 A5 
1A0FDF0 	D0 FD A0  1 30 FC A0  1 
32\ alias be-n! be-l!
1A0FDF8 	 0  0 62 65 2D 6E 21 A5 
1A0FE00 	F4 FD A0  1 8C FC A0  1 
32\ alias be-n, be-l,
1A0FE08 	 0  0 62 65 2D 6E 2C A5 
1A0FE10 	 4 FE A0  1 E0 FC A0  1 

64\ alias be-n@ be-x@
64\ alias be-n! be-x!
64\ alias be-n, be-x,

OpenFirmware/forth/kernel/endian.fth_AL	544 1A0FE18 
\ Primitives to concatenate ( "cat ), and print ( ". ) strings.
decimal
headerless

d# 260 buffer: string2
1A0FE18 	73 74 72 69 6E 67 32 87 
1A0FE20 	14 FE A0  1 B4 A9 A0  1 
1A0FE28 	24  3  0  0  4  1  0  0 
1A0FE30 	 0  0 A0  1 

headers
: $number  ( adr len -- true | n false )
1A0FE34 	24 6E 75 6D 
1A0FE38 	62 65 72 87 24 FE A0  1 
1A0FE40 	20 40 A0  1 
   $dnumber?  case
1A0FE44 	9C 9C A0  1 
      0 of  true        endof
1A0FE48 	70 6F A0  1 48 43 A0  1 
1A0FE50 	10  0  0  0  4 70 A0  1 
1A0FE58 	6C 43 A0  1 3C  0  0  0 
      1 of  false       endof
1A0FE60 	80 6F A0  1 48 43 A0  1 
1A0FE68 	10  0  0  0 18 70 A0  1 
1A0FE70 	6C 43 A0  1 24  0  0  0 
      2 of  drop false  endof
1A0FE78 	90 6F A0  1 48 43 A0  1 
1A0FE80 	14  0  0  0 30 49 A0  1 
1A0FE88 	18 70 A0  1 6C 43 A0  1 
1A0FE90 	 8  0  0  0 
   endcase
1A0FE94 	84 43 A0  1 
;
1A0FE98 	58 46 A0  1 

headerless

\ A single to double helper.
\ Sign extends the single if signed? is true
: ?n>d  ( n signed? -- d )   if  s>d  else  0  then  ;
1A0FE9C 	 0  0  0 3F 
1A0FEA0 	6E 3E 64 84 40 FE A0  1 
1A0FEA8 	20 40 A0  1 DC 41 A0  1 
1A0FEB0 	10  0  0  0 9C 68 A0  1 
1A0FEB8 	C8 41 A0  1  8  0  0  0 
1A0FEC0 	70 6F A0  1 58 46 A0  1 

headers
: $dnumber  ( signed adr len -- true | d false )
1A0FEC8 	 0  0  0 24 64 6E 75 6D 
1A0FED0 	62 65 72 88 A8 FE A0  1 
1A0FED8 	20 40 A0  1 
   $dnumber?       ( signed 0 | signed n 1 | signed d 2 )
1A0FEDC 	9C 9C A0  1 
   case
      0 of  drop        true     endof
1A0FEE0 	70 6F A0  1 48 43 A0  1 
1A0FEE8 	14  0  0  0 30 49 A0  1 
1A0FEF0 	 4 70 A0  1 6C 43 A0  1 
1A0FEF8 	48  0  0  0 
      1 of  swap ?n>d   false    endof
1A0FEFC 	80 6F A0  1 
1A0FF00 	48 43 A0  1 18  0  0  0 
1A0FF08 	68 49 A0  1 A8 FE A0  1 
1A0FF10 	18 70 A0  1 6C 43 A0  1 
1A0FF18 	28  0  0  0 
      2 of  rot drop    false    endof
1A0FF1C 	90 6F A0  1 
1A0FF20 	48 43 A0  1 18  0  0  0 
1A0FF28 	7C 49 A0  1 30 49 A0  1 
1A0FF30 	18 70 A0  1 6C 43 A0  1 
1A0FF38 	 8  0  0  0 
   endcase
1A0FF3C 	84 43 A0  1 
;
1A0FF40 	58 46 A0  1 

headerless
: $hnumber  ( adr len -- true | n false )  push-hex  $number  pop-base  ;
1A0FF44 	 0  0  0 24 
1A0FF48 	68 6E 75 6D 62 65 72 88 
1A0FF50 	D8 FE A0  1 20 40 A0  1 
1A0FF58 	5C F4 A0  1 40 FE A0  1 
1A0FF60 	9C F4 A0  1 58 46 A0  1 
headers

\ Here is a direct implementation of $number, except that it doesn't handle
\ DPL, and it allows , in addition to . for number punctuation
\ : $number  ( adr len -- n false | true )
\    1 0 2swap                    ( sign n adr len )
\    bounds  ?do                  ( sign n )
\       i c@  base @ digit  if    ( sign n digit )
\        swap base @ ul* +        ( sign n' )
\       else                      ( sign n char )
\          case                   ( sign n )
\             ascii -  of  swap negate swap  endof    ( -sign n )
\             ascii .  of                    endof    ( sign n )
\             ascii ,  of                    endof    ( sign n )
\           ( sign n char ) drop nip 0 swap leave     ( 0 n )
\          endcase
\       then
\    loop                         ( sign|0 n )
\    over  if                     ( sign n )
\       * false                   ( n' false )
\    else                         ( 0 n )
\       2drop true                ( true )
\    then
\ ;

: $cat2  ( $1 $2 -- $3 )
1A0FF68 	 0  0 24 63 61 74 32 85 
1A0FF70 	54 FF A0  1 20 40 A0  1 
   2 pick over +  dup >r alloc-mem >r
1A0FF78 	90 6F A0  1  C 4A A0  1 
1A0FF80 	54 49 A0  1  4 45 A0  1 
1A0FF88 	40 49 A0  1 BC 45 A0  1 
1A0FF90 	F0 6C A0  1 BC 45 A0  1 
   2swap tuck  r@ swap move           ( $2 $1-len )
1A0FF98 	F4 49 A0  1 E8 46 A0  1 
1A0FFA0 	E4 45 A0  1 68 49 A0  1 
1A0FFA8 	F4 4A A0  1 
   r@ + swap move                     ( )
1A0FFAC 	E4 45 A0  1 
1A0FFB0 	 4 45 A0  1 68 49 A0  1 
1A0FFB8 	F4 4A A0  1 
   r> r>
1A0FFBC 	D0 45 A0  1 
1A0FFC0 	D0 45 A0  1 
;
1A0FFC4 	58 46 A0  1 

OpenFirmware/forth/lib/strings.fth_AL	432 1A0FFC8 
\  Patch utility.  Allows you to make patches to already-defined words.
\   Usage:
\     PATCH new old word-to-patch
\         In the definition of "word-to-patch", replaces the first
\         occurence of "old" with "new".  "new" may be either a word
\         or a number.  "old" may be either a word or a number.
\
\     n-new  n-old  NPATCH  word-to-patch
\         In the definition of "word-to-patch", replaces the first
\         compiled instance of the number "n-old" with the number
\         "n-new".
\
\     n-new  n-old  start-adr  end-adr  (NPATCH
\         replaces the first occurrence of "n-old" in the word "acf"
\         with "n-new"
\
\     acf-new  acf-old  acf  (PATCH
\         replaces the first occurrence of "acf-old" in the word "acf"
\         with "acf-new"
\
\     new new-type   old old-type  acf  (PATCH)
\         replaces the first occurrence of "old" in the word "acf" with "new".
\         If "new-type" is true, "new" is a number, otherwise "new" is an acf.
\         If "old-type" is true, "old" is a number, otherwise "old" is an acf.
\
\     n  start-adr end-adr   SEARCH
\         searches for an occurrence of "n" between start-adr and
\         end-adr.  Leaves the adress where found and a success flag.
\
\     c  start-adr end-adr   CSEARCH
\         searches for a byte between start-adr and end-adr
\
\     w  start-adr end-adr   WSEARCH
\         searches for a 16-bit word between start-adr and end-adr
\
\     acf  start-adr end-adr TSEARCH
\         searches for a compiled adress between start-adr and end-adr
\
\

decimal

: csearch ( c start end -- loc true | false )
1A0FFC8 	63 73 65 61 72 63 68 87 
1A0FFD0 	74 FF A0  1 20 40 A0  1 
   false -rot swap  ?do			( c false )
1A0FFD8 	18 70 A0  1 94 49 A0  1 
1A0FFE0 	68 49 A0  1 50 42 A0  1 
1A0FFE8 	3C  0  0  0 
      over i c@ = if
1A0FFEC 	54 49 A0  1 
1A0FFF0 	B4 42 A0  1 C4 4C A0  1 
1A0FFF8 	24 48 A0  1 DC 41 A0  1 
1A10000 	18  0  0  0 
	 drop i swap true leave
1A10004 	30 49 A0  1 
1A10008 	B4 42 A0  1 68 49 A0  1 
1A10010 	 4 70 A0  1 18 43 A0  1 
      then
   /c +loop  nip
1A10018 	10 51 A0  1 1C 42 A0  1 
1A10020 	CC FF FF FF FC 46 A0  1 
;
1A10028 	58 46 A0  1 
: wsearch  ( w start end -- loc true | false )
1A1002C 	77 73 65 61 
1A10030 	72 63 68 87 D4 FF A0  1 
1A10038 	20 40 A0  1 
   rot n->w		\ strip off any high bits
1A1003C 	7C 49 A0  1 
1A10040 	C0 61 A0  1 
   false 2swap  swap  ?do		( w false )
1A10044 	18 70 A0  1 
1A10048 	F4 49 A0  1 68 49 A0  1 
1A10050 	50 42 A0  1 3C  0  0  0 
      over i w@ = if
1A10058 	54 49 A0  1 B4 42 A0  1 
1A10060 	94 4C A0  1 24 48 A0  1 
1A10068 	DC 41 A0  1 18  0  0  0 
	 drop i swap true leave
1A10070 	30 49 A0  1 B4 42 A0  1 
1A10078 	68 49 A0  1  4 70 A0  1 
1A10080 	18 43 A0  1 
      then
   /w +loop  nip
1A10084 	20 51 A0  1 
1A10088 	1C 42 A0  1 CC FF FF FF 
1A10090 	FC 46 A0  1 
;
1A10094 	58 46 A0  1 
: tsearch  ( adr start end -- loc true | false )
1A10098 	74 73 65 61 72 63 68 87 
1A100A0 	38  0 A1  1 20 40 A0  1 
   false -rot  swap  ?do			( targ false )
1A100A8 	18 70 A0  1 94 49 A0  1 
1A100B0 	68 49 A0  1 50 42 A0  1 
1A100B8 	3C  0  0  0 
      over i token@ = if
1A100BC 	54 49 A0  1 
1A100C0 	B4 42 A0  1  C 54 A0  1 
1A100C8 	24 48 A0  1 DC 41 A0  1 
1A100D0 	18  0  0  0 
	 drop i swap true leave
1A100D4 	30 49 A0  1 
1A100D8 	B4 42 A0  1 68 49 A0  1 
1A100E0 	 4 70 A0  1 18 43 A0  1 
      then
      \ Can't use /token because tokens could be 32-bits, aligned on 16-bit
      \ boundaries, with 16-bit branch offsets realigning the token list.
   #talign +loop  nip
1A100E8 	68 5A A0  1 1C 42 A0  1 
1A100F0 	CC FF FF FF FC 46 A0  1 
;
1A100F8 	58 46 A0  1 
: search  ( n start end -- loc true | false )
1A100FC 	 0 73 65 61 
1A10100 	72 63 68 86 A4  0 A1  1 
1A10108 	20 40 A0  1 
   false -rot  swap  ?do		( n false )
1A1010C 	18 70 A0  1 
1A10110 	94 49 A0  1 68 49 A0  1 
1A10118 	50 42 A0  1 3C  0  0  0 
      over i @ = if
1A10120 	54 49 A0  1 B4 42 A0  1 
1A10128 	5C 4C A0  1 24 48 A0  1 
1A10130 	DC 41 A0  1 18  0  0  0 
	 drop i swap true leave
1A10138 	30 49 A0  1 B4 42 A0  1 
1A10140 	68 49 A0  1  4 70 A0  1 
1A10148 	18 43 A0  1 
      then
   #talign +loop  nip
1A1014C 	68 5A A0  1 
1A10150 	1C 42 A0  1 CC FF FF FF 
1A10158 	FC 46 A0  1 
;
1A1015C 	58 46 A0  1 

headerless

: next-token  ( adr -- adr token )
1A10160 	 0 6E 65 78 74 2D 74 6F 
1A10168 	6B 65 6E 8A  8  1 A1  1 
1A10170 	20 40 A0  1 
   dup token@                 ( n adr token )
1A10174 	40 49 A0  1 
1A10178 	 C 54 A0  1 
   dup ['] unnest =  abort" Can't find word to replace"   ( n adr token )
1A1017C 	40 49 A0  1 
1A10180 	60 53 A0  1 58 46 A0  1 
1A10188 	24 48 A0  1  8 81 A0  1 
1A10190 	1A 43 61 6E 27 74 20 66 
1A10198 	69 6E 64 20 77 6F 72 64 
1A101A0 	20 74 6F 20 72 65 70 6C 
1A101A8 	61 63 65  0 
;
1A101AC 	58 46 A0  1 

\ Can't use ta1+ because tokens could be 32-bits, aligned on 16-bit
\ boundaries, with 16-bit branch offsets realigning the token list.
: talign+  ( adr -- adr' )  #talign +  ;
1A101B0 	74 61 6C 69 67 6E 2B 87 
1A101B8 	70  1 A1  1 20 40 A0  1 
1A101C0 	68 5A A0  1  4 45 A0  1 
1A101C8 	58 46 A0  1 

: find-lit  ( n acf -- adr )
1A101CC 	 0  0  0 66 
1A101D0 	69 6E 64 2D 6C 69 74 88 
1A101D8 	BC  1 A1  1 20 40 A0  1 
   >body
1A101E0 	E4 59 A0  1 
   begin
      next-token                 ( n adr token )
1A101E4 	70  1 A1  1 
\t16  dup  ['] (wlit)  =  if     ( n adr token )
\t16     drop                    ( n adr )
\t16     2dup ta1+ w@ 1-  =  if  ( n adr )
\t16        nip exit             ( adr )
\t16     else                    ( n adr )
\t16        ta1+ wa1+            ( n adr' )
\t16     then                    ( n adr )
\t16  else                       ( n adr token )
       dup  ['] (lit) =  if      ( n adr token )
1A101E8 	40 49 A0  1 60 53 A0  1 
1A101F0 	58 41 A0  1 24 48 A0  1 
1A101F8 	DC 41 A0  1 40  0  0  0 
	  drop                   ( n adr )
1A10200 	30 49 A0  1 
	  2dup ta1+ @  =  if     ( n adr )
1A10204 	C0 49 A0  1 
1A10208 	FC 50 A0  1 5C 4C A0  1 
1A10210 	24 48 A0  1 DC 41 A0  1 
1A10218 	14  0  0  0 
	     nip exit            ( adr )
1A1021C 	FC 46 A0  1 
1A10220 	40 46 A0  1 
	  else                   ( n adr )
1A10224 	C8 41 A0  1 
1A10228 	 C  0  0  0 
	     ta1+ na1+           ( n adr' )
1A1022C 	FC 50 A0  1 
1A10230 	CC 50 A0  1 
	  then                   ( n adr )
       else                      ( n adr token )
1A10234 	C8 41 A0  1 
1A10238 	58  0  0  0 
	  ['] (llit) =  if       ( n adr )
1A1023C 	60 53 A0  1 
1A10240 	6C 41 A0  1 24 48 A0  1 
1A10248 	DC 41 A0  1 40  0  0  0 
	     2dup ta1+ l@ 1-  =  if  ( n adr )
1A10250 	C0 49 A0  1 FC 50 A0  1 
1A10258 	6C 4C A0  1 54 4B A0  1 
1A10260 	24 48 A0  1 DC 41 A0  1 
1A10268 	14  0  0  0 
		nip exit             ( adr )
1A1026C 	FC 46 A0  1 
1A10270 	40 46 A0  1 
	     else                    ( n adr )
1A10274 	C8 41 A0  1 
1A10278 	 C  0  0  0 
		ta1+ la1+            ( n adr' )
1A1027C 	FC 50 A0  1 
1A10280 	B4 50 A0  1 
	     then                    ( n adr' )
	  else                       ( n adr )
1A10284 	C8 41 A0  1 
1A10288 	 8  0  0  0 
	     talign+                 ( n adr' )
1A1028C 	BC  1 A1  1 
	  then                       ( n adr' )
       then                          ( n adr' )
\t16 then
   again
1A10290 	C8 41 A0  1 50 FF FF FF 
;
1A10298 	58 46 A0  1 

: find-token  ( n acf -- adr )
1A1029C 	 0 66 69 6E 
1A102A0 	64 2D 74 6F 6B 65 6E 8A 
1A102A8 	DC  1 A1  1 20 40 A0  1 
   >body
1A102B0 	E4 59 A0  1 
   begin
      next-token                    ( n adr token )
1A102B4 	70  1 A1  1 
      2 pick =  if  nip exit  then  ( n adr )
1A102B8 	90 6F A0  1  C 4A A0  1 
1A102C0 	24 48 A0  1 DC 41 A0  1 
1A102C8 	 C  0  0  0 FC 46 A0  1 
1A102D0 	40 46 A0  1 
      talign+                       ( n adr' )
1A102D4 	BC  1 A1  1 
   again
1A102D8 	C8 41 A0  1 D8 FF FF FF 
;
1A102E0 	58 46 A0  1 

: make-name  ( n digit -- adr len )
1A102E4 	 0  0 6D 61 
1A102E8 	6B 65 2D 6E 61 6D 65 89 
1A102F0 	AC  2 A1  1 20 40 A0  1 
   >r  <# u#s ascii # hold  r> hold u#>   ( adr len )
1A102F8 	BC 45 A0  1  8 76 A0  1 
1A10300 	BC 76 A0  1 58 41 A0  1 
1A10308 	23  0  0  0 DC 75 A0  1 
1A10310 	D0 45 A0  1 DC 75 A0  1 
1A10318 	E0 76 A0  1 
;
1A1031C 	58 46 A0  1 

: put-constant  ( n adr -- )
1A10320 	 0  0  0 70 75 74 2D 63 
1A10328 	6F 6E 73 74 61 6E 74 8C 
1A10330 	F4  2 A1  1 20 40 A0  1 
   over
1A10338 	54 49 A0  1 
   base @  d# 16 =  if
1A1033C 	B8 75 A0  1 
1A10340 	5C 4C A0  1 58 41 A0  1 
1A10348 	10  0  0  0 24 48 A0  1 
1A10350 	DC 41 A0  1 18  0  0  0 
      ascii h make-name
1A10358 	58 41 A0  1 68  0  0  0 
1A10360 	F4  2 A1  1 
   else
1A10364 	C8 41 A0  1 
1A10368 	18  0  0  0 
      push-decimal
1A1036C 	48 F4 A0  1 
      ascii d make-name
1A10370 	58 41 A0  1 64  0  0  0 
1A10378 	F4  2 A1  1 
      pop-base
1A1037C 	9C F4 A0  1 
   then                           ( n adr name-adr name-len )

   \ We don't use  "create .. does> @  because we want this word
   \ to decompile as 'constant'

   warning @ >r  warning off
1A10380 	E4 9A A0  1 5C 4C A0  1 
1A10388 	BC 45 A0  1 E4 9A A0  1 
1A10390 	F8 4B A0  1 
   $header       ( n adr )
1A10394 	C8 6D A0  1 
   constant-cf swap ,             ( adr )
1A10398 	 C 5C A0  1 68 49 A0  1 
1A103A0 	98 55 A0  1 
   r> warning !
1A103A4 	D0 45 A0  1 
1A103A8 	E4 9A A0  1 54 4D A0  1 

   lastacf swap token!
1A103B0 	AC 57 A0  1 68 49 A0  1 
1A103B8 	20 54 A0  1 
;
1A103BC 	58 46 A0  1 

: put-noop  ( adr -- )  ta1+  ['] noop swap token!  ;
1A103C0 	 0  0  0 70 75 74 2D 6E 
1A103C8 	6F 6F 70 88 34  3 A1  1 
1A103D0 	20 40 A0  1 FC 50 A0  1 
1A103D8 	60 53 A0  1 64 4F A0  1 
1A103E0 	68 49 A0  1 20 54 A0  1 
1A103E8 	58 46 A0  1 

\t16 : short-number?  ( n -- flag )  -1  h# fffe  between  ;
\t32 : long-number?  ( n -- flag )  -1  h# fffffffe n->l between  ;
1A103EC 	 0  0  0 6C 
1A103F0 	6F 6E 67 2D 6E 75 6D 62 
1A103F8 	65 72 3F 8C D0  3 A1  1 
1A10400 	20 40 A0  1 58 41 A0  1 
1A10408 	FF FF FF FF 58 41 A0  1 
1A10410 	FE FF FF FF 74 4F A0  1 
1A10418 	D8 70 A0  1 58 46 A0  1 

headers
: (patch)  ( new number?  old number?  word -- )
1A10420 	28 70 61 74 63 68 29 87 
1A10428 	 0  4 A1  1 20 40 A0  1 
   swap  if                         ( new number? old acf )  \ Dest. is num
1A10430 	68 49 A0  1 DC 41 A0  1 
1A10438 	94  0  0  0 
      find-lit                      ( new number? adr )
1A1043C 	DC  1 A1  1 

\t16  dup token@ ['] (wlit) =  if   ( new number? old )  \ Dest. slot is wlit
\t16     swap  if                   ( new adr )   \ replacement is a number
\t16        over short-number?  if  ( new adr )   \ replacement is short num
\t16           ta1+ swap 1+ swap w! ( )
\t16           exit
\t16        then                    ( new adr )   \ Replacement is long num
\t16        tuck put-constant       ( adr )
\t16        put-noop                ( )
\t16        exit
\t16     then                       ( new adr )  \ replacement is a word
\t16     tuck token!  put-noop      ( )
\t16     exit
\t16  then                          ( new number? adr )  \ Dest. slot is lit

\t32  dup token@ ['] (llit) =  if   ( new number? old )  \ Dest. slot is wlit
1A10440 	40 49 A0  1  C 54 A0  1 
1A10448 	60 53 A0  1 6C 41 A0  1 
1A10450 	24 48 A0  1 DC 41 A0  1 
1A10458 	4C  0  0  0 
\t32     swap  if                   ( new adr )   \ replacement is a number
1A1045C 	68 49 A0  1 
1A10460 	DC 41 A0  1 30  0  0  0 
\t32        over long-number?  if   ( new adr )   \ replacement is short num
1A10468 	54 49 A0  1  0  4 A1  1 
1A10470 	DC 41 A0  1 10  0  0  0 
64\ \t32       ta1+ swap 1+ swap l! ( )
32\ \t32       ta1+ l!              ( )
1A10478 	FC 50 A0  1 7C 4D A0  1 
\t32           exit
1A10480 	40 46 A0  1 
\t32        then                    ( new adr )   \ Replacement is long num
\t32        tuck put-constant       ( adr )
1A10484 	E8 46 A0  1 
1A10488 	34  3 A1  1 
\t32        put-noop                ( )
1A1048C 	D0  3 A1  1 
\t32        exit
1A10490 	40 46 A0  1 
\t32     then                       ( new adr )  \ replacement is a word
\t32     tuck token!  put-noop      ( )
1A10494 	E8 46 A0  1 
1A10498 	20 54 A0  1 D0  3 A1  1 
\t32     exit
1A104A0 	40 46 A0  1 
\t32  then                          ( new number? adr )  \ Dest. slot is lit

      swap  if  ta1+ !  exit  then  ( new adr )  \ replacement is a word
1A104A4 	68 49 A0  1 
1A104A8 	DC 41 A0  1 10  0  0  0 
1A104B0 	FC 50 A0  1 54 4D A0  1 
1A104B8 	40 46 A0  1 

      tuck token!                   ( adr )
1A104BC 	E8 46 A0  1 
1A104C0 	20 54 A0  1 
32\ \t16  dup put-noop  ta1+               ( )
64\ \t16  dup put-noop  ta1+ dup put-noop  dup put-noop  ta1+  ( )
64\ \t32  dup put-noop  ta1+
      put-noop                             ( )
1A104C4 	D0  3 A1  1 
      exit
1A104C8 	40 46 A0  1 
   then                             ( new number? old acf )  \ Dest. is token

   find-token                       ( new number? adr )
1A104CC 	AC  2 A1  1 
   swap if  put-constant exit  then ( new adr )  \ replacement is a number
1A104D0 	68 49 A0  1 DC 41 A0  1 
1A104D8 	 C  0  0  0 34  3 A1  1 
1A104E0 	40 46 A0  1 
   token!
1A104E4 	20 54 A0  1 
;
1A104E8 	58 46 A0  1 

headerless
: get-word-type  \ word  ( -- val number? )
1A104EC 	 0  0 67 65 
1A104F0 	74 2D 77 6F 72 64 2D 74 
1A104F8 	79 70 65 8D 2C  4 A1  1 
1A10500 	20 40 A0  1 
   parse-word  $find  if  false exit  then  ( adr len )
1A10504 	34 93 A0  1 
1A10508 	C4 93 A0  1 DC 41 A0  1 
1A10510 	 C  0  0  0 18 70 A0  1 
1A10518 	40 46 A0  1 
   $dnumber?  1 <> abort" ?"  true
1A1051C 	9C 9C A0  1 
1A10520 	80 6F A0  1 44 48 A0  1 
1A10528 	 8 81 A0  1  1 3F  0  0 
1A10530 	 4 70 A0  1 
;
1A10534 	58 46 A0  1 

headers
: (npatch  ( newn oldn acf -- )  >r true tuck  r>  (patch)  ;
1A10538 	28 6E 70 61 74 63 68 87 
1A10540 	 0  5 A1  1 20 40 A0  1 
1A10548 	BC 45 A0  1  4 70 A0  1 
1A10550 	E8 46 A0  1 D0 45 A0  1 
1A10558 	2C  4 A1  1 58 46 A0  1 

: (patch  ( new-acf old-acf acf -- )  >r false tuck r>  (patch)  ;
1A10560 	 0 28 70 61 74 63 68 86 
1A10568 	44  5 A1  1 20 40 A0  1 
1A10570 	BC 45 A0  1 18 70 A0  1 
1A10578 	E8 46 A0  1 D0 45 A0  1 
1A10580 	2C  4 A1  1 58 46 A0  1 

\ substitute new for first occurrence of old in word "name"
: npatch  \ name  ( new old -- )
1A10588 	 0 6E 70 61 74 63 68 86 
1A10590 	6C  5 A1  1 20 40 A0  1 
   true tuck  '  ( new true old true acf )  (patch)
1A10598 	 4 70 A0  1 E8 46 A0  1 
1A105A0 	F8 95 A0  1 2C  4 A1  1 
;
1A105A8 	58 46 A0  1 

: patch  \ new old word  ( -- )
1A105AC 	 0  0 70 61 
1A105B0 	74 63 68 85 94  5 A1  1 
1A105B8 	20 40 A0  1 
   get-word-type   get-word-type  '  (patch)
1A105BC 	 0  5 A1  1 
1A105C0 	 0  5 A1  1 F8 95 A0  1 
1A105C8 	2C  4 A1  1 
;
1A105CC 	58 46 A0  1 


OpenFirmware/forth/lib/patch.fth_AL	1544 1A105D0 id: @(#)cirstack.fth 1.6 03/12/08 13:22:21
purpose: 

\ Circular stack defining words
\
\ 10 cirstack: foo    Create a new stack named foo with space for 10 numbers
\ 123 foo push        Push the number 123 on the stack foo
\ foo pop             Pop the top element from the stack foo onto the data stack
\
\ Advantages of a circular stack:
\    does not have to be cleared
\    cannot overflow or underflow
\
\ Disadvantages:
\    can silently lose data
\    implementation is cumbersome
\
\ Applications:
\    Useful for implementing user interfaces where you want to remember a
\    limited amount of "history", such as the last n commands, or the
\    last n directories "visited", but it is not necessary to guarantee
\    unlimited backtracking.

\ Implementation notes:
\    The circular stack data structure contains the following elements:
\        stack data   Space to store the stacked numbers
\        current      Offset into stack data of the next element to pop
\        limit        Size of stack data plus 1 cell
\
\    The elements are located as follows:
\        pfa:   user#   limit
\
\    user# is the offset of a user area location containing the address of
\    an allocated memory buffer.  That buffer contains "current" and "stack
\    data".
\
\    Note that this parameter field is intentionally the same as the parameter
\    field of word defined by "buffer:".  This allows us to automatically
\    allocate the necessary storage space using the buffer: mechanism.
\
\        user area location:  buffer-address
\        buffer-address:      current   stack-data ...

headerless
\ Implementation factor
: stack-params  ( stack -- adr limit current )
1A105D0 	 0  0  0 73 74 61 63 6B 
1A105D8 	2D 70 61 72 61 6D 73 8C 
1A105E0 	B8  5 A1  1 20 40 A0  1 
   dup  /user# + unaligned-@  /n -  ( stack limit )
1A105E8 	40 49 A0  1 40 5A A0  1 
1A105F0 	 4 45 A0  1 E0 4C A0  1 
1A105F8 	40 51 A0  1 18 45 A0  1 
   swap do-buffer                   ( limit adr )
1A10600 	68 49 A0  1 34 A9 A0  1 
   tuck @                           ( adr limit current )
1A10608 	E8 46 A0  1 5C 4C A0  1 
;
1A10610 	58 46 A0  1 
headers

\ Creates a new stack
: circular-stack:  \ name  ( #entries -- )
1A10614 	63 69 72 63 
1A10618 	75 6C 61 72 2D 73 74 61 
1A10620 	63 6B 3A 8F E4  5 A1  1 
1A10628 	20 40 A0  1 
   create
1A1062C 	A8 A2 A0  1 
   here body> swap    ( acf #entries )
1A10630 	70 54 A0  1 C8 59 A0  1 
1A10638 	68 49 A0  1 
   1+ /n*             ( acf size )
1A1063C 	30 4B A0  1 
1A10640 	98 51 A0  1 
   0 /n user#,  !     ( acf size )  ,   ( acf )
1A10644 	70 6F A0  1 
1A10648 	40 51 A0  1 84 9A A0  1 
1A10650 	54 4D A0  1 98 55 A0  1 
   buffer-link a@  a,  buffer-link a!
1A10658 	D0 A8 A0  1 88 58 A0  1 
1A10660 	AC 58 A0  1 D0 A8 A0  1 
1A10668 	98 58 A0  1 
;
1A1066C 	58 46 A0  1 

\ Adds a number to the stack
: push  ( n stack -- )
1A10670 	 0  0  0 70 75 73 68 84 
1A10678 	28  6 A1  1 20 40 A0  1 
   stack-params  na1+       ( n adr limit next )
1A10680 	E4  5 A1  1 CC 50 A0  1 
   tuck  <=  if             ( n adr next )
1A10688 	E8 46 A0  1  C 49 A0  1 
1A10690 	DC 41 A0  1  C  0  0  0 
      drop 0                ( n adr next' )     \ Wrap around
1A10698 	30 49 A0  1 70 6F A0  1 
   then                     ( n adr next' )
   2dup swap !              ( n adr next' )
1A106A0 	C0 49 A0  1 68 49 A0  1 
1A106A8 	54 4D A0  1 
   + na1+ !
1A106AC 	 4 45 A0  1 
1A106B0 	CC 50 A0  1 54 4D A0  1 
;
1A106B8 	58 46 A0  1 

\ Removes a number from the stack
: pop  ( stack -- n )
1A106BC 	70 6F 70 83 
1A106C0 	7C  6 A1  1 20 40 A0  1 
   stack-params             ( adr limit current )
1A106C8 	E4  5 A1  1 
   ?dup  if                 ( adr limit current )
1A106CC 	B4 70 A0  1 
1A106D0 	DC 41 A0  1 28  0  0  0 
      nip 2dup /n - swap !  ( adr current )     \ Decrement current
1A106D8 	FC 46 A0  1 C0 49 A0  1 
1A106E0 	40 51 A0  1 18 45 A0  1 
1A106E8 	68 49 A0  1 54 4D A0  1 
      +                     ( data-adr- )
1A106F0 	 4 45 A0  1 
   else                     ( adr limit )
1A106F4 	C8 41 A0  1 
1A106F8 	14  0  0  0 
      /n - over !           ( data-adr- )       \ Wrap around
1A106FC 	40 51 A0  1 
1A10700 	18 45 A0  1 54 49 A0  1 
1A10708 	54 4D A0  1 
   then
   na1+ @
1A1070C 	CC 50 A0  1 
1A10710 	5C 4C A0  1 
;
1A10714 	58 46 A0  1 

\ Returns, without popping, the number on top of the stack
: top@  ( stack -- n )
1A10718 	 0  0  0 74 6F 70 40 84 
1A10720 	C4  6 A1  1 20 40 A0  1 
   stack-params             ( adr limit current )
1A10728 	E4  5 A1  1 
   dup  if                  ( adr limit current )
1A1072C 	40 49 A0  1 
1A10730 	DC 41 A0  1 14  0  0  0 
      nip  +                ( data-adr- )
1A10738 	FC 46 A0  1  4 45 A0  1 
   else                     ( adr limit current )
1A10740 	C8 41 A0  1  8  0  0  0 
      2drop                 ( data-adr- )       \ Wrap around
1A10748 	AC 49 A0  1 
   then
   na1+ @
1A1074C 	CC 50 A0  1 
1A10750 	5C 4C A0  1 
;
1A10754 	58 46 A0  1 

OpenFirmware/forth/lib/cirstack.fth_AL	392 1A10758 
\ Implements needs and \needs.  These work as follows:
\
\ needs foo tools.fth
\
\ If foo is not defined, the file tools.fth will be loaded, which should
\ define foo.  If foo is already defined, nothing will happen.
\
\ \needs foo <arbitrary Forth commands>
\
\ If foo is not defined, the rest of the line is executed, else it is ignored

: needs  \ wordname filename  ( -- )
1A10758 	 0  0 6E 65 65 64 73 85 
1A10760 	24  7 A1  1 20 40 A0  1 
   safe-parse-word $canonical $find  if  ( cfa +-1 )
1A10768 	88 93 A0  1 FC B9 A0  1 
1A10770 	C4 93 A0  1 DC 41 A0  1 
1A10778 	18  0  0  0 
      drop  safe-parse-word 2drop
1A1077C 	30 49 A0  1 
1A10780 	88 93 A0  1 AC 49 A0  1 
   else
1A10788 	C8 41 A0  1 10  0  0  0 
      2drop safe-parse-word included
1A10790 	AC 49 A0  1 88 93 A0  1 
1A10798 	C8 E8 A0  1 
   then
;
1A1079C 	58 46 A0  1 
: \needs ( -- ) ( Input Stream: desired-word  more-forth-commands )
1A107A0 	 0 5C 6E 65 65 64 73 86 
1A107A8 	64  7 A1  1 20 40 A0  1 
   safe-parse-word $canonical $find  if  ( cfa +-1 )
1A107B0 	88 93 A0  1 FC B9 A0  1 
1A107B8 	C4 93 A0  1 DC 41 A0  1 
1A107C0 	14  0  0  0 
      drop  postpone \
1A107C4 	30 49 A0  1 
1A107C8 	74 8A A0  1 
   else                                  ( adr len )
1A107CC 	C8 41 A0  1 
1A107D0 	 8  0  0  0 
      2drop
1A107D4 	AC 49 A0  1 
   then
;
1A107D8 	58 46 A0  1 


OpenFirmware/forth/lib/needs.fth_AL	132 1A107DC 
\ Smart keyboard driven exit
\ Type q to abort the listing, anything else to pause it.
\ While it's paused, type q to abort, anything else to resume.

decimal

only forth also hidden also
hidden definitions

headerless
variable 1-more-line?  1-more-line? off
1A107DC 	 0  0  0 31 
1A107E0 	2D 6D 6F 72 65 2D 6C 69 
1A107E8 	6E 65 3F 8C  0  0 A0  1 
1A107F0 	48 40 A0  1 28  3  0  0 
true value page-mode?
1A107F8 	 0 70 61 67 65 2D 6D 6F 
1A10800 	64 65 3F 8A F0  7 A1  1 
1A10808 	50 40 A0  1 2C  3  0  0 

forth definitions
headers
: no-page    ( -- )  false is page-mode?  ;
1A10810 	6E 6F 2D 70 61 67 65 87 
1A10818 	AC  7 A1  1 20 40 A0  1 
1A10820 	18 70 A0  1 B8 40 A0  1 
1A10828 	 8  8 A1  1 58 46 A0  1 
: page-mode  ( -- )  true  is page-mode?  ;
1A10830 	 0  0 70 61 67 65 2D 6D 
1A10838 	6F 64 65 89 1C  8 A1  1 
1A10840 	20 40 A0  1  4 70 A0  1 
1A10848 	B8 40 A0  1  8  8 A1  1 
1A10850 	58 46 A0  1 
headerless
: suspend-help  ( -- )
1A10854 	 0  0  0 73 
1A10858 	75 73 70 65 6E 64 2D 68 
1A10860 	65 6C 70 8C 40  8 A1  1 
1A10868 	20 40 A0  1 
   ." Pager keys:" cr
1A1086C 	20 7C A0  1 
1A10870 	 B 50 61 67 65 72 20 6B 
1A10878 	65 79 73 3A  0  0  0  0 
1A10880 	80 6D A0  1 
   ."  <space>   Another page" cr
1A10884 	20 7C A0  1 
1A10888 	17 20 3C 73 70 61 63 65 
1A10890 	3E 20 20 20 41 6E 6F 74 
1A10898 	68 65 72 20 70 61 67 65 
1A108A0 	 0  0  0  0 80 6D A0  1 
   ."  <cr>      Another line" cr
1A108A8 	20 7C A0  1 17 20 3C 63 
1A108B0 	72 3E 20 20 20 20 20 20 
1A108B8 	41 6E 6F 74 68 65 72 20 
1A108C0 	6C 69 6E 65  0  0  0  0 
1A108C8 	80 6D A0  1 
   ."  q         Quit" cr
1A108CC 	20 7C A0  1 
1A108D0 	 F 20 71 20 20 20 20 20 
1A108D8 	20 20 20 20 51 75 69 74 
1A108E0 	 0  0  0  0 80 6D A0  1 
   ."  c         Page Mode Off" cr
1A108E8 	20 7C A0  1 18 20 63 20 
1A108F0 	20 20 20 20 20 20 20 20 
1A108F8 	50 61 67 65 20 4D 6F 64 
1A10900 	65 20 4F 66 66  0  0  0 
1A10908 	80 6D A0  1 
   ."  p         Page Mode On" cr
1A1090C 	20 7C A0  1 
1A10910 	17 20 70 20 20 20 20 20 
1A10918 	20 20 20 20 50 61 67 65 
1A10920 	20 4D 6F 64 65 20 4F 6E 
1A10928 	 0  0  0  0 80 6D A0  1 
   ."  i         Interact" cr
1A10930 	20 7C A0  1 13 20 69 20 
1A10938 	20 20 20 20 20 20 20 20 
1A10940 	49 6E 74 65 72 61 63 74 
1A10948 	 0  0  0  0 80 6D A0  1 
   ."  d         Debug" cr
1A10950 	20 7C A0  1 10 20 64 20 
1A10958 	20 20 20 20 20 20 20 20 
1A10960 	44 65 62 75 67  0  0  0 
1A10968 	80 6D A0  1 
   ."  h or ?    Help (this message)" cr
1A1096C 	20 7C A0  1 
1A10970 	1E 20 68 20 6F 72 20 3F 
1A10978 	20 20 20 20 48 65 6C 70 
1A10980 	20 28 74 68 69 73 20 6D 
1A10988 	65 73 73 61 67 65 29  0 
1A10990 	80 6D A0  1 
;
1A10994 	58 46 A0  1 
: suspend-interact  ( -- )  ." Type 'resume' to continue" cr  interact  ;
1A10998 	 0  0  0 73 75 73 70 65 
1A109A0 	6E 64 2D 69 6E 74 65 72 
1A109A8 	61 63 74 90 68  8 A1  1 
1A109B0 	20 40 A0  1 20 7C A0  1 
1A109B8 	19 54 79 70 65 20 27 72 
1A109C0 	65 73 75 6D 65 27 20 74 
1A109C8 	6F 20 63 6F 6E 74 69 6E 
1A109D0 	75 65  0  0 80 6D A0  1 
1A109D8 	E0 E4 A0  1 58 46 A0  1 
defer suspend-debug  ( -- )   ' noop is suspend-debug
1A109E0 	 0  0 73 75 73 70 65 6E 
1A109E8 	64 2D 64 65 62 75 67 8D 
1A109F0 	B0  9 A1  1 5C 40 A0  1 
1A109F8 	30  3  0  0 
: (reset-page)  #line off  1-more-line? off  ;
1A109FC 	 0  0  0 28 
1A10A00 	72 65 73 65 74 2D 70 61 
1A10A08 	67 65 29 8C F4  9 A1  1 
1A10A10 	20 40 A0  1 70 6D A0  1 
1A10A18 	F8 4B A0  1 F0  7 A1  1 
1A10A20 	F8 4B A0  1 58 46 A0  1 
' (reset-page)  is reset-page
: suspend  ( -- flag )
1A10A28 	73 75 73 70 65 6E 64 87 
1A10A30 	10  A A1  1 20 40 A0  1 
   #line off
1A10A38 	70 6D A0  1 F8 4B A0  1 
   ??cr dark  ."  More [<space>,<cr>,q,c,p,i,d,h] ? "  light
1A10A40 	 0 A1 A0  1 2C F8 A0  1 
1A10A48 	20 7C A0  1 23 20 4D 6F 
1A10A50 	72 65 20 5B 3C 73 70 61 
1A10A58 	63 65 3E 2C 3C 63 72 3E 
1A10A60 	2C 71 2C 63 2C 70 2C 69 
1A10A68 	2C 64 2C 68 5D 20 3F 20 
1A10A70 	 0  0  0  0 18 F8 A0  1 
   key  #out @  (cr  spaces  (cr  #out off
1A10A78 	50 6C A0  1 5C 6D A0  1 
1A10A80 	5C 4C A0  1 9C 72 A0  1 
1A10A88 	E8 71 A0  1 9C 72 A0  1 
1A10A90 	5C 6D A0  1 F8 4B A0  1 
   dup  ascii q  =   if  drop true  exit  then
1A10A98 	40 49 A0  1 58 41 A0  1 
1A10AA0 	71  0  0  0 24 48 A0  1 
1A10AA8 	DC 41 A0  1 10  0  0  0 
1A10AB0 	30 49 A0  1  4 70 A0  1 
1A10AB8 	40 46 A0  1 
   dup  ascii n  =   if  drop true  exit  then
1A10ABC 	40 49 A0  1 
1A10AC0 	58 41 A0  1 6E  0  0  0 
1A10AC8 	24 48 A0  1 DC 41 A0  1 
1A10AD0 	10  0  0  0 30 49 A0  1 
1A10AD8 	 4 70 A0  1 40 46 A0  1 
   dup  ascii p  =   if  drop page-mode  false  exit  then
1A10AE0 	40 49 A0  1 58 41 A0  1 
1A10AE8 	70  0  0  0 24 48 A0  1 
1A10AF0 	DC 41 A0  1 14  0  0  0 
1A10AF8 	30 49 A0  1 40  8 A1  1 
1A10B00 	18 70 A0  1 40 46 A0  1 
   dup  ascii c  =   if  drop no-page  false  exit  then
1A10B08 	40 49 A0  1 58 41 A0  1 
1A10B10 	63  0  0  0 24 48 A0  1 
1A10B18 	DC 41 A0  1 14  0  0  0 
1A10B20 	30 49 A0  1 1C  8 A1  1 
1A10B28 	18 70 A0  1 40 46 A0  1 
   dup  ascii i  =   if  drop suspend-interact  false  exit  then
1A10B30 	40 49 A0  1 58 41 A0  1 
1A10B38 	69  0  0  0 24 48 A0  1 
1A10B40 	DC 41 A0  1 14  0  0  0 
1A10B48 	30 49 A0  1 B0  9 A1  1 
1A10B50 	18 70 A0  1 40 46 A0  1 
   dup  ascii d  =   if  drop suspend-debug  false  exit  then
1A10B58 	40 49 A0  1 58 41 A0  1 
1A10B60 	64  0  0  0 24 48 A0  1 
1A10B68 	DC 41 A0  1 14  0  0  0 
1A10B70 	30 49 A0  1 F4  9 A1  1 
1A10B78 	18 70 A0  1 40 46 A0  1 
   dup  ascii h  =   if  drop suspend-help   false  exit  then
1A10B80 	40 49 A0  1 58 41 A0  1 
1A10B88 	68  0  0  0 24 48 A0  1 
1A10B90 	DC 41 A0  1 14  0  0  0 
1A10B98 	30 49 A0  1 68  8 A1  1 
1A10BA0 	18 70 A0  1 40 46 A0  1 
   dup  ascii ?  =   if  drop suspend-help   false  exit  then
1A10BA8 	40 49 A0  1 58 41 A0  1 
1A10BB0 	3F  0  0  0 24 48 A0  1 
1A10BB8 	DC 41 A0  1 14  0  0  0 
1A10BC0 	30 49 A0  1 68  8 A1  1 
1A10BC8 	18 70 A0  1 40 46 A0  1 
   dup  linefeed =  swap carret =  or  if  1-more-line? on  then
1A10BD0 	40 49 A0  1 4C 6F A0  1 
1A10BD8 	24 48 A0  1 68 49 A0  1 
1A10BE0 	60 6F A0  1 24 48 A0  1 
1A10BE8 	70 44 A0  1 DC 41 A0  1 
1A10BF0 	 C  0  0  0 F0  7 A1  1 
1A10BF8 	E0 4B A0  1 
   false
1A10BFC 	18 70 A0  1 
;
1A10C00 	58 46 A0  1 
d# 24 value default-#lines
1A10C04 	 0 64 65 66 
1A10C08 	61 75 6C 74 2D 23 6C 69 
1A10C10 	6E 65 73 8E 34  A A1  1 
1A10C18 	50 40 A0  1 34  3  0  0 
headers

defer lines/page  ' default-#lines is lines/page
1A10C20 	 0 6C 69 6E 65 73 2F 70 
1A10C28 	61 67 65 8A 18  C A1  1 
1A10C30 	5C 40 A0  1 38  3  0  0 

headerless
: (exit?)  ( -- flag )  \ True if the listing should be stopped
1A10C38 	28 65 78 69 74 3F 29 87 
1A10C40 	30  C A1  1 20 40 A0  1 
   interactive?  0=  if  false  exit  then
1A10C48 	C4 6C A0  1 24 47 A0  1 
1A10C50 	DC 41 A0  1  C  0  0  0 
1A10C58 	18 70 A0  1 40 46 A0  1 

   \ In case we start with lines/page already too large, we clear it out
   page-mode?  if  #line @ lines/page u>=  if  suspend exit  then  then
1A10C60 	 8  8 A1  1 DC 41 A0  1 
1A10C68 	24  0  0  0 70 6D A0  1 
1A10C70 	5C 4C A0  1 30  C A1  1 
1A10C78 	CC 48 A0  1 DC 41 A0  1 
1A10C80 	 C  0  0  0 34  A A1  1 
1A10C88 	40 46 A0  1 
   1-more-line? @  if  1-more-line? off  suspend  exit  then
1A10C8C 	F0  7 A1  1 
1A10C90 	5C 4C A0  1 DC 41 A0  1 
1A10C98 	14  0  0  0 F0  7 A1  1 
1A10CA0 	F8 4B A0  1 34  A A1  1 
1A10CA8 	40 46 A0  1 
   page-mode?  if  #line @ 1+  lines/page =  if  suspend exit  then  then
1A10CAC 	 8  8 A1  1 
1A10CB0 	DC 41 A0  1 28  0  0  0 
1A10CB8 	70 6D A0  1 5C 4C A0  1 
1A10CC0 	30 4B A0  1 30  C A1  1 
1A10CC8 	24 48 A0  1 DC 41 A0  1 
1A10CD0 	 C  0  0  0 34  A A1  1 
1A10CD8 	40 46 A0  1 
   key?  if
1A10CDC 	64 6C A0  1 
1A10CE0 	DC 41 A0  1 3C  0  0  0 
      key ascii q =  if   #line off  true  else  suspend  then
1A10CE8 	50 6C A0  1 58 41 A0  1 
1A10CF0 	71  0  0  0 24 48 A0  1 
1A10CF8 	DC 41 A0  1 18  0  0  0 
1A10D00 	70 6D A0  1 F8 4B A0  1 
1A10D08 	 4 70 A0  1 C8 41 A0  1 
1A10D10 	 8  0  0  0 34  A A1  1 
   else
1A10D18 	C8 41 A0  1  8  0  0  0 
      false
1A10D20 	18 70 A0  1 
   then
;
1A10D24 	58 46 A0  1 
headers
defer exit?
1A10D28 	 0  0 65 78 69 74 3F 85 
1A10D30 	44  C A1  1 5C 40 A0  1 
1A10D38 	3C  3  0  0 
' (exit?) is exit?
only forth also definitions


OpenFirmware/forth/lib/suspend.fth_AL	1376 1A10D3C 
hex

alias (s (
1A10D3C 	 0 28 73 E2 
1A10D40 	34  D A1  1 A4 ED A0  1 

: >user#  ( acf -- user# )   >body @user#  ;
1A10D48 	 0 3E 75 73 65 72 23 86 
1A10D50 	44  D A1  1 20 40 A0  1 
1A10D58 	E4 59 A0  1 B0 74 A0  1 
1A10D60 	58 46 A0  1 
: 'user#  \ name  ( -- user# )
1A10D64 	 0 27 75 73 
1A10D68 	65 72 23 86 54  D A1  1 
1A10D70 	20 40 A0  1 
   '  ( acf-of-user-variable )   >user#
1A10D74 	F8 95 A0  1 
1A10D78 	54  D A1  1 
;
1A10D7C 	58 46 A0  1 
headers
: tr  ( token-bits -- adr )      \ Token relocate
1A10D80 	 0 74 72 82 70  D A1  1 
1A10D88 	20 40 A0  1 
\t16   tshift <<
   origin+
1A10D8C 	64 55 A0  1 
;
1A10D90 	58 46 A0  1 
: x  ( adr -- )  execute  ;             \ Convenience word
1A10D94 	 0  0 78 81 
1A10D98 	88  D A1  1 20 40 A0  1 
1A10DA0 	98 41 A0  1 58 46 A0  1 
: .cstr  ( adr -- )             \ Display C string
1A10DA8 	 0  0 2E 63 73 74 72 85 
1A10DB0 	9C  D A1  1 20 40 A0  1 
   begin  dup c@ dup  while
1A10DB8 	40 49 A0  1 C4 4C A0  1 
1A10DC0 	40 49 A0  1 DC 41 A0  1 
1A10DC8 	38  0  0  0 
      dup newline =  if  drop cr  else  emit  then
1A10DCC 	40 49 A0  1 
1A10DD0 	A8 71 A0  1 24 48 A0  1 
1A10DD8 	DC 41 A0  1 14  0  0  0 
1A10DE0 	30 49 A0  1 80 6D A0  1 
1A10DE8 	C8 41 A0  1  8  0  0  0 
1A10DF0 	2C 6C A0  1 
      1+
1A10DF4 	30 4B A0  1 
   repeat
1A10DF8 	C8 41 A0  1 BC FF FF FF 
   2drop
1A10E00 	AC 49 A0  1 
;
1A10E04 	58 46 A0  1 

: .h  ( n -- )   push-hex     .  pop-base  ;
1A10E08 	 0 2E 68 82 B4  D A1  1 
1A10E10 	20 40 A0  1 5C F4 A0  1 
1A10E18 	94 7A A0  1 9C F4 A0  1 
1A10E20 	58 46 A0  1 
: .x  ( u -- )   push-hex    u.  pop-base  ;
1A10E24 	 0 2E 78 82 
1A10E28 	10  E A1  1 20 40 A0  1 
1A10E30 	5C F4 A0  1 C8 77 A0  1 
1A10E38 	9C F4 A0  1 58 46 A0  1 
: .d  ( n -- )   push-decimal .  pop-base  ;
1A10E40 	 0 2E 64 82 2C  E A1  1 
1A10E48 	20 40 A0  1 48 F4 A0  1 
1A10E50 	94 7A A0  1 9C F4 A0  1 
1A10E58 	58 46 A0  1 

headerless
defer lo-segment-base	' origin  is  lo-segment-base
1A10E5C 	6C 6F 2D 73 
1A10E60 	65 67 6D 65 6E 74 2D 62 
1A10E68 	61 73 65 8F 48  E A1  1 
1A10E70 	5C 40 A0  1 40  3  0  0 
defer lo-segment-limit	' origin  is  lo-segment-limit
1A10E78 	 0  0  0 6C 6F 2D 73 65 
1A10E80 	67 6D 65 6E 74 2D 6C 69 
1A10E88 	6D 69 74 90 70  E A1  1 
1A10E90 	5C 40 A0  1 44  3  0  0 
defer hi-segment-base	' origin  is  hi-segment-base
1A10E98 	68 69 2D 73 65 67 6D 65 
1A10EA0 	6E 74 2D 62 61 73 65 8F 
1A10EA8 	90  E A1  1 5C 40 A0  1 
1A10EB0 	48  3  0  0 
defer hi-segment-limit	' here    is  hi-segment-limit
1A10EB4 	 0  0  0 68 
1A10EB8 	69 2D 73 65 67 6D 65 6E 
1A10EC0 	74 2D 6C 69 6D 69 74 90 
1A10EC8 	AC  E A1  1 5C 40 A0  1 
1A10ED0 	4C  3  0  0 

: dictionary-size  ( -- n )  here origin-  ;
1A10ED4 	64 69 63 74 
1A10ED8 	69 6F 6E 61 72 79 2D 73 
1A10EE0 	69 7A 65 8F CC  E A1  1 
1A10EE8 	20 40 A0  1 70 54 A0  1 
1A10EF0 	80 55 A0  1 58 46 A0  1 

headerless

: #!  ( -- )  [compile] \  ; immediate  \ For use with script files
1A10EF8 	 0 23 21 C2 E8  E A1  1 
1A10F00 	20 40 A0  1 74 8A A0  1 
1A10F08 	58 46 A0  1 
alias >is >data		\ Backwards compatibility
1A10F0C 	3E 69 73 A3 
1A10F10 	 0  F A1  1 6C C7 A0  1 

: strip-blanks ( adr,len -- adr',len' )  -leading -trailing  ;
1A10F18 	 0  0  0 73 74 72 69 70 
1A10F20 	2D 62 6C 61 6E 6B 73 8C 
1A10F28 	14  F A1  1 20 40 A0  1 
1A10F30 	2C 8C A0  1 84 8C A0  1 
1A10F38 	58 46 A0  1 
: optional-arg$  ( -- adr len )  0 parse  strip-blanks  ;
1A10F3C 	 0  0 6F 70 
1A10F40 	74 69 6F 6E 61 6C 2D 61 
1A10F48 	72 67 24 8D 2C  F A1  1 
1A10F50 	20 40 A0  1 70 6F A0  1 
1A10F58 	E4 85 A0  1 2C  F A1  1 
1A10F60 	58 46 A0  1 

headers

alias not invert
1A10F64 	6E 6F 74 A3 
1A10F68 	50  F A1  1 30 45 A0  1 
alias eval evaluate
1A10F70 	 0  0  0 65 76 61 6C A4 
1A10F78 	6C  F A1  1 D8 E5 A0  1 

: c?  ( adr -- )  c@  u.  ;
1A10F80 	 0 63 3F 82 7C  F A1  1 
1A10F88 	20 40 A0  1 C4 4C A0  1 
1A10F90 	C8 77 A0  1 58 46 A0  1 
: w?  ( adr -- )  w@  u.  ;
1A10F98 	 0 77 3F 82 88  F A1  1 
1A10FA0 	20 40 A0  1 94 4C A0  1 
1A10FA8 	C8 77 A0  1 58 46 A0  1 
: l?  ( adr -- )  l@  u.  ;
1A10FB0 	 0 6C 3F 82 A0  F A1  1 
1A10FB8 	20 40 A0  1 6C 4C A0  1 
1A10FC0 	C8 77 A0  1 58 46 A0  1 
64\ : x?  ( adr -- )  x@  u.  ;
: d?  ( adr -- )  d@ swap u. u.  ;
1A10FC8 	 0 64 3F 82 B8  F A1  1 
1A10FD0 	20 40 A0  1 20 4C A0  1 
1A10FD8 	68 49 A0  1 C8 77 A0  1 
1A10FE0 	C8 77 A0  1 58 46 A0  1 

\ : behavior  ( xt1 -- xt2 )  >body >user token@  ;

: showstack    ( -- )  ['] (.s  is status  ;
1A10FE8 	 0  0 73 68 6F 77 73 74 
1A10FF0 	61 63 6B 89 D0  F A1  1 
1A10FF8 	20 40 A0  1 60 53 A0  1 
1A11000 	DC 7B A0  1 98 40 A0  1 
1A11008 	38 A1 A0  1 58 46 A0  1 
: noshowstack  ( -- )  ['] noop is status  ;
1A11010 	6E 6F 73 68 6F 77 73 74 
1A11018 	61 63 6B 8B F8  F A1  1 
1A11020 	20 40 A0  1 60 53 A0  1 
1A11028 	64 4F A0  1 98 40 A0  1 
1A11030 	38 A1 A0  1 58 46 A0  1 

: (confirmed?)  ( adr len -- char )
1A11038 	 0  0  0 28 63 6F 6E 66 
1A11040 	69 72 6D 65 64 3F 29 8C 
1A11048 	20 10 A1  1 20 40 A0  1 
   type  ."  [y/n]? "  key dup emit cr  upc
1A11050 	 4 6C A0  1 20 7C A0  1 
1A11058 	 8 20 5B 79 2F 6E 5D 3F 
1A11060 	20  0  0  0 50 6C A0  1 
1A11068 	40 49 A0  1 2C 6C A0  1 
1A11070 	80 6D A0  1 D0 51 A0  1 
;
1A11078 	58 46 A0  1 
\ Default value is yes
: confirmed?  ( adr len -- yes? )  (confirmed?) [char] N  <>  ;
1A1107C 	 0 63 6F 6E 
1A11080 	66 69 72 6D 65 64 3F 8A 
1A11088 	4C 10 A1  1 20 40 A0  1 
1A11090 	4C 10 A1  1 58 41 A0  1 
1A11098 	4E  0  0  0 44 48 A0  1 
1A110A0 	58 46 A0  1 
\ Default value is no
: confirmedn?  ( adr len -- yes? )  (confirmed?) [char] Y  =  ;
1A110A4 	63 6F 6E 66 
1A110A8 	69 72 6D 65 64 6E 3F 8B 
1A110B0 	8C 10 A1  1 20 40 A0  1 
1A110B8 	4C 10 A1  1 58 41 A0  1 
1A110C0 	59  0  0  0 24 48 A0  1 
1A110C8 	58 46 A0  1 

: lowmask  ( #bits -- mask )  1 swap lshift 1-  ;
1A110CC 	6C 6F 77 6D 
1A110D0 	61 73 6B 87 B4 10 A1  1 
1A110D8 	20 40 A0  1 80 6F A0  1 
1A110E0 	68 49 A0  1 9C 44 A0  1 
1A110E8 	54 4B A0  1 58 46 A0  1 
: lowbits  ( n #bits -- bits )  lowmask and  ;
1A110F0 	6C 6F 77 62 69 74 73 87 
1A110F8 	D8 10 A1  1 20 40 A0  1 
1A11100 	D8 10 A1  1 5C 44 A0  1 
1A11108 	58 46 A0  1 
: bits  ( n bit# #bits -- bits )  -rot rshift  swap lowbits  ;
1A1110C 	 0  0  0 62 
1A11110 	69 74 73 84 FC 10 A1  1 
1A11118 	20 40 A0  1 94 49 A0  1 
1A11120 	B4 44 A0  1 68 49 A0  1 
1A11128 	FC 10 A1  1 58 46 A0  1 
: bit  ( n bit# -- )  1 bits  ;
1A11130 	62 69 74 83 18 11 A1  1 
1A11138 	20 40 A0  1 80 6F A0  1 
1A11140 	18 11 A1  1 58 46 A0  1 

: kib  ( n -- nkib )  d# 10 lshift  ;  \ Convert to kilobytes
1A11148 	6B 69 62 83 38 11 A1  1 
1A11150 	20 40 A0  1 58 41 A0  1 
1A11158 	 A  0  0  0 9C 44 A0  1 
1A11160 	58 46 A0  1 
: mib  ( n -- nmib )  d# 20 lshift  ;  \ Convert to megabytes
1A11164 	6D 69 62 83 
1A11168 	50 11 A1  1 20 40 A0  1 
1A11170 	58 41 A0  1 14  0  0  0 
1A11178 	9C 44 A0  1 58 46 A0  1 

: log2  ( n -- log2-of-n )
1A11180 	 0  0  0 6C 6F 67 32 84 
1A11188 	6C 11 A1  1 20 40 A0  1 
   0  begin        ( n log )
1A11190 	70 6F A0  1 
      swap  2/     ( log n' )
1A11194 	68 49 A0  1 
1A11198 	78 4B A0  1 
   ?dup  while     ( log n' )
1A1119C 	B4 70 A0  1 
1A111A0 	DC 41 A0  1 14  0  0  0 
      swap 1+      ( n' log' )
1A111A8 	68 49 A0  1 30 4B A0  1 
   repeat          ( log )
1A111B0 	C8 41 A0  1 E0 FF FF FF 
;
1A111B8 	58 46 A0  1 

: many   ( -- )   key? 0=  if  0 >in !  then  ;
1A111BC 	 0  0  0 6D 
1A111C0 	61 6E 79 84 8C 11 A1  1 
1A111C8 	20 40 A0  1 64 6C A0  1 
1A111D0 	24 47 A0  1 DC 41 A0  1 
1A111D8 	10  0  0  0 70 6F A0  1 
1A111E0 	28 85 A0  1 54 4D A0  1 
1A111E8 	58 46 A0  1 

\ Display the bits in the number "x" according to the format string adr,len
\ The characters in the format string correspond to the bits in "x".
\ The last character in the string corresponds to the least-significant
\ bit in "x" (i.e. the bit whose binary weight is "1", the second-from-
\ last character corresponds to the "x" bit whose binary weight is "2",
\ and so on.  If there are fewer characters in the string than the number
\ of bits in a cell, the excess high-order bits in "x" are ignored.
\
\ The characters in the string are processed from left to right (i.e.
\ starting at the beginning of the string).  Each character in the string
\ is interpreted as follows:

\ If the character is "~":
\	The corresponding bit in "x" is ignored and nothing is displayed
\
\ If the character is alphabetic:
\	If the corresponding bit in "x" is clear (i.e. 0), the character is
\	displayed as-is.  If the bit is set (i.e. 1), the character is
\	displayed with its case inverted (upper-case changed to lower case,
\	and vice versa).
\
\ Otherwise:
\	The character is displayed as-is.

: show-bits  ( x adr len -- )
1A111EC 	 0  0 73 68 
1A111F0 	6F 77 2D 62 69 74 73 89 
1A111F8 	C8 11 A1  1 20 40 A0  1 
   1-  0  swap  do             ( mask adr )
1A11200 	54 4B A0  1 70 6F A0  1 
1A11208 	68 49 A0  1 88 42 A0  1 
1A11210 	8C  0  0  0 
      2dup c@                  ( mask adr mask char )
1A11214 	C0 49 A0  1 
1A11218 	C4 4C A0  1 
      dup [char] ~  =  if      ( mask adr mask char )
1A1121C 	40 49 A0  1 
1A11220 	58 41 A0  1 7E  0  0  0 
1A11228 	24 48 A0  1 DC 41 A0  1 
1A11230 	10  0  0  0 
         2drop                 ( mask adr )
1A11234 	AC 49 A0  1 
      else                     ( mask adr mask char )
1A11238 	C8 41 A0  1 4C  0  0  0 
         swap  1 i lshift and  ( mask adr char bit-set? )
1A11240 	68 49 A0  1 80 6F A0  1 
1A11248 	B4 42 A0  1 9C 44 A0  1 
1A11250 	5C 44 A0  1 
         if  dup [char] a <  if  lcc  else  upc  then  then
1A11254 	DC 41 A0  1 
1A11258 	2C  0  0  0 40 49 A0  1 
1A11260 	58 41 A0  1 61  0  0  0 
1A11268 	E4 47 A0  1 DC 41 A0  1 
1A11270 	10  0  0  0 F0 51 A0  1 
1A11278 	C8 41 A0  1  8  0  0  0 
1A11280 	D0 51 A0  1 
	 emit   ( mask adr )
1A11284 	2C 6C A0  1 
      then                     ( mask adr )
      1+                       ( mask adr' )
1A11288 	30 4B A0  1 
   -1 +loop                    ( mask adr )
1A1128C 	58 41 A0  1 
1A11290 	FF FF FF FF 1C 42 A0  1 
1A11298 	7C FF FF FF 
   2drop
1A1129C 	AC 49 A0  1 
;
1A112A0 	58 46 A0  1 

: .buffers ( -- )
1A112A4 	 0  0  0 2E 
1A112A8 	62 75 66 66 65 72 73 88 
1A112B0 	FC 11 A1  1 20 40 A0  1 
   buffer-link                    ( next-buffer-word )
1A112B8 	D0 A8 A0  1 
   begin  another-link?  while    ( acf )
1A112BC 	90 59 A0  1 
1A112C0 	DC 41 A0  1 58  0  0  0 
      dup .name                   ( acf )
1A112C8 	40 49 A0  1 C8 9A A0  1 
      dup >body dup >user @       ( acf apf addr )
1A112D0 	40 49 A0  1 E4 59 A0  1 
1A112D8 	40 49 A0  1 C8 74 A0  1 
1A112E0 	5C 4C A0  1 
      .x  /user# + @ .x  cr       ( acf )
1A112E4 	2C  E A1  1 
1A112E8 	40 5A A0  1  4 45 A0  1 
1A112F0 	5C 4C A0  1 2C  E A1  1 
1A112F8 	80 6D A0  1 
      exit?  if  drop exit  then  ( acf )
1A112FC 	34  D A1  1 
1A11300 	DC 41 A0  1  C  0  0  0 
1A11308 	30 49 A0  1 40 46 A0  1 
      >buffer-link                ( prev-buffer:-acf )
1A11310 	F4 A9 A0  1 
   repeat                         (  )
1A11314 	C8 41 A0  1 
1A11318 	A4 FF FF FF 
;
1A1131C 	58 46 A0  1 
defer showaddr  ( adr -- )	\ For disassemblers
1A11320 	 0  0  0 73 68 6F 77 61 
1A11328 	64 64 72 88 B4 12 A1  1 
1A11330 	5C 40 A0  1 50  3  0  0 
' u. is showaddr
\ : ux.  ( adr -- )  base @ >r  hex  (u.) type  r> base !  ;
\ ' ux. is showaddr

\ Integer division which rounds to nearest instead of truncating
: rounded-/  ( dividend divisor -- rounded-result )
1A11338 	 0  0 72 6F 75 6E 64 65 
1A11340 	64 2D 2F 89 30 13 A1  1 
1A11348 	20 40 A0  1 
   swap 2*  swap /  ( result*2 )
1A1134C 	68 49 A0  1 
1A11350 	A0 4B A0  1 68 49 A0  1 
1A11358 	98 5F A0  1 
   dup 1 and +      \ add 1 to the result if it is odd
1A1135C 	40 49 A0  1 
1A11360 	80 6F A0  1 5C 44 A0  1 
1A11368 	 4 45 A0  1 
   2/               ( rounded-result )
1A1136C 	78 4B A0  1 
;
1A11370 	58 46 A0  1 


OpenFirmware/forth/lib/util.fth_AL	638 1A11374 
\ Output Formatting
decimal
headerless

variable lmargin    0 lmargin !
1A11374 	6C 6D 61 72 
1A11378 	67 69 6E 87 48 13 A1  1 
1A11380 	48 40 A0  1 54  3  0  0 
variable rmargin   79 rmargin !
1A11388 	72 6D 61 72 67 69 6E 87 
1A11390 	80 13 A1  1 48 40 A0  1 
1A11398 	58  3  0  0 
: ?line  (s n -- )
1A1139C 	 0  0 3F 6C 
1A113A0 	69 6E 65 85 94 13 A1  1 
1A113A8 	20 40 A0  1 
   #out @ +    rmargin @ >  if  cr  lmargin @ spaces  then
1A113AC 	5C 6D A0  1 
1A113B0 	5C 4C A0  1  4 45 A0  1 
1A113B8 	94 13 A1  1 5C 4C A0  1 
1A113C0 	 4 48 A0  1 DC 41 A0  1 
1A113C8 	14  0  0  0 80 6D A0  1 
1A113D0 	80 13 A1  1 5C 4C A0  1 
1A113D8 	E8 71 A0  1 
;
1A113DC 	58 46 A0  1 
: ?cr  (s -- )  0 ?line  ;
1A113E0 	3F 63 72 83 A8 13 A1  1 
1A113E8 	20 40 A0  1 70 6F A0  1 
1A113F0 	A8 13 A1  1 58 46 A0  1 
: to-column  (s column -- )  #out @  -  1 max spaces  ;
1A113F8 	 0  0 74 6F 2D 63 6F 6C 
1A11400 	75 6D 6E 89 E8 13 A1  1 
1A11408 	20 40 A0  1 5C 6D A0  1 
1A11410 	5C 4C A0  1 18 45 A0  1 
1A11418 	80 6F A0  1 9C 4A A0  1 
1A11420 	E8 71 A0  1 58 46 A0  1 

variable tabstops  8 tabstops !
1A11428 	 0  0  0 74 61 62 73 74 
1A11430 	6F 70 73 88  8 14 A1  1 
1A11438 	48 40 A0  1 5C  3  0  0 
: ?to-column ( string-length starting-column -- )
1A11440 	 0 3F 74 6F 2D 63 6F 6C 
1A11448 	75 6D 6E 8A 38 14 A1  1 
1A11450 	20 40 A0  1 
   tuck + rmargin @ >  if
1A11454 	E8 46 A0  1 
1A11458 	 4 45 A0  1 94 13 A1  1 
1A11460 	5C 4C A0  1  4 48 A0  1 
1A11468 	DC 41 A0  1 20  0  0  0 
      drop cr  lmargin @ spaces
1A11470 	30 49 A0  1 80 6D A0  1 
1A11478 	80 13 A1  1 5C 4C A0  1 
1A11480 	E8 71 A0  1 
   else
1A11484 	C8 41 A0  1 
1A11488 	14  0  0  0 
      #out @ - spaces
1A1148C 	5C 6D A0  1 
1A11490 	5C 4C A0  1 18 45 A0  1 
1A11498 	E8 71 A0  1 
   then
;
1A1149C 	58 46 A0  1 
: .tab  ( string-length -- )
1A114A0 	 0  0  0 2E 74 61 62 84 
1A114A8 	50 14 A1  1 20 40 A0  1 
   \ Find the next tab stop after the current cursor position
   rmargin @ tabstops @ +  dup lmargin @  do   ( string-length target-column )
1A114B0 	94 13 A1  1 5C 4C A0  1 
1A114B8 	38 14 A1  1 5C 4C A0  1 
1A114C0 	 4 45 A0  1 40 49 A0  1 
1A114C8 	80 13 A1  1 5C 4C A0  1 
1A114D0 	88 42 A0  1 38  0  0  0 
      i  #out @   >=  if  drop i leave  then   ( string-length target-column )
1A114D8 	B4 42 A0  1 5C 6D A0  1 
1A114E0 	5C 4C A0  1 EC 48 A0  1 
1A114E8 	DC 41 A0  1 10  0  0  0 
1A114F0 	30 49 A0  1 B4 42 A0  1 
1A114F8 	18 43 A0  1 
   tabstops @ +loop                            ( string-length target-column )
1A114FC 	38 14 A1  1 
1A11500 	5C 4C A0  1 1C 42 A0  1 
1A11508 	D0 FF FF FF 
   ?to-column
1A1150C 	50 14 A1  1 
;
1A11510 	58 46 A0  1 
headers

OpenFirmware/forth/lib/format.fth_AL	416 1A11514 
\ String-array
\ Creates an array of strings.
\ Used in the form:
\ string-array name
\   ," This is the first string in the table"
\   ," this is the second one"
\   ," and this is the third"
\ end-string-array
\
\ name is later executed as:
\
\ name ( index -- addr )
\   index is a number between 0 and one less than the number of strings in
\   the array.  addr is the address of the corresponding packed string.
\   if index is less than 0 or greater than or equal to the number of
\   strings in the array, name aborts with the message:
\        String array index out of range

decimal
headerless

: string-array  \ name ( -- )
1A11514 	 0  0  0 73 
1A11518 	74 72 69 6E 67 2D 61 72 
1A11520 	72 61 79 8C AC 14 A1  1 
1A11528 	20 40 A0  1 
   create
1A1152C 	A8 A2 A0  1 
   0 ,    ( the number of strings )
1A11530 	70 6F A0  1 98 55 A0  1 
   0 ,    ( the starting address of the pointer table )
1A11538 	70 6F A0  1 98 55 A0  1 
   does>  ( index pfa )
1A11540 	50 A3 A0  1 90 90 90 E8 
1A11548 	30 2B FF FF 
   2dup @ ( index pfa  index #strings )
1A1154C 	C0 49 A0  1 
1A11550 	5C 4C A0  1 
   0 swap within  0= abort" String array index out of range"    ( index pfa )
1A11554 	70 6F A0  1 
1A11558 	68 49 A0  1  8 71 A0  1 
1A11560 	24 47 A0  1  8 81 A0  1 
1A11568 	1F 53 74 72 69 6E 67 20 
1A11570 	61 72 72 61 79 20 69 6E 
1A11578 	64 65 78 20 6F 75 74 20 
1A11580 	6F 66 20 72 61 6E 67 65 
1A11588 	 0  0  0  0 
   tuck  dup na1+ @ +      ( pfa index table-address )
1A1158C 	E8 46 A0  1 
1A11590 	40 49 A0  1 CC 50 A0  1 
1A11598 	5C 4C A0  1  4 45 A0  1 
   swap na+  @ +           ( string-address )
1A115A0 	68 49 A0  1 48 50 A0  1 
1A115A8 	5C 4C A0  1  4 45 A0  1 
;
1A115B0 	58 46 A0  1 
: end-string-array ( -- )
1A115B4 	 0  0  0 65 
1A115B8 	6E 64 2D 73 74 72 69 6E 
1A115C0 	67 2D 61 72 72 61 79 90 
1A115C8 	28 15 A1  1 20 40 A0  1 
   here                ( string-end-addr )
1A115D0 	70 54 A0  1 
   lastacf >body       ( string-end-addr pfa )
1A115D4 	AC 57 A0  1 
1A115D8 	E4 59 A0  1 
   dup >r                 \ Remember pfa of word for use as the base address
1A115DC 	40 49 A0  1 
1A115E0 	BC 45 A0  1 
   na1+ here r@ - over !  \ Store table address in the second word of the pf
1A115E4 	CC 50 A0  1 
1A115E8 	70 54 A0  1 E4 45 A0  1 
1A115F0 	18 45 A0  1 54 49 A0  1 
1A115F8 	54 4D A0  1 
   na1+                ( string-end-addr first-string-addr )
1A115FC 	CC 50 A0  1 
   begin               ( string-end-addr this-string-addr )
       2dup >          ( string-end-addr this-string-addr )
1A11600 	C0 49 A0  1  4 48 A0  1 
   while
1A11608 	DC 41 A0  1 20  0  0  0 
       \ Store string address in table
       dup r@ - ,      ( string-end-addr this-string-addr )
1A11610 	40 49 A0  1 E4 45 A0  1 
1A11618 	18 45 A0  1 98 55 A0  1 
       \ Find next string address
       +str            ( string-end-addr next-string-addr )
1A11620 	18 8B A0  1 
   repeat              ( string-end-addr next-string-addr )
1A11624 	C8 41 A0  1 
1A11628 	D8 FF FF FF 
   2drop               ( )
1A1162C 	AC 49 A0  1 
   \ Calculate and store number of strings
   lastacf >body       ( pfa )
1A11630 	AC 57 A0  1 E4 59 A0  1 
   dup dup na1+ @ +    ( pfa table-addr )
1A11638 	40 49 A0  1 40 49 A0  1 
1A11640 	CC 50 A0  1 5C 4C A0  1 
1A11648 	 4 45 A0  1 
   here swap - /n /    ( pfa #strings )
1A1164C 	70 54 A0  1 
1A11650 	68 49 A0  1 18 45 A0  1 
1A11658 	40 51 A0  1 98 5F A0  1 
   swap !
1A11660 	68 49 A0  1 54 4D A0  1 
   r> drop
1A11668 	D0 45 A0  1 30 49 A0  1 
;
1A11670 	58 46 A0  1 
headers


OpenFirmware/forth/lib/stringar.fth_AL	352 1A11674 
\ High level versions of string utilities needed for sifting

only forth also hidden also definitions
decimal
forth definitions
\ True if str1 is a substring of str2
: substring?   ( adr1 len1  adr2 len2 -- flag )
1A11674 	 0 73 75 62 
1A11678 	73 74 72 69 6E 67 3F 8A 
1A11680 	CC 15 A1  1 20 40 A0  1 
   rot tuck     ( adr1 adr2 len1  len2 len1 )
1A11688 	7C 49 A0  1 E8 46 A0  1 
   <  if  3drop false  else  tuck $=  then
1A11690 	E4 47 A0  1 DC 41 A0  1 
1A11698 	14  0  0  0 90 52 A0  1 
1A116A0 	18 70 A0  1 C8 41 A0  1 
1A116A8 	 C  0  0  0 E8 46 A0  1 
1A116B0 	88 8D A0  1 
;
1A116B4 	58 46 A0  1 

headerless
: unpack-name ( anf where -- where) \ Strip funny chars from a name field
1A116B8 	75 6E 70 61 63 6B 2D 6E 
1A116C0 	61 6D 65 8B 84 16 A1  1 
1A116C8 	20 40 A0  1 
   swap name>string rot pack
1A116CC 	68 49 A0  1 
1A116D0 	58 74 A0  1 7C 49 A0  1 
1A116D8 	DC 52 A0  1 
;
1A116DC 	58 46 A0  1 
\ hidden definitions
: 4dup   ( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2 n3 n4 )  2over 2over  ;
1A116E0 	 0  0  0 34 64 75 70 84 
1A116E8 	C8 16 A1  1 20 40 A0  1 
1A116F0 	D8 49 A0  1 D8 49 A0  1 
1A116F8 	58 46 A0  1 

headers
\ forth definitions
: sindex  ( adr1 len1 adr2 len2 -- n )
1A116FC 	 0 73 69 6E 
1A11700 	64 65 78 86 EC 16 A1  1 
1A11708 	20 40 A0  1 
   0 >r
1A1170C 	70 6F A0  1 
1A11710 	BC 45 A0  1 
   begin  ( adr1 len1 adr2' len2' )
      \ If string 1 is longer than string 2, it is not a substring
      2 pick over  >  if  r> 5drop  -1 exit   then
1A11714 	90 6F A0  1 
1A11718 	 C 4A A0  1 54 49 A0  1 
1A11720 	 4 48 A0  1 DC 41 A0  1 
1A11728 	18  0  0  0 D0 45 A0  1 
1A11730 	4C 53 A0  1 58 41 A0  1 
1A11738 	FF FF FF FF 40 46 A0  1 
      4dup substring?  if  4drop r> exit  then
1A11740 	EC 16 A1  1 84 16 A1  1 
1A11748 	DC 41 A0  1 10  0  0  0 
1A11750 	38 53 A0  1 D0 45 A0  1 
1A11758 	40 46 A0  1 
      \ Not found, so remove the first character from string 2 and try again
      swap 1+ swap 1-
1A1175C 	68 49 A0  1 
1A11760 	30 4B A0  1 68 49 A0  1 
1A11768 	54 4B A0  1 
      r> 1+ >r
1A1176C 	D0 45 A0  1 
1A11770 	30 4B A0  1 BC 45 A0  1 
   again
1A11778 	C8 41 A0  1 98 FF FF FF 
;
1A11780 	58 46 A0  1 

\ This version is faster (due to bscan being a code word) and arguably more convenient than sindex
: $sindex  ( small$ big$ -- rem$ )
1A11784 	24 73 69 6E 
1A11788 	64 65 78 87  8 17 A1  1 
1A11790 	20 40 A0  1 
   2 pick 0=  if  4drop 0  then  \ Null string is initial substring of anything
1A11794 	90 6F A0  1 
1A11798 	 C 4A A0  1 24 47 A0  1 
1A117A0 	DC 41 A0  1  C  0  0  0 
1A117A8 	38 53 A0  1 70 6F A0  1 
   3 pick c@  >r                 ( small$ big$  r: firstchar )
1A117B0 	A0 6F A0  1  C 4A A0  1 
1A117B8 	C4 4C A0  1 BC 45 A0  1 
   begin  r@  bscan  dup while   ( small$ rem$  r: firstchar )
1A117C0 	E4 45 A0  1 38 4F A0  1 
1A117C8 	40 49 A0  1 DC 41 A0  1 
1A117D0 	34  0  0  0 
      4dup substring?  if        ( small$ rem$  r: firstchar )
1A117D4 	EC 16 A1  1 
1A117D8 	84 16 A1  1 DC 41 A0  1 
1A117E0 	14  0  0  0 
         2swap r> 3drop  exit    ( -- rem$ )
1A117E4 	F4 49 A0  1 
1A117E8 	D0 45 A0  1 90 52 A0  1 
1A117F0 	40 46 A0  1 
      then                       ( small$ rem$  r: firstchar )
      1 /string                  ( small$ rem$'  r: firstchar )
1A117F4 	80 6F A0  1 
1A117F8 	3C 85 A0  1 
   repeat                        ( small$ rem$  r: firstchar )
1A117FC 	C8 41 A0  1 
1A11800 	C0 FF FF FF 
   2swap r> 3drop                ( rem$ )
1A11804 	F4 49 A0  1 
1A11808 	D0 45 A0  1 90 52 A0  1 
;
1A11810 	58 46 A0  1 

only forth also definitions


OpenFirmware/forth/lib/substrin.fth_AL	416 1A11814 \ This section introduces a new set of words:
\  $case  $of  $endof  $endcase
\ The semantics are very similar to the standard
\ Forth case statement.

\ Example of use:
\ : foo ( $ -- )
\   ( $ ) $case
\      " abc" $of  ." The string starts with abc" $endof
\      " xyz" $of  ." Oh, it's an xyz string"     $endof
\      ( $ ) ." **** It was " 2dup type
\   $endcase ( $ )

\ The default clause is optional.
\ When an $of clause is executed, the remaining selector string (past
\ the matched string) remains on the string.  It is the user's
\ responsibility to dispose of the string.
\ When a default clause is executed, the entire selector string is
\ on the stack.  The default clause must drop the selector, e.g., 2drop.

\ At run time, ($of) tests the top of the stack against the selector.

\ If the first N characters of the string supplied to $case are
\ the same, the selector string is shortened and the following
\ forth code is executed.  If the first characters are not the
\ same, execution continues at the point just following the
\ the matching $endof

\needs substring? fload ${BP}/forth/lib/substrin.fth

: ($of)  ( arg$ sel$ -- arg$' )
1A11814 	 0  0 28 24 
1A11818 	6F 66 29 85 90 17 A1  1 
1A11820 	20 40 A0  1 
   4dup 2swap substring?  if
1A11824 	EC 16 A1  1 
1A11828 	F4 49 A0  1 84 16 A1  1 
1A11830 	DC 41 A0  1 20  0  0  0 
      nip /string
1A11838 	FC 46 A0  1 3C 85 A0  1 
      r> cell+ >r      \ Return to next word in $of clause
1A11840 	D0 45 A0  1 E4 50 A0  1 
1A11848 	BC 45 A0  1 
   else
1A1184C 	C8 41 A0  1 
1A11850 	1C  0  0  0 
      2drop
1A11854 	AC 49 A0  1 
      r>  dup @ +  >r  \ Skip to matching $endof
1A11858 	D0 45 A0  1 40 49 A0  1 
1A11860 	5C 4C A0  1  4 45 A0  1 
1A11868 	BC 45 A0  1 
   then
;
1A1186C 	58 46 A0  1 

: $case   ( -- 0 )   +level  0                             ; immediate
1A11870 	 0  0 24 63 61 73 65 C5 
1A11878 	20 18 A1  1 20 40 A0  1 
1A11880 	 4 83 A0  1 70 6F A0  1 
1A11888 	58 46 A0  1 
: $of     ( -- >m )  ['] ($of)     +>mark                  ; immediate
1A1188C 	24 6F 66 C3 
1A11890 	7C 18 A1  1 20 40 A0  1 
1A11898 	60 53 A0  1 20 18 A1  1 
1A118A0 	D4 96 A0  1 58 46 A0  1 
: $endof  ( >m -- )  ['] ($endof)  +>mark  but  ->resolve  ; immediate
1A118A8 	 0 24 65 6E 64 6F 66 C6 
1A118B0 	94 18 A1  1 20 40 A0  1 
1A118B8 	60 53 A0  1 98 43 A0  1 
1A118C0 	D4 96 A0  1 70 97 A0  1 
1A118C8 	1C 97 A0  1 58 46 A0  1 

: $endcase  ( 0 [ >m ... ] -- )
1A118D0 	 0  0  0 24 65 6E 64 63 
1A118D8 	61 73 65 C8 B4 18 A1  1 
1A118E0 	20 40 A0  1 
   compile ($endcase)
1A118E4 	8C 75 A0  1 
1A118E8 	B0 43 A0  1 
   begin  ?dup  while  ->resolve  repeat
1A118EC 	B4 70 A0  1 
1A118F0 	DC 41 A0  1 10  0  0  0 
1A118F8 	1C 97 A0  1 C8 41 A0  1 
1A11900 	EC FF FF FF 
   -level
1A11904 	98 83 A0  1 
; immediate
1A11908 	58 46 A0  1 


OpenFirmware/forth/lib/strcase.fth_AL	248 1A1190C 
headers

\ Splits a string into two halves before the first occurrence of
\ a delimiter character.
\ adra,lena is the string including and after the delimiter
\ adrb,lenb is the string before the delimiter
\ lena = 0 if there was no delimiter

: split-before  ( adr len delim -- adra lena  adrb lenb )
1A1190C 	 0  0  0 73 
1A11910 	70 6C 69 74 2D 62 65 66 
1A11918 	6F 72 65 8C E0 18 A1  1 
1A11920 	20 40 A0  1 
   split-string 2swap
1A11924 	3C 64 A0  1 
1A11928 	F4 49 A0  1 
;
1A1192C 	58 46 A0  1 
alias $split left-parse-string
1A11930 	 0 24 73 70 6C 69 74 A6 
1A11938 	20 19 A1  1 44 D7 A0  1 

: cindex  ( adr len char -- [ index true ]  | false )
1A11940 	 0 63 69 6E 64 65 78 86 
1A11948 	3C 19 A1  1 20 40 A0  1 
   false swap 2swap  bounds  ?do  ( false char )
1A11950 	18 70 A0  1 68 49 A0  1 
1A11958 	F4 49 A0  1 F0 6D A0  1 
1A11960 	50 42 A0  1 38  0  0  0 
      dup  i c@  =  if  nip i true rot  leave  then
1A11968 	40 49 A0  1 B4 42 A0  1 
1A11970 	C4 4C A0  1 24 48 A0  1 
1A11978 	DC 41 A0  1 18  0  0  0 
1A11980 	FC 46 A0  1 B4 42 A0  1 
1A11988 	 4 70 A0  1 7C 49 A0  1 
1A11990 	18 43 A0  1 
   loop                           ( false char  |  index true char )
1A11994 	F8 41 A0  1 
1A11998 	D0 FF FF FF 
   drop
1A1199C 	30 49 A0  1 
;
1A119A0 	58 46 A0  1 

\ Splits a string into two halves after the last occurrence of
\ a delimiter character.
\ adra,lena is the string after the delimiter
\ adrb,lenb is the string before and including the delimiter
\ lenb = 0 if there was no delimiter

: right-split-string  ( $1 char -- tail$ head$|null$ )
1A119A4 	 0 72 69 67 
1A119A8 	68 74 2D 73 70 6C 69 74 
1A119B0 	2D 73 74 72 69 6E 67 92 
1A119B8 	4C 19 A1  1 20 40 A0  1 
   >r  2dup + 0           ( $1 null$ )
1A119C0 	BC 45 A0  1 C0 49 A0  1 
1A119C8 	 4 45 A0  1 70 6F A0  1 
   begin  2 pick  while                   ( head$ tail$ )
1A119D0 	90 6F A0  1  C 4A A0  1 
1A119D8 	DC 41 A0  1 48  0  0  0 
      2over + 1- c@  r@  <>
1A119E0 	D8 49 A0  1  4 45 A0  1 
1A119E8 	54 4B A0  1 C4 4C A0  1 
1A119F0 	E4 45 A0  1 44 48 A0  1 
   while                                  ( head$ tail$ )
1A119F8 	DC 41 A0  1 28  0  0  0 
      2swap 1-  2swap swap 1- swap 1+  
1A11A00 	F4 49 A0  1 54 4B A0  1 
1A11A08 	F4 49 A0  1 68 49 A0  1 
1A11A10 	54 4B A0  1 68 49 A0  1 
1A11A18 	30 4B A0  1 
   repeat  then
1A11A1C 	C8 41 A0  1 
1A11A20 	B0 FF FF FF 
   r> drop                                ( head$|null$ tail$ )
1A11A24 	D0 45 A0  1 
1A11A28 	30 49 A0  1 
   2swap                                  ( tail$ head$|null$ )
1A11A2C 	F4 49 A0  1 
;
1A11A30 	58 46 A0  1 
alias split-after right-split-string
1A11A34 	73 70 6C 69 
1A11A38 	74 2D 61 66 74 65 72 AB 
1A11A40 	BC 19 A1  1 BC 19 A1  1 
headers

OpenFirmware/forth/lib/parses1.fth_AL	316 1A11A48 
\ The dump utility gives you a formatted hex dump with the ascii
\ text corresponding to the bytes on the right hand side of the
\ screen.  In addition you can use the SM word to set a range of
\ memory locations to desired values.  SM displays an address and
\ its contents.  You can go forwards or backwards depending upon
\ which character you type. Entering a hex number changes the
\ contents of the location.  DL can be used to dump a line of
\ text from a screen.

decimal

only forth also hidden also  definitions

headerless
defer dc@ ' c@ is dc@
1A11A48 	64 63 40 83  8  8 A1  1 
1A11A50 	5C 40 A0  1 60  3  0  0 
\ : .2   (s n -- )   <#   u# u#   u#>   type   space   ;
: d.2   (s addr len -- )   bounds ?do   i dc@ .2   loop   ;
1A11A58 	64 2E 32 83 50 1A A1  1 
1A11A60 	20 40 A0  1 F0 6D A0  1 
1A11A68 	50 42 A0  1 18  0  0  0 
1A11A70 	B4 42 A0  1 50 1A A1  1 
1A11A78 	60 79 A0  1 F8 41 A0  1 
1A11A80 	F0 FF FF FF 58 46 A0  1 
: emit.   (s char -- )
1A11A88 	 0  0 65 6D 69 74 2E 85 
1A11A90 	60 1A A1  1 20 40 A0  1 
   d# 127 and dup printable? 0= if drop ascii . then emit
1A11A98 	58 41 A0  1 7F  0  0  0 
1A11AA0 	5C 44 A0  1 40 49 A0  1 
1A11AA8 	AC 8B A0  1 24 47 A0  1 
1A11AB0 	DC 41 A0  1 10  0  0  0 
1A11AB8 	30 49 A0  1 58 41 A0  1 
1A11AC0 	2E  0  0  0 2C 6C A0  1 
;
1A11AC8 	58 46 A0  1 
: emit.ln (s addr len -- )
1A11ACC 	65 6D 69 74 
1A11AD0 	2E 6C 6E 87 94 1A A1  1 
1A11AD8 	20 40 A0  1 
   bounds ?do   i dc@ emit.   loop
1A11ADC 	F0 6D A0  1 
1A11AE0 	50 42 A0  1 18  0  0  0 
1A11AE8 	B4 42 A0  1 50 1A A1  1 
1A11AF0 	94 1A A1  1 F8 41 A0  1 
1A11AF8 	F0 FF FF FF 
;
1A11AFC 	58 46 A0  1 
: dln   (s addr --- )
1A11B00 	64 6C 6E 83 D8 1A A1  1 
1A11B08 	20 40 A0  1 
   ??cr   dup  n->l 8 u.r   2 spaces   8 2dup d.2 space
1A11B0C 	 0 A1 A0  1 
1A11B10 	40 49 A0  1 74 4F A0  1 
1A11B18 	F0 6F A0  1 E4 77 A0  1 
1A11B20 	90 6F A0  1 E8 71 A0  1 
1A11B28 	F0 6F A0  1 C0 49 A0  1 
1A11B30 	60 1A A1  1 CC 71 A0  1 
   over + 8 d.2 space
1A11B38 	54 49 A0  1  4 45 A0  1 
1A11B40 	F0 6F A0  1 60 1A A1  1 
1A11B48 	CC 71 A0  1 
   16 emit.ln
1A11B4C 	58 41 A0  1 
1A11B50 	10  0  0  0 D8 1A A1  1 
;
1A11B58 	58 46 A0  1 

: .n2    (s n -- )  h# f and  3 .r  ;
1A11B5C 	2E 6E 32 83 
1A11B60 	 8 1B A1  1 20 40 A0  1 
1A11B68 	58 41 A0  1  F  0  0  0 
1A11B70 	5C 44 A0  1 A0 6F A0  1 
1A11B78 	58 78 A0  1 58 46 A0  1 
: .a     (s n -- )  h# f and  1 .r  ;
1A11B80 	 0 2E 61 82 64 1B A1  1 
1A11B88 	20 40 A0  1 58 41 A0  1 
1A11B90 	 F  0  0  0 5C 44 A0  1 
1A11B98 	80 6F A0  1 58 78 A0  1 
1A11BA0 	58 46 A0  1 

: .head   (s addr -- )
1A11BA4 	 0  0 2E 68 
1A11BA8 	65 61 64 85 88 1B A1  1 
1A11BB0 	20 40 A0  1 
   ??cr dup d# 16 >> d# 16 >> ?dup  if
1A11BB4 	 0 A1 A0  1 
1A11BB8 	40 49 A0  1 58 41 A0  1 
1A11BC0 	10  0  0  0 DC 44 A0  1 
1A11BC8 	58 41 A0  1 10  0  0  0 
1A11BD0 	DC 44 A0  1 B4 70 A0  1 
1A11BD8 	DC 41 A0  1 18  0  0  0 
      8 u.r space
1A11BE0 	F0 6F A0  1 E4 77 A0  1 
1A11BE8 	CC 71 A0  1 
   else
1A11BEC 	C8 41 A0  1 
1A11BF0 	10  0  0  0 
      9 spaces
1A11BF4 	58 41 A0  1 
1A11BF8 	 9  0  0  0 E8 71 A0  1 
   then                                  ( adr )
   8 0 do   dup i + .n2   loop   space   d# 16 8 do   dup i + .n2   loop
1A11C00 	F0 6F A0  1 70 6F A0  1 
1A11C08 	88 42 A0  1 1C  0  0  0 
1A11C10 	40 49 A0  1 B4 42 A0  1 
1A11C18 	 4 45 A0  1 64 1B A1  1 
1A11C20 	F8 41 A0  1 EC FF FF FF 
1A11C28 	CC 71 A0  1 58 41 A0  1 
1A11C30 	10  0  0  0 F0 6F A0  1 
1A11C38 	88 42 A0  1 1C  0  0  0 
1A11C40 	40 49 A0  1 B4 42 A0  1 
1A11C48 	 4 45 A0  1 64 1B A1  1 
1A11C50 	F8 41 A0  1 EC FF FF FF 
   2 spaces   d# 16 0 do  dup i + .a  loop   drop
1A11C58 	90 6F A0  1 E8 71 A0  1 
1A11C60 	58 41 A0  1 10  0  0  0 
1A11C68 	70 6F A0  1 88 42 A0  1 
1A11C70 	1C  0  0  0 40 49 A0  1 
1A11C78 	B4 42 A0  1  4 45 A0  1 
1A11C80 	88 1B A1  1 F8 41 A0  1 
1A11C88 	EC FF FF FF 30 49 A0  1 
;
1A11C90 	58 46 A0  1 
headers

: (dump) ( addr len -- )
1A11C94 	 0 28 64 75 
1A11C98 	6D 70 29 86 B0 1B A1  1 
1A11CA0 	20 40 A0  1 
   push-hex   over  .head  ( addr len )
1A11CA4 	5C F4 A0  1 
1A11CA8 	54 49 A0  1 B0 1B A1  1 
   1 max
1A11CB0 	80 6F A0  1 9C 4A A0  1 
   bounds do   i dln  exit? ?leave  16 +loop
1A11CB8 	F0 6D A0  1 88 42 A0  1 
1A11CC0 	24  0  0  0 B4 42 A0  1 
1A11CC8 	 8 1B A1  1 34  D A1  1 
1A11CD0 	34 43 A0  1 58 41 A0  1 
1A11CD8 	10  0  0  0 1C 42 A0  1 
1A11CE0 	E4 FF FF FF 
   pop-base
1A11CE4 	9C F4 A0  1 
;
1A11CE8 	58 46 A0  1 
also forth definitions

: dump ( addr len -- )      ['] c@ is dc@ (dump)  ;
1A11CEC 	 0  0  0 64 
1A11CF0 	75 6D 70 84 44 1A A1  1 
1A11CF8 	20 40 A0  1 60 53 A0  1 
1A11D00 	C4 4C A0  1 98 40 A0  1 
1A11D08 	50 1A A1  1 A0 1C A1  1 
1A11D10 	58 46 A0  1 
: du   ( addr -- addr+64 )  dup d# 64 dump   d# 64 +  ;
1A11D14 	 0 64 75 82 
1A11D18 	F8 1C A1  1 20 40 A0  1 
1A11D20 	40 49 A0  1 58 41 A0  1 
1A11D28 	40  0  0  0 F8 1C A1  1 
1A11D30 	58 41 A0  1 40  0  0  0 
1A11D38 	 4 45 A0  1 58 46 A0  1 

\ Dumps 16-bit signed samples in decimal
: dump-audio  ( adr len -- )
1A11D40 	 0 64 75 6D 70 2D 61 75 
1A11D48 	64 69 6F 8A 1C 1D A1  1 
1A11D50 	20 40 A0  1 
   base @ >r
1A11D54 	B8 75 A0  1 
1A11D58 	5C 4C A0  1 BC 45 A0  1 
   bounds ?do
1A11D60 	F0 6D A0  1 50 42 A0  1 
1A11D68 	68  0  0  0 
      hex
1A11D6C 	C0 8D A0  1 
      i 8 u.r ." : "
1A11D70 	B4 42 A0  1 F0 6F A0  1 
1A11D78 	E4 77 A0  1 20 7C A0  1 
1A11D80 	 2 3A 20  0 
      decimal
1A11D84 	E4 8D A0  1 
      i d# 16  bounds do
1A11D88 	B4 42 A0  1 58 41 A0  1 
1A11D90 	10  0  0  0 F0 6D A0  1 
1A11D98 	88 42 A0  1 20  0  0  0 
         i <w@ 7 .r
1A11DA0 	B4 42 A0  1 AC 4C A0  1 
1A11DA8 	E0 6F A0  1 58 78 A0  1 
      /w +loop
1A11DB0 	20 51 A0  1 1C 42 A0  1 
1A11DB8 	E8 FF FF FF 
      cr
1A11DBC 	80 6D A0  1 
   d# 16 +loop
1A11DC0 	58 41 A0  1 10  0  0  0 
1A11DC8 	1C 42 A0  1 A0 FF FF FF 
   pop-base  
1A11DD0 	9C F4 A0  1 
;
1A11DD4 	58 46 A0  1 

only forth also definitions

OpenFirmware/forth/lib/dump.fth_AL	912 1A11DD8 
\ Display the WORDS in the Context Vocabulary

decimal

only forth also definitions

: over-vocabulary  (s acf-of-word-to-execute voc-acf -- )
1A11DD8 	6F 76 65 72 2D 76 6F 63 
1A11DE0 	61 62 75 6C 61 72 79 8F 
1A11DE8 	50 1D A1  1 20 40 A0  1 
   follow  begin  another?  while   ( acf anf )
1A11DF0 	38 BC A0  1 68 BC A0  1 
1A11DF8 	DC 41 A0  1 18  0  0  0 
      n>link over execute           ( acf )
1A11E00 	8C 73 A0  1 54 49 A0  1 
1A11E08 	98 41 A0  1 
   repeat  ( acf )  drop
1A11E0C 	C8 41 A0  1 
1A11E10 	E4 FF FF FF 30 49 A0  1 
;
1A11E18 	58 46 A0  1 
: +words   (s -- )
1A11E1C 	 0 2B 77 6F 
1A11E20 	72 64 73 86 EC 1D A1  1 
1A11E28 	20 40 A0  1 
   0 lmargin !  td 64 rmargin !  td 14 tabstops !
1A11E2C 	70 6F A0  1 
1A11E30 	80 13 A1  1 54 4D A0  1 
1A11E38 	58 41 A0  1 40  0  0  0 
1A11E40 	94 13 A1  1 54 4D A0  1 
1A11E48 	58 41 A0  1  E  0  0  0 
1A11E50 	38 14 A1  1 54 4D A0  1 
   ??cr
1A11E58 	 0 A1 A0  1 
   begin  another?  while      ( anf )
1A11E5C 	68 BC A0  1 
1A11E60 	DC 41 A0  1 30  0  0  0 
     dup name>string nip .tab  ( anf )
1A11E68 	40 49 A0  1 58 74 A0  1 
1A11E70 	FC 46 A0  1 AC 14 A1  1 
     .id                       ( )
1A11E78 	A8 9A A0  1 
     exit? if  exit  then      ( )
1A11E7C 	34  D A1  1 
1A11E80 	DC 41 A0  1  8  0  0  0 
1A11E88 	40 46 A0  1 
   repeat                      ( )
1A11E8C 	C8 41 A0  1 
1A11E90 	CC FF FF FF 
;
1A11E94 	58 46 A0  1 
: follow-to  (s adr voc-acf -- error? )
1A11E98 	 0  0 66 6F 6C 6C 6F 77 
1A11EA0 	2D 74 6F 89 28 1E A1  1 
1A11EA8 	20 40 A0  1 
   follow  begin  another?  while         ( adr anf )
1A11EAC 	38 BC A0  1 
1A11EB0 	68 BC A0  1 DC 41 A0  1 
1A11EB8 	28  0  0  0 
      over u<  if  drop false exit  then  ( adr )
1A11EBC 	54 49 A0  1 
1A11EC0 	A8 48 A0  1 DC 41 A0  1 
1A11EC8 	10  0  0  0 30 49 A0  1 
1A11ED0 	18 70 A0  1 40 46 A0  1 
   repeat                                 ( adr )
1A11ED8 	C8 41 A0  1 D4 FF FF FF 
   drop true
1A11EE0 	30 49 A0  1  4 70 A0  1 
;
1A11EE8 	58 46 A0  1 
: prior-words  (s adr -- )
1A11EEC 	70 72 69 6F 
1A11EF0 	72 2D 77 6F 72 64 73 8B 
1A11EF8 	A8 1E A1  1 20 40 A0  1 
   context token@ follow-to  if
1A11F00 	DC A3 A0  1  C 54 A0  1 
1A11F08 	A8 1E A1  1 DC 41 A0  1 
1A11F10 	40  0  0  0 
      ." There are no words prior to this address." cr
1A11F14 	20 7C A0  1 
1A11F18 	29 54 68 65 72 65 20 61 
1A11F20 	72 65 20 6E 6F 20 77 6F 
1A11F28 	72 64 73 20 70 72 69 6F 
1A11F30 	72 20 74 6F 20 74 68 69 
1A11F38 	73 20 61 64 64 72 65 73 
1A11F40 	73 2E  0  0 80 6D A0  1 
   else
1A11F48 	C8 41 A0  1  8  0  0  0 
      +words
1A11F50 	28 1E A1  1 
   then
;
1A11F54 	58 46 A0  1 

: words  (s -- )  context token@ follow  +words  ;
1A11F58 	 0  0 77 6F 72 64 73 85 
1A11F60 	FC 1E A1  1 20 40 A0  1 
1A11F68 	DC A3 A0  1  C 54 A0  1 
1A11F70 	38 BC A0  1 28 1E A1  1 
1A11F78 	58 46 A0  1 

only definitions forth also
: words    words ;  \ Version for 'root' vocabulary
1A11F7C 	 0  0 77 6F 
1A11F80 	72 64 73 85  8 C5 A0  1 
1A11F88 	20 40 A0  1 64 1F A1  1 
1A11F90 	58 46 A0  1 
only forth also definitions

OpenFirmware/forth/lib/words.fth_AL	444 1A11F94 
\ The decompiler.
\ This program is based on the F83 decompiler by Perry and Laxen,
\ but it has been heavily modified:
\   Structured decompilation of conditionals
\   Largely machine independent
\   Prints the name of the definer for child words instead of the
\     definer's DOES> clause.
\   "Smart" decompilation of literals.

\ A Forth decompiler is a utility program that translates
\ executable forth code back into source code.  For many compiled languages,
\ decompilation is very hard or impossible.  Decompilation of threaded
\ code is relatively easy.
\ It was written with modifiability in mind, so if you add your
\ own special compiling words, it will be easy to change the
\ decompiler to include them.  This code is implementation
\ dependant, and will not necessarily work on other Forth system.
\ To invoke the decompiler, use the word SEE <name> where <name> is the
\ name of a Forth word.  Alternatively,  (SEE) will decompile the word
\ whose acf is on the stack.

: (in-dictionary?)  ( adr -- flag )  origin here within  ;
1A11F94 	 0  0  0 28 
1A11F98 	69 6E 2D 64 69 63 74 69 
1A11FA0 	6F 6E 61 72 79 3F 29 90 
1A11FA8 	64 1F A1  1 20 40 A0  1 
1A11FB0 	50 55 A0  1 70 54 A0  1 
1A11FB8 	 8 71 A0  1 58 46 A0  1 
\ defer in-dictionary?
' (in-dictionary?) is in-dictionary?

: probably-cfa?  ( possible-acf -- flag )
1A11FC0 	 0  0 70 72 6F 62 61 62 
1A11FC8 	6C 79 2D 63 66 61 3F 8D 
1A11FD0 	AC 1F A1  1 20 40 A0  1 
   dup dup acf-aligned =  over in-dictionary?  and  if
1A11FD8 	40 49 A0  1 40 49 A0  1 
1A11FE0 	 C 5D A0  1 24 48 A0  1 
1A11FE8 	54 49 A0  1 24 CF A0  1 
1A11FF0 	5C 44 A0  1 DC 41 A0  1 
1A11FF8 	10  0  0  0 
      colon-cf?
1A11FFC 	9C 5B A0  1 
   else
1A12000 	C8 41 A0  1  C  0  0  0 
      drop false
1A12008 	30 49 A0  1 18 70 A0  1 
   then
;
1A12010 	58 46 A0  1 

\ Given an ip, scan backwards until you find the acf.  This assumes
\ that the ip is within a colon definition, and it is not absolutely
\ guaranteed to work, but in practice it usually does.

: find-cfa  ( ip -- acf )
1A12014 	 0  0  0 66 
1A12018 	69 6E 64 2D 63 66 61 88 
1A12020 	D4 1F A1  1 20 40 A0  1 
   begin
      dup in-dictionary?  0=  if  drop ['] lose  exit  then
1A12028 	40 49 A0  1 24 CF A0  1 
1A12030 	24 47 A0  1 DC 41 A0  1 
1A12038 	14  0  0  0 30 49 A0  1 
1A12040 	60 53 A0  1 90 9B A0  1 
1A12048 	40 46 A0  1 
      #talign -  dup  probably-cfa?
1A1204C 	68 5A A0  1 
1A12050 	18 45 A0  1 40 49 A0  1 
1A12058 	D4 1F A1  1 
   until
1A1205C 	DC 41 A0  1 
1A12060 	C8 FF FF FF 
;
1A12064 	58 46 A0  1 

\needs iscreate  create iscreate
1A12068 	 0  0  0 69 73 63 72 65 
1A12070 	61 74 65 88 24 20 A1  1 
1A12078 	30 40 A0  1 
\needs (wlit)    create (wlit)
1A1207C 	 0 28 77 6C 
1A12080 	69 74 29 86 78 20 A1  1 
1A12088 	30 40 A0  1 

start-module
decimal

only forth also hidden also forth definitions
defer (see)
1A1208C 	 0  0 28 73 
1A12090 	65 65 29 85 88 20 A1  1 
1A12098 	5C 40 A0  1 64  3  0  0 

hidden definitions
d# 300 2* /n* constant /positions
1A120A0 	 0 2F 70 6F 73 69 74 69 
1A120A8 	6F 6E 73 8A A0 1C A1  1 
1A120B0 	68 40 A0  1 60  9  0  0 
/positions buffer: positions
1A120B8 	 0  0 70 6F 73 69 74 69 
1A120C0 	6F 6E 73 89 B0 20 A1  1 
1A120C8 	B4 A9 A0  1 68  3  0  0 
1A120D0 	60  9  0  0 24 FE A0  1 
0 value end-positions
1A120D8 	 0  0 65 6E 64 2D 70 6F 
1A120E0 	73 69 74 69 6F 6E 73 8D 
1A120E8 	C8 20 A1  1 50 40 A0  1 
1A120F0 	6C  3  0  0 
\ 0 value line-after-;

: init-positions  ( -- )  positions is end-positions  ;
1A120F4 	 0 69 6E 69 
1A120F8 	74 2D 70 6F 73 69 74 69 
1A12100 	6F 6E 73 8E EC 20 A1  1 
1A12108 	20 40 A0  1 C8 20 A1  1 
1A12110 	B8 40 A0  1 EC 20 A1  1 
1A12118 	58 46 A0  1 
: find-position  ( ip -- true | adr false )
1A1211C 	 0  0 66 69 
1A12120 	6E 64 2D 70 6F 73 69 74 
1A12128 	69 6F 6E 8D  8 21 A1  1 
1A12130 	20 40 A0  1 
   end-positions positions  ?do   ( ip )
1A12134 	EC 20 A1  1 
1A12138 	C8 20 A1  1 50 42 A0  1 
1A12140 	44  0  0  0 
      i 2@ nip                    ( ip that-ip )
1A12144 	B4 42 A0  1 
1A12148 	CC 4D A0  1 FC 46 A0  1 
      over =  if                  ( ip )
1A12150 	54 49 A0  1 24 48 A0  1 
1A12158 	DC 41 A0  1 18  0  0  0 
         drop i false             ( adr false )
1A12160 	30 49 A0  1 B4 42 A0  1 
1A12168 	18 70 A0  1 
         unloop exit              ( adr false -- )
1A1216C 	3C 42 A0  1 
1A12170 	40 46 A0  1 
      then                        ( ip )
   2 /n* +loop                    ( ip )
1A12174 	90 6F A0  1 
1A12178 	98 51 A0  1 1C 42 A0  1 
1A12180 	C4 FF FF FF 
   drop true                      ( true )
1A12184 	30 49 A0  1 
1A12188 	 4 70 A0  1 
;
1A1218C 	58 46 A0  1 
0 value decompiler-ip
1A12190 	 0  0 64 65 63 6F 6D 70 
1A12198 	69 6C 65 72 2D 69 70 8D 
1A121A0 	30 21 A1  1 50 40 A0  1 
1A121A8 	70  3  0  0 
: add-position  ( ip -- )
1A121AC 	 0  0  0 61 
1A121B0 	64 64 2D 70 6F 73 69 74 
1A121B8 	69 6F 6E 8C A4 21 A1  1 
1A121C0 	20 40 A0  1 
   decompiler-ip find-position  if                 ( )
1A121C4 	A4 21 A1  1 
1A121C8 	30 21 A1  1 DC 41 A0  1 
1A121D0 	58  0  0  0 
      end-positions  positions /positions +  >=    ( flag )
1A121D4 	EC 20 A1  1 
1A121D8 	C8 20 A1  1 B0 20 A1  1 
1A121E0 	 4 45 A0  1 EC 48 A0  1 
      abort" Decompiler position table overflow"   ( )
1A121E8 	 8 81 A0  1 22 44 65 63 
1A121F0 	6F 6D 70 69 6C 65 72 20 
1A121F8 	70 6F 73 69 74 69 6F 6E 
1A12200 	20 74 61 62 6C 65 20 6F 
1A12208 	76 65 72 66 6C 6F 77  0 
      end-positions  dup 2 na+  is end-positions   ( adr )
1A12210 	EC 20 A1  1 40 49 A0  1 
1A12218 	90 6F A0  1 48 50 A0  1 
1A12220 	B8 40 A0  1 EC 20 A1  1 
   then                                            ( adr )
   #out @ #line @ wljoin  decompiler-ip  rot 2!    ( )
1A12228 	5C 6D A0  1 5C 4C A0  1 
1A12230 	70 6D A0  1 5C 4C A0  1 
1A12238 	D4 4F A0  1 A4 21 A1  1 
1A12240 	7C 49 A0  1 E4 4D A0  1 
;
1A12248 	58 46 A0  1 
: ip>position  ( ip -- true | #out #line false )
1A1224C 	69 70 3E 70 
1A12250 	6F 73 69 74 69 6F 6E 8B 
1A12258 	C0 21 A1  1 20 40 A0  1 
   find-position  if    ( )
1A12260 	30 21 A1  1 DC 41 A0  1 
1A12268 	10  0  0  0 
      true              ( true )
1A1226C 	 4 70 A0  1 
   else                 ( adr )
1A12270 	C8 41 A0  1 14  0  0  0 
      2@ drop lwsplit   ( #out #line )
1A12278 	CC 4D A0  1 30 49 A0  1 
1A12280 	A0 4F A0  1 
      false             ( #out #line false )
1A12284 	18 70 A0  1 
   then                 ( true | #out #line false )
;
1A12288 	58 46 A0  1 
: ip-set-cursor  ( ip -- )
1A1228C 	 0  0 69 70 
1A12290 	2D 73 65 74 2D 63 75 72 
1A12298 	73 6F 72 8D 5C 22 A1  1 
1A122A0 	20 40 A0  1 
   ip>position 0=  if  at-xy  then
1A122A4 	5C 22 A1  1 
1A122A8 	24 47 A0  1 DC 41 A0  1 
1A122B0 	 8  0  0  0 40 F8 A0  1 
;
1A122B8 	58 46 A0  1 

headers
defer indent
1A122BC 	 0 69 6E 64 
1A122C0 	65 6E 74 86 A0 22 A1  1 
1A122C8 	5C 40 A0  1 74  3  0  0 
: (indent)  ( -- )  lmargin @ #out @ - 0 max spaces  ;
1A122D0 	 0  0  0 28 69 6E 64 65 
1A122D8 	6E 74 29 88 C8 22 A1  1 
1A122E0 	20 40 A0  1 80 13 A1  1 
1A122E8 	5C 4C A0  1 5C 6D A0  1 
1A122F0 	5C 4C A0  1 18 45 A0  1 
1A122F8 	70 6F A0  1 9C 4A A0  1 
1A12300 	E8 71 A0  1 58 46 A0  1 
' (indent) is indent
headerless

: +indent  ( -- )   3 lmargin +!  cr  ;
1A12308 	2B 69 6E 64 65 6E 74 87 
1A12310 	E0 22 A1  1 20 40 A0  1 
1A12318 	A0 6F A0  1 80 13 A1  1 
1A12320 	 C 4C A0  1 80 6D A0  1 
1A12328 	58 46 A0  1 
: -indent  ( -- )  ??cr -3 lmargin +!  ;
1A1232C 	2D 69 6E 64 
1A12330 	65 6E 74 87 14 23 A1  1 
1A12338 	20 40 A0  1  0 A1 A0  1 
1A12340 	58 41 A0  1 FD FF FF FF 
1A12348 	80 13 A1  1  C 4C A0  1 
1A12350 	58 46 A0  1 
\ : <indent  ( -- )  ??cr -3 lmargin +!  indent  3 lmargin +!   ;

headerless
\ Like ." but goes to a new line if needed.
: cr".  ( adr len -- )
1A12354 	 0  0  0 63 
1A12358 	72 22 2E 84 38 23 A1  1 
1A12360 	20 40 A0  1 
   dup ?line  indent            ( adr len )
1A12364 	40 49 A0  1 
1A12368 	A8 13 A1  1 C8 22 A1  1 
   add-position                 ( adr len )
1A12370 	C0 21 A1  1 
   magenta-letters type cancel  ( )
1A12374 	14 FA A0  1 
1A12378 	 4 6C A0  1 BC F7 A0  1 
;
1A12380 	58 46 A0  1 
: .."   ( -- )  [compile] " compile cr".  ; immediate
1A12384 	2E 2E 22 C3 
1A12388 	60 23 A1  1 20 40 A0  1 
1A12390 	5C 8A A0  1 8C 75 A0  1 
1A12398 	60 23 A1  1 58 46 A0  1 

\ Positional case defining word
\ Subscripts start from 0
: out   ( # apf -- )  \ report out of range error
1A123A0 	6F 75 74 83 8C 23 A1  1 
1A123A8 	20 40 A0  1 
   cr  ." subscript out of range on "  dup body> .name
1A123AC 	80 6D A0  1 
1A123B0 	20 7C A0  1 1A 73 75 62 
1A123B8 	73 63 72 69 70 74 20 6F 
1A123C0 	75 74 20 6F 66 20 72 61 
1A123C8 	6E 67 65 20 6F 6E 20  0 
1A123D0 	40 49 A0  1 C8 59 A0  1 
1A123D8 	C8 9A A0  1 
   ."    max is " ?   ."    tried " .  quit
1A123DC 	20 7C A0  1 
1A123E0 	 A 20 20 20 6D 61 78 20 
1A123E8 	69 73 20  0 C4 7B A0  1 
1A123F0 	20 7C A0  1  9 20 20 20 
1A123F8 	74 72 69 65 64 20  0  0 
1A12400 	94 7A A0  1 FC D0 A0  1 
;
1A12408 	58 46 A0  1 
: map  ( # apf -- a ) \ convert subscript # to address a
1A1240C 	6D 61 70 83 
1A12410 	A8 23 A1  1 20 40 A0  1 
   2dup @  u<  if  na1+ swap na+   else   out  then
1A12418 	C0 49 A0  1 5C 4C A0  1 
1A12420 	A8 48 A0  1 DC 41 A0  1 
1A12428 	18  0  0  0 CC 50 A0  1 
1A12430 	68 49 A0  1 48 50 A0  1 
1A12438 	C8 41 A0  1  8  0  0  0 
1A12440 	A8 23 A1  1 
;
1A12444 	58 46 A0  1 
: maptoken  ( # apf -- a ) \ convert subscript # to address a
1A12448 	 0  0  0 6D 61 70 74 6F 
1A12450 	6B 65 6E 88 14 24 A1  1 
1A12458 	20 40 A0  1 
   2dup @  u<  if  na1+ swap /token * +   else   out  then
1A1245C 	C0 49 A0  1 
1A12460 	5C 4C A0  1 A8 48 A0  1 
1A12468 	DC 41 A0  1 20  0  0  0 
1A12470 	CC 50 A0  1 68 49 A0  1 
1A12478 	B4 46 A0  1 1C 5F A0  1 
1A12480 	 4 45 A0  1 C8 41 A0  1 
1A12488 	 8  0  0  0 A8 23 A1  1 
;
1A12490 	58 46 A0  1 

forth definitions

headers
: case:   (s n --  ) \ define positional case defining word
1A12494 	 0  0 63 61 
1A12498 	73 65 3A 85 98 20 A1  1 
1A124A0 	20 40 A0  1 
   create ,  hide    ]
1A124A4 	A8 A2 A0  1 
1A124A8 	98 55 A0  1 54 A5 A0  1 
1A124B0 	A0 6D A0  1 
   does>   ( #subscript -- ) \ executes #'th word
1A124B4 	50 A3 A0  1 
1A124B8 	90 90 90 E8 BC 1B FF FF 
      maptoken  token@  execute
1A124C0 	58 24 A1  1  C 54 A0  1 
1A124C8 	98 41 A0  1 
;
1A124CC 	58 46 A0  1 

doestarget @ to do_case:

: tassociative:
1A124D0 	 0  0 74 61 73 73 6F 63 
1A124D8 	69 61 74 69 76 65 3A 8D 
1A124E0 	A0 24 A1  1 20 40 A0  1 
   create ,
1A124E8 	A8 A2 A0  1 98 55 A0  1 
   does>         (s n -- index )
1A124F0 	50 A3 A0  1 90 90 90 E8 
1A124F8 	80 1B FF FF 
      dup @              ( n pfa cnt )
1A124FC 	40 49 A0  1 
1A12500 	5C 4C A0  1 
      dup >r -rot na1+        ( cnt n table-addr )
1A12504 	40 49 A0  1 
1A12508 	BC 45 A0  1 94 49 A0  1 
1A12510 	CC 50 A0  1 
      r> 0  do                ( cnt n table-addr )
1A12514 	D0 45 A0  1 
1A12518 	70 6F A0  1 88 42 A0  1 
1A12520 	3C  0  0  0 
         2dup token@ =  if    ( cnt n pfa' )
1A12524 	C0 49 A0  1 
1A12528 	 C 54 A0  1 24 48 A0  1 
1A12530 	DC 41 A0  1 1C  0  0  0 
            2drop drop   i 0 0   leave
1A12538 	AC 49 A0  1 30 49 A0  1 
1A12540 	B4 42 A0  1 70 6F A0  1 
1A12548 	70 6F A0  1 18 43 A0  1 
         then
         \ clear stack and return index that matched
         ta1+
1A12550 	FC 50 A0  1 
      loop
1A12554 	F8 41 A0  1 
1A12558 	CC FF FF FF 
      2drop
1A1255C 	AC 49 A0  1 
;
1A12560 	58 46 A0  1 

hidden definitions
: #entries  ( associative-acf -- n )  >body @  ;
1A12564 	 0  0  0 23 
1A12568 	65 6E 74 72 69 65 73 88 
1A12570 	58 24 A1  1 20 40 A0  1 
1A12578 	E4 59 A0  1 5C 4C A0  1 
1A12580 	58 46 A0  1 

: nulldis  ( apf -- )  drop ." <no disassembler>"  ;
1A12584 	6E 75 6C 6C 
1A12588 	64 69 73 87 74 25 A1  1 
1A12590 	20 40 A0  1 30 49 A0  1 
1A12598 	20 7C A0  1 11 3C 6E 6F 
1A125A0 	20 64 69 73 61 73 73 65 
1A125A8 	6D 62 6C 65 72 3E  0  0 
1A125B0 	58 46 A0  1 
defer disassemble  ' nulldis is disassemble
1A125B4 	64 69 73 61 
1A125B8 	73 73 65 6D 62 6C 65 8B 
1A125C0 	90 25 A1  1 5C 40 A0  1 
1A125C8 	78  3  0  0 

headerless

\ Breaks is a list of places in a colon definition where control
\ is transferred without there being a branch nearby.
\ Each entry has two items: the address and a number which indicates
\ what kind of branch target it is (either a begin, for backward branches,
\ a then, for forward branches, or an exit.

d# 40 2* /n* constant /breaks
1A125CC 	2F 62 72 65 
1A125D0 	61 6B 73 87 C4 25 A1  1 
1A125D8 	68 40 A0  1 40  1  0  0 
/breaks buffer: breaks
1A125E0 	 0 62 72 65 61 6B 73 86 
1A125E8 	D8 25 A1  1 B4 A9 A0  1 
1A125F0 	7C  3  0  0 40  1  0  0 
1A125F8 	C8 20 A1  1 
variable end-breaks
1A125FC 	 0 65 6E 64 
1A12600 	2D 62 72 65 61 6B 73 8A 
1A12608 	EC 25 A1  1 48 40 A0  1 
1A12610 	80  3  0  0 

variable break-type  variable break-addr   variable where-break
1A12614 	 0 62 72 65 
1A12618 	61 6B 2D 74 79 70 65 8A 
1A12620 	 C 26 A1  1 48 40 A0  1 
1A12628 	84  3  0  0  0 62 72 65 
1A12630 	61 6B 2D 61 64 64 72 8A 
1A12638 	24 26 A1  1 48 40 A0  1 
1A12640 	88  3  0  0 77 68 65 72 
1A12648 	65 2D 62 72 65 61 6B 8B 
1A12650 	3C 26 A1  1 48 40 A0  1 
1A12658 	8C  3  0  0 
: next-break  ( -- break-address break-type )
1A1265C 	 0 6E 65 78 
1A12660 	74 2D 62 72 65 61 6B 8A 
1A12668 	54 26 A1  1 20 40 A0  1 
   -1 break-addr !   ( prime stack)
1A12670 	58 41 A0  1 FF FF FF FF 
1A12678 	3C 26 A1  1 54 4D A0  1 
   end-breaks @  breaks  ?do
1A12680 	 C 26 A1  1 5C 4C A0  1 
1A12688 	EC 25 A1  1 50 42 A0  1 
1A12690 	5C  0  0  0 
      i  2@ over   break-addr @ u<  if
1A12694 	B4 42 A0  1 
1A12698 	CC 4D A0  1 54 49 A0  1 
1A126A0 	3C 26 A1  1 5C 4C A0  1 
1A126A8 	A8 48 A0  1 DC 41 A0  1 
1A126B0 	28  0  0  0 
         break-type !  break-addr !  i where-break !
1A126B4 	24 26 A1  1 
1A126B8 	54 4D A0  1 3C 26 A1  1 
1A126C0 	54 4D A0  1 B4 42 A0  1 
1A126C8 	54 26 A1  1 54 4D A0  1 
      else
1A126D0 	C8 41 A0  1  8  0  0  0 
         2drop
1A126D8 	AC 49 A0  1 
      then
   /n 2* +loop
1A126DC 	40 51 A0  1 
1A126E0 	A0 4B A0  1 1C 42 A0  1 
1A126E8 	AC FF FF FF 
   break-addr @  -1  <>  if  -1 -1 where-break @ 2!  then
1A126EC 	3C 26 A1  1 
1A126F0 	5C 4C A0  1 58 41 A0  1 
1A126F8 	FF FF FF FF 44 48 A0  1 
1A12700 	DC 41 A0  1 20  0  0  0 
1A12708 	58 41 A0  1 FF FF FF FF 
1A12710 	58 41 A0  1 FF FF FF FF 
1A12718 	54 26 A1  1 5C 4C A0  1 
1A12720 	E4 4D A0  1 
;
1A12724 	58 46 A0  1 
: forward-branch?  ( ip-of-branch-token -- f )
1A12728 	66 6F 72 77 61 72 64 2D 
1A12730 	62 72 61 6E 63 68 3F 8F 
1A12738 	6C 26 A1  1 20 40 A0  1 
   dup >target u<
1A12740 	40 49 A0  1 58 58 A0  1 
1A12748 	A8 48 A0  1 
;
1A1274C 	58 46 A0  1 

\ Bare-if? checks to see if the target address on the stack was
\ produced by an IF with no ELSE.  This is used to decide whether
\ to put a THEN at that target address.  If the conditional branch
\ to this target is part of an IF ELSE THEN, the target address
\ for the THEN is found from the ELSE.  If the conditional branch
\ to this target was produced by a WHILE, there is no THEN.
: bare-if? ( ip-of-branch-target -- f )
1A12750 	 0  0  0 62 61 72 65 2D 
1A12758 	69 66 3F 88 3C 27 A1  1 
1A12760 	20 40 A0  1 
   /branch - /token - dup token@  ( ip' possible-branch-acf )
1A12764 	FC 57 A0  1 
1A12768 	18 45 A0  1 B4 46 A0  1 
1A12770 	18 45 A0  1 40 49 A0  1 
1A12778 	 C 54 A0  1 
   dup ['] branch  =    \ unconditional branch means else or repeat
1A1277C 	40 49 A0  1 
1A12780 	60 53 A0  1 C8 41 A0  1 
1A12788 	24 48 A0  1 
   if  drop drop false exit then  ( ip' acf )
1A1278C 	DC 41 A0  1 
1A12790 	14  0  0  0 30 49 A0  1 
1A12798 	30 49 A0  1 18 70 A0  1 
1A127A0 	40 46 A0  1 
   ['] ?branch =        \ cond. forw. branch is for an IF THEN with null body
1A127A4 	60 53 A0  1 
1A127A8 	DC 41 A0  1 24 48 A0  1 
   if   forward-branch?  else  drop true  then
1A127B0 	DC 41 A0  1 10  0  0  0 
1A127B8 	3C 27 A1  1 C8 41 A0  1 
1A127C0 	 C  0  0  0 30 49 A0  1 
1A127C8 	 4 70 A0  1 
;
1A127CC 	58 46 A0  1 

\ While? decides if the conditional branch at the current ip is
\ for a WHILE as opposed to an IF.  It finds out by looking at the
\ target for the conditional branch;  if there is a backward branch
\ just before the target, it is a WHILE.
: while?  ( ip-of-?branch -- f )
1A127D0 	 0 77 68 69 6C 65 3F 86 
1A127D8 	60 27 A1  1 20 40 A0  1 
  >target  /branch - /token - dup token@  ( ip' possible-branch-acf )
1A127E0 	58 58 A0  1 FC 57 A0  1 
1A127E8 	18 45 A0  1 B4 46 A0  1 
1A127F0 	18 45 A0  1 40 49 A0  1 
1A127F8 	 C 54 A0  1 
  ['] branch =  if          \ looking for the uncond. branch from the REPEAT
1A127FC 	60 53 A0  1 
1A12800 	C8 41 A0  1 24 48 A0  1 
1A12808 	DC 41 A0  1 14  0  0  0 
     forward-branch? 0=     \ if the branch is forward, it's an IF .. ELSE
1A12810 	3C 27 A1  1 24 47 A0  1 
  else
1A12818 	C8 41 A0  1  C  0  0  0 
     drop false
1A12820 	30 49 A0  1 18 70 A0  1 
  then

;
1A12828 	58 46 A0  1 

: .begin  ( -- )  .." begin " +indent  ;
1A1282C 	 0 2E 62 65 
1A12830 	67 69 6E 86 DC 27 A1  1 
1A12838 	20 40 A0  1 9C 53 A0  1 
1A12840 	 6 62 65 67 69 6E 20  0 
1A12848 	60 23 A1  1 14 23 A1  1 
1A12850 	58 46 A0  1 
: .then   ( -- )  -indent .." then"  cr  ;
1A12854 	 0  0 2E 74 
1A12858 	68 65 6E 85 38 28 A1  1 
1A12860 	20 40 A0  1 38 23 A1  1 
1A12868 	9C 53 A0  1  4 74 68 65 
1A12870 	6E  0  0  0 60 23 A1  1 
1A12878 	80 6D A0  1 58 46 A0  1 

\ Extent holds the largest known extent of the current word, as determined
\ by branch targets seen so far.  This is used to decide if an exit should
\ terminate the decompilation, or whether it is "protected" by a conditional.
variable extent  extent off
1A12880 	 0 65 78 74 65 6E 74 86 
1A12888 	60 28 A1  1 48 40 A0  1 
1A12890 	90  3  0  0 
: +extent  ( possible-new-extent -- )  extent @ umax extent !  ;
1A12894 	2B 65 78 74 
1A12898 	65 6E 74 87 8C 28 A1  1 
1A128A0 	20 40 A0  1 8C 28 A1  1 
1A128A8 	5C 4C A0  1 C8 4A A0  1 
1A128B0 	8C 28 A1  1 54 4D A0  1 
1A128B8 	58 46 A0  1 
: +branch  ( ip-of-branch -- next-ip )  ta1+ /branch +  ;
1A128BC 	2B 62 72 61 
1A128C0 	6E 63 68 87 A0 28 A1  1 
1A128C8 	20 40 A0  1 FC 50 A0  1 
1A128D0 	FC 57 A0  1  4 45 A0  1 
1A128D8 	58 46 A0  1 
: .endof  ( ip -- ip' )  .." endof" cr +branch  ;
1A128DC 	 0 2E 65 6E 
1A128E0 	64 6F 66 86 C8 28 A1  1 
1A128E8 	20 40 A0  1 9C 53 A0  1 
1A128F0 	 5 65 6E 64 6F 66  0  0 
1A128F8 	60 23 A1  1 80 6D A0  1 
1A12900 	C8 28 A1  1 58 46 A0  1 
: .endcase  ( ip -- ip' )  .." endcase" cr ta1+  ;
1A12908 	 0  0  0 2E 65 6E 64 63 
1A12910 	61 73 65 88 E8 28 A1  1 
1A12918 	20 40 A0  1 9C 53 A0  1 
1A12920 	 7 65 6E 64 63 61 73 65 
1A12928 	 0  0  0  0 60 23 A1  1 
1A12930 	80 6D A0  1 FC 50 A0  1 
1A12938 	58 46 A0  1 
: .$endof  ( ip -- ip' )  .." $endof" cr +branch  ;
1A1293C 	2E 24 65 6E 
1A12940 	64 6F 66 87 18 29 A1  1 
1A12948 	20 40 A0  1 9C 53 A0  1 
1A12950 	 6 24 65 6E 64 6F 66  0 
1A12958 	60 23 A1  1 80 6D A0  1 
1A12960 	C8 28 A1  1 58 46 A0  1 
: .$endcase  ( ip -- ip' )  .." $endcase" cr ta1+  ;
1A12968 	 0  0 2E 24 65 6E 64 63 
1A12970 	61 73 65 89 48 29 A1  1 
1A12978 	20 40 A0  1 9C 53 A0  1 
1A12980 	 8 24 65 6E 64 63 61 73 
1A12988 	65  0  0  0 60 23 A1  1 
1A12990 	80 6D A0  1 FC 50 A0  1 
1A12998 	58 46 A0  1 

: add-break  ( break-address break-type -- )
1A1299C 	 0  0 61 64 
1A129A0 	64 2D 62 72 65 61 6B 89 
1A129A8 	78 29 A1  1 20 40 A0  1 
   end-breaks @  breaks /breaks +  >=        ( adr,type full? )
1A129B0 	 C 26 A1  1 5C 4C A0  1 
1A129B8 	EC 25 A1  1 D8 25 A1  1 
1A129C0 	 4 45 A0  1 EC 48 A0  1 
   abort" Decompiler table overflow"         ( adr,type )
1A129C8 	 8 81 A0  1 19 44 65 63 
1A129D0 	6F 6D 70 69 6C 65 72 20 
1A129D8 	74 61 62 6C 65 20 6F 76 
1A129E0 	65 72 66 6C 6F 77  0  0 
   end-breaks @ breaks >  if                 ( adr,type )
1A129E8 	 C 26 A1  1 5C 4C A0  1 
1A129F0 	EC 25 A1  1  4 48 A0  1 
1A129F8 	DC 41 A0  1 6C  0  0  0 
      over end-breaks @ /n 2* - >r r@ 2@     ( adr,type  adr prev-adr,type )
1A12A00 	54 49 A0  1  C 26 A1  1 
1A12A08 	5C 4C A0  1 40 51 A0  1 
1A12A10 	A0 4B A0  1 18 45 A0  1 
1A12A18 	BC 45 A0  1 E4 45 A0  1 
1A12A20 	CC 4D A0  1 
      ['] .endof  =  -rot  =  and  if        ( adr,type )
1A12A24 	60 53 A0  1 
1A12A28 	E8 28 A1  1 24 48 A0  1 
1A12A30 	94 49 A0  1 24 48 A0  1 
1A12A38 	5C 44 A0  1 DC 41 A0  1 
1A12A40 	20  0  0  0 
	 r@ 2@  2swap  r> 2!                 ( prev-adr,type )
1A12A44 	E4 45 A0  1 
1A12A48 	CC 4D A0  1 F4 49 A0  1 
1A12A50 	D0 45 A0  1 E4 4D A0  1 
      else                                   ( adr,type )
1A12A58 	C8 41 A0  1  C  0  0  0 
	 r> drop                             ( adr,type )
1A12A60 	D0 45 A0  1 30 49 A0  1 
      then                                   ( adr,type )
   then                                      ( adr,type )
   end-breaks @ 2!  /n 2*  end-breaks +!     (  )
1A12A68 	 C 26 A1  1 5C 4C A0  1 
1A12A70 	E4 4D A0  1 40 51 A0  1 
1A12A78 	A0 4B A0  1  C 26 A1  1 
1A12A80 	 C 4C A0  1 
;
1A12A84 	58 46 A0  1 
: ?add-break  ( break-address break-type -- )
1A12A88 	 0 3F 61 64 64 2D 62 72 
1A12A90 	65 61 6B 8A AC 29 A1  1 
1A12A98 	20 40 A0  1 
   over             ( break-address break-type break-address )
1A12A9C 	54 49 A0  1 
   end-breaks @ breaks  ?do
1A12AA0 	 C 26 A1  1 5C 4C A0  1 
1A12AA8 	EC 25 A1  1 50 42 A0  1 
1A12AB0 	3C  0  0  0 
      dup  i 2@ drop   =  ( found? )  if
1A12AB4 	40 49 A0  1 
1A12AB8 	B4 42 A0  1 CC 4D A0  1 
1A12AC0 	30 49 A0  1 24 48 A0  1 
1A12AC8 	DC 41 A0  1 10  0  0  0 
         drop 0  leave
1A12AD0 	30 49 A0  1 70 6F A0  1 
1A12AD8 	18 43 A0  1 
      then
   /n 2*  +loop     ( break-address break-type not-found? )
1A12ADC 	40 51 A0  1 
1A12AE0 	A0 4B A0  1 1C 42 A0  1 
1A12AE8 	CC FF FF FF 

   if  add-break  else  2drop  then
1A12AEC 	DC 41 A0  1 
1A12AF0 	10  0  0  0 AC 29 A1  1 
1A12AF8 	C8 41 A0  1  8  0  0  0 
1A12B00 	AC 49 A0  1 
;
1A12B04 	58 46 A0  1 

: scan-of  ( ip-of-(of -- ip' )
1A12B08 	73 63 61 6E 2D 6F 66 87 
1A12B10 	98 2A A1  1 20 40 A0  1 
   dup >target dup +extent   ( ip next-of )
1A12B18 	40 49 A0  1 58 58 A0  1 
1A12B20 	40 49 A0  1 A0 28 A1  1 
   /branch - /token -        ( ip endof-addr )
1A12B28 	FC 57 A0  1 18 45 A0  1 
1A12B30 	B4 46 A0  1 18 45 A0  1 
   dup ['] .endof add-break  ( ip endof-addr )
1A12B38 	40 49 A0  1 60 53 A0  1 
1A12B40 	E8 28 A1  1 AC 29 A1  1 
   ['] .endcase ?add-break
1A12B48 	60 53 A0  1 18 29 A1  1 
1A12B50 	98 2A A1  1 
   +branch
1A12B54 	C8 28 A1  1 
;
1A12B58 	58 46 A0  1 
: scan-$of  ( ip-of-($of -- ip' )
1A12B5C 	 0  0  0 73 
1A12B60 	63 61 6E 2D 24 6F 66 88 
1A12B68 	14 2B A1  1 20 40 A0  1 
   dup >target dup +extent   ( ip next-$of )
1A12B70 	40 49 A0  1 58 58 A0  1 
1A12B78 	40 49 A0  1 A0 28 A1  1 
   /branch - /token -        ( ip $endof-addr )
1A12B80 	FC 57 A0  1 18 45 A0  1 
1A12B88 	B4 46 A0  1 18 45 A0  1 
   dup ['] .$endof add-break  ( ip $endof-addr )
1A12B90 	40 49 A0  1 60 53 A0  1 
1A12B98 	48 29 A1  1 AC 29 A1  1 
   ['] .$endcase ?add-break
1A12BA0 	60 53 A0  1 78 29 A1  1 
1A12BA8 	98 2A A1  1 
   +branch
1A12BAC 	C8 28 A1  1 
;
1A12BB0 	58 46 A0  1 
: scan-branch  ( ip-of-?branch -- ip' )
1A12BB4 	73 63 61 6E 
1A12BB8 	2D 62 72 61 6E 63 68 8B 
1A12BC0 	6C 2B A1  1 20 40 A0  1 
   dup dup forward-branch?  if
1A12BC8 	40 49 A0  1 40 49 A0  1 
1A12BD0 	3C 27 A1  1 DC 41 A0  1 
1A12BD8 	40  0  0  0 
      >target dup +extent   ( branch-target-address)
1A12BDC 	58 58 A0  1 
1A12BE0 	40 49 A0  1 A0 28 A1  1 
      dup bare-if?  if  ( ip ) \ is this an IF branch?
1A12BE8 	40 49 A0  1 60 27 A1  1 
1A12BF0 	DC 41 A0  1 18  0  0  0 
         ['] .then add-break
1A12BF8 	60 53 A0  1 60 28 A1  1 
1A12C00 	AC 29 A1  1 
      else
1A12C04 	C8 41 A0  1 
1A12C08 	 8  0  0  0 
         drop
1A12C0C 	30 49 A0  1 
      then
   else
1A12C10 	C8 41 A0  1 14  0  0  0 
      >target  ['] .begin add-break
1A12C18 	58 58 A0  1 60 53 A0  1 
1A12C20 	38 28 A1  1 AC 29 A1  1 
   then
   +branch
1A12C28 	C8 28 A1  1 
;
1A12C2C 	58 46 A0  1 

: scan-unnest  ( ip -- ip' | 0 )
1A12C30 	73 63 61 6E 2D 75 6E 6E 
1A12C38 	65 73 74 8B C4 2B A1  1 
1A12C40 	20 40 A0  1 
   dup extent @ u>=  if  drop 0  else  ta1+  then
1A12C44 	40 49 A0  1 
1A12C48 	8C 28 A1  1 5C 4C A0  1 
1A12C50 	CC 48 A0  1 DC 41 A0  1 
1A12C58 	14  0  0  0 30 49 A0  1 
1A12C60 	70 6F A0  1 C8 41 A0  1 
1A12C68 	 8  0  0  0 FC 50 A0  1 
;
1A12C70 	58 46 A0  1 
: scan-;code ( ip -- ip' | 0 )  does-ip?  0=  if  drop 0  then  ;
1A12C74 	 0 73 63 61 
1A12C78 	6E 2D 3B 63 6F 64 65 8A 
1A12C80 	40 2C A1  1 20 40 A0  1 
1A12C88 	F8 56 A0  1 24 47 A0  1 
1A12C90 	DC 41 A0  1  C  0  0  0 
1A12C98 	30 49 A0  1 70 6F A0  1 
1A12CA0 	58 46 A0  1 
: .;code    (s ip -- ip' )
1A12CA4 	 0 2E 3B 63 
1A12CA8 	6F 64 65 86 84 2C A1  1 
1A12CB0 	20 40 A0  1 
   does-ip?  if
1A12CB4 	F8 56 A0  1 
1A12CB8 	DC 41 A0  1 20  0  0  0 
      ??cr .." does> "
1A12CC0 	 0 A1 A0  1 9C 53 A0  1 
1A12CC8 	 6 64 6F 65 73 3E 20  0 
1A12CD0 	60 23 A1  1 
   else
1A12CD4 	C8 41 A0  1 
1A12CD8 	30  0  0  0 
      ??cr 0 lmargin ! .." ;code "  cr disassemble     0
1A12CDC 	 0 A1 A0  1 
1A12CE0 	70 6F A0  1 80 13 A1  1 
1A12CE8 	54 4D A0  1 9C 53 A0  1 
1A12CF0 	 6 3B 63 6F 64 65 20  0 
1A12CF8 	60 23 A1  1 80 6D A0  1 
1A12D00 	C4 25 A1  1 70 6F A0  1 
   then
;
1A12D08 	58 46 A0  1 
: .branch  ( ip -- ip' )
1A12D0C 	2E 62 72 61 
1A12D10 	6E 63 68 87 B0 2C A1  1 
1A12D18 	20 40 A0  1 
   dup forward-branch?  if
1A12D1C 	40 49 A0  1 
1A12D20 	3C 27 A1  1 DC 41 A0  1 
1A12D28 	24  0  0  0 
      -indent .." else" +indent
1A12D2C 	38 23 A1  1 
1A12D30 	9C 53 A0  1  4 65 6C 73 
1A12D38 	65  0  0  0 60 23 A1  1 
1A12D40 	14 23 A1  1 
   else
1A12D44 	C8 41 A0  1 
1A12D48 	1C  0  0  0 
      -indent .." repeat" cr
1A12D4C 	38 23 A1  1 
1A12D50 	9C 53 A0  1  6 72 65 70 
1A12D58 	65 61 74  0 60 23 A1  1 
1A12D60 	80 6D A0  1 
   then
   +branch
1A12D64 	C8 28 A1  1 
;
1A12D68 	58 46 A0  1 
: .?branch  ( ip -- ip' )
1A12D6C 	 0  0  0 2E 
1A12D70 	3F 62 72 61 6E 63 68 88 
1A12D78 	18 2D A1  1 20 40 A0  1 
  dup forward-branch?  if
1A12D80 	40 49 A0  1 3C 27 A1  1 
1A12D88 	DC 41 A0  1 4C  0  0  0 
     dup while?  if
1A12D90 	40 49 A0  1 DC 27 A1  1 
1A12D98 	DC 41 A0  1 24  0  0  0 
        -indent .." while" +indent
1A12DA0 	38 23 A1  1 9C 53 A0  1 
1A12DA8 	 5 77 68 69 6C 65  0  0 
1A12DB0 	60 23 A1  1 14 23 A1  1 
     else
1A12DB8 	C8 41 A0  1 14  0  0  0 
        .." if"  +indent
1A12DC0 	9C 53 A0  1  2 69 66  0 
1A12DC8 	60 23 A1  1 14 23 A1  1 
     then
  else
1A12DD0 	C8 41 A0  1 1C  0  0  0 
     -indent .." until " cr
1A12DD8 	38 23 A1  1 9C 53 A0  1 
1A12DE0 	 6 75 6E 74 69 6C 20  0 
1A12DE8 	60 23 A1  1 80 6D A0  1 
  then
  +branch
1A12DF0 	C8 28 A1  1 
;
1A12DF4 	58 46 A0  1 

: .do     ( ip -- ip' )  .." do    " +indent  +branch  ;
1A12DF8 	2E 64 6F 83 7C 2D A1  1 
1A12E00 	20 40 A0  1 9C 53 A0  1 
1A12E08 	 6 64 6F 20 20 20 20  0 
1A12E10 	60 23 A1  1 14 23 A1  1 
1A12E18 	C8 28 A1  1 58 46 A0  1 
: .?do    ( ip -- ip' )  .." ?do   " +indent  +branch  ;
1A12E20 	 0  0  0 2E 3F 64 6F 84 
1A12E28 	 0 2E A1  1 20 40 A0  1 
1A12E30 	9C 53 A0  1  6 3F 64 6F 
1A12E38 	20 20 20  0 60 23 A1  1 
1A12E40 	14 23 A1  1 C8 28 A1  1 
1A12E48 	58 46 A0  1 
: .loop   ( ip -- ip' )  -indent .." loop  " cr +branch  ;
1A12E4C 	 0  0 2E 6C 
1A12E50 	6F 6F 70 85 2C 2E A1  1 
1A12E58 	20 40 A0  1 38 23 A1  1 
1A12E60 	9C 53 A0  1  6 6C 6F 6F 
1A12E68 	70 20 20  0 60 23 A1  1 
1A12E70 	80 6D A0  1 C8 28 A1  1 
1A12E78 	58 46 A0  1 
: .+loop  ( ip -- ip' )  -indent .." +loop " cr +branch  ;
1A12E7C 	 0 2E 2B 6C 
1A12E80 	6F 6F 70 86 58 2E A1  1 
1A12E88 	20 40 A0  1 38 23 A1  1 
1A12E90 	9C 53 A0  1  6 2B 6C 6F 
1A12E98 	6F 70 20  0 60 23 A1  1 
1A12EA0 	80 6D A0  1 C8 28 A1  1 
1A12EA8 	58 46 A0  1 
: .of     ( ip -- ip' )  .." of   " +branch  ;
1A12EAC 	2E 6F 66 83 
1A12EB0 	88 2E A1  1 20 40 A0  1 
1A12EB8 	9C 53 A0  1  5 6F 66 20 
1A12EC0 	20 20  0  0 60 23 A1  1 
1A12EC8 	C8 28 A1  1 58 46 A0  1 
: .$of    ( ip -- ip' )  .." $of  " +branch  ;
1A12ED0 	 0  0  0 2E 24 6F 66 84 
1A12ED8 	B4 2E A1  1 20 40 A0  1 
1A12EE0 	9C 53 A0  1  5 24 6F 66 
1A12EE8 	20 20  0  0 60 23 A1  1 
1A12EF0 	C8 28 A1  1 58 46 A0  1 

\ first check for word being immediate so that it may be preceded
\ by [compile] if necessary
: check-[compile]  ( acf -- acf )
1A12EF8 	63 68 65 63 6B 2D 5B 63 
1A12F00 	6F 6D 70 69 6C 65 5D 8F 
1A12F08 	DC 2E A1  1 20 40 A0  1 
   dup immediate?  if  .." [compile] "  then
1A12F10 	40 49 A0  1 FC B8 A0  1 
1A12F18 	DC 41 A0  1 18  0  0  0 
1A12F20 	9C 53 A0  1  A 5B 63 6F 
1A12F28 	6D 70 69 6C 65 5D 20  0 
1A12F30 	60 23 A1  1 
;
1A12F34 	58 46 A0  1 

: put"  (s -- )  ascii " emit  space  ;
1A12F38 	 0  0  0 70 75 74 22 84 
1A12F40 	 C 2F A1  1 20 40 A0  1 
1A12F48 	58 41 A0  1 22  0  0  0 
1A12F50 	2C 6C A0  1 CC 71 A0  1 
1A12F58 	58 46 A0  1 

: cword-name  (s ip -- ip' $ name$ )
1A12F5C 	 0 63 77 6F 
1A12F60 	72 64 2D 6E 61 6D 65 8A 
1A12F68 	44 2F A1  1 20 40 A0  1 
   dup token@          ( ip acf )
1A12F70 	40 49 A0  1  C 54 A0  1 
   >name name>string   ( ip name$ )
1A12F78 	24 74 A0  1 58 74 A0  1 
   swap 1+ swap 2 -    ( ip name$' )  \ Remove parentheses
1A12F80 	68 49 A0  1 30 4B A0  1 
1A12F88 	68 49 A0  1 90 6F A0  1 
1A12F90 	18 45 A0  1 
   rot ta1+ -rot       ( ip' name$ )
1A12F94 	7C 49 A0  1 
1A12F98 	FC 50 A0  1 94 49 A0  1 
   2 pick count        ( ip name$ $ )
1A12FA0 	90 6F A0  1  C 4A A0  1 
1A12FA8 	BC 53 A0  1 
   2swap               ( ip $ name$ )
1A12FAC 	F4 49 A0  1 
;
1A12FB0 	58 46 A0  1 

: type#  ( $ -- )  \ render control characters as green #
1A12FB4 	 0  0 74 79 
1A12FB8 	70 65 23 85 6C 2F A1  1 
1A12FC0 	20 40 A0  1 
   bounds ?do
1A12FC4 	F0 6D A0  1 
1A12FC8 	50 42 A0  1 4C  0  0  0 
      i c@ dup h# 20 < if
1A12FD0 	B4 42 A0  1 C4 4C A0  1 
1A12FD8 	40 49 A0  1 58 41 A0  1 
1A12FE0 	20  0  0  0 E4 47 A0  1 
1A12FE8 	DC 41 A0  1 20  0  0  0 
	 drop green-letters ." #" red-letters
1A12FF0 	30 49 A0  1 C0 F9 A0  1 
1A12FF8 	20 7C A0  1  1 23  0  0 
1A13000 	A4 F9 A0  1 
      else
1A13004 	C8 41 A0  1 
1A13008 	 8  0  0  0 
	 emit
1A1300C 	2C 6C A0  1 
      then
   loop
1A13010 	F8 41 A0  1 BC FF FF FF 
;
1A13018 	58 46 A0  1 

: .string-tail  ( $ name$ -- )
1A1301C 	 0  0  0 2E 
1A13020 	73 74 72 69 6E 67 2D 74 
1A13028 	61 69 6C 8C C0 2F A1  1 
1A13030 	20 40 A0  1 
   2 pick over +  3 + ?line    ( $ name$ )  \ Keep word and string on the same line
1A13034 	90 6F A0  1 
1A13038 	 C 4A A0  1 54 49 A0  1 
1A13040 	 4 45 A0  1 A0 6F A0  1 
1A13048 	 4 45 A0  1 A8 13 A1  1 
   cr".  space                 ( $ )
1A13050 	60 23 A1  1 CC 71 A0  1 
   red-letters type#           ( )
1A13058 	A4 F9 A0  1 C0 2F A1  1 
   magenta-letters             ( )
1A13060 	14 FA A0  1 
   ." "" "                     ( )
1A13064 	20 7C A0  1 
1A13068 	 2 22 20  0 
   cancel                      ( )
1A1306C 	BC F7 A0  1 
;
1A13070 	58 46 A0  1 

: pretty-. ( n -- )
1A13074 	 0  0  0 70 
1A13078 	72 65 74 74 79 2D 2E 88 
1A13080 	30 30 A1  1 20 40 A0  1 
   base @ d# 10 =  if  (.)  else  (u.)  then   ( adr len )
1A13088 	B8 75 A0  1 5C 4C A0  1 
1A13090 	58 41 A0  1  A  0  0  0 
1A13098 	24 48 A0  1 DC 41 A0  1 
1A130A0 	10  0  0  0 10 78 A0  1 
1A130A8 	C8 41 A0  1  8  0  0  0 
1A130B0 	AC 77 A0  1 
   dup 3 + ?line  indent  add-position
1A130B4 	40 49 A0  1 
1A130B8 	A0 6F A0  1  4 45 A0  1 
1A130C0 	A8 13 A1  1 C8 22 A1  1 
1A130C8 	C0 21 A1  1 
   green-letters 
1A130CC 	C0 F9 A0  1 
   base @ case
1A130D0 	B8 75 A0  1 5C 4C A0  1 
      d# 10 of  ." d# "  endof
1A130D8 	58 41 A0  1  A  0  0  0 
1A130E0 	48 43 A0  1 18  0  0  0 
1A130E8 	20 7C A0  1  3 64 23 20 
1A130F0 	 0  0  0  0 6C 43 A0  1 
1A130F8 	74  0  0  0 
      d# 16 of  ." h# "  endof
1A130FC 	58 41 A0  1 
1A13100 	10  0  0  0 48 43 A0  1 
1A13108 	18  0  0  0 20 7C A0  1 
1A13110 	 3 68 23 20  0  0  0  0 
1A13118 	6C 43 A0  1 50  0  0  0 
      d#  8 of  ." o# "  endof
1A13120 	58 41 A0  1  8  0  0  0 
1A13128 	48 43 A0  1 18  0  0  0 
1A13130 	20 7C A0  1  3 6F 23 20 
1A13138 	 0  0  0  0 6C 43 A0  1 
1A13140 	2C  0  0  0 
      d#  2 of  ." b# "  endof
1A13144 	58 41 A0  1 
1A13148 	 2  0  0  0 48 43 A0  1 
1A13150 	18  0  0  0 20 7C A0  1 
1A13158 	 3 62 23 20  0  0  0  0 
1A13160 	6C 43 A0  1  8  0  0  0 
   endcase
1A13168 	84 43 A0  1 
   type cancel  space
1A1316C 	 4 6C A0  1 
1A13170 	BC F7 A0  1 CC 71 A0  1 
;
1A13178 	58 46 A0  1 

: .compiled  ( ip -- ip' )
1A1317C 	 0  0 2E 63 
1A13180 	6F 6D 70 69 6C 65 64 89 
1A13188 	84 30 A1  1 20 40 A0  1 
   dup token@ check-[compile]   ( ip xt )
1A13190 	40 49 A0  1  C 54 A0  1 
1A13198 	 C 2F A1  1 
   >name name>string            ( ip adr len )
1A1319C 	24 74 A0  1 
1A131A0 	58 74 A0  1 
   type space                   ( ip )
1A131A4 	 4 6C A0  1 
1A131A8 	CC 71 A0  1 
   ta1+                         ( ip' )
1A131AC 	FC 50 A0  1 
;
1A131B0 	58 46 A0  1 
: .word         ( ip -- ip' )
1A131B4 	 0  0 2E 77 
1A131B8 	6F 72 64 85 8C 31 A1  1 
1A131C0 	20 40 A0  1 
   indent
1A131C4 	C8 22 A1  1 
   dup token@ check-[compile]   ( ip xt )
1A131C8 	40 49 A0  1  C 54 A0  1 
1A131D0 	 C 2F A1  1 
   >name name>string            ( ip adr len )
1A131D4 	24 74 A0  1 
1A131D8 	58 74 A0  1 
   dup ?line  add-position      ( ip adr len )
1A131DC 	40 49 A0  1 
1A131E0 	A8 13 A1  1 C0 21 A1  1 
   type space                   ( ip )
1A131E8 	 4 6C A0  1 CC 71 A0  1 
   ta1+                         ( ip' )
1A131F0 	FC 50 A0  1 
;
1A131F4 	58 46 A0  1 
: skip-word     ( ip -- ip' )  ta1+  ;
1A131F8 	 0  0 73 6B 69 70 2D 77 
1A13200 	6F 72 64 89 C0 31 A1  1 
1A13208 	20 40 A0  1 FC 50 A0  1 
1A13210 	58 46 A0  1 
: .inline       ( ip -- ip' )  ta1+ dup unaligned-@  pretty-.  na1+   ;
1A13214 	2E 69 6E 6C 
1A13218 	69 6E 65 87  8 32 A1  1 
1A13220 	20 40 A0  1 FC 50 A0  1 
1A13228 	40 49 A0  1 E0 4C A0  1 
1A13230 	84 30 A1  1 CC 50 A0  1 
1A13238 	58 46 A0  1 
: skip-inline   ( ip -- ip' )  ta1+ na1+  ;
1A1323C 	73 6B 69 70 
1A13240 	2D 69 6E 6C 69 6E 65 8B 
1A13248 	20 32 A1  1 20 40 A0  1 
1A13250 	FC 50 A0  1 CC 50 A0  1 
1A13258 	58 46 A0  1 
: .wlit         ( ip -- ip' )  ta1+ dup unaligned-w@ 1- pretty-. wa1+  ;
1A1325C 	 0  0 2E 77 
1A13260 	6C 69 74 85 4C 32 A1  1 
1A13268 	20 40 A0  1 FC 50 A0  1 
1A13270 	40 49 A0  1 18 4D A0  1 
1A13278 	54 4B A0  1 84 30 A1  1 
1A13280 	A0 50 A0  1 58 46 A0  1 
: skip-wlit     ( ip -- ip' )  ta1+ wa1+  ;
1A13288 	 0  0 73 6B 69 70 2D 77 
1A13290 	6C 69 74 89 68 32 A1  1 
1A13298 	20 40 A0  1 FC 50 A0  1 
1A132A0 	A0 50 A0  1 58 46 A0  1 
: .llit         ( ip -- ip' )  ta1+ dup unaligned-l@ 1- pretty-. la1+  ;
1A132A8 	 0  0 2E 6C 6C 69 74 85 
1A132B0 	98 32 A1  1 20 40 A0  1 
1A132B8 	FC 50 A0  1 40 49 A0  1 
1A132C0 	FC 4C A0  1 54 4B A0  1 
1A132C8 	84 30 A1  1 B4 50 A0  1 
1A132D0 	58 46 A0  1 
: skip-llit     ( ip -- ip' )  ta1+ la1+  ;
1A132D4 	 0  0 73 6B 
1A132D8 	69 70 2D 6C 6C 69 74 89 
1A132E0 	B4 32 A1  1 20 40 A0  1 
1A132E8 	FC 50 A0  1 B4 50 A0  1 
1A132F0 	58 46 A0  1 
: .dlit         ( ip -- ip' )  ta1+ dup d@ (d.) add-position green-letters type ." . " cancel  2 na+  ;
1A132F4 	 0  0 2E 64 
1A132F8 	6C 69 74 85 E4 32 A1  1 
1A13300 	20 40 A0  1 FC 50 A0  1 
1A13308 	40 49 A0  1 20 4C A0  1 
1A13310 	10 7B A0  1 C0 21 A1  1 
1A13318 	C0 F9 A0  1  4 6C A0  1 
1A13320 	20 7C A0  1  2 2E 20  0 
1A13328 	BC F7 A0  1 90 6F A0  1 
1A13330 	48 50 A0  1 58 46 A0  1 
: skip-dlit     ( ip -- ip' )  ta1+ 2 na+  ;
1A13338 	 0  0 73 6B 69 70 2D 64 
1A13340 	6C 69 74 89  0 33 A1  1 
1A13348 	20 40 A0  1 FC 50 A0  1 
1A13350 	90 6F A0  1 48 50 A0  1 
1A13358 	58 46 A0  1 
: skip-branch   ( ip -- ip' )  +branch  ;
1A1335C 	73 6B 69 70 
1A13360 	2D 62 72 61 6E 63 68 8B 
1A13368 	48 33 A1  1 20 40 A0  1 
1A13370 	C8 28 A1  1 58 46 A0  1 
: .compile      ( ip -- ip' )  .." compile " ta1+ .compiled   ;
1A13378 	 0  0  0 2E 63 6F 6D 70 
1A13380 	69 6C 65 88 6C 33 A1  1 
1A13388 	20 40 A0  1 9C 53 A0  1 
1A13390 	 8 63 6F 6D 70 69 6C 65 
1A13398 	20  0  0  0 60 23 A1  1 
1A133A0 	FC 50 A0  1 8C 31 A1  1 
1A133A8 	58 46 A0  1 
: skip-compile  ( ip -- ip' )  ta1+ ta1+  ;
1A133AC 	 0  0  0 73 
1A133B0 	6B 69 70 2D 63 6F 6D 70 
1A133B8 	69 6C 65 8C 88 33 A1  1 
1A133C0 	20 40 A0  1 FC 50 A0  1 
1A133C8 	FC 50 A0  1 58 46 A0  1 
: skip-string   ( ip -- ip' )  ta1+ +str  ;
1A133D0 	73 6B 69 70 2D 73 74 72 
1A133D8 	69 6E 67 8B C0 33 A1  1 
1A133E0 	20 40 A0  1 FC 50 A0  1 
1A133E8 	18 8B A0  1 58 46 A0  1 
: skip-nstring  ( ip -- ip' )  ta1+ +nstr  ;
1A133F0 	 0  0  0 73 6B 69 70 2D 
1A133F8 	6E 73 74 72 69 6E 67 8C 
1A13400 	E0 33 A1  1 20 40 A0  1 
1A13408 	FC 50 A0  1 3C 8B A0  1 
1A13410 	58 46 A0  1 
: .(')          ( ip -- ip' )  ta1+  .." ['] " dup token@ .name  ta1+ ;
1A13414 	 0  0  0 2E 
1A13418 	28 27 29 84  4 34 A1  1 
1A13420 	20 40 A0  1 FC 50 A0  1 
1A13428 	9C 53 A0  1  4 5B 27 5D 
1A13430 	20  0  0  0 60 23 A1  1 
1A13438 	40 49 A0  1  C 54 A0  1 
1A13440 	C8 9A A0  1 FC 50 A0  1 
1A13448 	58 46 A0  1 
headers
: skip-(')      ( ip -- ip' )  ta1+ ta1+  ;
1A1344C 	 0  0  0 73 
1A13450 	6B 69 70 2D 28 27 29 88 
1A13458 	20 34 A1  1 20 40 A0  1 
1A13460 	FC 50 A0  1 FC 50 A0  1 
1A13468 	58 46 A0  1 
headerless
: .is           ( ip -- ip' )  .." to "  ta1+ dup token@ .name  ta1+  ;
1A1346C 	2E 69 73 83 
1A13470 	5C 34 A1  1 20 40 A0  1 
1A13478 	9C 53 A0  1  3 74 6F 20 
1A13480 	 0  0  0  0 60 23 A1  1 
1A13488 	FC 50 A0  1 40 49 A0  1 
1A13490 	 C 54 A0  1 C8 9A A0  1 
1A13498 	FC 50 A0  1 58 46 A0  1 
: .string       ( ip -- ip' )  cword-name              .string-tail +str   ;
1A134A0 	2E 73 74 72 69 6E 67 87 
1A134A8 	74 34 A1  1 20 40 A0  1 
1A134B0 	6C 2F A1  1 30 30 A1  1 
1A134B8 	18 8B A0  1 58 46 A0  1 
: .nstring      ( ip -- ip' )  ta1+  dup ncount " n""" .string-tail +nstr  ;
1A134C0 	 0  0  0 2E 6E 73 74 72 
1A134C8 	69 6E 67 88 AC 34 A1  1 
1A134D0 	20 40 A0  1 FC 50 A0  1 
1A134D8 	40 49 A0  1 F0 53 A0  1 
1A134E0 	9C 53 A0  1  2 6E 22  0 
1A134E8 	30 30 A1  1 3C 8B A0  1 
1A134F0 	58 46 A0  1 

\ Use this version of .branch if the structured conditional code is not used
\ : .branch     ( ip -- ip' )  .word   dup <w@ .   /branch +   ;

: .unnest     ( ip -- ip' )
1A134F4 	2E 75 6E 6E 
1A134F8 	65 73 74 87 D0 34 A1  1 
1A13500 	20 40 A0  1 
   dup extent @ u>=  if
1A13504 	40 49 A0  1 
1A13508 	8C 28 A1  1 5C 4C A0  1 
1A13510 	CC 48 A0  1 DC 41 A0  1 
1A13518 	30  0  0  0 
      ??cr 0 lmargin ! .." ;" drop   0
1A1351C 	 0 A1 A0  1 
1A13520 	70 6F A0  1 80 13 A1  1 
1A13528 	54 4D A0  1 9C 53 A0  1 
1A13530 	 1 3B  0  0 60 23 A1  1 
1A13538 	30 49 A0  1 70 6F A0  1 
   else
1A13540 	C8 41 A0  1 18  0  0  0 
      .." exit " ta1+
1A13548 	9C 53 A0  1  5 65 78 69 
1A13550 	74 20  0  0 60 23 A1  1 
1A13558 	FC 50 A0  1 
   then
;
1A1355C 	58 46 A0  1 
: dummy ;
1A13560 	 0  0 64 75 6D 6D 79 85 
1A13568 	 0 35 A1  1 20 40 A0  1 
1A13570 	58 46 A0  1 

\ classify each word in a definition

\  Common constant for sizing the three classes:
d# 36 constant #decomp-classes
1A13574 	23 64 65 63 
1A13578 	6F 6D 70 2D 63 6C 61 73 
1A13580 	73 65 73 8F 6C 35 A1  1 
1A13588 	68 40 A0  1 24  0  0  0 

#decomp-classes tassociative: execution-class  ( token -- index )
1A13590 	65 78 65 63 75 74 69 6F 
1A13598 	6E 2D 63 6C 61 73 73 8F 
1A135A0 	88 35 A1  1 F4 24 A1  1 
1A135A8 	24  0  0  0 
   (  0 ) [compile]  (lit)           (  1 ) [compile]  ?branch
1A135AC 	58 41 A0  1 
1A135B0 	DC 41 A0  1 
   (  2 ) [compile]  branch          (  3 ) [compile]  (loop)
1A135B4 	C8 41 A0  1 
1A135B8 	F8 41 A0  1 
   (  4 ) [compile]  (+loop)         (  5 ) [compile]  (do)
1A135BC 	1C 42 A0  1 
1A135C0 	88 42 A0  1 
   (  6 ) [compile]  compile         (  7 ) [compile]  (.")
1A135C4 	8C 75 A0  1 
1A135C8 	20 7C A0  1 
   (  8 ) [compile]  (abort")        (  9 ) [compile]  (;code)
1A135CC 	 8 81 A0  1 
1A135D0 	2C A3 A0  1 
   ( 10 ) [compile]  unnest          ( 11 ) [compile]  (")
1A135D4 	58 46 A0  1 
1A135D8 	9C 53 A0  1 
   ( 12 ) [compile]  (?do)           ( 13 ) [compile]  (does>)
1A135DC 	50 42 A0  1 
1A135E0 	50 A3 A0  1 
   ( 14 ) [compile]  exit            ( 15 ) [compile]  (wlit)
1A135E4 	40 46 A0  1 
1A135E8 	88 20 A1  1 
   ( 16 ) [compile]  (')             ( 17 ) [compile]  (of)
1A135EC 	60 53 A0  1 
1A135F0 	48 43 A0  1 
   ( 18 ) [compile]  (endof)         ( 19 ) [compile]  (endcase)
1A135F4 	6C 43 A0  1 
1A135F8 	84 43 A0  1 
   ( 20 ) [compile]  dummy	     ( 21 ) [compile]  (is)
1A135FC 	6C 35 A1  1 
1A13600 	B8 65 A0  1 
   ( 22 ) [compile]  (dlit)          ( 23 ) [compile]  (llit)
1A13604 	80 41 A0  1 
1A13608 	6C 41 A0  1 
   ( 24 ) [compile]  (n")            ( 25 ) [compile]  isdefer
1A1360C 	D4 53 A0  1 
1A13610 	98 40 A0  1 
   ( 26 ) [compile]  isuser          ( 27 ) [compile]  isvalue
1A13614 	D8 40 A0  1 
1A13618 	B8 40 A0  1 
   ( 28 ) [compile]  isconstant      ( 29 ) [compile]  isvariable
1A1361C 	FC 40 A0  1 
1A13620 	1C 41 A0  1 
   ( 30 ) [compile]  ($of)           ( 31 ) [compile]  ($endof)
1A13624 	20 18 A1  1 
1A13628 	98 43 A0  1 
   ( 32 ) [compile]  ($endcase)      ( 33 ) [compile]  dummy
1A1362C 	B0 43 A0  1 
1A13630 	6C 35 A1  1 
   ( 34 ) [compile]  dummy           ( 35 ) [compile]  dummy
1A13634 	6C 35 A1  1 
1A13638 	6C 35 A1  1 

\ Print a word which has been classified by  execution-class
#decomp-classes 1+ case: .execution-class  ( ip index -- ip' )
1A1363C 	 0  0  0 2E 
1A13640 	65 78 65 63 75 74 69 6F 
1A13648 	6E 2D 63 6C 61 73 73 90 
1A13650 	A4 35 A1  1 B8 24 A1  1 
1A13658 	25  0  0  0 
   (  0 )     .inline                (  1 )     .?branch
1A1365C 	20 32 A1  1 
1A13660 	7C 2D A1  1 
   (  2 )     .branch                (  3 )     .loop
1A13664 	18 2D A1  1 
1A13668 	58 2E A1  1 
   (  4 )     .+loop                 (  5 )     .do
1A1366C 	88 2E A1  1 
1A13670 	 0 2E A1  1 
   (  6 )     .compile               (  7 )     .string
1A13674 	88 33 A1  1 
1A13678 	AC 34 A1  1 
   (  8 )     .string                (  9 )     .;code
1A1367C 	AC 34 A1  1 
1A13680 	B0 2C A1  1 
   ( 10 )     .unnest                ( 11 )     .string
1A13684 	 0 35 A1  1 
1A13688 	AC 34 A1  1 
   ( 12 )     .?do                   ( 13 )     .;code
1A1368C 	2C 2E A1  1 
1A13690 	B0 2C A1  1 
   ( 14 )     .unnest                ( 15 )     .wlit
1A13694 	 0 35 A1  1 
1A13698 	68 32 A1  1 
   ( 16 )     .(')                   ( 17 )     .of
1A1369C 	20 34 A1  1 
1A136A0 	B4 2E A1  1 
   ( 18 )     .endof                 ( 19 )     .endcase
1A136A4 	E8 28 A1  1 
1A136A8 	18 29 A1  1 
   ( 20 )     dummy                  ( 21 )     .is
1A136AC 	6C 35 A1  1 
1A136B0 	74 34 A1  1 
   ( 22 )     .dlit                  ( 23 )     .llit
1A136B4 	 0 33 A1  1 
1A136B8 	B4 32 A1  1 
   ( 24 )     .nstring               ( 25 )     .is
1A136BC 	D0 34 A1  1 
1A136C0 	74 34 A1  1 
   ( 26 )     .is                    ( 27 )     .is
1A136C4 	74 34 A1  1 
1A136C8 	74 34 A1  1 
   ( 28 )     .is                    ( 29 )     .is
1A136CC 	74 34 A1  1 
1A136D0 	74 34 A1  1 
   ( 30 )     .$of                   ( 31 )     .$endof
1A136D4 	DC 2E A1  1 
1A136D8 	48 29 A1  1 
   ( 32 )     .$endcase              ( 33 )     dummy
1A136DC 	78 29 A1  1 
1A136E0 	6C 35 A1  1 
   ( 34 )     dummy                  ( 35 )     dummy
1A136E4 	6C 35 A1  1 
1A136E8 	6C 35 A1  1 
   ( default ) .word
1A136EC 	C0 31 A1  1 
;
1A136F0 	58 46 A0  1 

\ Determine the control structure implications of a word
\ which has been classified by  execution-class
#decomp-classes 1+ case: do-scan
1A136F4 	64 6F 2D 73 
1A136F8 	63 61 6E 87 54 36 A1  1 
1A13700 	B8 24 A1  1 25  0  0  0 
   (  0 )     skip-inline            (  1 )     scan-branch
1A13708 	4C 32 A1  1 C4 2B A1  1 
   (  2 )     scan-branch            (  3 )     skip-branch
1A13710 	C4 2B A1  1 6C 33 A1  1 
   (  4 )     skip-branch            (  6 )     skip-branch
1A13718 	6C 33 A1  1 6C 33 A1  1 
   (  6 )     skip-compile           (  7 )     skip-string
1A13720 	C0 33 A1  1 E0 33 A1  1 
   (  8 )     skip-string            (  9 )     scan-;code
1A13728 	E0 33 A1  1 84 2C A1  1 
   ( 10 )     scan-unnest            ( 11 )     skip-string
1A13730 	40 2C A1  1 E0 33 A1  1 
   ( 12 )     skip-branch            ( 13 )     scan-;code
1A13738 	6C 33 A1  1 84 2C A1  1 
   ( 14 )     scan-unnest            ( 15 )     skip-wlit
1A13740 	40 2C A1  1 98 32 A1  1 
   ( 16 )     skip-(')		     ( 17 )     scan-of
1A13748 	5C 34 A1  1 14 2B A1  1 
   ( 18 )     skip-branch            ( 19 )     skip-word
1A13750 	6C 33 A1  1  8 32 A1  1 
   ( 20 )     skip-string            ( 21 )     skip-word
1A13758 	E0 33 A1  1  8 32 A1  1 
   ( 22 )     skip-dlit              ( 23 )     skip-llit
1A13760 	48 33 A1  1 E4 32 A1  1 
   ( 24 )     skip-nstring           ( 25 )     skip-word
1A13768 	 4 34 A1  1  8 32 A1  1 
   ( 26 )     skip-word              ( 27 )     skip-word
1A13770 	 8 32 A1  1  8 32 A1  1 
   ( 28 )     skip-word              ( 29 )     skip-word
1A13778 	 8 32 A1  1  8 32 A1  1 
   ( 30 )     scan-$of               ( 31 )     skip-branch
1A13780 	6C 2B A1  1 6C 33 A1  1 
   ( 32 )     skip-word              ( 33 )     dummy
1A13788 	 8 32 A1  1 6C 35 A1  1 
   ( 34 )     dummy                  ( 35 )     dummy
1A13790 	6C 35 A1  1 6C 35 A1  1 
  ( default ) skip-word
1A13798 	 8 32 A1  1 
;
1A1379C 	58 46 A0  1 

headers
also forth definitions
: install-decomp  ( literal-acf display-acf skip-acf -- )
1A137A0 	 0 69 6E 73 74 61 6C 6C 
1A137A8 	2D 64 65 63 6F 6D 70 8E 
1A137B0 	E4 24 A1  1 20 40 A0  1 
   ['] dummy ['] do-scan          (patch
1A137B8 	60 53 A0  1 6C 35 A1  1 
1A137C0 	60 53 A0  1  0 37 A1  1 
1A137C8 	6C  5 A1  1 
   ['] dummy ['] .execution-class (patch
1A137CC 	60 53 A0  1 
1A137D0 	6C 35 A1  1 60 53 A0  1 
1A137D8 	54 36 A1  1 6C  5 A1  1 
   ['] dummy ['] execution-class >body na1+
1A137E0 	60 53 A0  1 6C 35 A1  1 
1A137E8 	60 53 A0  1 A4 35 A1  1 
1A137F0 	E4 59 A0  1 CC 50 A0  1 
	       dup [ #decomp-classes ] literal ta+ tsearch
1A137F8 	40 49 A0  1 58 41 A0  1 
1A13800 	24  0  0  0 60 50 A0  1 
1A13808 	A4  0 A1  1 
   drop token!
1A1380C 	30 49 A0  1 
1A13810 	20 54 A0  1 
;
1A13814 	58 46 A0  1 
previous definitions
headerless

\ Scan the parameter field of a colon definition and determine the
\ places where control is transferred.
: scan-pf   ( apf -- )
1A13818 	73 63 61 6E 2D 70 66 87 
1A13820 	 0 37 A1  1 20 40 A0  1 
   dup extent !                           ( apf )
1A13828 	40 49 A0  1 8C 28 A1  1 
1A13830 	54 4D A0  1 
   breaks end-breaks !                    ( apf )
1A13834 	EC 25 A1  1 
1A13838 	 C 26 A1  1 54 4D A0  1 
   begin                                  ( adr )
      dup token@ execution-class do-scan  ( adr' )
1A13840 	40 49 A0  1  C 54 A0  1 
1A13848 	A4 35 A1  1  0 37 A1  1 
      dup 0=                              ( adr' flag )
1A13850 	40 49 A0  1 24 47 A0  1 
   until                                  ( adr )
1A13858 	DC 41 A0  1 E4 FF FF FF 
   drop
1A13860 	30 49 A0  1 
;
1A13864 	58 46 A0  1 

forth definitions
headers
: .token  ( ip -- ip' )  dup token@ execution-class .execution-class  ;
1A13868 	 0 2E 74 6F 6B 65 6E 86 
1A13870 	B4 37 A1  1 20 40 A0  1 
1A13878 	40 49 A0  1  C 54 A0  1 
1A13880 	A4 35 A1  1 54 36 A1  1 
1A13888 	58 46 A0  1 
\ Decompile the parameter field of colon definition
: .pf   ( apf -- )
1A1388C 	2E 70 66 83 
1A13890 	74 38 A1  1 20 40 A0  1 
   init-positions                                     ( apf )
1A13898 	 8 21 A1  1 
   dup scan-pf next-break 3 lmargin ! indent          ( apf )
1A1389C 	40 49 A0  1 
1A138A0 	24 38 A1  1 6C 26 A1  1 
1A138A8 	A0 6F A0  1 80 13 A1  1 
1A138B0 	54 4D A0  1 C8 22 A1  1 
   begin                                              ( adr )
      dup is decompiler-ip                            ( adr )
1A138B8 	40 49 A0  1 B8 40 A0  1 
1A138C0 	A4 21 A1  1 
      ?cr                                             ( adr )
1A138C4 	E8 13 A1  1 
      break-addr @ over =  if                         ( adr )
1A138C8 	3C 26 A1  1 5C 4C A0  1 
1A138D0 	54 49 A0  1 24 48 A0  1 
1A138D8 	DC 41 A0  1 34  0  0  0 
	 begin                                        ( adr )
	    break-type @ execute                      ( adr )
1A138E0 	24 26 A1  1 5C 4C A0  1 
1A138E8 	98 41 A0  1 
	    next-break  break-addr @ over <>          ( adr done? )
1A138EC 	6C 26 A1  1 
1A138F0 	3C 26 A1  1 5C 4C A0  1 
1A138F8 	54 49 A0  1 44 48 A0  1 
	 until                                        ( adr )
1A13900 	DC 41 A0  1 DC FF FF FF 
      else                                            ( adr )
1A13908 	C8 41 A0  1  8  0  0  0 
         .token                                       ( adr' )
1A13910 	74 38 A1  1 
      then                                            ( adr' )
      dup 0=  exit?  if  nullstring throw  then       ( adr' )
1A13914 	40 49 A0  1 
1A13918 	24 47 A0  1 34  D A1  1 
1A13920 	DC 41 A0  1  C  0  0  0 
1A13928 	9C 8A A0  1 74 7F A0  1 
   until  drop                                        (  )
1A13930 	DC 41 A0  1 84 FF FF FF 
1A13938 	30 49 A0  1 
;
1A1393C 	58 46 A0  1 
headerless
hidden definitions

: .immediate  ( acf -- )   immediate? if   .." immediate"   then   ;
1A13940 	 0 2E 69 6D 6D 65 64 69 
1A13948 	61 74 65 8A 24 38 A1  1 
1A13950 	20 40 A0  1 FC B8 A0  1 
1A13958 	DC 41 A0  1 18  0  0  0 
1A13960 	9C 53 A0  1  9 69 6D 6D 
1A13968 	65 64 69 61 74 65  0  0 
1A13970 	60 23 A1  1 58 46 A0  1 

: .definer    ( acf definer-acf -- acf )
1A13978 	 0  0  0 2E 64 65 66 69 
1A13980 	6E 65 72 88 50 39 A1  1 
1A13988 	20 40 A0  1 
   magenta-letters .name  dup blue-letters  .name  cancel
1A1398C 	14 FA A0  1 
1A13990 	C8 9A A0  1 40 49 A0  1 
1A13998 	F8 F9 A0  1 C8 9A A0  1 
1A139A0 	BC F7 A0  1 
;
1A139A4 	58 46 A0  1 

: dump-body  ( pfa -- )
1A139A8 	 0  0 64 75 6D 70 2D 62 
1A139B0 	6F 64 79 89 88 39 A1  1 
1A139B8 	20 40 A0  1 
   push-hex
1A139BC 	5C F4 A0  1 
   dup @ pretty-. 2 spaces  8 emit.ln
1A139C0 	40 49 A0  1 5C 4C A0  1 
1A139C8 	84 30 A1  1 90 6F A0  1 
1A139D0 	E8 71 A0  1 F0 6F A0  1 
1A139D8 	D8 1A A1  1 
   pop-base
1A139DC 	9C F4 A0  1 
;
1A139E0 	58 46 A0  1 
\ Display category of word
: .:           ( acf definer -- )  .definer cr ( space space ) >body  .pf   ;
1A139E4 	 0 2E 3A 82 
1A139E8 	B8 39 A1  1 20 40 A0  1 
1A139F0 	88 39 A1  1 80 6D A0  1 
1A139F8 	E4 59 A0  1 94 38 A1  1 
1A13A00 	58 46 A0  1 
: debug-see    ( apf -- )
1A13A04 	 0  0 64 65 
1A13A08 	62 75 67 2D 73 65 65 89 
1A13A10 	EC 39 A1  1 20 40 A0  1 
   page-mode? >r  no-page
1A13A18 	 8  8 A1  1 BC 45 A0  1 
1A13A20 	1C  8 A1  1 
   find-cfa ['] :  .:
1A13A24 	24 20 A1  1 
1A13A28 	60 53 A0  1 90 A6 A0  1 
1A13A30 	EC 39 A1  1 
   r> is page-mode?
1A13A34 	D0 45 A0  1 
1A13A38 	B8 40 A0  1  8  8 A1  1 
;
1A13A40 	58 46 A0  1 
: .constant    ( acf definer -- )  over >data @ pretty-.  .definer drop  ;
1A13A44 	 0  0 2E 63 
1A13A48 	6F 6E 73 74 61 6E 74 89 
1A13A50 	14 3A A1  1 20 40 A0  1 
1A13A58 	54 49 A0  1 6C C7 A0  1 
1A13A60 	5C 4C A0  1 84 30 A1  1 
1A13A68 	88 39 A1  1 30 49 A0  1 
1A13A70 	58 46 A0  1 
: .2constant   ( acf definer -- )  over >data dup @ pretty-.  na1+ @ pretty-. .definer drop  ;
1A13A74 	 0 2E 32 63 
1A13A78 	6F 6E 73 74 61 6E 74 8A 
1A13A80 	54 3A A1  1 20 40 A0  1 
1A13A88 	54 49 A0  1 6C C7 A0  1 
1A13A90 	40 49 A0  1 5C 4C A0  1 
1A13A98 	84 30 A1  1 CC 50 A0  1 
1A13AA0 	5C 4C A0  1 84 30 A1  1 
1A13AA8 	88 39 A1  1 30 49 A0  1 
1A13AB0 	58 46 A0  1 
: .vocabulary  ( acf definer -- )  .definer drop  ;
1A13AB4 	2E 76 6F 63 
1A13AB8 	61 62 75 6C 61 72 79 8B 
1A13AC0 	84 3A A1  1 20 40 A0  1 
1A13AC8 	88 39 A1  1 30 49 A0  1 
1A13AD0 	58 46 A0  1 
: .code        ( acf definer -- )  .definer >code disassemble  ;
1A13AD4 	 0  0 2E 63 
1A13AD8 	6F 64 65 85 C4 3A A1  1 
1A13AE0 	20 40 A0  1 88 39 A1  1 
1A13AE8 	 0 5A A0  1 C4 25 A1  1 
1A13AF0 	58 46 A0  1 
: .variable    ( acf definer -- )
1A13AF4 	 0  0 2E 76 
1A13AF8 	61 72 69 61 62 6C 65 89 
1A13B00 	E0 3A A1  1 20 40 A0  1 
   over >data n.   .definer   ." value = " >data @ pretty-.
1A13B08 	54 49 A0  1 6C C7 A0  1 
1A13B10 	D0 7A A0  1 88 39 A1  1 
1A13B18 	20 7C A0  1  8 76 61 6C 
1A13B20 	75 65 20 3D 20  0  0  0 
1A13B28 	6C C7 A0  1 5C 4C A0  1 
1A13B30 	84 30 A1  1 
;
1A13B34 	58 46 A0  1 
: .create     ( acf definer -- )
1A13B38 	2E 63 72 65 61 74 65 87 
1A13B40 	 4 3B A1  1 20 40 A0  1 
   over >body n.   .definer   ." value = " >body dump-body
1A13B48 	54 49 A0  1 E4 59 A0  1 
1A13B50 	D0 7A A0  1 88 39 A1  1 
1A13B58 	20 7C A0  1  8 76 61 6C 
1A13B60 	75 65 20 3D 20  0  0  0 
1A13B68 	E4 59 A0  1 B8 39 A1  1 
;
1A13B70 	58 46 A0  1 
: .user        ( acf definer -- )
1A13B74 	 0  0 2E 75 
1A13B78 	73 65 72 85 44 3B A1  1 
1A13B80 	20 40 A0  1 
   over >body @ n.   .definer   ."  value = "   >data @ pretty-.
1A13B84 	54 49 A0  1 
1A13B88 	E4 59 A0  1 5C 4C A0  1 
1A13B90 	D0 7A A0  1 88 39 A1  1 
1A13B98 	20 7C A0  1  9 20 76 61 
1A13BA0 	6C 75 65 20 3D 20  0  0 
1A13BA8 	6C C7 A0  1 5C 4C A0  1 
1A13BB0 	84 30 A1  1 
;
1A13BB4 	58 46 A0  1 
: .defer       ( acf definer -- )
1A13BB8 	 0 2E 64 65 66 65 72 86 
1A13BC0 	80 3B A1  1 20 40 A0  1 
   .definer  ." is " cr  >data token@ (see)
1A13BC8 	88 39 A1  1 20 7C A0  1 
1A13BD0 	 3 69 73 20  0  0  0  0 
1A13BD8 	80 6D A0  1 6C C7 A0  1 
1A13BE0 	 C 54 A0  1 98 20 A1  1 
;
1A13BE8 	58 46 A0  1 
: .alias       ( acf definer -- )
1A13BEC 	 0 2E 61 6C 
1A13BF0 	69 61 73 86 C4 3B A1  1 
1A13BF8 	20 40 A0  1 
   .definer >body token@ .name
1A13BFC 	88 39 A1  1 
1A13C00 	E4 59 A0  1  C 54 A0  1 
1A13C08 	C8 9A A0  1 
;
1A13C0C 	58 46 A0  1 
: .value      ( acf definer -- )
1A13C10 	 0 2E 76 61 6C 75 65 86 
1A13C18 	F8 3B A1  1 20 40 A0  1 
   swap >data @ pretty-. .definer
1A13C20 	68 49 A0  1 6C C7 A0  1 
1A13C28 	5C 4C A0  1 84 30 A1  1 
1A13C30 	88 39 A1  1 
;
1A13C34 	58 46 A0  1 


\ Decompile a word whose type is not one of those listed in
\ definition-class.  These include does> and ;code words which
\ are not explicitly recognized in definition-class.
: .other   ( acf definer -- )
1A13C38 	 0 2E 6F 74 68 65 72 86 
1A13C40 	1C 3C A1  1 20 40 A0  1 
   .definer   >body ."    (Body: " dump-body ."  ) " cr
1A13C48 	88 39 A1  1 E4 59 A0  1 
1A13C50 	20 7C A0  1  A 20 20 20 
1A13C58 	28 42 6F 64 79 3A 20  0 
1A13C60 	B8 39 A1  1 20 7C A0  1 
1A13C68 	 3 20 29 20  0  0  0  0 
1A13C70 	80 6D A0  1 
;
1A13C74 	58 46 A0  1 

\ Classify a word based on its acf
alias  isalias  noop
1A13C78 	69 73 61 6C 69 61 73 A7 
1A13C80 	44 3C A1  1 64 4F A0  1 
create iscreate
1A13C88 	 0  0  0 69 73 63 72 65 
1A13C90 	61 74 65 88 84 3C A1  1 
1A13C98 	30 40 A0  1 
0 0 2constant is2cons
1A13C9C 	69 73 32 63 
1A13CA0 	6F 6E 73 87 98 3C A1  1 
1A13CA8 	70 40 A0  1  0  0  0  0 
1A13CB0 	 0  0  0  0 

: wt,  \ name  ( -- )  \ Compile name's word type
1A13CB4 	77 74 2C 83 
1A13CB8 	A8 3C A1  1 20 40 A0  1 
   ' word-type token,
1A13CC0 	F8 95 A0  1 B0 59 A0  1 
1A13CC8 	2C 55 A0  1 
;
1A13CCC 	58 46 A0  1 

d# 10 tassociative: word-types
1A13CD0 	 0 77 6F 72 64 2D 74 79 
1A13CD8 	70 65 73 8A BC 3C A1  1 
1A13CE0 	F4 24 A1  1  A  0  0  0 
   ( 0 )   wt, here        ( 1 )   wt, bl
1A13CE8 	20 40 A0  1 68 40 A0  1 
   ( 2 )   wt, isvar       ( 3 )   wt, base
1A13CF0 	48 40 A0  1 48 40 A0  1 
   ( 4 )   wt, emit        ( 5 )   wt, iscreate
1A13CF8 	5C 40 A0  1 30 40 A0  1 
   ( 6 )   wt, forth       ( 7 )   wt, isalias
1A13D00 	E0 B6 A0  1 68 4F A0  1 
   ( 8 )   wt, isval       ( 9 )   wt, is2cons
1A13D08 	50 40 A0  1 70 40 A0  1 

: cf,  \ name  ( -- )  \ Compile name's code field
1A13D10 	63 66 2C 83 E0 3C A1  1 
1A13D18 	20 40 A0  1 
   ' token,
1A13D1C 	F8 95 A0  1 
1A13D20 	2C 55 A0  1 
;
1A13D24 	58 46 A0  1 
d# 12 constant #definition-classes
1A13D28 	23 64 65 66 69 6E 69 74 
1A13D30 	69 6F 6E 2D 63 6C 61 73 
1A13D38 	73 65 73 93 18 3D A1  1 
1A13D40 	68 40 A0  1  C  0  0  0 
#definition-classes tassociative: definition-class
1A13D48 	 0  0  0 64 65 66 69 6E 
1A13D50 	69 74 69 6F 6E 2D 63 6C 
1A13D58 	61 73 73 90 40 3D A1  1 
1A13D60 	F4 24 A1  1  C  0  0  0 
   ( 0 )   cf,  :          ( 1 )   cf,  constant
1A13D68 	90 A6 A0  1 30 A7 A0  1 
   ( 2 )   cf,  variable   ( 3 )   cf,  user
1A13D70 	94 F2 A0  1  4 9A A0  1 
   ( 4 )   cf,  defer      ( 5 )   cf,  create
1A13D78 	44 A8 A0  1 A8 A2 A0  1 
   ( 6 )   cf,  vocabulary ( 7 )   cf,  alias
1A13D80 	28 B7 A0  1  8 E0 A0  1 
   ( 8 )   cf,  value      ( 9 )   cf,  2constant
1A13D88 	50 A7 A0  1 78 A8 A0  1 
   ( 10)   cf,  code       ( 11 )  cf,  dummy
1A13D90 	8C A3 A0  1 6C 35 A1  1 

#definition-classes 1+ case: .definition-class
1A13D98 	 0  0 2E 64 65 66 69 6E 
1A13DA0 	69 74 69 6F 6E 2D 63 6C 
1A13DA8 	61 73 73 91 60 3D A1  1 
1A13DB0 	B8 24 A1  1  D  0  0  0 
   ( 0 )   .:              ( 1 )   .constant
1A13DB8 	EC 39 A1  1 54 3A A1  1 
   ( 2 )   .variable       ( 3 )   .user
1A13DC0 	 4 3B A1  1 80 3B A1  1 
   ( 4 )   .defer          ( 5 )   .create
1A13DC8 	C4 3B A1  1 44 3B A1  1 
   ( 6 )   .vocabulary     ( 7 )   .alias
1A13DD0 	C4 3A A1  1 F8 3B A1  1 
   ( 8 )   .value          ( 9 )   .2constant
1A13DD8 	1C 3C A1  1 84 3A A1  1 
   ( 10)   .code           ( 11)   dummy
1A13DE0 	E0 3A A1  1 6C 35 A1  1 
   ( 12)   .other
1A13DE8 	44 3C A1  1 
;
1A13DEC 	58 46 A0  1 

headers
also forth definitions
: install-decomp-definer  ( definer-acf display-acf -- )
1A13DF0 	 0 69 6E 73 74 61 6C 6C 
1A13DF8 	2D 64 65 63 6F 6D 70 2D 
1A13E00 	64 65 66 69 6E 65 72 96 
1A13E08 	94 38 A1  1 20 40 A0  1 
   ['] dummy ['] .definition-class (patch
1A13E10 	60 53 A0  1 6C 35 A1  1 
1A13E18 	60 53 A0  1 B0 3D A1  1 
1A13E20 	6C  5 A1  1 
   ['] dummy ['] definition-class >body na1+
1A13E24 	60 53 A0  1 
1A13E28 	6C 35 A1  1 60 53 A0  1 
1A13E30 	60 3D A1  1 E4 59 A0  1 
1A13E38 	CC 50 A0  1 
	       dup [ #definition-classes ] literal ta+ tsearch
1A13E3C 	40 49 A0  1 
1A13E40 	58 41 A0  1  C  0  0  0 
1A13E48 	60 50 A0  1 A4  0 A1  1 
   drop token!
1A13E50 	30 49 A0  1 20 54 A0  1 
;
1A13E58 	58 46 A0  1 
previous definitions
headerless


: does/;code-xt?  ( xt -- flag )
1A13E5C 	 0 64 6F 65 
1A13E60 	73 2F 3B 63 6F 64 65 2D 
1A13E68 	78 74 3F 8E B0 3D A1  1 
1A13E70 	20 40 A0  1 
   dup  ['] (does>) =  swap  ['] (;code) =  or
1A13E74 	40 49 A0  1 
1A13E78 	60 53 A0  1 50 A3 A0  1 
1A13E80 	24 48 A0  1 68 49 A0  1 
1A13E88 	60 53 A0  1 2C A3 A0  1 
1A13E90 	24 48 A0  1 70 44 A0  1 
;
1A13E98 	58 46 A0  1 
: does/;code-action?  ( action-acf -- flag )
1A13E9C 	 0 64 6F 65 
1A13EA0 	73 2F 3B 63 6F 64 65 2D 
1A13EA8 	61 63 74 69 6F 6E 3F 92 
1A13EB0 	70 3E A1  1 20 40 A0  1 
   dup -1 ta+ token@ does/;code-xt?  if  drop true exit  then
1A13EB8 	40 49 A0  1 58 41 A0  1 
1A13EC0 	FF FF FF FF 60 50 A0  1 
1A13EC8 	 C 54 A0  1 70 3E A1  1 
1A13ED0 	DC 41 A0  1 10  0  0  0 
1A13ED8 	30 49 A0  1  4 70 A0  1 
1A13EE0 	40 46 A0  1 
   -2 ta+ token@ does/;code-xt?
1A13EE4 	58 41 A0  1 
1A13EE8 	FE FF FF FF 60 50 A0  1 
1A13EF0 	 C 54 A0  1 70 3E A1  1 
;
1A13EF8 	58 46 A0  1 
: no-objects  ( action-acf -- 'lose )  drop  ['] lose  ;
1A13EFC 	 0 6E 6F 2D 
1A13F00 	6F 62 6A 65 63 74 73 8A 
1A13F08 	B4 3E A1  1 20 40 A0  1 
1A13F10 	30 49 A0  1 60 53 A0  1 
1A13F18 	90 9B A0  1 58 46 A0  1 
headers
defer object-definer  ' no-objects is object-definer
1A13F20 	 0 6F 62 6A 65 63 74 2D 
1A13F28 	64 65 66 69 6E 65 72 8E 
1A13F30 	 C 3F A1  1 5C 40 A0  1 
1A13F38 	94  3  0  0 
: definer  ( acf-of-child -- acf-of-defining-word )
1A13F3C 	64 65 66 69 
1A13F40 	6E 65 72 87 34 3F A1  1 
1A13F48 	20 40 A0  1 
   dup code?  if  drop ['] code   exit then            ( acf )
1A13F4C 	40 49 A0  1 
1A13F50 	18 5A A0  1 DC 41 A0  1 
1A13F58 	14  0  0  0 30 49 A0  1 
1A13F60 	60 53 A0  1 8C A3 A0  1 
1A13F68 	40 46 A0  1 
   dup word-type word-types                            ( acf index )
1A13F6C 	40 49 A0  1 
1A13F70 	B0 59 A0  1 E0 3C A1  1 
   dup ['] word-types #entries  =  if                  ( acf index )
1A13F78 	40 49 A0  1 60 53 A0  1 
1A13F80 	E0 3C A1  1 74 25 A1  1 
1A13F88 	24 48 A0  1 DC 41 A0  1 
1A13F90 	34  0  0  0 
      drop word-type                                   ( action-acf )
1A13F94 	30 49 A0  1 
1A13F98 	B0 59 A0  1 
      dup does/;code-action?  if                       ( action-acf )
1A13F9C 	40 49 A0  1 
1A13FA0 	B4 3E A1  1 DC 41 A0  1 
1A13FA8 	10  0  0  0 
         find-cfa                                      ( definer )
1A13FAC 	24 20 A1  1 
      else                                             ( action-acf )
1A13FB0 	C8 41 A0  1  8  0  0  0 
         object-definer                                ( definer )
1A13FB8 	34 3F A1  1 
      then                                             ( definer )
   else                                                ( acf index )
1A13FBC 	C8 41 A0  1 
1A13FC0 	1C  0  0  0 
      nip  ['] definition-class >body maptoken token@  ( definer )
1A13FC4 	FC 46 A0  1 
1A13FC8 	60 53 A0  1 60 3D A1  1 
1A13FD0 	E4 59 A0  1 58 24 A1  1 
1A13FD8 	 C 54 A0  1 
   then
;
1A13FDC 	58 46 A0  1 
headerless

\ top level of the decompiler SEE
: ((see   ( acf -- )
1A13FE0 	 0  0 28 28 73 65 65 85 
1A13FE8 	48 3F A1  1 20 40 A0  1 
   d# 48 rmargin !
1A13FF0 	58 41 A0  1 30  0  0  0 
1A13FF8 	94 13 A1  1 54 4D A0  1 
   dup dup definer dup   definition-class .definition-class
1A14000 	40 49 A0  1 40 49 A0  1 
1A14008 	48 3F A1  1 40 49 A0  1 
1A14010 	60 3D A1  1 B0 3D A1  1 
   .immediate
1A14018 	50 39 A1  1 
   ??cr
1A1401C 	 0 A1 A0  1 
;
1A14020 	58 46 A0  1 
headers
' ((see  is (see)

forth definitions

: see  \ name  ( -- )
1A14024 	73 65 65 83 
1A14028 	 C 3E A1  1 20 40 A0  1 
   '  ['] (see) catch  if  drop  then
1A14030 	F8 95 A0  1 60 53 A0  1 
1A14038 	98 20 A1  1 14 7F A0  1 
1A14040 	DC 41 A0  1  8  0  0  0 
1A14048 	30 49 A0  1 
;
1A1404C 	58 46 A0  1 
only forth also definitions
end-module

OpenFirmware/forth/lib/decomp.fth_AL	8380 1A14050 
\ Command line editing.  See "install-line-editing" for functions
\ implemented and key bindings

d# 80 value display-width
1A14050 	 0  0 64 69 73 70 6C 61 
1A14058 	79 2D 77 69 64 74 68 8D 
1A14060 	2C 40 A1  1 50 40 A0  1 
1A14068 	98  3  0  0 

only forth also hidden also
hidden definitions

decimal

headers
true value display?     \ Turns display update on or off
1A1406C 	 0  0  0 64 
1A14070 	69 73 70 6C 61 79 3F 88 
1A14078 	EC 3F A1  1 50 40 A0  1 
1A14080 	9C  3  0  0 
false value accepting?	\ True when "accept" is calling the editor
1A14084 	 0 61 63 63 
1A14088 	65 70 74 69 6E 67 3F 8A 
1A14090 	7C 40 A1  1 50 40 A0  1 
1A14098 	A0  3  0  0 
headerless

\ Values used by redisplay code

: beep  ( -- )  display? 0=  if  exit  then   control G (emit  ;
1A1409C 	 0  0  0 62 
1A140A0 	65 65 70 84 94 40 A1  1 
1A140A8 	20 40 A0  1 7C 40 A1  1 
1A140B0 	24 47 A0  1 DC 41 A0  1 
1A140B8 	 8  0  0  0 40 46 A0  1 
1A140C0 	58 41 A0  1  7  0  0  0 
1A140C8 	18 6C A0  1 58 46 A0  1 

\ Values describing the current edit line

0 value line-start-adr  \ address of start of input buffer
1A140D0 	 0 6C 69 6E 65 2D 73 74 
1A140D8 	61 72 74 2D 61 64 72 8E 
1A140E0 	A8 40 A1  1 50 40 A0  1 
1A140E8 	A4  3  0  0 
0 value linelen         \ current size of input line
1A140EC 	6C 69 6E 65 
1A140F0 	6C 65 6E 87 E4 40 A1  1 
1A140F8 	50 40 A0  1 A8  3  0  0 
0 value #before         \ position of cursor within line
1A14100 	23 62 65 66 6F 72 65 87 
1A14108 	F8 40 A1  1 50 40 A0  1 
1A14110 	AC  3  0  0 

0 value edit-line#
1A14114 	 0 65 64 69 
1A14118 	74 2D 6C 69 6E 65 23 8A 
1A14120 	 C 41 A1  1 50 40 A0  1 
1A14128 	B0  3  0  0 

\ Positional information derived from the basic information

: #after        ( -- n )        linelen #before -  ;
1A1412C 	 0 23 61 66 
1A14130 	74 65 72 86 24 41 A1  1 
1A14138 	20 40 A0  1 F8 40 A1  1 
1A14140 	 C 41 A1  1 18 45 A0  1 
1A14148 	58 46 A0  1 
: cursor-adr    ( -- adr )      line-start-adr  #before  +  ;
1A1414C 	 0 63 75 72 
1A14150 	73 6F 72 2D 61 64 72 8A 
1A14158 	38 41 A1  1 20 40 A0  1 
1A14160 	E4 40 A1  1  C 41 A1  1 
1A14168 	 4 45 A0  1 58 46 A0  1 
headers
\ "after" needs a header because it's used by nvalias.fth
: after         ( -- adr len )  cursor-adr #after  ;
1A14170 	 0  0 61 66 74 65 72 85 
1A14178 	5C 41 A1  1 20 40 A0  1 
1A14180 	5C 41 A1  1 38 41 A1  1 
1A14188 	58 46 A0  1 
headerless
: line-end-adr  ( -- adr )      after +  ;
1A1418C 	 0  0  0 6C 
1A14190 	69 6E 65 2D 65 6E 64 2D 
1A14198 	61 64 72 8C 7C 41 A1  1 
1A141A0 	20 40 A0  1 7C 41 A1  1 
1A141A8 	 4 45 A0  1 58 46 A0  1 

\ Size and position of displayable "window" into the text line
d# 79 value window-width	\ Width of window in characters
1A141B0 	 0  0  0 77 69 6E 64 6F 
1A141B8 	77 2D 77 69 64 74 68 8C 
1A141C0 	A0 41 A1  1 50 40 A0  1 
1A141C8 	B4  3  0  0 
0 value window-x		\ Offset from start of line buffer
1A141CC 	 0  0  0 77 
1A141D0 	69 6E 64 6F 77 2D 78 88 
1A141D8 	C4 41 A1  1 50 40 A0  1 
1A141E0 	B8  3  0  0 

-1 value xdamage	\ The first character that doesn't match the display.
1A141E4 	78 64 61 6D 
1A141E8 	61 67 65 87 DC 41 A1  1 
1A141F0 	50 40 A0  1 BC  3  0  0 
			\ Offset in characters from start of line buffer.

-1 value ydamage	\ The first line that doesn't match the display.
1A141F8 	79 64 61 6D 61 67 65 87 
1A14200 	F0 41 A1  1 50 40 A0  1 
1A14208 	C0  3  0  0 
			\ Offset in lines from beginning of buffer.

defer new-line-end  ( new-lineend -- old-lineend )
1A1420C 	 0  0  0 6E 
1A14210 	65 77 2D 6C 69 6E 65 2D 
1A14218 	65 6E 64 8C  4 42 A1  1 
1A14220 	5C 40 A0  1 C4  3  0  0 

0 value dirty-x			\ Offset from start of window
1A14228 	64 69 72 74 79 2D 78 87 
1A14230 	20 42 A1  1 50 40 A0  1 
1A14238 	C8  3  0  0 
: (new-line-end)  ( new-lineend -- old-lineend )
1A1423C 	 0 28 6E 65 
1A14240 	77 2D 6C 69 6E 65 2D 65 
1A14248 	6E 64 29 8E 34 42 A1  1 
1A14250 	20 40 A0  1 
   dirty-x  swap is dirty-x   ( new-lineend old-lineend )
1A14254 	34 42 A1  1 
1A14258 	68 49 A0  1 B8 40 A0  1 
1A14260 	34 42 A1  1 
;
1A14264 	58 46 A0  1 
' (new-line-end) is new-line-end

: #to-clear  ( -- #spaces )
1A14268 	 0  0 23 74 6F 2D 63 6C 
1A14270 	65 61 72 89 50 42 A1  1 
1A14278 	20 40 A0  1 
   #out @  new-line-end  #out @  -  0 max
1A1427C 	5C 6D A0  1 
1A14280 	5C 4C A0  1 20 42 A1  1 
1A14288 	5C 6D A0  1 5C 4C A0  1 
1A14290 	18 45 A0  1 70 6F A0  1 
1A14298 	9C 4A A0  1 
;
1A1429C 	58 46 A0  1 

: new-window-width  ( -- )
1A142A0 	 0  0  0 6E 65 77 2D 77 
1A142A8 	69 6E 64 6F 77 2D 77 69 
1A142B0 	64 74 68 90 78 42 A1  1 
1A142B8 	20 40 A0  1 
   \ The 1- leaves room for the cursor
   display-width 1-  #out @ -  is window-width
1A142BC 	64 40 A1  1 
1A142C0 	54 4B A0  1 5C 6D A0  1 
1A142C8 	5C 4C A0  1 18 45 A0  1 
1A142D0 	B8 40 A0  1 C4 41 A1  1 
   0 #out !  0 #line !			\ Re-origin character counter
1A142D8 	70 6F A0  1 5C 6D A0  1 
1A142E0 	54 4D A0  1 70 6F A0  1 
1A142E8 	70 6D A0  1 54 4D A0  1 
;
1A142F0 	58 46 A0  1 

false value redisplay-line#?	\ Flag
1A142F4 	 0  0  0 72 
1A142F8 	65 64 69 73 70 6C 61 79 
1A14300 	2D 6C 69 6E 65 23 3F 90 
1A14308 	B8 42 A1  1 50 40 A0  1 
1A14310 	CC  3  0  0 

\ Displays a line number.
defer .line#
1A14314 	 0 2E 6C 69 
1A14318 	6E 65 23 86  C 43 A1  1 
1A14320 	5C 40 A0  1 D0  3  0  0 
: (.line#)  ( -- )
1A14328 	 0  0  0 28 2E 6C 69 6E 
1A14330 	65 23 29 88 20 43 A1  1 
1A14338 	20 40 A0  1 
   accepting?  redisplay-line#? 0=  or  if  exit  then
1A1433C 	94 40 A1  1 
1A14340 	 C 43 A1  1 24 47 A0  1 
1A14348 	70 44 A0  1 DC 41 A0  1 
1A14350 	 8  0  0  0 40 46 A0  1 
   (cr  0 #out !		\ Left edge of display
1A14358 	9C 72 A0  1 70 6F A0  1 
1A14360 	5C 6D A0  1 54 4D A0  1 
   push-decimal  edit-line#  4 u.r  ." : "  pop-base
1A14368 	48 F4 A0  1 24 41 A1  1 
1A14370 	B0 6F A0  1 E4 77 A0  1 
1A14378 	20 7C A0  1  2 3A 20  0 
1A14380 	9C F4 A0  1 
   false is redisplay-line#?
1A14384 	18 70 A0  1 
1A14388 	B8 40 A0  1  C 43 A1  1 
   new-window-width
1A14390 	B8 42 A1  1 
;
1A14394 	58 46 A0  1 
' (.line#) is .line#

: wtype  ( cursor len -- )  swap window-x +  line-start-adr +  swap type  ;
1A14398 	 0  0 77 74 79 70 65 85 
1A143A0 	38 43 A1  1 20 40 A0  1 
1A143A8 	68 49 A0  1 DC 41 A1  1 
1A143B0 	 4 45 A0  1 E4 40 A1  1 
1A143B8 	 4 45 A0  1 68 49 A0  1 
1A143C0 	 4 6C A0  1 58 46 A0  1 
: hmove-cursor  ( column# -- )
1A143C8 	 0  0  0 68 6D 6F 76 65 
1A143D0 	2D 63 75 72 73 6F 72 8C 
1A143D8 	A4 43 A1  1 20 40 A0  1 
   #out @ -  ?dup  if                               ( distance-right )
1A143E0 	5C 6D A0  1 5C 4C A0  1 
1A143E8 	18 45 A0  1 B4 70 A0  1 
1A143F0 	DC 41 A0  1 94  0  0  0 
      dup 0>  if                                    ( distance-right )
1A143F8 	40 49 A0  1 A4 47 A0  1 
1A14400 	DC 41 A0  1 38  0  0  0 
         \ Move forward n positions on the display.
         [ifdef] rights  dup 4 >  if  rights  exit  then  [then]
1A14408 	40 49 A0  1 B0 6F A0  1 
1A14410 	 4 48 A0  1 DC 41 A0  1 
1A14418 	 C  0  0  0 44 F7 A0  1 
1A14420 	40 46 A0  1 
   
         #out @  swap  wtype                        ( )
1A14424 	5C 6D A0  1 
1A14428 	5C 4C A0  1 68 49 A0  1 
1A14430 	A4 43 A1  1 
      else                                          ( distance-right )
1A14434 	C8 41 A0  1 
1A14438 	50  0  0  0 
         negate                                     ( distance-left )
1A1443C 	48 45 A0  1 

         \ Move backward n positions on the display.
         \ An optimization for the case where we have cursor control
         [ifdef] lefts   dup 4 >  if  lefts  exit  then   [then]
1A14440 	40 49 A0  1 B0 6F A0  1 
1A14448 	 4 48 A0  1 DC 41 A0  1 
1A14450 	 C  0  0  0 18 F7 A0  1 
1A14458 	40 46 A0  1 

         0  ?do  bs (emit  -1 #out +!  loop
1A1445C 	70 6F A0  1 
1A14460 	50 42 A0  1 24  0  0  0 
1A14468 	34 6F A0  1 18 6C A0  1 
1A14470 	58 41 A0  1 FF FF FF FF 
1A14478 	5C 6D A0  1  C 4C A0  1 
1A14480 	F8 41 A0  1 E4 FF FF FF 
      then
   then
;
1A14488 	58 46 A0  1 

\ Converts buffer-line-oriented coordinates to window-relative coordinates
: clip-x  ( line-x -- window-x )  window-x -  0 max  window-width min  ;
1A1448C 	 0 63 6C 69 
1A14490 	70 2D 78 86 DC 43 A1  1 
1A14498 	20 40 A0  1 DC 41 A1  1 
1A144A0 	18 45 A0  1 70 6F A0  1 
1A144A8 	9C 4A A0  1 C4 41 A1  1 
1A144B0 	74 4A A0  1 58 46 A0  1 

\ Computes a new position for window-x
\ Any change in window-x effectively forces a complete redisplay
: set-window-x  ( new-window-x -- )
1A144B8 	 0  0  0 73 65 74 2D 77 
1A144C0 	69 6E 64 6F 77 2D 78 8C 
1A144C8 	98 44 A1  1 20 40 A0  1 
   \ Fix things so clipped-redisplay redisplays the entire line
   \ If xdamage is nonzero, clipped-redisplay will first move the
   \ cursor to xdamage.
   dup is xdamage  is window-x
1A144D0 	40 49 A0  1 B8 40 A0  1 
1A144D8 	F0 41 A1  1 B8 40 A0  1 
1A144E0 	DC 41 A1  1 
;
1A144E4 	58 46 A0  1 

[ifdef] smooth-hscroll
\ If the cursor is at either end of the line, we allow it to go
\ all the way to the end;  Otherwise, we limit it to the adjacent
\ cell, so that you can always tell what you will delete.
: #before-min  ( -- n )  #before  #before 0<>  if  1-  then  ;
: #before-max  ( -- n )  #before  #after  0<>  if  1+  then  ;
[then]

: ?reframe  ( -- )
1A144E8 	 0  0  0 3F 72 65 66 72 
1A144F0 	61 6D 65 88 CC 44 A1  1 
1A144F8 	20 40 A0  1 
   \ If we don't have an overflow condition, we cancel the window-x offset
   linelen window-width <=  window-x 0<>  and  if  0 set-window-x  exit  then
1A144FC 	F8 40 A1  1 
1A14500 	C4 41 A1  1  C 49 A0  1 
1A14508 	DC 41 A1  1 44 47 A0  1 
1A14510 	5C 44 A0  1 DC 41 A0  1 
1A14518 	10  0  0  0 70 6F A0  1 
1A14520 	CC 44 A1  1 40 46 A0  1 

   \ The text doesn't fit, so we must decide where to put it in the window

[ifdef] smooth-hscroll
   \ If the cursor is out of the window in either direction, set window-x so
   \ the cursor is back in the window at the end closest to where it was.
   #before-min  window-x  <  if  #before-min set-window-x   exit  then

   #before-max  window-x window-width +  >=  if
      #before-max  window-width -  set-window-x
      exit
   then
[else]
   \ If the cursor is out of the window in either direction, set window-x so
   \ the cursor is back in the window at the end closest to where it was.
   #before  window-x  dup window-width +  within  0=  if
1A14528 	 C 41 A1  1 DC 41 A1  1 
1A14530 	40 49 A0  1 C4 41 A1  1 
1A14538 	 4 45 A0  1  8 71 A0  1 
1A14540 	24 47 A0  1 DC 41 A0  1 
1A14548 	24  0  0  0 
      #before  window-width 2/  -  0 max  set-window-x
1A1454C 	 C 41 A1  1 
1A14550 	C4 41 A1  1 78 4B A0  1 
1A14558 	18 45 A0  1 70 6F A0  1 
1A14560 	9C 4A A0  1 CC 44 A1  1 
      exit
1A14568 	40 46 A0  1 
   then
[then]

   \ If we get here, the cursor is still in the window, so we leave
   \ window-x as-is
;
1A1456C 	58 46 A0  1 

: clipped-redisplay  ( -- )
1A14570 	 0  0 63 6C 69 70 70 65 
1A14578 	64 2D 72 65 64 69 73 70 
1A14580 	6C 61 79 91 F8 44 A1  1 
1A14588 	20 40 A0  1 
   \ Redisplay everything after the first damaged location

   \ The reframer has ensured that #before is in the window.

   xdamage -1 <>  if                                ( )
1A1458C 	F0 41 A1  1 
1A14590 	58 41 A0  1 FF FF FF FF 
1A14598 	44 48 A0  1 DC 41 A0  1 
1A145A0 	30  0  0  0 
      \ Move the cursor to the leftmost damaged position
      xdamage clip-x  dup  hmove-cursor             ( damage )
1A145A4 	F0 41 A1  1 
1A145A8 	98 44 A1  1 40 49 A0  1 
1A145B0 	DC 43 A1  1 

      \ Redraw from the damaged position to the new end-of-line
      linelen clip-x                                ( damage end )
1A145B4 	F8 40 A1  1 
1A145B8 	98 44 A1  1 
      over - wtype                                  ( )
1A145BC 	54 49 A0  1 
1A145C0 	18 45 A0  1 A4 43 A1  1 

      \ If the old end-of=line is greater than the new one, blank the residue
      #to-clear  spaces                             ( )
1A145C8 	78 42 A1  1 E8 71 A0  1 
   then                                             ( )

   #before clip-x hmove-cursor
1A145D0 	 C 41 A1  1 98 44 A1  1 
1A145D8 	DC 43 A1  1 
;
1A145DC 	58 46 A0  1 

\ Redisplays the editing line, optimizing for common types of changes.

: hredisplay  ( -- )
1A145E0 	 0 68 72 65 64 69 73 70 
1A145E8 	6C 61 79 8A 88 45 A1  1 
1A145F0 	20 40 A0  1 
   .line#
1A145F4 	20 43 A1  1 
   ?reframe
1A145F8 	F8 44 A1  1 
   clipped-redisplay
1A145FC 	88 45 A1  1 
   -1 is xdamage
1A14600 	58 41 A0  1 FF FF FF FF 
1A14608 	B8 40 A0  1 F0 41 A1  1 
;
1A14610 	58 46 A0  1 

defer vredisplay  ' noop is vredisplay
1A14614 	 0 76 72 65 
1A14618 	64 69 73 70 6C 61 79 8A 
1A14620 	F0 45 A1  1 5C 40 A0  1 
1A14628 	D4  3  0  0 
: redisplay  ( -- )  display?  if  vredisplay  hredisplay  then  ;
1A1462C 	 0  0 72 65 
1A14630 	64 69 73 70 6C 61 79 89 
1A14638 	24 46 A1  1 20 40 A0  1 
1A14640 	7C 40 A1  1 DC 41 A0  1 
1A14648 	 C  0  0  0 24 46 A1  1 
1A14650 	F0 45 A1  1 58 46 A0  1 

defer line-moved
1A14658 	 0 6C 69 6E 65 2D 6D 6F 
1A14660 	76 65 64 8A 3C 46 A1  1 
1A14668 	5C 40 A0  1 D8  3  0  0 
: (line-moved)  ( -- )     \ Version for 1-line display
1A14670 	 0  0  0 28 6C 69 6E 65 
1A14678 	2D 6D 6F 76 65 64 29 8C 
1A14680 	68 46 A1  1 20 40 A0  1 
   0 is xdamage  true is redisplay-line#?  0 is window-x
1A14688 	70 6F A0  1 B8 40 A0  1 
1A14690 	F0 41 A1  1  4 70 A0  1 
1A14698 	B8 40 A0  1  C 43 A1  1 
1A146A0 	70 6F A0  1 B8 40 A0  1 
1A146A8 	DC 41 A1  1 
;
1A146AC 	58 46 A0  1 
' (line-moved) is line-moved

\ Invalidate the line display values.  The cursor must be on a line
\ that is clear to the right of the cursor when this is called.
\ The scrolling area will extend from the current cursor position,
\ as indicated by the current value of #out, to display-width.
: clear-line  ( -- )
1A146B0 	 0 63 6C 65 61 72 2D 6C 
1A146B8 	69 6E 65 8A 84 46 A1  1 
1A146C0 	20 40 A0  1 
   0 is dirty-x                   \ Force update of line end information 
1A146C4 	70 6F A0  1 
1A146C8 	B8 40 A0  1 34 42 A1  1 
   new-window-width  line-moved
1A146D0 	B8 42 A1  1 68 46 A1  1 
;
1A146D8 	58 46 A0  1 
defer open-display  ( -- )
1A146DC 	 0  0  0 6F 
1A146E0 	70 65 6E 2D 64 69 73 70 
1A146E8 	6C 61 79 8C C0 46 A1  1 
1A146F0 	5C 40 A0  1 DC  3  0  0 
defer close-display  ( -- )
1A146F8 	 0  0 63 6C 6F 73 65 2D 
1A14700 	64 69 73 70 6C 61 79 8D 
1A14708 	F0 46 A1  1 5C 40 A0  1 
1A14710 	E0  3  0  0 
' clear-line is open-display
' cr is close-display

\ Goes to a clean line on the display, noting that the old line display
\ values are now invalid.  This will cause the redisplay code to do a
\ full redisplay of the current line.
: fresh-line  ( -- )  display?  if  cr  clear-line  then  ;
1A14714 	 0 66 72 65 
1A14718 	73 68 2D 6C 69 6E 65 8A 
1A14720 	 C 47 A1  1 20 40 A0  1 
1A14728 	7C 40 A1  1 DC 41 A0  1 
1A14730 	 C  0  0  0 80 6D A0  1 
1A14738 	C0 46 A1  1 58 46 A0  1 

defer scroll-down
1A14740 	73 63 72 6F 6C 6C 2D 64 
1A14748 	6F 77 6E 8B 24 47 A1  1 
1A14750 	5C 40 A0  1 E4  3  0  0 
' fresh-line is scroll-down

\ Movement within a line, which doesn't affect the state of the buffer

headers
\ Move forward "#chars" positions, but stop at the end of the line.
: forward-characters  ( #chars -- )  #after min  #before +  is #before  ;
1A14758 	 0 66 6F 72 77 61 72 64 
1A14760 	2D 63 68 61 72 61 63 74 
1A14768 	65 72 73 92 50 47 A1  1 
1A14770 	20 40 A0  1 38 41 A1  1 
1A14778 	74 4A A0  1  C 41 A1  1 
1A14780 	 4 45 A0  1 B8 40 A0  1 
1A14788 	 C 41 A1  1 58 46 A0  1 

\ Move backward "#chars" positions, but stop at the beginning of the line.
: backward-characters  ( #chars -- )  #before min  #before swap -  is #before ;
1A14790 	62 61 63 6B 77 61 72 64 
1A14798 	2D 63 68 61 72 61 63 74 
1A147A0 	65 72 73 93 70 47 A1  1 
1A147A8 	20 40 A0  1  C 41 A1  1 
1A147B0 	74 4A A0  1  C 41 A1  1 
1A147B8 	68 49 A0  1 18 45 A0  1 
1A147C0 	B8 40 A0  1  C 41 A1  1 
1A147C8 	58 46 A0  1 

: forward-character   ( -- )  1 forward-characters  ;
1A147CC 	 0  0 66 6F 
1A147D0 	72 77 61 72 64 2D 63 68 
1A147D8 	61 72 61 63 74 65 72 91 
1A147E0 	A8 47 A1  1 20 40 A0  1 
1A147E8 	80 6F A0  1 70 47 A1  1 
1A147F0 	58 46 A0  1 
: backward-character  ( -- )  1 backward-characters  ;
1A147F4 	 0 62 61 63 
1A147F8 	6B 77 61 72 64 2D 63 68 
1A14800 	61 72 61 63 74 65 72 92 
1A14808 	E4 47 A1  1 20 40 A0  1 
1A14810 	80 6F A0  1 A8 47 A1  1 
1A14818 	58 46 A0  1 
: end-of-line         ( -- )  #after forward-characters  ;
1A1481C 	65 6E 64 2D 
1A14820 	6F 66 2D 6C 69 6E 65 8B 
1A14828 	 C 48 A1  1 20 40 A0  1 
1A14830 	38 41 A1  1 70 47 A1  1 
1A14838 	58 46 A0  1 
: beginning-of-line   ( -- )  #before backward-characters  ;
1A1483C 	 0  0 62 65 
1A14840 	67 69 6E 6E 69 6E 67 2D 
1A14848 	6F 66 2D 6C 69 6E 65 91 
1A14850 	2C 48 A1  1 20 40 A0  1 
1A14858 	 C 41 A1  1 A8 47 A1  1 
1A14860 	58 46 A0  1 

\ Redisplays the current line
: retype-line  ( -- )  scroll-down  ;
1A14864 	72 65 74 79 
1A14868 	70 65 2D 6C 69 6E 65 8B 
1A14870 	54 48 A1  1 20 40 A0  1 
1A14878 	50 47 A1  1 58 46 A0  1 

headerless

\ Locates the beginning of the previous (blank-delimited) word.
\ Doesn't move the cursor or change the display.  Internal.

: find-previous-word  ( -- adr )
1A14880 	 0 66 69 6E 64 2D 70 72 
1A14888 	65 76 69 6F 75 73 2D 77 
1A14890 	6F 72 64 92 74 48 A1  1 
1A14898 	20 40 A0  1 
   cursor-adr line-start-adr =  if  line-start-adr exit  then
1A1489C 	5C 41 A1  1 
1A148A0 	E4 40 A1  1 24 48 A0  1 
1A148A8 	DC 41 A0  1  C  0  0  0 
1A148B0 	E4 40 A1  1 40 46 A0  1 
   line-start-adr  dup cursor-adr 1-  ?do   ( linestart )
1A148B8 	E4 40 A1  1 40 49 A0  1 
1A148C0 	5C 41 A1  1 54 4B A0  1 
1A148C8 	50 42 A0  1 38  0  0  0 
      i c@  bl <>  if  drop i leave  then
1A148D0 	B4 42 A0  1 C4 4C A0  1 
1A148D8 	28 70 A0  1 44 48 A0  1 
1A148E0 	DC 41 A0  1 10  0  0  0 
1A148E8 	30 49 A0  1 B4 42 A0  1 
1A148F0 	18 43 A0  1 
   -1 +loop
1A148F4 	58 41 A0  1 
1A148F8 	FF FF FF FF 1C 42 A0  1 
1A14900 	D0 FF FF FF 
   ( nonblank-adr )
   line-start-adr  dup  rot  ?do   ( linestart )
1A14904 	E4 40 A1  1 
1A14908 	40 49 A0  1 7C 49 A0  1 
1A14910 	50 42 A0  1 3C  0  0  0 
      i c@  bl =  if  drop i 1+  leave  then
1A14918 	B4 42 A0  1 C4 4C A0  1 
1A14920 	28 70 A0  1 24 48 A0  1 
1A14928 	DC 41 A0  1 14  0  0  0 
1A14930 	30 49 A0  1 B4 42 A0  1 
1A14938 	30 4B A0  1 18 43 A0  1 
   -1 +loop
1A14940 	58 41 A0  1 FF FF FF FF 
1A14948 	1C 42 A0  1 CC FF FF FF 
;
1A14950 	58 46 A0  1 

\ Locates the beginning of the next (blank-delimited) word.
\ Doesn't move the cursor or change the display.  Internal.

: find-next-word  ( -- adr )
1A14954 	 0 66 69 6E 
1A14958 	64 2D 6E 65 78 74 2D 77 
1A14960 	6F 72 64 8E 98 48 A1  1 
1A14968 	20 40 A0  1 
   line-end-adr  dup  cursor-adr  ?do  ( bufend-adr )
1A1496C 	A0 41 A1  1 
1A14970 	40 49 A0  1 5C 41 A1  1 
1A14978 	50 42 A0  1 30  0  0  0 
      i c@  bl =  if  drop i leave  then
1A14980 	B4 42 A0  1 C4 4C A0  1 
1A14988 	28 70 A0  1 24 48 A0  1 
1A14990 	DC 41 A0  1 10  0  0  0 
1A14998 	30 49 A0  1 B4 42 A0  1 
1A149A0 	18 43 A0  1 
   loop
1A149A4 	F8 41 A0  1 
1A149A8 	D8 FF FF FF 
   line-end-adr  dup  rot  ?do  ( bufend-adr )
1A149AC 	A0 41 A1  1 
1A149B0 	40 49 A0  1 7C 49 A0  1 
1A149B8 	50 42 A0  1 30  0  0  0 
      i c@  bl <>  if  drop i leave  then
1A149C0 	B4 42 A0  1 C4 4C A0  1 
1A149C8 	28 70 A0  1 44 48 A0  1 
1A149D0 	DC 41 A0  1 10  0  0  0 
1A149D8 	30 49 A0  1 B4 42 A0  1 
1A149E0 	18 43 A0  1 
   loop
1A149E4 	F8 41 A0  1 
1A149E8 	D8 FF FF FF 
;
1A149EC 	58 46 A0  1 

\ This is used by the command completion package; it ought to be elsewhere,
\ and it also should find the end of the word without going there.
: end-of-word  ( -- )
1A149F0 	65 6E 64 2D 6F 66 2D 77 
1A149F8 	6F 72 64 8B 68 49 A1  1 
1A14A00 	20 40 A0  1 
   after bounds  ?do
1A14A04 	7C 41 A1  1 
1A14A08 	F0 6D A0  1 50 42 A0  1 
1A14A10 	24  0  0  0 
      i c@  bl =  ?leave  forward-character
1A14A14 	B4 42 A0  1 
1A14A18 	C4 4C A0  1 28 70 A0  1 
1A14A20 	24 48 A0  1 34 43 A0  1 
1A14A28 	E4 47 A1  1 
   loop
1A14A2C 	F8 41 A0  1 
1A14A30 	E4 FF FF FF 
;
1A14A34 	58 46 A0  1 

headers
: forward-word  ( -- )  find-next-word cursor-adr -  forward-characters  ;
1A14A38 	 0  0  0 66 6F 72 77 61 
1A14A40 	72 64 2D 77 6F 72 64 8C 
1A14A48 	 0 4A A1  1 20 40 A0  1 
1A14A50 	68 49 A1  1 5C 41 A1  1 
1A14A58 	18 45 A0  1 70 47 A1  1 
1A14A60 	58 46 A0  1 
: backward-word  ( -- )
1A14A64 	 0  0 62 61 
1A14A68 	63 6B 77 61 72 64 2D 77 
1A14A70 	6F 72 64 8D 4C 4A A1  1 
1A14A78 	20 40 A0  1 
   cursor-adr find-previous-word -  backward-characters
1A14A7C 	5C 41 A1  1 
1A14A80 	98 48 A1  1 18 45 A0  1 
1A14A88 	A8 47 A1  1 
;
1A14A8C 	58 46 A0  1 

\ Values describing the buffer that contains multiple editing lines

headerless
0 value buf-start-adr   \ address of start of input buffer
1A14A90 	 0  0 62 75 66 2D 73 74 
1A14A98 	61 72 74 2D 61 64 72 8D 
1A14AA0 	78 4A A1  1 50 40 A0  1 
1A14AA8 	E8  3  0  0 
headers
\ "buflen" needs a header because it's used by nvalias.fth
0 value buflen          \ current size of input buffer
1A14AAC 	 0 62 75 66 
1A14AB0 	6C 65 6E 86 A4 4A A1  1 
1A14AB8 	50 40 A0  1 EC  3  0  0 
headerless
0 value bufmax          \ maximum size of input buffer
1A14AC0 	 0 62 75 66 6D 61 78 86 
1A14AC8 	B8 4A A1  1 50 40 A0  1 
1A14AD0 	F0  3  0  0 

\ : buf-extent    ( -- adr len )  buf-start-adr  buflen  ;
\ : buf-end-adr   ( -- n )        buf-extent +  ;
: buf-end-adr   ( -- adr )   buf-start-adr buflen +  ;
1A14AD4 	62 75 66 2D 
1A14AD8 	65 6E 64 2D 61 64 72 8B 
1A14AE0 	CC 4A A1  1 20 40 A0  1 
1A14AE8 	A4 4A A1  1 B8 4A A1  1 
1A14AF0 	 4 45 A0  1 58 46 A0  1 
: buf#after     ( -- n )     buf-end-adr  cursor-adr -  ;
1A14AF8 	 0  0 62 75 66 23 61 66 
1A14B00 	74 65 72 89 E4 4A A1  1 
1A14B08 	20 40 A0  1 E4 4A A1  1 
1A14B10 	5C 41 A1  1 18 45 A0  1 
1A14B18 	58 46 A0  1 

\ The words after this point manipulate the buffer and its cursor
\ position, calling the display routines as needed to maintain the display.

headers
81 buffer: kill-buffer
1A14B1C 	6B 69 6C 6C 
1A14B20 	2D 62 75 66 66 65 72 8B 
1A14B28 	 8 4B A1  1 B4 A9 A0  1 
1A14B30 	F4  3  0  0 51  0  0  0 
1A14B38 	EC 25 A1  1 
headerless

\ Deletes "#chars" characters after the cursor.  This affects the characters
\ in the buffer, but does not update the screen display.  It will delete
\ newline characters the same as any others.

: (erase-characters)  ( #chars -- )
1A14B3C 	 0 28 65 72 
1A14B40 	61 73 65 2D 63 68 61 72 
1A14B48 	61 63 74 65 72 73 29 92 
1A14B50 	2C 4B A1  1 20 40 A0  1 
   >r
1A14B58 	BC 45 A0  1 
   r@ 1 >  if  cursor-adr r@  kill-buffer  place  then
1A14B5C 	E4 45 A0  1 
1A14B60 	80 6F A0  1  4 48 A0  1 
1A14B68 	DC 41 A0  1 14  0  0  0 
1A14B70 	5C 41 A1  1 E4 45 A0  1 
1A14B78 	2C 4B A1  1 F0 88 A0  1 
   cursor-adr  dup r@ +  swap  buf#after r@ -  cmove  \ Remove from buffer
1A14B80 	5C 41 A1  1 40 49 A0  1 
1A14B88 	E4 45 A0  1  4 45 A0  1 
1A14B90 	68 49 A0  1  8 4B A1  1 
1A14B98 	E4 45 A0  1 18 45 A0  1 
1A14BA0 	10 44 A0  1 
   buflen r> - is buflen
1A14BA4 	B8 4A A1  1 
1A14BA8 	D0 45 A0  1 18 45 A0  1 
1A14BB0 	B8 40 A0  1 B8 4A A1  1 
;
1A14BB8 	58 46 A0  1 

headers
\ "(insert-characters)" needs a header because it's used by nvalias.fth

\ Inserts characters from "adr len" into the buffer, up to the amount
\ of space remaining in the buffer.  #inserted is the number that
\ were actually inserted.  Does not update the display.

: (insert-characters)  ( adr len -- #inserted )
1A14BBC 	28 69 6E 73 
1A14BC0 	65 72 74 2D 63 68 61 72 
1A14BC8 	61 63 74 65 72 73 29 93 
1A14BD0 	54 4B A1  1 20 40 A0  1 
   dup buflen +  bufmax  <=  if        ( adr len )
1A14BD8 	40 49 A0  1 B8 4A A1  1 
1A14BE0 	 4 45 A0  1 CC 4A A1  1 
1A14BE8 	 C 49 A0  1 DC 41 A0  1 
1A14BF0 	64  0  0  0 
      dup buflen + is buflen           ( adr len )
1A14BF4 	40 49 A0  1 
1A14BF8 	B8 4A A1  1  4 45 A0  1 
1A14C00 	B8 40 A0  1 B8 4A A1  1 
      dup linelen + is linelen         ( adr len )
1A14C08 	40 49 A0  1 F8 40 A1  1 
1A14C10 	 4 45 A0  1 B8 40 A0  1 
1A14C18 	F8 40 A1  1 
      cursor-adr   2dup +              ( adr len  src-addr dst-addr )
1A14C1C 	5C 41 A1  1 
1A14C20 	C0 49 A0  1  4 45 A0  1 
      buf#after 3 pick -  cmove>       ( adr len  )
1A14C28 	 8 4B A1  1 A0 6F A0  1 
1A14C30 	 C 4A A0  1 18 45 A0  1 
1A14C38 	34 44 A0  1 
      tuck cursor-adr  swap cmove      ( len=#inserted )
1A14C3C 	E8 46 A0  1 
1A14C40 	5C 41 A1  1 68 49 A0  1 
1A14C48 	10 44 A0  1 
   else
1A14C4C 	C8 41 A0  1 
1A14C50 	 C  0  0  0 
      2drop 0                          ( 0 )
1A14C54 	AC 49 A0  1 
1A14C58 	70 6F A0  1 
   then
;
1A14C5C 	58 46 A0  1 
headerless

\ Finds the line length.  Used after moving to a new line.  Internal.
: update-linelen  ( -- )
1A14C60 	 0 75 70 64 61 74 65 2D 
1A14C68 	6C 69 6E 65 6C 65 6E 8E 
1A14C70 	D4 4B A1  1 20 40 A0  1 
   buf#after  0  ?do
1A14C78 	 8 4B A1  1 70 6F A0  1 
1A14C80 	50 42 A0  1 38  0  0  0 
      cursor-adr  i ca+ c@  newline =  ?leave
1A14C88 	5C 41 A1  1 B4 42 A0  1 
1A14C90 	 4 50 A0  1 C4 4C A0  1 
1A14C98 	A8 71 A0  1 24 48 A0  1 
1A14CA0 	34 43 A0  1 
      linelen 1+ is linelen
1A14CA4 	F8 40 A1  1 
1A14CA8 	30 4B A0  1 B8 40 A0  1 
1A14CB0 	F8 40 A1  1 
   loop
1A14CB4 	F8 41 A0  1 
1A14CB8 	D0 FF FF FF 
;
1A14CBC 	58 46 A0  1 
headers
: last-line?  ( -- flag )  line-end-adr  buf-end-adr  u>=  ;
1A14CC0 	 0 6C 61 73 74 2D 6C 69 
1A14CC8 	6E 65 3F 8A 74 4C A1  1 
1A14CD0 	20 40 A0  1 A0 41 A1  1 
1A14CD8 	E4 4A A1  1 CC 48 A0  1 
1A14CE0 	58 46 A0  1 
headerless
: set-line  ( line-start-adr line# -- )
1A14CE4 	 0  0  0 73 
1A14CE8 	65 74 2D 6C 69 6E 65 88 
1A14CF0 	D0 4C A1  1 20 40 A0  1 
   is edit-line#  is line-start-adr  0 is #before  0 is linelen  update-linelen
1A14CF8 	B8 40 A0  1 24 41 A1  1 
1A14D00 	B8 40 A0  1 E4 40 A1  1 
1A14D08 	70 6F A0  1 B8 40 A0  1 
1A14D10 	 C 41 A1  1 70 6F A0  1 
1A14D18 	B8 40 A0  1 F8 40 A1  1 
1A14D20 	74 4C A1  1 
;
1A14D24 	58 46 A0  1 
: +line  ( -- )
1A14D28 	 0  0 2B 6C 69 6E 65 85 
1A14D30 	F4 4C A1  1 20 40 A0  1 
   last-line?  if
1A14D38 	D0 4C A1  1 DC 41 A0  1 
1A14D40 	14  0  0  0 
      line-end-adr  edit-line#
1A14D44 	A0 41 A1  1 
1A14D48 	24 41 A1  1 
   else
1A14D4C 	C8 41 A0  1 
1A14D50 	14  0  0  0 
      line-end-adr 1+  edit-line# 1+
1A14D54 	A0 41 A1  1 
1A14D58 	30 4B A0  1 24 41 A1  1 
1A14D60 	30 4B A0  1 
   then
   set-line
1A14D64 	F4 4C A1  1 
;
1A14D68 	58 46 A0  1 
: end-line?  ( -- flag )  line-start-adr buf-end-adr u>=  ;
1A14D6C 	 0  0 65 6E 
1A14D70 	64 2D 6C 69 6E 65 3F 89 
1A14D78 	34 4D A1  1 20 40 A0  1 
1A14D80 	E4 40 A1  1 E4 4A A1  1 
1A14D88 	CC 48 A0  1 58 46 A0  1 
: -line  ( -- )
1A14D90 	 0  0 2D 6C 69 6E 65 85 
1A14D98 	7C 4D A1  1 20 40 A0  1 
   buf-start-adr  dup 1+                  ( previous-length buf0 buf1 )
1A14DA0 	A4 4A A1  1 40 49 A0  1 
1A14DA8 	30 4B A0  1 
   dup line-start-adr 1- max  ?do         ( previous-length buf0 )
1A14DAC 	40 49 A0  1 
1A14DB0 	E4 40 A1  1 54 4B A0  1 
1A14DB8 	9C 4A A0  1 50 42 A0  1 
1A14DC0 	44  0  0  0 
      i -1 ca+ c@                         ( previous-length buf0 char )
1A14DC4 	B4 42 A0  1 
1A14DC8 	58 41 A0  1 FF FF FF FF 
1A14DD0 	 4 50 A0  1 C4 4C A0  1 
      newline =  if  drop i leave  then   ( previous-length line-adr )
1A14DD8 	A8 71 A0  1 24 48 A0  1 
1A14DE0 	DC 41 A0  1 10  0  0  0 
1A14DE8 	30 49 A0  1 B4 42 A0  1 
1A14DF0 	18 43 A0  1 
   -1 +loop                               ( previous-length line-adr )
1A14DF4 	58 41 A0  1 
1A14DF8 	FF FF FF FF 1C 42 A0  1 
1A14E00 	C4 FF FF FF 
   edit-line# 1-  set-line                ( previous-length )
1A14E04 	24 41 A1  1 
1A14E08 	54 4B A0  1 F4 4C A1  1 
;
1A14E10 	58 46 A0  1 

: (to-command-line)  ( -- )
1A14E14 	 0  0 28 74 
1A14E18 	6F 2D 63 6F 6D 6D 61 6E 
1A14E20 	64 2D 6C 69 6E 65 29 91 
1A14E28 	9C 4D A1  1 20 40 A0  1 
   0 is #before
1A14E30 	70 6F A0  1 B8 40 A0  1 
1A14E38 	 C 41 A1  1 
   begin  edit-line# 0<  while  +line  repeat
1A14E3C 	24 41 A1  1 
1A14E40 	64 47 A0  1 DC 41 A0  1 
1A14E48 	10  0  0  0 34 4D A1  1 
1A14E50 	C8 41 A0  1 E8 FF FF FF 
;
1A14E58 	58 46 A0  1 

: ?copyline  ( -- )
1A14E5C 	 0  0 3F 63 
1A14E60 	6F 70 79 6C 69 6E 65 89 
1A14E68 	2C 4E A1  1 20 40 A0  1 
   edit-line#  0<  if
1A14E70 	24 41 A1  1 64 47 A0  1 
1A14E78 	DC 41 A0  1 44  0  0  0 
      #before  line-start-adr  linelen               ( cursor adr len )
1A14E80 	 C 41 A1  1 E4 40 A1  1 
1A14E88 	F8 40 A1  1 
      (to-command-line)                              ( cursor adr len )
1A14E8C 	2C 4E A1  1 
      #after  if
1A14E90 	38 41 A1  1 DC 41 A0  1 
1A14E98 	18  0  0  0 
         #after (erase-characters)
1A14E9C 	38 41 A1  1 
1A14EA0 	54 4B A1  1 
         0 is linelen
1A14EA4 	70 6F A0  1 
1A14EA8 	B8 40 A0  1 F8 40 A1  1 
      then                                           ( cursor adr len )
      (insert-characters) drop                       ( cursor )
1A14EB0 	D4 4B A1  1 30 49 A0  1 
      is #before
1A14EB8 	B8 40 A0  1  C 41 A1  1 
   then
;
1A14EC0 	58 46 A0  1 

: set-ydamage  ( -- )  edit-line# 1+ is ydamage  ;
1A14EC4 	73 65 74 2D 
1A14EC8 	79 64 61 6D 61 67 65 8B 
1A14ED0 	6C 4E A1  1 20 40 A0  1 
1A14ED8 	24 41 A1  1 30 4B A0  1 
1A14EE0 	B8 40 A0  1  4 42 A1  1 
1A14EE8 	58 46 A0  1 
: set-xdamage  ( -- )  xdamage #before umin  is xdamage  ;
1A14EEC 	73 65 74 2D 
1A14EF0 	78 64 61 6D 61 67 65 8B 
1A14EF8 	D4 4E A1  1 20 40 A0  1 
1A14F00 	F0 41 A1  1  C 41 A1  1 
1A14F08 	4C 4A A0  1 B8 40 A0  1 
1A14F10 	F0 41 A1  1 58 46 A0  1 

\ Insertion and deletion

headers

\ Inserts characters from "adr len" into the buffer, and redisplays
\ the rest of the line.
: insert-characters  ( adr len -- )
1A14F18 	 0  0 69 6E 73 65 72 74 
1A14F20 	2D 63 68 61 72 61 63 74 
1A14F28 	65 72 73 91 FC 4E A1  1 
1A14F30 	20 40 A0  1 
   ?copyline
1A14F34 	6C 4E A1  1 
   (insert-characters)          ( #inserted )
1A14F38 	D4 4B A1  1 
   dup  if  set-xdamage  then   ( #inserted )
1A14F3C 	40 49 A0  1 
1A14F40 	DC 41 A0  1  8  0  0  0 
1A14F48 	FC 4E A1  1 
   forward-characters
1A14F4C 	70 47 A1  1 
;
1A14F50 	58 46 A0  1 

\ Erases characters within a line and redisplays the rest of the line.
\ "#chars" must not be more than "#after"
: erase-characters  ( #chars -- )
1A14F54 	 0  0  0 65 
1A14F58 	72 61 73 65 2D 63 68 61 
1A14F60 	72 61 63 74 65 72 73 90 
1A14F68 	30 4F A1  1 20 40 A0  1 
   ?copyline
1A14F70 	6C 4E A1  1 
   set-xdamage
1A14F74 	FC 4E A1  1 
   dup (erase-characters)
1A14F78 	40 49 A0  1 54 4B A1  1 
   linelen swap - is linelen
1A14F80 	F8 40 A1  1 68 49 A0  1 
1A14F88 	18 45 A0  1 B8 40 A0  1 
1A14F90 	F8 40 A1  1 
;
1A14F94 	58 46 A0  1 

headerless
nuser ch	\ One-element array used to convert character to "adr len"
1A14F98 	 0 63 68 82 6C 4F A1  1 
1A14FA0 	48 40 A0  1 F8  3  0  0 

headers
: insert-character  ( char -- )  ch c!  ch 1 insert-characters  ;
1A14FA8 	 0  0  0 69 6E 73 65 72 
1A14FB0 	74 2D 63 68 61 72 61 63 
1A14FB8 	74 65 72 90 A0 4F A1  1 
1A14FC0 	20 40 A0  1 A0 4F A1  1 
1A14FC8 	B8 4D A0  1 A0 4F A1  1 
1A14FD0 	80 6F A0  1 30 4F A1  1 
1A14FD8 	58 46 A0  1 
: quote-next-character  ( -- )  key insert-character  ;
1A14FDC 	 0  0  0 71 
1A14FE0 	75 6F 74 65 2D 6E 65 78 
1A14FE8 	74 2D 63 68 61 72 61 63 
1A14FF0 	74 65 72 94 C0 4F A1  1 
1A14FF8 	20 40 A0  1 50 6C A0  1 
1A15000 	C0 4F A1  1 58 46 A0  1 

: erase-next-character  ( -- )  #after 1 min  erase-characters  ;
1A15008 	 0  0  0 65 72 61 73 65 
1A15010 	2D 6E 65 78 74 2D 63 68 
1A15018 	61 72 61 63 74 65 72 94 
1A15020 	F8 4F A1  1 20 40 A0  1 
1A15028 	38 41 A1  1 80 6F A0  1 
1A15030 	74 4A A0  1 6C 4F A1  1 
1A15038 	58 46 A0  1 

: erase-previous-character  ( -- )
1A1503C 	 0  0  0 65 
1A15040 	72 61 73 65 2D 70 72 65 
1A15048 	76 69 6F 75 73 2D 63 68 
1A15050 	61 72 61 63 74 65 72 98 
1A15058 	24 50 A1  1 20 40 A0  1 
   #before 1 min  dup backward-characters  erase-characters
1A15060 	 C 41 A1  1 80 6F A0  1 
1A15068 	74 4A A0  1 40 49 A0  1 
1A15070 	A8 47 A1  1 6C 4F A1  1 
;
1A15078 	58 46 A0  1 

\ EMACS-style "kill-line".  If executed in the middle of a line, kills
\ the rest of the line.  If executed at the end of a line, kills the
\ "newline", thus joining the next line to the end of the current one.

: kill-to-end-of-line  ( -- )
1A1507C 	6B 69 6C 6C 
1A15080 	2D 74 6F 2D 65 6E 64 2D 
1A15088 	6F 66 2D 6C 69 6E 65 93 
1A15090 	5C 50 A1  1 20 40 A0  1 
   #after  ?dup  if
1A15098 	38 41 A1  1 B4 70 A0  1 
1A150A0 	DC 41 A0  1 10  0  0  0 
      erase-characters				\ Kill rest of line
1A150A8 	6C 4F A1  1 
   else
1A150AC 	C8 41 A0  1 
1A150B0 	34  0  0  0 
      accepting? 0=  if
1A150B4 	94 40 A1  1 
1A150B8 	24 47 A0  1 DC 41 A0  1 
1A150C0 	24  0  0  0 
         \ Join lines unless we're already at the end of the file
         buf#after  if
1A150C4 	 8 4B A1  1 
1A150C8 	DC 41 A0  1 18  0  0  0 
            1 (erase-characters)
1A150D0 	80 6F A0  1 54 4B A1  1 
            update-linelen
1A150D8 	74 4C A1  1 
            set-xdamage  set-ydamage
1A150DC 	FC 4E A1  1 
1A150E0 	D4 4E A1  1 
         then
      then
   then
;
1A150E4 	58 46 A0  1 
: erase-next-word  ( -- )  find-next-word cursor-adr -  erase-characters  ;
1A150E8 	65 72 61 73 65 2D 6E 65 
1A150F0 	78 74 2D 77 6F 72 64 8F 
1A150F8 	94 50 A1  1 20 40 A0  1 
1A15100 	68 49 A1  1 5C 41 A1  1 
1A15108 	18 45 A0  1 6C 4F A1  1 
1A15110 	58 46 A0  1 
: erase-previous-word  ( -- )
1A15114 	65 72 61 73 
1A15118 	65 2D 70 72 65 76 69 6F 
1A15120 	75 73 2D 77 6F 72 64 93 
1A15128 	FC 50 A1  1 20 40 A0  1 
   cursor-adr  backward-word  cursor-adr -  erase-characters
1A15130 	5C 41 A1  1 78 4A A1  1 
1A15138 	5C 41 A1  1 18 45 A0  1 
1A15140 	6C 4F A1  1 
;
1A15144 	58 46 A0  1 
: beginning-of-file  ( -- )  buf-start-adr 0 set-line  ;
1A15148 	 0  0 62 65 67 69 6E 6E 
1A15150 	69 6E 67 2D 6F 66 2D 66 
1A15158 	69 6C 65 91 2C 51 A1  1 
1A15160 	20 40 A0  1 A4 4A A1  1 
1A15168 	70 6F A0  1 F4 4C A1  1 
1A15170 	58 46 A0  1 

headerless

defer to-goal-column  ( -- )
1A15174 	 0 74 6F 2D 
1A15178 	67 6F 61 6C 2D 63 6F 6C 
1A15180 	75 6D 6E 8E 60 51 A1  1 
1A15188 	5C 40 A0  1 FC  3  0  0 
' end-of-line is to-goal-column

headers
defer deny-history?   \ Turns off history access for security
1A15190 	 0  0 64 65 6E 79 2D 68 
1A15198 	69 73 74 6F 72 79 3F 8D 
1A151A0 	88 51 A1  1 5C 40 A0  1 
1A151A8 	 0  4  0  0 
' false is deny-history?

\ Goes to the next line, if there is one
: next-line  ( -- )
1A151AC 	 0  0 6E 65 
1A151B0 	78 74 2D 6C 69 6E 65 89 
1A151B8 	A4 51 A1  1 20 40 A0  1 
   accepting? deny-history?  and  if  exit  then
1A151C0 	94 40 A1  1 A4 51 A1  1 
1A151C8 	5C 44 A0  1 DC 41 A0  1 
1A151D0 	 8  0  0  0 40 46 A0  1 
   last-line? 0=  if
1A151D8 	D0 4C A1  1 24 47 A0  1 
1A151E0 	DC 41 A0  1 24  0  0  0 
      line-moved
1A151E8 	68 46 A1  1 
      +line to-goal-column
1A151EC 	34 4D A1  1 
1A151F0 	88 51 A1  1 
      accepting? 0=  if  scroll-down  then
1A151F4 	94 40 A1  1 
1A151F8 	24 47 A0  1 DC 41 A0  1 
1A15200 	 8  0  0  0 50 47 A1  1 
   then
;
1A15208 	58 46 A0  1 

\ Goes to the previous line
: previous-line  ( -- )
1A1520C 	 0  0 70 72 
1A15210 	65 76 69 6F 75 73 2D 6C 
1A15218 	69 6E 65 8D BC 51 A1  1 
1A15220 	20 40 A0  1 
   accepting? deny-history?  and  if  exit  then
1A15224 	94 40 A1  1 
1A15228 	A4 51 A1  1 5C 44 A0  1 
1A15230 	DC 41 A0  1  8  0  0  0 
1A15238 	40 46 A0  1 
   buf-start-adr  line-start-adr  <  if  line-moved -line to-goal-column  then
1A1523C 	A4 4A A1  1 
1A15240 	E4 40 A1  1 E4 47 A0  1 
1A15248 	DC 41 A0  1 10  0  0  0 
1A15250 	68 46 A1  1 9C 4D A1  1 
1A15258 	88 51 A1  1 
;
1A1525C 	58 46 A0  1 

\ : forward-lines  ( #lines -- )   0  ?do  next-line  loop  ;
\ : backward-lines  ( #lines -- )   0  ?do  previous-line  loop  ;

: split-line  ( -- )
1A15260 	 0 73 70 6C 69 74 2D 6C 
1A15268 	69 6E 65 8A 20 52 A1  1 
1A15270 	20 40 A0  1 
   accepting?  if  beep exit  then
1A15274 	94 40 A1  1 
1A15278 	DC 41 A0  1  C  0  0  0 
1A15280 	A8 40 A1  1 40 46 A0  1 

   newline ch c!  ch 1 (insert-characters)  if
1A15288 	A8 71 A0  1 A0 4F A1  1 
1A15290 	B8 4D A0  1 A0 4F A1  1 
1A15298 	80 6F A0  1 D4 4B A1  1 
1A152A0 	DC 41 A0  1 18  0  0  0 
      set-xdamage  set-ydamage
1A152A8 	FC 4E A1  1 D4 4E A1  1 
      #before is linelen    \ Erase the rest of the line
1A152B0 	 C 41 A1  1 B8 40 A0  1 
1A152B8 	F8 40 A1  1 
   then
;
1A152BC 	58 46 A0  1 
: new-line  ( -- )  split-line  next-line  ;
1A152C0 	 0  0  0 6E 65 77 2D 6C 
1A152C8 	69 6E 65 88 70 52 A1  1 
1A152D0 	20 40 A0  1 70 52 A1  1 
1A152D8 	BC 51 A1  1 58 46 A0  1 
: list-file  ( -- )
1A152E0 	 0  0 6C 69 73 74 2D 66 
1A152E8 	69 6C 65 89 D0 52 A1  1 
1A152F0 	20 40 A0  1 
   accepting? deny-history? and  if  exit  then
1A152F4 	94 40 A1  1 
1A152F8 	A4 51 A1  1 5C 44 A0  1 
1A15300 	DC 41 A0  1  8  0  0  0 
1A15308 	40 46 A0  1 
   #before line-start-adr edit-line#    ( #before adr line# )
1A1530C 	 C 41 A1  1 
1A15310 	E4 40 A1  1 24 41 A1  1 
   beginning-of-file                    ( #before adr line# )
1A15318 	60 51 A1  1 
   begin                                ( #before adr line# )
      line-moved retype-line redisplay  ( #before adr line# )
1A1531C 	68 46 A1  1 
1A15320 	74 48 A1  1 3C 46 A1  1 
   exit? last-line? or  0=  while       ( #before adr line# )
1A15328 	34  D A1  1 D0 4C A1  1 
1A15330 	70 44 A0  1 24 47 A0  1 
1A15338 	DC 41 A0  1 10  0  0  0 
      +line                             ( #before adr line# )
1A15340 	34 4D A1  1 
   repeat                               ( #before adr line# )
1A15344 	C8 41 A0  1 
1A15348 	D4 FF FF FF 
   set-line  is #before
1A1534C 	F4 4C A1  1 
1A15350 	B8 40 A0  1  C 41 A1  1 
   retype-line
1A15358 	74 48 A1  1 
;
1A1535C 	58 46 A0  1 
: yank  ( -- )  kill-buffer count insert-characters  ;
1A15360 	 0  0  0 79 61 6E 6B 84 
1A15368 	F0 52 A1  1 20 40 A0  1 
1A15370 	2C 4B A1  1 BC 53 A0  1 
1A15378 	30 4F A1  1 58 46 A0  1 

defer recenter  ( -- )
1A15380 	 0  0  0 72 65 63 65 6E 
1A15388 	74 65 72 88 6C 53 A1  1 
1A15390 	5C 40 A0  1  4  4  0  0 
' list-file is recenter

: one-line-display  ( -- )
1A15398 	 0  0  0 6F 6E 65 2D 6C 
1A153A0 	69 6E 65 2D 64 69 73 70 
1A153A8 	6C 61 79 90 90 53 A1  1 
1A153B0 	20 40 A0  1 
   ['] clear-line      is open-display
1A153B4 	60 53 A0  1 
1A153B8 	C0 46 A1  1 98 40 A0  1 
1A153C0 	F0 46 A1  1 
   ['] cr              is close-display
1A153C4 	60 53 A0  1 
1A153C8 	80 6D A0  1 98 40 A0  1 
1A153D0 	 C 47 A1  1 
   ['] noop            is vredisplay
1A153D4 	60 53 A0  1 
1A153D8 	64 4F A0  1 98 40 A0  1 
1A153E0 	24 46 A1  1 
   ['] (new-line-end)  is new-line-end
1A153E4 	60 53 A0  1 
1A153E8 	50 42 A1  1 98 40 A0  1 
1A153F0 	20 42 A1  1 
   ['] (.line#)        is .line#
1A153F4 	60 53 A0  1 
1A153F8 	38 43 A1  1 98 40 A0  1 
1A15400 	20 43 A1  1 
   ['] (line-moved)    is line-moved
1A15404 	60 53 A0  1 
1A15408 	84 46 A1  1 98 40 A0  1 
1A15410 	68 46 A1  1 
   ['] end-of-line     is to-goal-column
1A15414 	60 53 A0  1 
1A15418 	2C 48 A1  1 98 40 A0  1 
1A15420 	88 51 A1  1 
   ['] fresh-line      is scroll-down
1A15424 	60 53 A0  1 
1A15428 	24 47 A1  1 98 40 A0  1 
1A15430 	50 47 A1  1 
   ['] list-file       is recenter
1A15434 	60 53 A0  1 
1A15438 	F0 52 A1  1 98 40 A0  1 
1A15440 	90 53 A1  1 
;
1A15444 	58 46 A0  1 

headers

OpenFirmware/forth/lib/fileed.fth_AL	5112 1A15448 purpose: Screen-oriented extension for the line editor

also hidden definitions

d# 24 value display-height
1A15448 	 0 64 69 73 70 6C 61 79 
1A15450 	2D 68 65 69 67 68 74 8E 
1A15458 	B0 53 A1  1 50 40 A0  1 
1A15460 	 8  4  0  0 

headerless
0 value window-y	\ The line at the top of the window
1A15464 	 0  0  0 77 
1A15468 	69 6E 64 6F 77 2D 79 88 
1A15470 	5C 54 A1  1 50 40 A0  1 
1A15478 	 C  4  0  0 
			\ Offset in lines from beginning of buffer
1 value window-height	\ Height of window in lines
1A1547C 	 0  0 77 69 
1A15480 	6E 64 6F 77 2D 68 65 69 
1A15488 	67 68 74 8D 74 54 A1  1 
1A15490 	50 40 A0  1 10  4  0  0 
0 value old-line#	\ The line that the cursor was on at the last redisplay
1A15498 	 0  0 6F 6C 64 2D 6C 69 
1A154A0 	6E 65 23 89 90 54 A1  1 
1A154A8 	50 40 A0  1 14  4  0  0 
			\ This tells which line window-x applies to.
			\ Offset in lines from beginning of buffer

\ Move cursor vertically
: vmove-cursor  ( window-line# -- )
1A154B0 	 0  0  0 76 6D 6F 76 65 
1A154B8 	2D 63 75 72 73 6F 72 8C 
1A154C0 	A8 54 A1  1 20 40 A0  1 
   #line @ -  ?dup  if                             ( #lines-down )
1A154C8 	70 6D A0  1 5C 4C A0  1 
1A154D0 	18 45 A0  1 B4 70 A0  1 
1A154D8 	DC 41 A0  1 28  0  0  0 
      dup  0<  if  negate ups  else  downs  then   ( )
1A154E0 	40 49 A0  1 64 47 A0  1 
1A154E8 	DC 41 A0  1 14  0  0  0 
1A154F0 	48 45 A0  1 68 F7 A0  1 
1A154F8 	C8 41 A0  1  8  0  0  0 
1A15500 	94 F7 A0  1 
   then
;
1A15504 	58 46 A0  1 

\ Converts buffer-line-oriented coordinates to window-relative coordinates
: clip-y  ( buf-line# -- window-line# )  window-y - 0 max  window-height min  ;
1A15508 	 0 63 6C 69 70 2D 79 86 
1A15510 	C4 54 A1  1 20 40 A0  1 
1A15518 	74 54 A1  1 18 45 A0  1 
1A15520 	70 6F A0  1 9C 4A A0  1 
1A15528 	90 54 A1  1 74 4A A0  1 
1A15530 	58 46 A0  1 

: vreframe  ( -- )
1A15534 	 0  0  0 76 
1A15538 	72 65 66 72 61 6D 65 88 
1A15540 	14 55 A1  1 20 40 A0  1 
   edit-line#  window-height 2/  -  0 max  ( new-window-y )
1A15548 	24 41 A1  1 90 54 A1  1 
1A15550 	78 4B A0  1 18 45 A0  1 
1A15558 	70 6F A0  1 9C 4A A0  1 
   dup is ydamage  is window-y
1A15560 	40 49 A0  1 B8 40 A0  1 
1A15568 	 4 42 A1  1 B8 40 A0  1 
1A15570 	74 54 A1  1 
   line-moved			\ The old line info is useless now
1A15574 	68 46 A1  1 
;
1A15578 	58 46 A0  1 

\ If the cursor is out of the window in either direction, set the window so
\ the cursor is in the middle of the window, but don't let window-y
\ be negative.
: ?vreframe  ( -- )
1A1557C 	 0  0 3F 76 
1A15580 	72 65 66 72 61 6D 65 89 
1A15588 	44 55 A1  1 20 40 A0  1 
   edit-line#  window-y  dup window-height +  within  0=  if  vreframe  then
1A15590 	24 41 A1  1 74 54 A1  1 
1A15598 	40 49 A0  1 90 54 A1  1 
1A155A0 	 4 45 A0  1  8 71 A0  1 
1A155A8 	24 47 A0  1 DC 41 A0  1 
1A155B0 	 8  0  0  0 44 55 A1  1 
;
1A155B8 	58 46 A0  1 

: move-cursor  ( x y -- )  ( 0 hmove-cursor )  vmove-cursor  hmove-cursor  ;
1A155BC 	6D 6F 76 65 
1A155C0 	2D 63 75 72 73 6F 72 8B 
1A155C8 	8C 55 A1  1 20 40 A0  1 
1A155D0 	C4 54 A1  1 DC 43 A1  1 
1A155D8 	58 46 A0  1 

d# 100 buffer: line-ends  
1A155DC 	 0  0 6C 69 
1A155E0 	6E 65 2D 65 6E 64 73 89 
1A155E8 	CC 55 A1  1 B4 A9 A0  1 
1A155F0 	18  4  0  0 64  0  0  0 
1A155F8 	2C 4B A1  1 
: w-new-line-end  ( new-line-end -- old-line-end )
1A155FC 	 0 77 2D 6E 
1A15600 	65 77 2D 6C 69 6E 65 2D 
1A15608 	65 6E 64 8E EC 55 A1  1 
1A15610 	20 40 A0  1 
   line-ends  #line @  +          ( new-line-end adr )
1A15614 	EC 55 A1  1 
1A15618 	70 6D A0  1 5C 4C A0  1 
1A15620 	 4 45 A0  1 
   dup c@  -rot c!                ( old-line-end )
1A15624 	40 49 A0  1 
1A15628 	C4 4C A0  1 94 49 A0  1 
1A15630 	B8 4D A0  1 
;
1A15634 	58 46 A0  1 

\ The lower boundary of non-white lines in the window
\ Offset in lines from top of window
: rest-blank?  ( -- flag )
1A15638 	72 65 73 74 2D 62 6C 61 
1A15640 	6E 6B 3F 8B 10 56 A1  1 
1A15648 	20 40 A0  1 
   true                                      ( flag )
1A1564C 	 4 70 A0  1 
   window-height  #line @  ?do               ( flag )
1A15650 	90 54 A1  1 70 6D A0  1 
1A15658 	5C 4C A0  1 50 42 A0  1 
1A15660 	2C  0  0  0 
      line-ends i + c@  if  0=  leave  then  ( flag )
1A15664 	EC 55 A1  1 
1A15668 	B4 42 A0  1  4 45 A0  1 
1A15670 	C4 4C A0  1 DC 41 A0  1 
1A15678 	 C  0  0  0 24 47 A0  1 
1A15680 	18 43 A0  1 
   loop                                      ( flag )
1A15684 	F8 41 A0  1 
1A15688 	DC FF FF FF 
;
1A1568C 	58 46 A0  1 

\ (display-range) refreshes the display beginning at start-line (in buffer
\ line coordinates), and continuing for a maximum of #lines, subject to the
\ lower limit of the window.  (display-range) clips the #lines argument as
\ necessary.

: (display-range)  ( start-line #lines -- )
1A15690 	28 64 69 73 70 6C 61 79 
1A15698 	2D 72 61 6E 67 65 29 8F 
1A156A0 	48 56 A1  1 20 40 A0  1 
   #before line-start-adr edit-line# >r >r >r	\ Save current buffer position
1A156A8 	 C 41 A1  1 E4 40 A1  1 
1A156B0 	24 41 A1  1 BC 45 A0  1 
1A156B8 	BC 45 A0  1 BC 45 A0  1 

   \ Find start-line in the buffer
   beginning-of-file  over 0  ?do  +line  loop            ( start-line #lines )
1A156C0 	60 51 A1  1 54 49 A0  1 
1A156C8 	70 6F A0  1 50 42 A0  1 
1A156D0 	10  0  0  0 34 4D A1  1 
1A156D8 	F8 41 A0  1 F8 FF FF FF 

   \ Convert start-line from a buffer line number to a window line number,
   swap clip-y swap bounds                                ( end start )
1A156E0 	68 49 A0  1 14 55 A1  1 
1A156E8 	68 49 A0  1 F0 6D A0  1 

   \ Clip the range so it doesn't extend past the bottom of the window.
   swap  window-height min  swap                          ( end start )
1A156F0 	68 49 A0  1 90 54 A1  1 
1A156F8 	74 4A A0  1 68 49 A0  1 

   \ Loop over display window lines, beginning at the window line
   \ corresponding to the buffer line "start-line", continuing for
   \ the minimum of "#lines" or the number of lines remaining in the
   \ display window, or until there are no more lines left in the
   \ buffer and the remaining display lines are already blank.
   ?do
1A15700 	50 42 A0  1 54  0  0  0 
      \ Move the cursor to the beginning of the next line
      0 i move-cursor
1A15708 	70 6F A0  1 B4 42 A0  1 
1A15710 	CC 55 A1  1 

      end-line?  if
1A15714 	7C 4D A1  1 
1A15718 	DC 41 A0  1 14  0  0  0 
         \ We have displayed all the lines in the buffer,
         \ so we continue looping and clearing display lines
         \ until all the lines below us are already blank.
         rest-blank? ?leave
1A15720 	48 56 A1  1 34 43 A0  1 
      else
1A15728 	C8 41 A0  1 18  0  0  0 
         \ There is a (possibly zero-length) buffer line here; display it
         line-start-adr  window-width linelen min  type
1A15730 	E4 40 A1  1 C4 41 A1  1 
1A15738 	F8 40 A1  1 74 4A A0  1 
1A15740 	 4 6C A0  1 
      then

      \ Erase the rest of the line (perhaps the entire line)
      #to-clear  spaces
1A15744 	78 42 A1  1 
1A15748 	E8 71 A0  1 

      \ Advance to the next line; +line stops at the end of the buffer
      +line
1A1574C 	34 4D A1  1 
   loop
1A15750 	F8 41 A0  1 B4 FF FF FF 

   r> r> r> set-line  is #before		\ Restore buffer position
1A15758 	D0 45 A0  1 D0 45 A0  1 
1A15760 	D0 45 A0  1 F4 4C A1  1 
1A15768 	B8 40 A0  1  C 41 A1  1 
;
1A15770 	58 46 A0  1 

: old-damaged?  ( -- flag )  ydamage old-line# u<=  ;
1A15774 	 0  0  0 6F 
1A15778 	6C 64 2D 64 61 6D 61 67 
1A15780 	65 64 3F 8C A4 56 A1  1 
1A15788 	20 40 A0  1  4 42 A1  1 
1A15790 	A8 54 A1  1 88 48 A0  1 
1A15798 	58 46 A0  1 
: shifted?  ( -- flag )  window-x 0<>  ;
1A1579C 	 0  0  0 73 
1A157A0 	68 69 66 74 65 64 3F 88 
1A157A8 	88 57 A1  1 20 40 A0  1 
1A157B0 	DC 41 A1  1 44 47 A0  1 
1A157B8 	58 46 A0  1 
: line-moved?  ( -- flag )  edit-line# ( window-y - )  old-line# <>  ;
1A157BC 	6C 69 6E 65 
1A157C0 	2D 6D 6F 76 65 64 3F 8B 
1A157C8 	AC 57 A1  1 20 40 A0  1 
1A157D0 	24 41 A1  1 A8 54 A1  1 
1A157D8 	44 48 A0  1 58 46 A0  1 

: display-below  ( -- )
1A157E0 	 0  0 64 69 73 70 6C 61 
1A157E8 	79 2D 62 65 6C 6F 77 8D 
1A157F0 	CC 57 A1  1 20 40 A0  1 
   shifted?  old-damaged?  and  line-moved? 0=  and  if
1A157F8 	AC 57 A1  1 88 57 A1  1 
1A15800 	5C 44 A0  1 CC 57 A1  1 
1A15808 	24 47 A0  1 5C 44 A0  1 
1A15810 	DC 41 A0  1  C  0  0  0 
      \ If the vertical damage includes the current line and it was
      \ shifted, the vertical redisplay procedure will mess it up,
      \ so we do this to trigger a horizontal redisplay later.
      window-x  set-window-x
1A15818 	DC 41 A1  1 CC 44 A1  1 
   then
   ydamage window-height (display-range)
1A15820 	 4 42 A1  1 90 54 A1  1 
1A15828 	A4 56 A1  1 
;
1A1582C 	58 46 A0  1 

: (vredisplay)  ( -- )
1A15830 	 0  0  0 28 76 72 65 64 
1A15838 	69 73 70 6C 61 79 29 8C 
1A15840 	F4 57 A1  1 20 40 A0  1 
   ?vreframe
1A15848 	8C 55 A1  1 
   ydamage -1 <>  if  display-below  then
1A1584C 	 4 42 A1  1 
1A15850 	58 41 A0  1 FF FF FF FF 
1A15858 	44 48 A0  1 DC 41 A0  1 
1A15860 	 8  0  0  0 F4 57 A1  1 

   line-moved?  if   \ Need to move vertically
1A15868 	CC 57 A1  1 DC 41 A0  1 
1A15870 	44  0  0  0 
      shifted?  old-damaged? 0=  and  if
1A15874 	AC 57 A1  1 
1A15878 	88 57 A1  1 24 47 A0  1 
1A15880 	5C 44 A0  1 DC 41 A0  1 
1A15888 	1C  0  0  0 
         \ Old line was shifted and hasn't yet been redrawn
         old-line# 1 (display-range)
1A1588C 	A8 54 A1  1 
1A15890 	80 6F A0  1 A4 56 A1  1 
         0 is window-x
1A15898 	70 6F A0  1 B8 40 A0  1 
1A158A0 	DC 41 A1  1 
      then
      0  edit-line# clip-y  move-cursor
1A158A4 	70 6F A0  1 
1A158A8 	24 41 A1  1 14 55 A1  1 
1A158B0 	CC 55 A1  1 
   then
   edit-line# clip-y vmove-cursor
1A158B4 	24 41 A1  1 
1A158B8 	14 55 A1  1 C4 54 A1  1 
   edit-line# is old-line#
1A158C0 	24 41 A1  1 B8 40 A0  1 
1A158C8 	A8 54 A1  1 
   -1 is ydamage
1A158CC 	58 41 A0  1 
1A158D0 	FF FF FF FF B8 40 A0  1 
1A158D8 	 4 42 A1  1 
;
1A158DC 	58 46 A0  1 

: transfer-damage  ( -- )
1A158E0 	74 72 61 6E 73 66 65 72 
1A158E8 	2D 64 61 6D 61 67 65 8F 
1A158F0 	44 58 A1  1 20 40 A0  1 
   \ Horizontal damage only applies to the current line, so when we
   \ move to a different line, we have to transfer the old line's
   \ horizontal damage to vertical damage.
   xdamage -1 <>  if				\ Old line is damaged
1A158F8 	F0 41 A1  1 58 41 A0  1 
1A15900 	FF FF FF FF 44 48 A0  1 
1A15908 	DC 41 A0  1 28  0  0  0 
      edit-line# ydamage umin  is ydamage	\ Record as vertical damage
1A15910 	24 41 A1  1  4 42 A1  1 
1A15918 	4C 4A A0  1 B8 40 A0  1 
1A15920 	 4 42 A1  1 
      -1 is xdamage				\ Cancel horizontal damage
1A15924 	58 41 A0  1 
1A15928 	FF FF FF FF B8 40 A0  1 
1A15930 	F0 41 A1  1 
   then
;
1A15934 	58 46 A0  1 
: open-window  ( -- )
1A15938 	6F 70 65 6E 2D 77 69 6E 
1A15940 	64 6F 77 8B F4 58 A1  1 
1A15948 	20 40 A0  1 
   0 #out !  0 #line !
1A1594C 	70 6F A0  1 
1A15950 	5C 6D A0  1 54 4D A0  1 
1A15958 	70 6F A0  1 70 6D A0  1 
1A15960 	54 4D A0  1 
   line-ends window-height window-width fill
1A15964 	EC 55 A1  1 
1A15968 	90 54 A1  1 C4 41 A1  1 
1A15970 	8C 4E A0  1 
   0 is ydamage
1A15974 	70 6F A0  1 
1A15978 	B8 40 A0  1  4 42 A1  1 
;
1A15980 	58 46 A0  1 

: close-window  ( -- )
1A15984 	 0  0  0 63 
1A15988 	6C 6F 73 65 2D 77 69 6E 
1A15990 	64 6F 77 8C 48 59 A1  1 
1A15998 	20 40 A0  1 
   window-height 1- vmove-cursor  cr  kill-screen
1A1599C 	90 54 A1  1 
1A159A0 	54 4B A0  1 C4 54 A1  1 
1A159A8 	80 6D A0  1 7C F6 A0  1 
   one-line-display
1A159B0 	B0 53 A1  1 
;
1A159B4 	58 46 A0  1 

: screen-display  ( -- )
1A159B8 	 0 73 63 72 65 65 6E 2D 
1A159C0 	64 69 73 70 6C 61 79 8E 
1A159C8 	98 59 A1  1 20 40 A0  1 
   ['] open-window     is open-display
1A159D0 	60 53 A0  1 48 59 A1  1 
1A159D8 	98 40 A0  1 F0 46 A1  1 
   ['] close-window    is close-display
1A159E0 	60 53 A0  1 98 59 A1  1 
1A159E8 	98 40 A0  1  C 47 A1  1 
   ['] (vredisplay)    is vredisplay
1A159F0 	60 53 A0  1 44 58 A1  1 
1A159F8 	98 40 A0  1 24 46 A1  1 
   ['] w-new-line-end  is new-line-end
1A15A00 	60 53 A0  1 10 56 A1  1 
1A15A08 	98 40 A0  1 20 42 A1  1 
   ['] transfer-damage is line-moved
1A15A10 	60 53 A0  1 F4 58 A1  1 
1A15A18 	98 40 A0  1 68 46 A1  1 
   ['] noop            is .line#
1A15A20 	60 53 A0  1 64 4F A0  1 
1A15A28 	98 40 A0  1 20 43 A1  1 
   ['] noop            is to-goal-column
1A15A30 	60 53 A0  1 64 4F A0  1 
1A15A38 	98 40 A0  1 88 51 A1  1 
   ['] noop            is scroll-down
1A15A40 	60 53 A0  1 64 4F A0  1 
1A15A48 	98 40 A0  1 50 47 A1  1 
   ['] vreframe        is recenter
1A15A50 	60 53 A0  1 44 55 A1  1 
1A15A58 	98 40 A0  1 90 53 A1  1 
;
1A15A60 	58 46 A0  1 
: (set-window)  ( column# line# #columns #lines -- )
1A15A64 	 0  0  0 28 
1A15A68 	73 65 74 2D 77 69 6E 64 
1A15A70 	6F 77 29 8C CC 59 A1  1 
1A15A78 	20 40 A0  1 
   1 max is window-height         ( column# line# #columns )
1A15A7C 	80 6F A0  1 
1A15A80 	9C 4A A0  1 B8 40 A0  1 
1A15A88 	90 54 A1  1 

   2 pick  +                      ( col# line#  max-col# )
1A15A8C 	90 6F A0  1 
1A15A90 	 C 4A A0  1  4 45 A0  1 
   display-width 1- min           ( col# line#  clipped-col# )
1A15A98 	64 40 A1  1 54 4B A0  1 
1A15AA0 	74 4A A0  1 
   2 pick  -                      ( col# line#  clipped-#cols )
1A15AA4 	90 6F A0  1 
1A15AA8 	 C 4A A0  1 18 45 A0  1 
   is window-width                ( col# line# )
1A15AB0 	B8 40 A0  1 C4 41 A1  1 

   at-xy                          ( )
1A15AB8 	40 F8 A0  1 

   screen-display
1A15ABC 	CC 59 A1  1 
;
1A15AC0 	58 46 A0  1 
defer set-window
1A15AC4 	 0 73 65 74 
1A15AC8 	2D 77 69 6E 64 6F 77 8A 
1A15AD0 	78 5A A1  1 5C 40 A0  1 
1A15AD8 	1C  4  0  0 
' (set-window) is set-window

headers
: no-screen  ( -- )  ['] 4drop is set-window  ;
1A15ADC 	 0  0 6E 6F 
1A15AE0 	2D 73 63 72 65 65 6E 89 
1A15AE8 	D4 5A A1  1 20 40 A0  1 
1A15AF0 	60 53 A0  1 38 53 A0  1 
1A15AF8 	98 40 A0  1 D4 5A A1  1 
1A15B00 	58 46 A0  1 

OpenFirmware/forth/lib/screened.fth_AL	1724 1A15B04 
vocset=5D8918 1A00440 1A15B04 
headers
forth definitions

vocabulary keys-forth
1A15B04 	 0 6B 65 79 
1A15B08 	73 2D 66 6F 72 74 68 8A 
1A15B10 	64 40 A1  1 E0 B6 A0  1 
1A15B18 	20  4  0  0 18 F3 A0  1 
1A15B20 	 0  0  0  0 
defer skey  ' key is skey  \ Perhaps override with an ekey-based word later
1A15B24 	 0  0  0 73 
1A15B28 	6B 65 79 84 14 5B A1  1 
1A15B30 	5C 40 A0  1 24  4  0  0 

hidden definitions

headerless
tuser keys  ' keys-forth keys token!
1A15B38 	 0  0  0 6B 65 79 73 84 
1A15B40 	EC 5A A1  1 48 40 A0  1 
1A15B48 	28  4  0  0 

d# 32 buffer: name-buf
1A15B4C 	 0  0  0 6E 
1A15B50 	61 6D 65 2D 62 75 66 88 
1A15B58 	44 5B A1  1 B4 A9 A0  1 
1A15B60 	2C  4  0  0 20  0  0  0 
1A15B68 	EC 55 A1  1 

: add-char-to-string  ( str char -- )
1A15B6C 	 0 61 64 64 
1A15B70 	2D 63 68 61 72 2D 74 6F 
1A15B78 	2D 73 74 72 69 6E 67 92 
1A15B80 	5C 5B A1  1 20 40 A0  1 
   over ( str char str )
1A15B88 	54 49 A0  1 
   count dup >r ( str char addr len )
1A15B8C 	BC 53 A0  1 
1A15B90 	40 49 A0  1 BC 45 A0  1 
   + c!  ( str )
1A15B98 	 4 45 A0  1 B8 4D A0  1 
   r> 1+ swap c!
1A15BA0 	D0 45 A0  1 30 4B A0  1 
1A15BA8 	68 49 A0  1 B8 4D A0  1 
;
1A15BB0 	58 46 A0  1 
: add-char-to-name  ( str char -- )
1A15BB4 	 0  0  0 61 
1A15BB8 	64 64 2D 63 68 61 72 2D 
1A15BC0 	74 6F 2D 6E 61 6D 65 90 
1A15BC8 	84 5B A1  1 20 40 A0  1 
   dup bl u<  if    ( str char )  \ control character so translate to ^ form
1A15BD0 	40 49 A0  1 28 70 A0  1 
1A15BD8 	A8 48 A0  1 DC 41 A0  1 
1A15BE0 	30  0  0  0 
      over ascii ^ add-char-to-string  ( str char )
1A15BE4 	54 49 A0  1 
1A15BE8 	58 41 A0  1 5E  0  0  0 
1A15BF0 	84 5B A1  1 
      ascii a 1- +  ( str char' )  add-char-to-string
1A15BF4 	58 41 A0  1 
1A15BF8 	61  0  0  0 54 4B A0  1 
1A15C00 	 4 45 A0  1 84 5B A1  1 
  else
1A15C08 	C8 41 A0  1 A4  0  0  0 
      \ Map the Delete key to the string "del"
      dup d# 127 =  if   drop  " del" rot $cat  exit  then
1A15C10 	40 49 A0  1 58 41 A0  1 
1A15C18 	7F  0  0  0 24 48 A0  1 
1A15C20 	DC 41 A0  1 20  0  0  0 
1A15C28 	30 49 A0  1 9C 53 A0  1 
1A15C30 	 3 64 65 6C  0  0  0  0 
1A15C38 	7C 49 A0  1 84 7E A0  1 
1A15C40 	40 46 A0  1 

      \ Map the Unicode Control Sequence Identifier to the string "ESC["
      dup h# 9b =  if   drop  " esc-[" rot $cat  exit  then
1A15C44 	40 49 A0  1 
1A15C48 	58 41 A0  1 9B  0  0  0 
1A15C50 	24 48 A0  1 DC 41 A0  1 
1A15C58 	20  0  0  0 30 49 A0  1 
1A15C60 	9C 53 A0  1  5 65 73 63 
1A15C68 	2D 5B  0  0 7C 49 A0  1 
1A15C70 	84 7E A0  1 40 46 A0  1 

      \ Map the out-of-band character into the string "ext"
      dup -1 =   if   drop  " ext" rot $cat  exit  then
1A15C78 	40 49 A0  1 58 41 A0  1 
1A15C80 	FF FF FF FF 24 48 A0  1 
1A15C88 	DC 41 A0  1 20  0  0  0 
1A15C90 	30 49 A0  1 9C 53 A0  1 
1A15C98 	 3 65 78 74  0  0  0  0 
1A15CA0 	7C 49 A0  1 84 7E A0  1 
1A15CA8 	40 46 A0  1 

      add-char-to-string
1A15CAC 	84 5B A1  1 
  then
;
1A15CB0 	58 46 A0  1 
defer not-found
1A15CB4 	 0  0 6E 6F 
1A15CB8 	74 2D 66 6F 75 6E 64 89 
1A15CC0 	CC 5B A1  1 5C 40 A0  1 
1A15CC8 	30  4  0  0 

nuser lastchar		\ most-recently-typed character
1A15CCC 	 0  0  0 6C 
1A15CD0 	61 73 74 63 68 61 72 88 
1A15CD8 	C4 5C A1  1 48 40 A0  1 
1A15CE0 	34  4  0  0 
nuser beforechar	\ next most-recently-typed character
1A15CE4 	 0 62 65 66 
1A15CE8 	6F 72 65 63 68 61 72 8A 
1A15CF0 	DC 5C A1  1 48 40 A0  1 
1A15CF8 	38  4  0  0 
: do-command  ( prefix$ -- )
1A15CFC 	 0 64 6F 2D 
1A15D00 	63 6F 6D 6D 61 6E 64 8A 
1A15D08 	F4 5C A1  1 20 40 A0  1 
   name-buf place
1A15D10 	5C 5B A1  1 F0 88 A0  1 
   name-buf lastchar @  add-char-to-name
1A15D18 	5C 5B A1  1 DC 5C A1  1 
1A15D20 	5C 4C A0  1 CC 5B A1  1 
   name-buf count  keys token@ search-wordlist  ( false | cfa true )
1A15D28 	5C 5B A1  1 BC 53 A0  1 
1A15D30 	44 5B A1  1  C 54 A0  1 
1A15D38 	38 BB A0  1 
   if  catch drop  else  not-found  then
1A15D3C 	DC 41 A0  1 
1A15D40 	14  0  0  0 14 7F A0  1 
1A15D48 	30 49 A0  1 C8 41 A0  1 
1A15D50 	 8  0  0  0 C4 5C A1  1 
;
1A15D58 	58 46 A0  1 

defer printable-char
1A15D5C 	 0 70 72 69 
1A15D60 	6E 74 61 62 6C 65 2D 63 
1A15D68 	68 61 72 8E  C 5D A1  1 
1A15D70 	5C 40 A0  1 3C  4  0  0 
nuser finished		\ is the line complete yet?
1A15D78 	 0  0  0 66 69 6E 69 73 
1A15D80 	68 65 64 88 70 5D A1  1 
1A15D88 	48 40 A0  1 40  4  0  0 

headers
: start-edit  ( bufadr buflen bufmax line# position display? -- )
1A15D90 	 0 73 74 61 72 74 2D 65 
1A15D98 	64 69 74 8A 88 5D A1  1 
1A15DA0 	20 40 A0  1 
   is display?   2>r                        ( adr len max r: line#,position )
1A15DA4 	B8 40 A0  1 
1A15DA8 	7C 40 A1  1 F8 45 A0  1 
   is bufmax  is buflen  is buf-start-adr   ( r: line#,position )
1A15DB0 	B8 40 A0  1 CC 4A A1  1 
1A15DB8 	B8 40 A0  1 B8 4A A1  1 
1A15DC0 	B8 40 A0  1 A4 4A A1  1 
   2r> buf-start-adr +  swap  set-line
1A15DC8 	10 46 A0  1 A4 4A A1  1 
1A15DD0 	 4 45 A0  1 68 49 A0  1 
1A15DD8 	F4 4C A1  1 
;
1A15DDC 	58 46 A0  1 
: finish-edit  ( -- length )  buflen  ;
1A15DE0 	66 69 6E 69 73 68 2D 65 
1A15DE8 	64 69 74 8B A0 5D A1  1 
1A15DF0 	20 40 A0  1 B8 4A A1  1 
1A15DF8 	58 46 A0  1 
headerless
: edit-command-loop  ( -- )
1A15DFC 	 0  0 65 64 
1A15E00 	69 74 2D 63 6F 6D 6D 61 
1A15E08 	6E 64 2D 6C 6F 6F 70 91 
1A15E10 	F0 5D A1  1 20 40 A0  1 
   open-display redisplay
1A15E18 	F0 46 A1  1 3C 46 A1  1 
   finished off
1A15E20 	88 5D A1  1 F8 4B A0  1 
   begin
      lastchar @ beforechar !
1A15E28 	DC 5C A1  1 5C 4C A0  1 
1A15E30 	F4 5C A1  1 54 4D A0  1 
      skey lastchar !
1A15E38 	30 5B A1  1 DC 5C A1  1 
1A15E40 	54 4D A0  1 
      lastchar @
1A15E44 	DC 5C A1  1 
1A15E48 	5C 4C A0  1 
      dup  bl     h# 7e  between
1A15E4C 	40 49 A0  1 
1A15E50 	28 70 A0  1 58 41 A0  1 
1A15E58 	7E  0  0  0 D8 70 A0  1 
      swap h# a0  h# fe  between  or
1A15E60 	68 49 A0  1 58 41 A0  1 
1A15E68 	A0  0  0  0 58 41 A0  1 
1A15E70 	FE  0  0  0 D8 70 A0  1 
1A15E78 	70 44 A0  1 
      if  lastchar @ printable-char  else  " "  do-command  then
1A15E7C 	DC 41 A0  1 
1A15E80 	18  0  0  0 DC 5C A1  1 
1A15E88 	5C 4C A0  1 70 5D A1  1 
1A15E90 	C8 41 A0  1 10  0  0  0 
1A15E98 	9C 53 A0  1  0  0  0  0 
1A15EA0 	 C 5D A1  1 
      redisplay
1A15EA4 	3C 46 A1  1 
   finished @  until
1A15EA8 	88 5D A1  1 5C 4C A0  1 
1A15EB0 	DC 41 A0  1 74 FF FF FF 
   close-display
1A15EB8 	 C 47 A1  1 
;
1A15EBC 	58 46 A0  1 
headerless

: edit-buffer  (s bufadr buflen bufmax line# position -- newlen )
1A15EC0 	65 64 69 74 2D 62 75 66 
1A15EC8 	66 65 72 8B 14 5E A1  1 
1A15ED0 	20 40 A0  1 
[ifdef] set-window
   accepting?  0=  if
1A15ED4 	94 40 A1  1 
1A15ED8 	24 47 A0  1 DC 41 A0  1 
1A15EE0 	18  0  0  0 
      0 0  display-width display-height  set-window
1A15EE4 	70 6F A0  1 
1A15EE8 	70 6F A0  1 64 40 A1  1 
1A15EF0 	5C 54 A1  1 D4 5A A1  1 
   then
[then]

   true start-edit
1A15EF8 	 4 70 A0  1 A0 5D A1  1 

   edit-command-loop
1A15F00 	14 5E A1  1 

   finish-edit
1A15F04 	F0 5D A1  1 
;
1A15F08 	58 46 A0  1 
headers
: edit-file  (s addr len maxlen -- newlen )
1A15F0C 	 0  0 65 64 
1A15F10 	69 74 2D 66 69 6C 65 89 
1A15F18 	D0 5E A1  1 20 40 A0  1 
   0 0 edit-buffer
1A15F20 	70 6F A0  1 70 6F A0  1 
1A15F28 	D0 5E A1  1 
;
1A15F2C 	58 46 A0  1 
also forth definitions
: edit-line  ( addr len maxlen -- newlen )
1A15F30 	 0  0 65 64 69 74 2D 6C 
1A15F38 	69 6E 65 89 30 5B A1  1 
1A15F40 	20 40 A0  1 
   true is accepting?		\ Edit on a single line
1A15F44 	 4 70 A0  1 
1A15F48 	B8 40 A0  1 94 40 A1  1 
   0 0  true start-edit  end-of-line  edit-command-loop  finish-edit  ( len' )
1A15F50 	70 6F A0  1 70 6F A0  1 
1A15F58 	 4 70 A0  1 A0 5D A1  1 
1A15F60 	2C 48 A1  1 14 5E A1  1 
1A15F68 	F0 5D A1  1 
   false is accepting?
1A15F6C 	18 70 A0  1 
1A15F70 	B8 40 A0  1 94 40 A1  1 
;
1A15F78 	58 46 A0  1 
previous definitions

headerless

d# 512  /tib 2* max  value hbufmax
1A15F7C 	68 62 75 66 
1A15F80 	6D 61 78 87 1C 5F A1  1 
1A15F88 	50 40 A0  1 44  4  0  0 
hbufmax buffer: hbuf-adr
1A15F90 	 0  0  0 68 62 75 66 2D 
1A15F98 	61 64 72 88 88 5F A1  1 
1A15FA0 	B4 A9 A0  1 48  4  0  0 
1A15FA8 	 0  8  0  0 5C 5B A1  1 
0 value hbuflen
1A15FB0 	68 62 75 66 6C 65 6E 87 
1A15FB8 	A0 5F A1  1 50 40 A0  1 
1A15FC0 	4C  4  0  0 
: ensure-line-end  ( -- )
1A15FC4 	65 6E 73 75 
1A15FC8 	72 65 2D 6C 69 6E 65 2D 
1A15FD0 	65 6E 64 8F BC 5F A1  1 
1A15FD8 	20 40 A0  1 
   \ Put a newline at the end of the last line if necessary
   hbuflen  if
1A15FDC 	BC 5F A1  1 
1A15FE0 	DC 41 A0  1 4C  0  0  0 
      hbuf-adr hbuflen +  1-  c@  newline  <> if
1A15FE8 	A0 5F A1  1 BC 5F A1  1 
1A15FF0 	 4 45 A0  1 54 4B A0  1 
1A15FF8 	C4 4C A0  1 A8 71 A0  1 
1A16000 	44 48 A0  1 DC 41 A0  1 
1A16008 	28  0  0  0 
         newline  hbuf-adr hbuflen +  c!
1A1600C 	A8 71 A0  1 
1A16010 	A0 5F A1  1 BC 5F A1  1 
1A16018 	 4 45 A0  1 B8 4D A0  1 
	 hbuflen 1+  is hbuflen
1A16020 	BC 5F A1  1 30 4B A0  1 
1A16028 	B8 40 A0  1 BC 5F A1  1 
      then
   then
;
1A16030 	58 46 A0  1 
: make-room  ( needed -- )
1A16034 	 0  0 6D 61 
1A16038 	6B 65 2D 72 6F 6F 6D 89 
1A16040 	D8 5F A1  1 20 40 A0  1 
   1+  hbufmax  hbuflen -  -  ( shortfall )
1A16048 	30 4B A0  1 88 5F A1  1 
1A16050 	BC 5F A1  1 18 45 A0  1 
1A16058 	18 45 A0  1 
   dup  0>  if                ( shortfall )   \ Too little room at the end
1A1605C 	40 49 A0  1 
1A16060 	A4 47 A0  1 DC 41 A0  1 
1A16068 	44  0  0  0 
      dup hbuf-adr +  hbuf-adr  hbuflen 3 pick -  move  ( shortfall )
1A1606C 	40 49 A0  1 
1A16070 	A0 5F A1  1  4 45 A0  1 
1A16078 	A0 5F A1  1 BC 5F A1  1 
1A16080 	A0 6F A0  1  C 4A A0  1 
1A16088 	18 45 A0  1 F4 4A A0  1 
      hbuflen swap - is hbuflen
1A16090 	BC 5F A1  1 68 49 A0  1 
1A16098 	18 45 A0  1 B8 40 A0  1 
1A160A0 	BC 5F A1  1 
   else
1A160A4 	C8 41 A0  1 
1A160A8 	 8  0  0  0 
      drop
1A160AC 	30 49 A0  1 
   then
\      hbuf-adr over +  hbufmax  rot -    ( adr remaining )
\      hbufmax -rot  bounds  ?do          ( next-line-adr )
\         i c@  newline =  if
\	    drop i 1+  hbuf-adr - leave
\         then
\      loop                               ( shortfall next-line-adr )
\      dup hbuf-adr
   ensure-line-end
1A160B0 	D8 5F A1  1 
;
1A160B4 	58 46 A0  1 
: open-history  ( needed -- buf len maxlen line# position )
1A160B8 	 0  0  0 6F 70 65 6E 2D 
1A160C0 	68 69 73 74 6F 72 79 8C 
1A160C8 	44 60 A1  1 20 40 A0  1 
   make-room   ( )
1A160D0 	44 60 A1  1 
   hbuf-adr  hbuflen  hbufmax  0  hbuflen
1A160D4 	A0 5F A1  1 
1A160D8 	BC 5F A1  1 88 5F A1  1 
1A160E0 	70 6F A0  1 BC 5F A1  1 
;
1A160E8 	58 46 A0  1 
: xaccept  (s adr len -- actual )
1A160EC 	78 61 63 63 
1A160F0 	65 70 74 87 CC 60 A1  1 
1A160F8 	20 40 A0  1 
   tuck dup hbufmax 1-  >  if    ( len adr len )
1A160FC 	E8 46 A0  1 
1A16100 	40 49 A0  1 88 5F A1  1 
1A16108 	54 4B A0  1  4 48 A0  1 
1A16110 	DC 41 A0  1 1C  0  0  0 
      0 swap  0 0                ( len adr 0 len 0 0 )
1A16118 	70 6F A0  1 68 49 A0  1 
1A16120 	70 6F A0  1 70 6F A0  1 
   else                          ( adr len )
1A16128 	C8 41 A0  1  8  0  0  0 
      open-history               ( len adr  hbuf hlen hmax line# position )
1A16130 	CC 60 A1  1 
   then

   true is accepting?
1A16134 	 4 70 A0  1 
1A16138 	B8 40 A0  1 94 40 A1  1 
   edit-buffer  is hbuflen       ( len adr )
1A16140 	D0 5E A1  1 B8 40 A0  1 
1A16148 	BC 5F A1  1 
   false is accepting?
1A1614C 	18 70 A0  1 
1A16150 	B8 40 A0  1 94 40 A1  1 

   swap linelen min  tuck        ( len' adr len' )
1A16158 	68 49 A0  1 F8 40 A1  1 
1A16160 	74 4A A0  1 E8 46 A0  1 
   line-start-adr  -rot move     ( len' )
1A16168 	E4 40 A1  1 94 49 A0  1 
1A16170 	F4 4A A0  1 
;
1A16174 	58 46 A0  1 
: new-line-or-done  ( -- )
1A16178 	 0  0  0 6E 65 77 2D 6C 
1A16180 	69 6E 65 2D 6F 72 2D 64 
1A16188 	6F 6E 65 90 F8 60 A1  1 
1A16190 	20 40 A0  1 
   accepting?  if
1A16194 	94 40 A1  1 
1A16198 	DC 41 A0  1 30  0  0  0 
      finished on
1A161A0 	88 5D A1  1 E0 4B A0  1 
      edit-line# -1 < if  ?copyline  then
1A161A8 	24 41 A1  1 58 41 A0  1 
1A161B0 	FF FF FF FF E4 47 A0  1 
1A161B8 	DC 41 A0  1  8  0  0  0 
1A161C0 	6C 4E A1  1 
   else
1A161C4 	C8 41 A0  1 
1A161C8 	 8  0  0  0 
      new-line
1A161CC 	D0 52 A1  1 
   then
;
1A161D0 	58 46 A0  1 

: self-insert  ( -- )  lastchar @ insert-character  ;
1A161D4 	73 65 6C 66 
1A161D8 	2D 69 6E 73 65 72 74 8B 
1A161E0 	90 61 A1  1 20 40 A0  1 
1A161E8 	DC 5C A1  1 5C 4C A0  1 
1A161F0 	C0 4F A1  1 58 46 A0  1 

headers
keys-forth also definitions

: ^f  forward-character  ;
1A161F8 	 0 5E 66 82  0  0 A0  1 
1A16200 	20 40 A0  1 E4 47 A1  1 
1A16208 	58 46 A0  1 
: ^b  backward-character  ;
1A1620C 	 0 5E 62 82 
1A16210 	 0 62 A1  1 20 40 A0  1 
1A16218 	 C 48 A1  1 58 46 A0  1 
: ^a  beginning-of-line  ;
1A16220 	 0 5E 61 82 14 62 A1  1 
1A16228 	20 40 A0  1 54 48 A1  1 
1A16230 	58 46 A0  1 
: ^c  finished on  ;
1A16234 	 0 5E 63 82 
1A16238 	28 62 A1  1 20 40 A0  1 
1A16240 	88 5D A1  1 E0 4B A0  1 
1A16248 	58 46 A0  1 
: ^e  end-of-line  ;
1A1624C 	 0 5E 65 82 
1A16250 	3C 62 A1  1 20 40 A0  1 
1A16258 	2C 48 A1  1 58 46 A0  1 
: ^d  erase-next-character  ;
1A16260 	 0 5E 64 82 54 62 A1  1 
1A16268 	20 40 A0  1 24 50 A1  1 
1A16270 	58 46 A0  1 
: ^h  erase-previous-character  ;
1A16274 	 0 5E 68 82 
1A16278 	68 62 A1  1 20 40 A0  1 
1A16280 	5C 50 A1  1 58 46 A0  1 
: ^i  bl insert-character  ;
1A16288 	 0 5E 69 82 7C 62 A1  1 
1A16290 	20 40 A0  1 28 70 A0  1 
1A16298 	C0 4F A1  1 58 46 A0  1 
: ^j  new-line-or-done  ;
1A162A0 	 0 5E 6A 82 90 62 A1  1 
1A162A8 	20 40 A0  1 90 61 A1  1 
1A162B0 	58 46 A0  1 
: ^k  kill-to-end-of-line  ;
1A162B4 	 0 5E 6B 82 
1A162B8 	A8 62 A1  1 20 40 A0  1 
1A162C0 	94 50 A1  1 58 46 A0  1 
: ^l  recenter  ;
1A162C8 	 0 5E 6C 82 BC 62 A1  1 
1A162D0 	20 40 A0  1 90 53 A1  1 
1A162D8 	58 46 A0  1 
: ^m  new-line-or-done  ;
1A162DC 	 0 5E 6D 82 
1A162E0 	D0 62 A1  1 20 40 A0  1 
1A162E8 	90 61 A1  1 58 46 A0  1 
: ^n  next-line  ;
1A162F0 	 0 5E 6E 82 E4 62 A1  1 
1A162F8 	20 40 A0  1 BC 51 A1  1 
1A16300 	58 46 A0  1 
: ^o  split-line  ;
1A16304 	 0 5E 6F 82 
1A16308 	F8 62 A1  1 20 40 A0  1 
1A16310 	70 52 A1  1 58 46 A0  1 
: ^p  previous-line  ;
1A16318 	 0 5E 70 82  C 63 A1  1 
1A16320 	20 40 A0  1 20 52 A1  1 
1A16328 	58 46 A0  1 
: ^q  quote-next-character  ;
1A1632C 	 0 5E 71 82 
1A16330 	20 63 A1  1 20 40 A0  1 
1A16338 	F8 4F A1  1 58 46 A0  1 
: ^x  finished on  ;		\ XXX for testing on systems where ^C is magic
1A16340 	 0 5E 78 82 34 63 A1  1 
1A16348 	20 40 A0  1 88 5D A1  1 
1A16350 	E0 4B A0  1 58 46 A0  1 
: ^y  yank  ;
1A16358 	 0 5E 79 82 48 63 A1  1 
1A16360 	20 40 A0  1 6C 53 A1  1 
1A16368 	58 46 A0  1 

: ^{  key lastchar !  " esc-" do-command  ;
1A1636C 	 0 5E 7B 82 
1A16370 	60 63 A1  1 20 40 A0  1 
1A16378 	50 6C A0  1 DC 5C A1  1 
1A16380 	54 4D A0  1 9C 53 A0  1 
1A16388 	 4 65 73 63 2D  0  0  0 
1A16390 	 C 5D A1  1 58 46 A0  1 

: esc-v  only forth also definitions  beep beep beep  ;  \ Reset search order
1A16398 	 0  0 65 73 63 2D 76 85 
1A163A0 	74 63 A1  1 20 40 A0  1 
1A163A8 	88 C3 A0  1  8 C5 A0  1 
1A163B0 	C8 C1 A0  1 2C C4 A0  1 
1A163B8 	A8 40 A1  1 A8 40 A1  1 
1A163C0 	A8 40 A1  1 58 46 A0  1 
: esc-h  erase-previous-word  ;
1A163C8 	 0  0 65 73 63 2D 68 85 
1A163D0 	A4 63 A1  1 20 40 A0  1 
1A163D8 	2C 51 A1  1 58 46 A0  1 
: esc-d  erase-next-word  ;
1A163E0 	 0  0 65 73 63 2D 64 85 
1A163E8 	D4 63 A1  1 20 40 A0  1 
1A163F0 	FC 50 A1  1 58 46 A0  1 
: esc-f  forward-word  ;
1A163F8 	 0  0 65 73 63 2D 66 85 
1A16400 	EC 63 A1  1 20 40 A0  1 
1A16408 	4C 4A A1  1 58 46 A0  1 
: esc-b  backward-word  ;
1A16410 	 0  0 65 73 63 2D 62 85 
1A16418 	 4 64 A1  1 20 40 A0  1 
1A16420 	78 4A A1  1 58 46 A0  1 
: esc-^h  erase-previous-word  ;
1A16428 	 0 65 73 63 2D 5E 68 86 
1A16430 	1C 64 A1  1 20 40 A0  1 
1A16438 	2C 51 A1  1 58 46 A0  1 
: esc-^d  erase-next-word  ;
1A16440 	 0 65 73 63 2D 5E 64 86 
1A16448 	34 64 A1  1 20 40 A0  1 
1A16450 	FC 50 A1  1 58 46 A0  1 
: esc-^f  forward-word  ;
1A16458 	 0 65 73 63 2D 5E 66 86 
1A16460 	4C 64 A1  1 20 40 A0  1 
1A16468 	4C 4A A1  1 58 46 A0  1 
: esc-^b  backward-word  ;
1A16470 	 0 65 73 63 2D 5E 62 86 
1A16478 	64 64 A1  1 20 40 A0  1 
1A16480 	78 4A A1  1 58 46 A0  1 
: esc-del  erase-next-word  ;
1A16488 	65 73 63 2D 64 65 6C 87 
1A16490 	7C 64 A1  1 20 40 A0  1 
1A16498 	FC 50 A1  1 58 46 A0  1 

\ ANSI cursor keys
: esc-[  key lastchar !  " esc-[" do-command  ;
1A164A0 	 0  0 65 73 63 2D 5B 85 
1A164A8 	94 64 A1  1 20 40 A0  1 
1A164B0 	50 6C A0  1 DC 5C A1  1 
1A164B8 	54 4D A0  1 9C 53 A0  1 
1A164C0 	 5 65 73 63 2D 5B  0  0 
1A164C8 	 C 5D A1  1 58 46 A0  1 
: esc-o  key lastchar !  " esc-[" do-command  ;  \ TeraTerm uses esc-o as the arrow prefix
1A164D0 	 0  0 65 73 63 2D 6F 85 
1A164D8 	AC 64 A1  1 20 40 A0  1 
1A164E0 	50 6C A0  1 DC 5C A1  1 
1A164E8 	54 4D A0  1 9C 53 A0  1 
1A164F0 	 5 65 73 63 2D 5B  0  0 
1A164F8 	 C 5D A1  1 58 46 A0  1 
: esc-[A previous-line  ;
1A16500 	 0 65 73 63 2D 5B 61 86 
1A16508 	DC 64 A1  1 20 40 A0  1 
1A16510 	20 52 A1  1 58 46 A0  1 
: esc-[B next-line  ;
1A16518 	 0 65 73 63 2D 5B 62 86 
1A16520 	 C 65 A1  1 20 40 A0  1 
1A16528 	BC 51 A1  1 58 46 A0  1 
: esc-[C forward-character  ;
1A16530 	 0 65 73 63 2D 5B 63 86 
1A16538 	24 65 A1  1 20 40 A0  1 
1A16540 	E4 47 A1  1 58 46 A0  1 
: esc-[D backward-character  ;
1A16548 	 0 65 73 63 2D 5B 64 86 
1A16550 	3C 65 A1  1 20 40 A0  1 
1A16558 	 C 48 A1  1 58 46 A0  1 
: esc-[P erase-previous-character  ;
1A16560 	 0 65 73 63 2D 5B 70 86 
1A16568 	54 65 A1  1 20 40 A0  1 
1A16570 	5C 50 A1  1 58 46 A0  1 

hidden definitions
headerless
: emacs-edit
1A16578 	 0 65 6D 61 63 73 2D 65 
1A16580 	64 69 74 8A E4 61 A1  1 
1A16588 	20 40 A0  1 
   ['] beep             is  not-found
1A1658C 	60 53 A0  1 
1A16590 	A8 40 A1  1 98 40 A0  1 
1A16598 	C4 5C A1  1 
   ['] insert-character is  printable-char
1A1659C 	60 53 A0  1 
1A165A0 	C0 4F A1  1 98 40 A0  1 
1A165A8 	70 5D A1  1 
   ['] xaccept          is  accept
1A165AC 	60 53 A0  1 
1A165B0 	F8 60 A1  1 98 40 A0  1 
1A165B8 	D8 6C A0  1 
;
1A165BC 	58 46 A0  1 
emacs-edit

headers
forth definitions
: init  ( -- )  init  emacs-edit  ;
1A165C0 	 0  0  0 69 6E 69 74 84 
1A165C8 	40 5F A1  1 20 40 A0  1 
1A165D0 	40 E9 A0  1 88 65 A1  1 
1A165D8 	58 46 A0  1 

OpenFirmware/forth/lib/editcmd.fth_AL	2776 1A165DC 
\ To make the line editor handle ^U and ^W just like Unix normally does

only forth hidden also forth also keys-forth definitions

: ^u beginning-of-line kill-to-end-of-line ;
1A165DC 	 0 5E 75 82 
1A165E0 	6C 65 A1  1 20 40 A0  1 
1A165E8 	54 48 A1  1 94 50 A1  1 
1A165F0 	58 46 A0  1 
: ^w erase-previous-word ;
1A165F4 	 0 5E 77 82 
1A165F8 	E4 65 A1  1 20 40 A0  1 
1A16600 	2C 51 A1  1 58 46 A0  1 
: ^r retype-line ;
1A16608 	 0 5E 72 82 FC 65 A1  1 
1A16610 	20 40 A0  1 74 48 A1  1 
1A16618 	58 46 A0  1 
: del erase-previous-character ;
1A1661C 	64 65 6C 83 
1A16620 	10 66 A1  1 20 40 A0  1 
1A16628 	5C 50 A1  1 58 46 A0  1 

only forth also definitions

OpenFirmware/forth/lib/unixedit.fth_AL	84 1A16630 
vocset=5D8938 1A00470 1A16630 
\ Command completion package a la TENEX.

headerless

decimal
only forth also definitions
vocabulary command-completion
1A16630 	 0 63 6F 6D 6D 61 6E 64 
1A16638 	2D 63 6F 6D 70 6C 65 74 
1A16640 	69 6F 6E 92 CC 65 A1  1 
1A16648 	E0 B6 A0  1 50  4  0  0 
1A16650 	14 5B A1  1  0  0  0  0 
only forth also hidden also command-completion definitions

\ Interfaces to the line editing routines
defer find-end ( -- )        \ Move the cursor to the end of the word
1A16658 	 0  0  0 66 69 6E 64 2D 
1A16660 	65 6E 64 88  0  0 A0  1 
1A16668 	5C 40 A0  1 54  4  0  0 
defer cinsert  ( char -- )   \ Insert a character into the line
1A16670 	63 69 6E 73 65 72 74 87 
1A16678 	68 66 A1  1 5C 40 A0  1 
1A16680 	58  4  0  0 
defer cerase   ( -- )        \ Delete the character before the cursor
1A16684 	 0 63 65 72 
1A16688 	61 73 65 86 7C 66 A1  1 
1A16690 	5C 40 A0  1 5C  4  0  0 

\ Some variables are hijacked from the line editing code and used here:
\ line-start-adr #before

\ Index of char at the beginning of the latest word in the input buffer
variable start-of-word
1A16698 	 0  0 73 74 61 72 74 2D 
1A166A0 	6F 66 2D 77 6F 72 64 8D 
1A166A8 	90 66 A1  1 48 40 A0  1 
1A166B0 	60  4  0  0 

20 constant #candidates-max
1A166B4 	23 63 61 6E 
1A166B8 	64 69 64 61 74 65 73 2D 
1A166C0 	6D 61 78 8F AC 66 A1  1 
1A166C8 	68 40 A0  1 14  0  0  0 
variable #candidates   0 #candidates !
1A166D0 	23 63 61 6E 64 69 64 61 
1A166D8 	74 65 73 8B C8 66 A1  1 
1A166E0 	48 40 A0  1 64  4  0  0 
#candidates-max /n*  buffer: candidates
1A166E8 	 0 63 61 6E 64 69 64 61 
1A166F0 	74 65 73 8A E0 66 A1  1 
1A166F8 	B4 A9 A0  1 68  4  0  0 
1A16700 	50  0  0  0 A0 5F A1  1 
variable overflow
1A16708 	 0  0  0 6F 76 65 72 66 
1A16710 	6C 6F 77 88 F8 66 A1  1 
1A16718 	48 40 A0  1 6C  4  0  0 

: word-to-string  ( -- str )
1A16720 	 0 77 6F 72 64 2D 74 6F 
1A16728 	2D 73 74 72 69 6E 67 8E 
1A16730 	18 67 A1  1 20 40 A0  1 
   line-start-adr  start-of-word @  +  ( addr of start of word )
1A16738 	E4 40 A1  1 AC 66 A1  1 
1A16740 	5C 4C A0  1  4 45 A0  1 
   #before         start-of-word @  -  ( start-addr len )
1A16748 	 C 41 A1  1 AC 66 A1  1 
1A16750 	5C 4C A0  1 18 45 A0  1 
   'word  place
1A16758 	B4 C8 A0  1 F0 88 A0  1 
   'word
1A16760 	B4 C8 A0  1 
;
1A16764 	58 46 A0  1 

: collect-string  ( -- str )
1A16768 	 0 63 6F 6C 6C 65 63 74 
1A16770 	2D 73 74 72 69 6E 67 8E 
1A16778 	34 67 A1  1 20 40 A0  1 
   \ Finds start of this word and the current length of the word and
   \ leaves the address of a packed string which contains that word
   find-end
1A16780 	68 66 A1  1 
   #before    start-of-word !
1A16784 	 C 41 A1  1 
1A16788 	AC 66 A1  1 54 4D A0  1 
   #before  if
1A16790 	 C 41 A1  1 DC 41 A0  1 
1A16798 	5C  0  0  0 
       line-start-adr  #before  1-  bounds  ( bufend bufstart )
1A1679C 	E4 40 A1  1 
1A167A0 	 C 41 A1  1 54 4B A0  1 
1A167A8 	F0 6D A0  1 
       swap  ( bufstart bufend )  do    \ Loop runs backwards over buffer
1A167AC 	68 49 A0  1 
1A167B0 	88 42 A0  1 40  0  0  0 
          i c@  bl =  if  leave  then
1A167B8 	B4 42 A0  1 C4 4C A0  1 
1A167C0 	28 70 A0  1 24 48 A0  1 
1A167C8 	DC 41 A0  1  8  0  0  0 
1A167D0 	18 43 A0  1 
          -1 start-of-word +!
1A167D4 	58 41 A0  1 
1A167D8 	FF FF FF FF AC 66 A1  1 
1A167E0 	 C 4C A0  1 
       -1 +loop
1A167E4 	58 41 A0  1 
1A167E8 	FF FF FF FF 1C 42 A0  1 
1A167F0 	C8 FF FF FF 
   then
   word-to-string  ( str )
1A167F4 	34 67 A1  1 
;
1A167F8 	58 46 A0  1 

: substring?  ( pstr anf -- f )
1A167FC 	 0 73 75 62 
1A16800 	73 74 72 69 6E 67 3F 8A 
1A16808 	7C 67 A1  1 20 40 A0  1 

   name>string  rot count 2swap  ( pstr-adr,len name-adr,len )
1A16810 	58 74 A0  1 7C 49 A0  1 
1A16818 	BC 53 A0  1 F4 49 A0  1 

   \ It's not a substring if the string is longer than the name
   2 pick  <  if  2drop drop false exit  then  ( pstr-adr pstr-len name-adr )
1A16820 	90 6F A0  1  C 4A A0  1 
1A16828 	E4 47 A0  1 DC 41 A0  1 
1A16830 	14  0  0  0 AC 49 A0  1 
1A16838 	30 49 A0  1 18 70 A0  1 
1A16840 	40 46 A0  1 

   true swap 2swap   ( true name-adr pstr-adr pstr-len )
1A16844 	 4 70 A0  1 
1A16848 	68 49 A0  1 F4 49 A0  1 
   bounds  ?do       ( flag name-adr )
1A16850 	F0 6D A0  1 50 42 A0  1 
1A16858 	3C  0  0  0 
      dup c@  i c@ <>  if  swap 0= swap  leave   then  ( flag name-adr )
1A1685C 	40 49 A0  1 
1A16860 	C4 4C A0  1 B4 42 A0  1 
1A16868 	C4 4C A0  1 44 48 A0  1 
1A16870 	DC 41 A0  1 14  0  0  0 
1A16878 	68 49 A0  1 24 47 A0  1 
1A16880 	68 49 A0  1 18 43 A0  1 
      1+             ( flag name-adr' )
1A16888 	30 4B A0  1 
   loop              ( flag name-adr'' )
1A1688C 	F8 41 A0  1 
1A16890 	CC FF FF FF 
   drop
1A16894 	30 49 A0  1 
;
1A16898 	58 46 A0  1 

: new-candidate  ( anf -- )
1A1689C 	 0  0 6E 65 
1A168A0 	77 2D 63 61 6E 64 69 64 
1A168A8 	61 74 65 8D  C 68 A1  1 
1A168B0 	20 40 A0  1 
   #candidates @  #candidates-max >=  if  drop overflow on  exit  then
1A168B4 	E0 66 A1  1 
1A168B8 	5C 4C A0  1 C8 66 A1  1 
1A168C0 	EC 48 A0  1 DC 41 A0  1 
1A168C8 	14  0  0  0 30 49 A0  1 
1A168D0 	18 67 A1  1 E0 4B A0  1 
1A168D8 	40 46 A0  1 
   candidates #candidates @ na+   !   (  )
1A168DC 	F8 66 A1  1 
1A168E0 	E0 66 A1  1 5C 4C A0  1 
1A168E8 	48 50 A0  1 54 4D A0  1 
   1 #candidates +!
1A168F0 	80 6F A0  1 E0 66 A1  1 
1A168F8 	 C 4C A0  1 
;
1A168FC 	58 46 A0  1 

: find-candidates-in-voc  ( str voc -- str )
1A16900 	 0 66 69 6E 64 2D 63 61 
1A16908 	6E 64 69 64 61 74 65 73 
1A16910 	2D 69 6E 2D 76 6F 63 96 
1A16918 	B0 68 A1  1 20 40 A0  1 
   follow
1A16920 	38 BC A0  1 
   begin  another?  while
1A16924 	68 BC A0  1 
1A16928 	DC 41 A0  1 2C  0  0  0 
      2dup substring?  if  new-candidate  else  drop  then
1A16930 	C0 49 A0  1  C 68 A1  1 
1A16938 	DC 41 A0  1 10  0  0  0 
1A16940 	B0 68 A1  1 C8 41 A0  1 
1A16948 	 8  0  0  0 30 49 A0  1 
   repeat
1A16950 	C8 41 A0  1 D0 FF FF FF 
   ( str )
;
1A16958 	58 46 A0  1 

: find-candidates  ( str -- )
1A1695C 	66 69 6E 64 
1A16960 	2D 63 61 6E 64 69 64 61 
1A16968 	74 65 73 8F 1C 69 A1  1 
1A16970 	20 40 A0  1 
   #candidates off  overflow off
1A16974 	E0 66 A1  1 
1A16978 	F8 4B A0  1 18 67 A1  1 
1A16980 	F8 4B A0  1 
   prior off        ( str )
1A16984 	54 C0 A0  1 
1A16988 	F8 4B A0  1 
   dup c@ 0=  if  drop  exit  then     \ Don't bother with null search strings
1A1698C 	40 49 A0  1 
1A16990 	C4 4C A0  1 24 47 A0  1 
1A16998 	DC 41 A0  1  C  0  0  0 
1A169A0 	30 49 A0  1 40 46 A0  1 
   \ Maybe it would be better to search all the vocabularies in the system?
   context  #vocs /link *  bounds  do
1A169A8 	DC A3 A0  1 C8 A3 A0  1 
1A169B0 	78 73 A0  1 1C 5F A0  1 
1A169B8 	F0 6D A0  1 88 42 A0  1 
1A169C0 	54  0  0  0 
      i another-link?  if                ( str voc )
1A169C4 	B4 42 A0  1 
1A169C8 	90 59 A0  1 DC 41 A0  1 
1A169D0 	38  0  0  0 
         dup prior @ over prior !  = if  ( str voc )
1A169D4 	40 49 A0  1 
1A169D8 	54 C0 A0  1 5C 4C A0  1 
1A169E0 	54 49 A0  1 54 C0 A0  1 
1A169E8 	54 4D A0  1 24 48 A0  1 
1A169F0 	DC 41 A0  1 10  0  0  0 
            drop                         ( str )
1A169F8 	30 49 A0  1 
         else
1A169FC 	C8 41 A0  1 
1A16A00 	 8  0  0  0 
	    find-candidates-in-voc       ( str )
1A16A04 	1C 69 A1  1 
         then
      then                               ( str )
   /link +loop
1A16A08 	78 73 A0  1 1C 42 A0  1 
1A16A10 	B4 FF FF FF 
   drop
1A16A14 	30 49 A0  1 
;
1A16A18 	58 46 A0  1 
\ True if "char" is different from the "char#"-th character in name
: cclash?  ( char# char anf -- char# char flag )
1A16A1C 	63 63 6C 61 
1A16A20 	73 68 3F 87 70 69 A1  1 
1A16A28 	20 40 A0  1 
   name>string        ( char# char str-adr count )
1A16A2C 	58 74 A0  1 
   3 pick <=  if      ( char# char str-adr )
1A16A30 	A0 6F A0  1  C 4A A0  1 
1A16A38 	 C 49 A0  1 DC 41 A0  1 
1A16A40 	14  0  0  0 
      drop true       \ str too short is a clash
1A16A44 	30 49 A0  1 
1A16A48 	 4 70 A0  1 
   else               ( char# char str-adr )
1A16A4C 	C8 41 A0  1 
1A16A50 	1C  0  0  0 
      2 pick +  c@ over <>
1A16A54 	90 6F A0  1 
1A16A58 	 C 4A A0  1  4 45 A0  1 
1A16A60 	C4 4C A0  1 54 49 A0  1 
1A16A68 	44 48 A0  1 
   then
;
1A16A6C 	58 46 A0  1 

\ If all the candidate words have the same character in the "char#"-th
\ position, leave that character and true, otherwise just leave false.
: candidates-agree?  ( char# -- char true | false )
1A16A70 	 0  0 63 61 6E 64 69 64 
1A16A78 	61 74 65 73 2D 61 67 72 
1A16A80 	65 65 3F 91 28 6A A1  1 
1A16A88 	20 40 A0  1 

\ if the test string is the same length as the first candidate,
\ then the first candidate has no char at position char#, so there
\ can be no agreement.  Since the test string is a substring of all
\ candidates, the > condition should not happen

   candidates @  name>string               ( char# name-adr name-len )
1A16A8C 	F8 66 A1  1 
1A16A90 	5C 4C A0  1 58 74 A0  1 
   2 pick =  if  2drop false  exit  then   ( char# name-adr )
1A16A98 	90 6F A0  1  C 4A A0  1 
1A16AA0 	24 48 A0  1 DC 41 A0  1 
1A16AA8 	10  0  0  0 AC 49 A0  1 
1A16AB0 	18 70 A0  1 40 46 A0  1 
   over + c@                               ( char# char )
1A16AB8 	54 49 A0  1  4 45 A0  1 
1A16AC0 	C4 4C A0  1 

   \ now test all other candidates to see if their "char#"-th character
   \ is the same as that of the first candidate

   true -rot                               ( true char# char )
1A16AC4 	 4 70 A0  1 
1A16AC8 	94 49 A0  1 

   candidates na1+  #candidates @  1-  /n*  bounds  ?do   ( flag char# char )
1A16ACC 	F8 66 A1  1 
1A16AD0 	CC 50 A0  1 E0 66 A1  1 
1A16AD8 	5C 4C A0  1 54 4B A0  1 
1A16AE0 	98 51 A0  1 F0 6D A0  1 
1A16AE8 	50 42 A0  1 38  0  0  0 
       i @ cclash?  if                                    ( flag char# char )
1A16AF0 	B4 42 A0  1 5C 4C A0  1 
1A16AF8 	28 6A A1  1 DC 41 A0  1 
1A16B00 	18  0  0  0 
          rot drop  false -rot  leave
1A16B04 	7C 49 A0  1 
1A16B08 	30 49 A0  1 18 70 A0  1 
1A16B10 	94 49 A0  1 18 43 A0  1 
       then
   /n +loop                                               ( flag char# char )
1A16B18 	40 51 A0  1 1C 42 A0  1 
1A16B20 	D0 FF FF FF 
   rot if   nip true   else   2drop false   then
1A16B24 	7C 49 A0  1 
1A16B28 	DC 41 A0  1 14  0  0  0 
1A16B30 	FC 46 A0  1  4 70 A0  1 
1A16B38 	C8 41 A0  1  C  0  0  0 
1A16B40 	AC 49 A0  1 18 70 A0  1 
;
1A16B48 	58 46 A0  1 
: expand-initial-substring  ( -- )
1A16B4C 	 0  0  0 65 
1A16B50 	78 70 61 6E 64 2D 69 6E 
1A16B58 	69 74 69 61 6C 2D 73 75 
1A16B60 	62 73 74 72 69 6E 67 98 
1A16B68 	88 6A A1  1 20 40 A0  1 
   #before  start-of-word @  -
1A16B70 	 C 41 A1  1 AC 66 A1  1 
1A16B78 	5C 4C A0  1 18 45 A0  1 
   begin                         ( current-length )
         dup candidates-agree?   ( current-len [ char true ] | false )
1A16B80 	40 49 A0  1 88 6A A1  1 
   while
1A16B88 	DC 41 A0  1 14  0  0  0 
         cinsert  1+             ( current-length )
1A16B90 	7C 66 A1  1 30 4B A0  1 
   repeat
1A16B98 	C8 41 A0  1 E4 FF FF FF 
   drop
1A16BA0 	30 49 A0  1 
;
1A16BA4 	58 46 A0  1 

h# 34 buffer: candidate
1A16BA8 	 0  0 63 61 6E 64 69 64 
1A16BB0 	61 74 65 89 6C 6B A1  1 
1A16BB8 	B4 A9 A0  1 70  4  0  0 
1A16BC0 	34  0  0  0 F8 66 A1  1 

\ True if there is only one candidate or if all the names are the same.
: one-candidate?  ( -- flag )
1A16BC8 	 0 6F 6E 65 2D 63 61 6E 
1A16BD0 	64 69 64 61 74 65 3F 8E 
1A16BD8 	B8 6B A1  1 20 40 A0  1 

   \ We can't just compare the pointers, because we are checking for
   \ different words with the same name.

   candidates @ name>string  candidate place
1A16BE0 	F8 66 A1  1 5C 4C A0  1 
1A16BE8 	58 74 A0  1 B8 6B A1  1 
1A16BF0 	F0 88 A0  1 
   true
1A16BF4 	 4 70 A0  1 
   candidates  #candidates @ /n*  bounds  ?do  ( flag )
1A16BF8 	F8 66 A1  1 E0 66 A1  1 
1A16C00 	5C 4C A0  1 98 51 A0  1 
1A16C08 	F0 6D A0  1 50 42 A0  1 
1A16C10 	3C  0  0  0 
      i @  name>string  candidate count        ( flag )
1A16C14 	B4 42 A0  1 
1A16C18 	5C 4C A0  1 58 74 A0  1 
1A16C20 	B8 6B A1  1 BC 53 A0  1 
      $=  0=  if  0= leave  then               ( flag )
1A16C28 	88 8D A0  1 24 47 A0  1 
1A16C30 	DC 41 A0  1  C  0  0  0 
1A16C38 	24 47 A0  1 18 43 A0  1 
   /n +loop                                    ( flag )
1A16C40 	40 51 A0  1 1C 42 A0  1 
1A16C48 	CC FF FF FF 
;
1A16C4C 	58 46 A0  1 

0 [if]
: do-erase  ( -- ) \ Side effect: span and bufcursor may be reduced
   begin
      word-to-string   ( addr )
      dup c@ 0=  if  drop exit  then	\ Stop if the entire word is gone
      find-candidates
      #candidates @ 0=
   while
      cerase
   repeat
;
[then]

: do-expand  ( -- )
1A16C50 	 0  0 64 6F 2D 65 78 70 
1A16C58 	61 6E 64 89 DC 6B A1  1 
1A16C60 	20 40 A0  1 
   expand-initial-substring
1A16C64 	6C 6B A1  1 

   \ Beep if the expansion does not result in a unique choice
   one-candidate?  if  bl cinsert  else beep  then
1A16C68 	DC 6B A1  1 DC 41 A0  1 
1A16C70 	14  0  0  0 28 70 A0  1 
1A16C78 	7C 66 A1  1 C8 41 A0  1 
1A16C80 	 8  0  0  0 A8 40 A1  1 
;
1A16C88 	58 46 A0  1 

: expand-word  ( -- )
1A16C8C 	65 78 70 61 
1A16C90 	6E 64 2D 77 6F 72 64 8B 
1A16C98 	60 6C A1  1 20 40 A0  1 
   collect-string find-candidates  ( )
1A16CA0 	7C 67 A1  1 70 69 A1  1 
   #candidates @  if   do-expand   else
1A16CA8 	E0 66 A1  1 5C 4C A0  1 
1A16CB0 	DC 41 A0  1 10  0  0  0 
1A16CB8 	60 6C A1  1 C8 41 A0  1 
1A16CC0 	 8  0  0  0 
[ifdef] do-erase  do-erase  [else]  beep  [then]
1A16CC4 	A8 40 A1  1 
   then
;
1A16CC8 	58 46 A0  1 

: show-candidates  ( -- )
1A16CCC 	73 68 6F 77 
1A16CD0 	2D 63 61 6E 64 69 64 61 
1A16CD8 	74 65 73 8F 9C 6C A1  1 
1A16CE0 	20 40 A0  1 
   td 64 rmargin !
1A16CE4 	58 41 A0  1 
1A16CE8 	40  0  0  0 94 13 A1  1 
1A16CF0 	54 4D A0  1 
   candidates #candidates  @  /n* bounds  ?do  ?cr  i @ .id  /n +loop
1A16CF4 	F8 66 A1  1 
1A16CF8 	E0 66 A1  1 5C 4C A0  1 
1A16D00 	98 51 A0  1 F0 6D A0  1 
1A16D08 	50 42 A0  1 20  0  0  0 
1A16D10 	E8 13 A1  1 B4 42 A0  1 
1A16D18 	5C 4C A0  1 A8 9A A0  1 
1A16D20 	40 51 A0  1 1C 42 A0  1 
1A16D28 	E8 FF FF FF 
   overflow @  if  ." ..."  then
1A16D2C 	18 67 A1  1 
1A16D30 	5C 4C A0  1 DC 41 A0  1 
1A16D38 	10  0  0  0 20 7C A0  1 
1A16D40 	 3 2E 2E 2E  0  0  0  0 
;
1A16D48 	58 46 A0  1 

: do-show  ( -- )
1A16D4C 	64 6F 2D 73 
1A16D50 	68 6F 77 87 E0 6C A1  1 
1A16D58 	20 40 A0  1 
   cr
1A16D5C 	80 6D A0  1 
   collect-string  dup c@  if       ( str )
1A16D60 	7C 67 A1  1 40 49 A0  1 
1A16D68 	C4 4C A0  1 DC 41 A0  1 
1A16D70 	14  0  0  0 
      find-candidates show-candidates
1A16D74 	70 69 A1  1 
1A16D78 	E0 6C A1  1 
   else
1A16D7C 	C8 41 A0  1 
1A16D80 	60  0  0  0 
      drop ." Any word at all is a candidate." cr
1A16D84 	30 49 A0  1 
1A16D88 	20 7C A0  1 1F 41 6E 79 
1A16D90 	20 77 6F 72 64 20 61 74 
1A16D98 	20 61 6C 6C 20 69 73 20 
1A16DA0 	61 20 63 61 6E 64 69 64 
1A16DA8 	61 74 65 2E  0  0  0  0 
1A16DB0 	80 6D A0  1 
           ." Use words to see the entire dictionary"
1A16DB4 	20 7C A0  1 
1A16DB8 	26 55 73 65 20 77 6F 72 
1A16DC0 	64 73 20 74 6F 20 73 65 
1A16DC8 	65 20 74 68 65 20 65 6E 
1A16DD0 	74 69 72 65 20 64 69 63 
1A16DD8 	74 69 6F 6E 61 72 79  0 
   then
   retype-line
1A16DE0 	74 48 A1  1 
;
1A16DE4 	58 46 A0  1 
headers

only forth also definitions

OpenFirmware/forth/lib/cmdcpl.fth_AL	1976 1A16DE8 
\ Command completion interface for the Forth line editor

only forth also hidden also command-completion definitions

headerless
: install-fcmd
1A16DE8 	 0  0  0 69 6E 73 74 61 
1A16DF0 	6C 6C 2D 66 63 6D 64 8C 
1A16DF8 	58 6D A1  1 20 40 A0  1 
   ['] end-of-word               is find-end
1A16E00 	60 53 A0  1  0 4A A1  1 
1A16E08 	98 40 A0  1 68 66 A1  1 
   ['] insert-character          is cinsert
1A16E10 	60 53 A0  1 C0 4F A1  1 
1A16E18 	98 40 A0  1 7C 66 A1  1 
   ['] erase-previous-character  is cerase
1A16E20 	60 53 A0  1 5C 50 A1  1 
1A16E28 	98 40 A0  1 90 66 A1  1 
;
1A16E30 	58 46 A0  1 
install-fcmd

only forth also command-completion also hidden also keys-forth definitions

headers
\ TAB expands, TAB-TAB shows completions
: ^i beforechar @ control i =  if do-show  else  expand-word then  ;	\ tab
1A16E34 	 0 5E 69 82 
1A16E38 	24 66 A1  1 20 40 A0  1 
1A16E40 	F4 5C A1  1 5C 4C A0  1 
1A16E48 	58 41 A0  1  9  0  0  0 
1A16E50 	24 48 A0  1 DC 41 A0  1 
1A16E58 	10  0  0  0 58 6D A1  1 
1A16E60 	C8 41 A0  1  8  0  0  0 
1A16E68 	9C 6C A1  1 58 46 A0  1 
: ^` expand-word ;	\ Control-space or control-back-tick
1A16E70 	 0 5E 60 82 3C 6E A1  1 
1A16E78 	20 40 A0  1 9C 6C A1  1 
1A16E80 	58 46 A0  1 
: ^| expand-word ;	\ Control-vertical-bar or control-backslash
1A16E84 	 0 5E 7C 82 
1A16E88 	78 6E A1  1 20 40 A0  1 
1A16E90 	9C 6C A1  1 58 46 A0  1 
: ^} do-show ;		\ Control-right-bracket
1A16E98 	 0 5E 7D 82 8C 6E A1  1 
1A16EA0 	20 40 A0  1 58 6D A1  1 
1A16EA8 	58 46 A0  1 
: ^? do-show ;		\ Control-question-mark
1A16EAC 	 0 5E 7F 82 
1A16EB0 	A0 6E A1  1 20 40 A0  1 
1A16EB8 	58 6D A1  1 58 46 A0  1 
h# 7f last-t @ mmoname>string 
 mmodrop 1+
\ cr 2dup h. h. key drop
 c!   	\ Hack hack

only forth also definitions


OpenFirmware/forth/lib/fcmdcpl.fth_AL	216 1A16EC0 
also hidden
only forth also hidden also definitions
decimal
headerless

variable sift-vocabulary
1A16EC0 	73 69 66 74 2D 76 6F 63 
1A16EC8 	61 62 75 6C 61 72 79 8F 
1A16ED0 	88 65 A1  1 48 40 A0  1 
1A16ED8 	74  4  0  0 

headers

\ Leave a "hook" for showing the name of the vocabulary
\ only once, the first time a matching name is found.
\ Showing the name of a device can be plugged in here also...
defer .voc     ' noop is .voc
1A16EDC 	 0  0  0 2E 
1A16EE0 	76 6F 63 84 D4 6E A1  1 
1A16EE8 	5C 40 A0  1 78  4  0  0 

: .in  ( -- )  ??cr tabstops @ spaces  ." In "  ;
1A16EF0 	2E 69 6E 83 E8 6E A1  1 
1A16EF8 	20 40 A0  1  0 A1 A0  1 
1A16F00 	38 14 A1  1 5C 4C A0  1 
1A16F08 	E8 71 A0  1 20 7C A0  1 
1A16F10 	 3 49 6E 20  0  0  0  0 
1A16F18 	58 46 A0  1 

headerless
: .vocab  ( -- )
1A16F1C 	 0 2E 76 6F 
1A16F20 	63 61 62 86 F8 6E A1  1 
1A16F28 	20 40 A0  1 
   .in ['] vocabulary .name space
1A16F2C 	F8 6E A1  1 
1A16F30 	60 53 A0  1 28 B7 A0  1 
1A16F38 	C8 9A A0  1 CC 71 A0  1 
   sift-vocabulary @ .name cr
1A16F40 	D4 6E A1  1 5C 4C A0  1 
1A16F48 	C8 9A A0  1 80 6D A0  1 
   ['] noop is .voc
1A16F50 	60 53 A0  1 64 4F A0  1 
1A16F58 	98 40 A0  1 E8 6E A1  1 
;
1A16F60 	58 46 A0  1 

\ Show the "sifted" name, preceded by its  cfa  in parentheses.
\ Show the name of the vocabulary only the first time.
\ Control the display with  exit?
: .sift?  ( nfa -- exit? )
1A16F64 	 0 2E 73 69 
1A16F68 	66 74 3F 86 28 6F A1  1 
1A16F70 	20 40 A0  1 
   .voc
1A16F74 	E8 6E A1  1 
   exit? tuck  if  drop exit  then 		( exit? nfa )
1A16F78 	34  D A1  1 E8 46 A0  1 
1A16F80 	DC 41 A0  1  C  0  0  0 
1A16F88 	30 49 A0  1 40 46 A0  1 
   dup  name>				 	( exit? nfa cfa )
1A16F90 	40 49 A0  1  8 74 A0  1 
   over n>flags c@  h# 20 and  if  token@  then	  \ Handle aliases
1A16F98 	54 49 A0  1 BC 73 A0  1 
1A16FA0 	C4 4C A0  1 58 41 A0  1 
1A16FA8 	20  0  0  0 5C 44 A0  1 
1A16FB0 	DC 41 A0  1  8  0  0  0 
1A16FB8 	 C 54 A0  1 
   fake-name			 		( nfa fstr )
1A16FBC 	EC B7 A0  1 
   over name>string nip
1A16FC0 	54 49 A0  1 58 74 A0  1 
1A16FC8 	FC 46 A0  1 
   over name>string nip + 3 + .tab
1A16FCC 	54 49 A0  1 
1A16FD0 	58 74 A0  1 FC 46 A0  1 
1A16FD8 	 4 45 A0  1 A0 6F A0  1 
1A16FE0 	 4 45 A0  1 AC 14 A1  1 
  .id .id 2 spaces
1A16FE8 	A8 9A A0  1 A8 9A A0  1 
1A16FF0 	90 6F A0  1 E8 71 A0  1 
;
1A16FF8 	58 46 A0  1 

headers
forth definitions

\ Sift through the given vocabulary, using the sift-string given.
\ Control the display with  exit?
: vsift?  ( adr len voc-acf -- adr len exit? )
1A16FFC 	 0 76 73 69 
1A17000 	66 74 3F 86 48 66 A1  1 
1A17008 	20 40 A0  1 
   dup sift-vocabulary !  follow
1A1700C 	40 49 A0  1 
1A17010 	D4 6E A1  1 54 4D A0  1 
1A17018 	38 BC A0  1 
   begin  another?  while			( adr len nfa )
1A1701C 	68 BC A0  1 
1A17020 	DC 41 A0  1 44  0  0  0 
      3dup name>string sindex			( adr len nfa indx|-1 )
1A17028 	A4 52 A0  1 58 74 A0  1 
1A17030 	 8 17 A1  1 
      1+ if  .sift? ?dup if exit then
1A17034 	30 4B A0  1 
1A17038 	DC 41 A0  1 20  0  0  0 
1A17040 	70 6F A1  1 B4 70 A0  1 
1A17048 	DC 41 A0  1  8  0  0  0 
1A17050 	40 46 A0  1 
	else   drop
1A17054 	C8 41 A0  1 
1A17058 	 8  0  0  0 30 49 A0  1 
	then
   repeat	   false
1A17060 	C8 41 A0  1 B8 FF FF FF 
1A17068 	18 70 A0  1 
;
1A1706C 	58 46 A0  1 

\ Sift through all the vocabularies for the string given
\ on the stack as  addr,len
: $sift ( addr len -- )
1A17070 	 0  0 24 73 69 66 74 85 
1A17078 	 8 70 A1  1 20 40 A0  1 
   voc-link  begin  another-link?  while	( addr len v-link )
1A17080 	74 B6 A0  1 90 59 A0  1 
1A17088 	DC 41 A0  1 48  0  0  0 
      ['] .vocab is .voc
1A17090 	60 53 A0  1 28 6F A1  1 
1A17098 	98 40 A0  1 E8 6E A1  1 
      voc> >r r@ vsift? r> swap  if  3drop exit  then
1A170A0 	38 B6 A0  1 BC 45 A0  1 
1A170A8 	E4 45 A0  1  8 70 A1  1 
1A170B0 	D0 45 A0  1 68 49 A0  1 
1A170B8 	DC 41 A0  1  C  0  0  0 
1A170C0 	90 52 A0  1 40 46 A0  1 
      >voc-link		
1A170C8 	50 B6 A0  1 
   repeat  2drop
1A170CC 	C8 41 A0  1 
1A170D0 	B4 FF FF FF AC 49 A0  1 
;
1A170D8 	58 46 A0  1 

\  Same thing, only the string is given on the stack in packed format
: sift  ( str -- )  count $sift  ;
1A170DC 	 0  0  0 73 
1A170E0 	69 66 74 84 7C 70 A1  1 
1A170E8 	20 40 A0  1 BC 53 A0  1 
1A170F0 	7C 70 A1  1 58 46 A0  1 

\  Same thing, only the string is given in the input stream.
: sifting  \ name  ( -- )
1A170F8 	73 69 66 74 69 6E 67 87 
1A17100 	E8 70 A1  1 20 40 A0  1 
   safe-parse-word $sift
1A17108 	88 93 A0  1 7C 70 A1  1 
;
1A17110 	58 46 A0  1 

only forth also definitions

OpenFirmware/forth/lib/sift.fth_AL	596 1A17114 
forth definitions
headerless
: array  \ name  ( #elements -- )
1A17114 	 0  0 61 72 
1A17118 	72 61 79 85  4 71 A1  1 
1A17120 	20 40 A0  1 
\   create /n* allot   does>  swap na+	\ not ROMable
   /n* buffer:  does> do-buffer  swap na+    \ buffer: action plus  "swap na+"
1A17124 	98 51 A0  1 
1A17128 	D0 A9 A0  1 50 A3 A0  1 
1A17130 	90 90 90 E8 44 CF FE FF 
1A17138 	34 A9 A0  1 68 49 A0  1 
1A17140 	48 50 A0  1 
;
1A17144 	58 46 A0  1 
headers

OpenFirmware/forth/lib/array.fth_AL	52 1A17148 
\ Linked list words.  Assumes a singly-linked list, where the
\ first element in each list node is the link.  Links point to links,
\ and the last link contains 0.
\
\ list:  \ name  ( -- )   Child: ( -- list )
\	Defines a named list.
\
\ listnode   ( -- offset )
\	Used like "struct" to begin the creation of a list node structure
\	The link field is automatically included in the structure.
\
\ nodetype:  \ name  ( size -- )   Child: ( -- nodetype )
\	Defines a new named node type.  Example:
\
\		listnode
\			/n field >node-data
\		nodetype: integer-node
\
\ node-length  ( nodetype -- len )
\	Returns the length of a node of the indicated type.
\
\ allocate-node  ( nodetype -- node )
\	Allocates a node of the indicated type.
\
\ more-nodes  ( #nodes nodetype -- )
\	Adds "#nodes" more nodes to the free list for the indicated node type.
\	Automatically executed by "allocate-node" if necessary.
\
\ free-node  ( node nodetype -- )
\	Returns the indicated node to the free list for the indicated node
\	type.
\
\ insert-after  ( new-node-adr prev-node-adr -- )
\	Inserts "new-node" into a linked list after "prev-node" (and before
\	the node which was the successor of "prev-node").
\
\ delete-after  ( prev-node -- deleted-node )
\	Removes the node AFTER the argument node.  The deleted node is
\	returned so its memory can be freed or whatever.
\
\ find-node  ( ??? list acf -- ??? prev-node this-node|0 )
\	Searches the linked list "list", executing the procedure "acf"
\	for each node in the list.  Returns the node for which "acf"
\	returned "true", and also the preceding node.  See the comments
\	in the code for more information.
\
\ find-node?  ( ??? list acf -- ??? false | ??? node true )
\	Searches the linked list "list", executing the procedure "acf"
\	for each node in the list.  Returns the node and true if found,
\	or false if not found.

alias list: variable
1A17148 	 0  0 6C 69 73 74 3A A5 
1A17150 	20 71 A1  1 94 F2 A0  1 

alias listnode /n
1A17158 	 0  0  0 6C 69 73 74 6E 
1A17160 	6F 64 65 A8 54 71 A1  1 
1A17168 	40 51 A0  1 

: nodetype:  \ name  ( size -- )
1A1716C 	 0  0 6E 6F 
1A17170 	64 65 74 79 70 65 3A 89 
1A17178 	68 71 A1  1 20 40 A0  1 
   aligned  create 2 /n* user#,  0 over ! na1+ !     \ Free list, size
1A17180 	EC 5C A0  1 A8 A2 A0  1 
1A17188 	90 6F A0  1 98 51 A0  1 
1A17190 	84 9A A0  1 70 6F A0  1 
1A17198 	54 49 A0  1 54 4D A0  1 
1A171A0 	CC 50 A0  1 54 4D A0  1 
   does> >user
1A171A8 	50 A3 A0  1 90 90 90 E8 
1A171B0 	C8 CE FE FF C8 74 A0  1 
;
1A171B8 	58 46 A0  1 
: node-length  ( nodetype -- len )  na1+ @  ;
1A171BC 	6E 6F 64 65 
1A171C0 	2D 6C 65 6E 67 74 68 8B 
1A171C8 	7C 71 A1  1 20 40 A0  1 
1A171D0 	CC 50 A0  1 5C 4C A0  1 
1A171D8 	58 46 A0  1 

alias >next-node @     ( node-adr -- next-node-adr )
1A171DC 	 0 3E 6E 65 
1A171E0 	78 74 2D 6E 6F 64 65 AA 
1A171E8 	CC 71 A1  1 5C 4C A0  1 

: list-end?  ( node-adr -- flag )  >next-node @ 0=  ;
1A171F0 	 0  0 6C 69 73 74 2D 65 
1A171F8 	6E 64 3F 89 EC 71 A1  1 
1A17200 	20 40 A0  1 5C 4C A0  1 
1A17208 	5C 4C A0  1 24 47 A0  1 
1A17210 	58 46 A0  1 

\ Inserts "new-node" into a linked list after "prev-node" (and before
\ the node which was the successor of "prev-node").

: insert-after  ( new-node-adr prev-node-adr -- )
1A17214 	 0  0  0 69 
1A17218 	6E 73 65 72 74 2D 61 66 
1A17220 	74 65 72 8C  0 72 A1  1 
1A17228 	20 40 A0  1 
   2dup >next-node    ( new-node prev-node  new-node succ-node )
1A1722C 	C0 49 A0  1 
1A17230 	5C 4C A0  1 
   swap !             ( new-node prev-node  )
1A17234 	68 49 A0  1 
1A17238 	54 4D A0  1 
   !                  ( )
1A1723C 	54 4D A0  1 
;
1A17240 	58 46 A0  1 

\ Delete-after removes the node AFTER the argument node
\ The deleted node is returned so its memory can be freed or whatever.

: delete-after  ( prev-node -- deleted-node )  dup @ tuck @ swap !  ;
1A17244 	 0  0  0 64 
1A17248 	65 6C 65 74 65 2D 61 66 
1A17250 	74 65 72 8C 28 72 A1  1 
1A17258 	20 40 A0  1 40 49 A0  1 
1A17260 	5C 4C A0  1 E8 46 A0  1 
1A17268 	5C 4C A0  1 68 49 A0  1 
1A17270 	54 4D A0  1 58 46 A0  1 


\ find-node  traverses the list, executing "acf" between each pair of nodes.
\ When "acf" returns true, find-node returns the addresses of the pair of
\ nodes.  If the list is exhausted before "acf" returns true, the last node
\ and 0 is returned.

\ "acf" is called as:
\     ( ??? node-data-adr -- ??? flag )
\
\ ??? is whatever was on the stack underneath "list" and "acf" when "find-node"
\ was called.  It would typically be a test value used by the "acf" function.
\ "acf" is only called with valid node addresses, assuming that the list is
\ well-formed.  In other words, "acf" will not be called with either the
\ list head node or with the null node past the end of the list.

\ The data and return stack manipulations in find-node are pretty grim.
\ Reasons:
\ (a) We want the stack diagram for the action routine to be clean in order
\     to make find-node easy to use.  Thus we do not wish to expose the
\     loop information on the data stack when the action routine is called.
\ (b) The arguments to the action routine are arbitrary in number, thus
\     we cannot store loop information underneath them.
\ (c) This routine needs to be reentrant, since it is used by the alarm
\     interrupt handler.  Thus we cannot use variables.

: find-node  ( ??? list acf -- ??? prev-node this-node|0 )
1A17278 	 0  0 66 69 6E 64 2D 6E 
1A17280 	6F 64 65 89 58 72 A1  1 
1A17288 	20 40 A0  1 
   \ Guard against null lists
   over 0=  if  drop 0 exit  then
1A1728C 	54 49 A0  1 
1A17290 	24 47 A0  1 DC 41 A0  1 
1A17298 	10  0  0  0 30 49 A0  1 
1A172A0 	70 6F A0  1 40 46 A0  1 
   >r >r 0 >r                    ( ??? )       ( r: acf list 0 )
1A172A8 	BC 45 A0  1 BC 45 A0  1 
1A172B0 	70 6F A0  1 BC 45 A0  1 
   begin                         ( ??? )       ( r: acf prev-node old-node )
      r> drop  r>                ( ??? new-this-node )        ( r: acf )
1A172B8 	D0 45 A0  1 30 49 A0  1 
1A172C0 	D0 45 A0  1 
      dup >next-node dup 0=  if  ( ??? this-node next-node )  ( r: acf )
1A172C4 	40 49 A0  1 
1A172C8 	5C 4C A0  1 40 49 A0  1 
1A172D0 	24 47 A0  1 DC 41 A0  1 
1A172D8 	10  0  0  0 
         r> drop exit            ( ??? last-node 0 )          ( r: acf )
1A172DC 	D0 45 A0  1 
1A172E0 	30 49 A0  1 40 46 A0  1 
      then		         ( ??? this-node next-node )  ( r: acf )
      tuck r@ -rot  >r >r        ( ??? data-adr acf ) ( r: acf next this )
1A172E8 	E8 46 A0  1 E4 45 A0  1 
1A172F0 	94 49 A0  1 BC 45 A0  1 
1A172F8 	BC 45 A0  1 
      execute                    ( ??? flag )         ( r: acf next this )
1A172FC 	98 41 A0  1 
   until                         ( ??? )              ( r: acf next this )
1A17300 	DC 41 A0  1 B4 FF FF FF 
   r> r> r> drop                 ( ??? prev-node this-node )
1A17308 	D0 45 A0  1 D0 45 A0  1 
1A17310 	D0 45 A0  1 30 49 A0  1 
;
1A17318 	58 46 A0  1 

: find-node?  ( ??? list acf -- ??? false | ??? node true )
1A1731C 	 0 66 69 6E 
1A17320 	64 2D 6E 6F 64 65 3F 8A 
1A17328 	88 72 A1  1 20 40 A0  1 
   find-node ?dup  if   ( ??? prev-node this-node )
1A17330 	88 72 A1  1 B4 70 A0  1 
1A17338 	DC 41 A0  1 14  0  0  0 
      nip true          ( ??? node true )
1A17340 	FC 46 A0  1  4 70 A0  1 
   else                 ( ??? prev-node )
1A17348 	C8 41 A0  1  C  0  0  0 
      drop false        ( ??? false )
1A17350 	30 49 A0  1 18 70 A0  1 
   then                 ( ??? false | ??? node true )
;
1A17358 	58 46 A0  1 

\ Here's how "find-node" could be used to locate the insertion point
\ for a list sorted in ascending order of the second field.

\ : larger?  ( key node-data-adr -- key flag )  na1+ @ over u>  ;
\ : insertion-point  ( key list -- node )   ['] larger?  find-node  drop  ;


\ Locates the last node in the list.  The routine used with "find-node"
\ is "0=", which always returns "false" because find-node is guaranteed
\ not to call its test routine with a 0 node.

: last-node  ( list -- node-adr )  ['] 0=  find-node  drop  ;
1A1735C 	 0  0 6C 61 
1A17360 	73 74 2D 6E 6F 64 65 89 
1A17368 	2C 73 A1  1 20 40 A0  1 
1A17370 	60 53 A0  1 24 47 A0  1 
1A17378 	88 72 A1  1 30 49 A0  1 
1A17380 	58 46 A0  1 

\ Add new nodes to the free list of "nodetype", from the block of memory
\ "adr len", whose length must be a multiple of that nodetype's node length.
: add-nodes  ( adr len nodetype -- )
1A17384 	 0  0 61 64 
1A17388 	64 2D 6E 6F 64 65 73 89 
1A17390 	6C 73 A1  1 20 40 A0  1 
   dup node-length                     ( adr len nodetype /node )
1A17398 	40 49 A0  1 CC 71 A1  1 

   \ Find the end of the free list
   swap last-node                      ( adr len /node last-node )
1A173A0 	68 49 A0  1 6C 73 A1  1 

   \ Link new nodes onto free list
   2swap bounds  ?do                   ( /node prev-node )
1A173A8 	F4 49 A0  1 F0 6D A0  1 
1A173B0 	50 42 A0  1 20  0  0  0 
      i swap !  i                      ( /node prev-node' )
1A173B8 	B4 42 A0  1 68 49 A0  1 
1A173C0 	54 4D A0  1 B4 42 A0  1 
   over +loop                          ( /node prev-node' )
1A173C8 	54 49 A0  1 1C 42 A0  1 
1A173D0 	E8 FF FF FF 
   0 swap !   drop                     ( )
1A173D4 	70 6F A0  1 
1A173D8 	68 49 A0  1 54 4D A0  1 
1A173E0 	30 49 A0  1 
;
1A173E4 	58 46 A0  1 

\ Adds "#nodes" more nodes to the free list for the indicated node type.
\ Automatically executed by "allocate-node" if necessary.

: more-nodes  ( #nodes nodetype -- )
1A173E8 	 0 6D 6F 72 65 2D 6E 6F 
1A173F0 	64 65 73 8A 94 73 A1  1 
1A173F8 	20 40 A0  1 
   tuck node-length *                  ( nodetype total-size )
1A173FC 	E8 46 A0  1 
1A17400 	CC 71 A1  1 1C 5F A0  1 
   dup alloc-mem                       ( nodetype total-size adr )
1A17408 	40 49 A0  1 F0 6C A0  1 
   swap rot  add-nodes
1A17410 	68 49 A0  1 7C 49 A0  1 
1A17418 	94 73 A1  1 
;
1A1741C 	58 46 A0  1 

\ Allocates a node of the indicated type by removing a node from the
\ free list.  If the free list start out empty, allocate-node first
\ calls more-nodes to populate the free list.

: allocate-node  ( nodetype -- node )
1A17420 	 0  0 61 6C 6C 6F 63 61 
1A17428 	74 65 2D 6E 6F 64 65 8D 
1A17430 	F8 73 A1  1 20 40 A0  1 
   dup @  0=  if                       ( nodetype )
1A17438 	40 49 A0  1 5C 4C A0  1 
1A17440 	24 47 A0  1 DC 41 A0  1 
1A17448 	14  0  0  0 
      d# 10 over more-nodes            ( nodetype )
1A1744C 	58 41 A0  1 
1A17450 	 A  0  0  0 54 49 A0  1 
1A17458 	F8 73 A1  1 
   then

   dup >next-node dup >next-node       ( nodetype first-node second-node )
1A1745C 	40 49 A0  1 
1A17460 	5C 4C A0  1 40 49 A0  1 
1A17468 	5C 4C A0  1 
   rot !                               ( first-node )
1A1746C 	7C 49 A0  1 
1A17470 	54 4D A0  1 
;
1A17474 	58 46 A0  1 

\ Adds the node to the free list for the indicated node type.

: free-node  ( node nodetype -- )  insert-after  ;
1A17478 	 0  0 66 72 65 65 2D 6E 
1A17480 	6F 64 65 89 34 74 A1  1 
1A17488 	20 40 A0  1 28 72 A1  1 
1A17490 	58 46 A0  1 

OpenFirmware/forth/lib/linklist.fth_AL	844 1A17494 purpose: lexical analysis primitive

\ text$ means ( text-adr text-len )
0 value delim
1A17494 	 0  0 64 65 
1A17498 	6C 69 6D 85 88 74 A1  1 
1A174A0 	50 40 A0  1 7C  4  0  0 

\ lex scans text$ for each character in delim$
\ when one is found, lex splits text$ at that delimiter and leaves
: lex   ( text$ delim$ -- rem$ head$ delim true | text$ false )
1A174A8 	6C 65 78 83 A0 74 A1  1 
1A174B0 	20 40 A0  1 
   0 is delim
1A174B4 	70 6F A0  1 
1A174B8 	B8 40 A0  1 A0 74 A1  1 
   2over bounds ?do				( text$ delim$ )
1A174C0 	D8 49 A0  1 F0 6D A0  1 
1A174C8 	50 42 A0  1 44  0  0  0 
      2dup i c@ cindex if			( text$ delim$ [ index ] )
1A174D0 	C0 49 A0  1 B4 42 A0  1 
1A174D8 	C4 4C A0  1 4C 19 A1  1 
1A174E0 	DC 41 A0  1 24  0  0  0 
	 nip nip c@  dup is delim		( text$ delim )
1A174E8 	FC 46 A0  1 FC 46 A0  1 
1A174F0 	C4 4C A0  1 40 49 A0  1 
1A174F8 	B8 40 A0  1 A0 74 A1  1 
	 left-parse-string  leave		( rem$ head$ )
1A17500 	44 D7 A0  1 18 43 A0  1 
      then					( text$ delim$ | rem$ head$ )
   loop						( text$ delim$ | rem$ head$ )
1A17508 	F8 41 A0  1 C4 FF FF FF 
   delim if
1A17510 	A0 74 A1  1 DC 41 A0  1 
1A17518 	14  0  0  0 
      delim true
1A1751C 	A0 74 A1  1 
1A17520 	 4 70 A0  1 
   else
1A17524 	C8 41 A0  1 
1A17528 	 C  0  0  0 
      2drop false
1A1752C 	AC 49 A0  1 
1A17530 	18 70 A0  1 
   then
;
1A17534 	58 46 A0  1 

OpenFirmware/forth/lib/lex.fth_AL	164 1A17538 \ initsave.fth 1.1 94/09/01

headers
: $find-name  ( name -- acf )
1A17538 	 0 24 66 69 6E 64 2D 6E 
1A17540 	61 6D 65 8A B0 74 A1  1 
1A17548 	20 40 A0  1 
   $find  0= if  ." Can't find " type  cr  abort  then
1A1754C 	C4 93 A0  1 
1A17550 	24 47 A0  1 DC 41 A0  1 
1A17558 	24  0  0  0 20 7C A0  1 
1A17560 	 B 43 61 6E 27 74 20 66 
1A17568 	69 6E 64 20  0  0  0  0 
1A17570 	 4 6C A0  1 80 6D A0  1 
1A17578 	28 91 A0  1 
;
1A1757C 	58 46 A0  1 
headerless
: init-save  ( 'init-environment -- )
1A17580 	 0  0 69 6E 69 74 2D 73 
1A17588 	61 76 65 89 48 75 A1  1 
1A17590 	20 40 A0  1 
                 $find-name is init-environment
1A17594 	48 75 A1  1 
1A17598 	98 40 A0  1 B8 D0 A0  1 
   " init"       $find-name is do-init
1A175A0 	9C 53 A0  1  4 69 6E 69 
1A175A8 	74  0  0  0 48 75 A1  1 
1A175B0 	98 40 A0  1 80 D0 A0  1 
   " (cold-hook" $find-name is cold-hook
1A175B8 	9C 53 A0  1  A 28 63 6F 
1A175C0 	6C 64 2D 68 6F 6F 6B  0 
1A175C8 	48 75 A1  1 98 40 A0  1 
1A175D0 	98 D0 A0  1 

   here fence a!			\ Protect the dictionary
1A175D4 	70 54 A0  1 
1A175D8 	B8 BE A0  1 98 58 A0  1 
;
1A175E0 	58 46 A0  1 
headers


OpenFirmware/forth/lib/initsave.fth_AL	172 1A175E4 purpose: Forth access words for special 386 registers

decimal

only forth also definitions

\ Descriptor table registers and task register
code idtr@  ( -- base limit )
1A175E4 	 0  0 69 64 
1A175E8 	74 72 40 85 90 75 A1  1 
1A175F0 	F4 75 A1  1 
   ax ax sub   ax push   ax push	\ Make room on stack
1A175F4 	29 C0 50 50 
   sp ax mov   0 [ax] sidt		\ Read onto stack
1A175F8 	8B C4  F  1  8 
   2 [ax] bx mov  bx 4 [ax] mov		\ Move base up
1A175FD 	8B 58  2 
1A17600 	89 58  4 
   bx bx sub  op: bx 2 [ax] mov		\ Insert 0 in high half of limit
1A17603 	29 DB 66 89 58 
1A17608 	 2 
c;
1A17609 	FF E7 
code gdtr@  ( -- base limit )
1A1760B 	 0  0  0 67 64 
1A17610 	74 72 40 85 F0 75 A1  1 
1A17618 	1C 76 A1  1 
   ax ax sub   ax push   ax push	\ Make room on stack
1A1761C 	29 C0 50 50 
   sp ax mov   0 [ax] sgdt		\ Read onto stack
1A17620 	8B C4  F  1  0 
   2 [ax] bx mov  bx 4 [ax] mov		\ Move base up
1A17625 	8B 58  2 
1A17628 	89 58  4 
   bx bx sub  op: bx 2 [ax] mov		\ Insert 0 in high half of limit
1A1762B 	29 DB 66 89 58 
1A17630 	 2 
c;
1A17631 	FF E7 
code idtr!  ( base limit -- )
1A17633 	 0  0  0 69 64 
1A17638 	74 72 21 85 18 76 A1  1 
1A17640 	44 76 A1  1 
   sp ax mov
1A17644 	8B C4 
   4 [ax] bx mov  bx 2 [ax] mov		\ Move base down
1A17646 	8B 58 
1A17648 	 4 89 58  2 
   0 [ax] lidt				\ Load from stack
1A1764C 	 F  1 18 
   ax pop   ax pop			\ Clean up stack
1A1764F 	58 
1A17650 	58 
c;
1A17651 	FF E7 
code gdtr!  ( base limit -- )
1A17653 	 0  0  0 67 64 
1A17658 	74 72 21 85 40 76 A1  1 
1A17660 	64 76 A1  1 
   sp ax mov
1A17664 	8B C4 
   4 [ax] bx mov  bx 2 [ax] mov		\ Move base down
1A17666 	8B 58 
1A17668 	 4 89 58  2 
   0 [ax] lgdt				\ Load from stack
1A1766C 	 F  1 10 
   ax pop   ax pop			\ Clean up stack
1A1766F 	58 
1A17670 	58 
c;
1A17671 	FF E7 

code tr@   ( -- tr  )   ax str    1push c;
1A17673 	 0 74 72 40 83 
1A17678 	60 76 A1  1 80 76 A1  1 
1A17680 	 F  0 C8 50 FF E7 
code ldtr@  ( -- ldt )   ax sldt   1push c;
1A17686 	6C 64 
1A17688 	74 72 40 85 7C 76 A1  1 
1A17690 	94 76 A1  1  F  0 C0 50 
1A17698 	FF E7 
code tr!   ( tr -- )    ax pop    ax ltr   c;
1A1769A 	 0  0 74 72 21 83 
1A176A0 	90 76 A1  1 A8 76 A1  1 
1A176A8 	58  F  0 D8 FF E7 
code ldtr!  ( ldt -- )   ax pop    ax lldt  c;
1A176AE 	6C 64 
1A176B0 	74 72 21 85 A4 76 A1  1 
1A176B8 	BC 76 A1  1 58  F  0 D0 
1A176C0 	FF E7 

\ Control registers
code cr0@  ( -- n )  cr0 ax mov  1push c;
1A176C2 	 0 63 72 30 40 84 
1A176C8 	B8 76 A1  1 D0 76 A1  1 
1A176D0 	 F 20 C0 50 FF E7 
code cr2@  ( -- n )  cr2 ax mov  1push c;
1A176D6 	 0 63 
1A176D8 	72 32 40 84 CC 76 A1  1 
1A176E0 	E4 76 A1  1  F 20 D0 50 
1A176E8 	FF E7 
code cr3@  ( -- n )  cr3 ax mov  1push c;
1A176EA 	 0 63 72 33 40 84 
1A176F0 	E0 76 A1  1 F8 76 A1  1 
1A176F8 	 F 20 D8 50 FF E7 
code cr4@  ( -- n )  cr4 ax mov  1push c;
1A176FE 	 0 63 
1A17700 	72 34 40 84 F4 76 A1  1 
1A17708 	 C 77 A1  1  F 20 E0 50 
1A17710 	FF E7 

code cr0!  ( n -- )  ax pop  ax cr0 mov  c;
1A17712 	 0 63 72 30 21 84 
1A17718 	 8 77 A1  1 20 77 A1  1 
1A17720 	58  F 22 C0 FF E7 
code cr2!  ( n -- )  ax pop  ax cr2 mov  c;
1A17726 	 0 63 
1A17728 	72 32 21 84 1C 77 A1  1 
1A17730 	34 77 A1  1 58  F 22 D0 
1A17738 	FF E7 
code cr3!  ( n -- )  ax pop  ax cr3 mov  c;
1A1773A 	 0 63 72 33 21 84 
1A17740 	30 77 A1  1 48 77 A1  1 
1A17748 	58  F 22 D8 FF E7 
code cr4!  ( n -- )  ax pop  ax cr4 mov  c;
1A1774E 	 0 63 
1A17750 	72 34 21 84 44 77 A1  1 
1A17758 	5C 77 A1  1 58  F 22 E0 
1A17760 	FF E7 

\ Debug registers
code dr0@  ( -- n )  dr0 ax mov  1push c;
1A17762 	 0 64 72 30 40 84 
1A17768 	58 77 A1  1 70 77 A1  1 
1A17770 	 F 21 C0 50 FF E7 
code dr1@  ( -- n )  dr1 ax mov  1push c;
1A17776 	 0 64 
1A17778 	72 31 40 84 6C 77 A1  1 
1A17780 	84 77 A1  1  F 21 C8 50 
1A17788 	FF E7 
code dr2@  ( -- n )  dr2 ax mov  1push c;
1A1778A 	 0 64 72 32 40 84 
1A17790 	80 77 A1  1 98 77 A1  1 
1A17798 	 F 21 D0 50 FF E7 
code dr3@  ( -- n )  dr3 ax mov  1push c;
1A1779E 	 0 64 
1A177A0 	72 33 40 84 94 77 A1  1 
1A177A8 	AC 77 A1  1  F 21 D8 50 
1A177B0 	FF E7 
code dr6@  ( -- n )  dr6 ax mov  1push c;
1A177B2 	 0 64 72 36 40 84 
1A177B8 	A8 77 A1  1 C0 77 A1  1 
1A177C0 	 F 21 F0 50 FF E7 
code dr7@  ( -- n )  dr7 ax mov  1push c;
1A177C6 	 0 64 
1A177C8 	72 37 40 84 BC 77 A1  1 
1A177D0 	D4 77 A1  1  F 21 F8 50 
1A177D8 	FF E7 

code dr0!  ( n -- )  ax pop  ax dr0 mov  c;
1A177DA 	 0 64 72 30 21 84 
1A177E0 	D0 77 A1  1 E8 77 A1  1 
1A177E8 	58  F 23 C0 FF E7 
code dr1!  ( n -- )  ax pop  ax dr1 mov  c;
1A177EE 	 0 64 
1A177F0 	72 31 21 84 E4 77 A1  1 
1A177F8 	FC 77 A1  1 58  F 23 C8 
1A17800 	FF E7 
code dr2!  ( n -- )  ax pop  ax dr2 mov  c;
1A17802 	 0 64 72 32 21 84 
1A17808 	F8 77 A1  1 10 78 A1  1 
1A17810 	58  F 23 D0 FF E7 
code dr3!  ( n -- )  ax pop  ax dr3 mov  c;
1A17816 	 0 64 
1A17818 	72 33 21 84  C 78 A1  1 
1A17820 	24 78 A1  1 58  F 23 D8 
1A17828 	FF E7 
code dr6!  ( n -- )  ax pop  ax dr6 mov  c;
1A1782A 	 0 64 72 36 21 84 
1A17830 	20 78 A1  1 38 78 A1  1 
1A17838 	58  F 23 F0 FF E7 
code dr7!  ( n -- )  ax pop  ax dr7 mov  c;
1A1783E 	 0 64 
1A17840 	72 37 21 84 34 78 A1  1 
1A17848 	4C 78 A1  1 58  F 23 F8 
1A17850 	FF E7 

\ Test registers
code tr6@  ( -- n )  tr6 ax mov  1push c;
1A17852 	 0 74 72 36 40 84 
1A17858 	48 78 A1  1 60 78 A1  1 
1A17860 	 F 24 F0 50 FF E7 
code tr7@  ( -- n )  tr7 ax mov  1push c;
1A17866 	 0 74 
1A17868 	72 37 40 84 5C 78 A1  1 
1A17870 	74 78 A1  1  F 24 F8 50 
1A17878 	FF E7 

code tr6!  ( n -- )  ax pop  ax tr6 mov  c;
1A1787A 	 0 74 72 36 21 84 
1A17880 	70 78 A1  1 88 78 A1  1 
1A17888 	58  F 26 F0 FF E7 
code tr7!  ( n -- )  ax pop  ax tr7 mov  c;
1A1788E 	 0 74 
1A17890 	72 37 21 84 84 78 A1  1 
1A17898 	9C 78 A1  1 58  F 26 F8 
1A178A0 	FF E7 

code clts  ( -- )  h# 0f asm8,  h# 06 asm8,  c;
1A178A2 	 0 63 6C 74 73 84 
1A178A8 	98 78 A1  1 B0 78 A1  1 
1A178B0 	 F  6 FF E7 

code ds@  ( -- sel )  ax ax xor  ds ax mov  ax push  c;
1A178B4 	64 73 40 83 
1A178B8 	AC 78 A1  1 C0 78 A1  1 
1A178C0 	31 C0 8C D8 50 FF E7 
code cs@  ( -- sel )  ax ax xor  cs ax mov  ax push  c;
1A178C7 	 0 
1A178C8 	63 73 40 83 BC 78 A1  1 
1A178D0 	D4 78 A1  1 31 C0 8C C8 
1A178D8 	50 FF E7 
code ss@  ( -- sel )  ax ax xor  ss ax mov  ax push  c;
1A178DB 	 0 73 73 40 83 
1A178E0 	D0 78 A1  1 E8 78 A1  1 
1A178E8 	31 C0 8C D0 50 FF E7 
code es@  ( -- sel )  ax ax xor  es ax mov  ax push  c;
1A178EF 	 0 
1A178F0 	65 73 40 83 E4 78 A1  1 
1A178F8 	FC 78 A1  1 31 C0 8C C0 
1A17900 	50 FF E7 
code fs@  ( -- sel )  ax ax xor  fs ax mov  ax push  c;
1A17903 	 0 66 73 40 83 
1A17908 	F8 78 A1  1 10 79 A1  1 
1A17910 	31 C0 8C E0 50 FF E7 
code gs@  ( -- sel )  ax ax xor  gs ax mov  ax push  c;
1A17917 	 0 
1A17918 	67 73 40 83  C 79 A1  1 
1A17920 	24 79 A1  1 31 C0 8C E8 
1A17928 	50 FF E7 

OpenFirmware/cpu/x86/asmspec.fth_AL	839 1A1792B \ Machine/implementation-dependent definitions

decimal

only forth also hidden also definitions
headerless
: dictionary-base  ( -- adr )  origin 16 +  user-size +  ;
1A1792B 	 0 64 69 63 74 
1A17930 	69 6F 6E 61 72 79 2D 62 
1A17938 	61 73 65 8F 70 6F A1  1 
1A17940 	20 40 A0  1 50 55 A0  1 
1A17948 	58 41 A0  1 10  0  0  0 
1A17950 	 4 45 A0  1 E8 65 A0  1 
1A17958 	 4 45 A0  1 58 46 A0  1 

: ram/rom-in-dictionary?  ( adr flag -- )
1A17960 	 0 72 61 6D 2F 72 6F 6D 
1A17968 	2D 69 6E 2D 64 69 63 74 
1A17970 	69 6F 6E 61 72 79 3F 96 
1A17978 	40 79 A1  1 20 40 A0  1 
   dup  #align 1- and  0=  if
1A17980 	40 49 A0  1 54 5A A0  1 
1A17988 	54 4B A0  1 5C 44 A0  1 
1A17990 	24 47 A0  1 DC 41 A0  1 
1A17998 	30  0  0  0 
	  dup  lo-segment-base lo-segment-limit  within
1A1799C 	40 49 A0  1 
1A179A0 	70  E A1  1 90  E A1  1 
1A179A8 	 8 71 A0  1 
	  swap hi-segment-base hi-segment-limit  within  or
1A179AC 	68 49 A0  1 
1A179B0 	AC  E A1  1 CC  E A1  1 
1A179B8 	 8 71 A0  1 70 44 A0  1 
   else
1A179C0 	C8 41 A0  1  C  0  0  0 
	  drop false
1A179C8 	30 49 A0  1 18 70 A0  1 
   then
;
1A179D0 	58 46 A0  1 

: reasonable-ip?  ( ip -- flag )  in-dictionary?  ;
1A179D4 	 0 72 65 61 
1A179D8 	73 6F 6E 61 62 6C 65 2D 
1A179E0 	69 70 3F 8E 7C 79 A1  1 
1A179E8 	20 40 A0  1 24 CF A0  1 
1A179F0 	58 46 A0  1 


\ Decompiler extension for 32-bit literals
: .llit      ( ip -- ip' )  ta1+ dup l@ n.  la1+  ;  
1A179F4 	 0  0 2E 6C 
1A179F8 	6C 69 74 85 E8 79 A1  1 
1A17A00 	20 40 A0  1 FC 50 A0  1 
1A17A08 	40 49 A0  1 6C 4C A0  1 
1A17A10 	D0 7A A0  1 B4 50 A0  1 
1A17A18 	58 46 A0  1 
: skip-llit  ( ip -- ip' )  ta1+ la1+  ;  
1A17A1C 	 0  0 73 6B 
1A17A20 	69 70 2D 6C 6C 69 74 89 
1A17A28 	 0 7A A1  1 20 40 A0  1 
1A17A30 	FC 50 A0  1 B4 50 A0  1 
1A17A38 	58 46 A0  1 
\ ' (llit)  ' .llit  ' skip-llit  install-decomp

headers
only forth also definitions

OpenFirmware/cpu/x86/decompm.fth_AL	273 1A17A3C 
vocset=5D87D8 1A004A0 1A17A81 purpose: 386 disassembler.

\ TODO: disassembler floating point opcodes
\       Try to reduce the size
\         a) try optimizing string arrays
\         b) Use a single dispatch table for opcodes 80-ff
\         c) eliminate some "op-col" calls by moving it into common factors

also forth definitions
vocabulary disassembler
1A17A81 	 0  0 64 69 73 61 73 
1A17A88 	73 65 6D 62 6C 65 72 8C 
1A17A90 	74 7A A1  1 E0 B6 A0  1 
1A17A98 	80  4  0  0 48 66 A1  1 
1A17AA0 	 0  0  0  0 
also disassembler also definitions

nuser instruction
1A17AA4 	69 6E 73 74 
1A17AA8 	72 75 63 74 69 6F 6E 8B 
1A17AB0 	 0  0 A0  1 48 40 A0  1 
1A17AB8 	84  4  0  0 
variable end-found
1A17ABC 	 0  0 65 6E 
1A17AC0 	64 2D 66 6F 75 6E 64 89 
1A17AC8 	B4 7A A1  1 48 40 A0  1 
1A17AD0 	88  4  0  0 
nuser pc
1A17AD4 	 0 70 63 82 
1A17AD8 	CC 7A A1  1 48 40 A0  1 
1A17AE0 	8C  4  0  0 
nuser branch-target
1A17AE4 	 0  0 62 72 
1A17AE8 	61 6E 63 68 2D 74 61 72 
1A17AF0 	67 65 74 8D DC 7A A1  1 
1A17AF8 	48 40 A0  1 90  4  0  0 
nuser dis-offset
1A17B00 	 0 64 69 73 2D 6F 66 66 
1A17B08 	73 65 74 8A F8 7A A1  1 
1A17B10 	48 40 A0  1 94  4  0  0 

: op8@   ( -- b )  pc @  dis-offset @ +  c@  1 pc +!  ;
1A17B18 	 0  0  0 6F 70 38 40 84 
1A17B20 	10 7B A1  1 20 40 A0  1 
1A17B28 	DC 7A A1  1 5C 4C A0  1 
1A17B30 	10 7B A1  1 5C 4C A0  1 
1A17B38 	 4 45 A0  1 C4 4C A0  1 
1A17B40 	80 6F A0  1 DC 7A A1  1 
1A17B48 	 C 4C A0  1 58 46 A0  1 
: op16@  ( -- w )  op8@   op8@   bwjoin  ;
1A17B50 	 0  0 6F 70 31 36 40 85 
1A17B58 	24 7B A1  1 20 40 A0  1 
1A17B60 	24 7B A1  1 24 7B A1  1 
1A17B68 	84 FB A0  1 58 46 A0  1 
: op32@  ( -- l )  op16@  op16@  wljoin  ;
1A17B70 	 0  0 6F 70 33 32 40 85 
1A17B78 	5C 7B A1  1 20 40 A0  1 
1A17B80 	5C 7B A1  1 5C 7B A1  1 
1A17B88 	D4 4F A0  1 58 46 A0  1 

: bext  ( b -- l )  d# 24 <<  d# 24 >>a  ;
1A17B90 	 0  0  0 62 65 78 74 84 
1A17B98 	7C 7B A1  1 20 40 A0  1 
1A17BA0 	58 41 A0  1 18  0  0  0 
1A17BA8 	C8 44 A0  1 58 41 A0  1 
1A17BB0 	18  0  0  0 F0 44 A0  1 
1A17BB8 	58 46 A0  1 
: wext  ( w -- l )  d# 16 <<  d# 16 >>a  ;
1A17BBC 	 0  0  0 77 
1A17BC0 	65 78 74 84 9C 7B A1  1 
1A17BC8 	20 40 A0  1 58 41 A0  1 
1A17BD0 	10  0  0  0 C8 44 A0  1 
1A17BD8 	58 41 A0  1 10  0  0  0 
1A17BE0 	F0 44 A0  1 58 46 A0  1 

\ change size of data
true value op32?
1A17BE8 	 0  0 6F 70 33 32 3F 85 
1A17BF0 	C8 7B A1  1 50 40 A0  1 
1A17BF8 	98  4  0  0 
: opv@  ( -- l | w )  op32?  if  op32@  else  op16@  then  ;
1A17BFC 	 0  0  0 6F 
1A17C00 	70 76 40 84 F4 7B A1  1 
1A17C08 	20 40 A0  1 F4 7B A1  1 
1A17C10 	DC 41 A0  1 10  0  0  0 
1A17C18 	7C 7B A1  1 C8 41 A0  1 
1A17C20 	 8  0  0  0 5C 7B A1  1 
1A17C28 	58 46 A0  1 
true value ad32?
1A17C2C 	 0  0 61 64 
1A17C30 	33 32 3F 85  8 7C A1  1 
1A17C38 	50 40 A0  1 9C  4  0  0 
: adv@  ( -- l | w )  ad32?  if  op32@  else  op16@   then  ;
1A17C40 	 0  0  0 61 64 76 40 84 
1A17C48 	38 7C A1  1 20 40 A0  1 
1A17C50 	38 7C A1  1 DC 41 A0  1 
1A17C58 	10  0  0  0 7C 7B A1  1 
1A17C60 	C8 41 A0  1  8  0  0  0 
1A17C68 	5C 7B A1  1 58 46 A0  1 
: dis16  ( -- )  false is op32?  false is ad32?  ;
1A17C70 	 0  0 64 69 73 31 36 85 
1A17C78 	4C 7C A1  1 20 40 A0  1 
1A17C80 	18 70 A0  1 B8 40 A0  1 
1A17C88 	F4 7B A1  1 18 70 A0  1 
1A17C90 	B8 40 A0  1 38 7C A1  1 
1A17C98 	58 46 A0  1 
: dis32  ( -- )  true  is op32?  true  is ad32?  ;
1A17C9C 	 0  0 64 69 
1A17CA0 	73 33 32 85 7C 7C A1  1 
1A17CA8 	20 40 A0  1  4 70 A0  1 
1A17CB0 	B8 40 A0  1 F4 7B A1  1 
1A17CB8 	 4 70 A0  1 B8 40 A0  1 
1A17CC0 	38 7C A1  1 58 46 A0  1 
\ XXX We should also change the register names e.g. from "eax" to "ax"
\ and handle renamed regs, prefix operators,

: get-op  ( -- )  op8@ instruction !  ;
1A17CC8 	 0 67 65 74 2D 6F 70 86 
1A17CD0 	A8 7C A1  1 20 40 A0  1 
1A17CD8 	24 7B A1  1 B4 7A A1  1 
1A17CE0 	54 4D A0  1 58 46 A0  1 

: ibits  ( right-bit #bits -- field )
1A17CE8 	 0  0 69 62 69 74 73 85 
1A17CF0 	D4 7C A1  1 20 40 A0  1 
   instruction @ -rot bits
1A17CF8 	B4 7A A1  1 5C 4C A0  1 
1A17D00 	94 49 A0  1 18 11 A1  1 
;
1A17D08 	58 46 A0  1 
0 value wbit
1A17D0C 	 0  0  0 77 
1A17D10 	62 69 74 84 F4 7C A1  1 
1A17D18 	50 40 A0  1 A0  4  0  0 
: lowbits  ( -- n )  0 3 ibits  ;
1A17D20 	6C 6F 77 62 69 74 73 87 
1A17D28 	18 7D A1  1 20 40 A0  1 
1A17D30 	70 6F A0  1 A0 6F A0  1 
1A17D38 	F4 7C A1  1 58 46 A0  1 
: low4bits ( -- n )  0 4 ibits  ;
1A17D40 	 0  0  0 6C 6F 77 34 62 
1A17D48 	69 74 73 88 2C 7D A1  1 
1A17D50 	20 40 A0  1 70 6F A0  1 
1A17D58 	B0 6F A0  1 F4 7C A1  1 
1A17D60 	58 46 A0  1 
: midbits  ( -- n )  3 3 ibits  ;
1A17D64 	6D 69 64 62 
1A17D68 	69 74 73 87 50 7D A1  1 
1A17D70 	20 40 A0  1 A0 6F A0  1 
1A17D78 	A0 6F A0  1 F4 7C A1  1 
1A17D80 	58 46 A0  1 
: hibits   ( -- n )  6 2 ibits  ;
1A17D84 	 0 68 69 62 
1A17D88 	69 74 73 86 70 7D A1  1 
1A17D90 	20 40 A0  1 D0 6F A0  1 
1A17D98 	90 6F A0  1 F4 7C A1  1 
1A17DA0 	58 46 A0  1 

hex

: .,  ( -- )  ." ,"  ;
1A17DA4 	 0 2E 2C 82 
1A17DA8 	90 7D A1  1 20 40 A0  1 
1A17DB0 	20 7C A0  1  1 2C  0  0 
1A17DB8 	58 46 A0  1 

d# 32 buffer: ea-text
1A17DBC 	65 61 2D 74 
1A17DC0 	65 78 74 87 AC 7D A1  1 
1A17DC8 	B4 A9 A0  1 A4  4  0  0 
1A17DD0 	20  0  0  0 B8 6B A1  1 
: $add-text  ( adr len -- )  ea-text $cat  ;
1A17DD8 	 0  0 24 61 64 64 2D 74 
1A17DE0 	65 78 74 89 C8 7D A1  1 
1A17DE8 	20 40 A0  1 C8 7D A1  1 
1A17DF0 	84 7E A0  1 58 46 A0  1 

d# 34 buffer: disp-buf
1A17DF8 	 0  0  0 64 69 73 70 2D 
1A17E00 	62 75 66 88 E8 7D A1  1 
1A17E08 	B4 A9 A0  1 A8  4  0  0 
1A17E10 	22  0  0  0 C8 7D A1  1 
: ?+  ( -- )
1A17E18 	 0 3F 2B 82  8 7E A1  1 
1A17E20 	20 40 A0  1 
   ea-text c@ 1 >  if  " +" $add-text  then
1A17E24 	C8 7D A1  1 
1A17E28 	C4 4C A0  1 80 6F A0  1 
1A17E30 	 4 48 A0  1 DC 41 A0  1 
1A17E38 	10  0  0  0 9C 53 A0  1 
1A17E40 	 1 2B  0  0 E8 7D A1  1 
;
1A17E48 	58 46 A0  1 
: ?-  ( disp -- )
1A17E4C 	 0 3F 2D 82 
1A17E50 	20 7E A1  1 20 40 A0  1 
   ea-text c@ 1 >  if  " -" $add-text  negate  then
1A17E58 	C8 7D A1  1 C4 4C A0  1 
1A17E60 	80 6F A0  1  4 48 A0  1 
1A17E68 	DC 41 A0  1 14  0  0  0 
1A17E70 	9C 53 A0  1  1 2D  0  0 
1A17E78 	E8 7D A1  1 48 45 A0  1 
;
1A17E80 	58 46 A0  1 
: get-disp  ( mod -- adr len )
1A17E84 	 0  0  0 67 
1A17E88 	65 74 2D 64 69 73 70 88 
1A17E90 	54 7E A1  1 20 40 A0  1 
   case
   0  of  " "  exit    endof
1A17E98 	70 6F A0  1 48 43 A0  1 
1A17EA0 	18  0  0  0 9C 53 A0  1 
1A17EA8 	 0  0  0  0 40 46 A0  1 
1A17EB0 	6C 43 A0  1 50  0  0  0 
   1  of  op8@ bext     endof
1A17EB8 	80 6F A0  1 48 43 A0  1 
1A17EC0 	14  0  0  0 24 7B A1  1 
1A17EC8 	9C 7B A1  1 6C 43 A0  1 
1A17ED0 	34  0  0  0 
   2  of  adv@  ad32? 0=  if  wext  then  endof
1A17ED4 	90 6F A0  1 
1A17ED8 	48 43 A0  1 24  0  0  0 
1A17EE0 	4C 7C A1  1 38 7C A1  1 
1A17EE8 	24 47 A0  1 DC 41 A0  1 
1A17EF0 	 8  0  0  0 C8 7B A1  1 
1A17EF8 	6C 43 A0  1  8  0  0  0 
   endcase
1A17F00 	84 43 A0  1 
   dup 0>=  if  ?+  else  ?-  then  
1A17F04 	40 49 A0  1 
1A17F08 	C4 47 A0  1 DC 41 A0  1 
1A17F10 	10  0  0  0 20 7E A1  1 
1A17F18 	C8 41 A0  1  8  0  0  0 
1A17F20 	54 7E A1  1 
   (u.) disp-buf pack  count
1A17F24 	AC 77 A0  1 
1A17F28 	 8 7E A1  1 DC 52 A0  1 
1A17F30 	BC 53 A0  1 
;
1A17F34 	58 46 A0  1 
\ Used when "w" field contains 0
string-array >reg8
1A17F38 	 0  0 3E 72 65 67 38 85 
1A17F40 	94 7E A1  1 44 15 A1  1 
1A17F48 	 8  0  0  0 28  0  0  0 
," al" ," cl" ," dl" ," bl" ," ah" ," ch" ," dh" ," bh"
1A17F50 	 2 61 6C  0  2 63 6C  0 
1A17F58 	 2 64 6C  0  2 62 6C  0 
1A17F60 	 2 61 68  0  2 63 68  0 
1A17F68 	 2 64 68  0  2 62 68  0 
end-string-array
1A17F70 	 8  0  0  0  C  0  0  0 
1A17F78 	10  0  0  0 14  0  0  0 
1A17F80 	18  0  0  0 1C  0  0  0 
1A17F88 	20  0  0  0 24  0  0  0 

\ Used when the instruction implies a 16-bit register
string-array >reg16
1A17F90 	 0 3E 72 65 67 31 36 86 
1A17F98 	44 7F A1  1 44 15 A1  1 
1A17FA0 	 8  0  0  0 28  0  0  0 
," ax" ," cx" ," dx" ," bx" ," sp" ," bp" ," si" ," di"
1A17FA8 	 2 61 78  0  2 63 78  0 
1A17FB0 	 2 64 78  0  2 62 78  0 
1A17FB8 	 2 73 70  0  2 62 70  0 
1A17FC0 	 2 73 69  0  2 64 69  0 
end-string-array
1A17FC8 	 8  0  0  0  C  0  0  0 
1A17FD0 	10  0  0  0 14  0  0  0 
1A17FD8 	18  0  0  0 1C  0  0  0 
1A17FE0 	20  0  0  0 24  0  0  0 

\ Used when "w" field contains 1, and when there is no "w" field
string-array >regw
1A17FE8 	 0  0 3E 72 65 67 77 85 
1A17FF0 	9C 7F A1  1 44 15 A1  1 
1A17FF8 	 8  0  0  0 48  0  0  0 
\    0       1       2       3       4       5       6       7
," eax" ," ecx" ," edx" ," ebx" ," esp" ," ebp" ," esi" ," edi"
1A18000 	 3 65 61 78  0  0  0  0 
1A18008 	 3 65 63 78  0  0  0  0 
1A18010 	 3 65 64 78  0  0  0  0 
1A18018 	 3 65 62 78  0  0  0  0 
1A18020 	 3 65 73 70  0  0  0  0 
1A18028 	 3 65 62 70  0  0  0  0 
1A18030 	 3 65 73 69  0  0  0  0 
1A18038 	 3 65 64 69  0  0  0  0 
end-string-array
1A18040 	 8  0  0  0 10  0  0  0 
1A18048 	18  0  0  0 20  0  0  0 
1A18050 	28  0  0  0 30  0  0  0 
1A18058 	38  0  0  0 40  0  0  0 

: >reg  ( -- adr len )  >regw count  op32? 0=  if  1 /string  then  ;
1A18060 	 0  0  0 3E 72 65 67 84 
1A18068 	F4 7F A1  1 20 40 A0  1 
1A18070 	F4 7F A1  1 BC 53 A0  1 
1A18078 	F4 7B A1  1 24 47 A0  1 
1A18080 	DC 41 A0  1  C  0  0  0 
1A18088 	80 6F A0  1 3C 85 A0  1 
1A18090 	58 46 A0  1 
: >areg  ( -- adr len )  >regw count  ad32? 0=  if  1 /string  then  ;
1A18094 	 0  0 3E 61 
1A18098 	72 65 67 85 6C 80 A1  1 
1A180A0 	20 40 A0  1 F4 7F A1  1 
1A180A8 	BC 53 A0  1 38 7C A1  1 
1A180B0 	24 47 A0  1 DC 41 A0  1 
1A180B8 	 C  0  0  0 80 6F A0  1 
1A180C0 	3C 85 A0  1 58 46 A0  1 

: >greg  ( -- adr len )  wbit  if  >reg  else  >reg8 count  then  ;
1A180C8 	 0  0 3E 67 72 65 67 85 
1A180D0 	A0 80 A1  1 20 40 A0  1 
1A180D8 	18 7D A1  1 DC 41 A0  1 
1A180E0 	10  0  0  0 6C 80 A1  1 
1A180E8 	C8 41 A0  1  C  0  0  0 
1A180F0 	44 7F A1  1 BC 53 A0  1 
1A180F8 	58 46 A0  1 

: .reg   ( reg -- )  >reg  type  ;
1A180FC 	 0  0  0 2E 
1A18100 	72 65 67 84 D4 80 A1  1 
1A18108 	20 40 A0  1 6C 80 A1  1 
1A18110 	 4 6C A0  1 58 46 A0  1 
: .reg8  ( reg -- )  >reg8 type  ;
1A18118 	 0  0 2E 72 65 67 38 85 
1A18120 	 8 81 A1  1 20 40 A0  1 
1A18128 	44 7F A1  1  4 6C A0  1 
1A18130 	58 46 A0  1 

string-array  >scale
1A18134 	 0 3E 73 63 
1A18138 	61 6C 65 86 24 81 A1  1 
1A18140 	44 15 A1  1  4  0  0  0 
1A18148 	18  0  0  0 
   ," "  ," *2"  ," *4"  ," *8"
1A1814C 	 0  0  0  0 
1A18150 	 2 2A 32  0  2 2A 34  0 
1A18158 	 2 2A 38  0 
end-string-array
1A1815C 	 8  0  0  0 
1A18160 	 C  0  0  0 10  0  0  0 
1A18168 	14  0  0  0 

: get-scaled  ( -- )
1A1816C 	 0 67 65 74 
1A18170 	2D 73 63 61 6C 65 64 8A 
1A18178 	40 81 A1  1 20 40 A0  1 
   hibits  midbits                       ( scale index-reg )
1A18180 	90 7D A1  1 70 7D A1  1 
   dup 4 =  if                           ( scale index-reg )
1A18188 	40 49 A0  1 B0 6F A0  1 
1A18190 	24 48 A0  1 DC 41 A0  1 
1A18198 	2C  0  0  0 
      drop                               ( scale )
1A1819C 	30 49 A0  1 
      if  ?+  " UNDEF" $add-text  then   ( )
1A181A0 	DC 41 A0  1 18  0  0  0 
1A181A8 	20 7E A1  1 9C 53 A0  1 
1A181B0 	 5 55 4E 44 45 46  0  0 
1A181B8 	E8 7D A1  1 
   else                                  ( scale index-reg )
1A181BC 	C8 41 A0  1 
1A181C0 	1C  0  0  0 
      ?+  >areg $add-text                ( scale )
1A181C4 	20 7E A1  1 
1A181C8 	A0 80 A1  1 E8 7D A1  1 
      >scale count  $add-text            ( )
1A181D0 	40 81 A1  1 BC 53 A0  1 
1A181D8 	E8 7D A1  1 
   then                                  ( )
;
1A181DC 	58 46 A0  1 
: .[ " ["  $add-text ;
1A181E0 	 0 2E 5B 82 7C 81 A1  1 
1A181E8 	20 40 A0  1 9C 53 A0  1 
1A181F0 	 1 5B  0  0 E8 7D A1  1 
1A181F8 	58 46 A0  1 
: .] " ]"  $add-text ;
1A181FC 	 0 2E 5D 82 
1A18200 	E8 81 A1  1 20 40 A0  1 
1A18208 	9C 53 A0  1  1 5D  0  0 
1A18210 	E8 7D A1  1 58 46 A0  1 
: add-disp  ( sib? reg mod -- )
1A18218 	 0  0  0 61 64 64 2D 64 
1A18220 	69 73 70 88  4 82 A1  1 
1A18228 	20 40 A0  1 
   .[                            ( sib? reg mod )
1A1822C 	E8 81 A1  1 
   2dup 0<>  swap 5 <>  or  if   ( sib? reg mod )   \ D32
1A18230 	C0 49 A0  1 44 47 A0  1 
1A18238 	68 49 A0  1 C0 6F A0  1 
1A18240 	44 48 A0  1 70 44 A0  1 
1A18248 	DC 41 A0  1 18  0  0  0 
      swap >areg $add-text       ( sib? mod )
1A18250 	68 49 A0  1 A0 80 A1  1 
1A18258 	E8 7D A1  1 
   else                          ( sib? reg mod )
1A1825C 	C8 41 A0  1 
1A18260 	 C  0  0  0 
      2drop 2                    ( sib? mod=2 )
1A18264 	AC 49 A0  1 
1A18268 	90 6F A0  1 
   then                          ( sib? mod )
   swap  if  get-scaled  then    ( mod )
1A1826C 	68 49 A0  1 
1A18270 	DC 41 A0  1  8  0  0  0 
1A18278 	7C 81 A1  1 
   get-disp  $add-text           ( )
1A1827C 	94 7E A1  1 
1A18280 	E8 7D A1  1 
   .]                            ( )
1A18284 	 4 82 A1  1 
;
1A18288 	58 46 A0  1 

: .ea32  ( reg mod -- )
1A1828C 	 0  0 2E 65 
1A18290 	61 33 32 85 28 82 A1  1 
1A18298 	20 40 A0  1 
   >r                                    ( reg r: mod )
1A1829C 	BC 45 A0  1 
   dup 4 =  if                           ( reg )     \ s-i-b
1A182A0 	40 49 A0  1 B0 6F A0  1 
1A182A8 	24 48 A0  1 DC 41 A0  1 
1A182B0 	1C  0  0  0 
      drop  get-op  true  lowbits        ( true reg )
1A182B4 	30 49 A0  1 
1A182B8 	D4 7C A1  1  4 70 A0  1 
1A182C0 	2C 7D A1  1 
   else                                  ( reg )     \ displaced
1A182C4 	C8 41 A0  1 
1A182C8 	 C  0  0  0 
      false swap                         ( false reg )
1A182CC 	18 70 A0  1 
1A182D0 	68 49 A0  1 
   then                                  ( sib? reg )
   r> add-disp
1A182D4 	D0 45 A0  1 
1A182D8 	28 82 A1  1 
;
1A182DC 	58 46 A0  1 

string-array modes16
1A182E0 	6D 6F 64 65 73 31 36 87 
1A182E8 	98 82 A1  1 44 15 A1  1 
1A182F0 	 8  0  0  0 58  0  0  0 
   ," [bx+si]"
1A182F8 	 7 5B 62 78 2B 73 69 5D 
1A18300 	 0  0  0  0 
   ," [bx+di]"
1A18304 	 7 5B 62 78 
1A18308 	2B 64 69 5D  0  0  0  0 
   ," [bp+si]"
1A18310 	 7 5B 62 70 2B 73 69 5D 
1A18318 	 0  0  0  0 
   ," [bp+di]"
1A1831C 	 7 5B 62 70 
1A18320 	2B 64 69 5D  0  0  0  0 
   ," [si]"
1A18328 	 4 5B 73 69 5D  0  0  0 
   ," [di]"
1A18330 	 4 5B 64 69 5D  0  0  0 
   ," [bp]"
1A18338 	 4 5B 62 70 5D  0  0  0 
   ," [bx]"
1A18340 	 4 5B 62 78 5D  0  0  0 
end-string-array
1A18348 	 8  0  0  0 14  0  0  0 
1A18350 	20  0  0  0 2C  0  0  0 
1A18358 	38  0  0  0 40  0  0  0 
1A18360 	48  0  0  0 50  0  0  0 

: add-disp16  ( disp -- )
1A18368 	 0 61 64 64 2D 64 69 73 
1A18370 	70 31 36 8A EC 82 A1  1 
1A18378 	20 40 A0  1 
   h# ffff and  (u.) disp-buf pack count  $add-text
1A1837C 	58 41 A0  1 
1A18380 	FF FF  0  0 5C 44 A0  1 
1A18388 	AC 77 A0  1  8 7E A1  1 
1A18390 	DC 52 A0  1 BC 53 A0  1 
1A18398 	E8 7D A1  1 
;
1A1839C 	58 46 A0  1 
: +disp16  ( disp -- )
1A183A0 	2B 64 69 73 70 31 36 87 
1A183A8 	78 83 A1  1 20 40 A0  1 
   dup 0<  if
1A183B0 	40 49 A0  1 64 47 A0  1 
1A183B8 	DC 41 A0  1 1C  0  0  0 
      " -" $add-text  negate
1A183C0 	9C 53 A0  1  1 2D  0  0 
1A183C8 	E8 7D A1  1 48 45 A0  1 
   else
1A183D0 	C8 41 A0  1 10  0  0  0 
      " +" $add-text
1A183D8 	9C 53 A0  1  1 2B  0  0 
1A183E0 	E8 7D A1  1 
   then
   add-disp16
1A183E4 	78 83 A1  1 
;
1A183E8 	58 46 A0  1 

: .ea16  ( reg mod -- )
1A183EC 	 0  0 2E 65 
1A183F0 	61 31 36 85 AC 83 A1  1 
1A183F8 	20 40 A0  1 
   over 6 =  over 0= and  if             ( reg mod )
1A183FC 	54 49 A0  1 
1A18400 	D0 6F A0  1 24 48 A0  1 
1A18408 	54 49 A0  1 24 47 A0  1 
1A18410 	5C 44 A0  1 DC 41 A0  1 
1A18418 	1C  0  0  0 
      \ disp16 only, takes the place of the [bp] mode
      2drop op16@ .[ add-disp16 .] exit
1A1841C 	AC 49 A0  1 
1A18420 	5C 7B A1  1 E8 81 A1  1 
1A18428 	78 83 A1  1  4 82 A1  1 
1A18430 	40 46 A0  1 
   then                                  ( reg mod )
   swap modes16 count $add-text          ( mod )
1A18434 	68 49 A0  1 
1A18438 	EC 82 A1  1 BC 53 A0  1 
1A18440 	E8 7D A1  1 
   case
      1 of  op8@  bext +disp16  endof
1A18444 	80 6F A0  1 
1A18448 	48 43 A0  1 18  0  0  0 
1A18450 	24 7B A1  1 9C 7B A1  1 
1A18458 	AC 83 A1  1 6C 43 A0  1 
1A18460 	28  0  0  0 
      2 of  op16@ wext +disp16  endof
1A18464 	90 6F A0  1 
1A18468 	48 43 A0  1 18  0  0  0 
1A18470 	5C 7B A1  1 C8 7B A1  1 
1A18478 	AC 83 A1  1 6C 43 A0  1 
1A18480 	 8  0  0  0 
   endcase
1A18484 	84 43 A0  1 
;
1A18488 	58 46 A0  1 
: .ea  ( -- )
1A1848C 	2E 65 61 83 
1A18490 	F8 83 A1  1 20 40 A0  1 
   " "  ea-text  place
1A18498 	9C 53 A0  1  0  0  0  0 
1A184A0 	C8 7D A1  1 F0 88 A0  1 
   lowbits  hibits >r                    ( reg ) ( r: mod )
1A184A8 	2C 7D A1  1 90 7D A1  1 
1A184B0 	BC 45 A0  1 
   r@  3 =  if                           ( reg )     \ register direct
1A184B4 	E4 45 A0  1 
1A184B8 	A0 6F A0  1 24 48 A0  1 
1A184C0 	DC 41 A0  1 20  0  0  0 
      >greg $add-text                    ( )
1A184C8 	D4 80 A1  1 E8 7D A1  1 
      r> drop  ea-text ". exit
1A184D0 	D0 45 A0  1 30 49 A0  1 
1A184D8 	C8 7D A1  1 A8 7C A0  1 
1A184E0 	40 46 A0  1 
   then                                  ( reg )
   r> ad32?  if  .ea32  else  .ea16  then
1A184E4 	D0 45 A0  1 
1A184E8 	38 7C A1  1 DC 41 A0  1 
1A184F0 	10  0  0  0 98 82 A1  1 
1A184F8 	C8 41 A0  1  8  0  0  0 
1A18500 	F8 83 A1  1 
   ea-text ".
1A18504 	C8 7D A1  1 
1A18508 	A8 7C A0  1 
;
1A1850C 	58 46 A0  1 
: ,ea  ( -- )  .,  .ea  ;
1A18510 	2C 65 61 83 94 84 A1  1 
1A18518 	20 40 A0  1 AC 7D A1  1 
1A18520 	94 84 A1  1 58 46 A0  1 


\ Display formatting
variable start-column
1A18528 	 0  0  0 73 74 61 72 74 
1A18530 	2D 63 6F 6C 75 6D 6E 8C 
1A18538 	18 85 A1  1 48 40 A0  1 
1A18540 	AC  4  0  0 
: op-col  ( -- )  start-column @  d# 9 +  #out @  -  1 max  spaces  ;
1A18544 	 0 6F 70 2D 
1A18548 	63 6F 6C 86 3C 85 A1  1 
1A18550 	20 40 A0  1 3C 85 A1  1 
1A18558 	5C 4C A0  1 58 41 A0  1 
1A18560 	 9  0  0  0  4 45 A0  1 
1A18568 	5C 6D A0  1 5C 4C A0  1 
1A18570 	18 45 A0  1 80 6F A0  1 
1A18578 	9C 4A A0  1 E8 71 A0  1 
1A18580 	58 46 A0  1 

string-array >segment
1A18584 	 0  0  0 3E 
1A18588 	73 65 67 6D 65 6E 74 88 
1A18590 	50 85 A1  1 44 15 A1  1 
1A18598 	 6  0  0  0 20  0  0  0 
   ," es"  ," cs"  ," ss"  ," ds"  ," fs"  ," gs"
1A185A0 	 2 65 73  0  2 63 73  0 
1A185A8 	 2 73 73  0  2 64 73  0 
1A185B0 	 2 66 73  0  2 67 73  0 
end-string-array
1A185B8 	 8  0  0  0  C  0  0  0 
1A185C0 	10  0  0  0 14  0  0  0 
1A185C8 	18  0  0  0 1C  0  0  0 

string-array >binop
1A185D0 	 0 3E 62 69 6E 6F 70 86 
1A185D8 	94 85 A1  1 44 15 A1  1 
1A185E0 	 8  0  0  0 44  0  0  0 
   ," add"  ," or"  ," adc"  ," sbb"  ," and"  ," sub"  ," xor"  ," cmp"   
1A185E8 	 3 61 64 64  0  0  0  0 
1A185F0 	 2 6F 72  0  3 61 64 63 
1A185F8 	 0  0  0  0  3 73 62 62 
1A18600 	 0  0  0  0  3 61 6E 64 
1A18608 	 0  0  0  0  3 73 75 62 
1A18610 	 0  0  0  0  3 78 6F 72 
1A18618 	 0  0  0  0  3 63 6D 70 
1A18620 	 0  0  0  0 
end-string-array
1A18624 	 8  0  0  0 
1A18628 	10  0  0  0 14  0  0  0 
1A18630 	1C  0  0  0 24  0  0  0 
1A18638 	2C  0  0  0 34  0  0  0 
1A18640 	3C  0  0  0 

: .binop  ( n -- )  >binop ". op-col  ;
1A18644 	 0 2E 62 69 
1A18648 	6E 6F 70 86 DC 85 A1  1 
1A18650 	20 40 A0  1 DC 85 A1  1 
1A18658 	A8 7C A0  1 50 85 A1  1 
1A18660 	58 46 A0  1 

string-array >unop
1A18664 	 0  0 3E 75 
1A18668 	6E 6F 70 85 50 86 A1  1 
1A18670 	44 15 A1  1  4  0  0  0 
1A18678 	28  0  0  0 
   ," inc"  ," dec"  ," push"  ," pop"
1A1867C 	 3 69 6E 63 
1A18680 	 0  0  0  0  3 64 65 63 
1A18688 	 0  0  0  0  4 70 75 73 
1A18690 	68  0  0  0  3 70 6F 70 
1A18698 	 0  0  0  0 
end-string-array
1A1869C 	 8  0  0  0 
1A186A0 	10  0  0  0 18  0  0  0 
1A186A8 	20  0  0  0 

: .segment  ( -- )  3 2 ibits  >segment ".  ;
1A186AC 	 0  0  0 2E 
1A186B0 	73 65 67 6D 65 6E 74 88 
1A186B8 	70 86 A1  1 20 40 A0  1 
1A186C0 	A0 6F A0  1 90 6F A0  1 
1A186C8 	F4 7C A1  1 94 85 A1  1 
1A186D0 	A8 7C A0  1 58 46 A0  1 

string-array >adjust
1A186D8 	3E 61 64 6A 75 73 74 87 
1A186E0 	BC 86 A1  1 44 15 A1  1 
1A186E8 	 4  0  0  0 28  0  0  0 
   ," daa"  ," das"  ," aaa"  ," aas"
1A186F0 	 3 64 61 61  0  0  0  0 
1A186F8 	 3 64 61 73  0  0  0  0 
1A18700 	 3 61 61 61  0  0  0  0 
1A18708 	 3 61 61 73  0  0  0  0 
end-string-array
1A18710 	 8  0  0  0 10  0  0  0 
1A18718 	18  0  0  0 20  0  0  0 
: .fescape  ( -- )  ." Later, dude"  ;
1A18720 	 0  0  0 2E 66 65 73 63 
1A18728 	61 70 65 88 E4 86 A1  1 
1A18730 	20 40 A0  1 20 7C A0  1 
1A18738 	 B 4C 61 74 65 72 2C 20 
1A18740 	64 75 64 65  0  0  0  0 
1A18748 	58 46 A0  1 

0 value reg-field
1A1874C 	 0  0 72 65 
1A18750 	67 2D 66 69 65 6C 64 89 
1A18758 	30 87 A1  1 50 40 A0  1 
1A18760 	B0  4  0  0 
: get-ea  ( -- )  get-op  midbits  is reg-field  ;
1A18764 	 0 67 65 74 
1A18768 	2D 65 61 86 5C 87 A1  1 
1A18770 	20 40 A0  1 D4 7C A1  1 
1A18778 	70 7D A1  1 B8 40 A0  1 
1A18780 	5C 87 A1  1 58 46 A0  1 

: sreg  ( -- )  reg-field  >segment ".  ;
1A18788 	 0  0  0 73 72 65 67 84 
1A18790 	70 87 A1  1 20 40 A0  1 
1A18798 	5C 87 A1  1 94 85 A1  1 
1A187A0 	A8 7C A0  1 58 46 A0  1 
: .mm   ( reg# -- )  ." mm" (.) type  ;
1A187A8 	2E 6D 6D 83 94 87 A1  1 
1A187B0 	20 40 A0  1 20 7C A0  1 
1A187B8 	 2 6D 6D  0 10 78 A0  1 
1A187C0 	 4 6C A0  1 58 46 A0  1 
: mreg  ( -- )  reg-field  .mm  ;
1A187C8 	 0  0  0 6D 72 65 67 84 
1A187D0 	B0 87 A1  1 20 40 A0  1 
1A187D8 	5C 87 A1  1 B0 87 A1  1 
1A187E0 	58 46 A0  1 
: .mea  ( -- )  hibits 3 =  if  lowbits .mm  else  .ea  then  ;
1A187E4 	 0  0  0 2E 
1A187E8 	6D 65 61 84 D4 87 A1  1 
1A187F0 	20 40 A0  1 90 7D A1  1 
1A187F8 	A0 6F A0  1 24 48 A0  1 
1A18800 	DC 41 A0  1 14  0  0  0 
1A18808 	2C 7D A1  1 B0 87 A1  1 
1A18810 	C8 41 A0  1  8  0  0  0 
1A18818 	94 84 A1  1 58 46 A0  1 

: gb/v  ( -- )  reg-field  >greg type  ;
1A18820 	 0  0  0 67 62 2F 76 84 
1A18828 	F0 87 A1  1 20 40 A0  1 
1A18830 	5C 87 A1  1 D4 80 A1  1 
1A18838 	 4 6C A0  1 58 46 A0  1 
: ib    ( -- )  op8@ bext  (.) type  ;
1A18840 	 0 69 62 82 2C 88 A1  1 
1A18848 	20 40 A0  1 24 7B A1  1 
1A18850 	9C 7B A1  1 10 78 A0  1 
1A18858 	 4 6C A0  1 58 46 A0  1 
: ,ib  ( -- )  .,  ib  ;
1A18860 	2C 69 62 83 48 88 A1  1 
1A18868 	20 40 A0  1 AC 7D A1  1 
1A18870 	48 88 A1  1 58 46 A0  1 
: iub   ( -- )  op8@       (.) type  ;
1A18878 	69 75 62 83 68 88 A1  1 
1A18880 	20 40 A0  1 24 7B A1  1 
1A18888 	10 78 A0  1  4 6C A0  1 
1A18890 	58 46 A0  1 
: iw    ( -- )  op16@ (.) type  ;
1A18894 	 0 69 77 82 
1A18898 	80 88 A1  1 20 40 A0  1 
1A188A0 	5C 7B A1  1 10 78 A0  1 
1A188A8 	 4 6C A0  1 58 46 A0  1 
: iv    ( -- )  opv@ (.) type  ;
1A188B0 	 0 69 76 82 9C 88 A1  1 
1A188B8 	20 40 A0  1  8 7C A1  1 
1A188C0 	10 78 A0  1  4 6C A0  1 
1A188C8 	58 46 A0  1 
: iuv   ( -- )  adv@ (u.) type  ;
1A188CC 	69 75 76 83 
1A188D0 	B8 88 A1  1 20 40 A0  1 
1A188D8 	4C 7C A1  1 AC 77 A0  1 
1A188E0 	 4 6C A0  1 58 46 A0  1 
: ,ib/v ( -- )  .,  wbit  if  opv@  else  op8@  then  (u.) type  ;
1A188E8 	 0  0 2C 69 62 2F 76 85 
1A188F0 	D4 88 A1  1 20 40 A0  1 
1A188F8 	AC 7D A1  1 18 7D A1  1 
1A18900 	DC 41 A0  1 10  0  0  0 
1A18908 	 8 7C A1  1 C8 41 A0  1 
1A18910 	 8  0  0  0 24 7B A1  1 
1A18918 	AC 77 A0  1  4 6C A0  1 
1A18920 	58 46 A0  1 
: al/x  ( -- )  wbit  if  ." eax"  else  ." al"  then  ;
1A18924 	 0  0  0 61 
1A18928 	6C 2F 78 84 F4 88 A1  1 
1A18930 	20 40 A0  1 18 7D A1  1 
1A18938 	DC 41 A0  1 18  0  0  0 
1A18940 	20 7C A0  1  3 65 61 78 
1A18948 	 0  0  0  0 C8 41 A0  1 
1A18950 	 C  0  0  0 20 7C A0  1 
1A18958 	 2 61 6C  0 58 46 A0  1 
: ,al/x ( -- )  .,  al/x  ;
1A18960 	 0  0 2C 61 6C 2F 78 85 
1A18968 	30 89 A1  1 20 40 A0  1 
1A18970 	AC 7D A1  1 30 89 A1  1 
1A18978 	58 46 A0  1 
: ,cl  ( -- )  .,  ." cl"  ;
1A1897C 	2C 63 6C 83 
1A18980 	6C 89 A1  1 20 40 A0  1 
1A18988 	AC 7D A1  1 20 7C A0  1 
1A18990 	 2 63 6C  0 58 46 A0  1 

: .mode  ( mode -- )
1A18998 	 0  0 2E 6D 6F 64 65 85 
1A189A0 	84 89 A1  1 20 40 A0  1 
   1 >>
1A189A8 	80 6F A0  1 DC 44 A0  1 
   case
      0  of  get-ea  .ea   .,  gb/v  endof
1A189B0 	70 6F A0  1 48 43 A0  1 
1A189B8 	1C  0  0  0 70 87 A1  1 
1A189C0 	94 84 A1  1 AC 7D A1  1 
1A189C8 	2C 88 A1  1 6C 43 A0  1 
1A189D0 	44  0  0  0 
      1  of  get-ea  gb/v  ,ea       endof
1A189D4 	80 6F A0  1 
1A189D8 	48 43 A0  1 18  0  0  0 
1A189E0 	70 87 A1  1 2C 88 A1  1 
1A189E8 	18 85 A1  1 6C 43 A0  1 
1A189F0 	24  0  0  0 
      2  of          al/x  ,ib/v     endof
1A189F4 	90 6F A0  1 
1A189F8 	48 43 A0  1 14  0  0  0 
1A18A00 	30 89 A1  1 F4 88 A1  1 
1A18A08 	6C 43 A0  1  8  0  0  0 
   endcase
1A18A10 	84 43 A0  1 
;
1A18A14 	58 46 A0  1 
: .push  ( -- )  ." push" op-col  ;
1A18A18 	 0  0 2E 70 75 73 68 85 
1A18A20 	A4 89 A1  1 20 40 A0  1 
1A18A28 	20 7C A0  1  4 70 75 73 
1A18A30 	68  0  0  0 50 85 A1  1 
1A18A38 	58 46 A0  1 
: .pop   ( -- )  ." pop"  op-col  ;
1A18A3C 	 0  0  0 2E 
1A18A40 	70 6F 70 84 24 8A A1  1 
1A18A48 	20 40 A0  1 20 7C A0  1 
1A18A50 	 3 70 6F 70  0  0  0  0 
1A18A58 	50 85 A1  1 58 46 A0  1 

string-array >cond
1A18A60 	 0  0 3E 63 6F 6E 64 85 
1A18A68 	48 8A A1  1 44 15 A1  1 
1A18A70 	10  0  0  0 48  0  0  0 
   ," o"  ," no"  ," b"  ," ae"  ," e"  ," ne"  ," be"  ," a"
1A18A78 	 1 6F  0  0  2 6E 6F  0 
1A18A80 	 1 62  0  0  2 61 65  0 
1A18A88 	 1 65  0  0  2 6E 65  0 
1A18A90 	 2 62 65  0  1 61  0  0 
   ," s"  ," ns"  ," pe" ," po"  ," l"  ," ge"  ," le"  ," g"
1A18A98 	 1 73  0  0  2 6E 73  0 
1A18AA0 	 2 70 65  0  2 70 6F  0 
1A18AA8 	 1 6C  0  0  2 67 65  0 
1A18AB0 	 2 6C 65  0  1 67  0  0 
end-string-array
1A18AB8 	 8  0  0  0  C  0  0  0 
1A18AC0 	10  0  0  0 14  0  0  0 
1A18AC8 	18  0  0  0 1C  0  0  0 
1A18AD0 	20  0  0  0 24  0  0  0 
1A18AD8 	28  0  0  0 2C  0  0  0 
1A18AE0 	30  0  0  0 34  0  0  0 
1A18AE8 	38  0  0  0 3C  0  0  0 
1A18AF0 	40  0  0  0 44  0  0  0 

: showbranch  ( offset -- )
1A18AF8 	 0 73 68 6F 77 62 72 61 
1A18B00 	6E 63 68 8A 6C 8A A1  1 
1A18B08 	20 40 A0  1 
   pc @  op32?  if  ( offset pc )
1A18B0C 	DC 7A A1  1 
1A18B10 	5C 4C A0  1 F4 7B A1  1 
1A18B18 	DC 41 A0  1 10  0  0  0 
      +                    ( pc' )
1A18B20 	 4 45 A0  1 
   else                    ( offset pc )
1A18B24 	C8 41 A0  1 
1A18B28 	24  0  0  0 
      lwsplit  -rot        ( pc.high offset pc.low )
1A18B2C 	A0 4F A0  1 
1A18B30 	94 49 A0  1 
      + h# ffff and        ( pc.high pc.low' )
1A18B34 	 4 45 A0  1 
1A18B38 	58 41 A0  1 FF FF  0  0 
1A18B40 	5C 44 A0  1 
      swap wljoin          ( pc' )
1A18B44 	68 49 A0  1 
1A18B48 	D4 4F A0  1 
   then                    ( pc' )
   dup branch-target !  showaddr
1A18B4C 	40 49 A0  1 
1A18B50 	F8 7A A1  1 54 4D A0  1 
1A18B58 	30 13 A1  1 
;
1A18B5C 	58 46 A0  1 
: jb  ( -- )  op8@ bext  showbranch  ;
1A18B60 	 0 6A 62 82  8 8B A1  1 
1A18B68 	20 40 A0  1 24 7B A1  1 
1A18B70 	9C 7B A1  1  8 8B A1  1 
1A18B78 	58 46 A0  1 
: jv  ( -- )  opv@  showbranch  ;
1A18B7C 	 0 6A 76 82 
1A18B80 	68 8B A1  1 20 40 A0  1 
1A18B88 	 8 7C A1  1  8 8B A1  1 
1A18B90 	58 46 A0  1 

: .jcc  ( -- )  ." j"  low4bits >cond ".  op-col jb  ;
1A18B94 	 0  0  0 2E 
1A18B98 	6A 63 63 84 84 8B A1  1 
1A18BA0 	20 40 A0  1 20 7C A0  1 
1A18BA8 	 1 6A  0  0 50 7D A1  1 
1A18BB0 	6C 8A A1  1 A8 7C A0  1 
1A18BB8 	50 85 A1  1 68 8B A1  1 
1A18BC0 	58 46 A0  1 
: ea,g  ( -- )  get-ea  .ea ., gb/v  ;
1A18BC4 	 0  0  0 65 
1A18BC8 	61 2C 67 84 A0 8B A1  1 
1A18BD0 	20 40 A0  1 70 87 A1  1 
1A18BD8 	94 84 A1  1 AC 7D A1  1 
1A18BE0 	2C 88 A1  1 58 46 A0  1 
: g,ea  ( -- )  get-ea  gb/v ,ea  ;
1A18BE8 	 0  0  0 67 2C 65 61 84 
1A18BF0 	D0 8B A1  1 20 40 A0  1 
1A18BF8 	70 87 A1  1 2C 88 A1  1 
1A18C00 	18 85 A1  1 58 46 A0  1 

: decode-op  ( -- high4bits )  get-op   0 1 ibits  is wbit  4 4 ibits   ;
1A18C08 	 0  0 64 65 63 6F 64 65 
1A18C10 	2D 6F 70 89 F4 8B A1  1 
1A18C18 	20 40 A0  1 D4 7C A1  1 
1A18C20 	70 6F A0  1 80 6F A0  1 
1A18C28 	F4 7C A1  1 B8 40 A0  1 
1A18C30 	18 7D A1  1 B0 6F A0  1 
1A18C38 	B0 6F A0  1 F4 7C A1  1 
1A18C40 	58 46 A0  1 

string-array >grp6
1A18C44 	 0  0 3E 67 
1A18C48 	72 70 36 85 18 8C A1  1 
1A18C50 	44 15 A1  1  6  0  0  0 
1A18C58 	38  0  0  0 
   ," sldt"  ," str"  ," lldt"  ," ltr"  ," verr"  ," verw"
1A18C5C 	 4 73 6C 64 
1A18C60 	74  0  0  0  3 73 74 72 
1A18C68 	 0  0  0  0  4 6C 6C 64 
1A18C70 	74  0  0  0  3 6C 74 72 
1A18C78 	 0  0  0  0  4 76 65 72 
1A18C80 	72  0  0  0  4 76 65 72 
1A18C88 	77  0  0  0 
end-string-array
1A18C8C 	 8  0  0  0 
1A18C90 	10  0  0  0 18  0  0  0 
1A18C98 	20  0  0  0 28  0  0  0 
1A18CA0 	30  0  0  0 
string-array >grp7
1A18CA4 	 0  0 3E 67 
1A18CA8 	72 70 37 85 50 8C A1  1 
1A18CB0 	44 15 A1  1  8  0  0  0 
1A18CB8 	48  0  0  0 
   ," sgdt" ," sidt" ," lgdt" ," lidt" ," smsw" ," Unimp" ," lmsw" ," invlpg"
1A18CBC 	 4 73 67 64 
1A18CC0 	74  0  0  0  4 73 69 64 
1A18CC8 	74  0  0  0  4 6C 67 64 
1A18CD0 	74  0  0  0  4 6C 69 64 
1A18CD8 	74  0  0  0  4 73 6D 73 
1A18CE0 	77  0  0  0  5 55 6E 69 
1A18CE8 	6D 70  0  0  4 6C 6D 73 
1A18CF0 	77  0  0  0  6 69 6E 76 
1A18CF8 	6C 70 67  0 
end-string-array
1A18CFC 	 8  0  0  0 
1A18D00 	10  0  0  0 18  0  0  0 
1A18D08 	20  0  0  0 28  0  0  0 
1A18D10 	30  0  0  0 38  0  0  0 
1A18D18 	40  0  0  0 
string-array >grp8
1A18D1C 	 0  0 3E 67 
1A18D20 	72 70 38 85 B0 8C A1  1 
1A18D28 	44 15 A1  1  8  0  0  0 
1A18D30 	34  0  0  0 
   ," "  ," "  ," "  ," "  ," bt"  ," bts"  ," btr"  ," btc"
1A18D34 	 0  0  0  0 
1A18D38 	 0  0  0  0  0  0  0  0 
1A18D40 	 0  0  0  0  2 62 74  0 
1A18D48 	 3 62 74 73  0  0  0  0 
1A18D50 	 3 62 74 72  0  0  0  0 
1A18D58 	 3 62 74 63  0  0  0  0 
end-string-array
1A18D60 	 8  0  0  0  C  0  0  0 
1A18D68 	10  0  0  0 14  0  0  0 
1A18D70 	18  0  0  0 1C  0  0  0 
1A18D78 	24  0  0  0 2C  0  0  0 

: .unimp  ( -- )  ." Unimp"  ;
1A18D80 	 0 2E 75 6E 69 6D 70 86 
1A18D88 	28 8D A1  1 20 40 A0  1 
1A18D90 	20 7C A0  1  5 55 6E 69 
1A18D98 	6D 70  0  0 58 46 A0  1 

: ew  ( -- )  .ea  ;  \ XXX should print, e.g. BX not eBX
1A18DA0 	 0 65 77 82 8C 8D A1  1 
1A18DA8 	20 40 A0  1 94 84 A1  1 
1A18DB0 	58 46 A0  1 
: 2b0op  ( -- )
1A18DB4 	 0  0 32 62 
1A18DB8 	30 6F 70 85 A8 8D A1  1 
1A18DC0 	20 40 A0  1 
   low4bits  case
1A18DC4 	50 7D A1  1 
      0 of  get-ea  midbits >grp6 ".  op-col  ew  endof
1A18DC8 	70 6F A0  1 48 43 A0  1 
1A18DD0 	24  0  0  0 70 87 A1  1 
1A18DD8 	70 7D A1  1 50 8C A1  1 
1A18DE0 	A8 7C A0  1 50 85 A1  1 
1A18DE8 	A8 8D A1  1 6C 43 A0  1 
1A18DF0 	 4  1  0  0 
      1 of  get-ea  midbits >grp7 ".  op-col  ew  endof
1A18DF4 	80 6F A0  1 
1A18DF8 	48 43 A0  1 24  0  0  0 
1A18E00 	70 87 A1  1 70 7D A1  1 
1A18E08 	B0 8C A1  1 A8 7C A0  1 
1A18E10 	50 85 A1  1 A8 8D A1  1 
1A18E18 	6C 43 A0  1 D8  0  0  0 
      2 of  ." lar"  op-col  1 is wbit  g,ea  endof
1A18E20 	90 6F A0  1 48 43 A0  1 
1A18E28 	2C  0  0  0 20 7C A0  1 
1A18E30 	 3 6C 61 72  0  0  0  0 
1A18E38 	50 85 A1  1 80 6F A0  1 
1A18E40 	B8 40 A0  1 18 7D A1  1 
1A18E48 	F4 8B A1  1 6C 43 A0  1 
1A18E50 	A4  0  0  0 
      3 of  ." lsr"  op-col  1 is wbit  g,ea  endof
1A18E54 	A0 6F A0  1 
1A18E58 	48 43 A0  1 2C  0  0  0 
1A18E60 	20 7C A0  1  3 6C 73 72 
1A18E68 	 0  0  0  0 50 85 A1  1 
1A18E70 	80 6F A0  1 B8 40 A0  1 
1A18E78 	18 7D A1  1 F4 8B A1  1 
1A18E80 	6C 43 A0  1 70  0  0  0 
      6 of  ." clts"  endof
1A18E88 	D0 6F A0  1 48 43 A0  1 
1A18E90 	18  0  0  0 20 7C A0  1 
1A18E98 	 4 63 6C 74 73  0  0  0 
1A18EA0 	6C 43 A0  1 50  0  0  0 
      8 of  ." invd"  endof
1A18EA8 	F0 6F A0  1 48 43 A0  1 
1A18EB0 	18  0  0  0 20 7C A0  1 
1A18EB8 	 4 69 6E 76 64  0  0  0 
1A18EC0 	6C 43 A0  1 30  0  0  0 
      9 of  ." wbinvd"  endof
1A18EC8 	58 41 A0  1  9  0  0  0 
1A18ED0 	48 43 A0  1 18  0  0  0 
1A18ED8 	20 7C A0  1  6 77 62 69 
1A18EE0 	6E 76 64  0 6C 43 A0  1 
1A18EE8 	 C  0  0  0 
         .unimp
1A18EEC 	8C 8D A1  1 
   endcase
1A18EF0 	84 43 A0  1 
;   
1A18EF4 	58 46 A0  1 
: .mov  ( -- )  ." mov"  op-col  ;
1A18EF8 	 0  0  0 2E 6D 6F 76 84 
1A18F00 	C0 8D A1  1 20 40 A0  1 
1A18F08 	20 7C A0  1  3 6D 6F 76 
1A18F10 	 0  0  0  0 50 85 A1  1 
1A18F18 	58 46 A0  1 
: .byte  ( -- )  ." byte ptr "  ;
1A18F1C 	 0  0 2E 62 
1A18F20 	79 74 65 85  4 8F A1  1 
1A18F28 	20 40 A0  1 20 7C A0  1 
1A18F30 	 9 62 79 74 65 20 70 74 
1A18F38 	72 20  0  0 58 46 A0  1 
\ Don't bother to say "byte" for register direct addressing mode
: ?.byte  ( -- )  hibits 3 <>  wbit 0=  and  if  .byte  then  ;
1A18F40 	 0 3F 2E 62 79 74 65 86 
1A18F48 	28 8F A1  1 20 40 A0  1 
1A18F50 	90 7D A1  1 A0 6F A0  1 
1A18F58 	44 48 A0  1 18 7D A1  1 
1A18F60 	24 47 A0  1 5C 44 A0  1 
1A18F68 	DC 41 A0  1  8  0  0  0 
1A18F70 	28 8F A1  1 58 46 A0  1 

: .r#  ( -- )  reg-field (.) type  ;
1A18F78 	2E 72 23 83 4C 8F A1  1 
1A18F80 	20 40 A0  1 5C 87 A1  1 
1A18F88 	10 78 A0  1  4 6C A0  1 
1A18F90 	58 46 A0  1 
: movspec  ( -- )
1A18F94 	6D 6F 76 73 
1A18F98 	70 65 63 87 80 8F A1  1 
1A18FA0 	20 40 A0  1 
   .mov
1A18FA4 	 4 8F A1  1 
   1 is wbit		\ These are always 32 bits
1A18FA8 	80 6F A0  1 B8 40 A0  1 
1A18FB0 	18 7D A1  1 
   low4bits  get-ea  case
1A18FB4 	50 7D A1  1 
1A18FB8 	70 87 A1  1 
      \ XXX Warning - the 386 and 486 books disagree about the
      \ operand order of these instructions.
      2 of   ." cr" .r#  ,ea       endof
1A18FBC 	90 6F A0  1 
1A18FC0 	48 43 A0  1 1C  0  0  0 
1A18FC8 	20 7C A0  1  2 63 72  0 
1A18FD0 	80 8F A1  1 18 85 A1  1 
1A18FD8 	6C 43 A0  1 CC  0  0  0 
      3 of   ." dr" .r#  ,ea       endof
1A18FE0 	A0 6F A0  1 48 43 A0  1 
1A18FE8 	1C  0  0  0 20 7C A0  1 
1A18FF0 	 2 64 72  0 80 8F A1  1 
1A18FF8 	18 85 A1  1 6C 43 A0  1 
1A19000 	A8  0  0  0 
      6 of   ." tr" .r#  ,ea       endof
1A19004 	D0 6F A0  1 
1A19008 	48 43 A0  1 1C  0  0  0 
1A19010 	20 7C A0  1  2 74 72  0 
1A19018 	80 8F A1  1 18 85 A1  1 
1A19020 	6C 43 A0  1 84  0  0  0 
      0 of   .ea  .,  ." cr" .r#   endof
1A19028 	70 6F A0  1 48 43 A0  1 
1A19030 	20  0  0  0 94 84 A1  1 
1A19038 	AC 7D A1  1 20 7C A0  1 
1A19040 	 2 63 72  0 80 8F A1  1 
1A19048 	6C 43 A0  1 5C  0  0  0 
      1 of   .ea  .,  ." dr" .r#   endof
1A19050 	80 6F A0  1 48 43 A0  1 
1A19058 	20  0  0  0 94 84 A1  1 
1A19060 	AC 7D A1  1 20 7C A0  1 
1A19068 	 2 64 72  0 80 8F A1  1 
1A19070 	6C 43 A0  1 34  0  0  0 
      4 of   .ea  .,  ." tr" .r#   endof
1A19078 	B0 6F A0  1 48 43 A0  1 
1A19080 	20  0  0  0 94 84 A1  1 
1A19088 	AC 7D A1  1 20 7C A0  1 
1A19090 	 2 74 72  0 80 8F A1  1 
1A19098 	6C 43 A0  1  C  0  0  0 
         .unimp
1A190A0 	8C 8D A1  1 
   endcase
1A190A4 	84 43 A0  1 
;
1A190A8 	58 46 A0  1 
: 2baop  ( -- )
1A190AC 	 0  0 32 62 
1A190B0 	61 6F 70 85 A0 8F A1  1 
1A190B8 	20 40 A0  1 
   low4bits  case
1A190BC 	50 7D A1  1 
      0 of  .push  ." fs"  endof
1A190C0 	70 6F A0  1 48 43 A0  1 
1A190C8 	18  0  0  0 24 8A A1  1 
1A190D0 	20 7C A0  1  2 66 73  0 
1A190D8 	6C 43 A0  1 74  2  0  0 
      1 of  .pop   ." fs"  endof
1A190E0 	80 6F A0  1 48 43 A0  1 
1A190E8 	18  0  0  0 48 8A A1  1 
1A190F0 	20 7C A0  1  2 66 73  0 
1A190F8 	6C 43 A0  1 54  2  0  0 
      2 of  ." cpuid"      endof
1A19100 	90 6F A0  1 48 43 A0  1 
1A19108 	18  0  0  0 20 7C A0  1 
1A19110 	 5 63 70 75 69 64  0  0 
1A19118 	6C 43 A0  1 34  2  0  0 
      3 of  ." bt"   op-col             ea,g  endof
1A19120 	A0 6F A0  1 48 43 A0  1 
1A19128 	1C  0  0  0 20 7C A0  1 
1A19130 	 2 62 74  0 50 85 A1  1 
1A19138 	D0 8B A1  1 6C 43 A0  1 
1A19140 	10  2  0  0 
      4 of  ." shld" op-col  1 is wbit  ea,g  ,ib  endof
1A19144 	B0 6F A0  1 
1A19148 	48 43 A0  1 30  0  0  0 
1A19150 	20 7C A0  1  4 73 68 6C 
1A19158 	64  0  0  0 50 85 A1  1 
1A19160 	80 6F A0  1 B8 40 A0  1 
1A19168 	18 7D A1  1 D0 8B A1  1 
1A19170 	68 88 A1  1 6C 43 A0  1 
1A19178 	D8  1  0  0 
      5 of  ." shld" op-col  1 is wbit  ea,g  ,cl  endof
1A1917C 	C0 6F A0  1 
1A19180 	48 43 A0  1 30  0  0  0 
1A19188 	20 7C A0  1  4 73 68 6C 
1A19190 	64  0  0  0 50 85 A1  1 
1A19198 	80 6F A0  1 B8 40 A0  1 
1A191A0 	18 7D A1  1 D0 8B A1  1 
1A191A8 	84 89 A1  1 6C 43 A0  1 
1A191B0 	A0  1  0  0 
      6 of  ." cmpxchg" op-col          ea,g  endof
1A191B4 	D0 6F A0  1 
1A191B8 	48 43 A0  1 24  0  0  0 
1A191C0 	20 7C A0  1  7 63 6D 70 
1A191C8 	78 63 68 67  0  0  0  0 
1A191D0 	50 85 A1  1 D0 8B A1  1 
1A191D8 	6C 43 A0  1 74  1  0  0 
      7 of  ." cmpxchg" op-col          ea,g  endof
1A191E0 	E0 6F A0  1 48 43 A0  1 
1A191E8 	24  0  0  0 20 7C A0  1 
1A191F0 	 7 63 6D 70 78 63 68 67 
1A191F8 	 0  0  0  0 50 85 A1  1 
1A19200 	D0 8B A1  1 6C 43 A0  1 
1A19208 	48  1  0  0 
      8 of  .push  ." gs"  endof
1A1920C 	F0 6F A0  1 
1A19210 	48 43 A0  1 18  0  0  0 
1A19218 	24 8A A1  1 20 7C A0  1 
1A19220 	 2 67 73  0 6C 43 A0  1 
1A19228 	28  1  0  0 
      9 of  .pop   ." gs"  endof
1A1922C 	58 41 A0  1 
1A19230 	 9  0  0  0 48 43 A0  1 
1A19238 	18  0  0  0 48 8A A1  1 
1A19240 	20 7C A0  1  2 67 73  0 
1A19248 	6C 43 A0  1  4  1  0  0 
      a of  ." rsm"  end-found on  endof
1A19250 	58 41 A0  1  A  0  0  0 
1A19258 	48 43 A0  1 20  0  0  0 
1A19260 	20 7C A0  1  3 72 73 6D 
1A19268 	 0  0  0  0 CC 7A A1  1 
1A19270 	E0 4B A0  1 6C 43 A0  1 
1A19278 	D8  0  0  0 
      b of  ." bt"   op-col             ea,g  endof
1A1927C 	58 41 A0  1 
1A19280 	 B  0  0  0 48 43 A0  1 
1A19288 	1C  0  0  0 20 7C A0  1 
1A19290 	 2 62 74  0 50 85 A1  1 
1A19298 	D0 8B A1  1 6C 43 A0  1 
1A192A0 	B0  0  0  0 
      c of  ." shrd" op-col  1 is wbit  ea,g  ,ib  endof
1A192A4 	58 41 A0  1 
1A192A8 	 C  0  0  0 48 43 A0  1 
1A192B0 	30  0  0  0 20 7C A0  1 
1A192B8 	 4 73 68 72 64  0  0  0 
1A192C0 	50 85 A1  1 80 6F A0  1 
1A192C8 	B8 40 A0  1 18 7D A1  1 
1A192D0 	D0 8B A1  1 68 88 A1  1 
1A192D8 	6C 43 A0  1 74  0  0  0 
      d of  ." shrd" op-col  1 is wbit  ea,g  ,cl  endof
1A192E0 	58 41 A0  1  D  0  0  0 
1A192E8 	48 43 A0  1 30  0  0  0 
1A192F0 	20 7C A0  1  4 73 68 72 
1A192F8 	64  0  0  0 50 85 A1  1 
1A19300 	80 6F A0  1 B8 40 A0  1 
1A19308 	18 7D A1  1 D0 8B A1  1 
1A19310 	84 89 A1  1 6C 43 A0  1 
1A19318 	38  0  0  0 
      f of  ." imul" op-col  g,ea  endof
1A1931C 	58 41 A0  1 
1A19320 	 F  0  0  0 48 43 A0  1 
1A19328 	20  0  0  0 20 7C A0  1 
1A19330 	 4 69 6D 75 6C  0  0  0 
1A19338 	50 85 A1  1 F4 8B A1  1 
1A19340 	6C 43 A0  1  C  0  0  0 
         .unimp
1A19348 	8C 8D A1  1 
   endcase
1A1934C 	84 43 A0  1 
;
1A19350 	58 46 A0  1 
\ Decode operands for lds,..,lgs,lss instructions
: .lfp  ( -- )  op-col get-ea midbits .reg  ,ea   ;
1A19354 	 0  0  0 2E 
1A19358 	6C 66 70 84 B8 90 A1  1 
1A19360 	20 40 A0  1 50 85 A1  1 
1A19368 	70 87 A1  1 70 7D A1  1 
1A19370 	 8 81 A1  1 18 85 A1  1 
1A19378 	58 46 A0  1 

: reg,  ( -- )  op-col  get-ea reg-field .reg  .,  ;
1A1937C 	 0  0  0 72 
1A19380 	65 67 2C 84 60 93 A1  1 
1A19388 	20 40 A0  1 50 85 A1  1 
1A19390 	70 87 A1  1 5C 87 A1  1 
1A19398 	 8 81 A1  1 AC 7D A1  1 
1A193A0 	58 46 A0  1 
: ?.b/w  ( -- )
1A193A4 	 0  0 3F 2E 
1A193A8 	62 2F 77 85 88 93 A1  1 
1A193B0 	20 40 A0  1 
   hibits 3 <>  if
1A193B4 	90 7D A1  1 
1A193B8 	A0 6F A0  1 44 48 A0  1 
1A193C0 	DC 41 A0  1 2C  0  0  0 
      wbit  if  ." word ptr "  else  .byte  then
1A193C8 	18 7D A1  1 DC 41 A0  1 
1A193D0 	1C  0  0  0 20 7C A0  1 
1A193D8 	 9 77 6F 72 64 20 70 74 
1A193E0 	72 20  0  0 C8 41 A0  1 
1A193E8 	 8  0  0  0 28 8F A1  1 
   then
;
1A193F0 	58 46 A0  1 
: 2bbop  ( -- )
1A193F4 	 0  0 32 62 
1A193F8 	62 6F 70 85 B0 93 A1  1 
1A19400 	20 40 A0  1 
   low4bits  case
1A19404 	50 7D A1  1 
      2 of  ." lss"    .lfp               endof
1A19408 	90 6F A0  1 48 43 A0  1 
1A19410 	1C  0  0  0 20 7C A0  1 
1A19418 	 3 6C 73 73  0  0  0  0 
1A19420 	60 93 A1  1 6C 43 A0  1 
1A19428 	F0  1  0  0 
      3 of  ." btr"    op-col  ea,g       endof
1A1942C 	A0 6F A0  1 
1A19430 	48 43 A0  1 20  0  0  0 
1A19438 	20 7C A0  1  3 62 74 72 
1A19440 	 0  0  0  0 50 85 A1  1 
1A19448 	D0 8B A1  1 6C 43 A0  1 
1A19450 	C8  1  0  0 
      4 of  ." lfs"    .lfp               endof
1A19454 	B0 6F A0  1 
1A19458 	48 43 A0  1 1C  0  0  0 
1A19460 	20 7C A0  1  3 6C 66 73 
1A19468 	 0  0  0  0 60 93 A1  1 
1A19470 	6C 43 A0  1 A4  1  0  0 
      5 of  ." lgs"    .lfp               endof
1A19478 	C0 6F A0  1 48 43 A0  1 
1A19480 	1C  0  0  0 20 7C A0  1 
1A19488 	 3 6C 67 73  0  0  0  0 
1A19490 	60 93 A1  1 6C 43 A0  1 
1A19498 	80  1  0  0 
      6 of  ." movzx"  reg,  ?.b/w  .ea   endof
1A1949C 	D0 6F A0  1 
1A194A0 	48 43 A0  1 24  0  0  0 
1A194A8 	20 7C A0  1  5 6D 6F 76 
1A194B0 	7A 78  0  0 88 93 A1  1 
1A194B8 	B0 93 A1  1 94 84 A1  1 
1A194C0 	6C 43 A0  1 54  1  0  0 
      7 of  ." movzx"  reg,         .ea   endof
1A194C8 	E0 6F A0  1 48 43 A0  1 
1A194D0 	20  0  0  0 20 7C A0  1 
1A194D8 	 5 6D 6F 76 7A 78  0  0 
1A194E0 	88 93 A1  1 94 84 A1  1 
1A194E8 	6C 43 A0  1 2C  1  0  0 
      a of  get-ea midbits >grp8 ".  1 is wbit  op-col .ea ,ib    endof
1A194F0 	58 41 A0  1  A  0  0  0 
1A194F8 	48 43 A0  1 34  0  0  0 
1A19500 	70 87 A1  1 70 7D A1  1 
1A19508 	28 8D A1  1 A8 7C A0  1 
1A19510 	80 6F A0  1 B8 40 A0  1 
1A19518 	18 7D A1  1 50 85 A1  1 
1A19520 	94 84 A1  1 68 88 A1  1 
1A19528 	6C 43 A0  1 EC  0  0  0 
      b of  ." btc"    op-col  ea,g       endof
1A19530 	58 41 A0  1  B  0  0  0 
1A19538 	48 43 A0  1 20  0  0  0 
1A19540 	20 7C A0  1  3 62 74 63 
1A19548 	 0  0  0  0 50 85 A1  1 
1A19550 	D0 8B A1  1 6C 43 A0  1 
1A19558 	C0  0  0  0 
      c of  ." bsf"    reg,         .ea   endof
1A1955C 	58 41 A0  1 
1A19560 	 C  0  0  0 48 43 A0  1 
1A19568 	20  0  0  0 20 7C A0  1 
1A19570 	 3 62 73 66  0  0  0  0 
1A19578 	88 93 A1  1 94 84 A1  1 
1A19580 	6C 43 A0  1 94  0  0  0 
      d of  ." bsr"    reg,         .ea   endof
1A19588 	58 41 A0  1  D  0  0  0 
1A19590 	48 43 A0  1 20  0  0  0 
1A19598 	20 7C A0  1  3 62 73 72 
1A195A0 	 0  0  0  0 88 93 A1  1 
1A195A8 	94 84 A1  1 6C 43 A0  1 
1A195B0 	68  0  0  0 
      e of  ." movsx"  reg,  ?.b/w  .ea   endof
1A195B4 	58 41 A0  1 
1A195B8 	 E  0  0  0 48 43 A0  1 
1A195C0 	24  0  0  0 20 7C A0  1 
1A195C8 	 5 6D 6F 76 73 78  0  0 
1A195D0 	88 93 A1  1 B0 93 A1  1 
1A195D8 	94 84 A1  1 6C 43 A0  1 
1A195E0 	38  0  0  0 
      f of  ." movsx"  reg,         .ea   endof
1A195E4 	58 41 A0  1 
1A195E8 	 F  0  0  0 48 43 A0  1 
1A195F0 	20  0  0  0 20 7C A0  1 
1A195F8 	 5 6D 6F 76 73 78  0  0 
1A19600 	88 93 A1  1 94 84 A1  1 
1A19608 	6C 43 A0  1  C  0  0  0 
         .unimp
1A19610 	8C 8D A1  1 
   endcase
1A19614 	84 43 A0  1 
;
1A19618 	58 46 A0  1 
: 2bcop  ( -- )
1A1961C 	 0  0 32 62 
1A19620 	63 6F 70 85  0 94 A1  1 
1A19628 	20 40 A0  1 
   low4bits  case
1A1962C 	50 7D A1  1 
      0 of  ." xadd"  op-col  ea,g  endof
1A19630 	70 6F A0  1 48 43 A0  1 
1A19638 	20  0  0  0 20 7C A0  1 
1A19640 	 4 78 61 64 64  0  0  0 
1A19648 	50 85 A1  1 D0 8B A1  1 
1A19650 	6C 43 A0  1 70  0  0  0 
      1 of  ." xadd"  op-col  ea,g  endof
1A19658 	80 6F A0  1 48 43 A0  1 
1A19660 	20  0  0  0 20 7C A0  1 
1A19668 	 4 78 61 64 64  0  0  0 
1A19670 	50 85 A1  1 D0 8B A1  1 
1A19678 	6C 43 A0  1 48  0  0  0 
         dup 8 <  if
1A19680 	40 49 A0  1 F0 6F A0  1 
1A19688 	E4 47 A0  1 DC 41 A0  1 
1A19690 	10  0  0  0 
            .unimp
1A19694 	8C 8D A1  1 
         else
1A19698 	C8 41 A0  1 24  0  0  0 
            ." bswap" op-col  dup 8 - .reg
1A196A0 	20 7C A0  1  5 62 73 77 
1A196A8 	61 70  0  0 50 85 A1  1 
1A196B0 	40 49 A0  1 F0 6F A0  1 
1A196B8 	18 45 A0  1  8 81 A1  1 
         then
   endcase
1A196C0 	84 43 A0  1 
;
1A196C4 	58 46 A0  1 
: 2b6op  ( -- )
1A196C8 	 0  0 32 62 36 6F 70 85 
1A196D0 	28 96 A1  1 20 40 A0  1 
   low4bits  case
1A196D8 	50 7D A1  1 
      e of  ." movd"  op-col get-ea  1 is wbit  mreg ., .ea  endof
1A196DC 	58 41 A0  1 
1A196E0 	 E  0  0  0 48 43 A0  1 
1A196E8 	38  0  0  0 20 7C A0  1 
1A196F0 	 4 6D 6F 76 64  0  0  0 
1A196F8 	50 85 A1  1 70 87 A1  1 
1A19700 	80 6F A0  1 B8 40 A0  1 
1A19708 	18 7D A1  1 D4 87 A1  1 
1A19710 	AC 7D A1  1 94 84 A1  1 
1A19718 	6C 43 A0  1 50  0  0  0 
      f of  ." movq"  op-col get-ea  1 is wbit  mreg ., .mea endof
1A19720 	58 41 A0  1  F  0  0  0 
1A19728 	48 43 A0  1 38  0  0  0 
1A19730 	20 7C A0  1  4 6D 6F 76 
1A19738 	71  0  0  0 50 85 A1  1 
1A19740 	70 87 A1  1 80 6F A0  1 
1A19748 	B8 40 A0  1 18 7D A1  1 
1A19750 	D4 87 A1  1 AC 7D A1  1 
1A19758 	F0 87 A1  1 6C 43 A0  1 
1A19760 	 C  0  0  0 
      .unimp
1A19764 	8C 8D A1  1 
   endcase
1A19768 	84 43 A0  1 
;
1A1976C 	58 46 A0  1 
: 2b7op  ( -- )
1A19770 	 0  0 32 62 37 6F 70 85 
1A19778 	D4 96 A1  1 20 40 A0  1 
   low4bits  case
1A19780 	50 7D A1  1 
      7 of  ." emms"  endof
1A19784 	E0 6F A0  1 
1A19788 	48 43 A0  1 18  0  0  0 
1A19790 	20 7C A0  1  4 65 6D 6D 
1A19798 	73  0  0  0 6C 43 A0  1 
1A197A0 	18  1  0  0 
      8 of  ." svdc"  op-col get-ea  1 is wbit  .ea  ., sreg endof
1A197A4 	F0 6F A0  1 
1A197A8 	48 43 A0  1 38  0  0  0 
1A197B0 	20 7C A0  1  4 73 76 64 
1A197B8 	63  0  0  0 50 85 A1  1 
1A197C0 	70 87 A1  1 80 6F A0  1 
1A197C8 	B8 40 A0  1 18 7D A1  1 
1A197D0 	94 84 A1  1 AC 7D A1  1 
1A197D8 	94 87 A1  1 6C 43 A0  1 
1A197E0 	D8  0  0  0 
      9 of  ." rsdc"  op-col get-ea  1 is wbit  sreg ., .ea  endof
1A197E4 	58 41 A0  1 
1A197E8 	 9  0  0  0 48 43 A0  1 
1A197F0 	38  0  0  0 20 7C A0  1 
1A197F8 	 4 72 73 64 63  0  0  0 
1A19800 	50 85 A1  1 70 87 A1  1 
1A19808 	80 6F A0  1 B8 40 A0  1 
1A19810 	18 7D A1  1 94 87 A1  1 
1A19818 	AC 7D A1  1 94 84 A1  1 
1A19820 	6C 43 A0  1 94  0  0  0 
      e of  ." movd"  op-col get-ea  1 is wbit  .ea  ., mreg endof
1A19828 	58 41 A0  1  E  0  0  0 
1A19830 	48 43 A0  1 38  0  0  0 
1A19838 	20 7C A0  1  4 6D 6F 76 
1A19840 	64  0  0  0 50 85 A1  1 
1A19848 	70 87 A1  1 80 6F A0  1 
1A19850 	B8 40 A0  1 18 7D A1  1 
1A19858 	94 84 A1  1 AC 7D A1  1 
1A19860 	D4 87 A1  1 6C 43 A0  1 
1A19868 	50  0  0  0 
      f of  ." movq"  op-col get-ea  1 is wbit  .mea ., mreg endof
1A1986C 	58 41 A0  1 
1A19870 	 F  0  0  0 48 43 A0  1 
1A19878 	38  0  0  0 20 7C A0  1 
1A19880 	 4 6D 6F 76 71  0  0  0 
1A19888 	50 85 A1  1 70 87 A1  1 
1A19890 	80 6F A0  1 B8 40 A0  1 
1A19898 	18 7D A1  1 F0 87 A1  1 
1A198A0 	AC 7D A1  1 D4 87 A1  1 
1A198A8 	6C 43 A0  1  C  0  0  0 
      .unimp
1A198B0 	8C 8D A1  1 
   endcase
1A198B4 	84 43 A0  1 
;
1A198B8 	58 46 A0  1 
: msrop  ( -- )
1A198BC 	 0  0 6D 73 
1A198C0 	72 6F 70 85 7C 97 A1  1 
1A198C8 	20 40 A0  1 
   low4bits case
1A198CC 	50 7D A1  1 
      0 of  ." wrmsr"  endof
1A198D0 	70 6F A0  1 48 43 A0  1 
1A198D8 	18  0  0  0 20 7C A0  1 
1A198E0 	 5 77 72 6D 73 72  0  0 
1A198E8 	6C 43 A0  1 6C  0  0  0 
      1 of  ." rdtsc"  endof
1A198F0 	80 6F A0  1 48 43 A0  1 
1A198F8 	18  0  0  0 20 7C A0  1 
1A19900 	 5 72 64 74 73 63  0  0 
1A19908 	6C 43 A0  1 4C  0  0  0 
      2 of  ." rdmsr"  endof
1A19910 	90 6F A0  1 48 43 A0  1 
1A19918 	18  0  0  0 20 7C A0  1 
1A19920 	 5 72 64 6D 73 72  0  0 
1A19928 	6C 43 A0  1 2C  0  0  0 
      8 of  ." smint"  endof
1A19930 	F0 6F A0  1 48 43 A0  1 
1A19938 	18  0  0  0 20 7C A0  1 
1A19940 	 5 73 6D 69 6E 74  0  0 
1A19948 	6C 43 A0  1  C  0  0  0 
      .unimp
1A19950 	8C 8D A1  1 
   endcase
1A19954 	84 43 A0  1 
;
1A19958 	58 46 A0  1 

: .2byte  ( -- )
1A1995C 	 0 2E 32 62 
1A19960 	79 74 65 86 C8 98 A1  1 
1A19968 	20 40 A0  1 
   decode-op  case
1A1996C 	18 8C A1  1 
      0 of  2b0op  endof
1A19970 	70 6F A0  1 48 43 A0  1 
1A19978 	10  0  0  0 C0 8D A1  1 
1A19980 	6C 43 A0  1 38  1  0  0 
      2 of  movspec  endof
1A19988 	90 6F A0  1 48 43 A0  1 
1A19990 	10  0  0  0 A0 8F A1  1 
1A19998 	6C 43 A0  1 20  1  0  0 
      3 of  msrop    endof
1A199A0 	A0 6F A0  1 48 43 A0  1 
1A199A8 	10  0  0  0 C8 98 A1  1 
1A199B0 	6C 43 A0  1  8  1  0  0 
      6 of  2b6op    endof
1A199B8 	D0 6F A0  1 48 43 A0  1 
1A199C0 	10  0  0  0 D4 96 A1  1 
1A199C8 	6C 43 A0  1 F0  0  0  0 
      7 of  2b7op    endof
1A199D0 	E0 6F A0  1 48 43 A0  1 
1A199D8 	10  0  0  0 7C 97 A1  1 
1A199E0 	6C 43 A0  1 D8  0  0  0 
      8 of  ." j"   low4bits >cond ".  op-col  jv  endof
1A199E8 	F0 6F A0  1 48 43 A0  1 
1A199F0 	28  0  0  0 20 7C A0  1 
1A199F8 	 1 6A  0  0 50 7D A1  1 
1A19A00 	6C 8A A1  1 A8 7C A0  1 
1A19A08 	50 85 A1  1 84 8B A1  1 
1A19A10 	6C 43 A0  1 A8  0  0  0 
      9 of  ." set" low4bits >cond ".  op-col  0 is wbit  get-ea  .ea  endof
1A19A18 	58 41 A0  1  9  0  0  0 
1A19A20 	48 43 A0  1 3C  0  0  0 
1A19A28 	20 7C A0  1  3 73 65 74 
1A19A30 	 0  0  0  0 50 7D A1  1 
1A19A38 	6C 8A A1  1 A8 7C A0  1 
1A19A40 	50 85 A1  1 70 6F A0  1 
1A19A48 	B8 40 A0  1 18 7D A1  1 
1A19A50 	70 87 A1  1 94 84 A1  1 
1A19A58 	6C 43 A0  1 60  0  0  0 
      a of  2baop  endof
1A19A60 	58 41 A0  1  A  0  0  0 
1A19A68 	48 43 A0  1 10  0  0  0 
1A19A70 	B8 90 A1  1 6C 43 A0  1 
1A19A78 	44  0  0  0 
      b of  2bbop  endof
1A19A7C 	58 41 A0  1 
1A19A80 	 B  0  0  0 48 43 A0  1 
1A19A88 	10  0  0  0  0 94 A1  1 
1A19A90 	6C 43 A0  1 28  0  0  0 
      c of  2bcop  endof
1A19A98 	58 41 A0  1  C  0  0  0 
1A19AA0 	48 43 A0  1 10  0  0  0 
1A19AA8 	28 96 A1  1 6C 43 A0  1 
1A19AB0 	 C  0  0  0 
         .unimp
1A19AB4 	8C 8D A1  1 
   endcase
1A19AB8 	84 43 A0  1 
;
1A19ABC 	58 46 A0  1 
: .wierd  ( -- )
1A19AC0 	 0 2E 77 69 65 72 64 86 
1A19AC8 	68 99 A1  1 20 40 A0  1 
   instruction @  f =  if  .2byte  exit then
1A19AD0 	B4 7A A1  1 5C 4C A0  1 
1A19AD8 	58 41 A0  1  F  0  0  0 
1A19AE0 	24 48 A0  1 DC 41 A0  1 
1A19AE8 	 C  0  0  0 68 99 A1  1 
1A19AF0 	40 46 A0  1 
   instruction @  h# 21 and  case
1A19AF4 	B4 7A A1  1 
1A19AF8 	5C 4C A0  1 58 41 A0  1 
1A19B00 	21  0  0  0 5C 44 A0  1 
      0  of  .push    .segment   endof
1A19B08 	70 6F A0  1 48 43 A0  1 
1A19B10 	14  0  0  0 24 8A A1  1 
1A19B18 	BC 86 A1  1 6C 43 A0  1 
1A19B20 	74  0  0  0 
      1  of  .pop     .segment   endof
1A19B24 	80 6F A0  1 
1A19B28 	48 43 A0  1 14  0  0  0 
1A19B30 	48 8A A1  1 BC 86 A1  1 
1A19B38 	6C 43 A0  1 58  0  0  0 
     20  of           .segment  ." :"   endof
1A19B40 	58 41 A0  1 20  0  0  0 
1A19B48 	48 43 A0  1 18  0  0  0 
1A19B50 	BC 86 A1  1 20 7C A0  1 
1A19B58 	 1 3A  0  0 6C 43 A0  1 
1A19B60 	34  0  0  0 
     21  of  3 2 ibits >adjust  ". endof
1A19B64 	58 41 A0  1 
1A19B68 	21  0  0  0 48 43 A0  1 
1A19B70 	20  0  0  0 A0 6F A0  1 
1A19B78 	90 6F A0  1 F4 7C A1  1 
1A19B80 	E4 86 A1  1 A8 7C A0  1 
1A19B88 	6C 43 A0  1  8  0  0  0 
   endcase
1A19B90 	84 43 A0  1 
;
1A19B94 	58 46 A0  1 
: .2op  ( -- )
1A19B98 	 0  0  0 2E 32 6F 70 84 
1A19BA0 	CC 9A A1  1 20 40 A0  1 
   lowbits 5 >  if
1A19BA8 	2C 7D A1  1 C0 6F A0  1 
1A19BB0 	 4 48 A0  1 DC 41 A0  1 
1A19BB8 	10  0  0  0 
      .wierd
1A19BBC 	CC 9A A1  1 
   else
1A19BC0 	C8 41 A0  1 14  0  0  0 
      midbits .binop  lowbits .mode
1A19BC8 	70 7D A1  1 50 86 A1  1 
1A19BD0 	2C 7D A1  1 A4 89 A1  1 
   then
;
1A19BD8 	58 46 A0  1 
: .1op  ( -- )
1A19BDC 	 0  0  0 2E 
1A19BE0 	31 6F 70 84 A4 9B A1  1 
1A19BE8 	20 40 A0  1 
   3 2 ibits  >unop ".  op-col  lowbits .reg
1A19BEC 	A0 6F A0  1 
1A19BF0 	90 6F A0  1 F4 7C A1  1 
1A19BF8 	70 86 A1  1 A8 7C A0  1 
1A19C00 	50 85 A1  1 2C 7D A1  1 
1A19C08 	 8 81 A1  1 
;
1A19C0C 	58 46 A0  1 

defer dis-body
1A19C10 	 0  0  0 64 69 73 2D 62 
1A19C18 	6F 64 79 88 E8 9B A1  1 
1A19C20 	5C 40 A0  1 B4  4  0  0 
: dis-op:  ( -- )
1A19C28 	64 69 73 2D 6F 70 3A 87 
1A19C30 	20 9C A1  1 20 40 A0  1 
   op32? 0=  is op32?
1A19C38 	F4 7B A1  1 24 47 A0  1 
1A19C40 	B8 40 A0  1 F4 7B A1  1 
   ['] dis-body catch  ( error? )
1A19C48 	60 53 A0  1 20 9C A1  1 
1A19C50 	14 7F A0  1 
   op32? 0=  is op32?
1A19C54 	F4 7B A1  1 
1A19C58 	24 47 A0  1 B8 40 A0  1 
1A19C60 	F4 7B A1  1 
   throw
1A19C64 	74 7F A0  1 
;
1A19C68 	58 46 A0  1 
: dis-ad:  ( -- )
1A19C6C 	64 69 73 2D 
1A19C70 	61 64 3A 87 34 9C A1  1 
1A19C78 	20 40 A0  1 
   ad32? 0=  is ad32?
1A19C7C 	38 7C A1  1 
1A19C80 	24 47 A0  1 B8 40 A0  1 
1A19C88 	38 7C A1  1 
   ['] dis-body catch  ( error? )
1A19C8C 	60 53 A0  1 
1A19C90 	20 9C A1  1 14 7F A0  1 
   ad32? 0=  is ad32?
1A19C98 	38 7C A1  1 24 47 A0  1 
1A19CA0 	B8 40 A0  1 38 7C A1  1 
   throw
1A19CA8 	74 7F A0  1 
;
1A19CAC 	58 46 A0  1 

: .op6  ( -- )
1A19CB0 	 0  0  0 2E 6F 70 36 84 
1A19CB8 	78 9C A1  1 20 40 A0  1 
   low4bits case
1A19CC0 	50 7D A1  1 
      0 of  ." pushad" endof
1A19CC4 	70 6F A0  1 
1A19CC8 	48 43 A0  1 18  0  0  0 
1A19CD0 	20 7C A0  1  6 70 75 73 
1A19CD8 	68 61 64  0 6C 43 A0  1 
1A19CE0 	3C  2  0  0 
      1 of  ." popad"  endof
1A19CE4 	80 6F A0  1 
1A19CE8 	48 43 A0  1 18  0  0  0 
1A19CF0 	20 7C A0  1  5 70 6F 70 
1A19CF8 	61 64  0  0 6C 43 A0  1 
1A19D00 	1C  2  0  0 
      2 of  ." bound"  op-col   get-ea reg-field .reg ,ea  endof
1A19D04 	90 6F A0  1 
1A19D08 	48 43 A0  1 2C  0  0  0 
1A19D10 	20 7C A0  1  5 62 6F 75 
1A19D18 	6E 64  0  0 50 85 A1  1 
1A19D20 	70 87 A1  1 5C 87 A1  1 
1A19D28 	 8 81 A1  1 18 85 A1  1 
1A19D30 	6C 43 A0  1 E8  1  0  0 
      3 of  ." arpl"   op-col   ea,g  endof  \ XXX should be w-reg, not d-reg
1A19D38 	A0 6F A0  1 48 43 A0  1 
1A19D40 	20  0  0  0 20 7C A0  1 
1A19D48 	 4 61 72 70 6C  0  0  0 
1A19D50 	50 85 A1  1 D0 8B A1  1 
1A19D58 	6C 43 A0  1 C0  1  0  0 
      4 of  ." fs:"  endof
1A19D60 	B0 6F A0  1 48 43 A0  1 
1A19D68 	18  0  0  0 20 7C A0  1 
1A19D70 	 3 66 73 3A  0  0  0  0 
1A19D78 	6C 43 A0  1 A0  1  0  0 
      5 of  ." gs:"  endof
1A19D80 	C0 6F A0  1 48 43 A0  1 
1A19D88 	18  0  0  0 20 7C A0  1 
1A19D90 	 3 67 73 3A  0  0  0  0 
1A19D98 	6C 43 A0  1 80  1  0  0 
      6 of  ." op: "  dis-op:  endof
1A19DA0 	D0 6F A0  1 48 43 A0  1 
1A19DA8 	1C  0  0  0 20 7C A0  1 
1A19DB0 	 4 6F 70 3A 20  0  0  0 
1A19DB8 	34 9C A1  1 6C 43 A0  1 
1A19DC0 	5C  1  0  0 
      7 of  ." ad: "  dis-ad:  endof
1A19DC4 	E0 6F A0  1 
1A19DC8 	48 43 A0  1 1C  0  0  0 
1A19DD0 	20 7C A0  1  4 61 64 3A 
1A19DD8 	20  0  0  0 78 9C A1  1 
1A19DE0 	6C 43 A0  1 38  1  0  0 
      8 of  .push    iv  endof
1A19DE8 	F0 6F A0  1 48 43 A0  1 
1A19DF0 	14  0  0  0 24 8A A1  1 
1A19DF8 	B8 88 A1  1 6C 43 A0  1 
1A19E00 	1C  1  0  0 
      9 of  ." imul" op-col g,ea ., iv  endof
1A19E04 	58 41 A0  1 
1A19E08 	 9  0  0  0 48 43 A0  1 
1A19E10 	28  0  0  0 20 7C A0  1 
1A19E18 	 4 69 6D 75 6C  0  0  0 
1A19E20 	50 85 A1  1 F4 8B A1  1 
1A19E28 	AC 7D A1  1 B8 88 A1  1 
1A19E30 	6C 43 A0  1 E8  0  0  0 
      a of  .push    ib  endof
1A19E38 	58 41 A0  1  A  0  0  0 
1A19E40 	48 43 A0  1 14  0  0  0 
1A19E48 	24 8A A1  1 48 88 A1  1 
1A19E50 	6C 43 A0  1 C8  0  0  0 
      b of  ." imul" op-col g,ea ,ib    endof
1A19E58 	58 41 A0  1  B  0  0  0 
1A19E60 	48 43 A0  1 24  0  0  0 
1A19E68 	20 7C A0  1  4 69 6D 75 
1A19E70 	6C  0  0  0 50 85 A1  1 
1A19E78 	F4 8B A1  1 68 88 A1  1 
1A19E80 	6C 43 A0  1 98  0  0  0 
      c of  ." insb"  endof
1A19E88 	58 41 A0  1  C  0  0  0 
1A19E90 	48 43 A0  1 18  0  0  0 
1A19E98 	20 7C A0  1  4 69 6E 73 
1A19EA0 	62  0  0  0 6C 43 A0  1 
1A19EA8 	74  0  0  0 
      d of  ." insd"  endof
1A19EAC 	58 41 A0  1 
1A19EB0 	 D  0  0  0 48 43 A0  1 
1A19EB8 	18  0  0  0 20 7C A0  1 
1A19EC0 	 4 69 6E 73 64  0  0  0 
1A19EC8 	6C 43 A0  1 50  0  0  0 
      e of  ." outsb" endof
1A19ED0 	58 41 A0  1  E  0  0  0 
1A19ED8 	48 43 A0  1 18  0  0  0 
1A19EE0 	20 7C A0  1  5 6F 75 74 
1A19EE8 	73 62  0  0 6C 43 A0  1 
1A19EF0 	2C  0  0  0 
      f of  ." outsd" endof
1A19EF4 	58 41 A0  1 
1A19EF8 	 F  0  0  0 48 43 A0  1 
1A19F00 	18  0  0  0 20 7C A0  1 
1A19F08 	 5 6F 75 74 73 64  0  0 
1A19F10 	6C 43 A0  1  8  0  0  0 
   endcase
1A19F18 	84 43 A0  1 
;
1A19F1C 	58 46 A0  1 

: grp1op  ( -- )  get-ea  midbits .binop  ;
1A19F20 	 0 67 72 70 31 6F 70 86 
1A19F28 	BC 9C A1  1 20 40 A0  1 
1A19F30 	70 87 A1  1 70 7D A1  1 
1A19F38 	50 86 A1  1 58 46 A0  1 
: .test  ( -- )  ." test" op-col  ;
1A19F40 	 0  0 2E 74 65 73 74 85 
1A19F48 	2C 9F A1  1 20 40 A0  1 
1A19F50 	20 7C A0  1  4 74 65 73 
1A19F58 	74  0  0  0 50 85 A1  1 
1A19F60 	58 46 A0  1 

: .op8  ( -- )
1A19F64 	 0  0  0 2E 
1A19F68 	6F 70 38 84 4C 9F A1  1 
1A19F70 	20 40 A0  1 
   low4bits  case
1A19F74 	50 7D A1  1 
      0 of  grp1op    .byte .ea ., iub  endof
1A19F78 	70 6F A0  1 48 43 A0  1 
1A19F80 	20  0  0  0 2C 9F A1  1 
1A19F88 	28 8F A1  1 94 84 A1  1 
1A19F90 	AC 7D A1  1 80 88 A1  1 
1A19F98 	6C 43 A0  1 30  2  0  0 
      1 of  grp1op          .ea ., iv   endof
1A19FA0 	80 6F A0  1 48 43 A0  1 
1A19FA8 	1C  0  0  0 2C 9F A1  1 
1A19FB0 	94 84 A1  1 AC 7D A1  1 
1A19FB8 	B8 88 A1  1 6C 43 A0  1 
1A19FC0 	 C  2  0  0 
\ The opcode map in the Intel manual says 82 is "movb", but it actually
\ appears to be the same as "80" - the sign extension of the immediate
\ byte is irrelevant to a byte-width operation
\     2 of  ." movb"       al/x ,ib   endof
      2 of  grp1op    .byte .ea ,ib   endof \ Opcode maps says "movb"
1A19FC4 	90 6F A0  1 
1A19FC8 	48 43 A0  1 1C  0  0  0 
1A19FD0 	2C 9F A1  1 28 8F A1  1 
1A19FD8 	94 84 A1  1 68 88 A1  1 
1A19FE0 	6C 43 A0  1 E8  1  0  0 
      3 of  grp1op          .ea ,ib   endof
1A19FE8 	A0 6F A0  1 48 43 A0  1 
1A19FF0 	18  0  0  0 2C 9F A1  1 
1A19FF8 	94 84 A1  1 68 88 A1  1 
1A1A000 	6C 43 A0  1 C8  1  0  0 
      4 of  .test           ea,g  endof
1A1A008 	B0 6F A0  1 48 43 A0  1 
1A1A010 	14  0  0  0 4C 9F A1  1 
1A1A018 	D0 8B A1  1 6C 43 A0  1 
1A1A020 	AC  1  0  0 
      5 of  .test           ea,g  endof
1A1A024 	C0 6F A0  1 
1A1A028 	48 43 A0  1 14  0  0  0 
1A1A030 	4C 9F A1  1 D0 8B A1  1 
1A1A038 	6C 43 A0  1 90  1  0  0 
      6 of  ." xchg" op-col ea,g  endof
1A1A040 	D0 6F A0  1 48 43 A0  1 
1A1A048 	20  0  0  0 20 7C A0  1 
1A1A050 	 4 78 63 68 67  0  0  0 
1A1A058 	50 85 A1  1 D0 8B A1  1 
1A1A060 	6C 43 A0  1 68  1  0  0 
      7 of  ." xchg" op-col ea,g  endof
1A1A068 	E0 6F A0  1 48 43 A0  1 
1A1A070 	20  0  0  0 20 7C A0  1 
1A1A078 	 4 78 63 68 67  0  0  0 
1A1A080 	50 85 A1  1 D0 8B A1  1 
1A1A088 	6C 43 A0  1 40  1  0  0 
      8 of  .mov            ea,g  endof
1A1A090 	F0 6F A0  1 48 43 A0  1 
1A1A098 	14  0  0  0  4 8F A1  1 
1A1A0A0 	D0 8B A1  1 6C 43 A0  1 
1A1A0A8 	24  1  0  0 
      9 of  .mov            ea,g  endof
1A1A0AC 	58 41 A0  1 
1A1A0B0 	 9  0  0  0 48 43 A0  1 
1A1A0B8 	14  0  0  0  4 8F A1  1 
1A1A0C0 	D0 8B A1  1 6C 43 A0  1 
1A1A0C8 	 4  1  0  0 
      a of  .mov            g,ea  endof
1A1A0CC 	58 41 A0  1 
1A1A0D0 	 A  0  0  0 48 43 A0  1 
1A1A0D8 	14  0  0  0  4 8F A1  1 
1A1A0E0 	F4 8B A1  1 6C 43 A0  1 
1A1A0E8 	E4  0  0  0 
      b of  .mov            g,ea  endof
1A1A0EC 	58 41 A0  1 
1A1A0F0 	 B  0  0  0 48 43 A0  1 
1A1A0F8 	14  0  0  0  4 8F A1  1 
1A1A100 	F4 8B A1  1 6C 43 A0  1 
1A1A108 	C4  0  0  0 
      c of  .mov  get-ea  1 is wbit  .ea  ., sreg  endof
1A1A10C 	58 41 A0  1 
1A1A110 	 C  0  0  0 48 43 A0  1 
1A1A118 	2C  0  0  0  4 8F A1  1 
1A1A120 	70 87 A1  1 80 6F A0  1 
1A1A128 	B8 40 A0  1 18 7D A1  1 
1A1A130 	94 84 A1  1 AC 7D A1  1 
1A1A138 	94 87 A1  1 6C 43 A0  1 
1A1A140 	8C  0  0  0 
      e of  .mov  get-ea  1 is wbit  sreg ,ea   endof
1A1A144 	58 41 A0  1 
1A1A148 	 E  0  0  0 48 43 A0  1 
1A1A150 	28  0  0  0  4 8F A1  1 
1A1A158 	70 87 A1  1 80 6F A0  1 
1A1A160 	B8 40 A0  1 18 7D A1  1 
1A1A168 	94 87 A1  1 18 85 A1  1 
1A1A170 	6C 43 A0  1 58  0  0  0 
      d of  ." lea" op-col  g,ea         endof
1A1A178 	58 41 A0  1  D  0  0  0 
1A1A180 	48 43 A0  1 20  0  0  0 
1A1A188 	20 7C A0  1  3 6C 65 61 
1A1A190 	 0  0  0  0 50 85 A1  1 
1A1A198 	F4 8B A1  1 6C 43 A0  1 
1A1A1A0 	2C  0  0  0 
      f of  .pop  get-ea  .ea  endof
1A1A1A4 	58 41 A0  1 
1A1A1A8 	 F  0  0  0 48 43 A0  1 
1A1A1B0 	18  0  0  0 48 8A A1  1 
1A1A1B8 	70 87 A1  1 94 84 A1  1 
1A1A1C0 	6C 43 A0  1  8  0  0  0 
   endcase
1A1A1C8 	84 43 A0  1 
;
1A1A1CC 	58 46 A0  1 

: .4x  ( n -- )  push-hex <# u# u# u# u# u#> type pop-base  ;
1A1A1D0 	2E 34 78 83 70 9F A1  1 
1A1A1D8 	20 40 A0  1 5C F4 A0  1 
1A1A1E0 	 8 76 A0  1 94 76 A0  1 
1A1A1E8 	94 76 A0  1 94 76 A0  1 
1A1A1F0 	94 76 A0  1 E0 76 A0  1 
1A1A1F8 	 4 6C A0  1 9C F4 A0  1 
1A1A200 	58 46 A0  1 
: ap  ( -- )
1A1A204 	 0 61 70 82 
1A1A208 	D8 A1 A1  1 20 40 A0  1 
   opv@ ." far "
1A1A210 	 8 7C A1  1 20 7C A0  1 
1A1A218 	 4 66 61 72 20  0  0  0 
   op16@ push-hex (.) type pop-base
1A1A220 	5C 7B A1  1 5C F4 A0  1 
1A1A228 	10 78 A0  1  4 6C A0  1 
1A1A230 	9C F4 A0  1 
   ." :"  op32?  if  showaddr  else  .4x  then
1A1A234 	20 7C A0  1 
1A1A238 	 1 3A  0  0 F4 7B A1  1 
1A1A240 	DC 41 A0  1 10  0  0  0 
1A1A248 	30 13 A1  1 C8 41 A0  1 
1A1A250 	 8  0  0  0 D8 A1 A1  1 
   end-found on
1A1A258 	CC 7A A1  1 E0 4B A0  1 
;
1A1A260 	58 46 A0  1 

string-array >8line-ops
1A1A264 	 0 3E 38 6C 
1A1A268 	69 6E 65 2D 6F 70 73 8A 
1A1A270 	 C A2 A1  1 44 15 A1  1 
1A1A278 	 8  0  0  0 48  0  0  0 
  ," cwde"  ," cdq"  ," call"  ," wait"  ," pushfd" ," popfd" ," sahf" ," lahf"
1A1A280 	 4 63 77 64 65  0  0  0 
1A1A288 	 3 63 64 71  0  0  0  0 
1A1A290 	 4 63 61 6C 6C  0  0  0 
1A1A298 	 4 77 61 69 74  0  0  0 
1A1A2A0 	 6 70 75 73 68 66 64  0 
1A1A2A8 	 5 70 6F 70 66 64  0  0 
1A1A2B0 	 4 73 61 68 66  0  0  0 
1A1A2B8 	 4 6C 61 68 66  0  0  0 
end-string-array
1A1A2C0 	 8  0  0  0 10  0  0  0 
1A1A2C8 	18  0  0  0 20  0  0  0 
1A1A2D0 	28  0  0  0 30  0  0  0 
1A1A2D8 	38  0  0  0 40  0  0  0 

: .op9  ( -- )
1A1A2E0 	 0  0  0 2E 6F 70 39 84 
1A1A2E8 	74 A2 A1  1 20 40 A0  1 
   low4bits                                                       ( low4bits )
1A1A2F0 	50 7D A1  1 
   dup  8 <  if  ." xchg"  op-col  .reg  ., ." eax"  exit  then   ( low4bits )
1A1A2F4 	40 49 A0  1 
1A1A2F8 	F0 6F A0  1 E4 47 A0  1 
1A1A300 	DC 41 A0  1 2C  0  0  0 
1A1A308 	20 7C A0  1  4 78 63 68 
1A1A310 	67  0  0  0 50 85 A1  1 
1A1A318 	 8 81 A1  1 AC 7D A1  1 
1A1A320 	20 7C A0  1  3 65 61 78 
1A1A328 	 0  0  0  0 40 46 A0  1 
   dup 8 -  >8line-ops ".   a =  if  op-col ap  then
1A1A330 	40 49 A0  1 F0 6F A0  1 
1A1A338 	18 45 A0  1 74 A2 A1  1 
1A1A340 	A8 7C A0  1 58 41 A0  1 
1A1A348 	 A  0  0  0 24 48 A0  1 
1A1A350 	DC 41 A0  1  C  0  0  0 
1A1A358 	50 85 A1  1  C A2 A1  1 
;
1A1A360 	58 46 A0  1 

: .opa  ( -- )
1A1A364 	 0  0  0 2E 
1A1A368 	6F 70 61 84 EC A2 A1  1 
1A1A370 	20 40 A0  1 
   low4bits case
1A1A374 	50 7D A1  1 
      0 of  .mov  al/x ., ." [" iuv ." ]"  endof
1A1A378 	70 6F A0  1 48 43 A0  1 
1A1A380 	2C  0  0  0  4 8F A1  1 
1A1A388 	30 89 A1  1 AC 7D A1  1 
1A1A390 	20 7C A0  1  1 5B  0  0 
1A1A398 	D4 88 A1  1 20 7C A0  1 
1A1A3A0 	 1 5D  0  0 6C 43 A0  1 
1A1A3A8 	38  2  0  0 
      1 of  .mov  al/x ., ." [" iuv ." ]"  endof
1A1A3AC 	80 6F A0  1 
1A1A3B0 	48 43 A0  1 2C  0  0  0 
1A1A3B8 	 4 8F A1  1 30 89 A1  1 
1A1A3C0 	AC 7D A1  1 20 7C A0  1 
1A1A3C8 	 1 5B  0  0 D4 88 A1  1 
1A1A3D0 	20 7C A0  1  1 5D  0  0 
1A1A3D8 	6C 43 A0  1  4  2  0  0 
      2 of  .mov  ." [" iuv ." ]" ,al/x  endof
1A1A3E0 	90 6F A0  1 48 43 A0  1 
1A1A3E8 	28  0  0  0  4 8F A1  1 
1A1A3F0 	20 7C A0  1  1 5B  0  0 
1A1A3F8 	D4 88 A1  1 20 7C A0  1 
1A1A400 	 1 5D  0  0 6C 89 A1  1 
1A1A408 	6C 43 A0  1 D4  1  0  0 
      3 of  .mov  ." [" iuv ." ]" ,al/x  endof
1A1A410 	A0 6F A0  1 48 43 A0  1 
1A1A418 	28  0  0  0  4 8F A1  1 
1A1A420 	20 7C A0  1  1 5B  0  0 
1A1A428 	D4 88 A1  1 20 7C A0  1 
1A1A430 	 1 5D  0  0 6C 89 A1  1 
1A1A438 	6C 43 A0  1 A4  1  0  0 
      4 of  ." movsb"  endof
1A1A440 	B0 6F A0  1 48 43 A0  1 
1A1A448 	18  0  0  0 20 7C A0  1 
1A1A450 	 5 6D 6F 76 73 62  0  0 
1A1A458 	6C 43 A0  1 84  1  0  0 
      5 of  ." movsd"  endof
1A1A460 	C0 6F A0  1 48 43 A0  1 
1A1A468 	18  0  0  0 20 7C A0  1 
1A1A470 	 5 6D 6F 76 73 64  0  0 
1A1A478 	6C 43 A0  1 64  1  0  0 
      6 of  ." cmpsb"  endof
1A1A480 	D0 6F A0  1 48 43 A0  1 
1A1A488 	18  0  0  0 20 7C A0  1 
1A1A490 	 5 63 6D 70 73 62  0  0 
1A1A498 	6C 43 A0  1 44  1  0  0 
      7 of  ." cmpsd"  endof
1A1A4A0 	E0 6F A0  1 48 43 A0  1 
1A1A4A8 	18  0  0  0 20 7C A0  1 
1A1A4B0 	 5 63 6D 70 73 64  0  0 
1A1A4B8 	6C 43 A0  1 24  1  0  0 
      8 of  .test  al/x ,ib/v  endof
1A1A4C0 	F0 6F A0  1 48 43 A0  1 
1A1A4C8 	18  0  0  0 4C 9F A1  1 
1A1A4D0 	30 89 A1  1 F4 88 A1  1 
1A1A4D8 	6C 43 A0  1  4  1  0  0 
      9 of  .test  al/x ,ib/v  endof
1A1A4E0 	58 41 A0  1  9  0  0  0 
1A1A4E8 	48 43 A0  1 18  0  0  0 
1A1A4F0 	4C 9F A1  1 30 89 A1  1 
1A1A4F8 	F4 88 A1  1 6C 43 A0  1 
1A1A500 	E0  0  0  0 
      a of  ." stosb"  endof
1A1A504 	58 41 A0  1 
1A1A508 	 A  0  0  0 48 43 A0  1 
1A1A510 	18  0  0  0 20 7C A0  1 
1A1A518 	 5 73 74 6F 73 62  0  0 
1A1A520 	6C 43 A0  1 BC  0  0  0 
      b of  ." stosd"  endof
1A1A528 	58 41 A0  1  B  0  0  0 
1A1A530 	48 43 A0  1 18  0  0  0 
1A1A538 	20 7C A0  1  5 73 74 6F 
1A1A540 	73 64  0  0 6C 43 A0  1 
1A1A548 	98  0  0  0 
      c of  ." lodsb"  endof
1A1A54C 	58 41 A0  1 
1A1A550 	 C  0  0  0 48 43 A0  1 
1A1A558 	18  0  0  0 20 7C A0  1 
1A1A560 	 5 6C 6F 64 73 62  0  0 
1A1A568 	6C 43 A0  1 74  0  0  0 
      d of  ." lodsd"  endof
1A1A570 	58 41 A0  1  D  0  0  0 
1A1A578 	48 43 A0  1 18  0  0  0 
1A1A580 	20 7C A0  1  5 6C 6F 64 
1A1A588 	73 64  0  0 6C 43 A0  1 
1A1A590 	50  0  0  0 
      e of  ." scasb"  endof
1A1A594 	58 41 A0  1 
1A1A598 	 E  0  0  0 48 43 A0  1 
1A1A5A0 	18  0  0  0 20 7C A0  1 
1A1A5A8 	 5 73 63 61 73 62  0  0 
1A1A5B0 	6C 43 A0  1 2C  0  0  0 
      f of  ." scasd"  endof
1A1A5B8 	58 41 A0  1  F  0  0  0 
1A1A5C0 	48 43 A0  1 18  0  0  0 
1A1A5C8 	20 7C A0  1  5 73 63 61 
1A1A5D0 	73 64  0  0 6C 43 A0  1 
1A1A5D8 	 8  0  0  0 
   endcase
1A1A5DC 	84 43 A0  1 
;
1A1A5E0 	58 46 A0  1 
string-array >grp2-op
1A1A5E4 	 0  0  0 3E 
1A1A5E8 	67 72 70 32 2D 6F 70 88 
1A1A5F0 	70 A3 A1  1 44 15 A1  1 
1A1A5F8 	 8  0  0  0 48  0  0  0 
   ," rol"   ," ror"  ," rcl"  ," rcr"  ," shl"  ," shr"  ," sal"  ," sar"
1A1A600 	 3 72 6F 6C  0  0  0  0 
1A1A608 	 3 72 6F 72  0  0  0  0 
1A1A610 	 3 72 63 6C  0  0  0  0 
1A1A618 	 3 72 63 72  0  0  0  0 
1A1A620 	 3 73 68 6C  0  0  0  0 
1A1A628 	 3 73 68 72  0  0  0  0 
1A1A630 	 3 73 61 6C  0  0  0  0 
1A1A638 	 3 73 61 72  0  0  0  0 
end-string-array
1A1A640 	 8  0  0  0 10  0  0  0 
1A1A648 	18  0  0  0 20  0  0  0 
1A1A650 	28  0  0  0 30  0  0  0 
1A1A658 	38  0  0  0 40  0  0  0 
: grp2op  ( -- )  get-ea  midbits >grp2-op ". op-col  ;
1A1A660 	 0 67 72 70 32 6F 70 86 
1A1A668 	F4 A5 A1  1 20 40 A0  1 
1A1A670 	70 87 A1  1 70 7D A1  1 
1A1A678 	F4 A5 A1  1 A8 7C A0  1 
1A1A680 	50 85 A1  1 58 46 A0  1 
: .ret   ( -- )  ." ret"  op-col  end-found on  ;
1A1A688 	 0  0  0 2E 72 65 74 84 
1A1A690 	6C A6 A1  1 20 40 A0  1 
1A1A698 	20 7C A0  1  3 72 65 74 
1A1A6A0 	 0  0  0  0 50 85 A1  1 
1A1A6A8 	CC 7A A1  1 E0 4B A0  1 
1A1A6B0 	58 46 A0  1 
: .near  ( -- )  ." near "  ;
1A1A6B4 	 0  0 2E 6E 
1A1A6B8 	65 61 72 85 94 A6 A1  1 
1A1A6C0 	20 40 A0  1 20 7C A0  1 
1A1A6C8 	 5 6E 65 61 72 20  0  0 
1A1A6D0 	58 46 A0  1 
: .far   ( -- )  ." far "  ;
1A1A6D4 	 0  0  0 2E 
1A1A6D8 	66 61 72 84 C0 A6 A1  1 
1A1A6E0 	20 40 A0  1 20 7C A0  1 
1A1A6E8 	 4 66 61 72 20  0  0  0 
1A1A6F0 	58 46 A0  1 

: .opc  ( -- )
1A1A6F4 	 0  0  0 2E 
1A1A6F8 	6F 70 63 84 E0 A6 A1  1 
1A1A700 	20 40 A0  1 
   low4bits case
1A1A704 	50 7D A1  1 
      0 of  grp2op        ?.byte .ea ,ib    endof
1A1A708 	70 6F A0  1 48 43 A0  1 
1A1A710 	1C  0  0  0 6C A6 A1  1 
1A1A718 	4C 8F A1  1 94 84 A1  1 
1A1A720 	68 88 A1  1 6C 43 A0  1 
1A1A728 	38  2  0  0 
      1 of  grp2op               .ea ,ib    endof
1A1A72C 	80 6F A0  1 
1A1A730 	48 43 A0  1 18  0  0  0 
1A1A738 	6C A6 A1  1 94 84 A1  1 
1A1A740 	68 88 A1  1 6C 43 A0  1 
1A1A748 	18  2  0  0 
      2 of  .ret           .near iw         endof
1A1A74C 	90 6F A0  1 
1A1A750 	48 43 A0  1 18  0  0  0 
1A1A758 	94 A6 A1  1 C0 A6 A1  1 
1A1A760 	9C 88 A1  1 6C 43 A0  1 
1A1A768 	F8  1  0  0 
      3 of  .ret           .near            endof
1A1A76C 	A0 6F A0  1 
1A1A770 	48 43 A0  1 14  0  0  0 
1A1A778 	94 A6 A1  1 C0 A6 A1  1 
1A1A780 	6C 43 A0  1 DC  1  0  0 
      4 of  ." les"        .lfp             endof
1A1A788 	B0 6F A0  1 48 43 A0  1 
1A1A790 	1C  0  0  0 20 7C A0  1 
1A1A798 	 3 6C 65 73  0  0  0  0 
1A1A7A0 	60 93 A1  1 6C 43 A0  1 
1A1A7A8 	B8  1  0  0 
      5 of  ." lds"        .lfp             endof
1A1A7AC 	C0 6F A0  1 
1A1A7B0 	48 43 A0  1 1C  0  0  0 
1A1A7B8 	20 7C A0  1  3 6C 64 73 
1A1A7C0 	 0  0  0  0 60 93 A1  1 
1A1A7C8 	6C 43 A0  1 94  1  0  0 
      6 of  .mov           get-ea  ?.byte .ea  ,ib/v  endof
1A1A7D0 	D0 6F A0  1 48 43 A0  1 
1A1A7D8 	20  0  0  0  4 8F A1  1 
1A1A7E0 	70 87 A1  1 4C 8F A1  1 
1A1A7E8 	94 84 A1  1 F4 88 A1  1 
1A1A7F0 	6C 43 A0  1 6C  1  0  0 
      7 of  .mov           get-ea         .ea  ,ib/v  endof
1A1A7F8 	E0 6F A0  1 48 43 A0  1 
1A1A800 	1C  0  0  0  4 8F A1  1 
1A1A808 	70 87 A1  1 94 84 A1  1 
1A1A810 	F4 88 A1  1 6C 43 A0  1 
1A1A818 	48  1  0  0 
      8 of  ." enter" op-col  iw ,ib        endof
1A1A81C 	F0 6F A0  1 
1A1A820 	48 43 A0  1 24  0  0  0 
1A1A828 	20 7C A0  1  5 65 6E 74 
1A1A830 	65 72  0  0 50 85 A1  1 
1A1A838 	9C 88 A1  1 68 88 A1  1 
1A1A840 	6C 43 A0  1 1C  1  0  0 
      9 of  ." leave"                       endof
1A1A848 	58 41 A0  1  9  0  0  0 
1A1A850 	48 43 A0  1 18  0  0  0 
1A1A858 	20 7C A0  1  5 6C 65 61 
1A1A860 	76 65  0  0 6C 43 A0  1 
1A1A868 	F8  0  0  0 
      a of  .ret             .far  iw       endof
1A1A86C 	58 41 A0  1 
1A1A870 	 A  0  0  0 48 43 A0  1 
1A1A878 	18  0  0  0 94 A6 A1  1 
1A1A880 	E0 A6 A1  1 9C 88 A1  1 
1A1A888 	6C 43 A0  1 D4  0  0  0 
      b of  .ret             .far           endof
1A1A890 	58 41 A0  1  B  0  0  0 
1A1A898 	48 43 A0  1 14  0  0  0 
1A1A8A0 	94 A6 A1  1 E0 A6 A1  1 
1A1A8A8 	6C 43 A0  1 B4  0  0  0 
      c of  ." int"   op-col ." 3"          endof
1A1A8B0 	58 41 A0  1  C  0  0  0 
1A1A8B8 	48 43 A0  1 24  0  0  0 
1A1A8C0 	20 7C A0  1  3 69 6E 74 
1A1A8C8 	 0  0  0  0 50 85 A1  1 
1A1A8D0 	20 7C A0  1  1 33  0  0 
1A1A8D8 	6C 43 A0  1 84  0  0  0 
      d of  ." int"   op-col iub            endof
1A1A8E0 	58 41 A0  1  D  0  0  0 
1A1A8E8 	48 43 A0  1 20  0  0  0 
1A1A8F0 	20 7C A0  1  3 69 6E 74 
1A1A8F8 	 0  0  0  0 50 85 A1  1 
1A1A900 	80 88 A1  1 6C 43 A0  1 
1A1A908 	58  0  0  0 
      e of  ." into"                        endof
1A1A90C 	58 41 A0  1 
1A1A910 	 E  0  0  0 48 43 A0  1 
1A1A918 	18  0  0  0 20 7C A0  1 
1A1A920 	 4 69 6E 74 6F  0  0  0 
1A1A928 	6C 43 A0  1 34  0  0  0 
      f of  ." iretd"  end-found on         endof
1A1A930 	58 41 A0  1  F  0  0  0 
1A1A938 	48 43 A0  1 20  0  0  0 
1A1A940 	20 7C A0  1  5 69 72 65 
1A1A948 	74 64  0  0 CC 7A A1  1 
1A1A950 	E0 4B A0  1 6C 43 A0  1 
1A1A958 	 8  0  0  0 
   endcase
1A1A95C 	84 43 A0  1 
;
1A1A960 	58 46 A0  1 

defer .esc
1A1A964 	 0  0  0 2E 
1A1A968 	65 73 63 84  0 A7 A1  1 
1A1A970 	5C 40 A0  1 B8  4  0  0 
: null.esc  ( -- )
1A1A978 	 0  0  0 6E 75 6C 6C 2E 
1A1A980 	65 73 63 88 70 A9 A1  1 
1A1A988 	20 40 A0  1 
   ." Coprocessor Escape " instruction @ .  op8@ .
1A1A98C 	20 7C A0  1 
1A1A990 	13 43 6F 70 72 6F 63 65 
1A1A998 	73 73 6F 72 20 45 73 63 
1A1A9A0 	61 70 65 20  0  0  0  0 
1A1A9A8 	B4 7A A1  1 5C 4C A0  1 
1A1A9B0 	94 7A A0  1 24 7B A1  1 
1A1A9B8 	94 7A A0  1 
;
1A1A9BC 	58 46 A0  1 
' null.esc is .esc

: .opd  ( -- )
1A1A9C0 	 0  0  0 2E 6F 70 64 84 
1A1A9C8 	88 A9 A1  1 20 40 A0  1 
   low4bits  case
1A1A9D0 	50 7D A1  1 
      0 of  grp2op   .byte .ea  .,  ." 1"   endof
1A1A9D4 	70 6F A0  1 
1A1A9D8 	48 43 A0  1 24  0  0  0 
1A1A9E0 	6C A6 A1  1 28 8F A1  1 
1A1A9E8 	94 84 A1  1 AC 7D A1  1 
1A1A9F0 	20 7C A0  1  1 31  0  0 
1A1A9F8 	6C 43 A0  1  0  1  0  0 
      1 of  grp2op         .ea  .,  ." 1"   endof
1A1AA00 	80 6F A0  1 48 43 A0  1 
1A1AA08 	20  0  0  0 6C A6 A1  1 
1A1AA10 	94 84 A1  1 AC 7D A1  1 
1A1AA18 	20 7C A0  1  1 31  0  0 
1A1AA20 	6C 43 A0  1 D8  0  0  0 
      2 of  grp2op   .byte .ea  ,cl  endof
1A1AA28 	90 6F A0  1 48 43 A0  1 
1A1AA30 	1C  0  0  0 6C A6 A1  1 
1A1AA38 	28 8F A1  1 94 84 A1  1 
1A1AA40 	84 89 A1  1 6C 43 A0  1 
1A1AA48 	B4  0  0  0 
      3 of  grp2op         .ea  ,cl  endof
1A1AA4C 	A0 6F A0  1 
1A1AA50 	48 43 A0  1 18  0  0  0 
1A1AA58 	6C A6 A1  1 94 84 A1  1 
1A1AA60 	84 89 A1  1 6C 43 A0  1 
1A1AA68 	94  0  0  0 
      4 of  ." aam"   op8@ drop  endof   \ D4 is always followed by 0A (10)
1A1AA6C 	B0 6F A0  1 
1A1AA70 	48 43 A0  1 20  0  0  0 
1A1AA78 	20 7C A0  1  3 61 61 6D 
1A1AA80 	 0  0  0  0 24 7B A1  1 
1A1AA88 	30 49 A0  1 6C 43 A0  1 
1A1AA90 	6C  0  0  0 
      5 of  ." aad"   op8@ drop  endof   \ D5 is always followed by 0A (10)
1A1AA94 	C0 6F A0  1 
1A1AA98 	48 43 A0  1 20  0  0  0 
1A1AAA0 	20 7C A0  1  3 61 61 64 
1A1AAA8 	 0  0  0  0 24 7B A1  1 
1A1AAB0 	30 49 A0  1 6C 43 A0  1 
1A1AAB8 	44  0  0  0 
      6 of  .unimp    endof
1A1AABC 	D0 6F A0  1 
1A1AAC0 	48 43 A0  1 10  0  0  0 
1A1AAC8 	8C 8D A1  1 6C 43 A0  1 
1A1AAD0 	2C  0  0  0 
      7 of  ." xlatb" endof
1A1AAD4 	E0 6F A0  1 
1A1AAD8 	48 43 A0  1 18  0  0  0 
1A1AAE0 	20 7C A0  1  5 78 6C 61 
1A1AAE8 	74 62  0  0 6C 43 A0  1 
1A1AAF0 	 C  0  0  0 
          .esc
1A1AAF4 	70 A9 A1  1 
   endcase
1A1AAF8 	84 43 A0  1 
;
1A1AAFC 	58 46 A0  1 

string-array >loops
1A1AB00 	 0 3E 6C 6F 6F 70 73 86 
1A1AB08 	CC A9 A1  1 44 15 A1  1 
1A1AB10 	 4  0  0  0 28  0  0  0 
   ," loopne"  ," loope"  ," loop"  ," jcxz"
1A1AB18 	 6 6C 6F 6F 70 6E 65  0 
1A1AB20 	 5 6C 6F 6F 70 65  0  0 
1A1AB28 	 4 6C 6F 6F 70  0  0  0 
1A1AB30 	 4 6A 63 78 7A  0  0  0 
end-string-array
1A1AB38 	 8  0  0  0 10  0  0  0 
1A1AB40 	18  0  0  0 20  0  0  0 

: .in    ( -- )  ." in"   op-col  ;
1A1AB48 	2E 69 6E 83  C AB A1  1 
1A1AB50 	20 40 A0  1 20 7C A0  1 
1A1AB58 	 2 69 6E  0 50 85 A1  1 
1A1AB60 	58 46 A0  1 
: .out   ( -- )  ." out"  op-col  ;
1A1AB64 	 0  0  0 2E 
1A1AB68 	6F 75 74 84 50 AB A1  1 
1A1AB70 	20 40 A0  1 20 7C A0  1 
1A1AB78 	 3 6F 75 74  0  0  0  0 
1A1AB80 	50 85 A1  1 58 46 A0  1 
: .call  ( -- )  ." call" op-col  ;
1A1AB88 	 0  0 2E 63 61 6C 6C 85 
1A1AB90 	70 AB A1  1 20 40 A0  1 
1A1AB98 	20 7C A0  1  4 63 61 6C 
1A1ABA0 	6C  0  0  0 50 85 A1  1 
1A1ABA8 	58 46 A0  1 
: .jmp   ( -- )  ." jmp"  op-col  end-found on  ;
1A1ABAC 	 0  0  0 2E 
1A1ABB0 	6A 6D 70 84 94 AB A1  1 
1A1ABB8 	20 40 A0  1 20 7C A0  1 
1A1ABC0 	 3 6A 6D 70  0  0  0  0 
1A1ABC8 	50 85 A1  1 CC 7A A1  1 
1A1ABD0 	E0 4B A0  1 58 46 A0  1 
: dx  ( -- )  ." edx"  ;
1A1ABD8 	 0 64 78 82 B8 AB A1  1 
1A1ABE0 	20 40 A0  1 20 7C A0  1 
1A1ABE8 	 3 65 64 78  0  0  0  0 
1A1ABF0 	58 46 A0  1 

: ub    ( -- )  op8@  (.) type  ;
1A1ABF4 	 0 75 62 82 
1A1ABF8 	E0 AB A1  1 20 40 A0  1 
1A1AC00 	24 7B A1  1 10 78 A0  1 
1A1AC08 	 4 6C A0  1 58 46 A0  1 
: .ope  ( -- )
1A1AC10 	 0  0  0 2E 6F 70 65 84 
1A1AC18 	FC AB A1  1 20 40 A0  1 
   low4bits  dup  4 <  if  >loops ".  op-col jb   exit  then   ( low4bits )
1A1AC20 	50 7D A1  1 40 49 A0  1 
1A1AC28 	B0 6F A0  1 E4 47 A0  1 
1A1AC30 	DC 41 A0  1 18  0  0  0 
1A1AC38 	 C AB A1  1 A8 7C A0  1 
1A1AC40 	50 85 A1  1 68 8B A1  1 
1A1AC48 	40 46 A0  1 
   case
      4 of  .in   al/x  ., ub   endof
1A1AC4C 	B0 6F A0  1 
1A1AC50 	48 43 A0  1 1C  0  0  0 
1A1AC58 	50 AB A1  1 30 89 A1  1 
1A1AC60 	AC 7D A1  1 FC AB A1  1 
1A1AC68 	6C 43 A0  1 80  1  0  0 
      5 of  .in   al/x  ., ub   endof
1A1AC70 	C0 6F A0  1 48 43 A0  1 
1A1AC78 	1C  0  0  0 50 AB A1  1 
1A1AC80 	30 89 A1  1 AC 7D A1  1 
1A1AC88 	FC AB A1  1 6C 43 A0  1 
1A1AC90 	5C  1  0  0 
      6 of  .out  ub    ,al/x   endof
1A1AC94 	D0 6F A0  1 
1A1AC98 	48 43 A0  1 18  0  0  0 
1A1ACA0 	70 AB A1  1 FC AB A1  1 
1A1ACA8 	6C 89 A1  1 6C 43 A0  1 
1A1ACB0 	3C  1  0  0 
      7 of  .out  ub    ,al/x   endof
1A1ACB4 	E0 6F A0  1 
1A1ACB8 	48 43 A0  1 18  0  0  0 
1A1ACC0 	70 AB A1  1 FC AB A1  1 
1A1ACC8 	6C 89 A1  1 6C 43 A0  1 
1A1ACD0 	1C  1  0  0 
      8 of  .call jv            endof
1A1ACD4 	F0 6F A0  1 
1A1ACD8 	48 43 A0  1 14  0  0  0 
1A1ACE0 	94 AB A1  1 84 8B A1  1 
1A1ACE8 	6C 43 A0  1  0  1  0  0 
      9 of  .jmp  jv            endof
1A1ACF0 	58 41 A0  1  9  0  0  0 
1A1ACF8 	48 43 A0  1 14  0  0  0 
1A1AD00 	B8 AB A1  1 84 8B A1  1 
1A1AD08 	6C 43 A0  1 E0  0  0  0 
      a of  .jmp  ap            endof
1A1AD10 	58 41 A0  1  A  0  0  0 
1A1AD18 	48 43 A0  1 14  0  0  0 
1A1AD20 	B8 AB A1  1  C A2 A1  1 
1A1AD28 	6C 43 A0  1 C0  0  0  0 
      b of  .jmp  jb            endof
1A1AD30 	58 41 A0  1  B  0  0  0 
1A1AD38 	48 43 A0  1 14  0  0  0 
1A1AD40 	B8 AB A1  1 68 8B A1  1 
1A1AD48 	6C 43 A0  1 A0  0  0  0 
      c of  .in   al/x  .,  dx  endof
1A1AD50 	58 41 A0  1  C  0  0  0 
1A1AD58 	48 43 A0  1 1C  0  0  0 
1A1AD60 	50 AB A1  1 30 89 A1  1 
1A1AD68 	AC 7D A1  1 E0 AB A1  1 
1A1AD70 	6C 43 A0  1 78  0  0  0 
      d of  .in   al/x  .,  dx  endof
1A1AD78 	58 41 A0  1  D  0  0  0 
1A1AD80 	48 43 A0  1 1C  0  0  0 
1A1AD88 	50 AB A1  1 30 89 A1  1 
1A1AD90 	AC 7D A1  1 E0 AB A1  1 
1A1AD98 	6C 43 A0  1 50  0  0  0 
      e of  .out  dx    ,al/x   endof
1A1ADA0 	58 41 A0  1  E  0  0  0 
1A1ADA8 	48 43 A0  1 18  0  0  0 
1A1ADB0 	70 AB A1  1 E0 AB A1  1 
1A1ADB8 	6C 89 A1  1 6C 43 A0  1 
1A1ADC0 	2C  0  0  0 
      f of  .out  dx    ,al/x   endof
1A1ADC4 	58 41 A0  1 
1A1ADC8 	 F  0  0  0 48 43 A0  1 
1A1ADD0 	18  0  0  0 70 AB A1  1 
1A1ADD8 	E0 AB A1  1 6C 89 A1  1 
1A1ADE0 	6C 43 A0  1  8  0  0  0 
   endcase
1A1ADE8 	84 43 A0  1 
;
1A1ADEC 	58 46 A0  1 

string-array >fline-ops
1A1ADF0 	 0 3E 66 6C 69 6E 65 2D 
1A1ADF8 	6F 70 73 8A 1C AC A1  1 
1A1AE00 	44 15 A1  1  E  0  0  0 
1A1AE08 	70  0  0  0 
   ," lock"  ," unimp"  ," repne"  ," repe"  ," hlt"   ," cmc"  ," "  ," "
1A1AE0C 	 4 6C 6F 63 
1A1AE10 	6B  0  0  0  5 75 6E 69 
1A1AE18 	6D 70  0  0  5 72 65 70 
1A1AE20 	6E 65  0  0  4 72 65 70 
1A1AE28 	65  0  0  0  3 68 6C 74 
1A1AE30 	 0  0  0  0  3 63 6D 63 
1A1AE38 	 0  0  0  0  0  0  0  0 
1A1AE40 	 0  0  0  0 
   ," clc"   ," stc"    ," cli"    ," sti"   ," cld"   ," std"
1A1AE44 	 3 63 6C 63 
1A1AE48 	 0  0  0  0  3 73 74 63 
1A1AE50 	 0  0  0  0  3 63 6C 69 
1A1AE58 	 0  0  0  0  3 73 74 69 
1A1AE60 	 0  0  0  0  3 63 6C 64 
1A1AE68 	 0  0  0  0  3 73 74 64 
1A1AE70 	 0  0  0  0 
end-string-array
1A1AE74 	 8  0  0  0 
1A1AE78 	10  0  0  0 18  0  0  0 
1A1AE80 	20  0  0  0 28  0  0  0 
1A1AE88 	30  0  0  0 38  0  0  0 
1A1AE90 	3C  0  0  0 40  0  0  0 
1A1AE98 	48  0  0  0 50  0  0  0 
1A1AEA0 	58  0  0  0 60  0  0  0 
1A1AEA8 	68  0  0  0 

: acc-op  ( -- )  op-col  al/x  ,ea   ;
1A1AEAC 	 0 61 63 63 
1A1AEB0 	2D 6F 70 86  0 AE A1  1 
1A1AEB8 	20 40 A0  1 50 85 A1  1 
1A1AEC0 	30 89 A1  1 18 85 A1  1 
1A1AEC8 	58 46 A0  1 
: .grp3  ( -- )
1A1AECC 	 0  0 2E 67 
1A1AED0 	72 70 33 85 B8 AE A1  1 
1A1AED8 	20 40 A0  1 
   get-ea
1A1AEDC 	70 87 A1  1 
   midbits  case
1A1AEE0 	70 7D A1  1 
      0 of   .test             ?.byte .ea  ,ib/v  endof
1A1AEE4 	70 6F A0  1 
1A1AEE8 	48 43 A0  1 1C  0  0  0 
1A1AEF0 	4C 9F A1  1 4C 8F A1  1 
1A1AEF8 	94 84 A1  1 F4 88 A1  1 
1A1AF00 	6C 43 A0  1 10  1  0  0 
      1 of   .test                    .ea  ,ib/v  endof
1A1AF08 	80 6F A0  1 48 43 A0  1 
1A1AF10 	18  0  0  0 4C 9F A1  1 
1A1AF18 	94 84 A1  1 F4 88 A1  1 
1A1AF20 	6C 43 A0  1 F0  0  0  0 
      2 of   ." not"   op-col  ?.byte .ea  endof
1A1AF28 	90 6F A0  1 48 43 A0  1 
1A1AF30 	24  0  0  0 20 7C A0  1 
1A1AF38 	 3 6E 6F 74  0  0  0  0 
1A1AF40 	50 85 A1  1 4C 8F A1  1 
1A1AF48 	94 84 A1  1 6C 43 A0  1 
1A1AF50 	C4  0  0  0 
      3 of   ." neg"   op-col  ?.byte .ea  endof
1A1AF54 	A0 6F A0  1 
1A1AF58 	48 43 A0  1 24  0  0  0 
1A1AF60 	20 7C A0  1  3 6E 65 67 
1A1AF68 	 0  0  0  0 50 85 A1  1 
1A1AF70 	4C 8F A1  1 94 84 A1  1 
1A1AF78 	6C 43 A0  1 98  0  0  0 
      4 of   ." mul"   acc-op              endof
1A1AF80 	B0 6F A0  1 48 43 A0  1 
1A1AF88 	1C  0  0  0 20 7C A0  1 
1A1AF90 	 3 6D 75 6C  0  0  0  0 
1A1AF98 	B8 AE A1  1 6C 43 A0  1 
1A1AFA0 	74  0  0  0 
      5 of   ." imul"  acc-op              endof
1A1AFA4 	C0 6F A0  1 
1A1AFA8 	48 43 A0  1 1C  0  0  0 
1A1AFB0 	20 7C A0  1  4 69 6D 75 
1A1AFB8 	6C  0  0  0 B8 AE A1  1 
1A1AFC0 	6C 43 A0  1 50  0  0  0 
      6 of   ." div"   acc-op              endof
1A1AFC8 	D0 6F A0  1 48 43 A0  1 
1A1AFD0 	1C  0  0  0 20 7C A0  1 
1A1AFD8 	 3 64 69 76  0  0  0  0 
1A1AFE0 	B8 AE A1  1 6C 43 A0  1 
1A1AFE8 	2C  0  0  0 
      7 of   ." idiv"  acc-op              endof
1A1AFEC 	E0 6F A0  1 
1A1AFF0 	48 43 A0  1 1C  0  0  0 
1A1AFF8 	20 7C A0  1  4 69 64 69 
1A1B000 	76  0  0  0 B8 AE A1  1 
1A1B008 	6C 43 A0  1  8  0  0  0 
   endcase
1A1B010 	84 43 A0  1 
;
1A1B014 	58 46 A0  1 
: .grp4  ( -- )
1A1B018 	 0  0 2E 67 72 70 34 85 
1A1B020 	D8 AE A1  1 20 40 A0  1 
   get-ea midbits  dup 1 >  if
1A1B028 	70 87 A1  1 70 7D A1  1 
1A1B030 	40 49 A0  1 80 6F A0  1 
1A1B038 	 4 48 A0  1 DC 41 A0  1 
1A1B040 	14  0  0  0 
      drop .unimp
1A1B044 	30 49 A0  1 
1A1B048 	8C 8D A1  1 
   else
1A1B04C 	C8 41 A0  1 
1A1B050 	38  0  0  0 
      if  ." dec"  else  ." inc"  then
1A1B054 	DC 41 A0  1 
1A1B058 	18  0  0  0 20 7C A0  1 
1A1B060 	 3 64 65 63  0  0  0  0 
1A1B068 	C8 41 A0  1 10  0  0  0 
1A1B070 	20 7C A0  1  3 69 6E 63 
1A1B078 	 0  0  0  0 
      op-col  ?.byte .ea
1A1B07C 	50 85 A1  1 
1A1B080 	4C 8F A1  1 94 84 A1  1 
   then
;
1A1B088 	58 46 A0  1 
: .ep  ( -- )  ." far ptr "  .ea  ;
1A1B08C 	2E 65 70 83 
1A1B090 	24 B0 A1  1 20 40 A0  1 
1A1B098 	20 7C A0  1  8 66 61 72 
1A1B0A0 	20 70 74 72 20  0  0  0 
1A1B0A8 	94 84 A1  1 58 46 A0  1 
: .grp5  ( -- )
1A1B0B0 	 0  0 2E 67 72 70 35 85 
1A1B0B8 	94 B0 A1  1 20 40 A0  1 
   get-ea  midbits  case
1A1B0C0 	70 87 A1  1 70 7D A1  1 
      0 of  ." inc"  op-col  .ea   endof
1A1B0C8 	70 6F A0  1 48 43 A0  1 
1A1B0D0 	20  0  0  0 20 7C A0  1 
1A1B0D8 	 3 69 6E 63  0  0  0  0 
1A1B0E0 	50 85 A1  1 94 84 A1  1 
1A1B0E8 	6C 43 A0  1 DC  0  0  0 
      1 of  ." dec"  op-col  .ea   endof
1A1B0F0 	80 6F A0  1 48 43 A0  1 
1A1B0F8 	20  0  0  0 20 7C A0  1 
1A1B100 	 3 64 65 63  0  0  0  0 
1A1B108 	50 85 A1  1 94 84 A1  1 
1A1B110 	6C 43 A0  1 B4  0  0  0 
      2 of  .call  .ea   endof
1A1B118 	90 6F A0  1 48 43 A0  1 
1A1B120 	14  0  0  0 94 AB A1  1 
1A1B128 	94 84 A1  1 6C 43 A0  1 
1A1B130 	98  0  0  0 
      3 of  .call  .ep   endof
1A1B134 	A0 6F A0  1 
1A1B138 	48 43 A0  1 14  0  0  0 
1A1B140 	94 AB A1  1 94 B0 A1  1 
1A1B148 	6C 43 A0  1 7C  0  0  0 
      4 of  .jmp   .ea   instruction @  e7 =  end-found !  endof
1A1B150 	B0 6F A0  1 48 43 A0  1 
1A1B158 	30  0  0  0 B8 AB A1  1 
1A1B160 	94 84 A1  1 B4 7A A1  1 
1A1B168 	5C 4C A0  1 58 41 A0  1 
1A1B170 	E7  0  0  0 24 48 A0  1 
1A1B178 	CC 7A A1  1 54 4D A0  1 
1A1B180 	6C 43 A0  1 44  0  0  0 
      5 of  .jmp   .ep   endof
1A1B188 	C0 6F A0  1 48 43 A0  1 
1A1B190 	14  0  0  0 B8 AB A1  1 
1A1B198 	94 B0 A1  1 6C 43 A0  1 
1A1B1A0 	28  0  0  0 
      6 of  .push  .ea   endof
1A1B1A4 	D0 6F A0  1 
1A1B1A8 	48 43 A0  1 14  0  0  0 
1A1B1B0 	24 8A A1  1 94 84 A1  1 
1A1B1B8 	6C 43 A0  1  C  0  0  0 
         .unimp
1A1B1C0 	8C 8D A1  1 
   endcase
1A1B1C4 	84 43 A0  1 
;
1A1B1C8 	58 46 A0  1 
: .opf  ( -- )
1A1B1CC 	 0  0  0 2E 
1A1B1D0 	6F 70 66 84 BC B0 A1  1 
1A1B1D8 	20 40 A0  1 
   low4bits  lowbits  6 <  if
1A1B1DC 	50 7D A1  1 
1A1B1E0 	2C 7D A1  1 D0 6F A0  1 
1A1B1E8 	E4 47 A0  1 DC 41 A0  1 
1A1B1F0 	14  0  0  0 
      >fline-ops ".
1A1B1F4 	 0 AE A1  1 
1A1B1F8 	A8 7C A0  1 
   else
1A1B1FC 	C8 41 A0  1 
1A1B200 	70  0  0  0 
      case
         6 of  .grp3   endof
1A1B204 	D0 6F A0  1 
1A1B208 	48 43 A0  1 10  0  0  0 
1A1B210 	D8 AE A1  1 6C 43 A0  1 
1A1B218 	58  0  0  0 
         7 of  .grp3   endof
1A1B21C 	E0 6F A0  1 
1A1B220 	48 43 A0  1 10  0  0  0 
1A1B228 	D8 AE A1  1 6C 43 A0  1 
1A1B230 	40  0  0  0 
         e of  .grp4   endof
1A1B234 	58 41 A0  1 
1A1B238 	 E  0  0  0 48 43 A0  1 
1A1B240 	10  0  0  0 24 B0 A1  1 
1A1B248 	6C 43 A0  1 24  0  0  0 
         f of  .grp5   endof
1A1B250 	58 41 A0  1  F  0  0  0 
1A1B258 	48 43 A0  1 10  0  0  0 
1A1B260 	BC B0 A1  1 6C 43 A0  1 
1A1B268 	 8  0  0  0 
      endcase
1A1B26C 	84 43 A0  1 
   then
;
1A1B270 	58 46 A0  1 
: .movi ( -- )
1A1B274 	 0  0 2E 6D 
1A1B278 	6F 76 69 85 D8 B1 A1  1 
1A1B280 	20 40 A0  1 
   ." mov" op-col  3 1 ibits  is wbit  lowbits >greg type  ,ib/v
1A1B284 	20 7C A0  1 
1A1B288 	 3 6D 6F 76  0  0  0  0 
1A1B290 	50 85 A1  1 A0 6F A0  1 
1A1B298 	80 6F A0  1 F4 7C A1  1 
1A1B2A0 	B8 40 A0  1 18 7D A1  1 
1A1B2A8 	2C 7D A1  1 D4 80 A1  1 
1A1B2B0 	 4 6C A0  1 F4 88 A1  1 
;
1A1B2B8 	58 46 A0  1 
d# 16 case: op-class
1A1B2BC 	 0  0  0 6F 
1A1B2C0 	70 2D 63 6C 61 73 73 88 
1A1B2C8 	80 B2 A1  1 B8 24 A1  1 
1A1B2D0 	10  0  0  0 
   .2op  .2op  .2op  .2op  .1op  .1op  .op6  .jcc
1A1B2D4 	A4 9B A1  1 
1A1B2D8 	A4 9B A1  1 A4 9B A1  1 
1A1B2E0 	A4 9B A1  1 E8 9B A1  1 
1A1B2E8 	E8 9B A1  1 BC 9C A1  1 
1A1B2F0 	A0 8B A1  1 
   .op8  .op9  .opa  .movi .opc  .opd  .ope  .opf
1A1B2F4 	70 9F A1  1 
1A1B2F8 	EC A2 A1  1 70 A3 A1  1 
1A1B300 	80 B2 A1  1  0 A7 A1  1 
1A1B308 	CC A9 A1  1 1C AC A1  1 
1A1B310 	D8 B1 A1  1 
;
1A1B314 	58 46 A0  1 

: (dis-body)  ( -- )  branch-target off  decode-op  op-class  ;
1A1B318 	 0 28 64 69 73 2D 62 6F 
1A1B320 	64 79 29 8A CC B2 A1  1 
1A1B328 	20 40 A0  1 F8 7A A1  1 
1A1B330 	F8 4B A0  1 18 8C A1  1 
1A1B338 	CC B2 A1  1 58 46 A0  1 
' (dis-body) is dis-body
: dis1  ( -- )
1A1B340 	 0  0  0 64 69 73 31 84 
1A1B348 	28 B3 A1  1 20 40 A0  1 
   ??cr
1A1B350 	 0 A1 A0  1 
   pc @ showaddr  4 spaces  #out @  start-column !
1A1B354 	DC 7A A1  1 
1A1B358 	5C 4C A0  1 30 13 A1  1 
1A1B360 	B0 6F A0  1 E8 71 A0  1 
1A1B368 	5C 6D A0  1 5C 4C A0  1 
1A1B370 	3C 85 A1  1 54 4D A0  1 
   dis-body  cr
1A1B378 	20 9C A1  1 80 6D A0  1 
;
1A1B380 	58 46 A0  1 
: +dis  ( -- )
1A1B384 	 0  0  0 2B 
1A1B388 	64 69 73 84 4C B3 A1  1 
1A1B390 	20 40 A0  1 
   base @ >r  hex
1A1B394 	B8 75 A0  1 
1A1B398 	5C 4C A0  1 BC 45 A0  1 
1A1B3A0 	C0 8D A0  1 
   end-found off
1A1B3A4 	CC 7A A1  1 
1A1B3A8 	F8 4B A0  1 
   begin   dis1  end-found @  exit? or  until
1A1B3AC 	4C B3 A1  1 
1A1B3B0 	CC 7A A1  1 5C 4C A0  1 
1A1B3B8 	34  D A1  1 70 44 A0  1 
1A1B3C0 	DC 41 A0  1 E8 FF FF FF 
   r> base !
1A1B3C8 	D0 45 A0  1 B8 75 A0  1 
1A1B3D0 	54 4D A0  1 
;
1A1B3D4 	58 46 A0  1 
: dis      ( adr -- )   pc !   +dis  ;
1A1B3D8 	64 69 73 83 90 B3 A1  1 
1A1B3E0 	20 40 A0  1 DC 7A A1  1 
1A1B3E8 	54 4D A0  1 90 B3 A1  1 
1A1B3F0 	58 46 A0  1 
: pc!dis1  ( adr -- )   pc !   dis1  ;
1A1B3F4 	70 63 21 64 
1A1B3F8 	69 73 31 87 E0 B3 A1  1 
1A1B400 	20 40 A0  1 DC 7A A1  1 
1A1B408 	54 4D A0  1 4C B3 A1  1 
1A1B410 	58 46 A0  1 
forth definitions disassembler  \ Search disassembler but define in forth

alias pc!dis1 pc!dis1
1A1B414 	70 63 21 64 
1A1B418 	69 73 31 A7 94 7A A1  1 
1A1B420 	 0 B4 A1  1 
alias +dis +dis
1A1B424 	 0  0  0 2B 
1A1B428 	64 69 73 A4 20 B4 A1  1 
1A1B430 	90 B3 A1  1 
alias dis dis
1A1B434 	64 69 73 A3 
1A1B438 	30 B4 A1  1 E0 B3 A1  1 
alias dis16 dis16
1A1B440 	 0  0 64 69 73 31 36 A5 
1A1B448 	3C B4 A1  1 7C 7C A1  1 
alias dis32 dis32
1A1B450 	 0  0 64 69 73 33 32 A5 
1A1B458 	4C B4 A1  1 A8 7C A1  1 

previous previous previous definitions


only forth also hidden 
  ' dis is disassemble
only forth also definitions

OpenFirmware/cpu/x86/disassem.fth_AL	39DF 1A1B460 
\ Machine dependent support routines used for the objects package.
\ These words know intimate details about the Forth virtual machine
\ implementation.

\ Assembles the common code executed by actions.  That code
\ extracts the next token (which is the acf of the object) from the
\ code stream and leaves the corresponding apf on the stack.

: start-code  ( -- )  code-cf  !csp  ;
1A1B460 	 0 73 74 61 72 74 2D 63 
1A1B468 	6F 64 65 8A 5C B4 A1  1 
1A1B470 	20 40 A0  1  8 5B A0  1 
1A1B478 	D4 A2 A0  1 58 46 A0  1 

\ Assembles the code which begins a ;code clause
\ For this version, the acf of the child word is left in w
: start-;code  ( -- )  start-code  ;
1A1B480 	73 74 61 72 74 2D 3B 63 
1A1B488 	6F 64 65 8B 70 B4 A1  1 
1A1B490 	20 40 A0  1 70 B4 A1  1 
1A1B498 	58 46 A0  1 

\ Code field for an object action.
: doaction  ( -- )  acf-align colon-cf  ;
1A1B49C 	 0  0  0 64 
1A1B4A0 	6F 61 63 74 69 6F 6E 88 
1A1B4A8 	90 B4 A1  1 20 40 A0  1 
1A1B4B0 	2C 5D A0  1 78 5B A0  1 
1A1B4B8 	58 46 A0  1 
   
\ Returns the address of the code executed by the word whose code field
\ address is acf
: >code-adr  ( acf -- code-adr )  token@  ;
1A1B4BC 	 0  0 3E 63 
1A1B4C0 	6F 64 65 2D 61 64 72 89 
1A1B4C8 	AC B4 A1  1 20 40 A0  1 
1A1B4D0 	 C 54 A0  1 58 46 A0  1 

code >action-adr  ( object-acf action# -- )
1A1B4D8 	3E 61 63 74 69 6F 6E 2D 
1A1B4E0 	61 64 72 8B CC B4 A1  1 
1A1B4E8 	EC B4 A1  1 
  ( ... -- object-acf action# #actions true | object-apf action-adr false )
   cx           pop		\ action# in cx
1A1B4EC 	59 
   ax           pop		\ object-acf in ax 
1A1B4ED 	58 
    0 [ax]  bx  mov		\ code address in bx
1A1B4EE 	8B 18 
\+ rel  up bx add
   -4 [bx]  cx  cmp		\ Test action number
1A1B4F0 	3B 4B FC 
   > if				\ "true" branch is error
1A1B4F3 	7E  C 
      cx          push		\ Push action#
1A1B4F5 	51 
      -4 [bx]     push		\ Push #actions
1A1B4F6 	FF 73 
1A1B4F8 	FC 
      true #  ax  mov		\ Return true for error
1A1B4F9 	B8 FF FF FF FF 
      1push
1A1B4FE 	50 
      next
1A1B4FF 	FF 
1A1B500 	E7 
   then
   4 #          ax  add		\ Push object-apf
1A1B501 	 5  4  0  0  0 
   ax               push
1A1B506 	50 
   cx               neg		\ Index backwards into action table
1A1B507 	F7 
1A1B508 	D9 
\- rel  -4 [bx] [cx] *4  push	\ Push action-adr
1A1B509 	FF 74 8B FC 
\+ rel  -4 [bx] [cx] *4  ax mov   up ax add   ax push	\ Push action-adr
   ax           ax  xor		\ Return false for no error
1A1B50D 	31 C0 
   1push
1A1B50F 	50 
c;
1A1B510 	FF E7 

: action-name  \ name  ( action# -- )
1A1B512 	 0  0 61 63 74 69 
1A1B518 	6F 6E 2D 6E 61 6D 65 8B 
1A1B520 	E8 B4 A1  1 20 40 A0  1 
   create ,		\ Store action number in data field
1A1B528 	A8 A2 A0  1 98 55 A0  1 
   ;code
1A1B530 	2C A3 A0  1 
   4 [ax]  cx  mov	\ Action# in cx
1A1B534 	8B 48  4 

   ax          lods	\ Object acf in ax
1A1B537 	AD 
\+ rel  up ax add
   4 #     ax  add	\ Compute pfa
1A1B538 	 5  4  0  0  0 
   ax          push	\ and push it
1A1B53D 	50 

   -4 [ax] ax  mov	\ Token of default action 
1A1B53E 	8B 40 
1A1B540 	FC 
\+ rel  up ax add
   
   cx          neg	\ Index backwards into action table
1A1B541 	F7 D9 
   -4 [ax] [cx] *4  ax  mov	\ Address of action code
1A1B543 	8B 44 88 FC 
\+ rel up ax add

\- rel   0 [ax]      jmp	\ Tail of "NEXT"
1A1B547 	FF 
1A1B548 	20 
\+ rel   0 [ax]  bx mov  up bx add    bx jmp	\ Tail of "NEXT"
end-code
: >action#  ( apf -- action# )  @  ;
1A1B549 	 0  0 3E 61 63 74 69 
1A1B550 	6F 6E 23 88 24 B5 A1  1 
1A1B558 	20 40 A0  1 5C 4C A0  1 
1A1B560 	58 46 A0  1 

headers

\ Some examples of object actions defined in code.
\ 3 actions
\ action-code
\    apf w lw   bubble  w  base w  addu
\    w 0 bx lw  bubble  bx base bx addu
\    bx jr      nop
\ end-code
\ action:  token!  ;  \ is
\ action:          ;  \ addr
\ : defer  \ name  ( -- )
\    create ['] crash token,
\    use-actions
\ ;
\ 3 actions
\ action-code  cx sp push  apf cx lw     c;     \ Default; fetch
\ action-code  cx apf sw   sp cx pop     c;     \ to
\ action-code  cx sp push  apf cx addiu  c;     \ addr
\ : value  \ name  ( initial-value -- )
\    create ,
\    use-actions
\ ;

OpenFirmware/cpu/x86/objsup.fth_AL	104 1A1B564 
\ Action definition for multiple-code-field words.
\ Data structures:
\   nth-action-does-clause   acfs  unnest
\   n-1th-action-does-clause acfs  unnest
\   ...
\   1th-action-does-clause acfs  unnest
\   nth-adr
\   n-1th-adr
\   ...
\   1th-adr
\   n
\   0th-action-does-clause acfs  unnest
\   object-header  build-acfs
\   (') 0th-adr uses

\ Object data structure:
\
\ Created by object defining words (actions, action:, etc):
\
\   tokenN-1  tokenN-1   ...    token1   #actions  (does-clause) ...
\   |________|________|________|________|________|________
\                                                ^
\                                                |
\                     ___________________________|
\                    |
\ Object instance:   |
\                    |
\   name  link  code-field  parameter-field
\               ^           ^
\               |           |
\            object-acf  object-apf

needs doaction objsup.fth	\ Machine-dependent support routines

decimal
headerless

0 value action#
1A1B564 	61 63 74 69 
1A1B568 	6F 6E 23 87 58 B5 A1  1 
1A1B570 	50 40 A0  1 BC  4  0  0 
0 value #actions
1A1B578 	 0  0  0 23 61 63 74 69 
1A1B580 	6F 6E 73 88 70 B5 A1  1 
1A1B588 	50 40 A0  1 C0  4  0  0 
0 value action-adr
1A1B590 	 0 61 63 74 69 6F 6E 2D 
1A1B598 	61 64 72 8A 88 B5 A1  1 
1A1B5A0 	50 40 A0  1 C4  4  0  0 
headers
: actions  ( #actions -- )
1A1B5A8 	61 63 74 69 6F 6E 73 87 
1A1B5B0 	A0 B5 A1  1 20 40 A0  1 
   is #actions
1A1B5B8 	B8 40 A0  1 88 B5 A1  1 
   #actions 1- /token * na1+ allot    ( #actions )   \ Make the jump table
1A1B5C0 	88 B5 A1  1 54 4B A0  1 
1A1B5C8 	B4 46 A0  1 1C 5F A0  1 
1A1B5D0 	CC 50 A0  1 E4 54 A0  1 
   \ The default action is a code field, which must be aligned
   align acf-align  here is action-adr
1A1B5D8 	34 62 A0  1 2C 5D A0  1 
1A1B5E0 	70 54 A0  1 B8 40 A0  1 
1A1B5E8 	A0 B5 A1  1 
   0 is action#
1A1B5EC 	70 6F A0  1 
1A1B5F0 	B8 40 A0  1 70 B5 A1  1 
   #actions  action-adr /n -  !
1A1B5F8 	88 B5 A1  1 A0 B5 A1  1 
1A1B600 	40 51 A0  1 18 45 A0  1 
1A1B608 	54 4D A0  1 
;
1A1B60C 	58 46 A0  1 
headerless
\ Sets the address entry in the action table
: set-action  ( -- )
1A1B610 	 0 73 65 74 2D 61 63 74 
1A1B618 	69 6F 6E 8A B4 B5 A1  1 
1A1B620 	20 40 A0  1 
   action#  #actions  >= abort" Too many actions defined"
1A1B624 	70 B5 A1  1 
1A1B628 	88 B5 A1  1 EC 48 A0  1 
1A1B630 	 8 81 A0  1 18 54 6F 6F 
1A1B638 	20 6D 61 6E 79 20 61 63 
1A1B640 	74 69 6F 6E 73 20 64 65 
1A1B648 	66 69 6E 65 64  0  0  0 
   lastacf  action-adr  action# /token * -  /n -  token!
1A1B650 	AC 57 A0  1 A0 B5 A1  1 
1A1B658 	70 B5 A1  1 B4 46 A0  1 
1A1B660 	1C 5F A0  1 18 45 A0  1 
1A1B668 	40 51 A0  1 18 45 A0  1 
1A1B670 	20 54 A0  1 
;
1A1B674 	58 46 A0  1 
headers
: action:  ( -- )
1A1B678 	61 63 74 69 6F 6E 3A 87 
1A1B680 	20 B6 A1  1 20 40 A0  1 
   action# if   \ Not the default action
1A1B688 	70 B5 A1  1 DC 41 A0  1 
1A1B690 	14  0  0  0 
      doaction set-action
1A1B694 	AC B4 A1  1 
1A1B698 	20 B6 A1  1 
   else \ The default action, like does>
1A1B69C 	C8 41 A0  1 
1A1B6A0 	 8  0  0  0 
      place-does
1A1B6A4 	4C 56 A0  1 
   then

   action# 1+ is action#
1A1B6A8 	70 B5 A1  1 30 4B A0  1 
1A1B6B0 	B8 40 A0  1 70 B5 A1  1 
   !csp
1A1B6B8 	D4 A2 A0  1 
   ]
1A1B6BC 	A0 6D A0  1 
;
1A1B6C0 	58 46 A0  1 
: action-code  ( -- )
1A1B6C4 	61 63 74 69 
1A1B6C8 	6F 6E 2D 63 6F 64 65 8B 
1A1B6D0 	84 B6 A1  1 20 40 A0  1 
   action#  if   \ Not the default action
1A1B6D8 	70 B5 A1  1 DC 41 A0  1 
1A1B6E0 	18  0  0  0 
      acf-align start-code set-action
1A1B6E4 	2C 5D A0  1 
1A1B6E8 	70 B4 A1  1 20 B6 A1  1 
   else          \ The default action, like ;code
1A1B6F0 	C8 41 A0  1  8  0  0  0 
      start-;code
1A1B6F8 	90 B4 A1  1 
   then

   \ For the default action, the apf of the child word is found in
   \ the same way as with ;code words.

   action# 1+ is action#
1A1B6FC 	70 B5 A1  1 
1A1B700 	30 4B A0  1 B8 40 A0  1 
1A1B708 	70 B5 A1  1 
   do-entercode
1A1B70C 	78 A3 A0  1 
;
1A1B710 	58 46 A0  1 
: use-actions  ( -- )
1A1B714 	75 73 65 2D 
1A1B718 	61 63 74 69 6F 6E 73 CB 
1A1B720 	D4 B6 A1  1 20 40 A0  1 
   state @  if
1A1B728 	38 54 A0  1 5C 4C A0  1 
1A1B730 	DC 41 A0  1 24  0  0  0 
      compile (')  action-adr  token,  compile used
1A1B738 	8C 75 A0  1 60 53 A0  1 
1A1B740 	A0 B5 A1  1 2C 55 A0  1 
1A1B748 	8C 75 A0  1 E0 57 A0  1 
   else
1A1B750 	C8 41 A0  1  C  0  0  0 
      action-adr  used
1A1B758 	A0 B5 A1  1 E0 57 A0  1 
   then
; immediate
1A1B760 	58 46 A0  1 

headerless
: .object-error
1A1B764 	 0  0 2E 6F 
1A1B768 	62 6A 65 63 74 2D 65 72 
1A1B770 	72 6F 72 8D 24 B7 A1  1 
1A1B778 	20 40 A0  1 
   ( object-acf action-adr false  |  acf action# #actions true -- ... )
   ( ... -- object-acf action-adr )
   if
1A1B77C 	DC 41 A0  1 
1A1B780 	78  0  0  0 
      ." Unimplemented action # " swap .d  ." on object " swap .name
1A1B784 	20 7C A0  1 
1A1B788 	17 55 6E 69 6D 70 6C 65 
1A1B790 	6D 65 6E 74 65 64 20 61 
1A1B798 	63 74 69 6F 6E 20 23 20 
1A1B7A0 	 0  0  0  0 68 49 A0  1 
1A1B7A8 	48  E A1  1 20 7C A0  1 
1A1B7B0 	 A 6F 6E 20 6F 62 6A 65 
1A1B7B8 	63 74 20  0 68 49 A0  1 
1A1B7C0 	C8 9A A0  1 
      ." , whose maximum action # is " 1- .d cr
1A1B7C4 	20 7C A0  1 
1A1B7C8 	1C 2C 20 77 68 6F 73 65 
1A1B7D0 	20 6D 61 78 69 6D 75 6D 
1A1B7D8 	20 61 63 74 69 6F 6E 20 
1A1B7E0 	23 20 69 73 20  0  0  0 
1A1B7E8 	54 4B A0  1 48  E A1  1 
1A1B7F0 	80 6D A0  1 
      abort
1A1B7F4 	28 91 A0  1 
   then
;
1A1B7F8 	58 46 A0  1 

headers

[ifdef] notdef
\ Run-time code for "to".  This is important enough to deserve special
\ optimization.
code to  ( -- )
   ax           lods	\ Object acf in ax
   4 #     ax   add
   ax           push	\ Put pfa in top-of-stack register

   -4 [ax]  ax  mov	\ Token of default action clause

   -8 [ax]  ax  mov	\ Token of "to" action clause

   0 [ax]      jmp	\ Tail of "NEXT"
end-code
[then]

\ Executes the numbered action of the indicated object
\ It might be worthwhile to implement perform-action entirely in code.

: perform-action  ( object-acf action# -- )
1A1B7FC 	 0 70 65 72 
1A1B800 	66 6F 72 6D 2D 61 63 74 
1A1B808 	69 6F 6E 8E 78 B7 A1  1 
1A1B810 	20 40 A0  1 
   dup if
1A1B814 	40 49 A0  1 
1A1B818 	DC 41 A0  1 18  0  0  0 
      >action-adr .object-error  ( object-apf action-adr )
1A1B820 	E8 B4 A1  1 78 B7 A1  1 
      execute
1A1B828 	98 41 A0  1 
   else
1A1B82C 	C8 41 A0  1 
1A1B830 	 C  0  0  0 
      drop execute
1A1B834 	30 49 A0  1 
1A1B838 	98 41 A0  1 
   then
;
1A1B83C 	58 46 A0  1 

1 action-name to
1A1B840 	 0 74 6F 82 10 B8 A1  1 
1A1B848 	34 B5 A1  1  1  0  0  0 
2 action-name addr
1A1B850 	 0  0  0 61 64 64 72 84 
1A1B858 	48 B8 A1  1 34 B5 A1  1 
1A1B860 	 2  0  0  0 
' to to 'ac-to
\ Add these words to the decompiler case tables so that the
\ debugger will display their arguments and so that the decompiler
\ will not show the action name and its argument on separate lines
\ if it happens to be near the end of a line.

[ifdef] install-decomp

also hidden also
: .action  ( ip -- ip' )
1A1B864 	2E 61 63 74 
1A1B868 	69 6F 6E 87 5C B8 A1  1 
1A1B870 	20 40 A0  1 
   d# 15 ?line  \ Just a guess
1A1B874 	58 41 A0  1 
1A1B878 	 F  0  0  0 A8 13 A1  1 
   dup token@ >name name>string cr". space ta1+
1A1B880 	40 49 A0  1  C 54 A0  1 
1A1B888 	24 74 A0  1 58 74 A0  1 
1A1B890 	60 23 A1  1 CC 71 A0  1 
1A1B898 	FC 50 A0  1 
   .compiled
1A1B89C 	8C 31 A1  1 
;
1A1B8A0 	58 46 A0  1 

  ' to to 'is2value

previous previous
[then]


: ?has-action  ( object-acf action-acf -- object-acf action-acf )
1A1B8A4 	3F 68 61 73 
1A1B8A8 	2D 61 63 74 69 6F 6E 8B 
1A1B8B0 	70 B8 A1  1 20 40 A0  1 
   2dup >body >action# >action-adr .object-error  2drop
1A1B8B8 	C0 49 A0  1 E4 59 A0  1 
1A1B8C0 	58 B5 A1  1 E8 B4 A1  1 
1A1B8C8 	78 B7 A1  1 AC 49 A0  1 
;
1A1B8D0 	58 46 A0  1 
: action-compiler:  \ name  ( -- )
1A1B8D4 	 0  0  0 61 
1A1B8D8 	63 74 69 6F 6E 2D 63 6F 
1A1B8E0 	6D 70 69 6C 65 72 3A 90 
1A1B8E8 	B4 B8 A1  1 20 40 A0  1 
   parse-word  2dup $find  $?missing drop  \ adr len xt
1A1B8F0 	34 93 A0  1 C0 49 A0  1 
1A1B8F8 	C4 93 A0  1 84 94 A0  1 
1A1B900 	30 49 A0  1 
   -rot $create  token,  immediate
1A1B904 	94 49 A0  1 
1A1B908 	8C A2 A0  1 2C 55 A0  1 
1A1B910 	BC B8 A0  1 
   does>             ( apf )
1A1B914 	50 A3 A0  1 
1A1B918 	90 90 90 E8 5C 87 FE FF 
      ' swap token@  ( object-acf action-acf )
1A1B920 	F8 95 A0  1 68 49 A0  1 
1A1B928 	 C 54 A0  1 
      ?has-action    ( object-acf action-acf )
1A1B92C 	B4 B8 A1  1 
      +level         ( apf )	\ Enter temporary compile state if necessary
1A1B930 	 4 83 A0  1 
      compile,		\ Compile run-time action-name word
1A1B934 	74 75 A0  1 
      compile,		\ Compile object acf
1A1B938 	74 75 A0  1 
      -level		\ Exit temporary compile state, perhaps run word
1A1B93C 	98 83 A0  1 
;
1A1B940 	58 46 A0  1 

also hidden
[ifdef] object-definer
: (object-definer)  ( action-acf -- definer )
1A1B944 	 0  0  0 28 
1A1B948 	6F 62 6A 65 63 74 2D 64 
1A1B950 	65 66 69 6E 65 72 29 90 
1A1B958 	EC B8 A1  1 20 40 A0  1 
   dup /n -  @                 ( action-acf #actions )
1A1B960 	40 49 A0  1 40 51 A0  1 
1A1B968 	18 45 A0  1 5C 4C A0  1 
   1- /token * - /n -  token@  ( last-action-acf )
1A1B970 	54 4B A0  1 B4 46 A0  1 
1A1B978 	1C 5F A0  1 18 45 A0  1 
1A1B980 	40 51 A0  1 18 45 A0  1 
1A1B988 	 C 54 A0  1 
   ta1+                        ( adr )
1A1B98C 	FC 50 A0  1 

   taligned
1A1B990 	54 62 A0  1 
   begin
      dup in-dictionary?  0=  if  drop ['] lose  exit  then
1A1B994 	40 49 A0  1 
1A1B998 	24 CF A0  1 24 47 A0  1 
1A1B9A0 	DC 41 A0  1 14  0  0  0 
1A1B9A8 	30 49 A0  1 60 53 A0  1 
1A1B9B0 	90 9B A0  1 40 46 A0  1 
      ta1+  dup  probably-cfa?
1A1B9B8 	FC 50 A0  1 40 49 A0  1 
1A1B9C0 	D4 1F A1  1 
   until
1A1B9C4 	DC 41 A0  1 
1A1B9C8 	CC FF FF FF 
;
1A1B9CC 	58 46 A0  1 
' (object-definer) is object-definer
[then]
previous

\ action-compiler: to
action-compiler: addr
1A1B9D0 	 0  0  0 61 64 64 72 C4 
1A1B9D8 	5C B9 A1  1 18 B9 A1  1 
1A1B9E0 	5C B8 A1  1 


\ Makes "is" and "to" synonymous.  "is" first checks to see if the
\ object is of one of the kernel object types (which don't have multiple
\ code fields), and if so, compiles or executes the "(is) <token>" form.
\ If the object is not of one of the kernel object types, "is" calls
\ "to-hook" to handle the object as a multiple-code field type object.

: (to)  ( [data] acf -- )  +level  compile to  compile, -level  ;
1A1B9E4 	 0  0  0 28 
1A1B9E8 	74 6F 29 84 DC B9 A1  1 
1A1B9F0 	20 40 A0  1  4 83 A0  1 
1A1B9F8 	8C 75 A0  1 48 B8 A1  1 
1A1BA00 	74 75 A0  1 98 83 A0  1 
1A1BA08 	58 46 A0  1 
' (to) is to-hook

alias to is
1A1BA0C 	 0 74 6F E2 
1A1BA10 	F0 B9 A1  1 98 C8 A0  1 

3 actions
1A1BA18 	48 BA A1  1 38 BA A1  1 
1A1BA20 	 3  0  0  0 
action: >user 2@ ;
1A1BA24 	90 90 90 E8 
1A1BA28 	50 86 FE FF C8 74 A0  1 
1A1BA30 	CC 4D A0  1 58 46 A0  1 
action: >user 2! ;
1A1BA38 	20 40 A0  1 C8 74 A0  1 
1A1BA40 	E4 4D A0  1 58 46 A0  1 
action: >user    ;
1A1BA48 	20 40 A0  1 C8 74 A0  1 
1A1BA50 	58 46 A0  1 
: 2value-cf  create-cf use-actions  ;
1A1BA54 	 0  0 32 76 
1A1BA58 	61 6C 75 65 2D 63 66 89 
1A1BA60 	14 BA A1  1 20 40 A0  1 
1A1BA68 	30 5B A0  1 60 53 A0  1 
1A1BA70 	24 BA A1  1 E0 57 A0  1 
1A1BA78 	58 46 A0  1 
: 2value  ( n1 n2 "name" -- )  header 2value-cf  2 /n* user#,  2!  ;
1A1BA7C 	 0 32 76 61 
1A1BA80 	6C 75 65 86 64 BA A1  1 
1A1BA88 	20 40 A0  1 DC 6D A0  1 
1A1BA90 	64 BA A1  1 90 6F A0  1 
1A1BA98 	98 51 A0  1 84 9A A0  1 
1A1BAA0 	E4 4D A0  1 58 46 A0  1 

OpenFirmware/forth/lib/objects.fth_AL	1348 1A1BAA8 purpose: Buffers for saving program state

headers
\ Data structures defining the CPU state saved by a breakpoint trap.
\ This must be loaded before either catchexc.fth or register.fth,
\ and is the complete interface between those 2 modules.

headers
\ A place to save the CPU registers when we take a trap
0 value cpu-state               \ Pointer to CPU state save area
1A1BAA8 	 0  0 63 70 75 2D 73 74 
1A1BAB0 	61 74 65 89 88 BA A1  1 
1A1BAB8 	50 40 A0  1 C8  4  0  0 

headerless
: >state  ( offset -- adr )  cpu-state  +  ;
1A1BAC0 	 0 3E 73 74 61 74 65 86 
1A1BAC8 	B8 BA A1  1 20 40 A0  1 
1A1BAD0 	B8 BA A1  1  4 45 A0  1 
1A1BAD8 	58 46 A0  1 

h# 40 constant ua-size
1A1BADC 	75 61 2D 73 
1A1BAE0 	69 7A 65 87 CC BA A1  1 
1A1BAE8 	68 40 A0  1 40  0  0  0 

ps-size  buffer: pssave		\ A place to save the Forth data stack
1A1BAF0 	 0 70 73 73 61 76 65 86 
1A1BAF8 	E8 BA A1  1 B4 A9 A0  1 
1A1BB00 	CC  4  0  0  0  8  0  0 
1A1BB08 	 8 7E A1  1 
rs-size  buffer: rssave		\ A place to save the Forth return stack
1A1BB0C 	 0 72 73 73 
1A1BB10 	61 76 65 86 FC BA A1  1 
1A1BB18 	B4 A9 A0  1 D0  4  0  0 
1A1BB20 	 0  8  0  0 FC BA A1  1 
ua-size  buffer: uasave		\ A place to save part of the Forth user area
1A1BB28 	 0 75 61 73 61 76 65 86 
1A1BB30 	18 BB A1  1 B4 A9 A0  1 
1A1BB38 	D4  4  0  0 40  0  0  0 
1A1BB40 	18 BB A1  1 
				\ we really want to save saved-rp and saved-sp

headers
defer .exception		\ Display the exception type
1A1BB44 	 0 2E 65 78 
1A1BB48 	63 65 70 74 69 6F 6E 8A 
1A1BB50 	34 BB A1  1 5C 40 A0  1 
1A1BB58 	D8  4  0  0 
defer handle-breakpoint		\ What to do after saving the state
1A1BB5C 	 0  0 68 61 
1A1BB60 	6E 64 6C 65 2D 62 72 65 
1A1BB68 	61 6B 70 6F 69 6E 74 91 
1A1BB70 	54 BB A1  1 5C 40 A0  1 
1A1BB78 	DC  4  0  0 

transient
variable next-reg
1A1BB7C 	 0  0  0 6E 
1A1BB80 	65 78 74 2D 72 65 67 88 
1A1BB88 	74 BB A1  1 48 40 A0  1 
1A1BB90 	E0  4  0  0 
0 next-reg !

: alloc-reg  ( size -- offset )   next-reg @  swap next-reg +!  ;
1A1BB94 	 0  0 61 6C 
1A1BB98 	6C 6F 63 2D 72 65 67 89 
1A1BBA0 	8C BB A1  1 20 40 A0  1 
1A1BBA8 	8C BB A1  1 5C 4C A0  1 
1A1BBB0 	68 49 A0  1 8C BB A1  1 
1A1BBB8 	 C 4C A0  1 58 46 A0  1 
resident

OpenFirmware/cpu/x86/cpustate.fth_AL	280 1A1BBC0 \ Display and modify the saved state of the machine.
\
\ This code is highly machine-dependent.  This version is for the x86
\
\ Defines:
\
\ %eax %ebx %ecx %edx %ebp %esp %esi %edi %cs %ds %es %fs %gs %eflags

hex

only forth hidden also forth also definitions

headerless

3 actions
1A1BBC0 	F8 BB A1  1 E4 BB A1  1 
1A1BBC8 	 3  0  0  0 
action:  @ >state  le-@  ;
1A1BBCC 	90 90 90 E8 
1A1BBD0 	A8 84 FE FF 5C 4C A0  1 
1A1BBD8 	CC BA A1  1 38 4C A0  1 
1A1BBE0 	58 46 A0  1 
action:  @ >state  le-!  ; ( to )
1A1BBE4 	20 40 A0  1 
1A1BBE8 	5C 4C A0  1 CC BA A1  1 
1A1BBF0 	30 4D A0  1 58 46 A0  1 
action:  @ >state        ; ( addr )
1A1BBF8 	20 40 A0  1 5C 4C A0  1 
1A1BC00 	CC BA A1  1 58 46 A0  1 
: register  \ name  ( -- )
1A1BC08 	 0  0  0 72 65 67 69 73 
1A1BC10 	74 65 72 88 A4 BB A1  1 
1A1BC18 	20 40 A0  1 
   create /n alloc-reg ,
1A1BC1C 	A8 A2 A0  1 
1A1BC20 	40 51 A0  1 A4 BB A1  1 
1A1BC28 	98 55 A0  1 
   use-actions
1A1BC2C 	60 53 A0  1 
1A1BC30 	CC BB A1  1 E0 57 A0  1 
;
1A1BC38 	58 46 A0  1 
action-adr-t to doregister
3 actions
1A1BC3C 	74 BC A1  1 
1A1BC40 	60 BC A1  1  3  0  0  0 
action:  @ >state  le-w@  ;
1A1BC48 	90 90 90 E8 2C 84 FE FF 
1A1BC50 	5C 4C A0  1 CC BA A1  1 
1A1BC58 	80 4C A0  1 58 46 A0  1 
action:  @ >state  le-w!  ; ( to )
1A1BC60 	20 40 A0  1 5C 4C A0  1 
1A1BC68 	CC BA A1  1 90 4D A0  1 
1A1BC70 	58 46 A0  1 
action:  @ >state      ; ( addr )
1A1BC74 	20 40 A0  1 
1A1BC78 	5C 4C A0  1 CC BA A1  1 
1A1BC80 	58 46 A0  1 
: wregister  \ name  ( -- )
1A1BC84 	 0  0 77 72 
1A1BC88 	65 67 69 73 74 65 72 89 
1A1BC90 	18 BC A1  1 20 40 A0  1 
   create /n alloc-reg ,
1A1BC98 	A8 A2 A0  1 40 51 A0  1 
1A1BCA0 	A4 BB A1  1 98 55 A0  1 
   use-actions
1A1BCA8 	60 53 A0  1 48 BC A1  1 
1A1BCB0 	E0 57 A0  1 
;
1A1BCB4 	58 46 A0  1 
headers

\ The following register save layout mimics the format of a
\ Task State Segment

wregister %tlink
1A1BCB8 	 0 25 74 6C 69 6E 6B 86 
1A1BCC0 	94 BC A1  1 48 BC A1  1 
1A1BCC8 	 0  0  0  0 
register %esp0   wregister %ss0
1A1BCCC 	 0  0 25 65 
1A1BCD0 	73 70 30 85 C4 BC A1  1 
1A1BCD8 	CC BB A1  1  4  0  0  0 
1A1BCE0 	 0  0  0 25 73 73 30 84 
1A1BCE8 	D8 BC A1  1 48 BC A1  1 
1A1BCF0 	 8  0  0  0 
register %esp1   wregister %ss1
1A1BCF4 	 0  0 25 65 
1A1BCF8 	73 70 31 85 EC BC A1  1 
1A1BD00 	CC BB A1  1  C  0  0  0 
1A1BD08 	 0  0  0 25 73 73 31 84 
1A1BD10 	 0 BD A1  1 48 BC A1  1 
1A1BD18 	10  0  0  0 
register %esp2   wregister %ss2
1A1BD1C 	 0  0 25 65 
1A1BD20 	73 70 32 85 14 BD A1  1 
1A1BD28 	CC BB A1  1 14  0  0  0 
1A1BD30 	 0  0  0 25 73 73 32 84 
1A1BD38 	28 BD A1  1 48 BC A1  1 
1A1BD40 	18  0  0  0 
register %cr3
1A1BD44 	 0  0  0 25 
1A1BD48 	63 72 33 84 3C BD A1  1 
1A1BD50 	CC BB A1  1 1C  0  0  0 
register %eip
1A1BD58 	 0  0  0 25 65 69 70 84 
1A1BD60 	50 BD A1  1 CC BB A1  1 
1A1BD68 	20  0  0  0 
register %eflags
1A1BD6C 	25 65 66 6C 
1A1BD70 	61 67 73 87 64 BD A1  1 
1A1BD78 	CC BB A1  1 24  0  0  0 

register %eax  register %ecx  register %edx  register %ebx
1A1BD80 	 0  0  0 25 65 61 78 84 
1A1BD88 	78 BD A1  1 CC BB A1  1 
1A1BD90 	28  0  0  0  0  0  0 25 
1A1BD98 	65 63 78 84 8C BD A1  1 
1A1BDA0 	CC BB A1  1 2C  0  0  0 
1A1BDA8 	 0  0  0 25 65 64 78 84 
1A1BDB0 	A0 BD A1  1 CC BB A1  1 
1A1BDB8 	30  0  0  0  0  0  0 25 
1A1BDC0 	65 62 78 84 B4 BD A1  1 
1A1BDC8 	CC BB A1  1 34  0  0  0 
register %esp  register %ebp  register %esi  register %edi
1A1BDD0 	 0  0  0 25 65 73 70 84 
1A1BDD8 	C8 BD A1  1 CC BB A1  1 
1A1BDE0 	38  0  0  0  0  0  0 25 
1A1BDE8 	65 62 70 84 DC BD A1  1 
1A1BDF0 	CC BB A1  1 3C  0  0  0 
1A1BDF8 	 0  0  0 25 65 73 69 84 
1A1BE00 	F0 BD A1  1 CC BB A1  1 
1A1BE08 	40  0  0  0  0  0  0 25 
1A1BE10 	65 64 69 84  4 BE A1  1 
1A1BE18 	CC BB A1  1 44  0  0  0 

wregister %es  wregister %cs  wregister %ss  wregister %ds
1A1BE20 	25 65 73 83 18 BE A1  1 
1A1BE28 	48 BC A1  1 48  0  0  0 
1A1BE30 	25 63 73 83 28 BE A1  1 
1A1BE38 	48 BC A1  1 4C  0  0  0 
1A1BE40 	25 73 73 83 38 BE A1  1 
1A1BE48 	48 BC A1  1 50  0  0  0 
1A1BE50 	25 64 73 83 48 BE A1  1 
1A1BE58 	48 BC A1  1 54  0  0  0 
wregister %fs  wregister %gs
1A1BE60 	25 66 73 83 58 BE A1  1 
1A1BE68 	48 BC A1  1 58  0  0  0 
1A1BE70 	25 67 73 83 68 BE A1  1 
1A1BE78 	48 BC A1  1 5C  0  0  0 
wregister %ldt
1A1BE80 	 0  0  0 25 6C 64 74 84 
1A1BE88 	78 BE A1  1 48 BC A1  1 
1A1BE90 	60  0  0  0 
register  %tio
1A1BE94 	 0  0  0 25 
1A1BE98 	74 69 6F 84 8C BE A1  1 
1A1BEA0 	CC BB A1  1 64  0  0  0 

\ The following registers are not present in a Task State Segment

register int#
1A1BEA8 	 0  0  0 69 6E 74 23 84 
1A1BEB0 	A0 BE A1  1 CC BB A1  1 
1A1BEB8 	68  0  0  0 
register %error
1A1BEBC 	 0 25 65 72 
1A1BEC0 	72 6F 72 86 B4 BE A1  1 
1A1BEC8 	CC BB A1  1 6C  0  0  0 

alias rup %edi  alias rip %esi  alias rrp %ebp  alias rsp %esp
1A1BED0 	72 75 70 A3 C8 BE A1  1 
1A1BED8 	18 BE A1  1 72 69 70 A3 
1A1BEE0 	D8 BE A1  1  4 BE A1  1 
1A1BEE8 	72 72 70 A3 E4 BE A1  1 
1A1BEF0 	F0 BD A1  1 72 73 70 A3 
1A1BEF8 	F0 BE A1  1 DC BD A1  1 
alias rpc %eip  alias %pc %eip
1A1BF00 	72 70 63 A3 FC BE A1  1 
1A1BF08 	64 BD A1  1 25 70 63 A3 
1A1BF10 	 8 BF A1  1 64 BD A1  1 

\ System registers, not visible to most application programs
\ wregister %ldtr   wregister %tr  register %gdtr  register %idtr

\ State information needed by the firmware; not machine registers
register watchdog        register %state-valid   register %restartable?
1A1BF18 	 0  0  0 77 61 74 63 68 
1A1BF20 	64 6F 67 88 14 BF A1  1 
1A1BF28 	CC BB A1  1 70  0  0  0 
1A1BF30 	 0  0  0 25 73 74 61 74 
1A1BF38 	65 2D 76 61 6C 69 64 8C 
1A1BF40 	28 BF A1  1 CC BB A1  1 
1A1BF48 	74  0  0  0  0  0 25 72 
1A1BF50 	65 73 74 61 72 74 61 62 
1A1BF58 	6C 65 3F 8D 44 BF A1  1 
1A1BF60 	CC BB A1  1 78  0  0  0 
register %saved-my-self  register sig#
1A1BF68 	 0 25 73 61 76 65 64 2D 
1A1BF70 	6D 79 2D 73 65 6C 66 8E 
1A1BF78 	60 BF A1  1 CC BB A1  1 
1A1BF80 	7C  0  0  0  0  0  0 73 
1A1BF88 	69 67 23 84 7C BF A1  1 
1A1BF90 	CC BB A1  1 80  0  0  0 

\ Following words defined here to satisfy the
\ references to these "variables" anywhere else
: saved-my-self ( -- addr )  addr %saved-my-self  ;
1A1BF98 	 0  0 73 61 76 65 64 2D 
1A1BFA0 	6D 79 2D 73 65 6C 66 8D 
1A1BFA8 	90 BF A1  1 20 40 A0  1 
1A1BFB0 	5C B8 A1  1 7C BF A1  1 
1A1BFB8 	58 46 A0  1 
: state-valid   ( -- addr )  addr %state-valid    ;
1A1BFBC 	73 74 61 74 
1A1BFC0 	65 2D 76 61 6C 69 64 8B 
1A1BFC8 	AC BF A1  1 20 40 A0  1 
1A1BFD0 	5C B8 A1  1 44 BF A1  1 
1A1BFD8 	58 46 A0  1 
: restartable?  ( -- addr )  addr %restartable?   ;
1A1BFDC 	 0  0  0 72 
1A1BFE0 	65 73 74 61 72 74 61 62 
1A1BFE8 	6C 65 3F 8C CC BF A1  1 
1A1BFF0 	20 40 A0  1 5C B8 A1  1 
1A1BFF8 	60 BF A1  1 58 46 A0  1 

: offset-of  \ reg-name  ( -- offset )
1A1C000 	 0  0 6F 66 66 73 65 74 
1A1C008 	2D 6F 66 89 F0 BF A1  1 
1A1C010 	20 40 A0  1 
   ' >body @
1A1C014 	F8 95 A0  1 
1A1C018 	E4 59 A0  1 5C 4C A0  1 
;
1A1C020 	58 46 A0  1 
decimal

only forth also definitions

OpenFirmware/cpu/x86/register.fth_AL	1124 1A1C024 \ .current-word  ( ip -- )	"ip" is an address which is presumed to
\				be within the body of some colon definition.
\				.current-word displays the name of that
\				definition.

\ .caller  ( ip -- )		Displays the colon definition name as in
\				.current-word, and also the address "ip"

decimal

only forth also hidden also forth definitions

headers
: .current-word  ( ip -- )  find-cfa  ( acf )  .name  ;
1A1C024 	 0  0 2E 63 
1A1C028 	75 72 72 65 6E 74 2D 77 
1A1C030 	6F 72 64 8D 10 C0 A1  1 
1A1C038 	20 40 A0  1 24 20 A1  1 
1A1C040 	C8 9A A0  1 58 46 A0  1 

headerless 
: .caller  ( ip -- )
1A1C048 	2E 63 61 6C 6C 65 72 87 
1A1C050 	38 C0 A1  1 20 40 A0  1 
   td 18 to-column ." Called from "  dup .current-word
1A1C058 	58 41 A0  1 12  0  0  0 
1A1C060 	 8 14 A1  1 20 7C A0  1 
1A1C068 	 C 43 61 6C 6C 65 64 20 
1A1C070 	66 72 6F 6D 20  0  0  0 
1A1C078 	40 49 A0  1 38 C0 A1  1 
   td 56 to-column ." at "  9 u.r
1A1C080 	58 41 A0  1 38  0  0  0 
1A1C088 	 8 14 A1  1 20 7C A0  1 
1A1C090 	 3 61 74 20  0  0  0  0 
1A1C098 	58 41 A0  1  9  0  0  0 
1A1C0A0 	E4 77 A0  1 
;
1A1C0A4 	58 46 A0  1 
headers 
only forth also definitions

OpenFirmware/forth/lib/caller.fth_AL	132 1A1C0A8 
\ Forth stack backtrace
\ Implements:
\ (rstrace  ( low-adr high-adr -- )
\    Shows the calling sequence that is stored in memory between the
\    two addresses.  This is assumed to be a saved return stack image.
\ \ rstrace  ( -- )
\ \    Shows the calling sequence that is stored on the return stack,
\ \    without destroying the return stack.

decimal
only forth also hidden also definitions
headerless
: @+  ( adr -- adr' n )  dup na1+ swap @  ; 
1A1C0A8 	 0 40 2B 82 2C 7A A1  1 
1A1C0B0 	20 40 A0  1 40 49 A0  1 
1A1C0B8 	CC 50 A0  1 68 49 A0  1 
1A1C0C0 	5C 4C A0  1 58 46 A0  1 
: .last-executed  ( ip -- )
1A1C0C8 	 0 2E 6C 61 73 74 2D 65 
1A1C0D0 	78 65 63 75 74 65 64 8E 
1A1C0D8 	B0 C0 A1  1 20 40 A0  1 
   ip>token token@  ( acf )
1A1C0E0 	CC 46 A0  1  C 54 A0  1 
   dup reasonable-ip?  if   .name   else   drop ." ??"   then
1A1C0E8 	40 49 A0  1 E8 79 A1  1 
1A1C0F0 	DC 41 A0  1 10  0  0  0 
1A1C0F8 	C8 9A A0  1 C8 41 A0  1 
1A1C100 	10  0  0  0 30 49 A0  1 
1A1C108 	20 7C A0  1  2 3F 3F  0 
;
1A1C110 	58 46 A0  1 
: in-catch?  ( ip -- flag )  find-cfa  ['] catch =  ;
1A1C114 	 0  0 69 6E 
1A1C118 	2D 63 61 74 63 68 3F 89 
1A1C120 	DC C0 A1  1 20 40 A0  1 
1A1C128 	24 20 A1  1 60 53 A0  1 
1A1C130 	14 7F A0  1 24 48 A0  1 
1A1C138 	58 46 A0  1 
: .catch  ( rs-adr -- rs-adr' )
1A1C13C 	 0 2E 63 61 
1A1C140 	74 63 68 86 24 C1 A1  1 
1A1C148 	20 40 A0  1 
   ."    Catch frame - SP: " @+ .  ."   my-self: "  @+ .  ."   handler: "  @+ .
1A1C14C 	20 7C A0  1 
1A1C150 	15 20 20 20 43 61 74 63 
1A1C158 	68 20 66 72 61 6D 65 20 
1A1C160 	2D 20 53 50 3A 20  0  0 
1A1C168 	B0 C0 A1  1 94 7A A0  1 
1A1C170 	20 7C A0  1  B 20 20 6D 
1A1C178 	79 2D 73 65 6C 66 3A 20 
1A1C180 	 0  0  0  0 B0 C0 A1  1 
1A1C188 	94 7A A0  1 20 7C A0  1 
1A1C190 	 B 20 20 68 61 6E 64 6C 
1A1C198 	65 72 3A 20  0  0  0  0 
1A1C1A0 	B0 C0 A1  1 94 7A A0  1 
;
1A1C1A8 	58 46 A0  1 
1 bits/cell 1- lshift constant minus0
1A1C1AC 	 0 6D 69 6E 
1A1C1B0 	75 73 30 86 48 C1 A1  1 
1A1C1B8 	68 40 A0  1  0  0  0 80 
: loop-end?  ( adr -- flag )
1A1C1C0 	 0  0 6C 6F 6F 70 2D 65 
1A1C1C8 	6E 64 3F 89 B8 C1 A1  1 
1A1C1D0 	20 40 A0  1 
   dup reasonable-ip?  0=  if    ( adr )
1A1C1D4 	40 49 A0  1 
1A1C1D8 	E8 79 A1  1 24 47 A0  1 
1A1C1E0 	DC 41 A0  1 10  0  0  0 
      drop false exit            ( -- false )
1A1C1E8 	30 49 A0  1 18 70 A0  1 
1A1C1F0 	40 46 A0  1 
   then                          ( adr )
   dup @ +                       ( adr' )
1A1C1F4 	40 49 A0  1 
1A1C1F8 	5C 4C A0  1  4 45 A0  1 
   dup reasonable-ip?  0=  if    ( adr )
1A1C200 	40 49 A0  1 E8 79 A1  1 
1A1C208 	24 47 A0  1 DC 41 A0  1 
1A1C210 	10  0  0  0 
      drop false exit            ( -- false )
1A1C214 	30 49 A0  1 
1A1C218 	18 70 A0  1 40 46 A0  1 
   then                          ( adr )
   ip>token  -1 na+  token@      ( xt )
1A1C220 	CC 46 A0  1 58 41 A0  1 
1A1C228 	FF FF FF FF 48 50 A0  1 
1A1C230 	 C 54 A0  1 
   dup ['] (loop) =  swap ['] (+loop) =  or  ( flag )
1A1C234 	40 49 A0  1 
1A1C238 	60 53 A0  1 F8 41 A0  1 
1A1C240 	24 48 A0  1 68 49 A0  1 
1A1C248 	60 53 A0  1 1C 42 A0  1 
1A1C250 	24 48 A0  1 70 44 A0  1 
;
1A1C258 	58 46 A0  1 

: .do-or-n  ( rs-adr n -- rs-adr' )
1A1C25C 	 0  0  0 2E 
1A1C260 	64 6F 2D 6F 72 2D 6E 88 
1A1C268 	D0 C1 A1  1 20 40 A0  1 
   over @ reasonable-ip?  0=  if              ( rs-adr n )
1A1C270 	54 49 A0  1 5C 4C A0  1 
1A1C278 	E8 79 A1  1 24 47 A0  1 
1A1C280 	DC 41 A0  1 8C  0  0  0 
      \ The second number is not an IP so it could be a do loop frame
      over na1+ @                             ( rs-adr n n2 )
1A1C288 	54 49 A0  1 CC 50 A0  1 
1A1C290 	5C 4C A0  1 
      dup loop-end?  if                       ( rs-adr n n2 )
1A1C294 	40 49 A0  1 
1A1C298 	D0 C1 A1  1 DC 41 A0  1 
1A1C2A0 	6C  0  0  0 
         ."    Do loop frame inside "
1A1C2A4 	20 7C A0  1 
1A1C2A8 	18 20 20 20 44 6F 20 6C 
1A1C2B0 	6F 6F 70 20 66 72 61 6D 
1A1C2B8 	65 20 69 6E 73 69 64 65 
1A1C2C0 	20  0  0  0 
\ mmo         ip>token .current-word               ( rs-adr n )
         over @                               ( rs-adr n n1 )
1A1C2C4 	54 49 A0  1 
1A1C2C8 	5C 4C A0  1 
         ."   i: "  tuck + .                  ( rs-adr n1 )
1A1C2CC 	20 7C A0  1 
1A1C2D0 	 5 20 20 69 3A 20  0  0 
1A1C2D8 	E8 46 A0  1  4 45 A0  1 
1A1C2E0 	94 7A A0  1 
         ."   limit: "  minus0  + .           ( rs-adr )
1A1C2E4 	20 7C A0  1 
1A1C2E8 	 9 20 20 6C 69 6D 69 74 
1A1C2F0 	3A 20  0  0 B8 C1 A1  1 
1A1C2F8 	 4 45 A0  1 94 7A A0  1 
         2 na+ exit                           ( -- rs-adr' )
1A1C300 	90 6F A0  1 48 50 A0  1 
1A1C308 	40 46 A0  1 
      then                                    ( rs-adr n n2 )
      drop                                    ( rs-adr n )
1A1C30C 	30 49 A0  1 
   then                                       ( rs-adr n )
   9 u.r
1A1C310 	58 41 A0  1  9  0  0  0 
1A1C318 	E4 77 A0  1 
;
1A1C31C 	58 46 A0  1 

: .traceline  ( ipaddr -- )
1A1C320 	 0 2E 74 72 61 63 65 6C 
1A1C328 	69 6E 65 8A 6C C2 A1  1 
1A1C330 	20 40 A0  1 
   push-hex
1A1C334 	5C F4 A0  1 
   dup reasonable-ip?
1A1C338 	40 49 A0  1 E8 79 A1  1 
   if    dup .last-executed ip>token .caller   else  9 u.r   then   cr
1A1C340 	DC 41 A0  1 1C  0  0  0 
1A1C348 	40 49 A0  1 DC C0 A1  1 
1A1C350 	CC 46 A0  1 54 C0 A1  1 
1A1C358 	C8 41 A0  1 10  0  0  0 
1A1C360 	58 41 A0  1  9  0  0  0 
1A1C368 	E4 77 A0  1 80 6D A0  1 
   pop-base
1A1C370 	9C F4 A0  1 
;
1A1C374 	58 46 A0  1 
\ Heuristic display of return stack items, recognizing Forth word nesting,
\ catch frames, and do loop frames.
\ For later: It would also be nice to recognize input stream nesting frames.
: rtraceline  ( rs-adr -- rs-adr' )
1A1C378 	 0 72 74 72 61 63 65 6C 
1A1C380 	69 6E 65 8A 30 C3 A1  1 
1A1C388 	20 40 A0  1 
   push-hex                    ( rs-adr )
1A1C38C 	5C F4 A0  1 
   @+                          ( rs-adr' ip )
1A1C390 	B0 C0 A1  1 
   dup reasonable-ip?  if      ( rs-adr ip )
1A1C394 	40 49 A0  1 
1A1C398 	E8 79 A1  1 DC 41 A0  1 
1A1C3A0 	3C  0  0  0 
      dup in-catch?  if        ( rs-adr ip )
1A1C3A4 	40 49 A0  1 
1A1C3A8 	24 C1 A1  1 DC 41 A0  1 
1A1C3B0 	14  0  0  0 
         drop .catch           ( rs-adr' )
1A1C3B4 	30 49 A0  1 
1A1C3B8 	48 C1 A1  1 
      else                     ( rs-adr ip )
1A1C3BC 	C8 41 A0  1 
1A1C3C0 	14  0  0  0 
         dup .last-executed ip>token .caller  ( rs-adr )
1A1C3C4 	40 49 A0  1 
1A1C3C8 	DC C0 A1  1 CC 46 A0  1 
1A1C3D0 	54 C0 A1  1 
      then                     ( rs-adr )
   else                        ( rs-adr ip )
1A1C3D4 	C8 41 A0  1 
1A1C3D8 	 8  0  0  0 
      .do-or-n                 ( rs-adr )
1A1C3DC 	6C C2 A1  1 
   then   cr                   ( rs-adr )
1A1C3E0 	80 6D A0  1 
   pop-base
1A1C3E4 	9C F4 A0  1 
;
1A1C3E8 	58 46 A0  1 
: (rstrace  ( end-adr start-adr -- )
1A1C3EC 	 0  0  0 28 
1A1C3F0 	72 73 74 72 61 63 65 88 
1A1C3F8 	88 C3 A1  1 20 40 A0  1 
    begin  2dup u>  while           ( end-adr adr )
1A1C400 	C0 49 A0  1 64 48 A0  1 
1A1C408 	DC 41 A0  1 24  0  0  0 
       rtraceline                   ( end-adr adr' )
1A1C410 	88 C3 A1  1 
       exit?  if  2drop exit  then  ( end-adr adr )
1A1C414 	34  D A1  1 
1A1C418 	DC 41 A0  1  C  0  0  0 
1A1C420 	AC 49 A0  1 40 46 A0  1 
    repeat                          ( end-adr adr )
1A1C428 	C8 41 A0  1 D4 FF FF FF 
    2drop
1A1C430 	AC 49 A0  1 
;
1A1C434 	58 46 A0  1 
: skip-catch  ( rs-adr -- rs-adr' )  3 na+  ;
1A1C438 	 0 73 6B 69 70 2D 63 61 
1A1C440 	74 63 68 8A FC C3 A1  1 
1A1C448 	20 40 A0  1 A0 6F A0  1 
1A1C450 	48 50 A0  1 58 46 A0  1 
: skip-do-or-n  ( rs-adr n -- rs-adr' )
1A1C458 	 0  0  0 73 6B 69 70 2D 
1A1C460 	64 6F 2D 6F 72 2D 6E 8C 
1A1C468 	48 C4 A1  1 20 40 A0  1 
   over @ reasonable-ip?  0=  if              ( rs-adr n )
1A1C470 	54 49 A0  1 5C 4C A0  1 
1A1C478 	E8 79 A1  1 24 47 A0  1 
1A1C480 	DC 41 A0  1 A0  0  0  0 
      \ The second number is not an IP so it could be a do loop frame
      over na1+ @  reasonable-ip?  if         ( rs-adr n )
1A1C488 	54 49 A0  1 CC 50 A0  1 
1A1C490 	5C 4C A0  1 E8 79 A1  1 
1A1C498 	DC 41 A0  1 88  0  0  0 
         \ The third entry is a reasonable IP so it could be a do loop frame
         \ Make sure it points to an offset that points just past a loop end
         over na1+ @  dup @ +                 ( rs-adr n n2 )
1A1C4A0 	54 49 A0  1 CC 50 A0  1 
1A1C4A8 	5C 4C A0  1 40 49 A0  1 
1A1C4B0 	5C 4C A0  1  4 45 A0  1 
         dup reasonable-ip?  if               ( rs-adr n adr )
1A1C4B8 	40 49 A0  1 E8 79 A1  1 
1A1C4C0 	DC 41 A0  1 5C  0  0  0 
            ip>token  -1 na+  token@          ( rs-adr n xt )
1A1C4C8 	CC 46 A0  1 58 41 A0  1 
1A1C4D0 	FF FF FF FF 48 50 A0  1 
1A1C4D8 	 C 54 A0  1 
            dup ['] (loop) =  swap ['] (+loop) =  or  if  ( rs-adr n )
1A1C4DC 	40 49 A0  1 
1A1C4E0 	60 53 A0  1 F8 41 A0  1 
1A1C4E8 	24 48 A0  1 68 49 A0  1 
1A1C4F0 	60 53 A0  1 1C 42 A0  1 
1A1C4F8 	24 48 A0  1 70 44 A0  1 
1A1C500 	DC 41 A0  1 14  0  0  0 
               \ The two numbers span the +- boundary, so probably a do loop
               drop                           ( rs-adr )
1A1C508 	30 49 A0  1 
               2 na+ exit                     ( -- rs-adr )
1A1C50C 	90 6F A0  1 
1A1C510 	48 50 A0  1 40 46 A0  1 
            then                              ( rs-adr n )
         else                                 ( rs-adr n n2 )
1A1C518 	C8 41 A0  1  8  0  0  0 
            drop                              ( rs-adr n )
1A1C520 	30 49 A0  1 
         then                                 ( rs-adr n )
      then                                    ( rs-adr n )
   then                                       ( rs-adr n )
   drop                                       ( rs-adr )
1A1C524 	30 49 A0  1 
;
1A1C528 	58 46 A0  1 

\ boring? is a hook for Open Firmware.  It recognizes words like
\ $call-method that are essentially indirect calls.  Such words
\ just clutter up the stack display and should be elided for clarity.
defer indirect-call?
1A1C52C 	 0 69 6E 64 
1A1C530 	69 72 65 63 74 2D 63 61 
1A1C538 	6C 6C 3F 8E 6C C4 A1  1 
1A1C540 	5C 40 A0  1 E4  4  0  0 

: (indirect-call?)  ( xt -- flag )  ['] catch =  ;
1A1C548 	 0  0  0 28 69 6E 64 69 
1A1C550 	72 65 63 74 2D 63 61 6C 
1A1C558 	6C 3F 29 90 40 C5 A1  1 
1A1C560 	20 40 A0  1 60 53 A0  1 
1A1C568 	14 7F A0  1 24 48 A0  1 
1A1C570 	58 46 A0  1 
' (indirect-call?) is indirect-call?


: rtraceword  ( rs-end rs-adr -- rs-end rs-adr' )
1A1C574 	 0 72 74 72 
1A1C578 	61 63 65 77 6F 72 64 8A 
1A1C580 	60 C5 A1  1 20 40 A0  1 
   @+                          ( rs-end rs-adr' ip )
1A1C588 	B0 C0 A1  1 
   dup reasonable-ip?  0=  if  ( rs-end rs-adr ip )
1A1C58C 	40 49 A0  1 
1A1C590 	E8 79 A1  1 24 47 A0  1 
1A1C598 	DC 41 A0  1  C  0  0  0 
      skip-do-or-n exit        ( -- rs-end rs-adr )
1A1C5A0 	6C C4 A1  1 40 46 A0  1 
   then                        ( rs-end rs-adr )

   dup in-catch?  if           ( rs-end rs-adr ip )
1A1C5A8 	40 49 A0  1 24 C1 A1  1 
1A1C5B0 	DC 41 A0  1 10  0  0  0 
      drop skip-catch          ( rs-end rs-adr' )
1A1C5B8 	30 49 A0  1 48 C4 A1  1 
      exit                     ( -- rs-end rs-adr' )
1A1C5C0 	40 46 A0  1 
   then                        ( rs-end rs-adr ip )

   find-cfa                    ( rs-end rs-adr xt )
1A1C5C4 	24 20 A1  1 

   dup indirect-call?  if      ( rs-end rs-adr xt )
1A1C5C8 	40 49 A0  1 40 C5 A1  1 
1A1C5D0 	DC 41 A0  1  C  0  0  0 
      drop exit                ( -- rs-end rs-adr )
1A1C5D8 	30 49 A0  1 40 46 A0  1 
   then                        ( rs-end rs-adr xt )

   dup ['] interpret-do-defined =  if  ( rs-end rs-adr xt )
1A1C5E0 	40 49 A0  1 60 53 A0  1 
1A1C5E8 	3C 9F A0  1 24 48 A0  1 
1A1C5F0 	DC 41 A0  1 10  0  0  0 
      \ Set rs-adr = rs-end so the caller will exit
      2drop dup exit           ( -- rs-end rs-adr' )
1A1C5F8 	AC 49 A0  1 40 49 A0  1 
1A1C600 	40 46 A0  1 
   then                        ( rs-end rs-adr xt )

   >name name>string           ( rs-end rs-adr adr len )
1A1C604 	24 74 A0  1 
1A1C608 	58 74 A0  1 
   dup #out @ +  rmargin @  >=  if  ( rs-end rs-adr adr len )
1A1C60C 	40 49 A0  1 
1A1C610 	5C 6D A0  1 5C 4C A0  1 
1A1C618 	 4 45 A0  1 94 13 A1  1 
1A1C620 	5C 4C A0  1 EC 48 A0  1 
1A1C628 	DC 41 A0  1 20  0  0  0 
      \ Set rs-adr = rs-end so the caller will exit
      2drop ." ..."            ( rs-end rs-adr )
1A1C630 	AC 49 A0  1 20 7C A0  1 
1A1C638 	 3 2E 2E 2E  0  0  0  0 
      drop dup exit            ( -- rs-end rs-adr' )
1A1C640 	30 49 A0  1 40 49 A0  1 
1A1C648 	40 46 A0  1 
   then                        ( rs-end rs-adr adr len )

   type space                  ( rs-end rs-adr )
1A1C64C 	 4 6C A0  1 
1A1C650 	CC 71 A0  1 
;
1A1C654 	58 46 A0  1 
: rslist  ( end-adr start-adr -- )
1A1C658 	 0 72 73 6C 69 73 74 86 
1A1C660 	84 C5 A1  1 20 40 A0  1 
   begin  2dup u>  while           ( end-adr adr )
1A1C668 	C0 49 A0  1 64 48 A0  1 
1A1C670 	DC 41 A0  1 10  0  0  0 
      rtraceword                   ( end-adr adr' )
1A1C678 	84 C5 A1  1 
   repeat                          ( end-adr adr )
1A1C67C 	C8 41 A0  1 
1A1C680 	E8 FF FF FF 
   2drop
1A1C684 	AC 49 A0  1 
;
1A1C688 	58 46 A0  1 

only forth also definitions

OpenFirmware/forth/lib/rstrace.fth_AL	1508 1A1C68C 
vocset=5D8898 1A0050C 1A1C6D8 purpose: Machine-dependent interfaces used by the decompiler
hex

: low-dictionary-adr  ( -- adr )  origin  init-user-area +  user-size +  ;
1A1C68C 	 0 6C 6F 77 
1A1C690 	2D 64 69 63 74 69 6F 6E 
1A1C698 	61 72 79 2D 61 64 72 92 
1A1C6A0 	54 C0 A1  1 20 40 A0  1 
1A1C6A8 	50 55 A0  1 24 60 A0  1 
1A1C6B0 	 4 45 A0  1 E8 65 A0  1 
1A1C6B8 	 4 45 A0  1 58 46 A0  1 

nuser debug-next  \ Pointer to "next"
1A1C6C0 	 0 64 65 62 75 67 2D 6E 
1A1C6C8 	65 78 74 8A A4 C6 A1  1 
1A1C6D0 	48 40 A0  1 E8  4  0  0 
vocabulary bug   bug also definitions
1A1C6D8 	62 75 67 83 D0 C6 A1  1 
1A1C6E0 	E0 B6 A0  1 EC  4  0  0 
1A1C6E8 	94 7A A1  1  0  0  0  0 
nuser 'debug   \ code field for high level trace
1A1C6F0 	 0 27 64 65 62 75 67 86 
1A1C6F8 	 0  0 A0  1 48 40 A0  1 
1A1C700 	F0  4  0  0 
nuser <ip      \ lower limit of ip
1A1C704 	3C 69 70 83 
1A1C708 	FC C6 A1  1 48 40 A0  1 
1A1C710 	F4  4  0  0 
nuser ip>      \ upper limit of ip
1A1C714 	69 70 3E 83 
1A1C718 	 C C7 A1  1 48 40 A0  1 
1A1C720 	F8  4  0  0 
nuser cnt      \ how many times thru debug next
1A1C724 	63 6E 74 83 
1A1C728 	1C C7 A1  1 48 40 A0  1 
1A1C730 	FC  4  0  0 

label _flush_cache  ( -- )
1A1C734 	 0  0  0 5F 
1A1C738 	66 6C 75 73 68 5F 63 61 
1A1C740 	63 68 65 8C 2C C7 A1  1 
1A1C748 	30 40 A0  1 
   ret
1A1C74C 	C3 
end-code

label _disable_cache  ( -- )
1A1C74D 	5F 64 69 
1A1C750 	73 61 62 6C 65 5F 63 61 
1A1C758 	63 68 65 8E 48 C7 A1  1 
1A1C760 	30 40 A0  1 
   ret
1A1C764 	C3 
end-code

\ Change all the next routines in the indicated range to jump through
\ the user area vector
code slow-next  ( high low -- )
1A1C765 	 0 73 6C 
1A1C768 	6F 77 2D 6E 65 78 74 89 
1A1C770 	60 C7 A1  1 78 C7 A1  1 
   ax pop   ax pop
1A1C778 	58 58 
   _disable_cache #) call
1A1C77A 	E8 E5 FF FF FF 
   h# a7ff #  ax  mov		\ disp [up] jmp
1A1C77F 	B8 
1A1C780 	FF A7  0  0 
   op: ax  0 [up]  mov
1A1C784 	66 89  7 
   'user# debug-next #  ax  mov	  \ 'disp' is user area offset of debug-next
1A1C787 	B8 
1A1C788 	E8  4  0  0 
   ax      2 [up]  mov
1A1C78C 	89 47  2 
   _flush_cache #) call
1A1C78F 	E8 
1A1C790 	B8 FF FF FF 
c;
1A1C794 	FF E7 

\ Fix the NEXT routine in the user area to use the non-debug code.
code fast-next  ( high low -- )
1A1C796 	66 61 
1A1C798 	73 74 2D 6E 65 78 74 89 
1A1C7A0 	74 C7 A1  1 A8 C7 A1  1 
   ax pop   ax pop
1A1C7A8 	58 58 
   _disable_cache #)  call
1A1C7AA 	E8 B5 FF FF FF 

\+ rel  h# 8bf801ad #  ax mov	ax 0 [up]  mov	\ ax lods  up w add
\+ rel  h# fffb0118 #  ax mov	ax 4 [up]  mov	\ 0 [w] bx mov  up bx add
\+ rel  h# 909090e3 #  ax mov	ax 8 [up]  mov	\ bx jmp  nop nop nop

\- rel  h# 9020ffad #  ax mov	ax 0 [up]  mov	\ ax lods  0 [w] jmp  nop
1A1C7AF 	B8 
1A1C7B0 	AD FF 20 90 89  7 

   _flush_cache #)    call
1A1C7B6 	E8 91 
1A1C7B8 	FF FF FF 
c;
1A1C7BB 	FF E7 

label normal-next
1A1C7BD 	 0  0  0 
1A1C7C0 	6E 6F 72 6D 61 6C 2D 6E 
1A1C7C8 	65 78 74 8B A4 C7 A1  1 
1A1C7D0 	30 40 A0  1 
   \ We have to expand the code for NEXT in-line here, because if
   \ we let the assembler macro do it, we'll end up with a jump right back
   \ to this routine
\+ rel  ax lods  up w add   0 [w] bx mov  up bx add   bx jmp
\- rel  ax lods  0 [w] jmp
1A1C7D4 	AD FF 20 
end-code

label debnext
1A1C7D7 	 0 
1A1C7D8 	64 65 62 6E 65 78 74 87 
1A1C7E0 	D0 C7 A1  1 30 40 A0  1 
   'user <ip   ip  cmp
1A1C7E8 	3B B7 F4  4  0  0 
   u>= if
1A1C7EE 	72 38 
      'user ip>   ip  cmp
1A1C7F0 	3B B7 F8  4  0  0 
      u< if
1A1C7F6 	73 30 
         'user cnt  ax  mov
1A1C7F8 	8B 87 FC  4  0  0 
	 ax             inc
1A1C7FE 	40 
         ax  'user cnt  mov
1A1C7FF 	89 
1A1C800 	87 FC  4  0  0 
         2 #        ax  cmp
1A1C805 	3D  2  0 
1A1C808 	 0  0 
	 = if
1A1C80A 	75 1C 
            ax ax sub
1A1C80C 	29 C0 
	    ax  'user cnt         mov
1A1C80E 	89 87 
1A1C810 	FC  4  0  0 
\            normal-next #)   ax   lea
	    make-even 				\ word-align address
\- rel      normal-next   dup #)   ax   lea
1A1C814 	8D  5 D4 C7 
1A1C818 	A1  1 
\- rel      -4 allot  token, 			\ relocate address

\+ rel      normal-next origin -  #  ax  mov
\+ rel      up ax add

            ax  'user debug-next  mov
1A1C81A 	89 87 E8  4  0  0 

            'user 'debug     w    mov
1A1C820 	8B 87 F0  4  0  0 
\+ rel      up w add  0 [w] bx mov  up bx add   bx jmp
\- rel      0 [w]                 jmp
1A1C826 	FF 20 
         then
      then
   then
   \ We have to expand the code for NEXT in-line here, because if
   \ we let the assembler macro do it, we'll end up with a jump right back
   \ to this routine
\+ rel   ax lods  up w add   0 [w] bx mov  up bx add   bx jmp
\- rel   ax lods   0 [w] jmp		\ Next
1A1C828 	AD FF 20 
end-code

\ Fix the next routine to use the debug version
: pnext   (s -- )  debnext debug-next !  ;
1A1C82B 	 0  0  0 70 6E 
1A1C830 	65 78 74 85 E4 C7 A1  1 
1A1C838 	20 40 A0  1 E4 C7 A1  1 
1A1C840 	D0 C6 A1  1 54 4D A0  1 
1A1C848 	58 46 A0  1 

\ Turn off debugging
: unbug   (s -- )  normal-next debug-next !  ;
1A1C84C 	 0  0 75 6E 
1A1C850 	62 75 67 85 38 C8 A1  1 
1A1C858 	20 40 A0  1 D0 C7 A1  1 
1A1C860 	D0 C6 A1  1 54 4D A0  1 
1A1C868 	58 46 A0  1 

forth definitions
unbug

OpenFirmware/cpu/x86/debugm.fth_AL	1E0 1A1C86C \ Debugger.  Thanks, Mike Perry, Henry Laxen, Mark Smeder.
\
\ The debugger lets you single step the execution of a high level
\ definition.  To invoke the debugger, type debug xxx where xxx is
\ the name of the word you wish to trace.  When xxx executes, you will
\ get a single step trace showing you the word within xxx that
\ is about to execute, and the contents of the parameter stack.
\ Debugging makes everything run slightly slower, even outside
\ the word being debugged.  see debug-off
\
\ debug name	Mark that word for debugging
\ stepping	Debug in single step mode
\ tracing	Debug in trace mode
\ debug-off	Turn off the debugger (makes the system run fast again)
\ resume	Exit from a pushed interpreter (see the f keystroke)
\
\ Keystroke commands while you're single-stepping:
\   d		go down a level
\   u		go up a level
\   c		continue; trace without single stepping
\   g		go; turn off stepping and continue execution
\   f		push a Forth interpreter;  execute "resume" to get back
\   q		abort back to the top level

only forth also definitions

false value scrolling-debug?
1A1C86C 	 0  0  0 73 
1A1C870 	63 72 6F 6C 6C 69 6E 67 
1A1C878 	2D 64 65 62 75 67 3F 90 
1A1C880 	E0 C6 A1  1 50 40 A0  1 
1A1C888 	 0  5  0  0 

hex
headerless
variable slow-next?  slow-next? off
1A1C88C 	 0 73 6C 6F 
1A1C890 	77 2D 6E 65 78 74 3F 8A 
1A1C898 	84 C8 A1  1 48 40 A0  1 
1A1C8A0 	 4  5  0  0 

only forth hidden also forth also definitions
bug also definitions
variable step? step? on
1A1C8A4 	 0  0 73 74 
1A1C8A8 	65 70 3F 85 58 C8 A1  1 
1A1C8B0 	48 40 A0  1  8  5  0  0 
variable res
1A1C8B8 	72 65 73 83 B0 C8 A1  1 
1A1C8C0 	48 40 A0  1  C  5  0  0 
headers

-1 value displayed-xt
1A1C8C8 	 0  0  0 64 69 73 70 6C 
1A1C8D0 	61 79 65 64 2D 78 74 8C 
1A1C8D8 	C0 C8 A1  1 50 40 A0  1 
1A1C8E0 	10  5  0  0 
: force-redisplay  ( -- )  -1 to displayed-xt  ;
1A1C8E4 	66 6F 72 63 
1A1C8E8 	65 2D 72 65 64 69 73 70 
1A1C8F0 	6C 61 79 8F DC C8 A1  1 
1A1C8F8 	20 40 A0  1 58 41 A0  1 
1A1C900 	FF FF FF FF B8 40 A0  1 
1A1C908 	DC C8 A1  1 58 46 A0  1 

: (debug)       (s low-adr hi-adr -- )
1A1C910 	28 64 65 62 75 67 29 87 
1A1C918 	F8 C8 A1  1 20 40 A0  1 
   unbug   1 cnt !   ip> !   <ip !   pnext
1A1C920 	58 C8 A1  1 80 6F A0  1 
1A1C928 	2C C7 A1  1 54 4D A0  1 
1A1C930 	1C C7 A1  1 54 4D A0  1 
1A1C938 	 C C7 A1  1 54 4D A0  1 
1A1C940 	38 C8 A1  1 
   slow-next? @ 0=  if
1A1C944 	9C C8 A1  1 
1A1C948 	5C 4C A0  1 24 47 A0  1 
1A1C950 	DC 41 A0  1 18  0  0  0 
      here  low-dictionary-adr  slow-next
1A1C958 	70 54 A0  1 A4 C6 A1  1 
1A1C960 	74 C7 A1  1 
      slow-next? on
1A1C964 	9C C8 A1  1 
1A1C968 	E0 4B A0  1 
   then
   step? on
1A1C96C 	B0 C8 A1  1 
1A1C970 	E0 4B A0  1 
   force-redisplay
1A1C974 	F8 C8 A1  1 
;
1A1C978 	58 46 A0  1 

headerless
: 'unnest   (s pfa -- pfa' )
1A1C97C 	27 75 6E 6E 
1A1C980 	65 73 74 87 1C C9 A1  1 
1A1C988 	20 40 A0  1 
   begin   dup ta1+  swap  token@ ['] unnest =  until
1A1C98C 	40 49 A0  1 
1A1C990 	FC 50 A0  1 68 49 A0  1 
1A1C998 	 C 54 A0  1 60 53 A0  1 
1A1C9A0 	58 46 A0  1 24 48 A0  1 
1A1C9A8 	DC 41 A0  1 E0 FF FF FF 
;
1A1C9B0 	58 46 A0  1 
: set-<ip  (s pfa -- )
1A1C9B4 	73 65 74 2D 
1A1C9B8 	3C 69 70 87 88 C9 A1  1 
1A1C9C0 	20 40 A0  1 
   <ip !  <ip @  ip> @  u>=  if  <ip @  'unnest  ip> !  then
1A1C9C4 	 C C7 A1  1 
1A1C9C8 	54 4D A0  1  C C7 A1  1 
1A1C9D0 	5C 4C A0  1 1C C7 A1  1 
1A1C9D8 	5C 4C A0  1 CC 48 A0  1 
1A1C9E0 	DC 41 A0  1 18  0  0  0 
1A1C9E8 	 C C7 A1  1 5C 4C A0  1 
1A1C9F0 	88 C9 A1  1 1C C7 A1  1 
1A1C9F8 	54 4D A0  1 
;
1A1C9FC 	58 46 A0  1 

headers
\ Enter and leave the debugger
forth definitions
: defer?  ( acf -- flag )  word-type  ['] key word-type =  ;
1A1CA00 	 0 64 65 66 65 72 3F 86 
1A1CA08 	9C C8 A1  1 20 40 A0  1 
1A1CA10 	B0 59 A0  1 60 53 A0  1 
1A1CA18 	50 6C A0  1 B0 59 A0  1 
1A1CA20 	24 48 A0  1 58 46 A0  1 

defer resolve-defers
1A1CA28 	 0 72 65 73 6F 6C 76 65 
1A1CA30 	2D 64 65 66 65 72 73 8E 
1A1CA38 	 C CA A1  1 5C 40 A0  1 
1A1CA40 	14  5  0  0 
: (resolve-defers)  ( xt -- xt' )
1A1CA44 	 0  0  0 28 
1A1CA48 	72 65 73 6F 6C 76 65 2D 
1A1CA50 	64 65 66 65 72 73 29 90 
1A1CA58 	3C CA A1  1 20 40 A0  1 
   begin  dup defer?  while  behavior  repeat
1A1CA60 	40 49 A0  1  C CA A1  1 
1A1CA68 	DC 41 A0  1 10  0  0  0 
1A1CA70 	10 C7 A0  1 C8 41 A0  1 
1A1CA78 	E8 FF FF FF 
;
1A1CA7C 	58 46 A0  1 
' (resolve-defers)  to resolve-defers

: (debug  ( acf -- )
1A1CA80 	 0 28 64 65 62 75 67 86 
1A1CA88 	5C CA A1  1 20 40 A0  1 
   resolve-defers
1A1CA90 	3C CA A1  1 

   dup colon-cf?  0= abort" Not a colon definition"
1A1CA94 	40 49 A0  1 
1A1CA98 	9C 5B A0  1 24 47 A0  1 
1A1CAA0 	 8 81 A0  1 16 4E 6F 74 
1A1CAA8 	20 61 20 63 6F 6C 6F 6E 
1A1CAB0 	20 64 65 66 69 6E 69 74 
1A1CAB8 	69 6F 6E  0 
   >body dup 'unnest  (debug)
1A1CABC 	E4 59 A0  1 
1A1CAC0 	40 49 A0  1 88 C9 A1  1 
1A1CAC8 	1C C9 A1  1 
;
1A1CACC 	58 46 A0  1 
\ Debug the caller
: debug-me  (s -- )  ip@ find-cfa (debug  ;
1A1CAD0 	 0  0  0 64 65 62 75 67 
1A1CAD8 	2D 6D 65 88 8C CA A1  1 
1A1CAE0 	20 40 A0  1 9C 46 A0  1 
1A1CAE8 	24 20 A1  1 8C CA A1  1 
1A1CAF0 	58 46 A0  1 
: debug(  (s -- )  ip@ dup 'unnest (debug)  ;
1A1CAF4 	 0 64 65 62 
1A1CAF8 	75 67 28 86 E0 CA A1  1 
1A1CB00 	20 40 A0  1 9C 46 A0  1 
1A1CB08 	40 49 A0  1 88 C9 A1  1 
1A1CB10 	1C C9 A1  1 58 46 A0  1 
: )debug  (s -- )  ip@ ip> !  ;
1A1CB18 	 0 29 64 65 62 75 67 86 
1A1CB20 	 0 CB A1  1 20 40 A0  1 
1A1CB28 	9C 46 A0  1 84 46 A0  1 
1A1CB30 	54 4D A0  1 58 46 A0  1 
: debug-off (s -- )
1A1CB38 	 0  0 64 65 62 75 67 2D 
1A1CB40 	6F 66 66 89 24 CB A1  1 
1A1CB48 	20 40 A0  1 
   unbug  here  low-dictionary-adr  fast-next slow-next? off
1A1CB4C 	58 C8 A1  1 
1A1CB50 	70 54 A0  1 A4 C6 A1  1 
1A1CB58 	A4 C7 A1  1 9C C8 A1  1 
1A1CB60 	F8 4B A0  1 
;
1A1CB64 	58 46 A0  1 
bug definitions
headerless
\ Go up the return stack until we find an interesting caller
: up1  ( rp -- )
1A1CB68 	75 70 31 83 C0 C9 A1  1 
1A1CB70 	20 40 A0  1 
   begin  na1+  dup rp0 @ <>  while             ( rs-adr )
1A1CB74 	CC 50 A0  1 
1A1CB78 	40 49 A0  1 9C 66 A0  1 
1A1CB80 	5C 4C A0  1 44 48 A0  1 
1A1CB88 	DC 41 A0  1 AC  0  0  0 
      dup @                                     ( rs-adr ip )
1A1CB90 	40 49 A0  1 5C 4C A0  1 
      dup in-dictionary?  if                    ( rs-adr ip )
1A1CB98 	40 49 A0  1 24 CF A0  1 
1A1CBA0 	DC 41 A0  1 88  0  0  0 
	 dup loop-end?  if                      ( rs-adr ip )
1A1CBA8 	40 49 A0  1 D0 C1 A1  1 
1A1CBB0 	DC 41 A0  1 10  0  0  0 
	    drop                                ( rs-adr )
1A1CBB8 	30 49 A0  1 
         else                                   ( rs-adr ip )
1A1CBBC 	C8 41 A0  1 
1A1CBC0 	64  0  0  0 
            find-cfa  dup indirect-call?  if    ( rs-adr xt )
1A1CBC4 	24 20 A1  1 
1A1CBC8 	40 49 A0  1 40 C5 A1  1 
1A1CBD0 	DC 41 A0  1 10  0  0  0 
 	       drop                             ( rs-adr )
1A1CBD8 	30 49 A0  1 
            else                                ( rs-adr xt )
1A1CBDC 	C8 41 A0  1 
1A1CBE0 	44  0  0  0 
               nip                              ( rs-adr )
1A1CBE4 	FC 46 A0  1 
               scrolling-debug?  if             ( xt )
1A1CBE8 	84 C8 A1  1 DC 41 A0  1 
1A1CBF0 	2C  0  0  0 
                  cr ." [ Up to " dup .name ." ]" cr
1A1CBF4 	80 6D A0  1 
1A1CBF8 	20 7C A0  1  8 5B 20 55 
1A1CC00 	70 20 74 6F 20  0  0  0 
1A1CC08 	40 49 A0  1 C8 9A A0  1 
1A1CC10 	20 7C A0  1  1 5D  0  0 
1A1CC18 	80 6D A0  1 
               then                             ( xt )
               (debug                           ( )
1A1CC1C 	8C CA A1  1 
               exit                             ( -- )
1A1CC20 	40 46 A0  1 
            then                                ( rs-adr )
         then                                   ( rs-adr )
      else                                      ( rs-adr )
1A1CC24 	C8 41 A0  1 
1A1CC28 	 8  0  0  0 
         drop                                   ( rs-adr )
1A1CC2C 	30 49 A0  1 
      then                                      ( rs-adr )
   repeat                                       ( rs-adr )
1A1CC30 	C8 41 A0  1 40 FF FF FF 
   drop                                         ( )
1A1CC38 	30 49 A0  1 
;
1A1CC3C 	58 46 A0  1 

defer to-debug-window  ' noop is to-debug-window
1A1CC40 	74 6F 2D 64 65 62 75 67 
1A1CC48 	2D 77 69 6E 64 6F 77 8F 
1A1CC50 	70 CB A1  1 5C 40 A0  1 
1A1CC58 	18  5  0  0 
defer restore-window   ' noop is restore-window
1A1CC5C 	 0 72 65 73 
1A1CC60 	74 6F 72 65 2D 77 69 6E 
1A1CC68 	64 6F 77 8E 54 CC A1  1 
1A1CC70 	5C 40 A0  1 1C  5  0  0 
: .debug-short-help  ( -- )
1A1CC78 	 0  0 2E 64 65 62 75 67 
1A1CC80 	2D 73 68 6F 72 74 2D 68 
1A1CC88 	65 6C 70 91 70 CC A1  1 
1A1CC90 	20 40 A0  1 
  ." Stepper keys: <space> Down Up Continue Forth Go Help ? See $tring Quit" cr
1A1CC94 	20 7C A0  1 
1A1CC98 	46 53 74 65 70 70 65 72 
1A1CCA0 	20 6B 65 79 73 3A 20 3C 
1A1CCA8 	73 70 61 63 65 3E 20 44 
1A1CCB0 	6F 77 6E 20 55 70 20 43 
1A1CCB8 	6F 6E 74 69 6E 75 65 20 
1A1CCC0 	46 6F 72 74 68 20 47 6F 
1A1CCC8 	20 48 65 6C 70 20 3F 20 
1A1CCD0 	53 65 65 20 24 74 72 69 
1A1CCD8 	6E 67 20 51 75 69 74  0 
1A1CCE0 	80 6D A0  1 
;
1A1CCE4 	58 46 A0  1 
: .debug-long-help  ( -- )
1A1CCE8 	 0  0  0 2E 64 65 62 75 
1A1CCF0 	67 2D 6C 6F 6E 67 2D 68 
1A1CCF8 	65 6C 70 90 90 CC A1  1 
1A1CD00 	20 40 A0  1 
   ." Key     Action" cr
1A1CD04 	20 7C A0  1 
1A1CD08 	 E 4B 65 79 20 20 20 20 
1A1CD10 	20 41 63 74 69 6F 6E  0 
1A1CD18 	80 6D A0  1 
   ." <space> Execute displayed word" cr
1A1CD1C 	20 7C A0  1 
1A1CD20 	1E 3C 73 70 61 63 65 3E 
1A1CD28 	20 45 78 65 63 75 74 65 
1A1CD30 	20 64 69 73 70 6C 61 79 
1A1CD38 	65 64 20 77 6F 72 64  0 
1A1CD40 	80 6D A0  1 
   ." D       Down: Step down into displayed word" cr
1A1CD44 	20 7C A0  1 
1A1CD48 	2B 44 20 20 20 20 20 20 
1A1CD50 	20 44 6F 77 6E 3A 20 53 
1A1CD58 	74 65 70 20 64 6F 77 6E 
1A1CD60 	20 69 6E 74 6F 20 64 69 
1A1CD68 	73 70 6C 61 79 65 64 20 
1A1CD70 	77 6F 72 64  0  0  0  0 
1A1CD78 	80 6D A0  1 
   ." U       Up: Finish current definition and step in its caller" cr
1A1CD7C 	20 7C A0  1 
1A1CD80 	3C 55 20 20 20 20 20 20 
1A1CD88 	20 55 70 3A 20 46 69 6E 
1A1CD90 	69 73 68 20 63 75 72 72 
1A1CD98 	65 6E 74 20 64 65 66 69 
1A1CDA0 	6E 69 74 69 6F 6E 20 61 
1A1CDA8 	6E 64 20 73 74 65 70 20 
1A1CDB0 	69 6E 20 69 74 73 20 63 
1A1CDB8 	61 6C 6C 65 72  0  0  0 
1A1CDC0 	80 6D A0  1 
   ." C       Continue: trace current definition without stopping" cr
1A1CDC4 	20 7C A0  1 
1A1CDC8 	3B 43 20 20 20 20 20 20 
1A1CDD0 	20 43 6F 6E 74 69 6E 75 
1A1CDD8 	65 3A 20 74 72 61 63 65 
1A1CDE0 	20 63 75 72 72 65 6E 74 
1A1CDE8 	20 64 65 66 69 6E 69 74 
1A1CDF0 	69 6F 6E 20 77 69 74 68 
1A1CDF8 	6F 75 74 20 73 74 6F 70 
1A1CE00 	70 69 6E 67  0  0  0  0 
1A1CE08 	80 6D A0  1 
   ." F       Forth: enter a subordinate Forth interpreter" cr
1A1CE0C 	20 7C A0  1 
1A1CE10 	34 46 20 20 20 20 20 20 
1A1CE18 	20 46 6F 72 74 68 3A 20 
1A1CE20 	65 6E 74 65 72 20 61 20 
1A1CE28 	73 75 62 6F 72 64 69 6E 
1A1CE30 	61 74 65 20 46 6F 72 74 
1A1CE38 	68 20 69 6E 74 65 72 70 
1A1CE40 	72 65 74 65 72  0  0  0 
1A1CE48 	80 6D A0  1 
   ." G       Go: resume normal execution (stop debugging)" cr
1A1CE4C 	20 7C A0  1 
1A1CE50 	34 47 20 20 20 20 20 20 
1A1CE58 	20 47 6F 3A 20 72 65 73 
1A1CE60 	75 6D 65 20 6E 6F 72 6D 
1A1CE68 	61 6C 20 65 78 65 63 75 
1A1CE70 	74 69 6F 6E 20 28 73 74 
1A1CE78 	6F 70 20 64 65 62 75 67 
1A1CE80 	67 69 6E 67 29  0  0  0 
1A1CE88 	80 6D A0  1 
   ." H       Help: display this message" cr
1A1CE8C 	20 7C A0  1 
1A1CE90 	22 48 20 20 20 20 20 20 
1A1CE98 	20 48 65 6C 70 3A 20 64 
1A1CEA0 	69 73 70 6C 61 79 20 74 
1A1CEA8 	68 69 73 20 6D 65 73 73 
1A1CEB0 	61 67 65  0 80 6D A0  1 
   ." ?       Display short list of debug commands" cr
1A1CEB8 	20 7C A0  1 2C 3F 20 20 
1A1CEC0 	20 20 20 20 20 44 69 73 
1A1CEC8 	70 6C 61 79 20 73 68 6F 
1A1CED0 	72 74 20 6C 69 73 74 20 
1A1CED8 	6F 66 20 64 65 62 75 67 
1A1CEE0 	20 63 6F 6D 6D 61 6E 64 
1A1CEE8 	73  0  0  0 80 6D A0  1 
   ." R       RSTrace: Show contents of Forth return stack" cr
1A1CEF0 	20 7C A0  1 34 52 20 20 
1A1CEF8 	20 20 20 20 20 52 53 54 
1A1CF00 	72 61 63 65 3A 20 53 68 
1A1CF08 	6F 77 20 63 6F 6E 74 65 
1A1CF10 	6E 74 73 20 6F 66 20 46 
1A1CF18 	6F 72 74 68 20 72 65 74 
1A1CF20 	75 72 6E 20 73 74 61 63 
1A1CF28 	6B  0  0  0 80 6D A0  1 
   ." S       See: Decompile definition being debugged" cr
1A1CF30 	20 7C A0  1 30 53 20 20 
1A1CF38 	20 20 20 20 20 53 65 65 
1A1CF40 	3A 20 44 65 63 6F 6D 70 
1A1CF48 	69 6C 65 20 64 65 66 69 
1A1CF50 	6E 69 74 69 6F 6E 20 62 
1A1CF58 	65 69 6E 67 20 64 65 62 
1A1CF60 	75 67 67 65 64  0  0  0 
1A1CF68 	80 6D A0  1 
   ." $       Display top of stack as adr,len text string" cr
1A1CF6C 	20 7C A0  1 
1A1CF70 	33 24 20 20 20 20 20 20 
1A1CF78 	20 44 69 73 70 6C 61 79 
1A1CF80 	20 74 6F 70 20 6F 66 20 
1A1CF88 	73 74 61 63 6B 20 61 73 
1A1CF90 	20 61 64 72 2C 6C 65 6E 
1A1CF98 	20 74 65 78 74 20 73 74 
1A1CFA0 	72 69 6E 67  0  0  0  0 
1A1CFA8 	80 6D A0  1 
   ." \       Display Forth return stack as numbers (like the data stack)" cr
1A1CFAC 	20 7C A0  1 
1A1CFB0 	43 5C 20 20 20 20 20 20 
1A1CFB8 	20 44 69 73 70 6C 61 79 
1A1CFC0 	20 46 6F 72 74 68 20 72 
1A1CFC8 	65 74 75 72 6E 20 73 74 
1A1CFD0 	61 63 6B 20 61 73 20 6E 
1A1CFD8 	75 6D 62 65 72 73 20 28 
1A1CFE0 	6C 69 6B 65 20 74 68 65 
1A1CFE8 	20 64 61 74 61 20 73 74 
1A1CFF0 	61 63 6B 29  0  0  0  0 
1A1CFF8 	80 6D A0  1 
   ." Q       Quit: abandon execution of the debugged word" cr
1A1CFFC 	20 7C A0  1 
1A1D000 	34 51 20 20 20 20 20 20 
1A1D008 	20 51 75 69 74 3A 20 61 
1A1D010 	62 61 6E 64 6F 6E 20 65 
1A1D018 	78 65 63 75 74 69 6F 6E 
1A1D020 	20 6F 66 20 74 68 65 20 
1A1D028 	64 65 62 75 67 67 65 64 
1A1D030 	20 77 6F 72 64  0  0  0 
1A1D038 	80 6D A0  1 
   ." V       Visual: toggle between 2-D and scrolling" cr
1A1D03C 	20 7C A0  1 
1A1D040 	30 56 20 20 20 20 20 20 
1A1D048 	20 56 69 73 75 61 6C 3A 
1A1D050 	20 74 6F 67 67 6C 65 20 
1A1D058 	62 65 74 77 65 65 6E 20 
1A1D060 	32 2D 44 20 61 6E 64 20 
1A1D068 	73 63 72 6F 6C 6C 69 6E 
1A1D070 	67  0  0  0 80 6D A0  1 
   ." L       Visual: redisplay" cr
1A1D078 	20 7C A0  1 19 4C 20 20 
1A1D080 	20 20 20 20 20 56 69 73 
1A1D088 	75 61 6C 3A 20 72 65 64 
1A1D090 	69 73 70 6C 61 79  0  0 
1A1D098 	80 6D A0  1 
;
1A1D09C 	58 46 A0  1 
d# 24 constant cmd-column
1A1D0A0 	 0 63 6D 64 2D 63 6F 6C 
1A1D0A8 	75 6D 6E 8A  0 CD A1  1 
1A1D0B0 	68 40 A0  1 18  0  0  0 
: to-cmd-column  ( -- )  cmd-column to-column  ;
1A1D0B8 	 0  0 74 6F 2D 63 6D 64 
1A1D0C0 	2D 63 6F 6C 75 6D 6E 8D 
1A1D0C8 	B0 D0 A1  1 20 40 A0  1 
1A1D0D0 	B0 D0 A1  1  8 14 A1  1 
1A1D0D8 	58 46 A0  1 

0 value stack-line
1A1D0DC 	 0 73 74 61 
1A1D0E0 	63 6B 2D 6C 69 6E 65 8A 
1A1D0E8 	CC D0 A1  1 50 40 A0  1 
1A1D0F0 	20  5  0  0 
d# 45 constant stack-column
1A1D0F4 	 0  0  0 73 
1A1D0F8 	74 61 63 6B 2D 63 6F 6C 
1A1D100 	75 6D 6E 8C EC D0 A1  1 
1A1D108 	68 40 A0  1 2D  0  0  0 
\ 0 0 2value result-loc
0 0 2value full-stack-xy
1A1D110 	 0  0 66 75 6C 6C 2D 73 
1A1D118 	74 61 63 6B 2D 78 79 8D 
1A1D120 	 8 D1 A1  1 24 BA A1  1 
1A1D128 	24  5  0  0 
0 value result-line
1A1D12C 	72 65 73 75 
1A1D130 	6C 74 2D 6C 69 6E 65 8B 
1A1D138 	24 D1 A1  1 50 40 A0  1 
1A1D140 	2C  5  0  0 
0 value result-col
1A1D144 	 0 72 65 73 
1A1D148 	75 6C 74 2D 63 6F 6C 8A 
1A1D150 	3C D1 A1  1 50 40 A0  1 
1A1D158 	30  5  0  0 
: to-stack-location  ( -- )  stack-column stack-line at-xy  kill-line  ;
1A1D15C 	 0  0 74 6F 
1A1D160 	2D 73 74 61 63 6B 2D 6C 
1A1D168 	6F 63 61 74 69 6F 6E 91 
1A1D170 	54 D1 A1  1 20 40 A0  1 
1A1D178 	 8 D1 A1  1 EC D0 A1  1 
1A1D180 	40 F8 A0  1 58 F6 A0  1 
1A1D188 	58 46 A0  1 
: show-full-stack  ( -- )
1A1D18C 	73 68 6F 77 
1A1D190 	2D 66 75 6C 6C 2D 73 74 
1A1D198 	61 63 6B 8F 74 D1 A1  1 
1A1D1A0 	20 40 A0  1 
   full-stack-xy at-xy kill-line
1A1D1A4 	24 D1 A1  1 
1A1D1A8 	40 F8 A0  1 58 F6 A0  1 
   depth 0<  if  ." Stack Underflow"   exit  then  \ Don't clear stack here
1A1D1B0 	28 73 A0  1 64 47 A0  1 
1A1D1B8 	DC 41 A0  1 20  0  0  0 
1A1D1C0 	20 7C A0  1  F 53 74 61 
1A1D1C8 	63 6B 20 55 6E 64 65 72 
1A1D1D0 	66 6C 6F 77  0  0  0  0 
1A1D1D8 	40 46 A0  1 
   depth 0=  if  ." Empty"  exit  then
1A1D1DC 	28 73 A0  1 
1A1D1E0 	24 47 A0  1 DC 41 A0  1 
1A1D1E8 	14  0  0  0 20 7C A0  1 
1A1D1F0 	 5 45 6D 70 74 79  0  0 
1A1D1F8 	40 46 A0  1 
   depth 7 >  if  ." .. "  then
1A1D1FC 	28 73 A0  1 
1A1D200 	E0 6F A0  1  4 48 A0  1 
1A1D208 	DC 41 A0  1 10  0  0  0 
1A1D210 	20 7C A0  1  3 2E 2E 20 
1A1D218 	 0  0  0  0 
   depth  depth 7 - 0 max  ?do  depth i - 1- pick n.  loop
1A1D21C 	28 73 A0  1 
1A1D220 	28 73 A0  1 E0 6F A0  1 
1A1D228 	18 45 A0  1 70 6F A0  1 
1A1D230 	9C 4A A0  1 50 42 A0  1 
1A1D238 	24  0  0  0 28 73 A0  1 
1A1D240 	B4 42 A0  1 18 45 A0  1 
1A1D248 	54 4B A0  1  C 4A A0  1 
1A1D250 	D0 7A A0  1 F8 41 A0  1 
1A1D258 	E4 FF FF FF 
;
1A1D25C 	58 46 A0  1 
: show-partial-stack  ( -- )
1A1D260 	 0 73 68 6F 77 2D 70 61 
1A1D268 	72 74 69 61 6C 2D 73 74 
1A1D270 	61 63 6B 92 A0 D1 A1  1 
1A1D278 	20 40 A0  1 
   show-full-stack
1A1D27C 	A0 D1 A1  1 

   to-stack-location
1A1D280 	74 D1 A1  1 

   ." \ "
1A1D284 	20 7C A0  1 
1A1D288 	 2 5C 20  0 
   depth 0<  if  ." Stack Underflow" sp0 @ sp!  exit  then
1A1D28C 	28 73 A0  1 
1A1D290 	64 47 A0  1 DC 41 A0  1 
1A1D298 	2C  0  0  0 20 7C A0  1 
1A1D2A0 	 F 53 74 61 63 6B 20 55 
1A1D2A8 	6E 64 65 72 66 6C 6F 77 
1A1D2B0 	 0  0  0  0 8C 66 A0  1 
1A1D2B8 	5C 4C A0  1 9C 45 A0  1 
1A1D2C0 	40 46 A0  1 
   depth 0=  if  ." Empty"  exit  then
1A1D2C4 	28 73 A0  1 
1A1D2C8 	24 47 A0  1 DC 41 A0  1 
1A1D2D0 	14  0  0  0 20 7C A0  1 
1A1D2D8 	 5 45 6D 70 74 79  0  0 
1A1D2E0 	40 46 A0  1 
   depth 3 >  if  ." .. "  then
1A1D2E4 	28 73 A0  1 
1A1D2E8 	A0 6F A0  1  4 48 A0  1 
1A1D2F0 	DC 41 A0  1 10  0  0  0 
1A1D2F8 	20 7C A0  1  3 2E 2E 20 
1A1D300 	 0  0  0  0 
   depth  depth 4 - 0 max  ?do  depth i - 1- pick n.  loop
1A1D304 	28 73 A0  1 
1A1D308 	28 73 A0  1 B0 6F A0  1 
1A1D310 	18 45 A0  1 70 6F A0  1 
1A1D318 	9C 4A A0  1 50 42 A0  1 
1A1D320 	24  0  0  0 28 73 A0  1 
1A1D328 	B4 42 A0  1 18 45 A0  1 
1A1D330 	54 4B A0  1  C 4A A0  1 
1A1D338 	D0 7A A0  1 F8 41 A0  1 
1A1D340 	E4 FF FF FF 
;
1A1D344 	58 46 A0  1 

\ : save-result-loc  ( -- )  #out @ #line @ to result-loc  ;
\ : to-result-loc  ( -- )  result-loc at-xy  ;
: save-result-loc  ( -- )  #out @ to result-col   #line @ to result-line  ;
1A1D348 	73 61 76 65 2D 72 65 73 
1A1D350 	75 6C 74 2D 6C 6F 63 8F 
1A1D358 	78 D2 A1  1 20 40 A0  1 
1A1D360 	5C 6D A0  1 5C 4C A0  1 
1A1D368 	B8 40 A0  1 54 D1 A1  1 
1A1D370 	70 6D A0  1 5C 4C A0  1 
1A1D378 	B8 40 A0  1 3C D1 A1  1 
1A1D380 	58 46 A0  1 
: to-result-loc  ( -- )  result-col result-line 2dup at-xy  #line !  #out !  ;
1A1D384 	 0  0 74 6F 
1A1D388 	2D 72 65 73 75 6C 74 2D 
1A1D390 	6C 6F 63 8D 5C D3 A1  1 
1A1D398 	20 40 A0  1 54 D1 A1  1 
1A1D3A0 	3C D1 A1  1 C0 49 A0  1 
1A1D3A8 	40 F8 A0  1 70 6D A0  1 
1A1D3B0 	54 4D A0  1 5C 6D A0  1 
1A1D3B8 	54 4D A0  1 58 46 A0  1 

\ set-package is a hook for Open Firmware.  When Open Firmware is loaded,
\ set-package should be set to a word that sets the active package to the
\ package corresponding to the current instance.  set-package is called
\ by the "F" key, so the user will see the methods of the current instance.
headers
defer   set-package  ' noop is   set-package
1A1D3C0 	73 65 74 2D 70 61 63 6B 
1A1D3C8 	61 67 65 8B 98 D3 A1  1 
1A1D3D0 	5C 40 A0  1 34  5  0  0 
defer unset-package  ' noop is unset-package
1A1D3D8 	 0  0 75 6E 73 65 74 2D 
1A1D3E0 	70 61 63 6B 61 67 65 8D 
1A1D3E8 	D0 D3 A1  1 5C 40 A0  1 
1A1D3F0 	38  5  0  0 
headerless

: try  ( n acf -- okay? )
1A1D3F4 	74 72 79 83 
1A1D3F8 	EC D3 A1  1 20 40 A0  1 
   catch  ?dup if  .error drop false  else  true  then
1A1D400 	14 7F A0  1 B4 70 A0  1 
1A1D408 	DC 41 A0  1 18  0  0  0 
1A1D410 	70 CF A0  1 30 49 A0  1 
1A1D418 	18 70 A0  1 C8 41 A0  1 
1A1D420 	 8  0  0  0  4 70 A0  1 
;
1A1D428 	58 46 A0  1 
defer resolve-method
1A1D42C 	 0 72 65 73 
1A1D430 	6F 6C 76 65 2D 6D 65 74 
1A1D438 	68 6F 64 8E FC D3 A1  1 
1A1D440 	5C 40 A0  1 3C  5  0  0 
' noop to resolve-method
: executer  ( xt -- xt' )
1A1D448 	 0  0  0 65 78 65 63 75 
1A1D450 	74 65 72 88 40 D4 A1  1 
1A1D458 	20 40 A0  1 
   dup ['] execute =  over ['] catch =  or  if  drop dup  then
1A1D45C 	40 49 A0  1 
1A1D460 	60 53 A0  1 98 41 A0  1 
1A1D468 	24 48 A0  1 54 49 A0  1 
1A1D470 	60 53 A0  1 14 7F A0  1 
1A1D478 	24 48 A0  1 70 44 A0  1 
1A1D480 	DC 41 A0  1  C  0  0  0 
1A1D488 	30 49 A0  1 40 49 A0  1 
   resolve-method
1A1D490 	40 D4 A1  1 
;
1A1D494 	58 46 A0  1 
d# 72 constant /#buf
1A1D498 	 0  0 2F 23 62 75 66 85 
1A1D4A0 	58 D4 A1  1 68 40 A0  1 
1A1D4A8 	48  0  0  0 
/#buf buffer: #buf-save
1A1D4AC 	 0  0 23 62 
1A1D4B0 	75 66 2D 73 61 76 65 89 
1A1D4B8 	A4 D4 A1  1 B4 A9 A0  1 
1A1D4C0 	40  5  0  0 48  0  0  0 
1A1D4C8 	34 BB A1  1 
variable hld-save
1A1D4CC 	 0  0  0 68 
1A1D4D0 	6C 64 2D 73 61 76 65 88 
1A1D4D8 	BC D4 A1  1 48 40 A0  1 
1A1D4E0 	44  5  0  0 
variable show-rstack  \ Show the return stack along with the data stack?
1A1D4E4 	73 68 6F 77 
1A1D4E8 	2D 72 73 74 61 63 6B 8B 
1A1D4F0 	DC D4 A1  1 48 40 A0  1 
1A1D4F8 	48  5  0  0 
variable hex-stack    \ Show the data stack in hex?
1A1D4FC 	 0  0 68 65 
1A1D500 	78 2D 73 74 61 63 6B 89 
1A1D508 	F4 D4 A1  1 48 40 A0  1 
1A1D510 	4C  5  0  0 
: save#     ( -- )  #-buf /#buf -  #buf-save  d# 72 move    hld @  hld-save !  ;
1A1D514 	 0  0 73 61 
1A1D518 	76 65 23 85  C D5 A1  1 
1A1D520 	20 40 A0  1 18 75 A0  1 
1A1D528 	A4 D4 A1  1 18 45 A0  1 
1A1D530 	BC D4 A1  1 58 41 A0  1 
1A1D538 	48  0  0  0 F4 4A A0  1 
1A1D540 	C8 75 A0  1 5C 4C A0  1 
1A1D548 	DC D4 A1  1 54 4D A0  1 
1A1D550 	58 46 A0  1 
: restore#  ( -- )  #buf-save  #-buf /#buf -  d# 72 move    hld-save @  hld !  ;
1A1D554 	 0  0  0 72 
1A1D558 	65 73 74 6F 72 65 23 88 
1A1D560 	20 D5 A1  1 20 40 A0  1 
1A1D568 	BC D4 A1  1 18 75 A0  1 
1A1D570 	A4 D4 A1  1 18 45 A0  1 
1A1D578 	58 41 A0  1 48  0  0  0 
1A1D580 	F4 4A A0  1 DC D4 A1  1 
1A1D588 	5C 4C A0  1 C8 75 A0  1 
1A1D590 	54 4D A0  1 58 46 A0  1 
0 value the-ip
1A1D598 	 0 74 68 65 2D 69 70 86 
1A1D5A0 	64 D5 A1  1 50 40 A0  1 
1A1D5A8 	50  5  0  0 
0 value the-rp
1A1D5AC 	 0 74 68 65 
1A1D5B0 	2D 72 70 86 A4 D5 A1  1 
1A1D5B8 	50 40 A0  1 54  5  0  0 
: redisplay?  ( -- flag )  displayed-xt  the-ip find-cfa <>  ;
1A1D5C0 	 0 72 65 64 69 73 70 6C 
1A1D5C8 	61 79 3F 8A B8 D5 A1  1 
1A1D5D0 	20 40 A0  1 DC C8 A1  1 
1A1D5D8 	A4 D5 A1  1 24 20 A1  1 
1A1D5E0 	44 48 A0  1 58 46 A0  1 

: (.rs  ( -- )
1A1D5E8 	 0  0  0 28 2E 72 73 84 
1A1D5F0 	D0 D5 A1  1 20 40 A0  1 
   show-rstack @ 0=  if  exit  then
1A1D5F8 	F4 D4 A1  1 5C 4C A0  1 
1A1D600 	24 47 A0  1 DC 41 A0  1 
1A1D608 	 8  0  0  0 40 46 A0  1 
   ." return-stack: "
1A1D610 	20 7C A0  1  E 72 65 74 
1A1D618 	75 72 6E 2D 73 74 61 63 
1A1D620 	6B 3A 20  0 
   push-hex
1A1D624 	5C F4 A0  1 
   \ Skip the debugger's footprint on the return stack
   rp0 @  the-rp 5 na+  ?do  i @ .  /n +loop
1A1D628 	9C 66 A0  1 5C 4C A0  1 
1A1D630 	B8 D5 A1  1 C0 6F A0  1 
1A1D638 	48 50 A0  1 50 42 A0  1 
1A1D640 	1C  0  0  0 B4 42 A0  1 
1A1D648 	5C 4C A0  1 94 7A A0  1 
1A1D650 	40 51 A0  1 1C 42 A0  1 
1A1D658 	EC FF FF FF 
   pop-base
1A1D65C 	9C F4 A0  1 
;
1A1D660 	58 46 A0  1 
: setup-scrolling-display  ( -- )
1A1D664 	73 65 74 75 
1A1D668 	70 2D 73 63 72 6F 6C 6C 
1A1D670 	69 6E 67 2D 64 69 73 70 
1A1D678 	6C 61 79 97 F4 D5 A1  1 
1A1D680 	20 40 A0  1 
   ??cr
1A1D684 	 0 A1 A0  1 
   the-ip  <ip @ =  if  ." : "  else  ." Inside "  then
1A1D688 	A4 D5 A1  1  C C7 A1  1 
1A1D690 	5C 4C A0  1 24 48 A0  1 
1A1D698 	DC 41 A0  1 14  0  0  0 
1A1D6A0 	20 7C A0  1  2 3A 20  0 
1A1D6A8 	C8 41 A0  1 14  0  0  0 
1A1D6B0 	20 7C A0  1  7 49 6E 73 
1A1D6B8 	69 64 65 20  0  0  0  0 
   <ip @ find-cfa .name
1A1D6C0 	 C C7 A1  1 5C 4C A0  1 
1A1D6C8 	24 20 A1  1 C8 9A A0  1 
;
1A1D6D0 	58 46 A0  1 
: setup-2d-display  ( -- )
1A1D6D4 	 0  0  0 73 
1A1D6D8 	65 74 75 70 2D 32 64 2D 
1A1D6E0 	64 69 73 70 6C 61 79 90 
1A1D6E8 	80 D6 A1  1 20 40 A0  1 
   page
1A1D6F0 	94 F8 A0  1 
   d# 78 rmargin !
1A1D6F4 	58 41 A0  1 
1A1D6F8 	4E  0  0  0 94 13 A1  1 
1A1D700 	54 4D A0  1 
   .debug-short-help
1A1D704 	90 CC A1  1 
   d# 70 rmargin !
1A1D708 	58 41 A0  1 46  0  0  0 
1A1D710 	94 13 A1  1 54 4D A0  1 
   ." Callers: "  rp0 @ the-rp na1+ rslist kill-line cr
1A1D718 	20 7C A0  1  9 43 61 6C 
1A1D720 	6C 65 72 73 3A 20  0  0 
1A1D728 	9C 66 A0  1 5C 4C A0  1 
1A1D730 	B8 D5 A1  1 CC 50 A0  1 
1A1D738 	64 C6 A1  1 58 F6 A0  1 
1A1D740 	80 6D A0  1 
   d# 40 rmargin !
1A1D744 	58 41 A0  1 
1A1D748 	28  0  0  0 94 13 A1  1 
1A1D750 	54 4D A0  1 
   ." Stack: " #out @ #line @ to full-stack-xy  cr  \ For stack
1A1D754 	20 7C A0  1 
1A1D758 	 7 53 74 61 63 6B 3A 20 
1A1D760 	 0  0  0  0 5C 6D A0  1 
1A1D768 	5C 4C A0  1 70 6D A0  1 
1A1D770 	5C 4C A0  1 48 B8 A1  1 
1A1D778 	24 D1 A1  1 80 6D A0  1 
   the-ip debug-see
1A1D780 	A4 D5 A1  1 14 3A A1  1 
   the-ip find-cfa to displayed-xt
1A1D788 	A4 D5 A1  1 24 20 A1  1 
1A1D790 	B8 40 A0  1 DC C8 A1  1 
   cr
1A1D798 	80 6D A0  1 
   \ Display the initial stack on the cursor line
   the-ip ip>position  0=  if   ( col row )
1A1D79C 	A4 D5 A1  1 
1A1D7A0 	5C 22 A1  1 24 47 A0  1 
1A1D7A8 	DC 41 A0  1 10  0  0  0 
      is stack-line   drop      ( )
1A1D7B0 	B8 40 A0  1 EC D0 A1  1 
1A1D7B8 	30 49 A0  1 
   then
;
1A1D7BC 	58 46 A0  1 
: setup-debug-display  ( -- )
1A1D7C0 	73 65 74 75 70 2D 64 65 
1A1D7C8 	62 75 67 2D 64 69 73 70 
1A1D7D0 	6C 61 79 93 EC D6 A1  1 
1A1D7D8 	20 40 A0  1 
   redisplay?  if
1A1D7DC 	D0 D5 A1  1 
1A1D7E0 	DC 41 A0  1 2C  0  0  0 
      scrolling-debug?  if
1A1D7E8 	84 C8 A1  1 DC 41 A0  1 
1A1D7F0 	10  0  0  0 
         setup-scrolling-display
1A1D7F4 	80 D6 A1  1 
      else
1A1D7F8 	C8 41 A0  1  8  0  0  0 
         setup-2d-display
1A1D800 	EC D6 A1  1 
      then
      0 show-rstack !
1A1D804 	70 6F A0  1 
1A1D808 	F4 D4 A1  1 54 4D A0  1 
   then
;
1A1D810 	58 46 A0  1 
: show-debug-stack  ( -- )
1A1D814 	 0  0  0 73 
1A1D818 	68 6F 77 2D 64 65 62 75 
1A1D820 	67 2D 73 74 61 63 6B 90 
1A1D828 	D8 D7 A1  1 20 40 A0  1 
   scrolling-debug?  if
1A1D830 	84 C8 A1  1 DC 41 A0  1 
1A1D838 	A4  0  0  0 
      save#
1A1D83C 	20 D5 A1  1 
      cmd-column 2+ to-column
1A1D840 	B0 D0 A1  1 40 4B A0  1 
1A1D848 	 8 14 A1  1 

      hex-stack @  if  push-hex  then
1A1D84C 	 C D5 A1  1 
1A1D850 	5C 4C A0  1 DC 41 A0  1 
1A1D858 	 8  0  0  0 5C F4 A0  1 
      ." ( " .s    \ Show data stack
1A1D860 	20 7C A0  1  2 28 20  0 
1A1D868 	38 7C A0  1 
      hex-stack @  if  pop-base  then
1A1D86C 	 C D5 A1  1 
1A1D870 	5C 4C A0  1 DC 41 A0  1 
1A1D878 	 8  0  0  0 9C F4 A0  1 
      show-rstack @  if  (.rs  then   \ Show return stack
1A1D880 	F4 D4 A1  1 5C 4C A0  1 
1A1D888 	DC 41 A0  1  8  0  0  0 
1A1D890 	F4 D5 A1  1 
      ." )"
1A1D894 	20 7C A0  1 
1A1D898 	 1 29  0  0 
      restore#
1A1D89C 	64 D5 A1  1 

      cr
1A1D8A0 	80 6D A0  1 
      ['] noop is indent
1A1D8A4 	60 53 A0  1 
1A1D8A8 	64 4F A0  1 98 40 A0  1 
1A1D8B0 	C8 22 A1  1 
      the-ip .token drop		  \ Show word name
1A1D8B4 	A4 D5 A1  1 
1A1D8B8 	74 38 A1  1 30 49 A0  1 
      ['] (indent) is indent
1A1D8C0 	60 53 A0  1 E0 22 A1  1 
1A1D8C8 	98 40 A0  1 C8 22 A1  1 
      to-cmd-column
1A1D8D0 	CC D0 A1  1 
   else
1A1D8D4 	C8 41 A0  1 
1A1D8D8 	24  0  0  0 
      save-result-loc
1A1D8DC 	5C D3 A1  1 
      show-partial-stack
1A1D8E0 	78 D2 A1  1 
        
      the-ip ip-set-cursor
1A1D8E4 	A4 D5 A1  1 
1A1D8E8 	A0 22 A1  1 
      #line @ to stack-line
1A1D8EC 	70 6D A0  1 
1A1D8F0 	5C 4C A0  1 B8 40 A0  1 
1A1D8F8 	EC D0 A1  1 
   then
;
1A1D8FC 	58 46 A0  1 
: debug-interact  ( -- )
1A1D900 	 0 64 65 62 75 67 2D 69 
1A1D908 	6E 74 65 72 61 63 74 8E 
1A1D910 	2C D8 A1  1 20 40 A0  1 
   save#
1A1D918 	20 D5 A1  1 
   begin
      setup-debug-display
1A1D91C 	D8 D7 A1  1 
      step? @  if  to-debug-window  then
1A1D920 	B0 C8 A1  1 5C 4C A0  1 
1A1D928 	DC 41 A0  1  8  0  0  0 
1A1D930 	54 CC A1  1 
      show-debug-stack
1A1D934 	2C D8 A1  1 
      step? @  key? or  if
1A1D938 	B0 C8 A1  1 5C 4C A0  1 
1A1D940 	64 6C A0  1 70 44 A0  1 
1A1D948 	DC 41 A0  1 40  4  0  0 
         step? on  res off
1A1D950 	B0 C8 A1  1 E0 4B A0  1 
1A1D958 	C0 C8 A1  1 F8 4B A0  1 
         key dup bl <  if  drop bl  then
1A1D960 	50 6C A0  1 40 49 A0  1 
1A1D968 	28 70 A0  1 E4 47 A0  1 
1A1D970 	DC 41 A0  1  C  0  0  0 
1A1D978 	30 49 A0  1 28 70 A0  1 
         scrolling-debug?  if  dup emit  else  to-result-loc  then  upc
1A1D980 	84 C8 A1  1 DC 41 A0  1 
1A1D988 	14  0  0  0 40 49 A0  1 
1A1D990 	2C 6C A0  1 C8 41 A0  1 
1A1D998 	 8  0  0  0 98 D3 A1  1 
1A1D9A0 	D0 51 A0  1 
         restore-window
1A1D9A4 	70 CC A1  1 
         scrolling-debug?  if  reset-page  then
1A1D9A8 	84 C8 A1  1 DC 41 A0  1 
1A1D9B0 	 8  0  0  0 9C A1 A0  1 
         case
            ascii D  of  the-ip token@ executer  ['] (debug try endof \ Down
1A1D9B8 	58 41 A0  1 44  0  0  0 
1A1D9C0 	48 43 A0  1 24  0  0  0 
1A1D9C8 	A4 D5 A1  1  C 54 A0  1 
1A1D9D0 	58 D4 A1  1 60 53 A0  1 
1A1D9D8 	8C CA A1  1 FC D3 A1  1 
1A1D9E0 	6C 43 A0  1 A0  3  0  0 
	    ascii U  of  the-rp ['] up1 try                     endof \ Up
1A1D9E8 	58 41 A0  1 55  0  0  0 
1A1D9F0 	48 43 A0  1 1C  0  0  0 
1A1D9F8 	B8 D5 A1  1 60 53 A0  1 
1A1DA00 	70 CB A1  1 FC D3 A1  1 
1A1DA08 	6C 43 A0  1 78  3  0  0 
            ascii C  of                                               \ Continue
1A1DA10 	58 41 A0  1 43  0  0  0 
1A1DA18 	48 43 A0  1 48  0  0  0 
               step? @ 0= step? !              
1A1DA20 	B0 C8 A1  1 5C 4C A0  1 
1A1DA28 	24 47 A0  1 B0 C8 A1  1 
1A1DA30 	54 4D A0  1 
               step? @ 0=  if  true to scrolling-debug?  force-redisplay  then
1A1DA34 	B0 C8 A1  1 
1A1DA38 	5C 4C A0  1 24 47 A0  1 
1A1DA40 	DC 41 A0  1 14  0  0  0 
1A1DA48 	 4 70 A0  1 B8 40 A0  1 
1A1DA50 	84 C8 A1  1 F8 C8 A1  1 
               true
1A1DA58 	 4 70 A0  1 
            endof
1A1DA5C 	6C 43 A0  1 
1A1DA60 	24  3  0  0 

            ascii F  of						      \ Forth
1A1DA64 	58 41 A0  1 
1A1DA68 	46  0  0  0 48 43 A0  1 
1A1DA70 	50  0  0  0 
               cr ." Type 'resume' to return to debugger" cr
1A1DA74 	80 6D A0  1 
1A1DA78 	20 7C A0  1 23 54 79 70 
1A1DA80 	65 20 27 72 65 73 75 6D 
1A1DA88 	65 27 20 74 6F 20 72 65 
1A1DA90 	74 75 72 6E 20 74 6F 20 
1A1DA98 	64 65 62 75 67 67 65 72 
1A1DAA0 	 0  0  0  0 80 6D A0  1 
               set-package  interact  unset-package   false
1A1DAA8 	D0 D3 A1  1 E0 E4 A0  1 
1A1DAB0 	EC D3 A1  1 18 70 A0  1 
            endof
1A1DAB8 	6C 43 A0  1 C8  2  0  0 
            ascii G  of  debug-off  cr                 true   endof \ Go
1A1DAC0 	58 41 A0  1 47  0  0  0 
1A1DAC8 	48 43 A0  1 18  0  0  0 
1A1DAD0 	48 CB A1  1 80 6D A0  1 
1A1DAD8 	 4 70 A0  1 6C 43 A0  1 
1A1DAE0 	A4  2  0  0 
            ascii H  of  cr .debug-long-help           false  endof \ Help
1A1DAE4 	58 41 A0  1 
1A1DAE8 	48  0  0  0 48 43 A0  1 
1A1DAF0 	18  0  0  0 80 6D A0  1 
1A1DAF8 	 0 CD A1  1 18 70 A0  1 
1A1DB00 	6C 43 A0  1 80  2  0  0 
            ascii R  of  cr rp0 @ the-rp na1+ (rstrace false  endof \ RSTrace
1A1DB08 	58 41 A0  1 52  0  0  0 
1A1DB10 	48 43 A0  1 28  0  0  0 
1A1DB18 	80 6D A0  1 9C 66 A0  1 
1A1DB20 	5C 4C A0  1 B8 D5 A1  1 
1A1DB28 	CC 50 A0  1 FC C3 A1  1 
1A1DB30 	18 70 A0  1 6C 43 A0  1 
1A1DB38 	4C  2  0  0 
            ascii S  of  cr <ip @ body> (see)          false  endof \ See
1A1DB3C 	58 41 A0  1 
1A1DB40 	53  0  0  0 48 43 A0  1 
1A1DB48 	24  0  0  0 80 6D A0  1 
1A1DB50 	 C C7 A1  1 5C 4C A0  1 
1A1DB58 	C8 59 A0  1 98 20 A1  1 
1A1DB60 	18 70 A0  1 6C 43 A0  1 
1A1DB68 	1C  2  0  0 
            ascii ?  of  cr .debug-short-help	       false  endof \ Short Help
1A1DB6C 	58 41 A0  1 
1A1DB70 	3F  0  0  0 48 43 A0  1 
1A1DB78 	18  0  0  0 80 6D A0  1 
1A1DB80 	90 CC A1  1 18 70 A0  1 
1A1DB88 	6C 43 A0  1 F8  1  0  0 
            ascii $  of  space 2dup type cr to-cmd-column false endof \ String
1A1DB90 	58 41 A0  1 24  0  0  0 
1A1DB98 	48 43 A0  1 24  0  0  0 
1A1DBA0 	CC 71 A0  1 C0 49 A0  1 
1A1DBA8 	 4 6C A0  1 80 6D A0  1 
1A1DBB0 	CC D0 A1  1 18 70 A0  1 
1A1DBB8 	6C 43 A0  1 C8  1  0  0 
            ascii Q  of  cr ." unbug" abort           true   endof \ Quit
1A1DBC0 	58 41 A0  1 51  0  0  0 
1A1DBC8 	48 43 A0  1 24  0  0  0 
1A1DBD0 	80 6D A0  1 20 7C A0  1 
1A1DBD8 	 5 75 6E 62 75 67  0  0 
1A1DBE0 	28 91 A0  1  4 70 A0  1 
1A1DBE8 	6C 43 A0  1 98  1  0  0 
            ascii (  of  the-ip set-<ip                  false  endof
1A1DBF0 	58 41 A0  1 28  0  0  0 
1A1DBF8 	48 43 A0  1 18  0  0  0 
1A1DC00 	A4 D5 A1  1 C0 C9 A1  1 
1A1DC08 	18 70 A0  1 6C 43 A0  1 
1A1DC10 	74  1  0  0 
            ascii <  of  the-ip ta1+ set-<ip  1 cnt !    false  endof
1A1DC14 	58 41 A0  1 
1A1DC18 	3C  0  0  0 48 43 A0  1 
1A1DC20 	28  0  0  0 A4 D5 A1  1 
1A1DC28 	FC 50 A0  1 C0 C9 A1  1 
1A1DC30 	80 6F A0  1 2C C7 A1  1 
1A1DC38 	54 4D A0  1 18 70 A0  1 
1A1DC40 	6C 43 A0  1 40  1  0  0 
            ascii )  of  the-ip ip> !  1 cnt !           false  endof
1A1DC48 	58 41 A0  1 29  0  0  0 
1A1DC50 	48 43 A0  1 28  0  0  0 
1A1DC58 	A4 D5 A1  1 1C C7 A1  1 
1A1DC60 	54 4D A0  1 80 6F A0  1 
1A1DC68 	2C C7 A1  1 54 4D A0  1 
1A1DC70 	18 70 A0  1 6C 43 A0  1 
1A1DC78 	 C  1  0  0 
            ascii *  of  the-ip find-cfa dup <ip !  'unnest ip> !  false  endof
1A1DC7C 	58 41 A0  1 
1A1DC80 	2A  0  0  0 48 43 A0  1 
1A1DC88 	30  0  0  0 A4 D5 A1  1 
1A1DC90 	24 20 A1  1 40 49 A0  1 
1A1DC98 	 C C7 A1  1 54 4D A0  1 
1A1DCA0 	88 C9 A1  1 1C C7 A1  1 
1A1DCA8 	54 4D A0  1 18 70 A0  1 
1A1DCB0 	6C 43 A0  1 D0  0  0  0 
            ascii \  of  show-rstack @ 0= show-rstack !  false  endof  \ toggle return stack display
1A1DCB8 	58 41 A0  1 5C  0  0  0 
1A1DCC0 	48 43 A0  1 24  0  0  0 
1A1DCC8 	F4 D4 A1  1 5C 4C A0  1 
1A1DCD0 	24 47 A0  1 F4 D4 A1  1 
1A1DCD8 	54 4D A0  1 18 70 A0  1 
1A1DCE0 	6C 43 A0  1 A0  0  0  0 
            ascii X  of  hex-stack @ 0= hex-stack !      false  endof  \ toggle heX stack display
1A1DCE8 	58 41 A0  1 58  0  0  0 
1A1DCF0 	48 43 A0  1 24  0  0  0 
1A1DCF8 	 C D5 A1  1 5C 4C A0  1 
1A1DD00 	24 47 A0  1  C D5 A1  1 
1A1DD08 	54 4D A0  1 18 70 A0  1 
1A1DD10 	6C 43 A0  1 70  0  0  0 
            ascii L  of  force-redisplay                 false  endof  \ Redisplay
1A1DD18 	58 41 A0  1 4C  0  0  0 
1A1DD20 	48 43 A0  1 14  0  0  0 
1A1DD28 	F8 C8 A1  1 18 70 A0  1 
1A1DD30 	6C 43 A0  1 50  0  0  0 
            ascii V  of						\ toggle Visual (2D) mode
1A1DD38 	58 41 A0  1 56  0  0  0 
1A1DD40 	48 43 A0  1 34  0  0  0 
               scrolling-debug? 0= to scrolling-debug?      
1A1DD48 	84 C8 A1  1 24 47 A0  1 
1A1DD50 	B8 40 A0  1 84 C8 A1  1 
               scrolling-debug? 0=  if  force-redisplay  then  false
1A1DD58 	84 C8 A1  1 24 47 A0  1 
1A1DD60 	DC 41 A0  1  8  0  0  0 
1A1DD68 	F8 C8 A1  1 18 70 A0  1 
            endof
1A1DD70 	6C 43 A0  1 10  0  0  0 
            ( default )  true swap
1A1DD78 	 4 70 A0  1 68 49 A0  1 
         endcase
1A1DD80 	84 43 A0  1 
      else
1A1DD84 	C8 41 A0  1 
1A1DD88 	 8  0  0  0 
         true
1A1DD8C 	 4 70 A0  1 
      then
   until
1A1DD90 	DC 41 A0  1 88 FB FF FF 
   restore#
1A1DD98 	64 D5 A1  1 
;
1A1DD9C 	58 46 A0  1 
: (trace  ( -- )
1A1DDA0 	 0 28 74 72 61 63 65 86 
1A1DDA8 	14 D9 A1  1 20 40 A0  1 
   ip@ to the-ip
1A1DDB0 	9C 46 A0  1 B8 40 A0  1 
1A1DDB8 	A4 D5 A1  1 
   rp@ to the-rp
1A1DDBC 	7C 45 A0  1 
1A1DDC0 	B8 40 A0  1 B8 D5 A1  1 
   debug-interact
1A1DDC8 	14 D9 A1  1 
\   scrolling-debug? 0=  if  to-result-loc  then
   the-ip token@  dup ['] unnest =  swap ['] exit =  or  if
1A1DDCC 	A4 D5 A1  1 
1A1DDD0 	 C 54 A0  1 40 49 A0  1 
1A1DDD8 	60 53 A0  1 58 46 A0  1 
1A1DDE0 	24 48 A0  1 68 49 A0  1 
1A1DDE8 	60 53 A0  1 40 46 A0  1 
1A1DDF0 	24 48 A0  1 70 44 A0  1 
1A1DDF8 	DC 41 A0  1  C  0  0  0 
      cr  force-redisplay
1A1DE00 	80 6D A0  1 F8 C8 A1  1 
   then
   slow-next? @  if  pnext  then
1A1DE08 	9C C8 A1  1 5C 4C A0  1 
1A1DE10 	DC 41 A0  1  8  0  0  0 
1A1DE18 	38 C8 A1  1 
;
1A1DE1C 	58 46 A0  1 
' (trace  'debug token!

headers

only forth bug also forth definitions

: debug  \ name (s -- )
1A1DE20 	 0  0 64 65 62 75 67 85 
1A1DE28 	48 CB A1  1 20 40 A0  1 
   '
1A1DE30 	F8 95 A0  1 
   .debug-short-help
1A1DE34 	90 CC A1  1 
   (debug
1A1DE38 	8C CA A1  1 
;
1A1DE3C 	58 46 A0  1 
: debugging  ( -- )  ' .debug-short-help  dup (debug  execute  ;
1A1DE40 	 0  0 64 65 62 75 67 67 
1A1DE48 	69 6E 67 89 2C DE A1  1 
1A1DE50 	20 40 A0  1 F8 95 A0  1 
1A1DE58 	90 CC A1  1 40 49 A0  1 
1A1DE60 	8C CA A1  1 98 41 A0  1 
1A1DE68 	58 46 A0  1 
: resume    (s -- )  true is exit-interact?  force-redisplay  pnext  ;
1A1DE6C 	 0 72 65 73 
1A1DE70 	75 6D 65 86 50 DE A1  1 
1A1DE78 	20 40 A0  1  4 70 A0  1 
1A1DE80 	B8 40 A0  1 90 E0 A0  1 
1A1DE88 	F8 C8 A1  1 38 C8 A1  1 
1A1DE90 	58 46 A0  1 
: stepping  (s -- )  step? on  ;
1A1DE94 	 0  0  0 73 
1A1DE98 	74 65 70 70 69 6E 67 88 
1A1DEA0 	78 DE A1  1 20 40 A0  1 
1A1DEA8 	B0 C8 A1  1 E0 4B A0  1 
1A1DEB0 	58 46 A0  1 
: tracing   (s -- )  step? off ;
1A1DEB4 	74 72 61 63 
1A1DEB8 	69 6E 67 87 A4 DE A1  1 
1A1DEC0 	20 40 A0  1 B0 C8 A1  1 
1A1DEC8 	F8 4B A0  1 58 46 A0  1 

only forth also definitions

OpenFirmware/forth/lib/debug.fth_AL	1664 1A1DED0 purpose: Internet checksum (one's complement of 16-bit words) primitive

\ The complete checksum calculation consists of:
\ a) add together all the 16-bit big-endian words in the buffer, with
\    wrap-around carry (i.e. a carry out of the high bit is added back
\    in at the low bit).
\ b) Take the one's complement of the result, preserving only the
\    least-significant 16 bits.
\ c) If the result is 0, change it to ffff.

\ The process of computing a checksum for UDP packets involves the
\ creation of a "pseudo header" containing selected information
\ from the IP header, and checksumming the combination of that pseudo
\ header and the UDP packet.  To do so, it is convenient to perform
\ step (a) of the calculation separately on the two pieces (pseudo header
\ and UDP packet).  Thus we factor the checksum calculation code with
\ a separate primitive "(oc-checksum)" that performs step (a).  That
\ primitive is worth optimizing; steps (b) and (c) are typically not.

headerless
\ This computation depends on some properties of one's complement
\ summation.  The computation can be done in either endianness,
\ so we do it in little-endian, swapping at the end, to save time
\ on x86.  We also do it 32 bits at a time, folding the result
\ at the end.

code (oc-checksum)  ( accum adr len -- checksum )
1A1DF11 	 0 28 6F 63 2D 63 68 
1A1DF18 	65 63 6B 73 75 6D 29 8D 
1A1DF20 	 8 DF A1  1 28 DF A1  1 
   bx          pop     \ bx: len
1A1DF28 	5B 
   ax          pop     \ ax: adr
1A1DF29 	58 
   dx          pop     \ dx: accum
1A1DF2A 	5A 
   si          push    \ save si
1A1DF2B 	56 
   ax   si     mov     \ si: adr  ax: dead
1A1DF2C 	8B F0 
   bx   cx     mov     \ cx:len
1A1DF2E 	8B CB 
   2 #  cx     shr     \ cx:#shortwords
1A1DF30 	C1 E9  2 

   dl dh xchg  \ Byte swap into LE form
1A1DF33 	86 F2 
   clc         \ Initial carry is 0
1A1DF35 	F8 
   cx cx or  0<>  if
1A1DF36 	 9 C9 
1A1DF38 	74  5 
      begin
         ax lods
1A1DF3A 	AD 
         ax dx adc
1A1DF3B 	11 C2 
      loopa
1A1DF3D 	E2 FB 
   then

   0 # dx adc   \ Final carry
1A1DF3F 	83 
1A1DF40 	D2  0 

   2 # bx test  0<>  if      \ Leftover short?
1A1DF42 	F7 C3  2  0  0  0 
1A1DF48 	74  9 
      ax ax xor
1A1DF4A 	31 C0 
      op: ax lods
1A1DF4C 	66 AD 
      ax dx add
1A1DF4E 	 1 C2 
      0 # dx adc  \ Possible carry
1A1DF50 	83 D2  0 
   then

   1 # bx test  0<>  if      \ Leftover byte?
1A1DF53 	F7 C3  1  0  0 
1A1DF58 	 0 74  8 
      ax ax xor
1A1DF5B 	31 C0 
      al lodsb
1A1DF5D 	AC 
      ax dx add
1A1DF5E 	 1 C2 
      0 # dx adc  \ Possible carry
1A1DF60 	83 D2  0 
   then

   dx ax mov  d# 16 # ax shr  h# ffff # dx and  ax dx add  \ Add two halves
1A1DF63 	8B C2 C1 E8 10 
1A1DF68 	81 E2 FF FF  0  0  1 C2 
   dx ax mov  d# 16 # ax shr  h# ffff # dx and  ax dx add  \ Again for carry
1A1DF70 	8B C2 C1 E8 10 81 E2 FF 
1A1DF78 	FF  0  0  1 C2 
   dl dh xchg   \ Byte swap
1A1DF7D 	86 F2 

   si pop
1A1DF7F 	5E 
   dx push
1A1DF80 	52 
c;
1A1DF81 	FF E7 

OpenFirmware/cpu/x86/occhksum.fth_AL	72 1A1DF83 
vocset=5D88B8 1A00620 1A1E784 
vocset=5D88D8 1A0066C 1A210A8 
propset=1A210CC B441A3D 1A0068C 
vocset=B441A3D 1A0068C 1A210CC 
vocset=5D8958 1A00690 1A21294 
vocset=5D88F8 1A00698 1A212D8 1A213BC 
vocset=5D8838 1A0069C 1A217F4 
vocset=5D87F8 1A006B0 1A22650 
propset=1A250DC B441AF3 1A00714 
vocset=B441AF3 1A00714 1A250DC 
new-node=B441B07 1A006F4 
vocset=B441B07 1A006F4 1A250DC 
packages
1A250F0 
propset=1A25110 B441B24 1A00738 
vocset=B441B24 1A00738 1A25110 
new-node=B441B38 1A00718 
vocset=B441B38 1A00718 1A25110 
client-services
1A2512C 
99C98F4   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99C9904   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
6E09E34   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
6E09E44   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
propset=1A2517C B441B55 1A0075C 
vocset=B441B55 1A0075C 1A2517C 
new-node=B441B69 1A0073C 
vocset=B441B69 1A0073C 1A2517C 
chosen
1A2518C 
99CA584   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99CA594   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
propset=1A251C4 B441B86 1A00780 
vocset=B441B86 1A00780 1A251C4 
new-node=B441B9A 1A00760 
vocset=B441B9A 1A00760 1A251C4 
openprom
1A251D8 1A251FC 1A25220 
99CB214   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99CB224   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
propset=1A25258 B441BC9 1A007A4 
vocset=B441BC9 1A007A4 1A25258 
new-node=B441BDD 1A00784 
vocset=B441BDD 1A00784 1A25258 
options
1A2526C 
99CBEA4   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99CBEB4   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
propset=1A252A4 B441BFA 1A007C8 
vocset=B441BFA 1A007C8 1A252A4 
new-node=B441C0E 1A007A8 
vocset=B441C0E 1A007A8 1A252A4 
aliases
1A252B8 
99CCB34   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99CCB44   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
vocset=5D8858 1A00800 1A262D8 \ From standini.fth
0 value stand-init-debug?
1A1DF83 	 0  0  0 73 74 
1A1DF88 	61 6E 64 2D 69 6E 69 74 
1A1DF90 	2D 64 65 62 75 67 3F 91 
1A1DF98 	24 DF A1  1 50 40 A0  1 
1A1DFA0 	60  5  0  0 

defer ?message-code  ( adr len -- adr len )  ' noop to ?message-code
1A1DFA4 	 0  0 3F 6D 
1A1DFA8 	65 73 73 61 67 65 2D 63 
1A1DFB0 	6F 64 65 8D 9C DF A1  1 
1A1DFB8 	5C 40 A0  1 64  5  0  0 
: ?type  ( adr len -- )
1A1DFC0 	 0  0 3F 74 79 70 65 85 
1A1DFC8 	B8 DF A1  1 20 40 A0  1 
;
1A1DFD0 	58 46 A0  1 

only forth also hidden also forth definitions

\needs standalone?  false value standalone?

only forth also definitions
: stand-init-io  ( -- )  true to standalone?  ;	\ First definition
1A1DFD4 	 0  0 73 74 
1A1DFD8 	61 6E 64 2D 69 6E 69 74 
1A1DFE0 	2D 69 6F 8D CC DF A1  1 
1A1DFE8 	20 40 A0  1  4 70 A0  1 
1A1DFF0 	B8 40 A0  1 F4 DE A1  1 
1A1DFF8 	58 46 A0  1 
headers

\ From sysintf.fth
purpose: Interfaces to low-level system functions

\ Interfaces to system-dependent routines

headers
defer diag-key     ( -- char )  \ Used by dl, dlbin, dlfcode.
1A1DFFC 	 0  0  0 64 
1A1E000 	69 61 67 2D 6B 65 79 88 
1A1E008 	E8 DF A1  1 5C 40 A0  1 
1A1E010 	68  5  0  0 
defer diag-key?    ( -- flag )  \ Used by dlbin.
1A1E014 	 0  0 64 69 
1A1E018 	61 67 2D 6B 65 79 3F 89 
1A1E020 	 C E0 A1  1 5C 40 A0  1 
1A1E028 	6C  5  0  0 

\ (Approximately) millisecond-granularity timing
\ Typically implemented by a driver for a counter/timer device

d# 10 value ms/tick
1A1E02C 	6D 73 2F 74 
1A1E030 	69 63 6B 87 24 E0 A1  1 
1A1E038 	50 40 A0  1 70  5  0  0 
defer get-msecs  ( -- n )  ' 0 is get-msecs
1A1E040 	 0  0 67 65 74 2D 6D 73 
1A1E048 	65 63 73 89 38 E0 A1  1 
1A1E050 	5C 40 A0  1 74  5  0  0 
defer ms  ( n -- )   ' drop is ms
1A1E058 	 0 6D 73 82 50 E0 A1  1 
1A1E060 	5C 40 A0  1 78  5  0  0 
defer us  ( n -- )   ' drop is us
1A1E068 	 0 75 73 82 60 E0 A1  1 
1A1E070 	5C 40 A0  1 7C  5  0  0 


\ Enabling/disabling interrupts
\ Typically implemented by a driver for an interrupt controller

defer lock[    ( -- )   ' noop is lock[
1A1E078 	 0  0 6C 6F 63 6B 5B 85 
1A1E080 	70 E0 A1  1 5C 40 A0  1 
1A1E088 	80  5  0  0 
defer ]unlock  ( -- )   ' noop is ]unlock
1A1E08C 	5D 75 6E 6C 
1A1E090 	6F 63 6B 87 84 E0 A1  1 
1A1E098 	5C 40 A0  1 84  5  0  0 
defer enable-interrupts   ( -- )  ' noop is enable-interrupts
1A1E0A0 	 0  0 65 6E 61 62 6C 65 
1A1E0A8 	2D 69 6E 74 65 72 72 75 
1A1E0B0 	70 74 73 91 98 E0 A1  1 
1A1E0B8 	5C 40 A0  1 88  5  0  0 
defer disable-interrupts  ( -- )  ' noop is disable-interrupts
1A1E0C0 	 0 64 69 73 61 62 6C 65 
1A1E0C8 	2D 69 6E 74 65 72 72 75 
1A1E0D0 	70 74 73 92 B8 E0 A1  1 
1A1E0D8 	5C 40 A0  1 8C  5  0  0 


\ System-wide DMA memory allocation (used only by the deblocker)
\ Typically implemented by a MMU driver

headerless
: null-allocate-dma  ( #bytes -- 0 )  drop 0  ;
1A1E0E0 	 0  0 6E 75 6C 6C 2D 61 
1A1E0E8 	6C 6C 6F 63 61 74 65 2D 
1A1E0F0 	64 6D 61 91 D8 E0 A1  1 
1A1E0F8 	20 40 A0  1 30 49 A0  1 
1A1E100 	70 6F A0  1 58 46 A0  1 

headers
defer allocate-dma  ' null-allocate-dma is allocate-dma
1A1E108 	 0  0  0 61 6C 6C 6F 63 
1A1E110 	61 74 65 2D 64 6D 61 8C 
1A1E118 	F8 E0 A1  1 5C 40 A0  1 
1A1E120 	90  5  0  0 

headerless
: null-free-dma  ( virt #bytes -- )  2drop  ;
1A1E124 	 0  0 6E 75 
1A1E128 	6C 6C 2D 66 72 65 65 2D 
1A1E130 	64 6D 61 8D 1C E1 A1  1 
1A1E138 	20 40 A0  1 AC 49 A0  1 
1A1E140 	58 46 A0  1 

headers
defer free-dma  ' null-free-dma is free-dma
1A1E144 	 0  0  0 66 
1A1E148 	72 65 65 2D 64 6D 61 88 
1A1E150 	38 E1 A1  1 5C 40 A0  1 
1A1E158 	94  5  0  0 

\ Storage of reboot information across system resets
\ The reboot information is typically stored in some type of memory
\ that is not cleared by a system reset.  The information does not
\ necessary have to survive across power cycles.

false value reboot?	\ Usually set in machine-dependent startup code
1A1E15C 	72 65 62 6F 
1A1E160 	6F 74 3F 87 54 E1 A1  1 
1A1E168 	50 40 A0  1 98  5  0  0 
			\ after testing a magic flag in physical memory

: null$  ( -- adr len )  " "  ;
1A1E170 	 0  0 6E 75 6C 6C 24 85 
1A1E178 	68 E1 A1  1 20 40 A0  1 
1A1E180 	9C 53 A0  1  0  0  0  0 
1A1E188 	58 46 A0  1 

headerless

defer save-reboot-info  ( arg$ cmd$ line# column# -- )
1A1E18C 	 0  0  0 73 
1A1E190 	61 76 65 2D 72 65 62 6F 
1A1E198 	6F 74 2D 69 6E 66 6F 90 
1A1E1A0 	7C E1 A1  1 5C 40 A0  1 
1A1E1A8 	9C  5  0  0 
defer get-reboot-info  ( -- cmd+arg$ line# column# )
1A1E1AC 	67 65 74 2D 
1A1E1B0 	72 65 62 6F 6F 74 2D 69 
1A1E1B8 	6E 66 6F 8F A4 E1 A1  1 
1A1E1C0 	5C 40 A0  1 A0  5  0  0 

headerless
: null-save-reboot-info  ( arg$ cmd$ line# column# -- )  2drop 2drop 2drop  ;
1A1E1C8 	 0  0 6E 75 6C 6C 2D 73 
1A1E1D0 	61 76 65 2D 72 65 62 6F 
1A1E1D8 	6F 74 2D 69 6E 66 6F 95 
1A1E1E0 	C0 E1 A1  1 20 40 A0  1 
1A1E1E8 	AC 49 A0  1 AC 49 A0  1 
1A1E1F0 	AC 49 A0  1 58 46 A0  1 
' null-save-reboot-info is save-reboot-info
: null-get-reboot-info  ( -- cmd+arg$ line# column# )  null$ 0 0  ;
1A1E1F8 	 0  0  0 6E 75 6C 6C 2D 
1A1E200 	67 65 74 2D 72 65 62 6F 
1A1E208 	6F 74 2D 69 6E 66 6F 94 
1A1E210 	E4 E1 A1  1 20 40 A0  1 
1A1E218 	7C E1 A1  1 70 6F A0  1 
1A1E220 	70 6F A0  1 58 46 A0  1 
' null-get-reboot-info is get-reboot-info
headers

\ Force a system reset
\ Typically implemented by a driver for system-level special registers.

defer reset-all ( -- )  ' noop is reset-all
1A1E228 	 0  0 72 65 73 65 74 2D 
1A1E230 	61 6C 6C 89 14 E2 A1  1 
1A1E238 	5C 40 A0  1 A4  5  0  0 


defer cleanup ' noop is cleanup	\ pkg/boot/go.fth
1A1E240 	63 6C 65 61 6E 75 70 87 
1A1E248 	38 E2 A1  1 5C 40 A0  1 
1A1E250 	A8  5  0  0 

false value already-go?	\ sun4/reenter.fth
1A1E254 	61 6C 72 65 
1A1E258 	61 64 79 2D 67 6F 3F 8B 
1A1E260 	4C E2 A1  1 50 40 A0  1 
1A1E268 	AC  5  0  0 

\ From reenter.fth
headerless
nuser aborted?      aborted? off
1A1E26C 	 0  0  0 61 
1A1E270 	62 6F 72 74 65 64 3F 88 
1A1E278 	64 E2 A1  1 48 40 A0  1 
1A1E280 	B0  5  0  0 
1 value allow-user-aborts?  \ Must be 0/1 instead of false/true because of the incrementing in the low-level handler
1A1E284 	 0 61 6C 6C 
1A1E288 	6F 77 2D 75 73 65 72 2D 
1A1E290 	61 62 6F 72 74 73 3F 92 
1A1E298 	7C E2 A1  1 50 40 A0  1 
1A1E2A0 	B4  5  0  0 
: enable-user-aborts  ( -- )  1 to allow-user-aborts?  ;
1A1E2A4 	 0 65 6E 61 
1A1E2A8 	62 6C 65 2D 75 73 65 72 
1A1E2B0 	2D 61 62 6F 72 74 73 92 
1A1E2B8 	9C E2 A1  1 20 40 A0  1 
1A1E2C0 	80 6F A0  1 B8 40 A0  1 
1A1E2C8 	9C E2 A1  1 58 46 A0  1 
: disable-user-aborts  ( -- )  0 to allow-user-aborts?  ;
1A1E2D0 	64 69 73 61 62 6C 65 2D 
1A1E2D8 	75 73 65 72 2D 61 62 6F 
1A1E2E0 	72 74 73 93 BC E2 A1  1 
1A1E2E8 	20 40 A0  1 70 6F A0  1 
1A1E2F0 	B8 40 A0  1 9C E2 A1  1 
1A1E2F8 	58 46 A0  1 

headers
: user-abort  ( -- )  allow-user-aborts? aborted? ! ;
1A1E2FC 	 0 75 73 65 
1A1E300 	72 2D 61 62 6F 72 74 8A 
1A1E308 	E8 E2 A1  1 20 40 A0  1 
1A1E310 	9C E2 A1  1 7C E2 A1  1 
1A1E318 	54 4D A0  1 58 46 A0  1 
headerless

\ System and version identification

\ System architecture name - used to locate the proper boot file
defer cpu-arch  ( -- adr len )   ' null$ is cpu-arch
1A1E320 	 0  0  0 63 70 75 2D 61 
1A1E328 	72 63 68 88  C E3 A1  1 
1A1E330 	5C 40 A0  1 B8  5  0  0 

defer idprom-valid?  ( -- flag )
1A1E338 	 0  0 69 64 70 72 6F 6D 
1A1E340 	2D 76 61 6C 69 64 3F 8D 
1A1E348 	30 E3 A1  1 5C 40 A0  1 
1A1E350 	BC  5  0  0 
' true  is idprom-valid?

3 value major-release  0 value minor-release
1A1E354 	 0  0 6D 61 
1A1E358 	6A 6F 72 2D 72 65 6C 65 
1A1E360 	61 73 65 8D 4C E3 A1  1 
1A1E368 	50 40 A0  1 C0  5  0  0 
1A1E370 	 0  0 6D 69 6E 6F 72 2D 
1A1E378 	72 65 6C 65 61 73 65 8D 
1A1E380 	68 E3 A1  1 50 40 A0  1 
1A1E388 	C4  5  0  0 
defer sub-release  ( -- adr len )   ' null$ is sub-release
1A1E38C 	73 75 62 2D 
1A1E390 	72 65 6C 65 61 73 65 8B 
1A1E398 	84 E3 A1  1 5C 40 A0  1 
1A1E3A0 	C8  5  0  0 

defer serial#  ( -- n )   ' 0 is serial#
1A1E3A4 	73 65 72 69 
1A1E3A8 	61 6C 23 87 9C E3 A1  1 
1A1E3B0 	5C 40 A0  1 CC  5  0  0 


\ System-wide network address

\ system-mac-address is typically defined in some sort of ID PROM
defer system-mac-address  ( -- adr len )  ' null$ is system-mac-address
1A1E3B8 	 0 73 79 73 74 65 6D 2D 
1A1E3C0 	6D 61 63 2D 61 64 64 72 
1A1E3C8 	65 73 73 92 B0 E3 A1  1 
1A1E3D0 	5C 40 A0  1 D0  5  0  0 


\ Device to use for console output if the preferred device is unavailable

headers
defer fallback-device  ( -- adr len )  ' null$ is fallback-device
1A1E3D8 	66 61 6C 6C 62 61 63 6B 
1A1E3E0 	2D 64 65 76 69 63 65 8F 
1A1E3E8 	D0 E3 A1  1 5C 40 A0  1 
1A1E3F0 	D4  5  0  0 
headerless


\ Compatibility FCode support

defer sbus-intr>cpu   ( sbus-level -- cpu-level )  ' noop is sbus-intr>cpu
1A1E3F4 	 0  0 73 62 
1A1E3F8 	75 73 2D 69 6E 74 72 3E 
1A1E400 	63 70 75 8D EC E3 A1  1 
1A1E408 	5C 40 A0  1 D8  5  0  0 

: no-memory  ( -- adr len )  0 0  ;
1A1E410 	 0  0 6E 6F 2D 6D 65 6D 
1A1E418 	6F 72 79 89  8 E4 A1  1 
1A1E420 	20 40 A0  1 70 6F A0  1 
1A1E428 	70 6F A0  1 58 46 A0  1 

headers
\ OS callbacks
\ The real stack effect appears to be ( args vector -- )
\ defer callback-call  ( arg-array -- error? )  ' noop is callback-call


\ Default font
defer romfont  ( -- fontadr )  ' false is romfont
1A1E430 	72 6F 6D 66 6F 6E 74 87 
1A1E438 	20 E4 A1  1 5C 40 A0  1 
1A1E440 	DC  5  0  0 


\ Logo dimensions.  These particular values are stipulated by IEEE 1275-1994
d# 64 constant logo-width
1A1E444 	 0 6C 6F 67 
1A1E448 	6F 2D 77 69 64 74 68 8A 
1A1E450 	3C E4 A1  1 68 40 A0  1 
1A1E458 	40  0  0  0 
d# 64 constant logo-height
1A1E45C 	6C 6F 67 6F 
1A1E460 	2D 68 65 69 67 68 74 8B 
1A1E468 	54 E4 A1  1 68 40 A0  1 
1A1E470 	40  0  0  0 

defer default-logo  ' null$ is default-logo
1A1E474 	 0  0  0 64 
1A1E478 	65 66 61 75 6C 74 2D 6C 
1A1E480 	6F 67 6F 8C 6C E4 A1  1 
1A1E488 	5C 40 A0  1 E0  5  0  0 

defer nv-c@
1A1E490 	 0  0 6E 76 2D 63 40 85 
1A1E498 	88 E4 A1  1 5C 40 A0  1 
1A1E4A0 	E4  5  0  0 
defer nv-c!
1A1E4A4 	 0  0 6E 76 
1A1E4A8 	2D 63 21 85 9C E4 A1  1 
1A1E4B0 	5C 40 A0  1 E8  5  0  0 

defer power-off  ( -- )
1A1E4B8 	 0  0 70 6F 77 65 72 2D 
1A1E4C0 	6F 66 66 89 B0 E4 A1  1 
1A1E4C8 	5C 40 A0  1 EC  5  0  0 

defer (init-program) ' noop is (init-program)
1A1E4D0 	 0 28 69 6E 69 74 2D 70 
1A1E4D8 	72 6F 67 72 61 6D 29 8E 
1A1E4E0 	C8 E4 A1  1 5C 40 A0  1 
1A1E4E8 	F0  5  0  0 

headers
variable cpu-node
1A1E4EC 	 0  0  0 63 
1A1E4F0 	70 75 2D 6E 6F 64 65 88 
1A1E4F8 	E4 E4 A1  1 48 40 A0  1 
1A1E500 	F4  5  0  0 

\ From execbuf.fth
purpose: Chain of recognizers for image formats

defer interpret-string  ( adr len -- )  ' evaluate is interpret-string
1A1E504 	 0  0  0 69 
1A1E508 	6E 74 65 72 70 72 65 74 
1A1E510 	2D 73 74 72 69 6E 67 90 
1A1E518 	FC E4 A1  1 5C 40 A0  1 
1A1E520 	F8  5  0  0 

: safe-include-buffer  ( adr len -- ? )
1A1E524 	73 61 66 65 
1A1E528 	2D 69 6E 63 6C 75 64 65 
1A1E530 	2D 62 75 66 66 65 72 93 
1A1E538 	1C E5 A1  1 20 40 A0  1 
   dup alloc-mem          ( adr len adr1 )
1A1E540 	40 49 A0  1 F0 6C A0  1 
   swap 2>r               ( adr r: adr1,len )
1A1E548 	68 49 A0  1 F8 45 A0  1 
   2r@ move               ( r: adr1,len )
1A1E550 	28 46 A0  1 F4 4A A0  1 
   2r@ include-buffer     ( ? r: adr1,len )
1A1E558 	28 46 A0  1 28 E8 A0  1 
   2r> free-mem           ( ? )
1A1E560 	10 46 A0  1  8 6D A0  1 
;
1A1E568 	58 46 A0  1 
: execute-buffer  ( adr len -- )  true abort" Unrecognized program format"  ;
1A1E56C 	 0 65 78 65 
1A1E570 	63 75 74 65 2D 62 75 66 
1A1E578 	66 65 72 8E 3C E5 A1  1 
1A1E580 	20 40 A0  1  4 70 A0  1 
1A1E588 	 8 81 A0  1 1B 55 6E 72 
1A1E590 	65 63 6F 67 6E 69 7A 65 
1A1E598 	64 20 70 72 6F 67 72 61 
1A1E5A0 	6D 20 66 6F 72 6D 61 74 
1A1E5A8 	 0  0  0  0 58 46 A0  1 
: execute-buffer    ( adr len -- )              \ Try Forth
1A1E5B0 	 0 65 78 65 63 75 74 65 
1A1E5B8 	2D 62 75 66 66 65 72 8E 
1A1E5C0 	80 E5 A1  1 20 40 A0  1 
   " \ "         2over substring?  if  safe-include-buffer exit  then   ( adr len )
1A1E5C8 	9C 53 A0  1  2 5C 20  0 
1A1E5D0 	D8 49 A0  1 84 16 A1  1 
1A1E5D8 	DC 41 A0  1  C  0  0  0 
1A1E5E0 	3C E5 A1  1 40 46 A0  1 
   " purpose: "  2over substring?  if  safe-include-buffer exit  then   ( adr len )
1A1E5E8 	9C 53 A0  1  9 70 75 72 
1A1E5F0 	70 6F 73 65 3A 20  0  0 
1A1E5F8 	D8 49 A0  1 84 16 A1  1 
1A1E600 	DC 41 A0  1  C  0  0  0 
1A1E608 	3C E5 A1  1 40 46 A0  1 
   " id: "       2over substring?  if  safe-include-buffer exit  then   ( adr len )
1A1E610 	9C 53 A0  1  4 69 64 3A 
1A1E618 	20  0  0  0 D8 49 A0  1 
1A1E620 	84 16 A1  1 DC 41 A0  1 
1A1E628 	 C  0  0  0 3C E5 A1  1 
1A1E630 	40 46 A0  1 

   execute-buffer
1A1E634 	80 E5 A1  1 
;
1A1E638 	58 46 A0  1 
: 'execute-buffer  ( -- xt )
1A1E63C 	27 65 78 65 
1A1E640 	63 75 74 65 2D 62 75 66 
1A1E648 	66 65 72 8F C4 E5 A1  1 
1A1E650 	20 40 A0  1 
   " execute-buffer" ['] forth  search-wordlist  drop
1A1E654 	9C 53 A0  1 
1A1E658 	 E 65 78 65 63 75 74 65 
1A1E660 	2D 62 75 66 66 65 72  0 
1A1E668 	60 53 A0  1  8 C5 A0  1 
1A1E670 	38 BB A0  1 30 49 A0  1 
;
1A1E678 	58 46 A0  1 

headers


\ From diagmode.fth

headers
defer (diagnostic-mode?)  ' false is (diagnostic-mode?)
1A1E67C 	 0 28 64 69 
1A1E680 	61 67 6E 6F 73 74 69 63 
1A1E688 	2D 6D 6F 64 65 3F 29 92 
1A1E690 	50 E6 A1  1 5C 40 A0  1 
1A1E698 	FC  5  0  0 
: diagnostic-mode?  ( -- flag )
1A1E69C 	 0  0  0 64 
1A1E6A0 	69 61 67 6E 6F 73 74 69 
1A1E6A8 	63 2D 6D 6F 64 65 3F 90 
1A1E6B0 	94 E6 A1  1 20 40 A0  1 
   standalone?  if  (diagnostic-mode?)  else  false  then  
1A1E6B8 	F4 DE A1  1 DC 41 A0  1 
1A1E6C0 	10  0  0  0 94 E6 A1  1 
1A1E6C8 	C8 41 A0  1  8  0  0  0 
1A1E6D0 	18 70 A0  1 
;
1A1E6D4 	58 46 A0  1 

: diag-type ( adr,len -- )  diagnostic-mode?  if  type  else  2drop  then  ;
1A1E6D8 	 0  0 64 69 61 67 2D 74 
1A1E6E0 	79 70 65 89 B4 E6 A1  1 
1A1E6E8 	20 40 A0  1 B4 E6 A1  1 
1A1E6F0 	DC 41 A0  1 10  0  0  0 
1A1E6F8 	 4 6C A0  1 C8 41 A0  1 
1A1E700 	 8  0  0  0 AC 49 A0  1 
1A1E708 	58 46 A0  1 
: diag-cr   ( -- )  diagnostic-mode?  if  cr  then  ;
1A1E70C 	64 69 61 67 
1A1E710 	2D 63 72 87 E8 E6 A1  1 
1A1E718 	20 40 A0  1 B4 E6 A1  1 
1A1E720 	DC 41 A0  1  8  0  0  0 
1A1E728 	80 6D A0  1 58 46 A0  1 
: diag-.d   ( n -- ) diagnostic-mode?  if  .d  else  drop  then  ;   
1A1E730 	64 69 61 67 2D 2E 64 87 
1A1E738 	18 E7 A1  1 20 40 A0  1 
1A1E740 	B4 E6 A1  1 DC 41 A0  1 
1A1E748 	10  0  0  0 48  E A1  1 
1A1E750 	C8 41 A0  1  8  0  0  0 
1A1E758 	30 49 A0  1 58 46 A0  1 
: diag-type-cr ( adr,len -- )  diag-type diag-cr  ;
1A1E760 	 0  0  0 64 69 61 67 2D 
1A1E768 	74 79 70 65 2D 63 72 8C 
1A1E770 	3C E7 A1  1 20 40 A0  1 
1A1E778 	E8 E6 A1  1 18 E7 A1  1 
1A1E780 	58 46 A0  1 

headers

\ interpolated from loaddevt.fth

\ Create the options vocabulary.  Later, it will become the property
\ list of "options" node in the device tree.

vocabulary options
1A1E784 	6F 70 74 69 
1A1E788 	6F 6E 73 87 74 E7 A1  1 
1A1E790 	E0 B6 A0  1  0  6  0  0 
1A1E798 	E0 C6 A1  1  0  0  0  0 

\ Make the options vocabulary a permanent part of the search order.

only forth also root also definitions
: fw-search-order  ( -- )  root also options also  ;
1A1E7A0 	66 77 2D 73 65 61 72 63 
1A1E7A8 	68 2D 6F 72 64 65 72 8F 
1A1E7B0 	88 1F A1  1 20 40 A0  1 
1A1E7B8 	B0 C1 A0  1 C8 C1 A0  1 
1A1E7C0 	90 E7 A1  1 C8 C1 A0  1 
1A1E7C8 	58 46 A0  1 
' fw-search-order to minimum-search-order
only forth hidden also forth also definitions

\ end interpolation

\ From confact.fth

purpose: Generic framework for configuration options

\ Action names for configuration objects

headers

\ 0 action = value on stack  ( apf -- value )
\      call with: fieldname
\ 1 action = store value   ( value apf -- )
\      call with: value to fieldname
\ 2 action = adr on stack  ( apf -- adr )
\      call with: addr fieldname
\ 3 action = decode for display  ( apf -- adr len )
\      call with: decode fieldname
\ 4 action = encode for storage  ( adr len apf -- )
\      call with: encode fieldname
\ 5 action = default value  ( apf -- value )
\ "value" is either int, char, or ( adr len) for strings

: get  ( acf -- value )  0 perform-action  ;
1A1E7CC 	67 65 74 83 
1A1E7D0 	90 E7 A1  1 20 40 A0  1 
1A1E7D8 	70 6F A0  1 10 B8 A1  1 
1A1E7E0 	58 46 A0  1 
: set  ( value acf -- )  1 perform-action  ;
1A1E7E4 	73 65 74 83 
1A1E7E8 	D4 E7 A1  1 20 40 A0  1 
1A1E7F0 	80 6F A0  1 10 B8 A1  1 
1A1E7F8 	58 46 A0  1 
: decode  ( value acf -- adr len )  3 perform-action  ;
1A1E7FC 	 0 64 65 63 
1A1E800 	6F 64 65 86 EC E7 A1  1 
1A1E808 	20 40 A0  1 A0 6F A0  1 
1A1E810 	10 B8 A1  1 58 46 A0  1 
: encode  ( adr len acf -- true | value false )
1A1E818 	 0 65 6E 63 6F 64 65 86 
1A1E820 	 8 E8 A1  1 20 40 A0  1 
   4 ['] perform-action  catch  if
1A1E828 	B0 6F A0  1 60 53 A0  1 
1A1E830 	10 B8 A1  1 14 7F A0  1 
1A1E838 	DC 41 A0  1 18  0  0  0 
      2drop 2drop true
1A1E840 	AC 49 A0  1 AC 49 A0  1 
1A1E848 	 4 70 A0  1 
   else
1A1E84C 	C8 41 A0  1 
1A1E850 	 8  0  0  0 
      false
1A1E854 	18 70 A0  1 
   then
;
1A1E858 	58 46 A0  1 
: get-default  ( acf -- value )  5 perform-action  ;
1A1E85C 	67 65 74 2D 
1A1E860 	64 65 66 61 75 6C 74 8B 
1A1E868 	24 E8 A1  1 20 40 A0  1 
1A1E870 	C0 6F A0  1 10 B8 A1  1 
1A1E878 	58 46 A0  1 

defer config-rw  ( -- )  ' noop is config-rw
1A1E87C 	 0  0 63 6F 
1A1E880 	6E 66 69 67 2D 72 77 89 
1A1E888 	6C E8 A1  1 5C 40 A0  1 
1A1E890 	 4  6  0  0 
defer config-ro  ( -- )  ' noop is config-ro
1A1E894 	 0  0 63 6F 
1A1E898 	6E 66 69 67 2D 72 6F 89 
1A1E8A0 	8C E8 A1  1 5C 40 A0  1 
1A1E8A8 	 8  6  0  0 
headerless

: to-column:  \ name ( col# -- )  ( -- )
1A1E8AC 	 0 74 6F 2D 
1A1E8B0 	63 6F 6C 75 6D 6E 3A 8A 
1A1E8B8 	A4 E8 A1  1 20 40 A0  1 
   create c,  does>  c@ to-column
1A1E8C0 	A8 A2 A0  1 B8 55 A0  1 
1A1E8C8 	50 A3 A0  1 90 90 90 E8 
1A1E8D0 	A8 57 FE FF C4 4C A0  1 
1A1E8D8 	 8 14 A1  1 
;
1A1E8DC 	58 46 A0  1 

d# 22 to-column: value-column
1A1E8E0 	 0  0  0 76 61 6C 75 65 
1A1E8E8 	2D 63 6F 6C 75 6D 6E 8C 
1A1E8F0 	BC E8 A1  1 CC E8 A1  1 
1A1E8F8 	16 
d# 53 to-column: default-column
1A1E8F9 	64 65 66 61 75 6C 74 
1A1E900 	2D 63 6F 6C 75 6D 6E 8E 
1A1E908 	F4 E8 A1  1 CC E8 A1  1 
1A1E910 	35 

: 3u.r ( u -- ) <# bl hold u# u#s u#> type  ;
1A1E911 	 0  0 33 75 2E 72 84 
1A1E918 	 C E9 A1  1 20 40 A0  1 
1A1E920 	 8 76 A0  1 28 70 A0  1 
1A1E928 	DC 75 A0  1 94 76 A0  1 
1A1E930 	BC 76 A0  1 E0 76 A0  1 
1A1E938 	 4 6C A0  1 58 46 A0  1 

: cdump  ( adr len -- )  push-hex  bounds ?do  i c@ 3u.r  loop  pop-base  ;
1A1E940 	 0  0 63 64 75 6D 70 85 
1A1E948 	1C E9 A1  1 20 40 A0  1 
1A1E950 	5C F4 A0  1 F0 6D A0  1 
1A1E958 	50 42 A0  1 18  0  0  0 
1A1E960 	B4 42 A0  1 C4 4C A0  1 
1A1E968 	1C E9 A1  1 F8 41 A0  1 
1A1E970 	F0 FF FF FF 9C F4 A0  1 
1A1E978 	58 46 A0  1 
: -null  ( adr len -- adr len' )
1A1E97C 	 0  0 2D 6E 
1A1E980 	75 6C 6C 85 4C E9 A1  1 
1A1E988 	20 40 A0  1 
   \ Remove last character if it's a null
   dup  if                             ( adr len )
1A1E98C 	40 49 A0  1 
1A1E990 	DC 41 A0  1 24  0  0  0 
      2dup + 1- c@  0=  if  1-  then   ( adr len' )
1A1E998 	C0 49 A0  1  4 45 A0  1 
1A1E9A0 	54 4B A0  1 C4 4C A0  1 
1A1E9A8 	24 47 A0  1 DC 41 A0  1 
1A1E9B0 	 8  0  0  0 54 4B A0  1 
   then                                ( adr len' )
;
1A1E9B8 	58 46 A0  1 
: text?  ( adr len -- flag )
1A1E9BC 	 0  0 74 65 
1A1E9C0 	78 74 3F 85 88 E9 A1  1 
1A1E9C8 	20 40 A0  1 
   true -rot  bounds ?do                          ( true )
1A1E9CC 	 4 70 A0  1 
1A1E9D0 	94 49 A0  1 F0 6D A0  1 
1A1E9D8 	50 42 A0  1 64  0  0  0 
      i c@  bl h# 7e between  0=                  ( non-printable? )
1A1E9E0 	B4 42 A0  1 C4 4C A0  1 
1A1E9E8 	28 70 A0  1 58 41 A0  1 
1A1E9F0 	7E  0  0  0 D8 70 A0  1 
1A1E9F8 	24 47 A0  1 
      i c@  dup carret  =  swap linefeed  =  or   ( non-printable?  cr/nl? )
1A1E9FC 	B4 42 A0  1 
1A1EA00 	C4 4C A0  1 40 49 A0  1 
1A1EA08 	60 6F A0  1 24 48 A0  1 
1A1EA10 	68 49 A0  1 4C 6F A0  1 
1A1EA18 	24 48 A0  1 70 44 A0  1 
      0=  and  if  0= leave  then                 ( true )
1A1EA20 	24 47 A0  1 5C 44 A0  1 
1A1EA28 	DC 41 A0  1  C  0  0  0 
1A1EA30 	24 47 A0  1 18 43 A0  1 
   loop                            ( all-characters-printable? )
1A1EA38 	F8 41 A0  1 A4 FF FF FF 
;
1A1EA40 	58 46 A0  1 
: (type-entry)  ( adr,len  -- )
1A1EA44 	 0  0  0 28 
1A1EA48 	74 79 70 65 2D 65 6E 74 
1A1EA50 	72 79 29 8C C8 E9 A1  1 
1A1EA58 	20 40 A0  1 
   2dup text?  if
1A1EA5C 	C0 49 A0  1 
1A1EA60 	C8 E9 A1  1 DC 41 A0  1 
1A1EA68 	5C  0  0  0 
      bounds  ?do
1A1EA6C 	F0 6D A0  1 
1A1EA70 	50 42 A0  1 48  0  0  0 
	 i c@  dup  newline =  if
1A1EA78 	B4 42 A0  1 C4 4C A0  1 
1A1EA80 	40 49 A0  1 A8 71 A0  1 
1A1EA88 	24 48 A0  1 DC 41 A0  1 
1A1EA90 	20  0  0  0 
	    drop cr value-column  exit? ?leave
1A1EA94 	30 49 A0  1 
1A1EA98 	80 6D A0  1 F4 E8 A1  1 
1A1EAA0 	34  D A1  1 34 43 A0  1 
	 else
1A1EAA8 	C8 41 A0  1  8  0  0  0 
	    emit
1A1EAB0 	2C 6C A0  1 
	 then
      loop
1A1EAB4 	F8 41 A0  1 
1A1EAB8 	C0 FF FF FF 
   else
1A1EABC 	C8 41 A0  1 
1A1EAC0 	 8  0  0  0 
      cdump
1A1EAC4 	4C E9 A1  1 
   then
;
1A1EAC8 	58 46 A0  1 
: $type-entry  ( adr len acf -- )
1A1EACC 	24 74 79 70 
1A1EAD0 	65 2D 65 6E 74 72 79 8B 
1A1EAD8 	58 EA A1  1 20 40 A0  1 
   decode -null                                   ( adr len )
1A1EAE0 	 8 E8 A1  1 88 E9 A1  1 
   tuck 2dup text?  if  d# 28  else  d# 12  then  ( len adr len len' )
1A1EAE8 	E8 46 A0  1 C0 49 A0  1 
1A1EAF0 	C8 E9 A1  1 DC 41 A0  1 
1A1EAF8 	14  0  0  0 58 41 A0  1 
1A1EB00 	1C  0  0  0 C8 41 A0  1 
1A1EB08 	 C  0  0  0 58 41 A0  1 
1A1EB10 	 C  0  0  0 
   min rot over                                   ( adr len' len len' )
1A1EB14 	74 4A A0  1 
1A1EB18 	7C 49 A0  1 54 49 A0  1 
   >  if  4 - (type-entry) ." ..."  else  (type-entry)  then  (  )
1A1EB20 	 4 48 A0  1 DC 41 A0  1 
1A1EB28 	24  0  0  0 B0 6F A0  1 
1A1EB30 	18 45 A0  1 58 EA A1  1 
1A1EB38 	20 7C A0  1  3 2E 2E 2E 
1A1EB40 	 0  0  0  0 C8 41 A0  1 
1A1EB48 	 8  0  0  0 58 EA A1  1 
;
1A1EB50 	58 46 A0  1 
: $type-entry-long  ( adr len acf -- )  decode -null (type-entry)  ;
1A1EB54 	 0  0  0 24 
1A1EB58 	74 79 70 65 2D 65 6E 74 
1A1EB60 	72 79 2D 6C 6F 6E 67 90 
1A1EB68 	DC EA A1  1 20 40 A0  1 
1A1EB70 	 8 E8 A1  1 88 E9 A1  1 
1A1EB78 	58 EA A1  1 58 46 A0  1 

\ 0 action = value on stack  ( apf -- value )
\      call with: fieldname
\ 1 action = store value   ( value apf -- )
\      call with: value to fieldname
\ 2 action = adr on stack  ( apf -- adr )
\      call with: addr fieldname
\ 3 action = decode for display  ( apf -- adr len )
\ 4 action = encode for storage  ( adr len apf -- )
\ 5 action = default value  ( apf -- value )
\ "value" is either int, char, or ( adr len) for strings

\ XXX should be done using "string-property" or "driver" or something
\ create name " options" 1+ ",  does> count  ;  \ Include null byte in count

headerless

defer nodefault?  ' false is nodefault?
1A1EB80 	 0 6E 6F 64 65 66 61 75 
1A1EB88 	6C 74 3F 8A 6C EB A1  1 
1A1EB90 	5C 40 A0  1  C  6  0  0 

\ Copy default value to current value
: do-set-default  ( acf -- )
1A1EB98 	 0 64 6F 2D 73 65 74 2D 
1A1EBA0 	64 65 66 61 75 6C 74 8E 
1A1EBA8 	90 EB A1  1 20 40 A0  1 
   dup >body nodefault?  if  drop  else  >r r@ get-default  r> set  then
1A1EBB0 	40 49 A0  1 E4 59 A0  1 
1A1EBB8 	90 EB A1  1 DC 41 A0  1 
1A1EBC0 	10  0  0  0 30 49 A0  1 
1A1EBC8 	C8 41 A0  1 18  0  0  0 
1A1EBD0 	BC 45 A0  1 E4 45 A0  1 
1A1EBD8 	6C E8 A1  1 D0 45 A0  1 
1A1EBE0 	EC E7 A1  1 
;
1A1EBE4 	58 46 A0  1 
: $find-option  ( adr len -- false | xt true )
1A1EBE8 	 0  0  0 24 66 69 6E 64 
1A1EBF0 	2D 6F 70 74 69 6F 6E 8C 
1A1EBF8 	AC EB A1  1 20 40 A0  1 
   ['] options search-wordlist
1A1EC00 	60 53 A0  1 90 E7 A1  1 
1A1EC08 	38 BB A0  1 
;
1A1EC0C 	58 46 A0  1 
: find-option  ( adr len -- false | xt true )
1A1EC10 	66 69 6E 64 2D 6F 70 74 
1A1EC18 	69 6F 6E 8B FC EB A1  1 
1A1EC20 	20 40 A0  1 
   2dup  $find-option  if            ( adr len xt )
1A1EC24 	C0 49 A0  1 
1A1EC28 	FC EB A1  1 DC 41 A0  1 
1A1EC30 	18  0  0  0 
      nip nip  true                  ( xt true )
1A1EC34 	FC 46 A0  1 
1A1EC38 	FC 46 A0  1  4 70 A0  1 
   else                              ( adr len )
1A1EC40 	C8 41 A0  1 28  0  0  0 
      ." Unknown option: " type cr   ( )
1A1EC48 	20 7C A0  1 10 55 6E 6B 
1A1EC50 	6E 6F 77 6E 20 6F 70 74 
1A1EC58 	69 6F 6E 3A 20  0  0  0 
1A1EC60 	 4 6C A0  1 80 6D A0  1 
      false                          ( false )
1A1EC68 	18 70 A0  1 
   then
;
1A1EC6C 	58 46 A0  1 
   
: show-config-entry  ( acf -- )
1A1EC70 	 0  0 73 68 6F 77 2D 63 
1A1EC78 	6F 6E 66 69 67 2D 65 6E 
1A1EC80 	74 72 79 91 20 EC A1  1 
1A1EC88 	20 40 A0  1 
   >r
1A1EC8C 	BC 45 A0  1 
   r@ .name
1A1EC90 	E4 45 A0  1 C8 9A A0  1 
   value-column     r@ get           r@ $type-entry
1A1EC98 	F4 E8 A1  1 E4 45 A0  1 
1A1ECA0 	D4 E7 A1  1 E4 45 A0  1 
1A1ECA8 	DC EA A1  1 
   r@ >body  nodefault?  if
1A1ECAC 	E4 45 A0  1 
1A1ECB0 	E4 59 A0  1 90 EB A1  1 
1A1ECB8 	DC 41 A0  1 14  0  0  0 
      r> drop
1A1ECC0 	D0 45 A0  1 30 49 A0  1 
   else
1A1ECC8 	C8 41 A0  1 18  0  0  0 
      default-column  r@ get-default   r> $type-entry
1A1ECD0 	 C E9 A1  1 E4 45 A0  1 
1A1ECD8 	6C E8 A1  1 D0 45 A0  1 
1A1ECE0 	DC EA A1  1 
   then
   cr
1A1ECE4 	80 6D A0  1 
;
1A1ECE8 	58 46 A0  1 

: show-current-value ( acf -- )
1A1ECEC 	 0 73 68 6F 
1A1ECF0 	77 2D 63 75 72 72 65 6E 
1A1ECF8 	74 2D 76 61 6C 75 65 92 
1A1ED00 	88 EC A1  1 20 40 A0  1 
   dup .name ." = "  value-column
1A1ED08 	40 49 A0  1 C8 9A A0  1 
1A1ED10 	20 7C A0  1  2 3D 20  0 
1A1ED18 	F4 E8 A1  1 
   >r  r@ get  r> ( adr len acf )  $type-entry-long cr
1A1ED1C 	BC 45 A0  1 
1A1ED20 	E4 45 A0  1 D4 E7 A1  1 
1A1ED28 	D0 45 A0  1 6C EB A1  1 
1A1ED30 	80 6D A0  1 
;
1A1ED34 	58 46 A0  1 

\ Interfaces to the mechanism (if any) for user-created environment variables
\ Some of these interfaces are used in clientif.fth instead of in this file.

defer next-env-var  ( adr len -- adr' len' )
1A1ED38 	 0  0  0 6E 65 78 74 2D 
1A1ED40 	65 6E 76 2D 76 61 72 8C 
1A1ED48 	 4 ED A1  1 5C 40 A0  1 
1A1ED50 	10  6  0  0 
: no-next-env-var  ( adr len -- null$ )  2drop null$  ;
1A1ED54 	6E 6F 2D 6E 
1A1ED58 	65 78 74 2D 65 6E 76 2D 
1A1ED60 	76 61 72 8F 4C ED A1  1 
1A1ED68 	20 40 A0  1 AC 49 A0  1 
1A1ED70 	7C E1 A1  1 58 46 A0  1 
' no-next-env-var to next-env-var

defer put-env-var  ( value$ name$ -- len )
1A1ED78 	70 75 74 2D 65 6E 76 2D 
1A1ED80 	76 61 72 8B 68 ED A1  1 
1A1ED88 	5C 40 A0  1 14  6  0  0 
: no-put-env-var  ( value$ name$ -- len )  2drop 2drop -1  ;
1A1ED90 	 0 6E 6F 2D 70 75 74 2D 
1A1ED98 	65 6E 76 2D 76 61 72 8E 
1A1EDA0 	88 ED A1  1 20 40 A0  1 
1A1EDA8 	AC 49 A0  1 AC 49 A0  1 
1A1EDB0 	58 41 A0  1 FF FF FF FF 
1A1EDB8 	58 46 A0  1 
' no-put-env-var to put-env-var

\ show-extra-env displays the values of environment variables
\ other than the ones explicitly known by Open Firmware.
defer show-extra-env-vars
1A1EDBC 	73 68 6F 77 
1A1EDC0 	2D 65 78 74 72 61 2D 65 
1A1EDC8 	6E 76 2D 76 61 72 73 93 
1A1EDD0 	A4 ED A1  1 5C 40 A0  1 
1A1EDD8 	18  6  0  0 
' noop is show-extra-env-vars

defer show-extra-env-var  ( name$ -- )
1A1EDDC 	 0 73 68 6F 
1A1EDE0 	77 2D 65 78 74 72 61 2D 
1A1EDE8 	65 6E 76 2D 76 61 72 92 
1A1EDF0 	D4 ED A1  1 5C 40 A0  1 
1A1EDF8 	1C  6  0  0 
: no-show-extra  ( name$ -- )  ." Unknown option: " type cr  ;
1A1EDFC 	 0  0 6E 6F 
1A1EE00 	2D 73 68 6F 77 2D 65 78 
1A1EE08 	74 72 61 8D F4 ED A1  1 
1A1EE10 	20 40 A0  1 20 7C A0  1 
1A1EE18 	10 55 6E 6B 6E 6F 77 6E 
1A1EE20 	20 6F 70 74 69 6F 6E 3A 
1A1EE28 	20  0  0  0  4 6C A0  1 
1A1EE30 	80 6D A0  1 58 46 A0  1 
' no-show-extra to show-extra-env-var

defer put-extra-env-var  ( value$ name$ -- )
1A1EE38 	 0  0 70 75 74 2D 65 78 
1A1EE40 	74 72 61 2D 65 6E 76 2D 
1A1EE48 	76 61 72 91 10 EE A1  1 
1A1EE50 	5C 40 A0  1 20  6  0  0 
: no-put-extra  ( value$ name$ -- )  no-show-extra 2drop  ;
1A1EE58 	 0  0  0 6E 6F 2D 70 75 
1A1EE60 	74 2D 65 78 74 72 61 8C 
1A1EE68 	50 EE A1  1 20 40 A0  1 
1A1EE70 	10 EE A1  1 AC 49 A0  1 
1A1EE78 	58 46 A0  1 
' no-put-extra to put-extra-env-var

defer get-env-var  ( name$ -- true | value$ false )
1A1EE7C 	67 65 74 2D 
1A1EE80 	65 6E 76 2D 76 61 72 8B 
1A1EE88 	6C EE A1  1 5C 40 A0  1 
1A1EE90 	24  6  0  0 
: no-get-env-var  ( name$ -- true )  2drop  true  ;
1A1EE94 	 0 6E 6F 2D 
1A1EE98 	67 65 74 2D 65 6E 76 2D 
1A1EEA0 	76 61 72 8E 8C EE A1  1 
1A1EEA8 	20 40 A0  1 AC 49 A0  1 
1A1EEB0 	 4 70 A0  1 58 46 A0  1 
' no-get-env-var to get-env-var

defer erase-user-env-vars  ( -- )
1A1EEB8 	65 72 61 73 65 2D 75 73 
1A1EEC0 	65 72 2D 65 6E 76 2D 76 
1A1EEC8 	61 72 73 93 A8 EE A1  1 
1A1EED0 	5C 40 A0  1 28  6  0  0 
' noop to erase-user-env-vars

: printenv-all  ( -- )
1A1EED8 	 0  0  0 70 72 69 6E 74 
1A1EEE0 	65 6E 76 2D 61 6C 6C 8C 
1A1EEE8 	D0 EE A1  1 20 40 A0  1 
   ." Variable Name"  value-column  ." Value"
1A1EEF0 	20 7C A0  1  D 56 61 72 
1A1EEF8 	69 61 62 6C 65 20 4E 61 
1A1EF00 	6D 65  0  0 F4 E8 A1  1 
1A1EF08 	20 7C A0  1  5 56 61 6C 
1A1EF10 	75 65  0  0 
   default-column ." Default Value" cr cr
1A1EF14 	 C E9 A1  1 
1A1EF18 	20 7C A0  1  D 44 65 66 
1A1EF20 	61 75 6C 74 20 56 61 6C 
1A1EF28 	75 65  0  0 80 6D A0  1 
1A1EF30 	80 6D A0  1 

   ['] options  follow
1A1EF34 	60 53 A0  1 
1A1EF38 	90 E7 A1  1 38 BC A0  1 
   begin  another?  while
1A1EF40 	68 BC A0  1 DC 41 A0  1 
1A1EF48 	54  0  0  0 
      exit?  if  drop exit  then
1A1EF4C 	34  D A1  1 
1A1EF50 	DC 41 A0  1  C  0  0  0 
1A1EF58 	30 49 A0  1 40 46 A0  1 
      dup name>string " name" $= if  \ Don't display the "name" property
1A1EF60 	40 49 A0  1 58 74 A0  1 
1A1EF68 	9C 53 A0  1  4 6E 61 6D 
1A1EF70 	65  0  0  0 88 8D A0  1 
1A1EF78 	DC 41 A0  1 10  0  0  0 
         drop
1A1EF80 	30 49 A0  1 
      else
1A1EF84 	C8 41 A0  1 
1A1EF88 	 C  0  0  0 
         name>  show-config-entry
1A1EF8C 	 8 74 A0  1 
1A1EF90 	88 EC A1  1 
      then
   repeat
1A1EF94 	C8 41 A0  1 
1A1EF98 	A8 FF FF FF 
   show-extra-env-vars
1A1EF9C 	D4 ED A1  1 
;
1A1EFA0 	58 46 A0  1 

: (printenv)  ( adr len -- )
1A1EFA4 	 0 28 70 72 
1A1EFA8 	69 6E 74 65 6E 76 29 8A 
1A1EFB0 	EC EE A1  1 20 40 A0  1 
   2dup  $find-option  if
1A1EFB8 	C0 49 A0  1 FC EB A1  1 
1A1EFC0 	DC 41 A0  1 18  0  0  0 
      nip nip show-current-value
1A1EFC8 	FC 46 A0  1 FC 46 A0  1 
1A1EFD0 	 4 ED A1  1 
   else
1A1EFD4 	C8 41 A0  1 
1A1EFD8 	 8  0  0  0 
      show-extra-env-var
1A1EFDC 	F4 ED A1  1 
   then
;
1A1EFE0 	58 46 A0  1 

headers

: set-default  \ name  ( -- )
1A1EFE4 	73 65 74 2D 
1A1EFE8 	64 65 66 61 75 6C 74 8B 
1A1EFF0 	B4 EF A1  1 20 40 A0  1 
   parse-word dup   if                              ( adr len )
1A1EFF8 	34 93 A0  1 40 49 A0  1 
1A1F000 	DC 41 A0  1 1C  0  0  0 
      find-option  if  do-set-default  then         ( )
1A1F008 	20 EC A1  1 DC 41 A0  1 
1A1F010 	 8  0  0  0 AC EB A1  1 
   else                                             ( adr len )
1A1F018 	C8 41 A0  1 30  0  0  0 
      2drop  ." Usage: set-default option-name" cr  ( )
1A1F020 	AC 49 A0  1 20 7C A0  1 
1A1F028 	1E 55 73 61 67 65 3A 20 
1A1F030 	73 65 74 2D 64 65 66 61 
1A1F038 	75 6C 74 20 6F 70 74 69 
1A1F040 	6F 6E 2D 6E 61 6D 65  0 
1A1F048 	80 6D A0  1 
   then                                             ( )
;
1A1F04C 	58 46 A0  1 
: set-defaults  ( -- )
1A1F050 	 0  0  0 73 65 74 2D 64 
1A1F058 	65 66 61 75 6C 74 73 8C 
1A1F060 	F4 EF A1  1 20 40 A0  1 
   ." Setting configuration variables to default values."  cr
1A1F068 	20 7C A0  1 32 53 65 74 
1A1F070 	74 69 6E 67 20 63 6F 6E 
1A1F078 	66 69 67 75 72 61 74 69 
1A1F080 	6F 6E 20 76 61 72 69 61 
1A1F088 	62 6C 65 73 20 74 6F 20 
1A1F090 	64 65 66 61 75 6C 74 20 
1A1F098 	76 61 6C 75 65 73 2E  0 
1A1F0A0 	80 6D A0  1 
   config-rw
1A1F0A4 	8C E8 A1  1 
   erase-user-env-vars
1A1F0A8 	D0 EE A1  1 
   ['] options  follow
1A1F0AC 	60 53 A0  1 
1A1F0B0 	90 E7 A1  1 38 BC A0  1 
   begin  another?  while
1A1F0B8 	68 BC A0  1 DC 41 A0  1 
1A1F0C0 	40  0  0  0 
      dup name>string  " name" $=  if  drop  else  name> do-set-default  then
1A1F0C4 	40 49 A0  1 
1A1F0C8 	58 74 A0  1 9C 53 A0  1 
1A1F0D0 	 4 6E 61 6D 65  0  0  0 
1A1F0D8 	88 8D A0  1 DC 41 A0  1 
1A1F0E0 	10  0  0  0 30 49 A0  1 
1A1F0E8 	C8 41 A0  1  C  0  0  0 
1A1F0F0 	 8 74 A0  1 AC EB A1  1 
   repeat
1A1F0F8 	C8 41 A0  1 BC FF FF FF 
   config-ro
1A1F100 	A4 E8 A1  1 
;
1A1F104 	58 46 A0  1 

: ofw-$getenv  ( name$ -- true | value$ false )
1A1F108 	6F 66 77 2D 24 67 65 74 
1A1F110 	65 6E 76 8B 64 F0 A1  1 
1A1F118 	20 40 A0  1 
   2dup  $find-option  if                 ( name$ xt )
1A1F11C 	C0 49 A0  1 
1A1F120 	FC EB A1  1 DC 41 A0  1 
1A1F128 	30  0  0  0 
      nip nip                             ( xt )
1A1F12C 	FC 46 A0  1 
1A1F130 	FC 46 A0  1 
      >r  r@ get  r> decode -null false   ( prop$ false )
1A1F134 	BC 45 A0  1 
1A1F138 	E4 45 A0  1 D4 E7 A1  1 
1A1F140 	D0 45 A0  1  8 E8 A1  1 
1A1F148 	88 E9 A1  1 18 70 A0  1 
   else                                   ( name$ )
1A1F150 	C8 41 A0  1  8  0  0  0 
      get-env-var                         ( true | prop$ false )
1A1F158 	8C EE A1  1 
   then
   \ Remove the trailing null if there is one; the result from this
   \ word is a Forth string, not a prop-encoded array
   if  true  else  -null false  then
1A1F15C 	DC 41 A0  1 
1A1F160 	10  0  0  0  4 70 A0  1 
1A1F168 	C8 41 A0  1  C  0  0  0 
1A1F170 	88 E9 A1  1 18 70 A0  1 
;
1A1F178 	58 46 A0  1 

: printenv  \ [ option-name ]  ( -- )
1A1F17C 	 0  0  0 70 
1A1F180 	72 69 6E 74 65 6E 76 88 
1A1F188 	18 F1 A1  1 20 40 A0  1 
   parse-word dup  if  (printenv)  else  2drop printenv-all  then
1A1F190 	34 93 A0  1 40 49 A0  1 
1A1F198 	DC 41 A0  1 10  0  0  0 
1A1F1A0 	B4 EF A1  1 C8 41 A0  1 
1A1F1A8 	 C  0  0  0 AC 49 A0  1 
1A1F1B0 	EC EE A1  1 
;
1A1F1B4 	58 46 A0  1 

: $setenv  ( value$ name$ -- )
1A1F1B8 	24 73 65 74 65 6E 76 87 
1A1F1C0 	8C F1 A1  1 20 40 A0  1 
   2dup $find-option  if                             ( value$ name$ xt )
1A1F1C8 	C0 49 A0  1 FC EB A1  1 
1A1F1D0 	DC 41 A0  1 78  0  0  0 
      nip nip
1A1F1D8 	FC 46 A0  1 FC 46 A0  1 

      >r r@  encode  if
1A1F1E0 	BC 45 A0  1 E4 45 A0  1 
1A1F1E8 	24 E8 A1  1 DC 41 A0  1 
1A1F1F0 	44  0  0  0 
         r> drop  ." Invalid value; previous value retained." cr
1A1F1F4 	D0 45 A0  1 
1A1F1F8 	30 49 A0  1 20 7C A0  1 
1A1F200 	27 49 6E 76 61 6C 69 64 
1A1F208 	20 76 61 6C 75 65 3B 20 
1A1F210 	70 72 65 76 69 6F 75 73 
1A1F218 	20 76 61 6C 75 65 20 72 
1A1F220 	65 74 61 69 6E 65 64 2E 
1A1F228 	 0  0  0  0 80 6D A0  1 
         exit
1A1F230 	40 46 A0  1 
      then                                              ( value )

      \ We've passed all the error checks, now set the option value.

      r@ set  r> show-current-value                           ( )
1A1F234 	E4 45 A0  1 
1A1F238 	EC E7 A1  1 D0 45 A0  1 
1A1F240 	 4 ED A1  1 
   else
1A1F244 	C8 41 A0  1 
1A1F248 	 8  0  0  0 
      put-extra-env-var
1A1F24C 	50 EE A1  1 
   then
;
1A1F250 	58 46 A0  1 
: setenv  \ name value  ( -- )
1A1F254 	 0 73 65 74 
1A1F258 	65 6E 76 86 C4 F1 A1  1 
1A1F260 	20 40 A0  1 
   parse-word -1 parse strip-blanks  2swap       ( value$ name$ )
1A1F264 	34 93 A0  1 
1A1F268 	58 41 A0  1 FF FF FF FF 
1A1F270 	E4 85 A0  1 2C  F A1  1 
1A1F278 	F4 49 A0  1 
   2 pick 0=  over 0=  or  if                    ( value$ name$ )
1A1F27C 	90 6F A0  1 
1A1F280 	 C 4A A0  1 24 47 A0  1 
1A1F288 	54 49 A0  1 24 47 A0  1 
1A1F290 	70 44 A0  1 DC 41 A0  1 
1A1F298 	3C  0  0  0 
      2drop 2drop                                ( )
1A1F29C 	AC 49 A0  1 
1A1F2A0 	AC 49 A0  1 
      ." Usage: setenv option-name value" cr     ( )
1A1F2A4 	20 7C A0  1 
1A1F2A8 	1F 55 73 61 67 65 3A 20 
1A1F2B0 	73 65 74 65 6E 76 20 6F 
1A1F2B8 	70 74 69 6F 6E 2D 6E 61 
1A1F2C0 	6D 65 20 76 61 6C 75 65 
1A1F2C8 	 0  0  0  0 80 6D A0  1 
      exit                                       ( )
1A1F2D0 	40 46 A0  1 
   then                                          ( value$ name$ )
   $setenv                                       ( )
1A1F2D4 	C4 F1 A1  1 
;
1A1F2D8 	58 46 A0  1 

defer $unsetenv  ( name$ -- )   ' 2drop to $unsetenv
1A1F2DC 	 0  0 24 75 
1A1F2E0 	6E 73 65 74 65 6E 76 89 
1A1F2E8 	60 F2 A1  1 5C 40 A0  1 
1A1F2F0 	2C  6  0  0 
: unsetenv  ( "name" -- )  safe-parse-word $unsetenv  ;
1A1F2F4 	 0  0  0 75 
1A1F2F8 	6E 73 65 74 65 6E 76 88 
1A1F300 	EC F2 A1  1 20 40 A0  1 
1A1F308 	88 93 A0  1 EC F2 A1  1 
1A1F310 	58 46 A0  1 

: show  \ name  ( -- )
1A1F314 	 0  0  0 73 
1A1F318 	68 6F 77 84  4 F3 A1  1 
1A1F320 	20 40 A0  1 
   parse-word dup  if
1A1F324 	34 93 A0  1 
1A1F328 	40 49 A0  1 DC 41 A0  1 
1A1F330 	10  0  0  0 
      (printenv)
1A1F334 	B4 EF A1  1 
   else
1A1F338 	C8 41 A0  1 2C  0  0  0 
      2drop ." Usage: show option-name" cr
1A1F340 	AC 49 A0  1 20 7C A0  1 
1A1F348 	17 55 73 61 67 65 3A 20 
1A1F350 	73 68 6F 77 20 6F 70 74 
1A1F358 	69 6F 6E 2D 6E 61 6D 65 
1A1F360 	 0  0  0  0 80 6D A0  1 
   then
;
1A1F368 	58 46 A0  1 
: list  ( addr count -- )  \ a version of "type" used for displaying nvramrc
1A1F36C 	 0  0  0 6C 
1A1F370 	69 73 74 84 20 F3 A1  1 
1A1F378 	20 40 A0  1 
   bounds  ?do
1A1F37C 	F0 6D A0  1 
1A1F380 	50 42 A0  1 44  0  0  0 
      i c@ newline =  if  cr  exit? ?leave  else  i c@ emit  then
1A1F388 	B4 42 A0  1 C4 4C A0  1 
1A1F390 	A8 71 A0  1 24 48 A0  1 
1A1F398 	DC 41 A0  1 18  0  0  0 
1A1F3A0 	80 6D A0  1 34  D A1  1 
1A1F3A8 	34 43 A0  1 C8 41 A0  1 
1A1F3B0 	10  0  0  0 B4 42 A0  1 
1A1F3B8 	C4 4C A0  1 2C 6C A0  1 
   loop
1A1F3C0 	F8 41 A0  1 C4 FF FF FF 
;
1A1F3C8 	58 46 A0  1 

headerless
h# 2000 constant /$edit-max
1A1F3CC 	 0 2F 24 65 
1A1F3D0 	64 69 74 2D 6D 61 78 8A 
1A1F3D8 	78 F3 A1  1 68 40 A0  1 
1A1F3E0 	 0 20  0  0 
0 value $edit-buf
1A1F3E4 	 0  0 24 65 
1A1F3E8 	64 69 74 2D 62 75 66 89 
1A1F3F0 	DC F3 A1  1 50 40 A0  1 
1A1F3F8 	30  6  0  0 
: .edit-msg  ( -- )   ." Type Enter or Return to finish editing" cr  ;
1A1F3FC 	 0  0 2E 65 
1A1F400 	64 69 74 2D 6D 73 67 89 
1A1F408 	F4 F3 A1  1 20 40 A0  1 
1A1F410 	20 7C A0  1 26 54 79 70 
1A1F418 	65 20 45 6E 74 65 72 20 
1A1F420 	6F 72 20 52 65 74 75 72 
1A1F428 	6E 20 74 6F 20 66 69 6E 
1A1F430 	69 73 68 20 65 64 69 74 
1A1F438 	69 6E 67  0 80 6D A0  1 
1A1F440 	58 46 A0  1 
: $edit  ( default$ -- edited$ )
1A1F444 	 0  0 24 65 
1A1F448 	64 69 74 85  C F4 A1  1 
1A1F450 	20 40 A0  1 
   $edit-buf  0=  if  /$edit-max alloc-mem to $edit-buf  then   ( default$ )
1A1F454 	F4 F3 A1  1 
1A1F458 	24 47 A0  1 DC 41 A0  1 
1A1F460 	14  0  0  0 DC F3 A1  1 
1A1F468 	F0 6C A0  1 B8 40 A0  1 
1A1F470 	F4 F3 A1  1 
   $edit-buf /$edit-max erase           ( default$ )
1A1F474 	F4 F3 A1  1 
1A1F478 	DC F3 A1  1 F0 72 A0  1 
   tuck  $edit-buf swap  move           ( len )
1A1F480 	E8 46 A0  1 F4 F3 A1  1 
1A1F488 	68 49 A0  1 F4 4A A0  1 
   $edit-buf swap /$edit-max edit-line  ( len' )
1A1F490 	F4 F3 A1  1 68 49 A0  1 
1A1F498 	DC F3 A1  1 40 5F A1  1 
   $edit-buf swap   
1A1F4A0 	F4 F3 A1  1 68 49 A0  1 
;
1A1F4A8 	58 46 A0  1 
: free-edit-buf  ( -- )
1A1F4AC 	 0  0 66 72 
1A1F4B0 	65 65 2D 65 64 69 74 2D 
1A1F4B8 	62 75 66 8D 50 F4 A1  1 
1A1F4C0 	20 40 A0  1 
   $edit-buf  if  $edit-buf /$edit-max free-mem  0 to $edit-buf  then 
1A1F4C4 	F4 F3 A1  1 
1A1F4C8 	DC 41 A0  1 1C  0  0  0 
1A1F4D0 	F4 F3 A1  1 DC F3 A1  1 
1A1F4D8 	 8 6D A0  1 70 6F A0  1 
1A1F4E0 	B8 40 A0  1 F4 F3 A1  1 
;
1A1F4E8 	58 46 A0  1 
headers
: $editenv  ( name$ -- )
1A1F4EC 	 0  0  0 24 
1A1F4F0 	65 64 69 74 65 6E 76 88 
1A1F4F8 	C0 F4 A1  1 20 40 A0  1 
   2dup  $getenv  if  null$  then            ( name$ value$ )
1A1F500 	C0 49 A0  1 48 6D A0  1 
1A1F508 	DC 41 A0  1  8  0  0  0 
1A1F510 	7C E1 A1  1 

   .edit-msg $edit                           ( name$ value$' )
1A1F514 	 C F4 A1  1 
1A1F518 	50 F4 A1  1 

   \ If the new value is empty and the variable can be deleted,
   \ offer the user the opportunity to do so.
   dup  0=  if                               ( name$ value$ )
1A1F51C 	40 49 A0  1 
1A1F520 	24 47 A0  1 DC 41 A0  1 
1A1F528 	54  0  0  0 
      2over  $find-option  if                ( name$ value$ xt )
1A1F52C 	D8 49 A0  1 
1A1F530 	FC EB A1  1 DC 41 A0  1 
1A1F538 	10  0  0  0 
         drop                                ( name$ value$ )
1A1F53C 	30 49 A0  1 
      else                                   ( name$ value$ )
1A1F540 	C8 41 A0  1 38  0  0  0 
         " Delete variable"  confirmed?  if  ( name$ value$ )
1A1F548 	9C 53 A0  1  F 44 65 6C 
1A1F550 	65 74 65 20 76 61 72 69 
1A1F558 	61 62 6C 65  0  0  0  0 
1A1F560 	8C 10 A1  1 DC 41 A0  1 
1A1F568 	14  0  0  0 
            2drop  $unsetenv                 ( )
1A1F56C 	AC 49 A0  1 
1A1F570 	EC F2 A1  1 
            free-edit-buf                    ( )
1A1F574 	C0 F4 A1  1 
            exit
1A1F578 	40 46 A0  1 
         then                                ( name$ value$ )
      then                                   ( name$ value$ )
   then                                      ( name$ value$ )

   " Update configuration variable" confirmed?  if  ( name$ value$ )
1A1F57C 	9C 53 A0  1 
1A1F580 	1D 55 70 64 61 74 65 20 
1A1F588 	63 6F 6E 66 69 67 75 72 
1A1F590 	61 74 69 6F 6E 20 76 61 
1A1F598 	72 69 61 62 6C 65  0  0 
1A1F5A0 	8C 10 A1  1 DC 41 A0  1 
1A1F5A8 	14  0  0  0 
      2swap $setenv                                 ( )
1A1F5AC 	F4 49 A0  1 
1A1F5B0 	C4 F1 A1  1 
   else                                             ( name$ value$ )
1A1F5B4 	C8 41 A0  1 
1A1F5B8 	 8  0  0  0 
      4drop                                         ( )
1A1F5BC 	38 53 A0  1 
   then                                             ( )

   free-edit-buf
1A1F5C0 	C0 F4 A1  1 
;
1A1F5C4 	58 46 A0  1 
: editenv  ( "name" -- )  safe-parse-word $editenv  ;
1A1F5C8 	65 64 69 74 65 6E 76 87 
1A1F5D0 	FC F4 A1  1 20 40 A0  1 
1A1F5D8 	88 93 A0  1 FC F4 A1  1 
1A1F5E0 	58 46 A0  1 


\ From propenc.fth
purpose: Property encoding and decoding primitives

\ External encoding and decoding for primitive data types

\ Encode integers into a byte array, suitable for passing to Unix.
\ Decode integers from a byte array.

decimal
headers
\ Merge two property-encoded arrays into a single array
\ Assumes that adr0+len0 == adr1
: encode+    ( adr0 len0 adr1 len1 -- adr0 len0+len1 )  nip +  ;
1A1F5E4 	65 6E 63 6F 
1A1F5E8 	64 65 2B 87 D4 F5 A1  1 
1A1F5F0 	20 40 A0  1 FC 46 A0  1 
1A1F5F8 	 4 45 A0  1 58 46 A0  1 


\ Copy a byte array into the dictionary.
: encode-bytes  ( adr len -- adr' len )
1A1F600 	 0  0  0 65 6E 63 6F 64 
1A1F608 	65 2D 62 79 74 65 73 8C 
1A1F610 	F0 F5 A1  1 20 40 A0  1 
   here >r                      ( adr len )
1A1F618 	70 54 A0  1 BC 45 A0  1 
   bounds  ?do  i c@ c,  loop   ( rs: start )
1A1F620 	F0 6D A0  1 50 42 A0  1 
1A1F628 	18  0  0  0 B4 42 A0  1 
1A1F630 	C4 4C A0  1 B8 55 A0  1 
1A1F638 	F8 41 A0  1 F0 FF FF FF 
   r> here over -               ( adr' len )
1A1F640 	D0 45 A0  1 70 54 A0  1 
1A1F648 	54 49 A0  1 18 45 A0  1 
;
1A1F650 	58 46 A0  1 

: decode-bytes  ( adr1 len1  len2  -- adr1+len2 len1-len2  adr1 len2 )
1A1F654 	 0  0  0 64 
1A1F658 	65 63 6F 64 65 2D 62 79 
1A1F660 	74 65 73 8C 14 F6 A1  1 
1A1F668 	20 40 A0  1 
   >r  over swap r@ /string  rot r>
1A1F66C 	BC 45 A0  1 
1A1F670 	54 49 A0  1 68 49 A0  1 
1A1F678 	E4 45 A0  1 3C 85 A0  1 
1A1F680 	7C 49 A0  1 D0 45 A0  1 
;
1A1F688 	58 46 A0  1 


\ Copy a string to the dictionary, and add a null byte at the end
: encode-string  ( adr len -- adr' len+1 )
1A1F68C 	 0  0 65 6E 
1A1F690 	63 6F 64 65 2D 73 74 72 
1A1F698 	69 6E 67 8D 68 F6 A1  1 
1A1F6A0 	20 40 A0  1 
   here >r                             ( adr len )
1A1F6A4 	70 54 A0  1 
1A1F6A8 	BC 45 A0  1 
   bounds  ?do  i c@ c,  loop   0 c,   ( )  ( rs: start )
1A1F6AC 	F0 6D A0  1 
1A1F6B0 	50 42 A0  1 18  0  0  0 
1A1F6B8 	B4 42 A0  1 C4 4C A0  1 
1A1F6C0 	B8 55 A0  1 F8 41 A0  1 
1A1F6C8 	F0 FF FF FF 70 6F A0  1 
1A1F6D0 	B8 55 A0  1 
   r> here over -                      ( adr' len+1 )
1A1F6D4 	D0 45 A0  1 
1A1F6D8 	70 54 A0  1 54 49 A0  1 
1A1F6E0 	18 45 A0  1 
;
1A1F6E4 	58 46 A0  1 

\ adrb,lenb is the initial null-terminated string from the argument string.
\ lenb does not include the null.  adra lena is the remainder string.
: decode-string  ( adr len -- adra lena adrb lenb )
1A1F6E8 	 0  0 64 65 63 6F 64 65 
1A1F6F0 	2D 73 74 72 69 6E 67 8D 
1A1F6F8 	A0 F6 A1  1 20 40 A0  1 
   0 left-parse-string
1A1F700 	70 6F A0  1 44 D7 A0  1 
;
1A1F708 	58 46 A0  1 
: get-encoded-string  ( adr len -- adr len-1 )  1-  ;
1A1F70C 	 0 67 65 74 
1A1F710 	2D 65 6E 63 6F 64 65 64 
1A1F718 	2D 73 74 72 69 6E 67 92 
1A1F720 	FC F6 A1  1 20 40 A0  1 
1A1F728 	54 4B A0  1 58 46 A0  1 

\ Copy an int as 4 bytes to the dictionary
: encode-int  ( i -- adr len )   here  swap be-l,  /l  ;
1A1F730 	 0 65 6E 63 6F 64 65 2D 
1A1F738 	69 6E 74 8A 24 F7 A1  1 
1A1F740 	20 40 A0  1 70 54 A0  1 
1A1F748 	68 49 A0  1 48 7A A1  1 
1A1F750 	30 51 A0  1 58 46 A0  1 

: decode-int  ( adr len -- adr' len' n )
1A1F758 	 0 64 65 63 6F 64 65 2D 
1A1F760 	69 6E 74 8A 40 F7 A1  1 
1A1F768 	20 40 A0  1 
   over be-l@ >r  /l /string  r> l->n
1A1F76C 	54 49 A0  1 
1A1F770 	30 FC A0  1 BC 45 A0  1 
1A1F778 	30 51 A0  1 3C 85 A0  1 
1A1F780 	D0 45 A0  1 88 61 A0  1 
;
1A1F788 	58 46 A0  1 
: get-encoded-int  ( adr len -- n )  drop be-l@  ;
1A1F78C 	67 65 74 2D 
1A1F790 	65 6E 63 6F 64 65 64 2D 
1A1F798 	69 6E 74 8F 68 F7 A1  1 
1A1F7A0 	20 40 A0  1 30 49 A0  1 
1A1F7A8 	30 FC A0  1 58 46 A0  1 

: encode-cell  ( n -- adr len )   here  swap be-n,  /n  ;
1A1F7B0 	65 6E 63 6F 64 65 2D 63 
1A1F7B8 	65 6C 6C 8B A0 F7 A1  1 
1A1F7C0 	20 40 A0  1 70 54 A0  1 
1A1F7C8 	68 49 A0  1 E0 FC A0  1 
1A1F7D0 	40 51 A0  1 58 46 A0  1 

: decode-cell  ( adr len -- adr' len' n )
1A1F7D8 	64 65 63 6F 64 65 2D 63 
1A1F7E0 	65 6C 6C 8B C0 F7 A1  1 
1A1F7E8 	20 40 A0  1 
   over be-x@ >r  /x /string  r>
1A1F7EC 	54 49 A0  1 
1A1F7F0 	3C FD A0  1 BC 45 A0  1 
1A1F7F8 	 0 FD A0  1 3C 85 A0  1 
1A1F800 	D0 45 A0  1 
;
1A1F804 	58 46 A0  1 
: get-encoded-cell  ( adr len -- n )  drop be-n@  ;
1A1F808 	 0  0  0 67 65 74 2D 65 
1A1F810 	6E 63 6F 64 65 64 2D 63 
1A1F818 	65 6C 6C 90 E8 F7 A1  1 
1A1F820 	20 40 A0  1 30 49 A0  1 
1A1F828 	30 FC A0  1 58 46 A0  1 
headers

\ From devtree.fth
purpose: 

headers

defer voc>phandle ' noop to voc>phandle
1A1F830 	76 6F 63 3E 70 68 61 6E 
1A1F838 	64 6C 65 8B 20 F8 A1  1 
1A1F840 	5C 40 A0  1 34  6  0  0 
defer phandle>voc ' noop to phandle>voc
1A1F848 	70 68 61 6E 64 6C 65 3E 
1A1F850 	76 6F 63 8B 40 F8 A1  1 
1A1F858 	5C 40 A0  1 38  6  0  0 
defer dt-null     ' null to dt-null
1A1F860 	64 74 2D 6E 75 6C 6C 87 
1A1F868 	58 F8 A1  1 5C 40 A0  1 
1A1F870 	3C  6  0  0 

\ : : :  lastacf .name cr ;

: rel-voc>phandle  ( voc -- ph )  origin -  ;  ' rel-voc>phandle to voc>phandle
1A1F874 	72 65 6C 2D 
1A1F878 	76 6F 63 3E 70 68 61 6E 
1A1F880 	64 6C 65 8F 6C F8 A1  1 
1A1F888 	20 40 A0  1 50 55 A0  1 
1A1F890 	18 45 A0  1 58 46 A0  1 
: rel-phandle>voc  ( ph -- voc )  origin +  ;  ' rel-phandle>voc to phandle>voc
1A1F898 	72 65 6C 2D 70 68 61 6E 
1A1F8A0 	64 6C 65 3E 76 6F 63 8F 
1A1F8A8 	88 F8 A1  1 20 40 A0  1 
1A1F8B0 	50 55 A0  1  4 45 A0  1 
1A1F8B8 	58 46 A0  1 
' 0 to dt-null

\ TODO
\ Don't use the system search order; use a private stack
\ $find searches through the private stack
\ Change names back from "regprop" to "reg", etc.
\ Either implement a true breadth-first search or don't specify it.

: cdev drop context token@  voc>phandle  ;
1A1F8BC 	 0  0  0 63 
1A1F8C0 	64 65 76 84 AC F8 A1  1 
1A1F8C8 	20 40 A0  1 30 49 A0  1 
1A1F8D0 	DC A3 A0  1  C 54 A0  1 
1A1F8D8 	40 F8 A1  1 58 46 A0  1 
: devc drop phandle>voc  context token!  definitions  ;
1A1F8E0 	 0  0  0 64 65 76 63 84 
1A1F8E8 	C8 F8 A1  1 20 40 A0  1 
1A1F8F0 	30 49 A0  1 58 F8 A1  1 
1A1F8F8 	DC A3 A0  1 20 54 A0  1 
1A1F900 	2C C4 A0  1 58 46 A0  1 
2 actions
1A1F908 	20 F9 A1  1  2  0  0  0 
action: cdev ;
1A1F910 	90 90 90 E8 64 47 FE FF 
1A1F918 	C8 F8 A1  1 58 46 A0  1 
action: devc ;
1A1F920 	20 40 A0  1 EC F8 A1  1 
1A1F928 	58 46 A0  1 
create current-device  use-actions
1A1F92C 	 0 63 75 72 
1A1F930 	72 65 6E 74 2D 64 65 76 
1A1F938 	69 63 65 8E EC F8 A1  1 
1A1F940 	10 F9 A1  1 

action-adr-t to ^current-device

headerless
: ufield  \ name  ( offset size -- offset' )
1A1F944 	 0 75 66 69 
1A1F948 	65 6C 64 86 40 F9 A1  1 
1A1F950 	20 40 A0  1 
   create  over ,   +
1A1F954 	A8 A2 A0  1 
1A1F958 	54 49 A0  1 98 55 A0  1 
1A1F960 	 4 45 A0  1 
   does>  @  current-device  phandle>voc  >body >user +
1A1F964 	50 A3 A0  1 
1A1F968 	90 90 90 E8  C 47 FE FF 
1A1F970 	5C 4C A0  1 40 F9 A1  1 
1A1F978 	58 F8 A1  1 E4 59 A0  1 
1A1F980 	C8 74 A0  1  4 45 A0  1 
;
1A1F988 	58 46 A0  1 

\ Notes for a more abstract searching mechanism:
\ Instead of the child and peer links in the device node, packages
\ with children have "search", "create", and "enumerate" methods.
\ To search a level, call that package's search method.  Those
\ methods probably need to work from a phandle, not an ihandle.

: unaligned-ualloc  ( size -- user# )
1A1F98C 	 0  0  0 75 
1A1F990 	6E 61 6C 69 67 6E 65 64 
1A1F998 	2D 75 61 6C 6C 6F 63 90 
1A1F9A0 	50 F9 A1  1 20 40 A0  1 
   #user @  dup user-size > abort" User area used up!"  ( size user# )
1A1F9A8 	7C 66 A0  1 5C 4C A0  1 
1A1F9B0 	40 49 A0  1 E8 65 A0  1 
1A1F9B8 	 4 48 A0  1  8 81 A0  1 
1A1F9C0 	12 55 73 65 72 20 61 72 
1A1F9C8 	65 61 20 75 73 65 64 20 
1A1F9D0 	75 70 21  0 
   swap #user +!  ( user# )
1A1F9D4 	68 49 A0  1 
1A1F9D8 	7C 66 A0  1  C 4C A0  1 
;
1A1F9E0 	58 46 A0  1 

struct  ( devnode )
/link #threads *  ufield  'threads	\ Package methods
1A1F9E4 	 0  0  0 27 
1A1F9E8 	74 68 72 65 61 64 73 88 
1A1F9F0 	A4 F9 A1  1 68 F9 A1  1 
1A1F9F8 	 0  0  0  0 
dup				\ The following fields will be "ualloc"ed
   /token  ufield  'child	\ Pointer to first child
1A1F9FC 	 0 27 63 68 
1A1FA00 	69 6C 64 86 F4 F9 A1  1 
1A1FA08 	68 F9 A1  1  4  0  0  0 
   /token  ufield  'peer	\ Pointer to next peer
1A1FA10 	 0  0 27 70 65 65 72 85 
1A1FA18 	 8 FA A1  1 68 F9 A1  1 
1A1FA20 	 8  0  0  0 
   /token  ufield  'properties	\ Pointer to properties vocabulary
1A1FA24 	27 70 72 6F 
1A1FA28 	70 65 72 74 69 65 73 8B 
1A1FA30 	1C FA A1  1 68 F9 A1  1 
1A1FA38 	 C  0  0  0 
   /n      ufield  '#adr-cells	\ Size of a parent address
1A1FA3C 	27 23 61 64 
1A1FA40 	72 2D 63 65 6C 6C 73 8B 
1A1FA48 	34 FA A1  1 68 F9 A1  1 
1A1FA50 	10  0  0  0 
   /n      ufield  '#buffers
1A1FA54 	 0  0 27 23 
1A1FA58 	62 75 66 66 65 72 73 89 
1A1FA60 	4C FA A1  1 68 F9 A1  1 
1A1FA68 	14  0  0  0 
   /n      ufield  '#values
1A1FA6C 	 0  0  0 27 
1A1FA70 	23 76 61 6C 75 65 73 88 
1A1FA78 	64 FA A1  1 68 F9 A1  1 
1A1FA80 	18  0  0  0 
   /token  ufield  'values
1A1FA84 	27 76 61 6C 
1A1FA88 	75 65 73 87 7C FA A1  1 
1A1FA90 	68 F9 A1  1 1C  0  0  0 
( starting-offset ending-offset )  swap -  ( size-to-ualloc )
constant /devnode-extra
1A1FA98 	 0 2F 64 65 76 6E 6F 64 
1A1FAA0 	65 2D 65 78 74 72 61 8E 
1A1FAA8 	90 FA A1  1 68 40 A0  1 
1A1FAB0 	1C  0  0  0 

headers
: >parent  ( node -- parent-node )  phandle>voc >voc-link  a@ voc>phandle  ;
1A1FAB4 	3E 70 61 72 
1A1FAB8 	65 6E 74 87 AC FA A1  1 
1A1FAC0 	20 40 A0  1 58 F8 A1  1 
1A1FAC8 	50 B6 A0  1 88 58 A0  1 
1A1FAD0 	40 F8 A1  1 58 46 A0  1 
: parent-device  ( -- parent-node )  current-device >parent  ;
1A1FAD8 	 0  0 70 61 72 65 6E 74 
1A1FAE0 	2D 64 65 76 69 63 65 8D 
1A1FAE8 	C0 FA A1  1 20 40 A0  1 
1A1FAF0 	40 F9 A1  1 C0 FA A1  1 
1A1FAF8 	58 46 A0  1 

: (select-package)  ( phandle -- )  phandle>voc execute  ;
1A1FAFC 	 0  0  0 28 
1A1FB00 	73 65 6C 65 63 74 2D 70 
1A1FB08 	61 63 6B 61 67 65 29 90 
1A1FB10 	EC FA A1  1 20 40 A0  1 
1A1FB18 	58 F8 A1  1 98 41 A0  1 
1A1FB20 	58 46 A0  1 
: (push-package)  ( phandle -- )  also (select-package)  ;
1A1FB24 	 0 28 70 75 
1A1FB28 	73 68 2D 70 61 63 6B 61 
1A1FB30 	67 65 29 8E 14 FB A1  1 
1A1FB38 	20 40 A0  1 C8 C1 A0  1 
1A1FB40 	14 FB A1  1 58 46 A0  1 
: (pop-package)  ( phandle -- )  previous  ;
1A1FB48 	 0  0 28 70 6F 70 2D 70 
1A1FB50 	61 63 6B 61 67 65 29 8D 
1A1FB58 	38 FB A1  1 20 40 A0  1 
1A1FB60 	E4 C3 A0  1 58 46 A0  1 
: push-package  ( phandle -- )
1A1FB68 	 0  0  0 70 75 73 68 2D 
1A1FB70 	70 61 63 6B 61 67 65 8C 
1A1FB78 	5C FB A1  1 20 40 A0  1 
   dup  0=  if  ." Attempting to push null package!!!" abort  then
1A1FB80 	40 49 A0  1 24 47 A0  1 
1A1FB88 	DC 41 A0  1 30  0  0  0 
1A1FB90 	20 7C A0  1 22 41 74 74 
1A1FB98 	65 6D 70 74 69 6E 67 20 
1A1FBA0 	74 6F 20 70 75 73 68 20 
1A1FBA8 	6E 75 6C 6C 20 70 61 63 
1A1FBB0 	6B 61 67 65 21 21 21  0 
1A1FBB8 	28 91 A0  1 
   (push-package)  definitions
1A1FBBC 	38 FB A1  1 
1A1FBC0 	2C C4 A0  1 
;
1A1FBC4 	58 46 A0  1 
: pop-package  ( -- )  (pop-package) definitions  ;
1A1FBC8 	70 6F 70 2D 70 61 63 6B 
1A1FBD0 	61 67 65 8B 7C FB A1  1 
1A1FBD8 	20 40 A0  1 5C FB A1  1 
1A1FBE0 	2C C4 A0  1 58 46 A0  1 
: push-device  ( phandle -- )  to current-device  ;
1A1FBE8 	70 75 73 68 2D 64 65 76 
1A1FBF0 	69 63 65 8B D8 FB A1  1 
1A1FBF8 	20 40 A0  1 48 B8 A1  1 
1A1FC00 	40 F9 A1  1 58 46 A0  1 

: pop-device  ( -- )
1A1FC08 	 0 70 6F 70 2D 64 65 76 
1A1FC10 	69 63 65 8A F8 FB A1  1 
1A1FC18 	20 40 A0  1 
   parent-device                     ( parent-phandle )
1A1FC1C 	EC FA A1  1 
   dup dt-null <>  if  push-device  else  drop  then
1A1FC20 	40 49 A0  1 6C F8 A1  1 
1A1FC28 	44 48 A0  1 DC 41 A0  1 
1A1FC30 	10  0  0  0 F8 FB A1  1 
1A1FC38 	C8 41 A0  1  8  0  0  0 
1A1FC40 	30 49 A0  1 
\    non-null?  if  push-device  then
;
1A1FC44 	58 46 A0  1 

\ Each package instance has its own private data storage area.
\ The data creation words "value", "variable", and "buffer:",
\ when used during compilation of a package, allocate memory
\ relative to a base pointer.  The package definition includes the
\ initial values for the words created with "value" and "variable".
\ When a package instance is created, memory is allocated for the
\ package's data and the portion used for values and variables is
\ initialized from the values stored in the package definition.
\
\ While the package is being defined (i.e. its code is being compiled),
\ a "dummy" instance is created with space for data, so that
\ data words may be used as soon as they are created.  The "dummy"
\ instance data area is given a "generous" default size (for 100 * cellsize
\ bytes of initialized data, 700 * cellsize for buffers).
\ Hopefully this won't be exceeded.

headerless
variable package-level  package-level off
1A1FC48 	 0  0 70 61 63 6B 61 67 
1A1FC50 	65 2D 6C 65 76 65 6C 8D 
1A1FC58 	18 FC A1  1 48 40 A0  1 
1A1FC60 	40  6  0  0 
variable next-is-package  next-is-package off
1A1FC64 	6E 65 78 74 
1A1FC68 	2D 69 73 2D 70 61 63 6B 
1A1FC70 	61 67 65 8F 5C FC A1  1 
1A1FC78 	48 40 A0  1 44  6  0  0 
variable next-is-instance  next-is-instance off
1A1FC80 	 0  0  0 6E 65 78 74 2D 
1A1FC88 	69 73 2D 69 6E 73 74 61 
1A1FC90 	6E 63 65 90 78 FC A1  1 
1A1FC98 	48 40 A0  1 48  6  0  0 
: instance?  ( -- flag )
1A1FCA0 	 0  0 69 6E 73 74 61 6E 
1A1FCA8 	63 65 3F 89 98 FC A1  1 
1A1FCB0 	20 40 A0  1 
   package-level @ 0<>  next-is-instance @  and
1A1FCB4 	5C FC A1  1 
1A1FCB8 	5C 4C A0  1 44 47 A0  1 
1A1FCC0 	98 FC A1  1 5C 4C A0  1 
1A1FCC8 	5C 44 A0  1 
   next-is-instance off
1A1FCCC 	98 FC A1  1 
1A1FCD0 	F8 4B A0  1 
;
1A1FCD4 	58 46 A0  1 
: package?  ( -- flag )
1A1FCD8 	 0  0  0 70 61 63 6B 61 
1A1FCE0 	67 65 3F 88 B0 FC A1  1 
1A1FCE8 	20 40 A0  1 
   package-level @ 0<>  next-is-package @  and
1A1FCEC 	5C FC A1  1 
1A1FCF0 	5C 4C A0  1 44 47 A0  1 
1A1FCF8 	78 FC A1  1 5C 4C A0  1 
1A1FD00 	5C 44 A0  1 
   next-is-package off
1A1FD04 	78 FC A1  1 
1A1FD08 	F8 4B A0  1 
;
1A1FD0C 	58 46 A0  1 
headers
: instance  ( -- )  next-is-instance on  ;
1A1FD10 	 0  0  0 69 6E 73 74 61 
1A1FD18 	6E 63 65 88 E8 FC A1  1 
1A1FD20 	20 40 A0  1 98 FC A1  1 
1A1FD28 	E0 4B A0  1 58 46 A0  1 
: package  ( -- )  next-is-package on  ;
1A1FD30 	70 61 63 6B 61 67 65 87 
1A1FD38 	20 FD A1  1 20 40 A0  1 
1A1FD40 	78 FC A1  1 E0 4B A0  1 
1A1FD48 	58 46 A0  1 
: global   ( -- )  next-is-package off  ;  \ The default, for now
1A1FD4C 	 0 67 6C 6F 
1A1FD50 	62 61 6C 86 3C FD A1  1 
1A1FD58 	20 40 A0  1 78 FC A1  1 
1A1FD60 	F8 4B A0  1 58 46 A0  1 
headerless

\ Should be in machine code
: >instance-data  ( pfa -- adr )
1A1FD68 	 0 3E 69 6E 73 74 61 6E 
1A1FD70 	63 65 2D 64 61 74 61 8E 
1A1FD78 	58 FD A1  1 20 40 A0  1 
   my-self  if  @ my-self + exit  then
1A1FD80 	EC 7E A0  1 DC 41 A0  1 
1A1FD88 	14  0  0  0 5C 4C A0  1 
1A1FD90 	EC 7E A0  1  4 45 A0  1 
1A1FD98 	40 46 A0  1 
   true abort" Tried to access instance-specific data with no current instance"
1A1FD9C 	 4 70 A0  1 
1A1FDA0 	 8 81 A0  1 3F 54 72 69 
1A1FDA8 	65 64 20 74 6F 20 61 63 
1A1FDB0 	63 65 73 73 20 69 6E 73 
1A1FDB8 	74 61 6E 63 65 2D 73 70 
1A1FDC0 	65 63 69 66 69 63 20 64 
1A1FDC8 	61 74 61 20 77 69 74 68 
1A1FDD0 	20 6E 6F 20 63 75 72 72 
1A1FDD8 	65 6E 74 20 69 6E 73 74 
1A1FDE0 	61 6E 63 65  0  0  0  0 
;
1A1FDE8 	58 46 A0  1 

\ Sizes of the initialized and unitialized portions of the buffer that
\ is used as the instance data when the package is being created.
\ This allows variables, buffers, and values to be used while the
\ package is being created.

d# 100 /n* constant /value-area
1A1FDEC 	2F 76 61 6C 
1A1FDF0 	75 65 2D 61 72 65 61 8B 
1A1FDF8 	7C FD A1  1 68 40 A0  1 
1A1FE00 	90  1  0  0 
d# 700 /n* constant /buffer-area
1A1FE04 	 0  0  0 2F 
1A1FE08 	62 75 66 66 65 72 2D 61 
1A1FE10 	72 65 61 8C FC FD A1  1 
1A1FE18 	68 40 A0  1 F0  A  0  0 

: value#,  ( size -- adr )
1A1FE20 	76 61 6C 75 65 23 2C 87 
1A1FE28 	18 FE A1  1 20 40 A0  1 
   '#values @  dup ,   ( size offset )
1A1FE30 	7C FA A1  1 5C 4C A0  1 
1A1FE38 	40 49 A0  1 98 55 A0  1 
   tuck +              ( offset offset' )
1A1FE40 	E8 46 A0  1  4 45 A0  1 
   dup /value-area >= abort" Too many instance variables/values/defers"
1A1FE48 	40 49 A0  1 FC FD A1  1 
1A1FE50 	EC 48 A0  1  8 81 A0  1 
1A1FE58 	29 54 6F 6F 20 6D 61 6E 
1A1FE60 	79 20 69 6E 73 74 61 6E 
1A1FE68 	63 65 20 76 61 72 69 61 
1A1FE70 	62 6C 65 73 2F 76 61 6C 
1A1FE78 	75 65 73 2F 64 65 66 65 
1A1FE80 	72 73  0  0 
   '#values !          ( offset )
1A1FE84 	7C FA A1  1 
1A1FE88 	54 4D A0  1 
   my-self +           ( adr )
1A1FE8C 	EC 7E A0  1 
1A1FE90 	 4 45 A0  1 
;
1A1FE94 	58 46 A0  1 

headers
: value  \ name  ( initial-value -- )
1A1FE98 	 0  0 76 61 6C 75 65 85 
1A1FEA0 	2C FE A1  1 20 40 A0  1 
   header noop   \  Will patch with (value)
1A1FEA8 	DC 6D A0  1 E8  5 A2  1 
;
1A1FEB0 	58 46 A0  1 
headerless
3 actions
1A1FEB4 	E4 FE A1  1 
1A1FEB8 	D4 FE A1  1  3  0  0  0 
action:  >instance-data @  ;
1A1FEC0 	90 90 90 E8 B4 41 FE FF 
1A1FEC8 	7C FD A1  1 5C 4C A0  1 
1A1FED0 	58 46 A0  1 
action:  >instance-data !  ;
1A1FED4 	20 40 A0  1 
1A1FED8 	7C FD A1  1 54 4D A0  1 
1A1FEE0 	58 46 A0  1 
action:  >instance-data    ;
1A1FEE4 	20 40 A0  1 
1A1FEE8 	7C FD A1  1 58 46 A0  1 
action-adr-t to ^instance
: instance-value  ( initial-value -- )
1A1FEF0 	 0 69 6E 73 74 61 6E 63 
1A1FEF8 	65 2D 76 61 6C 75 65 8E 
1A1FF00 	A4 FE A1  1 20 40 A0  1 
   create-cf use-actions  /n value#, !
1A1FF08 	30 5B A0  1 60 53 A0  1 
1A1FF10 	C0 FE A1  1 E0 57 A0  1 
1A1FF18 	40 51 A0  1 2C FE A1  1 
1A1FF20 	54 4D A0  1 
;
1A1FF24 	58 46 A0  1 

\ Create fields which are present in every instance record.
\ "fixed instance value"

headers
transient
: fibuf:  \ name  ( offset -- offset' )
1A1FF28 	 0 66 69 62 75 66 3A 86 
1A1FF30 	 4 FF A1  1 20 40 A0  1 
   create -1 na+ dup ,  ( offset' )
1A1FF38 	A8 A2 A0  1 58 41 A0  1 
1A1FF40 	FF FF FF FF 48 50 A0  1 
1A1FF48 	40 49 A0  1 98 55 A0  1 
   use-actions
1A1FF50 	60 53 A0  1 C0 FE A1  1 
1A1FF58 	E0 57 A0  1 
;
1A1FF5C 	58 46 A0  1 
: fival:  \ name  ( offset -- offset' )
1A1FF60 	 0 66 69 76 61 6C 3A 86 
1A1FF68 	34 FF A1  1 20 40 A0  1 
   create dup , na1+ ( offset' )
1A1FF70 	A8 A2 A0  1 40 49 A0  1 
1A1FF78 	98 55 A0  1 CC 50 A0  1 
   use-actions
1A1FF80 	60 53 A0  1 C0 FE A1  1 
1A1FF88 	E0 57 A0  1 
;
1A1FF8C 	58 46 A0  1 
resident

headerless
: 2value  \ name  ( d.initial-value -- )
1A1FF90 	 0 32 76 61 6C 75 65 86 
1A1FF98 	6C FF A1  1 20 40 A0  1 
   header noop   \  Will patch with (2value)
1A1FFA0 	DC 6D A0  1 B8  6 A2  1 
;
1A1FFA8 	58 46 A0  1 

3 actions
1A1FFAC 	DC FF A1  1 
1A1FFB0 	CC FF A1  1  3  0  0  0 
action:  >instance-data 2@  ;
1A1FFB8 	90 90 90 E8 BC 40 FE FF 
1A1FFC0 	7C FD A1  1 CC 4D A0  1 
1A1FFC8 	58 46 A0  1 
action:  >instance-data 2!  ;
1A1FFCC 	20 40 A0  1 
1A1FFD0 	7C FD A1  1 E4 4D A0  1 
1A1FFD8 	58 46 A0  1 
action:  >instance-data     ;
1A1FFDC 	20 40 A0  1 
1A1FFE0 	7C FD A1  1 58 46 A0  1 

: instance-2value  ( d.initial-value -- )
1A1FFE8 	69 6E 73 74 61 6E 63 65 
1A1FFF0 	2D 32 76 61 6C 75 65 8F 
1A1FFF8 	9C FF A1  1 20 40 A0  1 
   create-cf use-actions  /n 2* value#,  2!
1A20000 	30 5B A0  1 60 53 A0  1 
1A20008 	B8 FF A1  1 E0 57 A0  1 
1A20010 	40 51 A0  1 A0 4B A0  1 
1A20018 	2C FE A1  1 E4 4D A0  1 
;
1A20020 	58 46 A0  1 

action-adr-t to ^instance-2value

headers
: buffer:  \ name  ( size -- )
1A20024 	62 75 66 66 
1A20028 	65 72 3A 87 FC FF A1  1 
1A20030 	20 40 A0  1 
   header noop  \ Will patch with (buffer:)
1A20034 	DC 6D A0  1 
1A20038 	88  0 A2  1 
;
1A2003C 	58 46 A0  1 

3 actions
1A20040 	6C  0 A2  1 5C  0 A2  1 
1A20048 	 3  0  0  0 
action:  >instance-data    ;
1A2004C 	90 90 90 E8 
1A20050 	28 40 FE FF 7C FD A1  1 
1A20058 	58 46 A0  1 
action:  >instance-data !  ;
1A2005C 	20 40 A0  1 
1A20060 	7C FD A1  1 54 4D A0  1 
1A20068 	58 46 A0  1 
action:  >instance-data    ;
1A2006C 	20 40 A0  1 
1A20070 	7C FD A1  1 58 46 A0  1 

headerless
: (buffer:)  ( #bytes -- )
1A20078 	 0  0 28 62 75 66 66 65 
1A20080 	72 3A 29 89 30  0 A2  1 
1A20088 	20 40 A0  1 
   instance?  if
1A2008C 	B0 FC A1  1 
1A20090 	DC 41 A0  1 78  0  0  0 
      create-cf
1A20098 	30 5B A0  1 
      '#buffers @ swap aligned -  dup  ,  ( offset' )
1A2009C 	64 FA A1  1 
1A200A0 	5C 4C A0  1 68 49 A0  1 
1A200A8 	EC 5C A0  1 18 45 A0  1 
1A200B0 	40 49 A0  1 98 55 A0  1 
      dup negate /buffer-area > abort" Too many bytes of instance buffers"
1A200B8 	40 49 A0  1 48 45 A0  1 
1A200C0 	18 FE A1  1  4 48 A0  1 
1A200C8 	 8 81 A0  1 22 54 6F 6F 
1A200D0 	20 6D 61 6E 79 20 62 79 
1A200D8 	74 65 73 20 6F 66 20 69 
1A200E0 	6E 73 74 61 6E 63 65 20 
1A200E8 	62 75 66 66 65 72 73  0 
      '#buffers !  use-actions
1A200F0 	64 FA A1  1 54 4D A0  1 
1A200F8 	60 53 A0  1 4C  0 A2  1 
1A20100 	E0 57 A0  1 
   else
1A20104 	C8 41 A0  1 
1A20108 	 8  0  0  0 
      (buffer:)
1A2010C 	A4 A9 A0  1 
   then
; patch (buffer:) noop buffer:
1A20110 	58 46 A0  1 

action-adr-t to ^instanceBUF

headers
: variable  \ name  ( -- )
1A20114 	 0  0  0 76 
1A20118 	61 72 69 61 62 6C 65 88 
1A20120 	88  0 A2  1 20 40 A0  1 
   header  noop \ Will patch with (variable)
1A20128 	DC 6D A0  1 7C  1 A2  1 
;
1A20130 	58 46 A0  1 

3 actions
1A20134 	60  1 A2  1 
1A20138 	50  1 A2  1  3  0  0  0 
action:  >instance-data    ;
1A20140 	90 90 90 E8 34 3F FE FF 
1A20148 	7C FD A1  1 58 46 A0  1 
action:  >instance-data !  ;
1A20150 	20 40 A0  1 7C FD A1  1 
1A20158 	54 4D A0  1 58 46 A0  1 
action:  >instance-data    ;
1A20160 	20 40 A0  1 7C FD A1  1 
1A20168 	58 46 A0  1 

headerless
: (variable)  ( -- )
1A2016C 	 0 28 76 61 
1A20170 	72 69 61 62 6C 65 29 8A 
1A20178 	24  1 A2  1 20 40 A0  1 
   instance?  if
1A20180 	B0 FC A1  1 DC 41 A0  1 
1A20188 	28  0  0  0 
      create-cf use-actions  0 /n value#,  else  user-cf  0 /n  user#,
1A2018C 	30 5B A0  1 
1A20190 	60 53 A0  1 40  1 A2  1 
1A20198 	E0 57 A0  1 70 6F A0  1 
1A201A0 	40 51 A0  1 2C FE A1  1 
1A201A8 	C8 41 A0  1 14  0  0  0 
1A201B0 	C4 5B A0  1 70 6F A0  1 
1A201B8 	40 51 A0  1 84 9A A0  1 
   then
   !
1A201C0 	54 4D A0  1 
; patch (variable) noop variable
1A201C4 	58 46 A0  1 
action-adr-t to ^instance-VARIABLE 
headers
: defer  \ name  ( -- )
1A201C8 	 0  0 64 65 66 65 72 85 
1A201D0 	7C  1 A2  1 20 40 A0  1 
   header noop \ Will patch with (defer)
1A201D8 	DC 6D A0  1 70  2 A2  1 
;
1A201E0 	58 46 A0  1 
3 actions
1A201E4 	18  2 A2  1 
1A201E8 	 8  2 A2  1  3  0  0  0 
action:  >instance-data token@ execute  ;
1A201F0 	90 90 90 E8 84 3E FE FF 
1A201F8 	7C FD A1  1  C 54 A0  1 
1A20200 	98 41 A0  1 58 46 A0  1 
action:  >instance-data token!  ;
1A20208 	20 40 A0  1 7C FD A1  1 
1A20210 	20 54 A0  1 58 46 A0  1 
action:  >instance-data token@  ;
1A20218 	20 40 A0  1 7C FD A1  1 
1A20220 	 C 54 A0  1 58 46 A0  1 

headerless
: instance-defer  ( -- )
1A20228 	 0 69 6E 73 74 61 6E 63 
1A20230 	65 2D 64 65 66 65 72 8E 
1A20238 	D4  1 A2  1 20 40 A0  1 
   create-cf  ['] crash /token  ( value data-size )
1A20240 	30 5B A0  1 60 53 A0  1 
1A20248 	C8 A7 A0  1 B4 46 A0  1 
   use-actions  value#,
1A20250 	60 53 A0  1 F0  1 A2  1 
1A20258 	E0 57 A0  1 2C FE A1  1 
;
1A20260 	58 46 A0  1 
: (defer)  ( -- )
1A20264 	28 64 65 66 
1A20268 	65 72 29 87 3C  2 A2  1 
1A20270 	20 40 A0  1 
   instance?  if
1A20274 	B0 FC A1  1 
1A20278 	DC 41 A0  1 10  0  0  0 
      instance-defer
1A20280 	3C  2 A2  1 
   else
1A20284 	C8 41 A0  1 
1A20288 	18  0  0  0 
      defer-cf  ['] crash /token   ( value data-size )
1A2028C 	30 5C A0  1 
1A20290 	60 53 A0  1 C8 A7 A0  1 
1A20298 	B4 46 A0  1 
      user#,
1A2029C 	84 9A A0  1 
   then                            ( value adr )
   token!
1A202A0 	20 54 A0  1 
; patch (defer) noop defer
1A202A4 	58 46 A0  1 
action-adr-t to ^instance-defer

\ Extend debugger to handle instance defers
: (resolve-instance-defers)  ( xt -- xt' )
1A202A8 	 0  0 28 72 65 73 6F 6C 
1A202B0 	76 65 2D 69 6E 73 74 61 
1A202B8 	6E 63 65 2D 64 65 66 65 
1A202C0 	72 73 29 99 70  2 A2  1 
1A202C8 	20 40 A0  1 
   begin
      dup defer?  if                             ( xt )
1A202CC 	40 49 A0  1 
1A202D0 	 C CA A1  1 DC 41 A0  1 
1A202D8 	10  0  0  0 
	 behavior                                ( xt' )
1A202DC 	10 C7 A0  1 
      else                                       ( xt )
1A202E0 	C8 41 A0  1 34  0  0  0 
         dup definer ['] instance-defer  =  if   ( xt )
1A202E8 	40 49 A0  1 48 3F A1  1 
1A202F0 	60 53 A0  1 3C  2 A2  1 
1A202F8 	24 48 A0  1 DC 41 A0  1 
1A20300 	14  0  0  0 
            2 perform-action                     ( xt' )
1A20304 	90 6F A0  1 
1A20308 	10 B8 A1  1 
	 else                                    ( xt )
1A2030C 	C8 41 A0  1 
1A20310 	 8  0  0  0 
	    exit
1A20314 	40 46 A0  1 
         then
      then
   again
1A20318 	C8 41 A0  1 B0 FF FF FF 
;
1A20320 	58 46 A0  1 
' (resolve-instance-defers) to resolve-defers

\ Extend decompiler to handle instance defers
: .instance-defer  ( xt definer -- )
1A20324 	2E 69 6E 73 
1A20328 	74 61 6E 63 65 2D 64 65 
1A20330 	66 65 72 8F C8  2 A2  1 
1A20338 	20 40 A0  1 
   .definer  ." is " cr   ( xt )
1A2033C 	88 39 A1  1 
1A20340 	20 7C A0  1  3 69 73 20 
1A20348 	 0  0  0  0 80 6D A0  1 
   2 perform-action       ( xt' )
1A20350 	90 6F A0  1 10 B8 A1  1 
   (see)
1A20358 	98 20 A1  1 
;
1A2035C 	58 46 A0  1 
' instance-defer  ' .instance-defer  install-decomp-definer

headers
\ Instance values that are automatically created for every package instance.

0
fival: my-adr0		\ F: First component of device probe address
1A20360 	6D 79 2D 61 64 72 30 87 
1A20368 	38  3 A2  1 C0 FE A1  1 
1A20370 	 0  0  0  0 
fival: my-adr1		\ F: Intermediate component of device probe address
1A20374 	6D 79 2D 61 
1A20378 	64 72 31 87 6C  3 A2  1 
1A20380 	C0 FE A1  1  4  0  0  0 
fival: my-adr2		\ F: Intermediate component of device probe address
1A20388 	6D 79 2D 61 64 72 32 87 
1A20390 	80  3 A2  1 C0 FE A1  1 
1A20398 	 8  0  0  0 
fival: my-space 	\ F: Last component of device probe address
1A2039C 	 0  0  0 6D 
1A203A0 	79 2D 73 70 61 63 65 88 
1A203A8 	94  3 A2  1 C0 FE A1  1 
1A203B0 	 C  0  0  0 
fival: frame-buffer-adr \ F: Frame buffer address.  Strictly speaking, this
1A203B4 	 0  0  0 66 
1A203B8 	72 61 6D 65 2D 62 75 66 
1A203C0 	66 65 72 2D 61 64 72 90 
1A203C8 	AC  3 A2  1 C0 FE A1  1 
1A203D0 	10  0  0  0 
                        \ should not be in every package, but we put it
                        \ here as a work-around for some old CG6 FCode
                        \ drivers whose selftest routines use frame-buffer-adr
                        \ for diagnostics mappings.  If frame-buffer-adr is
                        \ global, that would cause dual-cg6 systems to break.
fival: my-termemu
1A203D4 	 0 6D 79 2D 
1A203D8 	74 65 72 6D 65 6D 75 8A 
1A203E0 	CC  3 A2  1 C0 FE A1  1 
1A203E8 	14  0  0  0 

headerless
constant #fixed-vals
1A203EC 	23 66 69 78 
1A203F0 	65 64 2D 76 61 6C 73 8B 
1A203F8 	E4  3 A2  1 68 40 A0  1 
1A20400 	18  0  0  0 
headers

0
fibuf: my-voc           \ Package definition (code) for this instance
1A20404 	 0 6D 79 2D 
1A20408 	76 6F 63 86 FC  3 A2  1 
1A20410 	C0 FE A1  1 FC FF FF FF 
fibuf: my-parent        \ Current instance just before this one was created
1A20418 	 0  0 6D 79 2D 70 61 72 
1A20420 	65 6E 74 89 10  4 A2  1 
1A20428 	C0 FE A1  1 F8 FF FF FF 
fibuf: my-args-adr      \ Argument string - base address
1A20430 	6D 79 2D 61 72 67 73 2D 
1A20438 	61 64 72 8B 28  4 A2  1 
1A20440 	C0 FE A1  1 F4 FF FF FF 
fibuf: my-args-len      \ Argument string - length
1A20448 	6D 79 2D 61 72 67 73 2D 
1A20450 	6C 65 6E 8B 40  4 A2  1 
1A20458 	C0 FE A1  1 F0 FF FF FF 
fibuf: my-unit-3	\ Fourth component of device instance address
1A20460 	 0  0 6D 79 2D 75 6E 69 
1A20468 	74 2D 33 89 58  4 A2  1 
1A20470 	C0 FE A1  1 EC FF FF FF 
fibuf: my-unit-2	\ Third  component of device instance address
1A20478 	 0  0 6D 79 2D 75 6E 69 
1A20480 	74 2D 32 89 70  4 A2  1 
1A20488 	C0 FE A1  1 E8 FF FF FF 
fibuf: my-unit-1	\ Second component of device instance address
1A20490 	 0  0 6D 79 2D 75 6E 69 
1A20498 	74 2D 31 89 88  4 A2  1 
1A204A0 	C0 FE A1  1 E4 FF FF FF 
fibuf: my-unit-low	\ First  component of device instance address
1A204A8 	6D 79 2D 75 6E 69 74 2D 
1A204B0 	6C 6F 77 8B A0  4 A2  1 
1A204B8 	C0 FE A1  1 E0 FF FF FF 

headerless
constant #fixed-bufs
1A204C0 	23 66 69 78 65 64 2D 62 
1A204C8 	75 66 73 8B B8  4 A2  1 
1A204D0 	68 40 A0  1 E0 FF FF FF 

: initial-values  ( -- adr )  'values token@  ;
1A204D8 	 0 69 6E 69 74 69 61 6C 
1A204E0 	2D 76 61 6C 75 65 73 8E 
1A204E8 	D0  4 A2  1 20 40 A0  1 
1A204F0 	90 FA A1  1  C 54 A0  1 
1A204F8 	58 46 A0  1 

\ Non-instance values defined inside packages are stored in the initial
\ value array that is used to initialize instance data, but unlike instance
\ values, they are accessed directly from the initial value array instead
\ of from the instance record.  This allows their values to be shared among
\ different instances, either simultaneously-active ones or ones that are
\ separated in time, and also allows different clones of that package to
\ have separate copies of that data.  The down side of this scheme, compared
\ to the previous technique of using the user area for non-instance values
\ is that it is not ROMable, because the initial value array must be writeable
\ (previously it was only written at package creation time, and read-only
\ thereafter).  One up side is that packages that use large numbers of non-
\ instance values no longer consume a lot of user area (a relative-limited
\ resource).  If we ever need to make this ROMable, we can implement copy-on-
\ write for initial values.

: initial-values'  ( -- adr )
1A204FC 	69 6E 69 74 
1A20500 	69 61 6C 2D 76 61 6C 75 
1A20508 	65 73 27 8F EC  4 A2  1 
1A20510 	20 40 A0  1 
   my-self  if	\ Use current instance's package if there is a current instance
1A20514 	EC 7E A0  1 
1A20518 	DC 41 A0  1 1C  0  0  0 
      my-voc (push-package)  initial-values  (pop-package)
1A20520 	10  4 A2  1 38 FB A1  1 
1A20528 	EC  4 A2  1 5C FB A1  1 
   else		\ Otherwise use the active package
1A20530 	C8 41 A0  1  8  0  0  0 
      initial-values
1A20538 	EC  4 A2  1 
   then
;
1A2053C 	58 46 A0  1 

: >initial-value  ( pfa -- adr )  @  initial-values' +  ;
1A20540 	 0 3E 69 6E 69 74 69 61 
1A20548 	6C 2D 76 61 6C 75 65 8E 
1A20550 	10  5 A2  1 20 40 A0  1 
1A20558 	5C 4C A0  1 10  5 A2  1 
1A20560 	 4 45 A0  1 58 46 A0  1 

3 actions
1A20568 	98  5 A2  1 88  5 A2  1 
1A20570 	 3  0  0  0 
action:  >initial-value @  ;
1A20574 	90 90 90 E8 
1A20578 	 0 3B FE FF 54  5 A2  1 
1A20580 	5C 4C A0  1 58 46 A0  1 
action:  >initial-value !  ;
1A20588 	20 40 A0  1 54  5 A2  1 
1A20590 	54 4D A0  1 58 46 A0  1 
action:  >initial-value    ;
1A20598 	20 40 A0  1 54  5 A2  1 
1A205A0 	58 46 A0  1 

: package-value  ( initial-value -- )
1A205A4 	 0  0 70 61 
1A205A8 	63 6B 61 67 65 2D 76 61 
1A205B0 	6C 75 65 8D 54  5 A2  1 
1A205B8 	20 40 A0  1 
   create-cf use-actions  /n value#,  !
1A205BC 	30 5B A0  1 
1A205C0 	60 53 A0  1 74  5 A2  1 
1A205C8 	E0 57 A0  1 40 51 A0  1 
1A205D0 	2C FE A1  1 54 4D A0  1 
;
1A205D8 	58 46 A0  1 
 action-adr-t to dopackage-value
: (value)  ( initial-value -- )
1A205DC 	28 76 61 6C 
1A205E0 	75 65 29 87 B8  5 A2  1 
1A205E8 	20 40 A0  1 
   instance?  if
1A205EC 	B0 FC A1  1 
1A205F0 	DC 41 A0  1 10  0  0  0 
      instance-value
1A205F8 	 4 FF A1  1 
   else
1A205FC 	C8 41 A0  1 
1A20600 	2C  0  0  0 
      package?  if  package-value  else  value-cf /n user#, !  then
1A20604 	E8 FC A1  1 
1A20608 	DC 41 A0  1 10  0  0  0 
1A20610 	B8  5 A2  1 C8 41 A0  1 
1A20618 	14  0  0  0 E8 5B A0  1 
1A20620 	40 51 A0  1 84 9A A0  1 
1A20628 	54 4D A0  1 
   then
;
1A2062C 	58 46 A0  1 
patch (value) noop value

3 actions
1A20630 	60  6 A2  1 50  6 A2  1 
1A20638 	 3  0  0  0 
action:  >initial-value 2@  ;
1A2063C 	90 90 90 E8 
1A20640 	38 3A FE FF 54  5 A2  1 
1A20648 	CC 4D A0  1 58 46 A0  1 
action:  >initial-value 2!  ;
1A20650 	20 40 A0  1 54  5 A2  1 
1A20658 	E4 4D A0  1 58 46 A0  1 
action:  >initial-value     ;
1A20660 	20 40 A0  1 54  5 A2  1 
1A20668 	58 46 A0  1 

: package-2value  ( initial-value -- )
1A2066C 	 0 70 61 63 
1A20670 	6B 61 67 65 2D 32 76 61 
1A20678 	6C 75 65 8E E8  5 A2  1 
1A20680 	20 40 A0  1 
   create-cf use-actions  2 /n* value#,  2!
1A20684 	30 5B A0  1 
1A20688 	60 53 A0  1 3C  6 A2  1 
1A20690 	E0 57 A0  1 90 6F A0  1 
1A20698 	98 51 A0  1 2C FE A1  1 
1A206A0 	E4 4D A0  1 
;
1A206A4 	58 46 A0  1 

: (2value)  ( initial-value -- )
1A206A8 	 0  0  0 28 32 76 61 6C 
1A206B0 	75 65 29 88 80  6 A2  1 
1A206B8 	20 40 A0  1 
   instance?  if
1A206BC 	B0 FC A1  1 
1A206C0 	DC 41 A0  1 10  0  0  0 
      instance-2value
1A206C8 	FC FF A1  1 
   else
1A206CC 	C8 41 A0  1 
1A206D0 	30  0  0  0 
     package?  if  package-2value  else  2value-cf  2 /n* user#, 2!  then
1A206D4 	E8 FC A1  1 
1A206D8 	DC 41 A0  1 10  0  0  0 
1A206E0 	80  6 A2  1 C8 41 A0  1 
1A206E8 	18  0  0  0 64 BA A1  1 
1A206F0 	90 6F A0  1 98 51 A0  1 
1A206F8 	84 9A A0  1 E4 4D A0  1 
   then
;
1A20700 	58 46 A0  1 
patch (2value) noop 2value

headers
: my-args  ( -- adr len )  my-args-adr my-args-len  ;
1A20704 	6D 79 2D 61 
1A20708 	72 67 73 87 B8  6 A2  1 
1A20710 	20 40 A0  1 40  4 A2  1 
1A20718 	58  4 A2  1 58 46 A0  1 

headerless
: allocate-instance  ( value-size variable-size -- )
1A20720 	 0  0 61 6C 6C 6F 63 61 
1A20728 	74 65 2D 69 6E 73 74 61 
1A20730 	6E 63 65 91 10  7 A2  1 
1A20738 	20 40 A0  1 
   \ Allocate instance record
   my-self >r                                 ( val-size var-size )
1A2073C 	EC 7E A0  1 
1A20740 	BC 45 A0  1 
   tuck +  alloc-mem                          ( var-size base-adr )
1A20744 	E8 46 A0  1 
1A20748 	 4 45 A0  1 F0 6C A0  1 
   + is my-self                               ( )
1A20750 	 4 45 A0  1 B8 40 A0  1 
1A20758 	EC 7E A0  1 

   \ Set the fixed fields
   r> to my-parent                            ( )
1A2075C 	D0 45 A0  1 
1A20760 	48 B8 A1  1 28  4 A2  1 
   current-device  to my-voc                  ( )
1A20768 	40 F9 A1  1 48 B8 A1  1 
1A20770 	10  4 A2  1 
   0 to my-args-len  0 to my-args-adr         ( )  \ May be changed later
1A20774 	70 6F A0  1 
1A20778 	48 B8 A1  1 58  4 A2  1 
1A20780 	70 6F A0  1 48 B8 A1  1 
1A20788 	40  4 A2  1 
;
1A2078C 	58 46 A0  1 

\ Returns the address of the initial value of the named instance data.
: (initial-addr)  ( adr -- adr' )    my-self -  initial-values' +  ;
1A20790 	 0 28 69 6E 69 74 69 61 
1A20798 	6C 2D 61 64 64 72 29 8E 
1A207A0 	38  7 A2  1 20 40 A0  1 
1A207A8 	EC 7E A0  1 18 45 A0  1 
1A207B0 	10  5 A2  1  4 45 A0  1 
1A207B8 	58 46 A0  1 
: initial-addr  \ name  ( -- addr )
1A207BC 	 0  0  0 69 
1A207C0 	6E 69 74 69 61 6C 2D 61 
1A207C8 	64 64 72 CC A4  7 A2  1 
1A207D0 	20 40 A0  1 
   [compile] addr
1A207D4 	DC B9 A1  1 
   state @  if  compile (initial-addr)  else  (initial-addr)  then
1A207D8 	38 54 A0  1 5C 4C A0  1 
1A207E0 	DC 41 A0  1 14  0  0  0 
1A207E8 	8C 75 A0  1 A4  7 A2  1 
1A207F0 	C8 41 A0  1  8  0  0  0 
1A207F8 	A4  7 A2  1 
; immediate
1A207FC 	58 46 A0  1 

: copy-args  ( args-adr,len -- )
1A20800 	 0  0 63 6F 70 79 2D 61 
1A20808 	72 67 73 89 D0  7 A2  1 
1A20810 	20 40 A0  1 
   dup  if
1A20814 	40 49 A0  1 
1A20818 	DC 41 A0  1 30  0  0  0 
      dup alloc-mem to my-args-adr          ( args-adr,len )
1A20820 	40 49 A0  1 F0 6C A0  1 
1A20828 	48 B8 A1  1 40  4 A2  1 
      to my-args-len                        ( args-adr )
1A20830 	48 B8 A1  1 58  4 A2  1 
      my-args-adr my-args-len move          ( )
1A20838 	40  4 A2  1 58  4 A2  1 
1A20840 	F4 4A A0  1 
   else
1A20844 	C8 41 A0  1 
1A20848 	 8  0  0  0 
      2drop
1A2084C 	AC 49 A0  1 
   then
;
1A20850 	58 46 A0  1 

: copy-instance-data  ( -- )
1A20854 	 0 63 6F 70 
1A20858 	79 2D 69 6E 73 74 61 6E 
1A20860 	63 65 2D 64 61 74 61 92 
1A20868 	10  8 A2  1 20 40 A0  1 
   initial-values  my-self  '#values @  move
1A20870 	EC  4 A2  1 EC 7E A0  1 
1A20878 	7C FA A1  1 5C 4C A0  1 
1A20880 	F4 4A A0  1 
;
1A20884 	58 46 A0  1 
\ my-self points to a position in the middle of the instance record.
\ Initialized data ("values") is at positive offsets from my-self,
\ and uninitialized data ("variables" and "buffers") is at negative offsets.
: new-instance  ( args-adr args-len -- )
1A20888 	 0  0  0 6E 65 77 2D 69 
1A20890 	6E 73 74 61 6E 63 65 8C 
1A20898 	6C  8 A2  1 20 40 A0  1 
   '#values @  '#buffers @ negate  allocate-instance  ( args-adr args-len )
1A208A0 	7C FA A1  1 5C 4C A0  1 
1A208A8 	64 FA A1  1 5C 4C A0  1 
1A208B0 	48 45 A0  1 38  7 A2  1 
   copy-instance-data                                 ( args-adr args-len )
1A208B8 	6C  8 A2  1 
   copy-args
1A208BC 	10  8 A2  1 
;
1A208C0 	58 46 A0  1 

: deallocate-instance  ( value-size variabled-size -- )
1A208C4 	64 65 61 6C 
1A208C8 	6C 6F 63 61 74 65 2D 69 
1A208D0 	6E 73 74 61 6E 63 65 93 
1A208D8 	9C  8 A2  1 20 40 A0  1 
   my-args-len  if  my-args-adr my-args-len free-mem  then
1A208E0 	58  4 A2  1 DC 41 A0  1 
1A208E8 	10  0  0  0 40  4 A2  1 
1A208F0 	58  4 A2  1  8 6D A0  1 
   my-self  my-parent is my-self   ( val-size var-size self )
1A208F8 	EC 7E A0  1 28  4 A2  1 
1A20900 	B8 40 A0  1 EC 7E A0  1 
   over -                          ( val-size var-size base-adr )
1A20908 	54 49 A0  1 18 45 A0  1 
   -rot  +  free-mem               ( )
1A20910 	94 49 A0  1  4 45 A0  1 
1A20918 	 8 6D A0  1 
;
1A2091C 	58 46 A0  1 

\ Destroy instance has the side effect of setting my-self to the parent
\ of the node that is being destroyed.  This prevents my-self from referring
\ to a non-existent instance.

: destroy-instance  ( -- )
1A20920 	 0  0  0 64 65 73 74 72 
1A20928 	6F 79 2D 69 6E 73 74 61 
1A20930 	6E 63 65 90 DC  8 A2  1 
1A20938 	20 40 A0  1 
   my-voc (push-package)              ( )
1A2093C 	10  4 A2  1 
1A20940 	38 FB A1  1 
   '#values @  '#buffers @  negate    ( value-size variable-size )
1A20944 	7C FA A1  1 
1A20948 	5C 4C A0  1 64 FA A1  1 
1A20950 	5C 4C A0  1 48 45 A0  1 
   (pop-package)                      ( value-size variable-size )
1A20958 	5C FB A1  1 
   deallocate-instance
1A2095C 	DC  8 A2  1 

;
1A20960 	58 46 A0  1 
\ When creating a package definition, we initialize the buffer
\ (uninitialized data) allocation pointer and the value (initialized data)
\ allocation pointer.

: prime-package  ( -- )
1A20964 	 0  0 70 72 
1A20968 	69 6D 65 2D 70 61 63 6B 
1A20970 	61 67 65 8D 38  9 A2  1 
1A20978 	20 40 A0  1 
   next-is-instance off
1A2097C 	98 FC A1  1 
1A20980 	F8 4B A0  1 
   1 package-level +!  /value-area /buffer-area  allocate-instance
1A20984 	80 6F A0  1 
1A20988 	5C FC A1  1  C 4C A0  1 
1A20990 	FC FD A1  1 18 FE A1  1 
1A20998 	38  7 A2  1 
   my-self  'values token!
1A2099C 	EC 7E A0  1 
1A209A0 	90 FA A1  1 20 54 A0  1 
;
1A209A8 	58 46 A0  1 
headers
: extend-package  ( -- )
1A209AC 	 0 65 78 74 
1A209B0 	65 6E 64 2D 70 61 63 6B 
1A209B8 	61 67 65 8E 78  9 A2  1 
1A209C0 	20 40 A0  1 
   initial-values              ( 'values )
1A209C4 	EC  4 A2  1 
   prime-package               ( 'values )
1A209C8 	78  9 A2  1 
   my-self  '#values @  move   \ Preserve the initial values
1A209CC 	EC 7E A0  1 
1A209D0 	7C FA A1  1 5C 4C A0  1 
1A209D8 	F4 4A A0  1 
;
1A209DC 	58 46 A0  1 
headerless

: allot-package-data  ( -- )
1A209E0 	 0 61 6C 6C 6F 74 2D 70 
1A209E8 	61 63 6B 61 67 65 2D 64 
1A209F0 	61 74 61 92 C0  9 A2  1 
1A209F8 	20 40 A0  1 
   acf-align here dup 'values token!  '#values @ dup allot  erase
1A209FC 	2C 5D A0  1 
1A20A00 	70 54 A0  1 40 49 A0  1 
1A20A08 	90 FA A1  1 20 54 A0  1 
1A20A10 	7C FA A1  1 5C 4C A0  1 
1A20A18 	40 49 A0  1 E4 54 A0  1 
1A20A20 	F0 72 A0  1 
;
1A20A24 	58 46 A0  1 
: finish-package-data  ( -- )
1A20A28 	66 69 6E 69 73 68 2D 70 
1A20A30 	61 63 6B 61 67 65 2D 64 
1A20A38 	61 74 61 93 F8  9 A2  1 
1A20A40 	20 40 A0  1 
   \ Copy the initialized data into the dictionary and set up the
   \ pointer to it.
   '#values @  if  allot-package-data  then
1A20A44 	7C FA A1  1 
1A20A48 	5C 4C A0  1 DC 41 A0  1 
1A20A50 	 8  0  0  0 F8  9 A2  1 
   my-self  initial-values  '#values @  move            ( )
1A20A58 	EC 7E A0  1 EC  4 A2  1 
1A20A60 	7C FA A1  1 5C 4C A0  1 
1A20A68 	F4 4A A0  1 

   initial-addr frame-buffer-adr off
1A20A6C 	5C B8 A1  1 
1A20A70 	CC  3 A2  1 A4  7 A2  1 
1A20A78 	F8 4B A0  1 
   initial-addr my-termemu       off
1A20A7C 	5C B8 A1  1 
1A20A80 	E4  3 A2  1 A4  7 A2  1 
1A20A88 	F8 4B A0  1 

   /value-area /buffer-area deallocate-instance         ( )
1A20A8C 	FC FD A1  1 
1A20A90 	18 FE A1  1 DC  8 A2  1 
   package-level @ 1- 0 max package-level !
1A20A98 	5C FC A1  1 5C 4C A0  1 
1A20AA0 	54 4B A0  1 70 6F A0  1 
1A20AA8 	9C 4A A0  1 5C FC A1  1 
1A20AB0 	54 4D A0  1 
;
1A20AB4 	58 46 A0  1 

\ Internal factor used to implement first-child and next-child
: set-child?  ( link-adr -- flag )
1A20AB8 	 0 73 65 74 2D 63 68 69 
1A20AC0 	6C 64 3F 8A 40  A A2  1 
1A20AC8 	20 40 A0  1 
   get-token?  if  voc>phandle push-device true  else  false  then
1A20ACC 	6C 59 A0  1 
1A20AD0 	DC 41 A0  1 18  0  0  0 
1A20AD8 	40 F8 A1  1 F8 FB A1  1 
1A20AE0 	 4 70 A0  1 C8 41 A0  1 
1A20AE8 	 8  0  0  0 18 70 A0  1 
;
1A20AF0 	58 46 A0  1 

\ Interface to searching code in breadth.fth:
: first-child  ( -- another? )  'child set-child?  ;
1A20AF4 	66 69 72 73 
1A20AF8 	74 2D 63 68 69 6C 64 8B 
1A20B00 	C8  A A2  1 20 40 A0  1 
1A20B08 	 8 FA A1  1 C8  A A2  1 
1A20B10 	58 46 A0  1 
: next-child   ( -- another? )  'peer  pop-device  set-child?  ;
1A20B14 	 0 6E 65 78 
1A20B18 	74 2D 63 68 69 6C 64 8A 
1A20B20 	 4  B A2  1 20 40 A0  1 
1A20B28 	1C FA A1  1 18 FC A1  1 
1A20B30 	C8  A A2  1 58 46 A0  1 

\ Removes the voc-link field from the most-recently-created vocabulary
: erase-voc-link  ( -- )
1A20B38 	 0 65 72 61 73 65 2D 76 
1A20B40 	6F 63 2D 6C 69 6E 6B 8E 
1A20B48 	24  B A2  1 20 40 A0  1 
   voc-link  a@ >voc-link a@  voc-link a!
1A20B50 	74 B6 A0  1 88 58 A0  1 
1A20B58 	50 B6 A0  1 88 58 A0  1 
1A20B60 	74 B6 A0  1 98 58 A0  1 
   /link na1+ negate allot
1A20B68 	78 73 A0  1 CC 50 A0  1 
1A20B70 	48 45 A0  1 E4 54 A0  1 
;
1A20B78 	58 46 A0  1 

\ Creates an unnamed vocabulary
: (vocabulary)  ( -- )
1A20B7C 	 0  0  0 28 
1A20B80 	76 6F 63 61 62 75 6C 61 
1A20B88 	72 79 29 8C 4C  B A2  1 
1A20B90 	20 40 A0  1 
   ['] acf-align is header
1A20B94 	60 53 A0  1 
1A20B98 	2C 5D A0  1 98 40 A0  1 
1A20BA0 	DC 6D A0  1 
   vocabulary
1A20BA4 	28 B7 A0  1 
   ['] (header) is header
1A20BA8 	60 53 A0  1 70 A2 A0  1 
1A20BB0 	98 40 A0  1 DC 6D A0  1 

   erase-voc-link
1A20BB8 	4C  B A2  1 
;
1A20BBC 	58 46 A0  1 

: allocate-node-record  ( -- )
1A20BC0 	 0  0  0 61 6C 6C 6F 63 
1A20BC8 	61 74 65 2D 6E 6F 64 65 
1A20BD0 	2D 72 65 63 6F 72 64 94 
1A20BD8 	90  B A2  1 20 40 A0  1 
   \ Allocate user (RAM) space for  properties, "last" field, children, peers
   /devnode-extra  unaligned-ualloc drop
1A20BE0 	AC FA A1  1 A4 F9 A1  1 
1A20BE8 	30 49 A0  1 

   lastacf voc>phandle push-device           ( parent's-child-field )
1A20BEC 	AC 57 A0  1 
1A20BF0 	40 F8 A1  1 F8 FB A1  1 
;
1A20BF8 	58 46 A0  1 
: init-properties  ( -- )  (vocabulary)  lastacf 'properties token!  ;
1A20BFC 	69 6E 69 74 
1A20C00 	2D 70 72 6F 70 65 72 74 
1A20C08 	69 65 73 8F DC  B A2  1 
1A20C10 	20 40 A0  1 90  B A2  1 
1A20C18 	AC 57 A0  1 34 FA A1  1 
1A20C20 	20 54 A0  1 58 46 A0  1 

: init-node  ( #address-cells -- )
1A20C28 	 0  0 69 6E 69 74 2D 6E 
1A20C30 	6F 64 65 89 10  C A2  1 
1A20C38 	20 40 A0  1 
   allocate-node-record
1A20C3C 	DC  B A2  1 

  '#adr-cells !
1A20C40 	4C FA A1  1 54 4D A0  1 
  'child      !null-token      \ No children yet
1A20C48 	 8 FA A1  1 10 59 A0  1 
  'peer       !null-token      \ Null peer
1A20C50 	1C FA A1  1 10 59 A0  1 

   #fixed-vals  '#values    !  \ Initialize data sizes
1A20C58 	FC  3 A2  1 7C FA A1  1 
1A20C60 	54 4D A0  1 
   #fixed-bufs  '#buffers   !
1A20C64 	D0  4 A2  1 
1A20C68 	64 FA A1  1 54 4D A0  1 

   'values    !null-token      \ No initial data values yet
1A20C70 	90 FA A1  1 10 59 A0  1 

   init-properties
1A20C78 	10  C A2  1 
;
1A20C7C 	58 46 A0  1 

: current-properties  ( -- )  'properties token@  ;
1A20C80 	 0 63 75 72 72 65 6E 74 
1A20C88 	2D 70 72 6F 70 65 72 74 
1A20C90 	69 65 73 92 38  C A2  1 
1A20C98 	20 40 A0  1 34 FA A1  1 
1A20CA0 	 C 54 A0  1 58 46 A0  1 

headerless
: link-to-peer  ( parent's-child-field -- )
1A20CA8 	 0  0  0 6C 69 6E 6B 2D 
1A20CB0 	74 6F 2D 70 65 65 72 8C 
1A20CB8 	98  C A2  1 20 40 A0  1 
   dup token@ 'peer token!             ( parent's-child-field )
1A20CC0 	40 49 A0  1  C 54 A0  1 
1A20CC8 	1C FA A1  1 20 54 A0  1 
   current-device phandle>voc  swap token!         ( )
1A20CD0 	40 F9 A1  1 58 F8 A1  1 
1A20CD8 	68 49 A0  1 20 54 A0  1 
;
1A20CE0 	58 46 A0  1 
: device-node?  ( voc -- flag )
1A20CE4 	 0  0  0 64 
1A20CE8 	65 76 69 63 65 2D 6E 6F 
1A20CF0 	64 65 3F 8C BC  C A2  1 
1A20CF8 	20 40 A0  1 
   voc-link  begin  another-link?  while        ( voc link )
1A20CFC 	74 B6 A0  1 
1A20D00 	90 59 A0  1 DC 41 A0  1 
1A20D08 	30  0  0  0 
      2dup voc>  =  if  2drop false exit  then  ( voc link )
1A20D0C 	C0 49 A0  1 
1A20D10 	38 B6 A0  1 24 48 A0  1 
1A20D18 	DC 41 A0  1 10  0  0  0 
1A20D20 	AC 49 A0  1 18 70 A0  1 
1A20D28 	40 46 A0  1 
      >voc-link
1A20D2C 	50 B6 A0  1 
   repeat                                       ( voc )
1A20D30 	C8 41 A0  1 CC FF FF FF 
   drop true
1A20D38 	30 49 A0  1  4 70 A0  1 
;
1A20D40 	58 46 A0  1 

: $vexecute?  ( adr len voc-acf -- true | ??? false)
1A20D44 	 0 24 76 65 
1A20D48 	78 65 63 75 74 65 3F 8A 
1A20D50 	F8  C A2  1 20 40 A0  1 
   (search-wordlist)  if  execute false  else  true  then
1A20D58 	 0 BB A0  1 DC 41 A0  1 
1A20D60 	14  0  0  0 98 41 A0  1 
1A20D68 	18 70 A0  1 C8 41 A0  1 
1A20D70 	 8  0  0  0  4 70 A0  1 
;
1A20D78 	58 46 A0  1 
: $package-execute?  ( adr len phandle -- true | ??? false)
1A20D7C 	 0  0 24 70 
1A20D80 	61 63 6B 61 67 65 2D 65 
1A20D88 	78 65 63 75 74 65 3F 91 
1A20D90 	54  D A2  1 20 40 A0  1 
   phandle>voc (search-wordlist)  if  execute false  else  true  then
1A20D98 	58 F8 A1  1  0 BB A0  1 
1A20DA0 	DC 41 A0  1 14  0  0  0 
1A20DA8 	98 41 A0  1 18 70 A0  1 
1A20DB0 	C8 41 A0  1  8  0  0  0 
1A20DB8 	 4 70 A0  1 
;
1A20DBC 	58 46 A0  1 
: $vexecute  ( adr len voc-acf -- ?? )  $vexecute? drop  ;
1A20DC0 	 0  0 24 76 65 78 65 63 
1A20DC8 	75 74 65 89 94  D A2  1 
1A20DD0 	20 40 A0  1 54  D A2  1 
1A20DD8 	30 49 A0  1 58 46 A0  1 

headers
\ Used during compilation (probing), when the search order includes
\ the current vocabulary as well as the parent vocabularies.
: get-property  ( name-adr,len -- true | value-adr,len false )
1A20DE0 	 0  0  0 67 65 74 2D 70 
1A20DE8 	72 6F 70 65 72 74 79 8C 
1A20DF0 	D0  D A2  1 20 40 A0  1 
   current-properties (search-wordlist)  if  ( xt )
1A20DF8 	98  C A2  1  0 BB A0  1 
1A20E00 	DC 41 A0  1 24  0  0  0 
      >r r@ get  r> decode                   ( value-adr,len )
1A20E08 	BC 45 A0  1 E4 45 A0  1 
1A20E10 	D4 E7 A1  1 D0 45 A0  1 
1A20E18 	 8 E8 A1  1 
      false                                  ( value-adr,len false )
1A20E1C 	18 70 A0  1 
   else                                      ( )
1A20E20 	C8 41 A0  1  8  0  0  0 
      true                                   ( true )
1A20E28 	 4 70 A0  1 
   then
;
1A20E2C 	58 46 A0  1 

headerless
: #adr-cells  ( -- n )
1A20E30 	 0 23 61 64 72 2D 63 65 
1A20E38 	6C 6C 73 8A F4  D A2  1 
1A20E40 	20 40 A0  1 
   " #address-cells" get-property  if  2  else  get-encoded-int  then
1A20E44 	9C 53 A0  1 
1A20E48 	 E 23 61 64 64 72 65 73 
1A20E50 	73 2D 63 65 6C 6C 73  0 
1A20E58 	F4  D A2  1 DC 41 A0  1 
1A20E60 	10  0  0  0 90 6F A0  1 
1A20E68 	C8 41 A0  1  8  0  0  0 
1A20E70 	A0 F7 A1  1 
;
1A20E74 	58 46 A0  1 

headers
: new-node  ( -- )
1A20E78 	 0  0  0 6E 65 77 2D 6E 
1A20E80 	6F 64 65 88 40  E A2  1 
1A20E88 	20 40 A0  1 
   (vocabulary)  current-device phandle>voc a,  ( )  \ Up-link to parent device
1A20E8C 	90  B A2  1 
1A20E90 	40 F9 A1  1 58 F8 A1  1 
1A20E98 	AC 58 A0  1 

   \ Save parent linkage address on stack for later use
   'child                              ( parent's-child-field )
1A20E9C 	 8 FA A1  1 
   #adr-cells init-node                ( parent's-child-field )
1A20EA0 	40  E A2  1 38  C A2  1 
   link-to-peer                        ( )
1A20EA8 	BC  C A2  1 
;
1A20EAC 	58 46 A0  1 

: (clone)  ( template-phandle parent-phandle -- )
1A20EB0 	28 63 6C 6F 6E 65 29 87 
1A20EB8 	88  E A2  1 20 40 A0  1 
   (vocabulary)  a,                 ( template )  \ Up-link
1A20EC0 	90  B A2  1 AC 58 A0  1 

   \ Get pointers from template node
   push-package                        ( )
1A20EC8 	7C FB A1  1 
   current-properties >threads token@  ( props )
1A20ECC 	98  C A2  1 
1A20ED0 	EC 74 A0  1  C 54 A0  1 
   'threads                            ( props record )
1A20ED8 	F4 F9 A1  1 
   pop-package                         ( props record )
1A20EDC 	D8 FB A1  1 

   \ Inherit methods and initialized data
   allocate-node-record                ( props record )
1A20EE0 	DC  B A2  1 
   'threads /devnode-extra  /link #threads * +  move   ( props )
1A20EE4 	F4 F9 A1  1 
1A20EE8 	AC FA A1  1 78 73 A0  1 
1A20EF0 	48 B7 A0  1 1C 5F A0  1 
1A20EF8 	 4 45 A0  1 F4 4A A0  1 

   \ Inherit properties
   init-properties                     ( props )
1A20F00 	10  C A2  1 
   current-properties >threads token!  ( )
1A20F04 	98  C A2  1 
1A20F08 	EC 74 A0  1 20 54 A0  1 

   \ Don't inherit children
   'child      !null-token             ( )
1A20F10 	 8 FA A1  1 10 59 A0  1 

   parent-device push-package          ( )
1A20F18 	EC FA A1  1 7C FB A1  1 
   #adr-cells 'child                   ( #adr-cells parent's-child-field )
1A20F20 	40  E A2  1  8 FA A1  1 
   pop-package                         ( #adr-cells parent's-child-field )
1A20F28 	D8 FB A1  1 

   \ Attach the new node to its parent's list of children
   link-to-peer                        ( #adr-cells )
1A20F2C 	BC  C A2  1 

   \ Fix #adr-cells in case the template is under a node that doesn't have
   \ the right number of address cells (e.g. /templates).

   '#adr-cells !                       ( )
1A20F30 	4C FA A1  1 54 4D A0  1 

   extend-package                      ( )
1A20F38 	C0  9 A2  1 
;
1A20F3C 	58 46 A0  1 

\ Creates a copy of current-device, setting current-device to the new copy.
\ The new clone is located in the device tree as a peer of the package that
\ was copied.
\ See also "$clone-node" in instance.fth
: clone-node  ( -- )  current-device  parent-device  (clone)  ;
1A20F40 	 0 63 6C 6F 6E 65 2D 6E 
1A20F48 	6F 64 65 8A BC  E A2  1 
1A20F50 	20 40 A0  1 40 F9 A1  1 
1A20F58 	EC FA A1  1 BC  E A2  1 
1A20F60 	58 46 A0  1 

: new-device   ( -- )  new-node  prime-package  ;
1A20F64 	 0 6E 65 77 
1A20F68 	2D 64 65 76 69 63 65 8A 
1A20F70 	50  F A2  1 20 40 A0  1 
1A20F78 	88  E A2  1 78  9 A2  1 
1A20F80 	58 46 A0  1 

: device-end   ( -- )  only forth also definitions  package-level off  ;
1A20F84 	 0 64 65 76 
1A20F88 	69 63 65 2D 65 6E 64 8A 
1A20F90 	74  F A2  1 20 40 A0  1 
1A20F98 	88 C3 A0  1  8 C5 A0  1 
1A20FA0 	C8 C1 A0  1 2C C4 A0  1 
1A20FA8 	5C FC A1  1 F8 4B A0  1 
1A20FB0 	58 46 A0  1 
alias dend device-end
1A20FB4 	 0  0  0 64 
1A20FB8 	65 6E 64 A4 94  F A2  1 
1A20FC0 	94  F A2  1 

: my-#adr-cells  ( -- n )
1A20FC4 	 0  0 6D 79 
1A20FC8 	2D 23 61 64 72 2D 63 65 
1A20FD0 	6C 6C 73 8D C0  F A2  1 
1A20FD8 	20 40 A0  1 
   my-self  if	\ Use current instance's package if there is a current instance
1A20FDC 	EC 7E A0  1 
1A20FE0 	DC 41 A0  1 20  0  0  0 
      my-voc (push-package)  '#adr-cells @  (pop-package)
1A20FE8 	10  4 A2  1 38 FB A1  1 
1A20FF0 	4C FA A1  1 5C 4C A0  1 
1A20FF8 	5C FB A1  1 
   else		\ Otherwise use the active package
1A20FFC 	C8 41 A0  1 
1A21000 	 C  0  0  0 
      '#adr-cells @
1A21004 	4C FA A1  1 
1A21008 	5C 4C A0  1 
   then
;
1A2100C 	58 46 A0  1 

\ my-address applies to the current instance, regardless of whether or
\ not the active package corresponds to the current instance, thus it must
\ use my-#adr-cells, which explicitly refers to the current instance's
\ package.

: my-address  ( -- phys.lo .. )
1A21010 	 0 6D 79 2D 61 64 64 72 
1A21018 	65 73 73 8A D8  F A2  1 
1A21020 	20 40 A0  1 
   addr my-adr0  my-#adr-cells 1- 0 max /n* bounds  ?do  i @  /n +loop
1A21024 	5C B8 A1  1 
1A21028 	6C  3 A2  1 D8  F A2  1 
1A21030 	54 4B A0  1 70 6F A0  1 
1A21038 	9C 4A A0  1 98 51 A0  1 
1A21040 	F0 6D A0  1 50 42 A0  1 
1A21048 	18  0  0  0 B4 42 A0  1 
1A21050 	5C 4C A0  1 40 51 A0  1 
1A21058 	1C 42 A0  1 F0 FF FF FF 
;
1A21060 	58 46 A0  1 
: my-unit  ( -- phys.lo .. )
1A21064 	6D 79 2D 75 
1A21068 	6E 69 74 87 20 10 A2  1 
1A21070 	20 40 A0  1 
   addr my-unit-low  my-#adr-cells /n* bounds  ?do  i @  /n +loop
1A21074 	5C B8 A1  1 
1A21078 	B8  4 A2  1 D8  F A2  1 
1A21080 	98 51 A0  1 F0 6D A0  1 
1A21088 	50 42 A0  1 18  0  0  0 
1A21090 	B4 42 A0  1 5C 4C A0  1 
1A21098 	40 51 A0  1 1C 42 A0  1 
1A210A0 	F0 FF FF FF 
;
1A210A4 	58 46 A0  1 

vocabulary root-node
1A210A8 	 0  0 72 6F 6F 74 2D 6E 
1A210B0 	6F 64 65 89 70 10 A2  1 
1A210B8 	E0 B6 A0  1 4C  6  0  0 
1A210C0 	 0  0 A0  1 
 ' root-node TO LASTACFV \ MMO
   erase-voc-link  null ,   \ Root has no parent
   0 init-node
1A210C4 	E0 B6 A0  1 
1A210C8 	6C  6  0  0 
   allot-package-data
1A210CC 	 0  0  0  0 
1A210D0 	 0  0  0  0  0  0  0  0 
1A210D8 	 0  0  0  0  0  0  0  0 
1A210E0 	 0  0  0  0 
device-end
: root-phandle  ( -- ph )  ['] root-node voc>phandle  ;
1A210E4 	 0  0  0 72 
1A210E8 	6F 6F 74 2D 70 68 61 6E 
1A210F0 	64 6C 65 8C B8 10 A2  1 
1A210F8 	20 40 A0  1 60 53 A0  1 
1A21100 	B8 10 A2  1 40 F8 A1  1 
1A21108 	58 46 A0  1 

: root-device  ( -- )  only forth also  root-phandle push-device  ;
1A2110C 	72 6F 6F 74 
1A21110 	2D 64 65 76 69 63 65 8B 
1A21118 	F8 10 A2  1 20 40 A0  1 
1A21120 	88 C3 A0  1  8 C5 A0  1 
1A21128 	C8 C1 A0  1 F8 10 A2  1 
1A21130 	F8 FB A1  1 58 46 A0  1 

: root-device?  ( -- flag )  parent-device dt-null =  ;
1A21138 	 0  0  0 72 6F 6F 74 2D 
1A21140 	64 65 76 69 63 65 3F 8C 
1A21148 	1C 11 A2  1 20 40 A0  1 
1A21150 	EC FA A1  1 6C F8 A1  1 
1A21158 	24 48 A0  1 58 46 A0  1 

: finish-device  ( -- )  finish-package-data  pop-device  ;
1A21160 	 0  0 66 69 6E 69 73 68 
1A21168 	2D 64 65 76 69 63 65 8D 
1A21170 	4C 11 A2  1 20 40 A0  1 
1A21178 	40  A A2  1 18 FC A1  1 
1A21180 	58 46 A0  1 

: next-package  ( phandle -- phandle' )
1A21184 	 0  0  0 6E 
1A21188 	65 78 74 2D 70 61 63 6B 
1A21190 	61 67 65 8C 74 11 A2  1 
1A21198 	20 40 A0  1 
   push-package 'peer a@ pop-package   ( phandle phandle' )
1A2119C 	7C FB A1  1 
1A211A0 	1C FA A1  1 88 58 A0  1 
1A211A8 	D8 FB A1  1 
;
1A211AC 	58 46 A0  1 
: previous-link  ( phandle -- link-adr )
1A211B0 	 0  0 70 72 65 76 69 6F 
1A211B8 	75 73 2D 6C 69 6E 6B 8D 
1A211C0 	98 11 A2  1 20 40 A0  1 
   dup >r push-package             (                    R: phandle )
1A211C8 	40 49 A0  1 BC 45 A0  1 
1A211D0 	7C FB A1  1 
   root-device?  abort" Attempted to find the predecessor of the root package"
1A211D4 	4C 11 A2  1 
1A211D8 	 8 81 A0  1 35 41 74 74 
1A211E0 	65 6D 70 74 65 64 20 74 
1A211E8 	6F 20 66 69 6E 64 20 74 
1A211F0 	68 65 20 70 72 65 64 65 
1A211F8 	63 65 73 73 6F 72 20 6F 
1A21200 	66 20 74 68 65 20 72 6F 
1A21208 	6F 74 20 70 61 63 6B 61 
1A21210 	67 65  0  0 
   pop-device                      (                    R: phandle )
1A21214 	18 FC A1  1 
   'child   begin                  ( link               R: phandle )
1A21218 	 8 FA A1  1 
      dup a@                    ( link voc'          R: phandle )
1A2121C 	40 49 A0  1 
1A21220 	88 58 A0  1 
      dup r@ phandle>voc <>        ( link voc'          flag R: phandle )
1A21224 	40 49 A0  1 
1A21228 	E4 45 A0  1 58 F8 A1  1 
1A21230 	44 48 A0  1 
   while                           ( link phandle'      R: phandle )
1A21234 	DC 41 A0  1 
1A21238 	1C  0  0  0 
      voc>phandle push-device      ( link               R: phandle)
1A2123C 	40 F8 A1  1 
1A21240 	F8 FB A1  1 
      drop  'peer                  ( link'              R: phandle)
1A21244 	30 49 A0  1 
1A21248 	1C FA A1  1 
   repeat                          ( link phandle'      R: phandle )
1A2124C 	C8 41 A0  1 
1A21250 	CC FF FF FF 
   r> 2drop                        ( link )
1A21254 	D0 45 A0  1 
1A21258 	AC 49 A0  1 
   pop-package                     ( link )
1A2125C 	D8 FB A1  1 
;
1A21260 	58 46 A0  1 
: delete-package  ( phandle -- )
1A21264 	 0 64 65 6C 
1A21268 	65 74 65 2D 70 61 63 6B 
1A21270 	61 67 65 8E C4 11 A2  1 
1A21278 	20 40 A0  1 
   dup next-package  swap previous-link a!
1A2127C 	40 49 A0  1 
1A21280 	98 11 A2  1 68 49 A0  1 
1A21288 	C4 11 A2  1 98 58 A0  1 
;
1A21290 	58 46 A0  1 

\ The magic-device-types vocabulary contains words whose names are the
\ same as the names of the device_type property values that we wish to
\ recognize as special cases.  "device_type" in the "magic-properties"
\ vocabulary searches this vocabulary every time that a "device_type"
\ property is created, and executes the corresponding word if a match
\ is found.  That word may look at the property name and value on the
\ stack, but it must not remove them.  However, it might wish to alter
\ the value!

vocabulary magic-device-types
1A21294 	 0 6D 61 67 
1A21298 	69 63 2D 64 65 76 69 63 
1A212A0 	65 2D 74 79 70 65 73 92 
1A212A8 	78 12 A2  1 E0 B6 A0  1 
1A212B0 	70  6  0  0 90 E7 A1  1 
1A212B8 	 0  0  0  0 

\ The magic-properties vocabulary contains words whose names are the
\ same as the names of properties that we wish to recognize as special
\ cases.  "property" searches this vocabulary every time that an
\ property is created, and executes the corresponding word if a match
\ is found.  That word may look at the property name and value on the
\ stack, but it must not remove them.  However, it might wish to alter
\ either the name or the value!

headerless
false value autoloading?		\ Used to suppress probe reports
1A212BC 	 0  0  0 61 
1A212C0 	75 74 6F 6C 6F 61 64 69 
1A212C8 	6E 67 3F 8C AC 12 A2  1 
1A212D0 	50 40 A0  1 74  6  0  0 
headers

vocabulary magic-properties
1A212D8 	 0  0  0 6D 61 67 69 63 
1A212E0 	2D 70 72 6F 70 65 72 74 
1A212E8 	69 65 73 90 D0 12 A2  1 
1A212F0 	E0 B6 A0  1 78  6  0  0 
1A212F8 	AC 12 A2  1  0  0  0  0 

\ The parameter field of a property word contains:
\    offset size
\ Offset is the 32-bit positive distance from the beginning of the
\ property-encoded byte array to the parameter field address.  size is the
\ 16-bit size of the property value array.  This representation depends on
\ the fact that property-encoded arrays are stored in the dictionary.

: make-property-name  ( name-adr,len -- )
1A21300 	 0 6D 61 6B 65 2D 70 72 
1A21308 	6F 70 65 72 74 79 2D 6E 
1A21310 	61 6D 65 92 F0 12 A2  1 
1A21318 	20 40 A0  1 
   current token@ >r current-properties current token!
1A2131C 	F0 A3 A0  1 
1A21320 	 C 54 A0  1 BC 45 A0  1 
1A21328 	98  C A2  1 F0 A3 A0  1 
1A21330 	20 54 A0  1 
   $create
1A21334 	8C A2 A0  1 
   r> current token!
1A21338 	D0 45 A0  1 F0 A3 A0  1 
1A21340 	20 54 A0  1 
;
1A21344 	58 46 A0  1 

headerless
: change-property  ( value-adr,len property-acf -- )
1A21348 	63 68 61 6E 67 65 2D 70 
1A21350 	72 6F 70 65 72 74 79 8F 
1A21358 	18 13 A2  1 20 40 A0  1 
   \ Make a safe copy of the property value string if necessary
   >r  over in-dictionary?  0=  if  encode-bytes  then  r>
1A21360 	BC 45 A0  1 54 49 A0  1 
1A21368 	24 CF A0  1 24 47 A0  1 
1A21370 	DC 41 A0  1  8  0  0  0 
1A21378 	14 F6 A1  1 D0 45 A0  1 
   >body tuck na1+ !     ( value-adr property-apf )
1A21380 	E4 59 A0  1 E8 46 A0  1 
1A21388 	CC 50 A0  1 54 4D A0  1 
   dup rot - swap !      ( )
1A21390 	40 49 A0  1 7C 49 A0  1 
1A21398 	18 45 A0  1 68 49 A0  1 
1A213A0 	54 4D A0  1 
;
1A213A4 	58 46 A0  1 

headers
5 actions
1A213A8 	 8 14 A2  1 FC 13 A2  1 
1A213B0 	F4 13 A2  1 E4 13 A2  1 
1A213B8 	 5  0  0  0 
action:  dup dup @ -  swap na1+ @  ;
1A213BC 	90 90 90 E8 
1A213C0 	B8 2C FE FF 40 49 A0  1 
1A213C8 	40 49 A0  1 5C 4C A0  1 
1A213D0 	18 45 A0  1 68 49 A0  1 
1A213D8 	CC 50 A0  1 5C 4C A0  1 
1A213E0 	58 46 A0  1 
action:  body> change-property  ;
1A213E4 	20 40 A0  1 
1A213E8 	C8 59 A0  1 5C 13 A2  1 
1A213F0 	58 46 A0  1 
action:  ;
1A213F4 	20 40 A0  1 
1A213F8 	58 46 A0  1 
action:  drop  ;
1A213FC 	20 40 A0  1 
1A21400 	30 49 A0  1 58 46 A0  1 
action:  drop  ;
1A21408 	20 40 A0  1 30 49 A0  1 
1A21410 	58 46 A0  1 

action-adr-t dup h. to vproperty \ mmo

: (property)  ( value-adr,len  name-adr,len  -- )
1A21414 	 0 28 70 72 
1A21418 	6F 70 65 72 74 79 29 8A 
1A21420 	5C 13 A2  1 20 40 A0  1 
   caps @ >r  caps off
1A21428 	18 85 A0  1 5C 4C A0  1 
1A21430 	BC 45 A0  1 18 85 A0  1 
1A21438 	F8 4B A0  1 
   2dup  ['] magic-properties  $vexecute          ( value-str name-str )
1A2143C 	C0 49 A0  1 
1A21440 	60 53 A0  1 F0 12 A2  1 
1A21448 	D0  D A2  1 
   2dup current-properties (search-wordlist)  if  ( value-str name-str acf )
1A2144C 	C0 49 A0  1 
1A21450 	98  C A2  1  0 BB A0  1 
1A21458 	DC 41 A0  1 18  0  0  0 
      nip nip change-property                     ( )
1A21460 	FC 46 A0  1 FC 46 A0  1 
1A21468 	5C 13 A2  1 
   else                                           ( value-str name-str )
1A2146C 	C8 41 A0  1 
1A21470 	2C  0  0  0 
      make-property-name                          ( value-str )
1A21474 	18 13 A2  1 
      here rot - , ,  align use-actions           ( )
1A21478 	70 54 A0  1 7C 49 A0  1 
1A21480 	18 45 A0  1 98 55 A0  1 
1A21488 	98 55 A0  1 34 62 A0  1 
1A21490 	60 53 A0  1 BC 13 A2  1 
1A21498 	E0 57 A0  1 
   then                                           ( )
   r> caps !
1A2149C 	D0 45 A0  1 
1A214A0 	18 85 A0  1 54 4D A0  1 
;
1A214A8 	58 46 A0  1 

: property  ( value-adr,len  name-adr,len  -- )
1A214AC 	 0  0  0 70 
1A214B0 	72 6F 70 65 72 74 79 88 
1A214B8 	24 14 A2  1 20 40 A0  1 
   my-self if
1A214C0 	EC 7E A0  1 DC 41 A0  1 
1A214C8 	30  0  0  0 
      context token@ >r my-voc (select-package)
1A214CC 	DC A3 A0  1 
1A214D0 	 C 54 A0  1 BC 45 A0  1 
1A214D8 	10  4 A2  1 14 FB A1  1 
      (property)
1A214E0 	24 14 A2  1 
      r> context token!
1A214E4 	D0 45 A0  1 
1A214E8 	DC A3 A0  1 20 54 A0  1 
   else
1A214F0 	C8 41 A0  1  8  0  0  0 
      (property)
1A214F8 	24 14 A2  1 
   then
;
1A214FC 	58 46 A0  1 

: delete-property  ( name-adr,len -- )
1A21500 	64 65 6C 65 74 65 2D 70 
1A21508 	72 6F 70 65 72 74 79 8F 
1A21510 	BC 14 A2  1 20 40 A0  1 
   current-properties (search-wordlist)  if
1A21518 	98  C A2  1  0 BB A0  1 
1A21520 	DC 41 A0  1 10  0  0  0 
      >link current-properties  remove-word
1A21528 	EC 73 A0  1 98  C A2  1 
1A21530 	54 A4 A0  1 
   then
;
1A21534 	58 46 A0  1 
: forget  \ name  ( -- )
1A21538 	 0 66 6F 72 67 65 74 86 
1A21540 	14 15 A2  1 20 40 A0  1 
   current token@  device-node?  abort" Can't forget device methods"
1A21548 	F0 A3 A0  1  C 54 A0  1 
1A21550 	F8  C A2  1  8 81 A0  1 
1A21558 	1B 43 61 6E 27 74 20 66 
1A21560 	6F 72 67 65 74 20 64 65 
1A21568 	76 69 63 65 20 6D 65 74 
1A21570 	68 6F 64 73  0  0  0  0 
   forget
1A21578 	B0 BF A0  1 
;
1A2157C 	58 46 A0  1 

: get-unit  ( -- true | adr len false )  " reg" get-property  ;
1A21580 	 0  0  0 67 65 74 2D 75 
1A21588 	6E 69 74 88 44 15 A2  1 
1A21590 	20 40 A0  1 9C 53 A0  1 
1A21598 	 3 72 65 67  0  0  0  0 
1A215A0 	F4  D A2  1 58 46 A0  1 

headerless
: unit-str>phys-  ( adr len -- phys.hi .. phys.lo )
1A215A8 	 0 75 6E 69 74 2D 73 74 
1A215B0 	72 3E 70 68 79 73 2D 8E 
1A215B8 	90 15 A2  1 20 40 A0  1 
   '#adr-cells @  0  ?do  decode-int -rot  loop  2drop   ( phys.hi .. phys.lo )
1A215C0 	4C FA A1  1 5C 4C A0  1 
1A215C8 	70 6F A0  1 50 42 A0  1 
1A215D0 	14  0  0  0 68 F7 A1  1 
1A215D8 	94 49 A0  1 F8 41 A0  1 
1A215E0 	F4 FF FF FF AC 49 A0  1 
;
1A215E8 	58 46 A0  1 

: reorder  ( xn .. x1 n -- x1 .. xn )  0  ?do  i roll  loop  ;
1A215EC 	72 65 6F 72 
1A215F0 	64 65 72 87 BC 15 A2  1 
1A215F8 	20 40 A0  1 70 6F A0  1 
1A21600 	50 42 A0  1 14  0  0  0 
1A21608 	B4 42 A0  1 50 70 A0  1 
1A21610 	F8 41 A0  1 F4 FF FF FF 
1A21618 	58 46 A0  1 

: unit-str>phys  ( adr len -- phys.lo .. phys.hi )
1A2161C 	 0  0 75 6E 
1A21620 	69 74 2D 73 74 72 3E 70 
1A21628 	68 79 73 8D F8 15 A2  1 
1A21630 	20 40 A0  1 
   unit-str>phys-           ( phys.hi .. phys.lo )
1A21634 	BC 15 A2  1 
   '#adr-cells @  reorder   ( phys.lo .. phys.hi )
1A21638 	4C FA A1  1 5C 4C A0  1 
1A21640 	F8 15 A2  1 
;
1A21644 	58 46 A0  1 
headers

\ From breadth.fth
purpose: 

\ Tree searching code:
\ This implements a funny-order search of an n-ary tree.
\ First, all the child nodes at this level are searched.
\ If not found, then the first child node is made the current node
\ and the process is repeated recursively.  If that fails, the second
\ child node is selected, and so on.
\ All the descendents of the first node will thus be searched before
\ any of the descendents of the second node.
\ This is not quite a breadth-first search.

\ Interface to code in devtree.fth:
\   first-child   ( -- another? )
\       If current-node has a first child, sets current-node to that
\	child and returns true.
\   next-child    ( -- another? )
\	If current-node has a next peer, sets current-node to that peer
\	and returns true, else sets current-node to the parent of
\	current-node and returns false.
\
\ This rather strange interface turns out to be extremely convenient
\ to use in a loop over all children; e.g.
\
\       first-child  begin while   XXX   next-child repeat
\
\ where XXX is the code to be executed for each child.

headerless

: error:  \ name  ( -- )
1A21648 	 0 65 72 72 6F 72 3A 86 
1A21650 	30 16 A2  1 20 40 A0  1 
   create  does>
1A21658 	A8 A2 A0  1 50 A3 A0  1 
1A21660 	90 90 90 E8 14 2A FE FF 
;
1A21668 	58 46 A0  1 

error: found      ," "
1A2166C 	 0  0 66 6F 
1A21670 	75 6E 64 85 54 16 A2  1 
1A21678 	60 16 A2  1  0  0  0  0 
error: not-found  ," Device not found"
1A21680 	 0  0 6E 6F 74 2D 66 6F 
1A21688 	75 6E 64 89 78 16 A2  1 
1A21690 	60 16 A2  1 10 44 65 76 
1A21698 	69 63 65 20 6E 6F 74 20 
1A216A0 	66 6F 75 6E 64  0  0  0 

: (search-level)  ( ? acf -- ? acf )
1A216A8 	 0 28 73 65 61 72 63 68 
1A216B0 	2D 6C 65 76 65 6C 29 8E 
1A216B8 	90 16 A2  1 20 40 A0  1 
   first-child  begin while                ( ? acf )
1A216C0 	 4  B A2  1 DC 41 A0  1 
1A216C8 	40  0  0  0 

      dup catch  ?dup  if                  ( ? acf error )
1A216CC 	40 49 A0  1 
1A216D0 	14 7F A0  1 B4 70 A0  1 
1A216D8 	DC 41 A0  1 10  0  0  0 
         .error                            ( ? acf )
1A216E0 	70 CF A0  1 
      else                                 ( ? acf found? )
1A216E4 	C8 41 A0  1 
1A216E8 	14  0  0  0 
         if  found throw  then             ( ? acf )
1A216EC 	DC 41 A0  1 
1A216F0 	 C  0  0  0 78 16 A2  1 
1A216F8 	74 7F A0  1 
      then

   next-child repeat                       ( ? acf )
1A216FC 	24  B A2  1 
1A21700 	C8 41 A0  1 C0 FF FF FF 
;
1A21708 	58 46 A0  1 

: (search-preorder)  ( ? acf -- ? acf )   recursive
1A2170C 	 0  0 28 73 
1A21710 	65 61 72 63 68 2D 70 72 
1A21718 	65 6F 72 64 65 72 29 91 
1A21720 	BC 16 A2  1 20 40 A0  1 
   (search-level)
1A21728 	BC 16 A2  1 

   first-child  begin while  (search-preorder)  next-child repeat
1A2172C 	 4  B A2  1 
1A21730 	DC 41 A0  1 14  0  0  0 
1A21738 	24 17 A2  1 24  B A2  1 
1A21740 	C8 41 A0  1 EC FF FF FF 
;
1A21748 	58 46 A0  1 

: invert-signal  ( ? acf -- ? acf )
1A2174C 	 0  0 69 6E 
1A21750 	76 65 72 74 2D 73 69 67 
1A21758 	6E 61 6C 8D 24 17 A2  1 
1A21760 	20 40 A0  1 
   catch  case
1A21764 	14 7F A0  1 
      0     of     not-found throw    endof
1A21768 	70 6F A0  1 48 43 A0  1 
1A21770 	14  0  0  0 90 16 A2  1 
1A21778 	74 7F A0  1 6C 43 A0  1 
1A21780 	20  0  0  0 
      found of                        endof
1A21784 	78 16 A2  1 
1A21788 	48 43 A0  1  C  0  0  0 
1A21790 	6C 43 A0  1  C  0  0  0 
      ( default )  throw
1A21798 	74 7F A0  1 
   endcase
1A2179C 	84 43 A0  1 
;
1A217A0 	58 46 A0  1 
: search-preorder  ( ? acf -- ? acf )  ['] (search-preorder)  invert-signal  ;
1A217A4 	73 65 61 72 
1A217A8 	63 68 2D 70 72 65 6F 72 
1A217B0 	64 65 72 8F 60 17 A2  1 
1A217B8 	20 40 A0  1 60 53 A0  1 
1A217C0 	24 17 A2  1 60 17 A2  1 
1A217C8 	58 46 A0  1 
: search-level     ( ? acf -- ? acf )  ['] (search-level)     invert-signal  ;
1A217CC 	 0  0  0 73 
1A217D0 	65 61 72 63 68 2D 6C 65 
1A217D8 	76 65 6C 8C B8 17 A2  1 
1A217E0 	20 40 A0  1 60 53 A0  1 
1A217E8 	BC 16 A2  1 60 17 A2  1 
1A217F0 	58 46 A0  1 
headers

\ From finddev.fth
purpose: 

vocabulary aliases
1A217F4 	61 6C 69 61 
1A217F8 	73 65 73 87 E0 17 A2  1 
1A21800 	E0 B6 A0  1 7C  6  0  0 
1A21808 	F0 12 A2  1  0  0  0  0 

4 /n* buffer: unit#
1A21810 	 0  0 75 6E 69 74 23 85 
1A21818 	 0 18 A2  1 B4 A9 A0  1 
1A21820 	80  6  0  0 10  0  0  0 
1A21828 	BC D4 A1  1 

headerless
0 value unit#-valid?
1A2182C 	 0  0  0 75 
1A21830 	6E 69 74 23 2D 76 61 6C 
1A21838 	69 64 3F 8C 1C 18 A2  1 
1A21840 	50 40 A0  1 84  6  0  0 
: unit-bounds  ( -- end-adr start-adr )  unit#  '#adr-cells @ /n*  bounds  ;
1A21848 	75 6E 69 74 2D 62 6F 75 
1A21850 	6E 64 73 8B 40 18 A2  1 
1A21858 	20 40 A0  1 1C 18 A2  1 
1A21860 	4C FA A1  1 5C 4C A0  1 
1A21868 	98 51 A0  1 F0 6D A0  1 
1A21870 	58 46 A0  1 

: "name" ( -- adr,len )  " name"  ;  \ Space savings
1A21874 	 0 22 6E 61 
1A21878 	6D 65 22 86 58 18 A2  1 
1A21880 	20 40 A0  1 9C 53 A0  1 
1A21888 	 4 6E 61 6D 65  0  0  0 
1A21890 	58 46 A0  1 

\ True if "name$" matches the node's name
: name-match?  ( name$ -- name$ flag )
1A21894 	6E 61 6D 65 
1A21898 	2D 6D 61 74 63 68 3F 8B 
1A218A0 	80 18 A2  1 20 40 A0  1 
   "name" get-property  if                  ( name$ )
1A218A8 	80 18 A2  1 F4  D A2  1 
1A218B0 	DC 41 A0  1 10  0  0  0 
      false                                 ( name$ false )
1A218B8 	18 70 A0  1 
   else                                     ( name$ adr' len' )
1A218BC 	C8 41 A0  1 
1A218C0 	44  0  0  0 
      1-    \ Omit null byte 		    ( name$ adr' len' )
1A218C4 	54 4B A0  1 
      2over 2over  $=  if                   ( name$ adr' len' )
1A218C8 	D8 49 A0  1 D8 49 A0  1 
1A218D0 	88 8D A0  1 DC 41 A0  1 
1A218D8 	14  0  0  0 
         2drop true                         ( name$ true )
1A218DC 	AC 49 A0  1 
1A218E0 	 4 70 A0  1 
      else                                  ( name$ adr' len' )
1A218E4 	C8 41 A0  1 
1A218E8 	1C  0  0  0 
         \ Omit the manufacturer name and test again
         ascii , left-parse-string  2drop  2over  $=
1A218EC 	58 41 A0  1 
1A218F0 	2C  0  0  0 44 D7 A0  1 
1A218F8 	AC 49 A0  1 D8 49 A0  1 
1A21900 	88 8D A0  1 
      then
   then                                     ( name$ flag )
;
1A21904 	58 46 A0  1 

\ True if "unit-adr,space" matches the node's unit number
: unit-match?  ( -- flag )
1A21908 	75 6E 69 74 2D 6D 61 74 
1A21910 	63 68 3F 8B A4 18 A2  1 
1A21918 	20 40 A0  1 
   get-unit  if                 ( )
1A2191C 	90 15 A2  1 
1A21920 	DC 41 A0  1 10  0  0  0 
      false  	                ( flag )  \ No "reg" property
1A21928 	18 70 A0  1 
   else                         ( phys.lo .. phys.hi )
1A2192C 	C8 41 A0  1 
1A21930 	48  0  0  0 
      true                      ( unit-adr,len )
1A21934 	 4 70 A0  1 
      unit-bounds  ?do          ( unit-adr,len  flag )
1A21938 	58 18 A2  1 50 42 A0  1 
1A21940 	30  0  0  0 
         -rot  decode-int       ( flag  unit-adr,len' n )
1A21944 	94 49 A0  1 
1A21948 	68 F7 A1  1 
	 i @ =  3 roll and      ( unit-adr,len' flag' )
1A2194C 	B4 42 A0  1 
1A21950 	5C 4C A0  1 24 48 A0  1 
1A21958 	A0 6F A0  1 50 70 A0  1 
1A21960 	5C 44 A0  1 
      /n +loop                  ( unit-adr,len' flag )
1A21964 	40 51 A0  1 
1A21968 	1C 42 A0  1 D8 FF FF FF 
      nip nip                   ( flag )
1A21970 	FC 46 A0  1 FC 46 A0  1 
   then                         ( flag )
;
1A21978 	58 46 A0  1 

headerless
create bad-number ," Bad number syntax"
1A2197C 	 0 62 61 64 
1A21980 	2D 6E 75 6D 62 65 72 8A 
1A21988 	18 19 A2  1 30 40 A0  1 
1A21990 	11 42 61 64 20 6E 75 6D 
1A21998 	62 65 72 20 73 79 6E 74 
1A219A0 	61 78  0  0 
: safe->number  ( adr len -- n )  $number  if  bad-number throw  then  ;
1A219A4 	 0  0  0 73 
1A219A8 	61 66 65 2D 3E 6E 75 6D 
1A219B0 	62 65 72 8C 8C 19 A2  1 
1A219B8 	20 40 A0  1 40 FE A0  1 
1A219C0 	DC 41 A0  1  C  0  0  0 
1A219C8 	8C 19 A2  1 74 7F A0  1 
1A219D0 	58 46 A0  1 

headers
: package-execute  ( ?? adr len -- ?? )
1A219D4 	70 61 63 6B 
1A219D8 	61 67 65 2D 65 78 65 63 
1A219E0 	75 74 65 8F B8 19 A2  1 
1A219E8 	20 40 A0  1 
   current-device $package-execute?  abort" Package method not found"
1A219EC 	40 F9 A1  1 
1A219F0 	94  D A2  1  8 81 A0  1 
1A219F8 	18 50 61 63 6B 61 67 65 
1A21A00 	20 6D 65 74 68 6F 64 20 
1A21A08 	6E 6F 74 20 66 6F 75 6E 
1A21A10 	64  0  0  0 
;
1A21A14 	58 46 A0  1 
headerless

\ True if the node has no unit number and "name$" matches the node's name
: wildcard-match?  ( name$ acf -- name$ acf flag )
1A21A18 	77 69 6C 64 63 61 72 64 
1A21A20 	2D 6D 61 74 63 68 3F 8F 
1A21A28 	E8 19 A2  1 20 40 A0  1 
   >r
1A21A30 	BC 45 A0  1 
   dup  if
1A21A34 	40 49 A0  1 
1A21A38 	DC 41 A0  1 20  0  0  0 
      name-match?  0=  if  r> false  exit  then
1A21A40 	A4 18 A2  1 24 47 A0  1 
1A21A48 	DC 41 A0  1 10  0  0  0 
1A21A50 	D0 45 A0  1 18 70 A0  1 
1A21A58 	40 46 A0  1 
   then                                                   ( name$ )

   get-unit  0=  if  2drop  r> false  exit  then          ( name$ )
1A21A5C 	90 15 A2  1 
1A21A60 	24 47 A0  1 DC 41 A0  1 
1A21A68 	14  0  0  0 AC 49 A0  1 
1A21A70 	D0 45 A0  1 18 70 A0  1 
1A21A78 	40 46 A0  1 

   dup 0=  unit#-valid? 0=  and  if  r> false  exit  then
1A21A7C 	40 49 A0  1 
1A21A80 	24 47 A0  1 40 18 A2  1 
1A21A88 	24 47 A0  1 5C 44 A0  1 
1A21A90 	DC 41 A0  1 10  0  0  0 
1A21A98 	D0 45 A0  1 18 70 A0  1 
1A21AA0 	40 46 A0  1 

   r> true
1A21AA4 	D0 45 A0  1 
1A21AA8 	 4 70 A0  1 
;
1A21AAC 	58 46 A0  1 

: exact-match?  ( name$ acf -- name$ acf flag )
1A21AB0 	 0  0  0 65 78 61 63 74 
1A21AB8 	2D 6D 61 74 63 68 3F 8C 
1A21AC0 	2C 1A A2  1 20 40 A0  1 
   >r
1A21AC8 	BC 45 A0  1 
   dup  if                              ( name$ )       \ Name present
1A21ACC 	40 49 A0  1 
1A21AD0 	DC 41 A0  1 20  0  0  0 
      name-match?  0=  if  r> false  exit  then
1A21AD8 	A4 18 A2  1 24 47 A0  1 
1A21AE0 	DC 41 A0  1 10  0  0  0 
1A21AE8 	D0 45 A0  1 18 70 A0  1 
1A21AF0 	40 46 A0  1 
   then                                 ( name$ )
   unit#-valid?  if                     ( name$ )       \ Unit present
1A21AF4 	40 18 A2  1 
1A21AF8 	DC 41 A0  1 20  0  0  0 
      unit-match?  0=  if  r> false  exit  then
1A21B00 	18 19 A2  1 24 47 A0  1 
1A21B08 	DC 41 A0  1 10  0  0  0 
1A21B10 	D0 45 A0  1 18 70 A0  1 
1A21B18 	40 46 A0  1 
   then
   r> true
1A21B1C 	D0 45 A0  1 
1A21B20 	 4 70 A0  1 
;
1A21B24 	58 46 A0  1 

\ 1) Search direct children for an exact match
\ 2) Search direct children for a wildcard match
\ 3) Select each child node in turn and (recursively) repeat steps
\    (1), (2), and (3)

: (find-node)  ( unit$ name$ -- unit$ name$ )
1A21B28 	28 66 69 6E 64 2D 6E 6F 
1A21B30 	64 65 29 8B C4 1A A2  1 
1A21B38 	20 40 A0  1 

   \ If the node has no children, then there is no point in searching it,
   \ and it doesn't matter if it has no decode-unit method
   first-child  0=  if  exit  then  pop-device
1A21B3C 	 4  B A2  1 
1A21B40 	24 47 A0  1 DC 41 A0  1 
1A21B48 	 8  0  0  0 40 46 A0  1 
1A21B50 	18 FC A1  1 

   unit#-valid?  if		\ Omit unit match test if no unit string
1A21B54 	40 18 A2  1 
1A21B58 	DC 41 A0  1 68  0  0  0 
      2over " decode-unit"           ( unit$ name$  unit$ method$ )
1A21B60 	D8 49 A0  1 9C 53 A0  1 
1A21B68 	 B 64 65 63 6F 64 65 2D 
1A21B70 	75 6E 69 74  0  0  0  0 

      ['] package-execute catch  if  ( unit$ name$  x x x x )
1A21B78 	60 53 A0  1 E8 19 A2  1 
1A21B80 	14 7F A0  1 DC 41 A0  1 
1A21B88 	10  0  0  0 
         \ If decode-unit aborted, a match at this level is impossible 
         2drop 2drop exit
1A21B8C 	AC 49 A0  1 
1A21B90 	AC 49 A0  1 40 46 A0  1 
      then                           ( unit$ name$ phys.lo .. phys.hi )

      \ We can't use unit-bounds here
      unit# #adr-cells /n*  bounds  ?do  i !  /n +loop   ( unit$ name$ )
1A21B98 	1C 18 A2  1 40  E A2  1 
1A21BA0 	98 51 A0  1 F0 6D A0  1 
1A21BA8 	50 42 A0  1 18  0  0  0 
1A21BB0 	B4 42 A0  1 54 4D A0  1 
1A21BB8 	40 51 A0  1 1C 42 A0  1 
1A21BC0 	F0 FF FF FF 
   then

   \ (search-level) will throw "found" to (find-device) if it succeeds
   ['] exact-match?     (search-level)  drop             ( unit$ name$ )
1A21BC4 	60 53 A0  1 
1A21BC8 	C4 1A A2  1 BC 16 A2  1 
1A21BD0 	30 49 A0  1 
   ['] wildcard-match?  (search-level)  drop             ( unit$ name$ )
1A21BD4 	60 53 A0  1 
1A21BD8 	2C 1A A2  1 BC 16 A2  1 
1A21BE0 	30 49 A0  1 
;
1A21BE4 	58 46 A0  1 

: (find-child-node)  ( unit$ name$ -- unit$ name$ ) recursive
1A21BE8 	 0  0 28 66 69 6E 64 2D 
1A21BF0 	63 68 69 6C 64 2D 6E 6F 
1A21BF8 	64 65 29 91 38 1B A2  1 
1A21C00 	20 40 A0  1 
   first-child  begin while   (find-node) (find-child-node)  next-child repeat
1A21C04 	 4  B A2  1 
1A21C08 	DC 41 A0  1 18  0  0  0 
1A21C10 	38 1B A2  1  0 1C A2  1 
1A21C18 	24  B A2  1 C8 41 A0  1 
1A21C20 	E8 FF FF FF 
;
1A21C24 	58 46 A0  1 

: find-component  ( component$ -- )
1A21C28 	 0 66 69 6E 64 2D 63 6F 
1A21C30 	6D 70 6F 6E 65 6E 74 8E 
1A21C38 	 0 1C A2  1 20 40 A0  1 
   \ Separate out arguments
   ascii : left-parse-string            ( args-str name.unit$ )
1A21C40 	58 41 A0  1 3A  0  0  0 
1A21C48 	44 D7 A0  1 

   \ Arguments only apply to "open", so discard them when searching
   2swap 2drop                              ( name.unit$ )
1A21C4C 	F4 49 A0  1 
1A21C50 	AC 49 A0  1 

   \ Split name and unit
   ascii @  left-parse-string               ( unit$ name$ )
1A21C54 	58 41 A0  1 
1A21C58 	40  0  0  0 44 D7 A0  1 

   2 pick is unit#-valid?                   ( unit$ name$ )
1A21C60 	90 6F A0  1  C 4A A0  1 
1A21C68 	B8 40 A0  1 40 18 A2  1 

   ['] (find-node)  catch  ?dup  if         ( unit$ name$ error )
1A21C70 	60 53 A0  1 38 1B A2  1 
1A21C78 	14 7F A0  1 B4 70 A0  1 
1A21C80 	DC 41 A0  1 30  0  0  0 
       dup found <>  if                     ( unit$ name$ error )
1A21C88 	40 49 A0  1 78 16 A2  1 
1A21C90 	44 48 A0  1 DC 41 A0  1 
1A21C98 	10  0  0  0 
           dup .error throw
1A21C9C 	40 49 A0  1 
1A21CA0 	70 CF A0  1 74 7F A0  1 
       then                                 ( unit$ name$ error )
       drop                                 ( unit$ name$ )
1A21CA8 	30 49 A0  1 
   else                                     ( unit$ name$ )
1A21CAC 	C8 41 A0  1 
1A21CB0 	10  0  0  0 
       ['] (find-child-node)  invert-signal ( unit$ name$ )
1A21CB4 	60 53 A0  1 
1A21CB8 	 0 1C A2  1 60 17 A2  1 
   then                                     ( unit$ name$ )

   2drop 2drop                              ( )
1A21CC0 	AC 49 A0  1 AC 49 A0  1 
;
1A21CC8 	58 46 A0  1 
: (find-device)  ( str -- )
1A21CCC 	 0  0 28 66 
1A21CD0 	69 6E 64 2D 64 65 76 69 
1A21CD8 	63 65 29 8D 3C 1C A2  1 
1A21CE0 	20 40 A0  1 

   0 to unit#-valid?
1A21CE4 	70 6F A0  1 
1A21CE8 	B8 40 A0  1 40 18 A2  1 

   \ If a search path is present, find the indicated subdirectory
   begin  dup  while        ( rem$ )
1A21CF0 	40 49 A0  1 DC 41 A0  1 
1A21CF8 	44  0  0  0 

      \ Split the remaining string at the first backslash, if there is one
      ascii / left-parse-string            ( rem$' component$ )
1A21CFC 	58 41 A0  1 
1A21D00 	2F  0  0  0 44 D7 A0  1 

      dup  if                              ( rem$ component$ )
1A21D08 	40 49 A0  1 DC 41 A0  1 
1A21D10 	10  0  0  0 
         find-component                    ( rem$ )
1A21D14 	3C 1C A2  1 
      else                                 ( rem$ component$ )
1A21D18 	C8 41 A0  1 18  0  0  0 
         \ If the component name string is null, there was a double slash,
         \ indicating an interposed support package.  Skip it.
         2drop                             ( rem$ )
1A21D20 	AC 49 A0  1 
         ascii / left-parse-string  2drop  ( rem$' )
1A21D24 	58 41 A0  1 
1A21D28 	2F  0  0  0 44 D7 A0  1 
1A21D30 	AC 49 A0  1 
      then                                 ( rem$ )

   repeat                   ( rem$ )
1A21D34 	C8 41 A0  1 
1A21D38 	B8 FF FF FF 

   2drop
1A21D3C 	AC 49 A0  1 
;
1A21D40 	58 46 A0  1 

: not-alias?  ( str -- expansion$ false | true )
1A21D44 	 0 6E 6F 74 
1A21D48 	2D 61 6C 69 61 73 3F 8A 
1A21D50 	E0 1C A2  1 20 40 A0  1 
   \ Search the alias list.
   ['] aliases (search-wordlist)  if  execute false  else  true  then
1A21D58 	60 53 A0  1  0 18 A2  1 
1A21D60 	 0 BB A0  1 DC 41 A0  1 
1A21D68 	14  0  0  0 98 41 A0  1 
1A21D70 	18 70 A0  1 C8 41 A0  1 
1A21D78 	 8  0  0  0  4 70 A0  1 
;
1A21D80 	58 46 A0  1 

headerless
\ Ultimately, we need a more robust way to manage the alias buffer.
\ One approach would be to use a two-entry ping-pong buffer.  In every
\ place where "?expand-alias" or "aliased?" is called, save the buffer
\ specification and allocate a new two-entry buffer.  When the buffer
\ is no longer needed, free the buffer and restore the previous one.
\ That will be a little tricky, since they are used in several places,
\ both in this directory and also in pkg/*/*th.
h# 800 buffer: (alias-buf)
1A21D84 	28 61 6C 69 
1A21D88 	61 73 2D 62 75 66 29 8B 
1A21D90 	54 1D A2  1 B4 A9 A0  1 
1A21D98 	88  6  0  0  0  8  0  0 
1A21DA0 	1C 18 A2  1 
0 value alias-buf-offset
1A21DA4 	 0  0  0 61 
1A21DA8 	6C 69 61 73 2D 62 75 66 
1A21DB0 	2D 6F 66 66 73 65 74 90 
1A21DB8 	94 1D A2  1 50 40 A0  1 
1A21DC0 	8C  6  0  0 
: alias-buf  ( -- adr )  (alias-buf) alias-buf-offset +  ;
1A21DC4 	 0  0 61 6C 
1A21DC8 	69 61 73 2D 62 75 66 89 
1A21DD0 	BC 1D A2  1 20 40 A0  1 
1A21DD8 	94 1D A2  1 BC 1D A2  1 
1A21DE0 	 4 45 A0  1 58 46 A0  1 
: switch-alias-buf  ( -- )
1A21DE8 	 0  0  0 73 77 69 74 63 
1A21DF0 	68 2D 61 6C 69 61 73 2D 
1A21DF8 	62 75 66 90 D4 1D A2  1 
1A21E00 	20 40 A0  1 
   alias-buf-offset  h# 100 +  h# 7ff and  to alias-buf-offset
1A21E04 	BC 1D A2  1 
1A21E08 	58 41 A0  1  0  1  0  0 
1A21E10 	 4 45 A0  1 58 41 A0  1 
1A21E18 	FF  7  0  0 5C 44 A0  1 
1A21E20 	B8 40 A0  1 BC 1D A2  1 
;
1A21E28 	58 46 A0  1 

\ Expands devaliases optionally overwriting the default argument
\ to the rightmost component of the expanded pathname
: expand-alias  ( devspec$ -- pathname$ flag )
1A21E2C 	 0  0  0 65 
1A21E30 	78 70 61 6E 64 2D 61 6C 
1A21E38 	69 61 73 8C  0 1E A2  1 
1A21E40 	20 40 A0  1 
   switch-alias-buf
1A21E44 	 0 1E A2  1 
   \ Extract the part of the pathname that can be an alias

   2dup  ascii /  split-before  ( devspec$ tail$ head$ )
1A21E48 	C0 49 A0  1 58 41 A0  1 
1A21E50 	2F  0  0  0 20 19 A1  1 
   ascii :  split-before        ( devspec$ tail$ arg$ name$ )
1A21E58 	58 41 A0  1 3A  0  0  0 
1A21E60 	20 19 A1  1 

   \ If the device-specifier is not an alias, return it unmodified.

   not-alias?  if               ( devspec$ tail$ arg$ )
1A21E64 	54 1D A2  1 
1A21E68 	DC 41 A0  1 14  0  0  0 
      2drop 2drop false  exit   ( devspec$ )
1A21E70 	AC 49 A0  1 AC 49 A0  1 
1A21E78 	18 70 A0  1 40 46 A0  1 
   then                         ( devspec$ tail$ arg$ expansion$ )

   \ The device-specifier is an alias.

   \ If the aliased component of the device-specifier had explicit
   \ arguments, use them to override any arguments that were included
   \ in the alias expansion.

   2 pick  if                   ( devspec$ tail$ arg$ expansion$ )
1A21E80 	90 6F A0  1  C 4A A0  1 
1A21E88 	DC 41 A0  1 40  0  0  0 
      \ alias name has args
      ascii / split-after       ( devspec$ tail$ arg$ alias-tail$ alias-head$ )
1A21E90 	58 41 A0  1 2F  0  0  0 
1A21E98 	BC 19 A1  1 
      alias-buf place           ( devspec$ tail$ arg$ alias-tail$ )
1A21E9C 	D4 1D A2  1 
1A21EA0 	F0 88 A0  1 
      ascii : split-before      ( devspec$ tail$ arg$ $deadargs $alias-tail$' )
1A21EA4 	58 41 A0  1 
1A21EA8 	3A  0  0  0 20 19 A1  1 
      alias-buf $cat            ( devspec$ tail$ arg$ $deadargs )
1A21EB0 	D4 1D A2  1 84 7E A0  1 
      2drop  alias-buf $cat     ( devspec$ tail$ )
1A21EB8 	AC 49 A0  1 D4 1D A2  1 
1A21EC0 	84 7E A0  1 
   else                         ( devspec$ tail$ arg$ expansion$ )
1A21EC4 	C8 41 A0  1 
1A21EC8 	10  0  0  0 
      \ alias name does not have args
      alias-buf place           ( devspec$ tail$ arg$ )
1A21ECC 	D4 1D A2  1 
1A21ED0 	F0 88 A0  1 
      2drop                     ( devspec$ tail$ )
1A21ED4 	AC 49 A0  1 
   then                         ( devspec$ tail$ )

   \ Append the tail of the device specifier to the expanded alias

   alias-buf $cat               ( devspec$ )
1A21ED8 	D4 1D A2  1 84 7E A0  1 
   2drop                        ( devspec$ )
1A21EE0 	AC 49 A0  1 
   alias-buf count  true        ( pathname$ true )
1A21EE4 	D4 1D A2  1 
1A21EE8 	BC 53 A0  1  4 70 A0  1 
;
1A21EF0 	58 46 A0  1 
: aliased?  ( name-str -- name-str false | alias-expansion-str true )
1A21EF4 	 0  0  0 61 
1A21EF8 	6C 69 61 73 65 64 3F 88 
1A21F00 	40 1E A2  1 20 40 A0  1 
   \ The empty string is not an alias
   dup 0=  if  false exit  then               ( str )
1A21F08 	40 49 A0  1 24 47 A0  1 
1A21F10 	DC 41 A0  1  C  0  0  0 
1A21F18 	18 70 A0  1 40 46 A0  1 

   \ A pathname beginning with a slash is not an alias
   over c@  ascii / =  if  false exit  then   ( str )
1A21F20 	54 49 A0  1 C4 4C A0  1 
1A21F28 	58 41 A0  1 2F  0  0  0 
1A21F30 	24 48 A0  1 DC 41 A0  1 
1A21F38 	 C  0  0  0 18 70 A0  1 
1A21F40 	40 46 A0  1 

   d# 100  0  do                              ( str )
1A21F44 	58 41 A0  1 
1A21F48 	64  0  0  0 70 6F A0  1 
1A21F50 	88 42 A0  1 38  0  0  0 
      expand-alias  0=  if                    ( str )
1A21F58 	40 1E A2  1 24 47 A0  1 
1A21F60 	DC 41 A0  1 20  0  0  0 
         \ The result has been expanded if the first character
         \ is now a "/"
         over c@  [char] / =                  ( str flag )
1A21F68 	54 49 A0  1 C4 4C A0  1 
1A21F70 	58 41 A0  1 2F  0  0  0 
1A21F78 	24 48 A0  1 
         unloop exit
1A21F7C 	3C 42 A0  1 
1A21F80 	40 46 A0  1 
      then                                    ( str )
   loop
1A21F84 	F8 41 A0  1 
1A21F88 	D0 FF FF FF 
   true abort" Too many levels of aliasing"
1A21F8C 	 4 70 A0  1 
1A21F90 	 8 81 A0  1 1B 54 6F 6F 
1A21F98 	20 6D 61 6E 79 20 6C 65 
1A21FA0 	76 65 6C 73 20 6F 66 20 
1A21FA8 	61 6C 69 61 73 69 6E 67 
1A21FB0 	 0  0  0  0 
;
1A21FB4 	58 46 A0  1 
: ?expand-alias  ( name-str -- name-str | alias-expansion-str )
1A21FB8 	 0  0 3F 65 78 70 61 6E 
1A21FC0 	64 2D 61 6C 69 61 73 8D 
1A21FC8 	 4 1F A2  1 20 40 A0  1 
   aliased? drop
1A21FD0 	 4 1F A2  1 30 49 A0  1 
;
1A21FD8 	58 46 A0  1 

: context-voc?  ( voc-acf -- flag )  context token@ =  ;
1A21FDC 	 0  0  0 63 
1A21FE0 	6F 6E 74 65 78 74 2D 76 
1A21FE8 	6F 63 3F 8C CC 1F A2  1 
1A21FF0 	20 40 A0  1 DC A3 A0  1 
1A21FF8 	 C 54 A0  1 24 48 A0  1 
1A22000 	58 46 A0  1 
: device-context?  ( -- flag )  ['] context-voc? find-voc  0=  ;
1A22004 	64 65 76 69 
1A22008 	63 65 2D 63 6F 6E 74 65 
1A22010 	78 74 3F 8F F0 1F A2  1 
1A22018 	20 40 A0  1 60 53 A0  1 
1A22020 	F0 1F A2  1 60 B7 A0  1 
1A22028 	24 47 A0  1 58 46 A0  1 

: ?not-found  ( flag -- )  if  not-found throw  then  ;
1A22030 	 0 3F 6E 6F 74 2D 66 6F 
1A22038 	75 6E 64 8A 18 20 A2  1 
1A22040 	20 40 A0  1 DC 41 A0  1 
1A22048 	 C  0  0  0 90 16 A2  1 
1A22050 	74 7F A0  1 58 46 A0  1 
: noalias-find-device  ( str -- )
1A22058 	6E 6F 61 6C 69 61 73 2D 
1A22060 	66 69 6E 64 2D 64 65 76 
1A22068 	69 63 65 93 40 20 A2  1 
1A22070 	20 40 A0  1 
   \ Throw if null string
   ?dup 0=  ?not-found                 ( str$ )
1A22074 	B4 70 A0  1 
1A22078 	24 47 A0  1 40 20 A2  1 

   \ The path starts at the root directory if the first character is "/";
   \ otherwise it starts at the current directory
   dup 1 >=  if                        ( str$ )
1A22080 	40 49 A0  1 80 6F A0  1 
1A22088 	EC 48 A0  1 DC 41 A0  1 
1A22090 	30  0  0  0 
      over c@  ascii /  =  if  1 /string  root-phandle push-device  then
1A22094 	54 49 A0  1 
1A22098 	C4 4C A0  1 58 41 A0  1 
1A220A0 	2F  0  0  0 24 48 A0  1 
1A220A8 	DC 41 A0  1 14  0  0  0 
1A220B0 	80 6F A0  1 3C 85 A0  1 
1A220B8 	F8 10 A2  1 F8 FB A1  1 
   then                                ( str$ )

   current-device dt-null =  ?not-found
1A220C0 	40 F9 A1  1 6C F8 A1  1 
1A220C8 	24 48 A0  1 40 20 A2  1 
   device-context?  0= ?not-found
1A220D0 	18 20 A2  1 24 47 A0  1 
1A220D8 	40 20 A2  1 
   (find-device)
1A220DC 	E0 1C A2  1 
;
1A220E0 	58 46 A0  1 
: aliased-find-device  ( str -- )  ?expand-alias noalias-find-device  ;
1A220E4 	61 6C 69 61 
1A220E8 	73 65 64 2D 66 69 6E 64 
1A220F0 	2D 64 65 76 69 63 65 93 
1A220F8 	70 20 A2  1 20 40 A0  1 
1A22100 	CC 1F A2  1 70 20 A2  1 
1A22108 	58 46 A0  1 
headers
5 actions
1A2210C 	5C 21 A2  1 
1A22110 	44 21 A2  1 3C 21 A2  1 
1A22118 	30 21 A2  1  5  0  0  0 
action: count  ;
1A22120 	90 90 90 E8 54 1F FE FF 
1A22128 	BC 53 A0  1 58 46 A0  1 
action: 3drop  ;        \ No "store" method
1A22130 	20 40 A0  1 90 52 A0  1 
1A22138 	58 46 A0  1 
action:        ;        \ Just return the address
1A2213C 	20 40 A0  1 
1A22140 	58 46 A0  1 
action: drop $cstr cscount 1+  ;    \ Convert to string encoding
1A22144 	20 40 A0  1 
1A22148 	30 49 A0  1 F8 DE A0  1 
1A22150 	AC DF A0  1 30 4B A0  1 
1A22158 	58 46 A0  1 
action: drop get-encoded-string  ;  \ Remove null byte
1A2215C 	20 40 A0  1 
1A22160 	30 49 A0  1 24 F7 A1  1 
1A22168 	58 46 A0  1 
: $devalias  ( name-str expansion-str -- )
1A2216C 	 0  0 24 64 
1A22170 	65 76 61 6C 69 61 73 89 
1A22178 	FC 20 A2  1 20 40 A0  1 
   also aliases definitions
1A22180 	C8 C1 A0  1  0 18 A2  1 
1A22188 	2C C4 A0  1 
   strip-blanks  2swap strip-blanks
1A2218C 	2C  F A1  1 
1A22190 	F4 49 A0  1 2C  F A1  1 
   warning @ >r warning off $create r> warning !
1A22198 	E4 9A A0  1 5C 4C A0  1 
1A221A0 	BC 45 A0  1 E4 9A A0  1 
1A221A8 	F8 4B A0  1 8C A2 A0  1 
1A221B0 	D0 45 A0  1 E4 9A A0  1 
1A221B8 	54 4D A0  1 
   previous definitions
1A221BC 	E4 C3 A0  1 
1A221C0 	2C C4 A0  1 
   ",
1A221C4 	24 89 A0  1 
   use-actions
1A221C8 	60 53 A0  1 20 21 A2  1 
1A221D0 	E0 57 A0  1 
;
1A221D4 	58 46 A0  1 

action-adr-t to dodevalias \ mmo

: locate-device  ( adr len -- true  |  phandle false )
1A221D8 	 0  0 6C 6F 63 61 74 65 
1A221E0 	2D 64 65 76 69 63 65 8D 
1A221E8 	7C 21 A2  1 20 40 A0  1 
   also
1A221F0 	C8 C1 A0  1 
   ['] aliased-find-device catch  if
1A221F4 	60 53 A0  1 
1A221F8 	FC 20 A2  1 14 7F A0  1 
1A22200 	DC 41 A0  1 14  0  0  0 
      2drop true
1A22208 	AC 49 A0  1  4 70 A0  1 
   else
1A22210 	C8 41 A0  1  C  0  0  0 
      current-device false
1A22218 	40 F9 A1  1 18 70 A0  1 
   then
   previous definitions
1A22220 	E4 C3 A0  1 2C C4 A0  1 
;
1A22228 	58 46 A0  1 

headerless
: noa-find-device  ( adr len -- )
1A2222C 	6E 6F 61 2D 
1A22230 	66 69 6E 64 2D 64 65 76 
1A22238 	69 63 65 8F EC 21 A2  1 
1A22240 	20 40 A0  1 
   current-device >r
1A22244 	40 F9 A1  1 
1A22248 	BC 45 A0  1 
   ['] noalias-find-device  catch  case
1A2224C 	60 53 A0  1 
1A22250 	70 20 A2  1 14 7F A0  1 
      0          of  r> drop                          endof
1A22258 	70 6F A0  1 48 43 A0  1 
1A22260 	14  0  0  0 D0 45 A0  1 
1A22268 	30 49 A0  1 6C 43 A0  1 
1A22270 	38  0  0  0 
      not-found  of  r> push-device  not-found throw  endof
1A22274 	90 16 A2  1 
1A22278 	48 43 A0  1 1C  0  0  0 
1A22280 	D0 45 A0  1 F8 FB A1  1 
1A22288 	90 16 A2  1 74 7F A0  1 
1A22290 	6C 43 A0  1 14  0  0  0 
      ( default )    r> push-device  throw
1A22298 	D0 45 A0  1 F8 FB A1  1 
1A222A0 	74 7F A0  1 
   endcase
1A222A4 	84 43 A0  1 
;
1A222A8 	58 46 A0  1 
headers
: find-device  ( adr len -- )  ?expand-alias noa-find-device  ;
1A222AC 	66 69 6E 64 
1A222B0 	2D 64 65 76 69 63 65 8B 
1A222B8 	40 22 A2  1 20 40 A0  1 
1A222C0 	CC 1F A2  1 40 22 A2  1 
1A222C8 	58 46 A0  1 

headerless
: $parent-execute  ( adr len -- )
1A222CC 	24 70 61 72 
1A222D0 	65 6E 74 2D 65 78 65 63 
1A222D8 	75 74 65 8F BC 22 A2  1 
1A222E0 	20 40 A0  1 
   current-device >r  pop-device  package-execute  r> push-device
1A222E4 	40 F9 A1  1 
1A222E8 	BC 45 A0  1 18 FC A1  1 
1A222F0 	E8 19 A2  1 D0 45 A0  1 
1A222F8 	F8 FB A1  1 
;
1A222FC 	58 46 A0  1 
headers

\ From testdevt.fth
purpose: 

headerless
: (nh.) ( u -- adr,len )  push-hex   (u.)  pop-base  ;
1A22300 	 0  0 28 6E 68 2E 29 85 
1A22308 	E0 22 A2  1 20 40 A0  1 
1A22310 	5C F4 A0  1 AC 77 A0  1 
1A22318 	9C F4 A0  1 58 46 A0  1 
: .nh  ( u -- )  (nh.) type  ;
1A22320 	2E 6E 68 83  C 23 A2  1 
1A22328 	20 40 A0  1  C 23 A2  1 
1A22330 	 4 6C A0  1 58 46 A0  1 

: is-named? ( -- value-adr,len true | false )  " name" get-property 0=  ;
1A22338 	 0  0 69 73 2D 6E 61 6D 
1A22340 	65 64 3F 89 28 23 A2  1 
1A22348 	20 40 A0  1 9C 53 A0  1 
1A22350 	 4 6E 61 6D 65  0  0  0 
1A22358 	F4  D A2  1 24 47 A0  1 
1A22360 	58 46 A0  1 
: get-node-name  ( -- adr,len )
1A22364 	 0  0 67 65 
1A22368 	74 2D 6E 6F 64 65 2D 6E 
1A22370 	61 6D 65 8D 48 23 A2  1 
1A22378 	20 40 A0  1 
   is-named?  if  get-encoded-string   else  " <Unnamed>"   then
1A2237C 	48 23 A2  1 
1A22380 	DC 41 A0  1 10  0  0  0 
1A22388 	24 F7 A1  1 C8 41 A0  1 
1A22390 	14  0  0  0 9C 53 A0  1 
1A22398 	 9 3C 55 6E 6E 61 6D 65 
1A223A0 	64 3E  0  0 
;
1A223A4 	58 46 A0  1 

: .node-name  ( -- )
1A223A8 	 0 2E 6E 6F 64 65 2D 6E 
1A223B0 	61 6D 65 8A 78 23 A2  1 
1A223B8 	20 40 A0  1 
   get-node-name  type
1A223BC 	78 23 A2  1 
1A223C0 	 4 6C A0  1 
   get-unit  0=  if                           ( unit-str )
1A223C4 	90 15 A2  1 
1A223C8 	24 47 A0  1 DC 41 A0  1 
1A223D0 	88  0  0  0 
      ." @"
1A223D4 	20 7C A0  1 
1A223D8 	 1 40  0  0 
      unit-str>phys                           ( phys.lo .. phys.hi )
1A223DC 	30 16 A2  1 
      " encode-unit"  parent-device           ( phys.lo .. phys.hi adr,len phandle )
1A223E0 	9C 53 A0  1  B 65 6E 63 
1A223E8 	6F 64 65 2D 75 6E 69 74 
1A223F0 	 0  0  0  0 EC FA A1  1 
      $package-execute?  if                   ( phys.lo .. phys.hi )
1A223F8 	94  D A2  1 DC 41 A0  1 
1A22400 	54  0  0  0 
         '#adr-cells @  if  .nh  then         ( phys.lo .. phys.next )
1A22404 	4C FA A1  1 
1A22408 	5C 4C A0  1 DC 41 A0  1 
1A22410 	 8  0  0  0 28 23 A2  1 
	 '#adr-cells @ 1-  0 max  0  ?do  ." ,"  .nh  loop  ( )
1A22418 	4C FA A1  1 5C 4C A0  1 
1A22420 	54 4B A0  1 70 6F A0  1 
1A22428 	9C 4A A0  1 70 6F A0  1 
1A22430 	50 42 A0  1 18  0  0  0 
1A22438 	20 7C A0  1  1 2C  0  0 
1A22440 	28 23 A2  1 F8 41 A0  1 
1A22448 	F0 FF FF FF 
      else
1A2244C 	C8 41 A0  1 
1A22450 	 8  0  0  0 
         type
1A22454 	 4 6C A0  1 
      then
   then
;
1A22458 	58 46 A0  1 

: u.h   ( u -- )   push-hex u. pop-base  ;
1A2245C 	75 2E 68 83 
1A22460 	B8 23 A2  1 20 40 A0  1 
1A22468 	5C F4 A0  1 C8 77 A0  1 
1A22470 	9C F4 A0  1 58 46 A0  1 

: .nodeid  ( -- )  current-device u.h  .node-name  cr  ;
1A22478 	2E 6E 6F 64 65 69 64 87 
1A22480 	64 24 A2  1 20 40 A0  1 
1A22488 	40 F9 A1  1 64 24 A2  1 
1A22490 	B8 23 A2  1 80 6D A0  1 
1A22498 	58 46 A0  1 

: 8.x  ( n -- )
1A2249C 	38 2E 78 83 
1A224A0 	84 24 A2  1 20 40 A0  1 
   push-hex
1A224A8 	5C F4 A0  1 
   (.8) type space
1A224AC 	28 79 A0  1 
1A224B0 	 4 6C A0  1 CC 71 A0  1 
   pop-base
1A224B8 	9C F4 A0  1 
;
1A224BC 	58 46 A0  1 

: to-display-column  ( -- )  d# 25 to-column  ;
1A224C0 	 0  0 74 6F 2D 64 69 73 
1A224C8 	70 6C 61 79 2D 63 6F 6C 
1A224D0 	75 6D 6E 91 A4 24 A2  1 
1A224D8 	20 40 A0  1 58 41 A0  1 
1A224E0 	19  0  0  0  8 14 A1  1 
1A224E8 	58 46 A0  1 

\ Displays the property value "adr,len" as a list of integer values,
\ showing '#ints/line' on each line.
: .ints  ( adr len #ints/line  -- )
1A224EC 	 0  0 2E 69 
1A224F0 	6E 74 73 85 D8 24 A2  1 
1A224F8 	20 40 A0  1 
   >r
1A224FC 	BC 45 A0  1 
   begin  dup 0>  while                  ( adr len )
1A22500 	40 49 A0  1 A4 47 A0  1 
1A22508 	DC 41 A0  1 58  0  0  0 
      to-display-column
1A22510 	D8 24 A2  1 
      r@  0  do  decode-int 8.x  loop    ( adr' len' )
1A22514 	E4 45 A0  1 
1A22518 	70 6F A0  1 88 42 A0  1 
1A22520 	14  0  0  0 68 F7 A1  1 
1A22528 	A4 24 A2  1 F8 41 A0  1 
1A22530 	F4 FF FF FF 
      cr
1A22534 	80 6D A0  1 
      \ Pause before additional lines
      dup 0>  if  exit?  if  1 throw  then  then  ( adr' len' flag )
1A22538 	40 49 A0  1 A4 47 A0  1 
1A22540 	DC 41 A0  1 18  0  0  0 
1A22548 	34  D A1  1 DC 41 A0  1 
1A22550 	 C  0  0  0 80 6F A0  1 
1A22558 	74 7F A0  1 
   repeat                                ( adr',len' )
1A2255C 	C8 41 A0  1 
1A22560 	A0 FF FF FF 
   r> 3drop
1A22564 	D0 45 A0  1 
1A22568 	90 52 A0  1 
;
1A2256C 	58 46 A0  1 

: parent-#size-cells  ( -- #size-cells )
1A22570 	 0 70 61 72 65 6E 74 2D 
1A22578 	23 73 69 7A 65 2D 63 65 
1A22580 	6C 6C 73 92 F8 24 A2  1 
1A22588 	20 40 A0  1 
   \ Root node has no parent, therefore the size of its parent's address
   \ space is meaningless
   root-device?  if  0  exit  then
1A2258C 	4C 11 A2  1 
1A22590 	DC 41 A0  1  C  0  0  0 
1A22598 	70 6F A0  1 40 46 A0  1 
   current-device >r  pop-device
1A225A0 	40 F9 A1  1 BC 45 A0  1 
1A225A8 	18 FC A1  1 
   " #size-cells" get-property  if  1  else  get-encoded-int  then
1A225AC 	9C 53 A0  1 
1A225B0 	 B 23 73 69 7A 65 2D 63 
1A225B8 	65 6C 6C 73  0  0  0  0 
1A225C0 	F4  D A2  1 DC 41 A0  1 
1A225C8 	10  0  0  0 80 6F A0  1 
1A225D0 	C8 41 A0  1  8  0  0  0 
1A225D8 	A0 F7 A1  1 
   r> push-device
1A225DC 	D0 45 A0  1 
1A225E0 	F8 FB A1  1 
;
1A225E4 	58 46 A0  1 
: my-#size-cells  ( -- #size-cells )
1A225E8 	 0 6D 79 2D 23 73 69 7A 
1A225F0 	65 2D 63 65 6C 6C 73 8E 
1A225F8 	88 25 A2  1 20 40 A0  1 
   " #size-cells" get-property  if  1  else  get-encoded-int  then
1A22600 	9C 53 A0  1  B 23 73 69 
1A22608 	7A 65 2D 63 65 6C 6C 73 
1A22610 	 0  0  0  0 F4  D A2  1 
1A22618 	DC 41 A0  1 10  0  0  0 
1A22620 	80 6F A0  1 C8 41 A0  1 
1A22628 	 8  0  0  0 A0 F7 A1  1 
;
1A22630 	58 46 A0  1 
: size+  ( #cells -- #cells+#size-cells )  parent-#size-cells +  ;
1A22634 	 0  0 73 69 
1A22638 	7A 65 2B 85 FC 25 A2  1 
1A22640 	20 40 A0  1 88 25 A2  1 
1A22648 	 4 45 A0  1 58 46 A0  1 

vocabulary known-int-properties
1A22650 	 0  0  0 6B 6E 6F 77 6E 
1A22658 	2D 69 6E 74 2D 70 72 6F 
1A22660 	70 65 72 74 69 65 73 94 
1A22668 	40 26 A2  1 E0 B6 A0  1 
1A22670 	90  6  0  0  0 18 A2  1 
1A22678 	 0  0  0  0 
also known-int-properties definitions

headers
: intr             ( -- n )  2  ;
1A2267C 	 0  0  0 69 
1A22680 	6E 74 72 84  0  0 A0  1 
1A22688 	20 40 A0  1 90 6F A0  1 
1A22690 	58 46 A0  1 
: available        ( -- n )  '#adr-cells @ size+  ;
1A22694 	 0  0 61 76 
1A22698 	61 69 6C 61 62 6C 65 89 
1A226A0 	88 26 A2  1 20 40 A0  1 
1A226A8 	4C FA A1  1 5C 4C A0  1 
1A226B0 	40 26 A2  1 58 46 A0  1 
: reg              ( -- n )  '#adr-cells @ size+  ;
1A226B8 	72 65 67 83 A4 26 A2  1 
1A226C0 	20 40 A0  1 4C FA A1  1 
1A226C8 	5C 4C A0  1 40 26 A2  1 
1A226D0 	58 46 A0  1 
: existing         ( -- n )  '#adr-cells @ size+  ;
1A226D4 	 0  0  0 65 
1A226D8 	78 69 73 74 69 6E 67 88 
1A226E0 	C0 26 A2  1 20 40 A0  1 
1A226E8 	4C FA A1  1 5C 4C A0  1 
1A226F0 	40 26 A2  1 58 46 A0  1 
: ranges           ( -- n )  '#adr-cells @  #adr-cells + my-#size-cells +  ;
1A226F8 	 0 72 61 6E 67 65 73 86 
1A22700 	E4 26 A2  1 20 40 A0  1 
1A22708 	4C FA A1  1 5C 4C A0  1 
1A22710 	40  E A2  1  4 45 A0  1 
1A22718 	FC 25 A2  1  4 45 A0  1 
1A22720 	58 46 A0  1 
: dma-ranges       ( -- n )  ranges  ;
1A22724 	 0 64 6D 61 
1A22728 	2D 72 61 6E 67 65 73 8A 
1A22730 	 4 27 A2  1 20 40 A0  1 
1A22738 	 4 27 A2  1 58 46 A0  1 
: address          ( -- n )  1  ;
1A22740 	61 64 64 72 65 73 73 87 
1A22748 	34 27 A2  1 20 40 A0  1 
1A22750 	80 6F A0  1 58 46 A0  1 
: interrupts       ( -- n )  1  ;
1A22758 	 0 69 6E 74 65 72 72 75 
1A22760 	70 74 73 8A 4C 27 A2  1 
1A22768 	20 40 A0  1 80 6F A0  1 
1A22770 	58 46 A0  1 
: clock-frequency  ( -- n )  1  ;
1A22774 	63 6C 6F 63 
1A22778 	6B 2D 66 72 65 71 75 65 
1A22780 	6E 63 79 8F 68 27 A2  1 
1A22788 	20 40 A0  1 80 6F A0  1 
1A22790 	58 46 A0  1 
: #size-cells      ( -- n )  1  ;
1A22794 	23 73 69 7A 
1A22798 	65 2D 63 65 6C 6C 73 8B 
1A227A0 	88 27 A2  1 20 40 A0  1 
1A227A8 	80 6F A0  1 58 46 A0  1 
: dma              ( -- n )  5  ;
1A227B0 	64 6D 61 83 A4 27 A2  1 
1A227B8 	20 40 A0  1 C0 6F A0  1 
1A227C0 	58 46 A0  1 

previous definitions

headerless
: show-strings  ( adr,len -- )
1A227C4 	 0  0  0 73 
1A227C8 	68 6F 77 2D 73 74 72 69 
1A227D0 	6E 67 73 8C 6C 26 A2  1 
1A227D8 	20 40 A0  1 
   begin  dup  while  decode-string  to-display-column type cr  repeat
1A227DC 	40 49 A0  1 
1A227E0 	DC 41 A0  1 1C  0  0  0 
1A227E8 	FC F6 A1  1 D8 24 A2  1 
1A227F0 	 4 6C A0  1 80 6D A0  1 
1A227F8 	C8 41 A0  1 E0 FF FF FF 
   2drop
1A22800 	AC 49 A0  1 
;
1A22804 	58 46 A0  1 
: display  ( anf adr len -- )
1A22808 	64 69 73 70 6C 61 79 87 
1A22810 	D8 27 A2  1 20 40 A0  1 
   rot  name>string   ( adr,len  name,len )
1A22818 	7C 49 A0  1 58 74 A0  1 

   2dup  " compatible"  $=  if  2drop show-strings  exit  then
1A22820 	C0 49 A0  1 9C 53 A0  1 
1A22828 	 A 63 6F 6D 70 61 74 69 
1A22830 	62 6C 65  0 88 8D A0  1 
1A22838 	DC 41 A0  1 10  0  0  0 
1A22840 	AC 49 A0  1 D8 27 A2  1 
1A22848 	40 46 A0  1 

   ['] known-int-properties (search-wordlist)  if
1A2284C 	60 53 A0  1 
1A22850 	6C 26 A2  1  0 BB A0  1 
1A22858 	DC 41 A0  1 10  0  0  0 
       execute .ints  exit
1A22860 	98 41 A0  1 F8 24 A2  1 
1A22868 	40 46 A0  1 
   then  ( adr,len )

   \ Test for unprintable characters
   2dup -null text?  if   
1A2286C 	C0 49 A0  1 
1A22870 	88 E9 A1  1 C8 E9 A1  1 
1A22878 	DC 41 A0  1 14  0  0  0 
      to-display-column  -null  type  exit  
1A22880 	D8 24 A2  1 88 E9 A1  1 
1A22888 	 4 6C A0  1 40 46 A0  1 
   then   ( adr,len )

   dup /n =  if  1 .ints   exit  then                              ( adr,len )
1A22890 	40 49 A0  1 40 51 A0  1 
1A22898 	24 48 A0  1 DC 41 A0  1 
1A228A0 	10  0  0  0 80 6F A0  1 
1A228A8 	F8 24 A2  1 40 46 A0  1 

   to-display-column  h# 10 min  cdump                             ( )
1A228B0 	D8 24 A2  1 58 41 A0  1 
1A228B8 	10  0  0  0 74 4A A0  1 
1A228C0 	4C E9 A1  1 
;
1A228C4 	58 46 A0  1 

: (.parents)  ( -- )  recursive
1A228C8 	 0 28 2E 70 61 72 65 6E 
1A228D0 	74 73 29 8A 14 28 A2  1 
1A228D8 	20 40 A0  1 
   root-device?  0=  if
1A228DC 	4C 11 A2  1 
1A228E0 	24 47 A0  1 DC 41 A0  1 
1A228E8 	20  0  0  0 
      current-device  pop-device  (.parents)  push-device
1A228EC 	40 F9 A1  1 
1A228F0 	18 FC A1  1 D8 28 A2  1 
1A228F8 	F8 FB A1  1 
      ." /"  .node-name
1A228FC 	20 7C A0  1 
1A22900 	 1 2F  0  0 B8 23 A2  1 
   then
;
1A22908 	58 46 A0  1 

: .not-devtree ( -- )
1A2290C 	 0  0  0 2E 
1A22910 	6E 6F 74 2D 64 65 76 74 
1A22918 	72 65 65 8C D8 28 A2  1 
1A22920 	20 40 A0  1 
   ." Not at a device tree node. Use 'dev <device-pathname>'."
1A22924 	20 7C A0  1 
1A22928 	37 4E 6F 74 20 61 74 20 
1A22930 	61 20 64 65 76 69 63 65 
1A22938 	20 74 72 65 65 20 6E 6F 
1A22940 	64 65 2E 20 55 73 65 20 
1A22948 	27 64 65 76 20 3C 64 65 
1A22950 	76 69 63 65 2D 70 61 74 
1A22958 	68 6E 61 6D 65 3E 27 2E 
1A22960 	 0  0  0  0 
;
1A22964 	58 46 A0  1 
: (.property)  ( anf xt -- )  dup .name >r r@ get r> decode display  ;
1A22968 	28 2E 70 72 6F 70 65 72 
1A22970 	74 79 29 8B 20 29 A2  1 
1A22978 	20 40 A0  1 40 49 A0  1 
1A22980 	C8 9A A0  1 BC 45 A0  1 
1A22988 	E4 45 A0  1 D4 E7 A1  1 
1A22990 	D0 45 A0  1  8 E8 A1  1 
1A22998 	14 28 A2  1 58 46 A0  1 
: options?  ( -- flag )  current-properties  ['] options  =  ;
1A229A0 	 0  0  0 6F 70 74 69 6F 
1A229A8 	6E 73 3F 88 78 29 A2  1 
1A229B0 	20 40 A0  1 98  C A2  1 
1A229B8 	60 53 A0  1 90 E7 A1  1 
1A229C0 	24 48 A0  1 58 46 A0  1 
headers
: .property  ( "name" -- )  ' (.property)  ;
1A229C8 	 0  0 2E 70 72 6F 70 65 
1A229D0 	72 74 79 89 B0 29 A2  1 
1A229D8 	20 40 A0  1 F8 95 A0  1 
1A229E0 	78 29 A2  1 58 46 A0  1 
: .properties  ( -- )
1A229E8 	2E 70 72 6F 70 65 72 74 
1A229F0 	69 65 73 8B D8 29 A2  1 
1A229F8 	20 40 A0  1 
   device-context?  if
1A229FC 	18 20 A2  1 
1A22A00 	DC 41 A0  1 C4  0  0  0 
      current-properties follow
1A22A08 	98  C A2  1 38 BC A0  1 
      begin
         ??cr
1A22A10 	 0 A1 A0  1 
	 another?
1A22A14 	68 BC A0  1 
      while
1A22A18 	DC 41 A0  1 44  0  0  0 
         exit?  if  drop exit  then
1A22A20 	34  D A1  1 DC 41 A0  1 
1A22A28 	 C  0  0  0 30 49 A0  1 
1A22A30 	40 46 A0  1 
	 dup name>  ['] (.property)  catch  if  2drop exit  then
1A22A34 	40 49 A0  1 
1A22A38 	 8 74 A0  1 60 53 A0  1 
1A22A40 	78 29 A2  1 14 7F A0  1 
1A22A48 	DC 41 A0  1  C  0  0  0 
1A22A50 	AC 49 A0  1 40 46 A0  1 
      repeat
1A22A58 	C8 41 A0  1 B4 FF FF FF 
      \ In the options node, also display user-created environment variables
      options?  if
1A22A60 	B0 29 A2  1 DC 41 A0  1 
1A22A68 	58  0  0  0 
         null$  begin                      ( adr len )
1A22A6C 	7C E1 A1  1 
            next-env-var  dup              ( adr' len' len' )
1A22A70 	4C ED A1  1 40 49 A0  1 
         while                             ( adr len )
1A22A78 	DC 41 A0  1 40  0  0  0 
            exit?  if  2drop exit  then    ( adr len )
1A22A80 	34  D A1  1 DC 41 A0  1 
1A22A88 	 C  0  0  0 AC 49 A0  1 
1A22A90 	40 46 A0  1 
            2dup type  to-display-column   ( adr len )
1A22A94 	C0 49 A0  1 
1A22A98 	 4 6C A0  1 D8 24 A2  1 
            2dup get-env-var drop type cr  ( adr len )
1A22AA0 	C0 49 A0  1 8C EE A1  1 
1A22AA8 	30 49 A0  1  4 6C A0  1 
1A22AB0 	80 6D A0  1 
         repeat                            ( adr len )
1A22AB4 	C8 41 A0  1 
1A22AB8 	B8 FF FF FF 
         2drop                             ( )
1A22ABC 	AC 49 A0  1 
      then
   else
1A22AC0 	C8 41 A0  1  8  0  0  0 
      .not-devtree
1A22AC8 	20 29 A2  1 
   then
;
1A22ACC 	58 46 A0  1 
: ls  ( -- )
1A22AD0 	 0 6C 73 82 F8 29 A2  1 
1A22AD8 	20 40 A0  1 
   device-context?  if
1A22ADC 	18 20 A2  1 
1A22AE0 	DC 41 A0  1 40  0  0  0 
      'child token@                   ( first-node-voc )
1A22AE8 	 8 FA A1  1  C 54 A0  1 
      begin  non-null?  while         ( node-voc )
1A22AF0 	34 59 A0  1 DC 41 A0  1 
1A22AF8 	24  0  0  0 
	 voc>phandle push-device      ( )
1A22AFC 	40 F8 A1  1 
1A22B00 	F8 FB A1  1 
	 .nodeid                      ( )
1A22B04 	84 24 A2  1 
	 'peer token@                 ( node-voc' )
1A22B08 	1C FA A1  1  C 54 A0  1 
	 pop-device                   ( )
1A22B10 	18 FC A1  1 
      repeat                          ( )
1A22B14 	C8 41 A0  1 
1A22B18 	D8 FF FF FF 
   else
1A22B1C 	C8 41 A0  1 
1A22B20 	 8  0  0  0 
      .not-devtree
1A22B24 	20 29 A2  1 
   then
;
1A22B28 	58 46 A0  1 
: delete-my-children  ( -- )
1A22B2C 	 0 64 65 6C 
1A22B30 	65 74 65 2D 6D 79 2D 63 
1A22B38 	68 69 6C 64 72 65 6E 92 
1A22B40 	D8 2A A2  1 20 40 A0  1 
   device-context?  if
1A22B48 	18 20 A2  1 DC 41 A0  1 
1A22B50 	40  0  0  0 
      'child token@                   ( first-node-voc )
1A22B54 	 8 FA A1  1 
1A22B58 	 C 54 A0  1 
      begin  non-null?  while         ( node-voc )
1A22B5C 	34 59 A0  1 
1A22B60 	DC 41 A0  1 2C  0  0  0 
	 voc>phandle dup push-device  ( node-phandle )
1A22B68 	40 F8 A1  1 40 49 A0  1 
1A22B70 	F8 FB A1  1 
	 'peer token@                 ( node-phandle peer-voc )
1A22B74 	1C FA A1  1 
1A22B78 	 C 54 A0  1 
	 pop-device                   ( node-phandle peer-voc )
1A22B7C 	18 FC A1  1 
         swap delete-package          ( peer-voc )
1A22B80 	68 49 A0  1 78 12 A2  1 
      repeat                          ( )
1A22B88 	C8 41 A0  1 D0 FF FF FF 
   then
;
1A22B90 	58 46 A0  1 

headers

: (pwd)  ( -- )
1A22B94 	 0  0 28 70 
1A22B98 	77 64 29 85 44 2B A2  1 
1A22BA0 	20 40 A0  1 
   root-device?  if  ." /"  else  (.parents)  then
1A22BA4 	4C 11 A2  1 
1A22BA8 	DC 41 A0  1 14  0  0  0 
1A22BB0 	20 7C A0  1  1 2F  0  0 
1A22BB8 	C8 41 A0  1  8  0  0  0 
1A22BC0 	D8 28 A2  1 
;
1A22BC4 	58 46 A0  1 
: pwd  ( -- )
1A22BC8 	70 77 64 83 A0 2B A2  1 
1A22BD0 	20 40 A0  1 
   device-context?  if  (pwd)  else  .not-devtree  then   cr  
1A22BD4 	18 20 A2  1 
1A22BD8 	DC 41 A0  1 10  0  0  0 
1A22BE0 	A0 2B A2  1 C8 41 A0  1 
1A22BE8 	 8  0  0  0 20 29 A2  1 
1A22BF0 	80 6D A0  1 
;
1A22BF4 	58 46 A0  1 
: .voc-name   ( a -- )
1A22BF8 	 0  0 2E 76 6F 63 2D 6E 
1A22C00 	61 6D 65 89 D0 2B A2  1 
1A22C08 	20 40 A0  1 
   dup device-node? if
1A22C0C 	40 49 A0  1 
1A22C10 	F8  C A2  1 DC 41 A0  1 
1A22C18 	30  0  0  0 
      current-device phandle>voc  swap context token! (pwd) space  
1A22C1C 	40 F9 A1  1 
1A22C20 	58 F8 A1  1 68 49 A0  1 
1A22C28 	DC A3 A0  1 20 54 A0  1 
1A22C30 	A0 2B A2  1 CC 71 A0  1 
      context token!
1A22C38 	DC A3 A0  1 20 54 A0  1 
   else
1A22C40 	C8 41 A0  1  8  0  0  0 
      .name
1A22C48 	C8 9A A0  1 
   then
;
1A22C4C 	58 46 A0  1 
: order   (s -- )
1A22C50 	 0  0 6F 72 64 65 72 85 
1A22C58 	 8 2C A2  1 20 40 A0  1 
   ." context: "
1A22C60 	20 7C A0  1  9 63 6F 6E 
1A22C68 	74 65 78 74 3A 20  0  0 
   get-order  0  ?do  .voc-name  loop
1A22C70 	AC C2 A0  1 70 6F A0  1 
1A22C78 	50 42 A0  1 10  0  0  0 
1A22C80 	 8 2C A2  1 F8 41 A0  1 
1A22C88 	F8 FF FF FF 
   cr  ." current: "  get-current .voc-name
1A22C8C 	80 6D A0  1 
1A22C90 	20 7C A0  1  9 63 75 72 
1A22C98 	72 65 6E 74 3A 20  0  0 
1A22CA0 	6C C2 A0  1  8 2C A2  1 
;
1A22CA8 	58 46 A0  1 

headerless
: shownode  ( -- false )  exit?  if  true  else  pwd false  then  ;
1A22CAC 	 0  0  0 73 
1A22CB0 	68 6F 77 6E 6F 64 65 88 
1A22CB8 	5C 2C A2  1 20 40 A0  1 
1A22CC0 	34  D A1  1 DC 41 A0  1 
1A22CC8 	10  0  0  0  4 70 A0  1 
1A22CD0 	C8 41 A0  1  C  0  0  0 
1A22CD8 	D0 2B A2  1 18 70 A0  1 
1A22CE0 	58 46 A0  1 
: optional-arg-or-/$ ( -- adr len )
1A22CE4 	 0 6F 70 74 
1A22CE8 	69 6F 6E 61 6C 2D 61 72 
1A22CF0 	67 2D 6F 72 2D 2F 24 92 
1A22CF8 	BC 2C A2  1 20 40 A0  1 
   parse-word dup 0=  if  2drop " /"  then  ( adr len )
1A22D00 	34 93 A0  1 40 49 A0  1 
1A22D08 	24 47 A0  1 DC 41 A0  1 
1A22D10 	10  0  0  0 AC 49 A0  1 
1A22D18 	9C 53 A0  1  1 2F  0  0 
;
1A22D20 	58 46 A0  1 
headers
: $show-devs  ( adr len -- )
1A22D24 	 0 24 73 68 
1A22D28 	6F 77 2D 64 65 76 73 8A 
1A22D30 	FC 2C A2  1 20 40 A0  1 
   locate-device  if  not-found throw  then
1A22D38 	EC 21 A2  1 DC 41 A0  1 
1A22D40 	 C  0  0  0 90 16 A2  1 
1A22D48 	74 7F A0  1 
   push-package
1A22D4C 	7C FB A1  1 
      ['] shownode  ['] (search-preorder) catch 2drop
1A22D50 	60 53 A0  1 BC 2C A2  1 
1A22D58 	60 53 A0  1 24 17 A2  1 
1A22D60 	14 7F A0  1 AC 49 A0  1 
   pop-package
1A22D68 	D8 FB A1  1 
;
1A22D6C 	58 46 A0  1 
: show-devs  ( ["path"] -- )  optional-arg-or-/$ $show-devs  ;
1A22D70 	 0  0 73 68 6F 77 2D 64 
1A22D78 	65 76 73 89 34 2D A2  1 
1A22D80 	20 40 A0  1 FC 2C A2  1 
1A22D88 	34 2D A2  1 58 46 A0  1 

: dev  ( -- )
1A22D90 	64 65 76 83 80 2D A2  1 
1A22D98 	20 40 A0  1 
   optional-arg-or-/$            ( adr,len )
1A22D9C 	FC 2C A2  1 
   ?expand-alias                 ( adr,len )
1A22DA0 	CC 1F A2  1 
   2dup " .." $=  if             ( adr,len )
1A22DA4 	C0 49 A0  1 
1A22DA8 	9C 53 A0  1  2 2E 2E  0 
1A22DB0 	88 8D A0  1 DC 41 A0  1 
1A22DB8 	2C  0  0  0 
      2drop device-context?  if  (  )
1A22DBC 	AC 49 A0  1 
1A22DC0 	18 20 A2  1 DC 41 A0  1 
1A22DC8 	10  0  0  0 
	 pop-device              (  )
1A22DCC 	18 FC A1  1 
      else                       (  )
1A22DD0 	C8 41 A0  1  8  0  0  0 
	 .not-devtree            (  )
1A22DD8 	20 29 A2  1 
      then                       (  )
   else                          ( adr,len )
1A22DDC 	C8 41 A0  1 
1A22DE0 	 8  0  0  0 
      find-device                (  )
1A22DE4 	BC 22 A2  1 
   then                          (  )
;
1A22DE8 	58 46 A0  1 

: show-props  ( -- )
1A22DEC 	 0 73 68 6F 
1A22DF0 	77 2D 70 72 6F 70 73 8A 
1A22DF8 	98 2D A2  1 20 40 A0  1 
   current-device >r
1A22E00 	40 F9 A1  1 BC 45 A0  1 
   optional-arg-or-/$           ( adr len )
1A22E08 	FC 2C A2  1 
   find-device  .properties  device-end
1A22E0C 	BC 22 A2  1 
1A22E10 	F8 29 A2  1 94  F A2  1 
   r> push-device
1A22E18 	D0 45 A0  1 F8 FB A1  1 
;
1A22E20 	58 46 A0  1 
headerless
: show-aliases  ( -- )
1A22E24 	 0  0  0 73 
1A22E28 	68 6F 77 2D 61 6C 69 61 
1A22E30 	73 65 73 8C FC 2D A2  1 
1A22E38 	20 40 A0  1 
   also  " /aliases" find-device  .properties  (  )
1A22E3C 	C8 C1 A0  1 
1A22E40 	9C 53 A0  1  8 2F 61 6C 
1A22E48 	69 61 73 65 73  0  0  0 
1A22E50 	BC 22 A2  1 F8 29 A2  1 
   previous definitions                        (  )
1A22E58 	E4 C3 A0  1 2C C4 A0  1 
;
1A22E60 	58 46 A0  1 
: show-alias  ( adr len -- )
1A22E64 	 0 73 68 6F 
1A22E68 	77 2D 61 6C 69 61 73 8A 
1A22E70 	38 2E A2  1 20 40 A0  1 
   2dup " name" $= 0=  if     ( adr,len )
1A22E78 	C0 49 A0  1 9C 53 A0  1 
1A22E80 	 4 6E 61 6D 65  0  0  0 
1A22E88 	88 8D A0  1 24 47 A0  1 
1A22E90 	DC 41 A0  1 30  0  0  0 
      ['] aliases $vfind  if  ( xt )
1A22E98 	60 53 A0  1  0 18 A2  1 
1A22EA0 	5C BB A0  1 DC 41 A0  1 
1A22EA8 	1C  0  0  0 
	 dup >name swap  (.property) cr exit
1A22EAC 	40 49 A0  1 
1A22EB0 	24 74 A0  1 68 49 A0  1 
1A22EB8 	78 29 A2  1 80 6D A0  1 
1A22EC0 	40 46 A0  1 
      then                    ( adr,len )
   then                       ( adr,len )
   type ."  : no such alias"  (  )
1A22EC4 	 4 6C A0  1 
1A22EC8 	20 7C A0  1 10 20 3A 20 
1A22ED0 	6E 6F 20 73 75 63 68 20 
1A22ED8 	61 6C 69 61 73  0  0  0 
;
1A22EE0 	58 46 A0  1 
headers
: devalias  \ name string  ( -- )
1A22EE4 	 0  0  0 64 
1A22EE8 	65 76 61 6C 69 61 73 88 
1A22EF0 	74 2E A2  1 20 40 A0  1 
   parse-word  parse-word
1A22EF8 	34 93 A0  1 34 93 A0  1 
   dup  if                        ( name$ path$ )
1A22F00 	40 49 A0  1 DC 41 A0  1 
1A22F08 	10  0  0  0 
      $devalias  (  )
1A22F0C 	7C 21 A2  1 
   else                           ( name$ path$ )
1A22F10 	C8 41 A0  1 28  0  0  0 
      2drop dup  if               ( name$ )
1A22F18 	AC 49 A0  1 40 49 A0  1 
1A22F20 	DC 41 A0  1 10  0  0  0 
	 show-alias               (  )
1A22F28 	74 2E A2  1 
      else                        ( name$ )
1A22F2C 	C8 41 A0  1 
1A22F30 	 C  0  0  0 
	 2drop show-aliases       (  )
1A22F34 	AC 49 A0  1 
1A22F38 	38 2E A2  1 
      then                        (  )
   then                           (  )
;
1A22F3C 	58 46 A0  1 

\ From instance.fth
purpose: Create, destroy, and call package instances

\ Creation and destruction of device instances.  Also package interface words.

headerless
create no-proc  ," Unimplemented package interface procedure"
1A22F40 	6E 6F 2D 70 72 6F 63 87 
1A22F48 	F4 2E A2  1 30 40 A0  1 
1A22F50 	29 55 6E 69 6D 70 6C 65 
1A22F58 	6D 65 6E 74 65 64 20 70 
1A22F60 	61 63 6B 61 67 65 20 69 
1A22F68 	6E 74 65 72 66 61 63 65 
1A22F70 	20 70 72 6F 63 65 64 75 
1A22F78 	72 65  0  0 

headers
defer fm-hook  ( adr len phandle -- adr len phandle )
1A22F7C 	66 6D 2D 68 
1A22F80 	6F 6F 6B 87 4C 2F A2  1 
1A22F88 	5C 40 A0  1 94  6  0  0 
' noop is fm-hook

: find-method  ( adr len phandle -- false | acf true )
1A22F90 	66 69 6E 64 2D 6D 65 74 
1A22F98 	68 6F 64 8B 88 2F A2  1 
1A22FA0 	20 40 A0  1 
   fm-hook  phandle>voc (search-wordlist)
1A22FA4 	88 2F A2  1 
1A22FA8 	58 F8 A1  1  0 BB A0  1 
;
1A22FB0 	58 46 A0  1 

headerless
2variable error-method
1A22FB4 	 0  0  0 65 
1A22FB8 	72 72 6F 72 2D 6D 65 74 
1A22FC0 	68 6F 64 8C A0 2F A2  1 
1A22FC8 	48 40 A0  1 98  6  0  0 
0 value error-instance
1A22FD0 	 0 65 72 72 6F 72 2D 69 
1A22FD8 	6E 73 74 61 6E 63 65 8E 
1A22FE0 	C8 2F A2  1 50 40 A0  1 
1A22FE8 	A0  6  0  0 
0 value error-package	\ Undefined if error-instance is 0
1A22FEC 	 0  0 65 72 
1A22FF0 	72 6F 72 2D 70 61 63 6B 
1A22FF8 	61 67 65 8D E4 2F A2  1 
1A23000 	50 40 A0  1 A4  6  0  0 
headers
: .method  ( -- )
1A23008 	2E 6D 65 74 68 6F 64 87 
1A23010 	 0 30 A2  1 20 40 A0  1 
   ." Method: " error-method 2@ type  ."  Instance: " error-instance u.
1A23018 	20 7C A0  1  8 4D 65 74 
1A23020 	68 6F 64 3A 20  0  0  0 
1A23028 	C8 2F A2  1 CC 4D A0  1 
1A23030 	 4 6C A0  1 20 7C A0  1 
1A23038 	 B 20 49 6E 73 74 61 6E 
1A23040 	63 65 3A 20  0  0  0  0 
1A23048 	E4 2F A2  1 C8 77 A0  1 
   error-instance  if
1A23050 	E4 2F A2  1 DC 41 A0  1 
1A23058 	24  0  0  0 
      ." Package: " error-package push-package (pwd) pop-package
1A2305C 	20 7C A0  1 
1A23060 	 9 50 61 63 6B 61 67 65 
1A23068 	3A 20  0  0  0 30 A2  1 
1A23070 	7C FB A1  1 A0 2B A2  1 
1A23078 	D8 FB A1  1 
   then
   cr
1A2307C 	80 6D A0  1 
;
1A23080 	58 46 A0  1 

headerless
: "open"  " open"  ;
1A23084 	 0 22 6F 70 
1A23088 	65 6E 22 86 14 30 A2  1 
1A23090 	20 40 A0  1 9C 53 A0  1 
1A23098 	 4 6F 70 65 6E  0  0  0 
1A230A0 	58 46 A0  1 

headers
: $call-self  ( adr len -- )
1A230A4 	 0 24 63 61 
1A230A8 	6C 6C 2D 73 65 6C 66 8A 
1A230B0 	90 30 A2  1 20 40 A0  1 
   my-self  if
1A230B8 	EC 7E A0  1 DC 41 A0  1 
1A230C0 	24  0  0  0 
      my-voc  fm-hook phandle>voc $find-word  if  execute  exit  then
1A230C4 	10  4 A2  1 
1A230C8 	88 2F A2  1 58 F8 A1  1 
1A230D0 	D4 BA A0  1 DC 41 A0  1 
1A230D8 	 C  0  0  0 98 41 A0  1 
1A230E0 	40 46 A0  1 
   then
   my-self to error-instance
1A230E4 	EC 7E A0  1 
1A230E8 	B8 40 A0  1 E4 2F A2  1 
   error-instance  if  my-voc  to error-package  then
1A230F0 	E4 2F A2  1 DC 41 A0  1 
1A230F8 	10  0  0  0 10  4 A2  1 
1A23100 	B8 40 A0  1  0 30 A2  1 
   error-method 2! no-proc throw
1A23108 	C8 2F A2  1 E4 4D A0  1 
1A23110 	4C 2F A2  1 74 7F A0  1 
;
1A23118 	58 46 A0  1 

[ifndef] package(
: package(  ( ihandle -- )  r> my-self >r >r  is my-self  ;
1A2311C 	 0  0  0 70 
1A23120 	61 63 6B 61 67 65 28 88 
1A23128 	B4 30 A2  1 20 40 A0  1 
1A23130 	D0 45 A0  1 EC 7E A0  1 
1A23138 	BC 45 A0  1 BC 45 A0  1 
1A23140 	B8 40 A0  1 EC 7E A0  1 
1A23148 	58 46 A0  1 
: )package  ( -- )  r> r> is my-self >r  ;
1A2314C 	 0  0  0 29 
1A23150 	70 61 63 6B 61 67 65 88 
1A23158 	2C 31 A2  1 20 40 A0  1 
1A23160 	D0 45 A0  1 D0 45 A0  1 
1A23168 	B8 40 A0  1 EC 7E A0  1 
1A23170 	BC 45 A0  1 58 46 A0  1 
[then]

: call-package  ( ??? acf ihandle -- ??? )      package( execute    )package  ;
1A23178 	 0  0  0 63 61 6C 6C 2D 
1A23180 	70 61 63 6B 61 67 65 8C 
1A23188 	5C 31 A2  1 20 40 A0  1 
1A23190 	2C 31 A2  1 98 41 A0  1 
1A23198 	5C 31 A2  1 58 46 A0  1 
: $call-method  ( ??? adr len ihandle -- ??? )  package( $call-self )package  ;
1A231A0 	 0  0  0 24 63 61 6C 6C 
1A231A8 	2D 6D 65 74 68 6F 64 8C 
1A231B0 	8C 31 A2  1 20 40 A0  1 
1A231B8 	2C 31 A2  1 B4 30 A2  1 
1A231C0 	5C 31 A2  1 58 46 A0  1 
: $call-parent  ( adr len -- )  my-parent $call-method  ;
1A231C8 	 0  0  0 24 63 61 6C 6C 
1A231D0 	2D 70 61 72 65 6E 74 8C 
1A231D8 	B4 31 A2  1 20 40 A0  1 
1A231E0 	28  4 A2  1 B4 31 A2  1 
1A231E8 	58 46 A0  1 
: ihandle>phandle  ( ihandle -- phandle )       package( my-voc     )package  ;
1A231EC 	69 68 61 6E 
1A231F0 	64 6C 65 3E 70 68 61 6E 
1A231F8 	64 6C 65 8F DC 31 A2  1 
1A23200 	20 40 A0  1 2C 31 A2  1 
1A23208 	10  4 A2  1 5C 31 A2  1 
1A23210 	58 46 A0  1 

headerless
: activate  ( -- )
1A23214 	 0  0  0 61 
1A23218 	63 74 69 76 61 74 65 88 
1A23220 	 0 32 A2  1 20 40 A0  1 
   my-self  if
1A23228 	EC 7E A0  1 DC 41 A0  1 
1A23230 	5C  0  0  0 
      my-self ihandle>phandle
1A23234 	EC 7E A0  1 
1A23238 	 0 32 A2  1 
      ?dup  if  push-package  else  ." Current instance " my-self . ." has 0 phandle!"  cr  then
1A2323C 	B4 70 A0  1 
1A23240 	DC 41 A0  1 10  0  0  0 
1A23248 	7C FB A1  1 C8 41 A0  1 
1A23250 	3C  0  0  0 20 7C A0  1 
1A23258 	11 43 75 72 72 65 6E 74 
1A23260 	20 69 6E 73 74 61 6E 63 
1A23268 	65 20  0  0 EC 7E A0  1 
1A23270 	94 7A A0  1 20 7C A0  1 
1A23278 	 E 68 61 73 20 30 20 70 
1A23280 	68 61 6E 64 6C 65 21  0 
1A23288 	80 6D A0  1 
   then
;
1A2328C 	58 46 A0  1 
: deactivate  ( -- )  my-self  if  pop-package  then  ;
1A23290 	 0 64 65 61 63 74 69 76 
1A23298 	61 74 65 8A 24 32 A2  1 
1A232A0 	20 40 A0  1 EC 7E A0  1 
1A232A8 	DC 41 A0  1  8  0  0  0 
1A232B0 	D8 FB A1  1 58 46 A0  1 

[ifdef] bug
also bug
'   activate to   set-package
' deactivate to unset-package
previous
[then]

headers
: $call-static-method  ( ??? adr len phandle -- ??? )
1A232B8 	24 63 61 6C 6C 2D 73 74 
1A232C0 	61 74 69 63 2D 6D 65 74 
1A232C8 	68 6F 64 93 A0 32 A2  1 
1A232D0 	20 40 A0  1 
   find-method  0=  if  no-proc throw  then  execute
1A232D4 	A0 2F A2  1 
1A232D8 	24 47 A0  1 DC 41 A0  1 
1A232E0 	 C  0  0  0 4C 2F A2  1 
1A232E8 	74 7F A0  1 98 41 A0  1 
;
1A232F0 	58 46 A0  1 

\ set-args is executed only during probing, at which time the active package
\ corresponds to the current instance, thus '#adr-cells can be executed
\ directly.

: set-args  ( arg-str reg-str -- )
1A232F4 	 0  0  0 73 
1A232F8 	65 74 2D 61 72 67 73 88 
1A23300 	D0 32 A2  1 20 40 A0  1 
   " decode-unit" $call-parent  '#adr-cells @  ( arg-str phys .. #cells )
1A23308 	9C 53 A0  1  B 64 65 63 
1A23310 	6F 64 65 2D 75 6E 69 74 
1A23318 	 0  0  0  0 DC 31 A2  1 
1A23320 	4C FA A1  1 5C 4C A0  1 
   dup  if  swap  to my-space  1-   then       ( arg-str phys .. #cells' )
1A23328 	40 49 A0  1 DC 41 A0  1 
1A23330 	14  0  0  0 68 49 A0  1 
1A23338 	48 B8 A1  1 AC  3 A2  1 
1A23340 	54 4B A0  1 
   addr my-adr0  swap /n* bounds  ?do  i !  /n +loop   ( arg-str )
1A23344 	5C B8 A1  1 
1A23348 	6C  3 A2  1 68 49 A0  1 
1A23350 	98 51 A0  1 F0 6D A0  1 
1A23358 	50 42 A0  1 18  0  0  0 
1A23360 	B4 42 A0  1 54 4D A0  1 
1A23368 	40 51 A0  1 1C 42 A0  1 
1A23370 	F0 FF FF FF 
   copy-args
1A23374 	10  8 A2  1 
;
1A23378 	58 46 A0  1 

: get-package-property  ( adr len phandle -- true | adr' len' false )
1A2337C 	 0  0  0 67 
1A23380 	65 74 2D 70 61 63 6B 61 
1A23388 	67 65 2D 70 72 6F 70 65 
1A23390 	72 74 79 94  4 33 A2  1 
1A23398 	20 40 A0  1 
   (push-package)  get-property  (pop-package)
1A2339C 	38 FB A1  1 
1A233A0 	F4  D A2  1 5C FB A1  1 
;
1A233A8 	58 46 A0  1 

\ XXX - I think this could be implemented by   (push-package) (property) (pop-package)
: set-package-property  ( value$ name$ phandle -- )
1A233AC 	 0  0  0 73 
1A233B0 	65 74 2D 70 61 63 6B 61 
1A233B8 	67 65 2D 70 72 6F 70 65 
1A233C0 	72 74 79 94 98 33 A2  1 
1A233C8 	20 40 A0  1 
   current token@ >r  context token@ >r   (select-package)  ( value$ name$ )
1A233CC 	F0 A3 A0  1 
1A233D0 	 C 54 A0  1 BC 45 A0  1 
1A233D8 	DC A3 A0  1  C 54 A0  1 
1A233E0 	BC 45 A0  1 14 FB A1  1 
   (property)
1A233E8 	24 14 A2  1 
   r> context token!  r> current token!
1A233EC 	D0 45 A0  1 
1A233F0 	DC A3 A0  1 20 54 A0  1 
1A233F8 	D0 45 A0  1 F0 A3 A0  1 
1A23400 	20 54 A0  1 
;
1A23404 	58 46 A0  1 

\ Used when executing from an open package instance.  Finds a property
\ associated with the current package.
: get-my-property  ( adr len -- true | adr' len' false )
1A23408 	67 65 74 2D 6D 79 2D 70 
1A23410 	72 6F 70 65 72 74 79 8F 
1A23418 	C8 33 A2  1 20 40 A0  1 
   my-voc get-package-property
1A23420 	10  4 A2  1 98 33 A2  1 
;
1A23428 	58 46 A0  1 

headerless
0 value interposer	\ phandle of interposing package, if any
1A2342C 	 0 69 6E 74 
1A23430 	65 72 70 6F 73 65 72 8A 
1A23438 	1C 34 A2  1 50 40 A0  1 
1A23440 	A8  6  0  0 
0 value ip-arg-adr	\ arguments for interposing package
1A23444 	 0 69 70 2D 
1A23448 	61 72 67 2D 61 64 72 8A 
1A23450 	3C 34 A2  1 50 40 A0  1 
1A23458 	AC  6  0  0 
0 value ip-arg-len
1A2345C 	 0 69 70 2D 
1A23460 	61 72 67 2D 6C 65 6E 8A 
1A23468 	54 34 A2  1 50 40 A0  1 
1A23470 	B0  6  0  0 

false value pkg-interpose?	\ phandle of interposing package, if any
1A23474 	 0 70 6B 67 
1A23478 	2D 69 6E 74 65 72 70 6F 
1A23480 	73 65 3F 8E 6C 34 A2  1 
1A23488 	50 40 A0  1 B4  6  0  0 

: interposed?  ( -- false | arg$ phandle true )
1A23490 	69 6E 74 65 72 70 6F 73 
1A23498 	65 64 3F 8B 88 34 A2  1 
1A234A0 	20 40 A0  1 
   interposer  if
1A234A4 	3C 34 A2  1 
1A234A8 	DC 41 A0  1 34  0  0  0 
      false to pkg-interpose?
1A234B0 	18 70 A0  1 B8 40 A0  1 
1A234B8 	88 34 A2  1 
      ip-arg-adr ip-arg-len  interposer  0 to interposer  true
1A234BC 	54 34 A2  1 
1A234C0 	6C 34 A2  1 3C 34 A2  1 
1A234C8 	70 6F A0  1 B8 40 A0  1 
1A234D0 	3C 34 A2  1  4 70 A0  1 
   else
1A234D8 	C8 41 A0  1  8  0  0  0 
      false
1A234E0 	18 70 A0  1 
   then
;
1A234E4 	58 46 A0  1 

\ 0 value pip-arg-adr	\ arguments for interposing package
\ 0 value pip-arg-len

: package-interposed?  ( -- false | arg$ phandle true )
1A234E8 	70 61 63 6B 61 67 65 2D 
1A234F0 	69 6E 74 65 72 70 6F 73 
1A234F8 	65 64 3F 93 A0 34 A2  1 
1A23500 	20 40 A0  1 
   pkg-interpose?  if  interposed?  else  false  then
1A23504 	88 34 A2  1 
1A23508 	DC 41 A0  1 10  0  0  0 
1A23510 	A0 34 A2  1 C8 41 A0  1 
1A23518 	 8  0  0  0 18 70 A0  1 
;
1A23520 	58 46 A0  1 

headers
: interpose  ( args$ phandle -- )
1A23524 	 0  0 69 6E 
1A23528 	74 65 72 70 6F 73 65 89 
1A23530 	 0 35 A2  1 20 40 A0  1 
   false to pkg-interpose?
1A23538 	18 70 A0  1 B8 40 A0  1 
1A23540 	88 34 A2  1 
   to interposer  to ip-arg-len  to ip-arg-adr
1A23544 	B8 40 A0  1 
1A23548 	3C 34 A2  1 B8 40 A0  1 
1A23550 	6C 34 A2  1 B8 40 A0  1 
1A23558 	54 34 A2  1 
;
1A2355C 	58 46 A0  1 
: package-interpose  ( args$ phandle -- )
1A23560 	 0  0 70 61 63 6B 61 67 
1A23568 	65 2D 69 6E 74 65 72 70 
1A23570 	6F 73 65 91 34 35 A2  1 
1A23578 	20 40 A0  1 
   interpose
1A2357C 	34 35 A2  1 
   true to pkg-interpose?
1A23580 	 4 70 A0  1 B8 40 A0  1 
1A23588 	88 34 A2  1 
;
1A2358C 	58 46 A0  1 

headerless
\ Internal factor of get-inherited-property.  This factoring is necessary
\ because we use "exit" to make the control flow easier.
: (get-any)   ( adr len -- true | adr' len' false )
1A23590 	 0  0 28 67 65 74 2D 61 
1A23598 	6E 79 29 89 78 35 A2  1 
1A235A0 	20 40 A0  1 
   begin  my-self   while            ( adr len )  \ Search up parent chain
1A235A4 	EC 7E A0  1 
1A235A8 	DC 41 A0  1 4C  0  0  0 
      my-voc phandle>voc current token!         ( adr len )
1A235B0 	10  4 A2  1 58 F8 A1  1 
1A235B8 	F0 A3 A0  1 20 54 A0  1 
      2dup get-my-property  0=  if   ( adr len adr' len' )
1A235C0 	C0 49 A0  1 1C 34 A2  1 
1A235C8 	24 47 A0  1 DC 41 A0  1 
1A235D0 	14  0  0  0 
         2swap 2drop false exit      ( adr' len' false )   \ Found
1A235D4 	F4 49 A0  1 
1A235D8 	AC 49 A0  1 18 70 A0  1 
1A235E0 	40 46 A0  1 
      then                           ( adr len )
      my-parent is my-self           ( adr len )
1A235E4 	28  4 A2  1 
1A235E8 	B8 40 A0  1 EC 7E A0  1 
   repeat                            ( adr len )
1A235F0 	C8 41 A0  1 B0 FF FF FF 
   2drop true                        ( true )              \ Not found
1A235F8 	AC 49 A0  1  4 70 A0  1 
;
1A23600 	58 46 A0  1 

headers
\ Finds a property associated with the current package or with one of
\ its parents.
: get-inherited-property  ( adr len -- true | adr' len' false )
1A23604 	 0 67 65 74 
1A23608 	2D 69 6E 68 65 72 69 74 
1A23610 	65 64 2D 70 72 6F 70 65 
1A23618 	72 74 79 96 A0 35 A2  1 
1A23620 	20 40 A0  1 
   current token@ >r   my-self >r
1A23624 	F0 A3 A0  1 
1A23628 	 C 54 A0  1 BC 45 A0  1 
1A23630 	EC 7E A0  1 BC 45 A0  1 
   (get-any)
1A23638 	A0 35 A2  1 
   r> is my-self  r> current token!
1A2363C 	D0 45 A0  1 
1A23640 	B8 40 A0  1 EC 7E A0  1 
1A23648 	D0 45 A0  1 F0 A3 A0  1 
1A23650 	20 54 A0  1 
;
1A23654 	58 46 A0  1 

headerless
: ?close  ( -- )  " close"  ['] $call-self  catch  if  2drop  then  ;
1A23658 	 0 3F 63 6C 6F 73 65 86 
1A23660 	20 36 A2  1 20 40 A0  1 
1A23668 	9C 53 A0  1  5 63 6C 6F 
1A23670 	73 65  0  0 60 53 A0  1 
1A23678 	B4 30 A2  1 14 7F A0  1 
1A23680 	DC 41 A0  1  8  0  0  0 
1A23688 	AC 49 A0  1 58 46 A0  1 
headers
\ Close all the instances up the chain from ihandle to my-self.
\ This assumes that close-package is called from the same instance
\ from which open-package was called.  The reason for closing a
\ chain, instead of just one instance, is because open-package
\ could have created a chain as a result of interposition.
: close-package  ( ihandle -- )
1A23690 	 0  0 63 6C 6F 73 65 2D 
1A23698 	70 61 63 6B 61 67 65 8D 
1A236A0 	64 36 A2  1 20 40 A0  1 
   my-self  swap to my-self             ( end-ihandle )
1A236A8 	EC 7E A0  1 68 49 A0  1 
1A236B0 	B8 40 A0  1 EC 7E A0  1 
   begin                                ( end-ihandle )
      dup my-self <>  my-self 0<>  and  ( end-ihandle more? )
1A236B8 	40 49 A0  1 EC 7E A0  1 
1A236C0 	44 48 A0  1 EC 7E A0  1 
1A236C8 	44 47 A0  1 5C 44 A0  1 
   while                                ( end-ihandle )
1A236D0 	DC 41 A0  1 14  0  0  0 
      ?close                            ( end-ihandle )
1A236D8 	64 36 A2  1 
      destroy-instance                  ( end-ihandle )
1A236DC 	38  9 A2  1 
      \ destroy-instance sets my-self to the parent ihandle
   repeat                               ( end-ihandle )
1A236E0 	C8 41 A0  1 D4 FF FF FF 
   to my-self                           ( ) \ In case we bailed on a 0 ihandle
1A236E8 	B8 40 A0  1 EC 7E A0  1 
;
1A236F0 	58 46 A0  1 
headerless
: close-parents  ( -- )
1A236F4 	 0  0 63 6C 
1A236F8 	6F 73 65 2D 70 61 72 65 
1A23700 	6E 74 73 8D A4 36 A2  1 
1A23708 	20 40 A0  1 
   begin  my-self  while  ?close destroy-instance  repeat
1A2370C 	EC 7E A0  1 
1A23710 	DC 41 A0  1 14  0  0  0 
1A23718 	64 36 A2  1 38  9 A2  1 
1A23720 	C8 41 A0  1 E8 FF FF FF 
;
1A23728 	58 46 A0  1 
: close-chain  ( -- )  destroy-instance  close-parents  ;
1A2372C 	63 6C 6F 73 
1A23730 	65 2D 63 68 61 69 6E 8B 
1A23738 	 8 37 A2  1 20 40 A0  1 
1A23740 	38  9 A2  1  8 37 A2  1 
1A23748 	58 46 A0  1 
headers
: close-dev  ( ihandle -- )  package(  close-parents  )package  ;
1A2374C 	 0  0 63 6C 
1A23750 	6F 73 65 2D 64 65 76 89 
1A23758 	3C 37 A2  1 20 40 A0  1 
1A23760 	2C 31 A2  1  8 37 A2  1 
1A23768 	5C 31 A2  1 58 46 A0  1 

: parse/  ( $ -- head$ tail$ )  ascii /  left-parse-string  ;
1A23770 	 0 70 61 72 73 65 2F 86 
1A23778 	5C 37 A2  1 20 40 A0  1 
1A23780 	58 41 A0  1 2F  0  0  0 
1A23788 	44 D7 A0  1 58 46 A0  1 
: parse:  ( $ -- head$ tail$ )  ascii :  left-parse-string  ;
1A23790 	 0 70 61 72 73 65 3A 86 
1A23798 	7C 37 A2  1 20 40 A0  1 
1A237A0 	58 41 A0  1 3A  0  0  0 
1A237A8 	44 D7 A0  1 58 46 A0  1 
\ Extract the next (leftmost) component from the path name, updating the
\ path variable to reflect the remainder of the path after the extracted
\ component.
: parse-component  ( path$ first? -- path$ args$ devname$ package? )
1A237B0 	70 61 72 73 65 2D 63 6F 
1A237B8 	6D 70 6F 6E 65 6E 74 8F 
1A237C0 	9C 37 A2  1 20 40 A0  1 
   >r                             ( path$' component$ r: first? )
1A237C8 	BC 45 A0  1 
   parse/                         ( path$' component$ r: first? )
1A237CC 	7C 37 A2  1 
   dup 0=  if                     ( path$' component$ r: first? )
1A237D0 	40 49 A0  1 24 47 A0  1 
1A237D8 	DC 41 A0  1 9C  0  0  0 
      \ The first character was a slash, so it's either the root node
      \ or a support package
      2drop                       ( path$' r: first? )
1A237E0 	AC 49 A0  1 
      r@  if                      ( path$' r: first? )
1A237E4 	E4 45 A0  1 
1A237E8 	DC 41 A0  1 78  0  0  0 
         \ This is the first path component, so it could be either
         \ the root node or a support package
         dup  if
1A237F0 	40 49 A0  1 DC 41 A0  1 
1A237F8 	50  0  0  0 
            \ The rest of the string is not empty, so it could be either ...
	    2dup parse/           ( path$' tail$ head$ r: first? )
1A237FC 	C0 49 A0  1 
1A23800 	7C 37 A2  1 
	    nip  if               ( path$' tail$ r: first? )
1A23804 	FC 46 A0  1 
1A23808 	DC 41 A0  1 24  0  0  0 
	       \ The next character was not a slash, so it must be the root.
	       \ Undo the last parse and return the root node specification.
	       2drop              ( path$' r: first? )
1A23810 	AC 49 A0  1 
	       " "  " /" false    ( path$' args$ devname$ package? r: first? )
1A23814 	9C 53 A0  1 
1A23818 	 0  0  0  0 9C 53 A0  1 
1A23820 	 1 2F  0  0 18 70 A0  1 
	    else                  ( path$' tail$ r: first? )
1A23828 	C8 41 A0  1 14  0  0  0 
	       \ The next character was a slash, so it's a support package.
	       \ tail$ is path$ minus that slash, i.e. the new path$
	       2nip               ( path$'' r: first? )
1A23830 	 8 6A A0  1 
	       parse/             ( path$' component$ r: first? )
1A23834 	7C 37 A2  1 
	       parse:  true       ( path$ args$ devname$ package? )
1A23838 	9C 37 A2  1  4 70 A0  1 
	    then
         else
1A23840 	C8 41 A0  1 18  0  0  0 
            \ The rest of the string was empty, so it must be the root.
            " "  " /" false       ( path$' args$ devname$ package? r: first? )
1A23848 	9C 53 A0  1  0  0  0  0 
1A23850 	9C 53 A0  1  1 2F  0  0 
1A23858 	18 70 A0  1 
         then
      else                        ( path$' r: first? )
1A2385C 	C8 41 A0  1 
1A23860 	10  0  0  0 
         \ This is not the first path component, so it
         \ must be a support package
         parse/                   ( path$' component$ r: first? )
1A23864 	7C 37 A2  1 
         parse:  true             ( path$ args$ devname$ package? )
1A23868 	9C 37 A2  1  4 70 A0  1 
      then
   else
1A23870 	C8 41 A0  1  C  0  0  0 
      \ The first character was not a slash, so the component is an
      \ ordinary device node
      parse:  false               ( path$ args$ devname$ package? )
1A23878 	9C 37 A2  1 18 70 A0  1 
   then
   r> drop
1A23880 	D0 45 A0  1 30 49 A0  1 
;
1A23888 	58 46 A0  1 

: apply-method  ( adr len -- no-such-method? )
1A2388C 	 0  0  0 61 
1A23890 	70 70 6C 79 2D 6D 65 74 
1A23898 	68 6F 64 8C C4 37 A2  1 
1A238A0 	20 40 A0  1 
   my-voc fm-hook  ['] $package-execute?  catch  ?dup  if  ( x x x errno )
1A238A4 	10  4 A2  1 
1A238A8 	88 2F A2  1 60 53 A0  1 
1A238B0 	94  D A2  1 14 7F A0  1 
1A238B8 	B4 70 A0  1 DC 41 A0  1 
1A238C0 	10  0  0  0 
      \ executing method caused an error
      nip nip nip                                   ( errno )
1A238C4 	FC 46 A0  1 
1A238C8 	FC 46 A0  1 FC 46 A0  1 
   then                                             ( ??? false | true | errno )
;
1A238D0 	58 46 A0  1 

headerless

d# 64 buffer: package-name-buf
1A238D4 	 0  0  0 70 
1A238D8 	61 63 6B 61 67 65 2D 6E 
1A238E0 	61 6D 65 2D 62 75 66 90 
1A238E8 	A0 38 A2  1 B4 A9 A0  1 
1A238F0 	B8  6  0  0 40  0  0  0 
1A238F8 	94 1D A2  1 

headers
: open-package  ( args$ phandle -- ihandle )  recursive
1A238FC 	 0  0  0 6F 
1A23900 	70 65 6E 2D 70 61 63 6B 
1A23908 	61 67 65 8C EC 38 A2  1 
1A23910 	20 40 A0  1 
   push-package                              ( args$ )
1A23914 	7C FB A1  1 
   new-instance                              ( )
1A23918 	9C  8 A2  1 
   "open" apply-method  if  false  then  if  ( )
1A2391C 	90 30 A2  1 
1A23920 	A0 38 A2  1 DC 41 A0  1 
1A23928 	 8  0  0  0 18 70 A0  1 
1A23930 	DC 41 A0  1 48  0  0  0 
      package-interposed?  if                ( arg$ phandle )
1A23938 	 0 35 A2  1 DC 41 A0  1 
1A23940 	24  0  0  0 
         open-package                        ( ihandle|0 )
1A23944 	10 39 A2  1 
         dup  0=  if  destroy-instance  then ( )
1A23948 	40 49 A0  1 24 47 A0  1 
1A23950 	DC 41 A0  1  8  0  0  0 
1A23958 	38  9 A2  1 
      else                                   ( )
1A2395C 	C8 41 A0  1 
1A23960 	14  0  0  0 
         my-self  my-parent is my-self       ( ihandle )
1A23964 	EC 7E A0  1 
1A23968 	28  4 A2  1 B8 40 A0  1 
1A23970 	EC 7E A0  1 
      then                                   ( )
   else                                      ( )
1A23974 	C8 41 A0  1 
1A23978 	 C  0  0  0 
      destroy-instance  0                    ( 0 )
1A2397C 	38  9 A2  1 
1A23980 	70 6F A0  1 
   then                                      ( ihandle )
   pop-package                               ( ihandle )
1A23984 	D8 FB A1  1 
;
1A23988 	58 46 A0  1 

defer load-package  ( name$ -- false  |  phandle true )
1A2398C 	 0  0  0 6C 
1A23990 	6F 61 64 2D 70 61 63 6B 
1A23998 	61 67 65 8C 10 39 A2  1 
1A239A0 	5C 40 A0  1 BC  6  0  0 
: no-load-package   ( name$ -- false )  2drop false  ;
1A239A8 	6E 6F 2D 6C 6F 61 64 2D 
1A239B0 	70 61 63 6B 61 67 65 8F 
1A239B8 	A0 39 A2  1 20 40 A0  1 
1A239C0 	AC 49 A0  1 18 70 A0  1 
1A239C8 	58 46 A0  1 
' no-load-package is load-package

: find-package  ( name$ -- false  |  phandle true )
1A239CC 	 0  0  0 66 
1A239D0 	69 6E 64 2D 70 61 63 6B 
1A239D8 	61 67 65 8C BC 39 A2  1 
1A239E0 	20 40 A0  1 
   dup 0=  if  true  else  over c@  ascii / <>  then  ( name$ relative? )
1A239E4 	40 49 A0  1 
1A239E8 	24 47 A0  1 DC 41 A0  1 
1A239F0 	10  0  0  0  4 70 A0  1 
1A239F8 	C8 41 A0  1 18  0  0  0 
1A23A00 	54 49 A0  1 C4 4C A0  1 
1A23A08 	58 41 A0  1 2F  0  0  0 
1A23A10 	44 48 A0  1 
   if                                                 ( name$ )
1A23A14 	DC 41 A0  1 
1A23A18 	28  0  0  0 
      " /packages/" package-name-buf pack  $cat       ( )
1A23A1C 	9C 53 A0  1 
1A23A20 	 A 2F 70 61 63 6B 61 67 
1A23A28 	65 73 2F  0 EC 38 A2  1 
1A23A30 	DC 52 A0  1 84 7E A0  1 
      package-name-buf count                          ( name$' )
1A23A38 	EC 38 A2  1 BC 53 A0  1 
   then                                               ( name$' )
   2dup locate-device  if                             ( name$ )
1A23A40 	C0 49 A0  1 EC 21 A2  1 
1A23A48 	DC 41 A0  1 10  0  0  0 
      load-package                                    ( false | phandle true )
1A23A50 	A0 39 A2  1 
   else                                               ( name$ phandle )
1A23A54 	C8 41 A0  1 
1A23A58 	10  0  0  0 
      nip nip true                                    ( phandle true )
1A23A5C 	FC 46 A0  1 
1A23A60 	FC 46 A0  1  4 70 A0  1 
   then                                               ( false | phandle true )
;
1A23A68 	58 46 A0  1 

: $open-package  ( arg$ name$ -- ihandle )
1A23A6C 	 0  0 24 6F 
1A23A70 	70 65 6E 2D 70 61 63 6B 
1A23A78 	61 67 65 8D E0 39 A2  1 
1A23A80 	20 40 A0  1 
   find-package  if  open-package  else  2drop 0  then
1A23A84 	E0 39 A2  1 
1A23A88 	DC 41 A0  1 10  0  0  0 
1A23A90 	10 39 A2  1 C8 41 A0  1 
1A23A98 	 C  0  0  0 AC 49 A0  1 
1A23AA0 	70 6F A0  1 
;
1A23AA4 	58 46 A0  1 

: $delete-package  ( adr len -- )
1A23AA8 	24 64 65 6C 65 74 65 2D 
1A23AB0 	70 61 63 6B 61 67 65 8F 
1A23AB8 	80 3A A2  1 20 40 A0  1 
   locate-device abort" Can't find package" delete-package
1A23AC0 	EC 21 A2  1  8 81 A0  1 
1A23AC8 	12 43 61 6E 27 74 20 66 
1A23AD0 	69 6E 64 20 70 61 63 6B 
1A23AD8 	61 67 65  0 78 12 A2  1 
;
1A23AE0 	58 46 A0  1 

headers

: my-unit-bounds  ( -- end-adr start-adr )
1A23AE4 	 0 6D 79 2D 
1A23AE8 	75 6E 69 74 2D 62 6F 75 
1A23AF0 	6E 64 73 8E BC 3A A2  1 
1A23AF8 	20 40 A0  1 
   addr my-unit-low  '#adr-cells @ /n*  bounds
1A23AFC 	5C B8 A1  1 
1A23B00 	B8  4 A2  1 4C FA A1  1 
1A23B08 	5C 4C A0  1 98 51 A0  1 
1A23B10 	F0 6D A0  1 
;
1A23B14 	58 46 A0  1 
: set-my-unit  ( phys.hi .. phys.lo -- )
1A23B18 	73 65 74 2D 6D 79 2D 75 
1A23B20 	6E 69 74 8B F8 3A A2  1 
1A23B28 	20 40 A0  1 
   my-unit-bounds  ?do  i !  /n +loop
1A23B2C 	F8 3A A2  1 
1A23B30 	50 42 A0  1 18  0  0  0 
1A23B38 	B4 42 A0  1 54 4D A0  1 
1A23B40 	40 51 A0  1 1C 42 A0  1 
1A23B48 	F0 FF FF FF 
;
1A23B4C 	58 46 A0  1 

: set-default-unit  ( -- )
1A23B50 	 0  0  0 73 65 74 2D 64 
1A23B58 	65 66 61 75 6C 74 2D 75 
1A23B60 	6E 69 74 90 28 3B A2  1 
1A23B68 	20 40 A0  1 
   get-unit  if                         ( )
1A23B6C 	90 15 A2  1 
1A23B70 	DC 41 A0  1 2C  0  0  0 
      '#adr-cells @  0  ?do  0  loop    ( phys.. )
1A23B78 	4C FA A1  1 5C 4C A0  1 
1A23B80 	70 6F A0  1 50 42 A0  1 
1A23B88 	10  0  0  0 70 6F A0  1 
1A23B90 	F8 41 A0  1 F8 FF FF FF 
   else                                 ( adr len )
1A23B98 	C8 41 A0  1  8  0  0  0 
      unit-str>phys-                    ( phys.. )
1A23BA0 	BC 15 A2  1 
   then                                 ( phys.. )
   set-my-unit                          ( )
1A23BA4 	28 3B A2  1 
;
1A23BA8 	58 46 A0  1 

\ Set the my-unit fields in the instance record:
\ If an address was given in path component, use it
\ If not, use address in "reg" property of package
\ Otherwise, use 0,0
: set-instance-address  ( -- )
1A23BAC 	 0  0  0 73 
1A23BB0 	65 74 2D 69 6E 73 74 61 
1A23BB8 	6E 63 65 2D 61 64 64 72 
1A23BC0 	65 73 73 94 68 3B A2  1 
1A23BC8 	20 40 A0  1 
   unit#-valid?  if
1A23BCC 	40 18 A2  1 
1A23BD0 	DC 41 A0  1 30  0  0  0 
      unit-bounds  ?do  i @  /n +loop  set-my-unit
1A23BD8 	58 18 A2  1 50 42 A0  1 
1A23BE0 	18  0  0  0 B4 42 A0  1 
1A23BE8 	5C 4C A0  1 40 51 A0  1 
1A23BF0 	1C 42 A0  1 F0 FF FF FF 
1A23BF8 	28 3B A2  1 
   else
1A23BFC 	C8 41 A0  1 
1A23C00 	 8  0  0  0 
      set-default-unit
1A23C04 	68 3B A2  1 
   then
;
1A23C08 	58 46 A0  1 

headerless
: (apply-method)  ( adr len -- ??? )
1A23C0C 	 0 28 61 70 
1A23C10 	70 6C 79 2D 6D 65 74 68 
1A23C18 	6F 64 29 8E C8 3B A2  1 
1A23C20 	20 40 A0  1 
   apply-method  if  close-chain no-proc throw  then    ( )
1A23C24 	A0 38 A2  1 
1A23C28 	DC 41 A0  1 10  0  0  0 
1A23C30 	3C 37 A2  1 4C 2F A2  1 
1A23C38 	74 7F A0  1 
;
1A23C3C 	58 46 A0  1 
: (open-node)  ( -- )
1A23C40 	28 6F 70 65 6E 2D 6E 6F 
1A23C48 	64 65 29 8B 20 3C A2  1 
1A23C50 	20 40 A0  1 
   "open"  (apply-method)  0=  if          ( okay? )
1A23C54 	90 30 A2  1 
1A23C58 	20 3C A2  1 24 47 A0  1 
1A23C60 	DC 41 A0  1 20  0  0  0 
      close-chain  true abort" open failed" ( )
1A23C68 	3C 37 A2  1  4 70 A0  1 
1A23C70 	 8 81 A0  1  B 6F 70 65 
1A23C78 	6E 20 66 61 69 6C 65 64 
1A23C80 	 0  0  0  0 
   then
;
1A23C84 	58 46 A0  1 
: open-node  ( -- ) recursive
1A23C88 	 0  0 6F 70 65 6E 2D 6E 
1A23C90 	6F 64 65 89 50 3C A2  1 
1A23C98 	20 40 A0  1 
   (open-node)
1A23C9C 	50 3C A2  1 
   interposed?  if                              ( arg$ phandle )
1A23CA0 	A0 34 A2  1 DC 41 A0  1 
1A23CA8 	20  0  0  0 
      push-package  new-instance  ['] open-node catch  pop-package  ( error? )
1A23CAC 	7C FB A1  1 
1A23CB0 	9C  8 A2  1 60 53 A0  1 
1A23CB8 	98 3C A2  1 14 7F A0  1 
1A23CC0 	D8 FB A1  1 
      throw
1A23CC4 	74 7F A0  1 
   then
;
1A23CC8 	58 46 A0  1 

: open-parents  ( parent-phandle end-phandle -- )   recursive
1A23CCC 	 0  0  0 6F 
1A23CD0 	70 65 6E 2D 70 61 72 65 
1A23CD8 	6E 74 73 8C 98 3C A2  1 
1A23CE0 	20 40 A0  1 
   \ Exit at null "parent" of root node
   2dup =  if  2drop exit  then
1A23CE4 	C0 49 A0  1 
1A23CE8 	24 48 A0  1 DC 41 A0  1 
1A23CF0 	 C  0  0  0 AC 49 A0  1 
1A23CF8 	40 46 A0  1 

   over >parent swap  open-parents  ( phandle )
1A23CFC 	54 49 A0  1 
1A23D00 	C0 FA A1  1 68 49 A0  1 
1A23D08 	E0 3C A2  1 

   push-device                      (  )
1A23D0C 	F8 FB A1  1 
   " "  new-instance                (  )
1A23D10 	9C 53 A0  1  0  0  0  0 
1A23D18 	9C  8 A2  1 
   set-default-unit                 (  )
1A23D1C 	68 3B A2  1 
   open-node                        (  )
1A23D20 	98 3C A2  1 
;
1A23D24 	58 46 A0  1 

\ Open packages between, but not including, "phandle" and the active package
: select-node  ( path$ first? -- path$' )
1A23D28 	73 65 6C 65 63 74 2D 6E 
1A23D30 	6F 64 65 8B E0 3C A2  1 
1A23D38 	20 40 A0  1 
   current-device >r                        ( path$ first? )
1A23D3C 	40 F9 A1  1 
1A23D40 	BC 45 A0  1 
   parse-component  if                      ( path$ args$ devname$ )
1A23D44 	C4 37 A2  1 
1A23D48 	DC 41 A0  1 28  0  0  0 
      \ The path component is a support package
      find-package 0= throw                 ( path$ args$ my-phandle )
1A23D50 	E0 39 A2  1 24 47 A0  1 
1A23D58 	74 7F A0  1 
      push-device                           ( path$ args$ )
1A23D5C 	F8 FB A1  1 
      new-instance                          ( path$ )
1A23D60 	9C  8 A2  1 
      r> push-device                        ( path$ )
1A23D64 	D0 45 A0  1 
1A23D68 	F8 FB A1  1 
   else                                     ( path$ args$ devname$ )
1A23D6C 	C8 41 A0  1 
1A23D70 	40  0  0  0 
      \ The path component is an ordinary device node or the root node
      ['] noa-find-device  catch  ?dup  if  ( path$ args$ x x throw-code )
1A23D74 	60 53 A0  1 
1A23D78 	40 22 A2  1 14 7F A0  1 
1A23D80 	B4 70 A0  1 DC 41 A0  1 
1A23D88 	 C  0  0  0 
         close-parents  throw
1A23D8C 	 8 37 A2  1 
1A23D90 	74 7F A0  1 
      then                                  ( path$ args$ )
      current-device  parent-device  r> open-parents ( path$ args$ my-phandle )
1A23D94 	40 F9 A1  1 
1A23D98 	EC FA A1  1 D0 45 A0  1 
1A23DA0 	E0 3C A2  1 
      push-device                           ( path$ args$ )
1A23DA4 	F8 FB A1  1 
      new-instance                          ( path$ )
1A23DA8 	9C  8 A2  1 
      set-instance-address                  ( path$ )
1A23DAC 	C8 3B A2  1 
   then
;
1A23DB0 	58 46 A0  1 

: (open-path)  ( path$ -- )
1A23DB4 	28 6F 70 65 
1A23DB8 	6E 2D 70 61 74 68 29 8B 
1A23DC0 	38 3D A2  1 20 40 A0  1 
   0 to interposer
1A23DC8 	70 6F A0  1 B8 40 A0  1 
1A23DD0 	3C 34 A2  1 
   ?expand-alias  true select-node                          ( path$ )
1A23DD4 	CC 1F A2  1 
1A23DD8 	 4 70 A0  1 38 3D A2  1 
   begin  dup  while  open-node false select-node  repeat   ( path$' )
1A23DE0 	40 49 A0  1 DC 41 A0  1 
1A23DE8 	18  0  0  0 98 3C A2  1 
1A23DF0 	18 70 A0  1 38 3D A2  1 
1A23DF8 	C8 41 A0  1 E4 FF FF FF 
   2drop                                                    ( )
1A23E00 	AC 49 A0  1 
;
1A23E04 	58 46 A0  1 
\ Open pathname components until the last one, and then apply the indicated
\ method to the last component.
: open-path  ( path$ -- )
1A23E08 	 0  0 6F 70 65 6E 2D 70 
1A23E10 	61 74 68 89 C4 3D A2  1 
1A23E18 	20 40 A0  1 
   ?dup  if                                              ( path$ )
1A23E1C 	B4 70 A0  1 
1A23E20 	DC 41 A0  1 48  0  0  0 
      \ Establish the initial parent
      also						 ( path$ )	
1A23E28 	C8 C1 A0  1 
      dt-null to current-device                          ( path$ )
1A23E2C 	6C F8 A1  1 
1A23E30 	48 B8 A1  1 40 F9 A1  1 
      ['] (open-path) catch  dup  if  nip nip  then      ( error? )
1A23E38 	60 53 A0  1 C4 3D A2  1 
1A23E40 	14 7F A0  1 40 49 A0  1 
1A23E48 	DC 41 A0  1  C  0  0  0 
1A23E50 	FC 46 A0  1 FC 46 A0  1 
      previous definitions                               ( error? )
1A23E58 	E4 C3 A0  1 2C C4 A0  1 
      throw                                              ( )
1A23E60 	74 7F A0  1 
   else                                                  ( adr )
1A23E64 	C8 41 A0  1 
1A23E68 	 C  0  0  0 
      not-found throw                                    (  )
1A23E6C 	90 16 A2  1 
1A23E70 	74 7F A0  1 
   then                                                  (  )
;
1A23E74 	58 46 A0  1 

headers

: begin-open-dev  ( path$ -- ihandle )
1A23E78 	 0 62 65 67 69 6E 2D 6F 
1A23E80 	70 65 6E 2D 64 65 76 8E 
1A23E88 	18 3E A2  1 20 40 A0  1 
   0 package(  current-device >r
1A23E90 	70 6F A0  1 2C 31 A2  1 
1A23E98 	40 F9 A1  1 BC 45 A0  1 

      \ Since "catch/throw" saves and restores my-self,
      \ my-self will be 0 if a throw occurred.

      ['] open-path catch  if  2drop  then
1A23EA0 	60 53 A0  1 18 3E A2  1 
1A23EA8 	14 7F A0  1 DC 41 A0  1 
1A23EB0 	 8  0  0  0 AC 49 A0  1 
      my-self                                   ( ihandle )
1A23EB8 	EC 7E A0  1 

   r> push-device  )package                     ( ihandle )
1A23EBC 	D0 45 A0  1 
1A23EC0 	F8 FB A1  1 5C 31 A2  1 
;
1A23EC8 	58 46 A0  1 

headerless

: (open-dev)  ( path$ -- )  open-path  open-node  ;
1A23ECC 	 0 28 6F 70 
1A23ED0 	65 6E 2D 64 65 76 29 8A 
1A23ED8 	8C 3E A2  1 20 40 A0  1 
1A23EE0 	18 3E A2  1 98 3C A2  1 
1A23EE8 	58 46 A0  1 

headers

: open-dev  ( adr len -- ihandle | 0 )
1A23EEC 	 0  0  0 6F 
1A23EF0 	70 65 6E 2D 64 65 76 88 
1A23EF8 	DC 3E A2  1 20 40 A0  1 
   0 package(  current-device >r
1A23F00 	70 6F A0  1 2C 31 A2  1 
1A23F08 	40 F9 A1  1 BC 45 A0  1 

      \ Since "catch/throw" saves and restores my-self,
      \ my-self will be 0 if a throw occurred.

      ['] (open-dev) catch  if  2drop  then
1A23F10 	60 53 A0  1 DC 3E A2  1 
1A23F18 	14 7F A0  1 DC 41 A0  1 
1A23F20 	 8  0  0  0 AC 49 A0  1 
      my-self                                   ( ihandle )
1A23F28 	EC 7E A0  1 

   r> push-device  )package                     ( ihandle )
1A23F2C 	D0 45 A0  1 
1A23F30 	F8 FB A1  1 5C 31 A2  1 
;
1A23F38 	58 46 A0  1 

headerless

: (execute-method)  ( path$ method$ -- false | ??? true )
1A23F3C 	 0  0  0 28 
1A23F40 	65 78 65 63 75 74 65 2D 
1A23F48 	6D 65 74 68 6F 64 29 90 
1A23F50 	FC 3E A2  1 20 40 A0  1 
   2swap  open-path  (apply-method)
1A23F58 	F4 49 A0  1 18 3E A2  1 
1A23F60 	20 3C A2  1 
;
1A23F64 	58 46 A0  1 

headers

: execute-device-method  ( path$ method$ -- false | ??? true )
1A23F68 	 0  0 65 78 65 63 75 74 
1A23F70 	65 2D 64 65 76 69 63 65 
1A23F78 	2D 6D 65 74 68 6F 64 95 
1A23F80 	54 3F A2  1 20 40 A0  1 
   0 package(  current-device >r       ( path$ method$ )
1A23F88 	70 6F A0  1 2C 31 A2  1 
1A23F90 	40 F9 A1  1 BC 45 A0  1 
      ['] (execute-method)  catch  if  ( x x x x )
1A23F98 	60 53 A0  1 54 3F A2  1 
1A23FA0 	14 7F A0  1 DC 41 A0  1 
1A23FA8 	18  0  0  0 
         2drop 2drop  false            ( false )
1A23FAC 	AC 49 A0  1 
1A23FB0 	AC 49 A0  1 18 70 A0  1 
      else                             ( ??? )
1A23FB8 	C8 41 A0  1  C  0  0  0 
         close-chain  true             ( ??? true )
1A23FC0 	3C 37 A2  1  4 70 A0  1 
      then                             ( false | ??? true )
   r> push-device  )package            ( false | ??? true )
1A23FC8 	D0 45 A0  1 F8 FB A1  1 
1A23FD0 	5C 31 A2  1 
;
1A23FD4 	58 46 A0  1 

\ Easier to use version of execute-device-method
\
\ ex:  apply  selftest  net
\
: apply ( -- ??? ) \ method { devpath | alias }
1A23FD8 	 0  0 61 70 70 6C 79 85 
1A23FE0 	84 3F A2  1 20 40 A0  1 
   safe-parse-word  safe-parse-word  ( method$ devpath$ )
1A23FE8 	88 93 A0  1 88 93 A0  1 
   2swap  execute-device-method      ( ??? success? )
1A23FF0 	F4 49 A0  1 84 3F A2  1 
   0= abort" apply failed."          ( ??? )
1A23FF8 	24 47 A0  1  8 81 A0  1 
1A24000 	 D 61 70 70 6C 79 20 66 
1A24008 	61 69 6C 65 64 2E  0  0 
;
1A24010 	58 46 A0  1 


h# 10 circular-stack: istack
1A24014 	 0 69 73 74 
1A24018 	61 63 6B 86 E4 3F A2  1 
1A24020 	30 40 A0  1 C0  6  0  0 
1A24028 	44  0  0  0 EC 38 A2  1 

\ select-dev opens a package, sets my-self to that ihandle, pushes the
\ old my-self on the instance stack, and pushes that package's vocabulary
\ on the search order.  unselect-dev undoes select-dev .

: iselect  ( ihandle -- )
1A24030 	69 73 65 6C 65 63 74 87 
1A24038 	20 40 A2  1 20 40 A0  1 
   dup 0= abort" Invalid ihandle"  ( ihandle )
1A24040 	40 49 A0  1 24 47 A0  1 
1A24048 	 8 81 A0  1  F 49 6E 76 
1A24050 	61 6C 69 64 20 69 68 61 
1A24058 	6E 64 6C 65  0  0  0  0 
   my-self istack push  is my-self
1A24060 	EC 7E A0  1 20 40 A2  1 
1A24068 	7C  6 A1  1 B8 40 A0  1 
1A24070 	EC 7E A0  1 
   also my-voc  push-device
1A24074 	C8 C1 A0  1 
1A24078 	10  4 A2  1 F8 FB A1  1 
;
1A24080 	58 46 A0  1 
: iunselect  ( -- )  previous definitions  istack pop is my-self  ;
1A24084 	 0  0 69 75 
1A24088 	6E 73 65 6C 65 63 74 89 
1A24090 	3C 40 A2  1 20 40 A0  1 
1A24098 	E4 C3 A0  1 2C C4 A0  1 
1A240A0 	20 40 A2  1 C4  6 A1  1 
1A240A8 	B8 40 A0  1 EC 7E A0  1 
1A240B0 	58 46 A0  1 
: select-dev  ( adr,len -- )  open-dev  iselect  ;
1A240B4 	 0 73 65 6C 
1A240B8 	65 63 74 2D 64 65 76 8A 
1A240C0 	94 40 A2  1 20 40 A0  1 
1A240C8 	FC 3E A2  1 3C 40 A2  1 
1A240D0 	58 46 A0  1 
: begin-select-dev  ( adr,len -- )   begin-open-dev  iselect  ;
1A240D4 	 0  0  0 62 
1A240D8 	65 67 69 6E 2D 73 65 6C 
1A240E0 	65 63 74 2D 64 65 76 90 
1A240E8 	C4 40 A2  1 20 40 A0  1 
1A240F0 	8C 3E A2  1 3C 40 A2  1 
1A240F8 	58 46 A0  1 

: select  ( "name" -- )  safe-parse-word select-dev  ;
1A240FC 	 0 73 65 6C 
1A24100 	65 63 74 86 EC 40 A2  1 
1A24108 	20 40 A0  1 88 93 A0  1 
1A24110 	C4 40 A2  1 58 46 A0  1 
: begin-select  ( "name" -- )  safe-parse-word begin-select-dev  ;
1A24118 	 0  0  0 62 65 67 69 6E 
1A24120 	2D 73 65 6C 65 63 74 8C 
1A24128 	 8 41 A2  1 20 40 A0  1 
1A24130 	88 93 A0  1 EC 40 A2  1 
1A24138 	58 46 A0  1 

: unselect-dev  ( -- )   my-self  iunselect  close-dev  ;
1A2413C 	 0  0  0 75 
1A24140 	6E 73 65 6C 65 63 74 2D 
1A24148 	64 65 76 8C 2C 41 A2  1 
1A24150 	20 40 A0  1 EC 7E A0  1 
1A24158 	94 40 A2  1 5C 37 A2  1 
1A24160 	58 46 A0  1 
: unselect  ( -- )  unselect-dev  ;
1A24164 	 0  0  0 75 
1A24168 	6E 73 65 6C 65 63 74 88 
1A24170 	50 41 A2  1 20 40 A0  1 
1A24178 	50 41 A2  1 58 46 A0  1 

: begin-package  ( arg-str reg-str parent-str -- )
1A24180 	 0  0 62 65 67 69 6E 2D 
1A24188 	70 61 63 6B 61 67 65 8D 
1A24190 	74 41 A2  1 20 40 A0  1 
   select-dev  new-device  set-args
1A24198 	C4 40 A2  1 74  F A2  1 
1A241A0 	 4 33 A2  1 
;
1A241A4 	58 46 A0  1 

: end-package  ( -- )  finish-device  unselect-dev  ;
1A241A8 	65 6E 64 2D 70 61 63 6B 
1A241B0 	61 67 65 8B 94 41 A2  1 
1A241B8 	20 40 A0  1 74 11 A2  1 
1A241C0 	50 41 A2  1 58 46 A0  1 

: support-package:  ( "name" -- )
1A241C8 	 0  0  0 73 75 70 70 6F 
1A241D0 	72 74 2D 70 61 63 6B 61 
1A241D8 	67 65 3A 90 B8 41 A2  1 
1A241E0 	20 40 A0  1 
   " /packages" find-device
1A241E4 	9C 53 A0  1 
1A241E8 	 9 2F 70 61 63 6B 61 67 
1A241F0 	65 73  0  0 BC 22 A2  1 
   new-device
1A241F8 	74  F A2  1 
   safe-parse-word encode-string " name" property
1A241FC 	88 93 A0  1 
1A24200 	A0 F6 A1  1 9C 53 A0  1 
1A24208 	 4 6E 61 6D 65  0  0  0 
1A24210 	BC 14 A2  1 
;
1A24214 	58 46 A0  1 

: end-support-package  ( -- )  finish-device device-end  ;
1A24218 	65 6E 64 2D 73 75 70 70 
1A24220 	6F 72 74 2D 70 61 63 6B 
1A24228 	61 67 65 93 E0 41 A2  1 
1A24230 	20 40 A0  1 74 11 A2  1 
1A24238 	94  F A2  1 58 46 A0  1 

defer skip-test?  ( phandle -- flag )
1A24240 	 0 73 6B 69 70 2D 74 65 
1A24248 	73 74 3F 8A 30 42 A2  1 
1A24250 	5C 40 A0  1 C4  6  0  0 
: no-skip  ( phandle -- false )  drop false  ;
1A24258 	6E 6F 2D 73 6B 69 70 87 
1A24260 	50 42 A2  1 20 40 A0  1 
1A24268 	30 49 A0  1 18 70 A0  1 
1A24270 	58 46 A0  1 
' no-skip  to skip-test?

: (test-dev)  ( name,len -- )
1A24274 	 0 28 74 65 
1A24278 	73 74 2D 64 65 76 29 8A 
1A24280 	64 42 A2  1 20 40 A0  1 
   2dup  locate-device  if  ( name,len )
1A24288 	C0 49 A0  1 EC 21 A2  1 
1A24290 	DC 41 A0  1 38  0  0  0 
      ??cr  ." Device " type  ."  not found." cr exit
1A24298 	 0 A1 A0  1 20 7C A0  1 
1A242A0 	 7 44 65 76 69 63 65 20 
1A242A8 	 0  0  0  0  4 6C A0  1 
1A242B0 	20 7C A0  1  B 20 6E 6F 
1A242B8 	74 20 66 6F 75 6E 64 2E 
1A242C0 	 0  0  0  0 80 6D A0  1 
1A242C8 	40 46 A0  1 
   then   ( name,len  phandle )

   dup  skip-test?  if
1A242CC 	40 49 A0  1 
1A242D0 	50 42 A2  1 DC 41 A0  1 
1A242D8 	78  0  0  0 
      ." This implementation does not support selftest for plug-in devices." cr
1A242DC 	20 7C A0  1 
1A242E0 	42 54 68 69 73 20 69 6D 
1A242E8 	70 6C 65 6D 65 6E 74 61 
1A242F0 	74 69 6F 6E 20 64 6F 65 
1A242F8 	73 20 6E 6F 74 20 73 75 
1A24300 	70 70 6F 72 74 20 73 65 
1A24308 	6C 66 74 65 73 74 20 66 
1A24310 	6F 72 20 70 6C 75 67 2D 
1A24318 	69 6E 20 64 65 76 69 63 
1A24320 	65 73 2E  0 80 6D A0  1 
      drop type ."  is a plug-in device." cr
1A24328 	30 49 A0  1  4 6C A0  1 
1A24330 	20 7C A0  1 15 20 69 73 
1A24338 	20 61 20 70 6C 75 67 2D 
1A24340 	69 6E 20 64 65 76 69 63 
1A24348 	65 2E  0  0 80 6D A0  1 
   then

   drop 2dup >r >r                        ( name,len )         ( r: len,name )
1A24350 	30 49 A0  1 C0 49 A0  1 
1A24358 	BC 45 A0  1 BC 45 A0  1 
   " selftest" execute-device-method  if  ( test-result-flag ) ( r: len,name )
1A24360 	9C 53 A0  1  8 73 65 6C 
1A24368 	66 74 65 73 74  0  0  0 
1A24370 	84 3F A2  1 DC 41 A0  1 
1A24378 	70  0  0  0 
      ?dup  if                            ( error-code )       ( r: len,name )
1A2437C 	B4 70 A0  1 
1A24380 	DC 41 A0  1 50  0  0  0 
	 cr  r> r> type space             ( error-code )
1A24388 	80 6D A0  1 D0 45 A0  1 
1A24390 	D0 45 A0  1  4 6C A0  1 
1A24398 	CC 71 A0  1 
	 ." selftest failed. Return code = " .d cr  ( )
1A2439C 	20 7C A0  1 
1A243A0 	1F 73 65 6C 66 74 65 73 
1A243A8 	74 20 66 61 69 6C 65 64 
1A243B0 	2E 20 52 65 74 75 72 6E 
1A243B8 	20 63 6F 64 65 20 3D 20 
1A243C0 	 0  0  0  0 48  E A1  1 
1A243C8 	80 6D A0  1 
       else                               (  ) ( r: len,name )
1A243CC 	C8 41 A0  1 
1A243D0 	10  0  0  0 
	  r> r> 2drop                     (  )
1A243D4 	D0 45 A0  1 
1A243D8 	D0 45 A0  1 AC 49 A0  1 
       then                               (  )
    else                                  (  ) ( r: len,name )
1A243E0 	C8 41 A0  1 3C  0  0  0 
       ??cr ." No selftest method for " r> r> type space cr
1A243E8 	 0 A1 A0  1 20 7C A0  1 
1A243F0 	17 4E 6F 20 73 65 6C 66 
1A243F8 	74 65 73 74 20 6D 65 74 
1A24400 	68 6F 64 20 66 6F 72 20 
1A24408 	 0  0  0  0 D0 45 A0  1 
1A24410 	D0 45 A0  1  4 6C A0  1 
1A24418 	CC 71 A0  1 80 6D A0  1 
    then  true throw
1A24420 	 4 70 A0  1 74 7F A0  1 
;
1A24428 	58 46 A0  1 
: test-dev ( name,len -- )  ['] (test-dev) catch  if  2drop  then  ;
1A2442C 	 0  0  0 74 
1A24430 	65 73 74 2D 64 65 76 88 
1A24438 	84 42 A2  1 20 40 A0  1 
1A24440 	60 53 A0  1 84 42 A2  1 
1A24448 	14 7F A0  1 DC 41 A0  1 
1A24450 	 8  0  0  0 AC 49 A0  1 
1A24458 	58 46 A0  1 

: test   \ device-specifier  ( -- )
1A2445C 	 0  0  0 74 
1A24460 	65 73 74 84 3C 44 A2  1 
1A24468 	20 40 A0  1 
   \ Get device specifier string
   parse-word  ( adr len )
1A2446C 	34 93 A0  1 
   dup 0=  if
1A24470 	40 49 A0  1 24 47 A0  1 
1A24478 	DC 41 A0  1 30  0  0  0 
      ??cr ." No device name specified."
1A24480 	 0 A1 A0  1 20 7C A0  1 
1A24488 	19 4E 6F 20 64 65 76 69 
1A24490 	63 65 20 6E 61 6D 65 20 
1A24498 	73 70 65 63 69 66 69 65 
1A244A0 	64 2E  0  0 
   else
1A244A4 	C8 41 A0  1 
1A244A8 	 8  0  0  0 
      test-dev
1A244AC 	3C 44 A2  1 
   then
;
1A244B0 	58 46 A0  1 

headerless
\ XXX This really needs to append the stuff to a given string buffer
: .instance-name  ( -- )
1A244B4 	 0 2E 69 6E 
1A244B8 	73 74 61 6E 63 65 2D 6E 
1A244C0 	61 6D 65 8E 68 44 A2  1 
1A244C8 	20 40 A0  1 
   " name" get-my-property  0=  if  get-encoded-string type  then
1A244CC 	9C 53 A0  1 
1A244D0 	 4 6E 61 6D 65  0  0  0 
1A244D8 	1C 34 A2  1 24 47 A0  1 
1A244E0 	DC 41 A0  1  C  0  0  0 
1A244E8 	24 F7 A1  1  4 6C A0  1 
   my-unit  ." @"  .nh  ." ,"  .nh
1A244F0 	70 10 A2  1 20 7C A0  1 
1A244F8 	 1 40  0  0 28 23 A2  1 
1A24500 	20 7C A0  1  1 2C  0  0 
1A24508 	28 23 A2  1 
   my-args  ?dup  if  ." :" type  else  drop  then
1A2450C 	10  7 A2  1 
1A24510 	B4 70 A0  1 DC 41 A0  1 
1A24518 	18  0  0  0 20 7C A0  1 
1A24520 	 1 3A  0  0  4 6C A0  1 
1A24528 	C8 41 A0  1  8  0  0  0 
1A24530 	30 49 A0  1 
;
1A24534 	58 46 A0  1 
headers
: .path  ( ihandle -- )  recursive
1A24538 	 0  0 2E 70 61 74 68 85 
1A24540 	C8 44 A2  1 20 40 A0  1 
   ?dup  if
1A24548 	B4 70 A0  1 DC 41 A0  1 
1A24550 	2C  0  0  0 
      package(
1A24554 	2C 31 A2  1 
         my-parent  ?dup  if   .path  ." /"  .instance-name  then
1A24558 	28  4 A2  1 B4 70 A0  1 
1A24560 	DC 41 A0  1 14  0  0  0 
1A24568 	44 45 A2  1 20 7C A0  1 
1A24570 	 1 2F  0  0 C8 44 A2  1 
      )package
1A24578 	5C 31 A2  1 
   then
;
1A2457C 	58 46 A0  1 

headerless

: (execute-phandle-method)  ( method-adr,len phandle -- ??? )
1A24580 	 0  0  0 28 65 78 65 63 
1A24588 	75 74 65 2D 70 68 61 6E 
1A24590 	64 6C 65 2D 6D 65 74 68 
1A24598 	6F 64 29 98 44 45 A2  1 
1A245A0 	20 40 A0  1 
   0 to unit#-valid?              ( method-adr,len phandle )
1A245A4 	70 6F A0  1 
1A245A8 	B8 40 A0  1 40 18 A2  1 
   dup >parent dt-null open-parents  ( method-adr,len phandle )
1A245B0 	40 49 A0  1 C0 FA A1  1 
1A245B8 	6C F8 A1  1 E0 3C A2  1 
   push-device                    ( method-adr,len )
1A245C0 	F8 FB A1  1 
   " "  new-instance              ( method-adr,len )
1A245C4 	9C 53 A0  1 
1A245C8 	 0  0  0  0 9C  8 A2  1 
   set-default-unit               ( method-adr,len )
1A245D0 	68 3B A2  1 
   (apply-method)                 ( ???? )
1A245D4 	20 3C A2  1 
;
1A245D8 	58 46 A0  1 

headers
: open-phandle  ( phandle -- ihandle | 0 )
1A245DC 	 0  0  0 6F 
1A245E0 	70 65 6E 2D 70 68 61 6E 
1A245E8 	64 6C 65 8C A0 45 A2  1 
1A245F0 	20 40 A0  1 
   0 package(                   ( phandle )
1A245F4 	70 6F A0  1 
1A245F8 	2C 31 A2  1 
      current-device >r         ( phandle )
1A245FC 	40 F9 A1  1 
1A24600 	BC 45 A0  1 
      0 to unit#-valid?         ( phandle )
1A24604 	70 6F A0  1 
1A24608 	B8 40 A0  1 40 18 A2  1 
      dt-null ['] open-parents catch  if  ( x x )
1A24610 	6C F8 A1  1 60 53 A0  1 
1A24618 	E0 3C A2  1 14 7F A0  1 
1A24620 	DC 41 A0  1 14  0  0  0 
         2drop  0               ( 0 )
1A24628 	AC 49 A0  1 70 6F A0  1 
      else                      (   )
1A24630 	C8 41 A0  1  8  0  0  0 
         my-self                ( ihandle )
1A24638 	EC 7E A0  1 
      then                      ( ihandle | 0 )
      r> push-device            ( ihandle | 0 )
1A2463C 	D0 45 A0  1 
1A24640 	F8 FB A1  1 
   )package                     ( ihandle | 0 )
1A24644 	5C 31 A2  1 
;
1A24648 	58 46 A0  1 

: execute-phandle-method  ( method-adr,len phandle -- false | ??? true )
1A2464C 	 0 65 78 65 
1A24650 	63 75 74 65 2D 70 68 61 
1A24658 	6E 64 6C 65 2D 6D 65 74 
1A24660 	68 6F 64 96 F0 45 A2  1 
1A24668 	20 40 A0  1 
   3dup find-method  if  drop  else  false exit  then
1A2466C 	A4 52 A0  1 
1A24670 	A0 2F A2  1 DC 41 A0  1 
1A24678 	10  0  0  0 30 49 A0  1 
1A24680 	C8 41 A0  1  C  0  0  0 
1A24688 	18 70 A0  1 40 46 A0  1 
   0 package(                                  ( method-adr,len phandle )
1A24690 	70 6F A0  1 2C 31 A2  1 
      current-device >r                        ( method-adr,len phandle )
1A24698 	40 F9 A1  1 BC 45 A0  1 
      ['] (execute-phandle-method)  catch  if  ( method-adr,len phandle err-code )
1A246A0 	60 53 A0  1 A0 45 A2  1 
1A246A8 	14 7F A0  1 DC 41 A0  1 
1A246B0 	14  0  0  0 
         3drop false                           ( false )
1A246B4 	90 52 A0  1 
1A246B8 	18 70 A0  1 
      else                                     ( ??? )
1A246BC 	C8 41 A0  1 
1A246C0 	 C  0  0  0 
         close-chain true                      ( ??? true )
1A246C4 	3C 37 A2  1 
1A246C8 	 4 70 A0  1 
      then                                     ( false | ??? true )
      r> push-device                           ( false | ??? true )
1A246CC 	D0 45 A0  1 
1A246D0 	F8 FB A1  1 
   )package                                    ( false | ??? true )
1A246D4 	5C 31 A2  1 
;
1A246D8 	58 46 A0  1 

\ Creates a copy of the named package, placing the new clone in the device
\ tree as a child of the package that was active when $clone-node was called,
\ and makes the new clone the current instance and the active package.
: $clone-node  ( name$ -- )
1A246DC 	24 63 6C 6F 
1A246E0 	6E 65 2D 6E 6F 64 65 8B 
1A246E8 	68 46 A2  1 20 40 A0  1 
   find-package 0= abort" No such node"  current-device  (clone)
1A246F0 	E0 39 A2  1 24 47 A0  1 
1A246F8 	 8 81 A0  1  C 4E 6F 20 
1A24700 	73 75 63 68 20 6E 6F 64 
1A24708 	65  0  0  0 40 F9 A1  1 
1A24710 	BC  E A2  1 
;
1A24714 	58 46 A0  1 
headers

\ From comprop.fth
purpose:

: encode-ints  ( nn .. n1 n -- adr len )
1A24718 	65 6E 63 6F 64 65 2D 69 
1A24720 	6E 74 73 8B EC 46 A2  1 
1A24728 	20 40 A0  1 
   0 0 encode-bytes   rot  0  ?do  rot encode-int encode+  loop
1A2472C 	70 6F A0  1 
1A24730 	70 6F A0  1 14 F6 A1  1 
1A24738 	7C 49 A0  1 70 6F A0  1 
1A24740 	50 42 A0  1 18  0  0  0 
1A24748 	7C 49 A0  1 40 F7 A1  1 
1A24750 	F0 F5 A1  1 F8 41 A0  1 
1A24758 	F0 FF FF FF 
;
1A2475C 	58 46 A0  1 
: decode-ints  ( adr len n -- nn .. n1 )
1A24760 	64 65 63 6F 64 65 2D 69 
1A24768 	6E 74 73 8B 28 47 A2  1 
1A24770 	20 40 A0  1 
   dup begin  ?dup  while              ( adr len n cnt )     ( r: phys.hi.. )
1A24774 	40 49 A0  1 
1A24778 	B4 70 A0  1 DC 41 A0  1 
1A24780 	2C  0  0  0 
      >r >r  decode-int r> r> rot >r   ( adr' len' n cnt )   ( r: phys.hi... )
1A24784 	BC 45 A0  1 
1A24788 	BC 45 A0  1 68 F7 A1  1 
1A24790 	D0 45 A0  1 D0 45 A0  1 
1A24798 	7C 49 A0  1 BC 45 A0  1 
      1-                               ( adr' len' n cnt-1 ) ( r: phys.hi... )
1A247A0 	54 4B A0  1 
   repeat                              ( adr' len' n )       ( r: phys.hi..lo )
1A247A4 	C8 41 A0  1 
1A247A8 	D0 FF FF FF 
   begin  ?dup  while                  ( adr' len' cnt )     ( r: phys.hi.. )
1A247AC 	B4 70 A0  1 
1A247B0 	DC 41 A0  1 18  0  0  0 
      r> swap 1-                       ( adr' len' phys.lo.. cnt-1 )
1A247B8 	D0 45 A0  1 68 49 A0  1 
1A247C0 	54 4B A0  1 
   repeat                              ( adr' len' phys.lo..hi )
1A247C4 	C8 41 A0  1 
1A247C8 	E4 FF FF FF 
;
1A247CC 	58 46 A0  1 
: encode-phys  ( phys.lo..hi -- addr len )  my-#adr-cells encode-ints  ;
1A247D0 	65 6E 63 6F 64 65 2D 70 
1A247D8 	68 79 73 8B 70 47 A2  1 
1A247E0 	20 40 A0  1 D8  F A2  1 
1A247E8 	28 47 A2  1 58 46 A0  1 

: decode-phys  ( adr len -- adr' len' phys.lo..hi )
1A247F0 	64 65 63 6F 64 65 2D 70 
1A247F8 	68 79 73 8B E0 47 A2  1 
1A24800 	20 40 A0  1 
   my-#adr-cells decode-ints
1A24804 	D8  F A2  1 
1A24808 	70 47 A2  1 
;
1A2480C 	58 46 A0  1 

: encode-reg  ( phys.lo..hi size -- adr len )
1A24810 	 0 65 6E 63 6F 64 65 2D 
1A24818 	72 65 67 8A  0 48 A2  1 
1A24820 	20 40 A0  1 
   >r  encode-phys  r> encode-int encode+
1A24824 	BC 45 A0  1 
1A24828 	E0 47 A2  1 D0 45 A0  1 
1A24830 	40 F7 A1  1 F0 F5 A1  1 
;
1A24838 	58 46 A0  1 

headerless
\ The IEEE standard restricts the use of encode-reg to buses
\ with #size-cells=1 .  Therefore, the generalized code that
\ immediately follows is not strictly necessary; the simplified
\ version above is sufficient for IEEE compliance.

: my-parent-#size-cells  ( -- #size-cells )
1A2483C 	 0  0 6D 79 
1A24840 	2D 70 61 72 65 6E 74 2D 
1A24848 	23 73 69 7A 65 2D 63 65 
1A24850 	6C 6C 73 95 20 48 A2  1 
1A24858 	20 40 A0  1 
   \ Root node has no parent, therefore the size of its parent's address
   \ space is meaningless
   my-voc  root-phandle =  if  0  exit  then
1A2485C 	10  4 A2  1 
1A24860 	F8 10 A2  1 24 48 A0  1 
1A24868 	DC 41 A0  1  C  0  0  0 
1A24870 	70 6F A0  1 40 46 A0  1 

   " #size-cells"    my-parent ihandle>phandle  ( adr len phandle )
1A24878 	9C 53 A0  1  B 23 73 69 
1A24880 	7A 65 2D 63 65 6C 6C 73 
1A24888 	 0  0  0  0 28  4 A2  1 
1A24890 	 0 32 A2  1 
   get-package-property  if  1  else  get-encoded-int  then
1A24894 	98 33 A2  1 
1A24898 	DC 41 A0  1 10  0  0  0 
1A248A0 	80 6F A0  1 C8 41 A0  1 
1A248A8 	 8  0  0  0 A0 F7 A1  1 
;
1A248B0 	58 46 A0  1 

headers
[ifdef] notdef
: n>r  ( nn .. n1 n -- )
   dup r>  swap  begin  ?dup  while   ( nn .. nm n retadr cnt )
      3 pick >r  1-                   ( nn .. nm+1 n retadr cnt-1 ) ( r: .. )
   repeat                             ( n retadr )
   swap >r >r                         ( )
;

: nr>  ( -- nn .. n1 )
   r> r> swap                                ( retadr n )
   begin  ?dup  while  r> -rot  1-  repeat   ( retadr )
   >r
;

: encode-reg  ( phys.lo..hi size.lo..hi -- adr len )
   my-parent-#size-cells n>r              ( phys.lo..hi )
   encode-phys                            ( adr len )
   nr>                                    ( adr len size.lo..hi n )
   my-parent-#size-cells  encode-ints     ( adr len adr1 len1 )
   encode+                                ( adr len )
;
[then]

: string-property   ( value-adr,len name-adr,len -- )
1A248B4 	73 74 72 69 
1A248B8 	6E 67 2D 70 72 6F 70 65 
1A248C0 	72 74 79 8F 58 48 A2  1 
1A248C8 	20 40 A0  1 
   2swap encode-string 2swap  property
1A248CC 	F4 49 A0  1 
1A248D0 	A0 F6 A1  1 F4 49 A0  1 
1A248D8 	BC 14 A2  1 
;
1A248DC 	58 46 A0  1 
: integer-property ( value  name-adr,len -- )
1A248E0 	 0  0  0 69 6E 74 65 67 
1A248E8 	65 72 2D 70 72 6F 70 65 
1A248F0 	72 74 79 90 C8 48 A2  1 
1A248F8 	20 40 A0  1 
   rot encode-int 2swap property
1A248FC 	7C 49 A0  1 
1A24900 	40 F7 A1  1 F4 49 A0  1 
1A24908 	BC 14 A2  1 
;
1A2490C 	58 46 A0  1 
: device-name  ( adr len -- )  " name" string-property  ;
1A24910 	64 65 76 69 63 65 2D 6E 
1A24918 	61 6D 65 8B F8 48 A2  1 
1A24920 	20 40 A0  1 9C 53 A0  1 
1A24928 	 4 6E 61 6D 65  0  0  0 
1A24930 	C8 48 A2  1 58 46 A0  1 
alias nameprop device-name
1A24938 	 0  0  0 6E 61 6D 65 70 
1A24940 	72 6F 70 A8 20 49 A2  1 
1A24948 	20 49 A2  1 

: driver  ( adr len -- )   \ string is of the form: manufacturer,name
1A2494C 	 0 64 72 69 
1A24950 	76 65 72 86 48 49 A2  1 
1A24958 	20 40 A0  1 
   ascii , left-parse-string                          ( after-, before-, )
1A2495C 	58 41 A0  1 
1A24960 	2C  0  0  0 44 D7 A0  1 
   2swap  dup  if                                     ( man.-str name-str )
1A24968 	F4 49 A0  1 40 49 A0  1 
1A24970 	DC 41 A0  1 28  0  0  0 
      device-name
1A24978 	20 49 A2  1 
      " manufacturer" string-property
1A2497C 	9C 53 A0  1 
1A24980 	 C 6D 61 6E 75 66 61 63 
1A24988 	74 75 72 65 72  0  0  0 
1A24990 	C8 48 A2  1 
   else                                               ( null-str name-str )
1A24994 	C8 41 A0  1 
1A24998 	 C  0  0  0 
      2drop  device-name
1A2499C 	AC 49 A0  1 
1A249A0 	20 49 A2  1 
   then
;
1A249A4 	58 46 A0  1 
: device-type  ( adr len -- )  " device_type" string-property  ;
1A249A8 	64 65 76 69 63 65 2D 74 
1A249B0 	79 70 65 8B 58 49 A2  1 
1A249B8 	20 40 A0  1 9C 53 A0  1 
1A249C0 	 B 64 65 76 69 63 65 5F 
1A249C8 	74 79 70 65  0  0  0  0 
1A249D0 	C8 48 A2  1 58 46 A0  1 

\ This is a handy tool for amending "compatible" properties.
\ It prepends the string on the stack to the beginning of the existing
\ "compatible" property, or creates the property if it doesn't exist.
: +compatible  ( compat$ -- )
1A249D8 	2B 63 6F 6D 70 61 74 69 
1A249E0 	62 6C 65 8B B8 49 A2  1 
1A249E8 	20 40 A0  1 
   encode-string                        ( prop$ )
1A249EC 	A0 F6 A1  1 
   " compatible" get-property  0=  if   ( prop$ old-prop$ )
1A249F0 	9C 53 A0  1  A 63 6F 6D 
1A249F8 	70 61 74 69 62 6C 65  0 
1A24A00 	F4  D A2  1 24 47 A0  1 
1A24A08 	DC 41 A0  1  C  0  0  0 
      encode-bytes encode+              ( prop$' )
1A24A10 	14 F6 A1  1 F0 F5 A1  1 
   then                                 ( prop$ )
   " compatible" property
1A24A18 	9C 53 A0  1  A 63 6F 6D 
1A24A20 	70 61 74 69 62 6C 65  0 
1A24A28 	BC 14 A2  1 
;
1A24A2C 	58 46 A0  1 

headerless

: modelprop        ( adr len -- )  " model"       string-property  ;
1A24A30 	 0  0 6D 6F 64 65 6C 70 
1A24A38 	72 6F 70 89 E8 49 A2  1 
1A24A40 	20 40 A0  1 9C 53 A0  1 
1A24A48 	 5 6D 6F 64 65 6C  0  0 
1A24A50 	C8 48 A2  1 58 46 A0  1 
: addrprop  ( a -- )  encode-int  " address" property  ;
1A24A58 	 0  0  0 61 64 64 72 70 
1A24A60 	72 6F 70 88 40 4A A2  1 
1A24A68 	20 40 A0  1 40 F7 A1  1 
1A24A70 	9C 53 A0  1  7 61 64 64 
1A24A78 	72 65 73 73  0  0  0  0 
1A24A80 	BC 14 A2  1 58 46 A0  1 
: regprop  ( address space size -- )
1A24A88 	72 65 67 70 72 6F 70 87 
1A24A90 	68 4A A2  1 20 40 A0  1 
   >r  encode-phys  r> encode-int encode+  " reg"  property
1A24A98 	BC 45 A0  1 E0 47 A2  1 
1A24AA0 	D0 45 A0  1 40 F7 A1  1 
1A24AA8 	F0 F5 A1  1 9C 53 A0  1 
1A24AB0 	 3 72 65 67  0  0  0  0 
1A24AB8 	BC 14 A2  1 
;
1A24ABC 	58 46 A0  1 

headers
: parse-int  ( adr len -- n )  dup  if  safe->number  else  2drop 0  then  ;
1A24AC0 	 0  0 70 61 72 73 65 2D 
1A24AC8 	69 6E 74 89 94 4A A2  1 
1A24AD0 	20 40 A0  1 40 49 A0  1 
1A24AD8 	DC 41 A0  1 10  0  0  0 
1A24AE0 	B8 19 A2  1 C8 41 A0  1 
1A24AE8 	 C  0  0  0 AC 49 A0  1 
1A24AF0 	70 6F A0  1 58 46 A0  1 

: parse-2int  ( adr len -- address space )
1A24AF8 	 0 70 61 72 73 65 2D 32 
1A24B00 	69 6E 74 8A D0 4A A2  1 
1A24B08 	20 40 A0  1 
   ascii , left-parse-string     ( after-str before-str )
1A24B0C 	58 41 A0  1 
1A24B10 	2C  0  0  0 44 D7 A0  1 
   parse-int  >r                ( after-str )
1A24B18 	D0 4A A2  1 BC 45 A0  1 
   parse-int  r>                ( address space )
1A24B20 	D0 4A A2  1 D0 45 A0  1 
;
1A24B28 	58 46 A0  1 
headerless
: encode-ranges ( offs bustype  phys offset size -- adr len )
1A24B2C 	 0  0 65 6E 
1A24B30 	63 6F 64 65 2D 72 61 6E 
1A24B38 	67 65 73 8D  8 4B A2  1 
1A24B40 	20 40 A0  1 
   >r >r >r  encode-phys  r> r> r> encode-reg  encode+
1A24B44 	BC 45 A0  1 
1A24B48 	BC 45 A0  1 BC 45 A0  1 
1A24B50 	E0 47 A2  1 D0 45 A0  1 
1A24B58 	D0 45 A0  1 D0 45 A0  1 
1A24B60 	20 48 A2  1 F0 F5 A1  1 
;
1A24B68 	58 46 A0  1 
headers
: encode-phandle  ( name$ -- adr len )
1A24B6C 	 0 65 6E 63 
1A24B70 	6F 64 65 2D 70 68 61 6E 
1A24B78 	64 6C 65 8E 40 4B A2  1 
1A24B80 	20 40 A0  1 
   locate-device abort" encode-phandle - Can't find package"  encode-int
1A24B84 	EC 21 A2  1 
1A24B88 	 8 81 A0  1 23 65 6E 63 
1A24B90 	6F 64 65 2D 70 68 61 6E 
1A24B98 	64 6C 65 20 2D 20 43 61 
1A24BA0 	6E 27 74 20 66 69 6E 64 
1A24BA8 	20 70 61 63 6B 61 67 65 
1A24BB0 	 0  0  0  0 40 F7 A1  1 
;
1A24BB8 	58 46 A0  1 

\ From finddisp.fth
purpose: 

\ Creates an alias for the full path of a given device.

headerless
variable 'fb-node  origin 'fb-node token!
1A24BBC 	 0  0  0 27 
1A24BC0 	66 62 2D 6E 6F 64 65 88 
1A24BC8 	80 4B A2  1 48 40 A0  1 
1A24BD0 	C8  6  0  0 
: encode-bytes+  ( adr1 len1  adr2 len2  --  adr1 len1+len2 )
1A24BD4 	 0  0 65 6E 
1A24BD8 	63 6F 64 65 2D 62 79 74 
1A24BE0 	65 73 2B 8D CC 4B A2  1 
1A24BE8 	20 40 A0  1 
   encode-bytes encode+
1A24BEC 	14 F6 A1  1 
1A24BF0 	F0 F5 A1  1 
;
1A24BF4 	58 46 A0  1 
: encode-number+  ( u adr,len -- adr,len' )
1A24BF8 	 0 65 6E 63 6F 64 65 2D 
1A24C00 	6E 75 6D 62 65 72 2B 8E 
1A24C08 	E8 4B A2  1 20 40 A0  1 
   push-hex
1A24C10 	5C F4 A0  1 
   rot  (u.)  encode-bytes+
1A24C14 	7C 49 A0  1 
1A24C18 	AC 77 A0  1 E8 4B A2  1 
   pop-base
1A24C20 	9C F4 A0  1 
;
1A24C24 	58 46 A0  1 

: encode-unit+  ( phys .. adr,len -- adr,len' )
1A24C28 	 0  0  0 65 6E 63 6F 64 
1A24C30 	65 2D 75 6E 69 74 2B 8C 
1A24C38 	 C 4C A2  1 20 40 A0  1 
   " decode-unit" parent-device find-method  if  drop  else
1A24C40 	9C 53 A0  1  B 64 65 63 
1A24C48 	6F 64 65 2D 75 6E 69 74 
1A24C50 	 0  0  0  0 EC FA A1  1 
1A24C58 	A0 2F A2  1 DC 41 A0  1 
1A24C60 	10  0  0  0 30 49 A0  1 
1A24C68 	C8 41 A0  1 30  0  0  0 
      \ Parent has no decode-unit--therefore we're done.
      2>r
1A24C70 	F8 45 A0  1 
      '#adr-cells @  0  ?do  drop  loop
1A24C74 	4C FA A1  1 
1A24C78 	5C 4C A0  1 70 6F A0  1 
1A24C80 	50 42 A0  1 10  0  0  0 
1A24C88 	30 49 A0  1 F8 41 A0  1 
1A24C90 	F8 FF FF FF 
      2r> exit
1A24C94 	10 46 A0  1 
1A24C98 	40 46 A0  1 
   then

   " @" encode-bytes+ 2>r	           ( phys .. )          ( R: $ )
1A24C9C 	9C 53 A0  1 
1A24CA0 	 1 40  0  0 E8 4B A2  1 
1A24CA8 	F8 45 A0  1 

   " encode-unit"  parent-device           ( phys .. adr,len phandle ) ( R: $ )
1A24CAC 	9C 53 A0  1 
1A24CB0 	 B 65 6E 63 6F 64 65 2D 
1A24CB8 	75 6E 69 74  0  0  0  0 
1A24CC0 	EC FA A1  1 
   $package-execute?  if                       ( phys .. )          ( R: $ )
1A24CC4 	94  D A2  1 
1A24CC8 	DC 41 A0  1 5C  0  0  0 

      2r>                                      ( phys .. adr,len )  ( R: )
1A24CD0 	10 46 A0  1 
      '#adr-cells @  if  encode-number+  then  ( phys .  adr,len' )
1A24CD4 	4C FA A1  1 
1A24CD8 	5C 4C A0  1 DC 41 A0  1 
1A24CE0 	 8  0  0  0  C 4C A2  1 
      '#adr-cells @ 1-  0 max  0  ?do          ( phys .. adr,len )
1A24CE8 	4C FA A1  1 5C 4C A0  1 
1A24CF0 	54 4B A0  1 70 6F A0  1 
1A24CF8 	9C 4A A0  1 70 6F A0  1 
1A24D00 	50 42 A0  1 1C  0  0  0 
         " ,"  encode-bytes+                   ( phys .. adr,len' )
1A24D08 	9C 53 A0  1  1 2C  0  0 
1A24D10 	E8 4B A2  1 
         encode-number+                        ( phys .  adr,len' )
1A24D14 	 C 4C A2  1 
      loop                                     ( adr,len )
1A24D18 	F8 41 A0  1 EC FF FF FF 
   else                                        ( unit-str )         ( R: $ )
1A24D20 	C8 41 A0  1 10  0  0  0 
      2r> 2swap encode-bytes+                  ( adr,len' )         ( R: )
1A24D28 	10 46 A0  1 F4 49 A0  1 
1A24D30 	E8 4B A2  1 
   then
;
1A24D34 	58 46 A0  1 

: (pwd$)  ( adr len -- adr len' )  recursive
1A24D38 	 0 28 70 77 64 24 29 86 
1A24D40 	3C 4C A2  1 20 40 A0  1 
   root-device? 0=  if
1A24D48 	4C 11 A2  1 24 47 A0  1 
1A24D50 	DC 41 A0  1 70  0  0  0 
      current-device >r  pop-device (pwd$)  r> push-device
1A24D58 	40 F9 A1  1 BC 45 A0  1 
1A24D60 	18 FC A1  1 44 4D A2  1 
1A24D68 	D0 45 A0  1 F8 FB A1  1 
      " /" encode-bytes+
1A24D70 	9C 53 A0  1  1 2F  0  0 
1A24D78 	E8 4B A2  1 
      " name" get-property  0=  if                 ( adr len name-adr1,len1 )
1A24D7C 	9C 53 A0  1 
1A24D80 	 4 6E 61 6D 65  0  0  0 
1A24D88 	F4  D A2  1 24 47 A0  1 
1A24D90 	DC 41 A0  1  C  0  0  0 
         get-encoded-string encode-bytes+          ( adr len' )
1A24D98 	24 F7 A1  1 E8 4B A2  1 
      then                                         ( adr len )
      get-unit  0=  if                             ( adr len unit-adr1,len1 )
1A24DA0 	90 15 A2  1 24 47 A0  1 
1A24DA8 	DC 41 A0  1 18  0  0  0 
         2swap 2>r  unit-str>phys                  ( phys.lo..hi )
1A24DB0 	F4 49 A0  1 F8 45 A0  1 
1A24DB8 	30 16 A2  1 
	 2r>  encode-unit+                         ( adr len' )
1A24DBC 	10 46 A0  1 
1A24DC0 	3C 4C A2  1 
      then                                         ( adr,len' )
   then
;
1A24DC4 	58 46 A0  1 

h# 100 buffer: pwd-buf
1A24DC8 	70 77 64 2D 62 75 66 87 
1A24DD0 	44 4D A2  1 B4 A9 A0  1 
1A24DD8 	CC  6  0  0  0  1  0  0 
1A24DE0 	20 40 A2  1 
\ adr len is the full path string.
: pwd$  ( -- adr len )
1A24DE4 	 0  0  0 70 
1A24DE8 	77 64 24 84 D4 4D A2  1 
1A24DF0 	20 40 A0  1 
   0 0  encode-bytes        ( adr,len )
1A24DF4 	70 6F A0  1 
1A24DF8 	70 6F A0  1 14 F6 A1  1 
   root-device?  if         ( adr,len )
1A24E00 	4C 11 A2  1 DC 41 A0  1 
1A24E08 	18  0  0  0 
      " /"  encode-bytes+   ( adr,len' )
1A24E0C 	9C 53 A0  1 
1A24E10 	 1 2F  0  0 E8 4B A2  1 
   else                     ( adr,len )
1A24E18 	C8 41 A0  1  8  0  0  0 
      (pwd$)                ( adr,len" )
1A24E20 	44 4D A2  1 
   then                     ( adr,len )

   \ Free the dictionary space
   \ used to collect the names
   over here -  allot    ( adr,len )
1A24E24 	54 49 A0  1 
1A24E28 	70 54 A0  1 18 45 A0  1 
1A24E30 	E4 54 A0  1 

   pwd-buf pack count    ( adr',len )
1A24E34 	D4 4D A2  1 
1A24E38 	DC 52 A0  1 BC 53 A0  1 
;
1A24E40 	58 46 A0  1 

: make-node-alias  ( voc name-str -- )
1A24E44 	6D 61 6B 65 
1A24E48 	2D 6E 6F 64 65 2D 61 6C 
1A24E50 	69 61 73 8F F0 4D A2  1 
1A24E58 	20 40 A0  1 
   current-device >r  ( nodeid name-str )
1A24E5C 	40 F9 A1  1 
1A24E60 	BC 45 A0  1 
   rot voc>phandle push-device    ( name-str )
1A24E64 	7C 49 A0  1 
1A24E68 	40 F8 A1  1 F8 FB A1  1 
   pwd$               ( name-str expansion-str )
1A24E70 	F0 4D A2  1 
   r> push-device     ( name-str expansion-str )
1A24E74 	D0 45 A0  1 
1A24E78 	F8 FB A1  1 
   $devalias          (  )
1A24E7C 	7C 21 A2  1 
;
1A24E80 	58 46 A0  1 

: (ihandle>devname) ( adr,len -- adr,len' ) recursive
1A24E84 	 0  0 28 69 
1A24E88 	68 61 6E 64 6C 65 3E 64 
1A24E90 	65 76 6E 61 6D 65 29 91 
1A24E98 	58 4E A2  1 20 40 A0  1 
   my-parent  if
1A24EA0 	28  4 A2  1 DC 41 A0  1 
1A24EA8 	1C  1  0  0 
      current-device >r
1A24EAC 	40 F9 A1  1 
1A24EB0 	BC 45 A0  1 
      my-voc push-device
1A24EB4 	10  4 A2  1 
1A24EB8 	F8 FB A1  1 
      my-parent  package( (ihandle>devname) )package
1A24EBC 	28  4 A2  1 
1A24EC0 	2C 31 A2  1 9C 4E A2  1 
1A24EC8 	5C 31 A2  1 
\     " support" get-my-property  0=  if  2drop  r> push-device  exit  then
      " /" encode-bytes+
1A24ECC 	9C 53 A0  1 
1A24ED0 	 1 2F  0  0 E8 4B A2  1 

      \ Display interposed package names with an extra leading /
      parent-device  my-parent ihandle>phandle <>  if  " /" encode-bytes+  then
1A24ED8 	EC FA A1  1 28  4 A2  1 
1A24EE0 	 0 32 A2  1 44 48 A0  1 
1A24EE8 	DC 41 A0  1 10  0  0  0 
1A24EF0 	9C 53 A0  1  1 2F  0  0 
1A24EF8 	E8 4B A2  1 

      " name" get-my-property  if  " "  else  1-  then  encode-bytes+   ( $ )
1A24EFC 	9C 53 A0  1 
1A24F00 	 4 6E 61 6D 65  0  0  0 
1A24F08 	1C 34 A2  1 DC 41 A0  1 
1A24F10 	14  0  0  0 9C 53 A0  1 
1A24F18 	 0  0  0  0 C8 41 A0  1 
1A24F20 	 8  0  0  0 54 4B A0  1 
1A24F28 	E8 4B A2  1 

      2>r                                                           ( R: $ )
1A24F2C 	F8 45 A0  1 

      'child get-token?  if
1A24F30 	 8 FA A1  1 6C 59 A0  1 
1A24F38 	DC 41 A0  1 30  0  0  0 
	 \ Has children so it is not a leaf node.
	 drop get-unit 	0= dup  if		 ( unit-str has-regs? )
1A24F40 	30 49 A0  1 90 15 A2  1 
1A24F48 	24 47 A0  1 40 49 A0  1 
1A24F50 	DC 41 A0  1 10  0  0  0 
            drop				 ( unit-str )
1A24F58 	30 49 A0  1 
            unit-str>phys			 ( phys.lo .. phys.hi )
1A24F5C 	30 16 A2  1 
	    true				 ( phys .. true )
1A24F60 	 4 70 A0  1 
	 then					 ( [ phys .. ] has-regs? )
      else					 ( )
1A24F64 	C8 41 A0  1 
1A24F68 	 C  0  0  0 
	 my-unit  true				 ( [ phys .. ] true )
1A24F6C 	70 10 A2  1 
1A24F70 	 4 70 A0  1 
      then					 ( [ phys .. ] has-regs? )

      2r> rot  if				 ( phys .. adr,len )  ( R: )
1A24F74 	10 46 A0  1 
1A24F78 	7C 49 A0  1 DC 41 A0  1 
1A24F80 	3C  0  0  0 
         encode-unit+                            ( adr,len' )
1A24F84 	3C 4C A2  1 

	 my-args dup  if                         ( adr,len args,len )
1A24F88 	10  7 A2  1 40 49 A0  1 
1A24F90 	DC 41 A0  1 24  0  0  0 
	    2swap  " :" encode-bytes+            ( args,len adr,len )
1A24F98 	F4 49 A0  1 9C 53 A0  1 
1A24FA0 	 1 3A  0  0 E8 4B A2  1 
	    2swap  encode-bytes+                 ( adr,len )
1A24FA8 	F4 49 A0  1 E8 4B A2  1 
	 else                                    ( adr,len args,0 )
1A24FB0 	C8 41 A0  1  8  0  0  0 
	    2drop                                ( adr,len )
1A24FB8 	AC 49 A0  1 
	 then                                    ( adr,len )
      then                                       ( adr,len )
      r> push-device
1A24FBC 	D0 45 A0  1 
1A24FC0 	F8 FB A1  1 
   then
;
1A24FC4 	58 46 A0  1 

headers
: ihandle>devname ( ihandle -- adr,len )
1A24FC8 	69 68 61 6E 64 6C 65 3E 
1A24FD0 	64 65 76 6E 61 6D 65 8F 
1A24FD8 	9C 4E A2  1 20 40 A0  1 
   0 0 encode-bytes
1A24FE0 	70 6F A0  1 70 6F A0  1 
1A24FE8 	14 F6 A1  1 
   rot package( (ihandle>devname) )package
1A24FEC 	7C 49 A0  1 
1A24FF0 	2C 31 A2  1 9C 4E A2  1 
1A24FF8 	5C 31 A2  1 
   over here - allot
1A24FFC 	54 49 A0  1 
1A25000 	70 54 A0  1 18 45 A0  1 
1A25008 	E4 54 A0  1 
   pwd-buf pack count    ( adr',len )
1A2500C 	D4 4D A2  1 
1A25010 	DC 52 A0  1 BC 53 A0  1 
;
1A25018 	58 46 A0  1 

: phandle>devname ( phandle -- adr,len )
1A2501C 	70 68 61 6E 
1A25020 	64 6C 65 3E 64 65 76 6E 
1A25028 	61 6D 65 8F DC 4F A2  1 
1A25030 	20 40 A0  1 
   current-device >r  ( phandle )  ( r: phandle' )
1A25034 	40 F9 A1  1 
1A25038 	BC 45 A0  1 
   push-device  pwd$  ( adr,len )  ( r: phandle' )
1A2503C 	F8 FB A1  1 
1A25040 	F0 4D A2  1 
   r> push-device     ( adr,len )
1A25044 	D0 45 A0  1 
1A25048 	F8 FB A1  1 
;
1A2504C 	58 46 A0  1 
: .ichain  ( -- )  my-self ihandle>devname type  ;
1A25050 	2E 69 63 68 61 69 6E 87 
1A25058 	30 50 A2  1 20 40 A0  1 
1A25060 	EC 7E A0  1 DC 4F A2  1 
1A25068 	 4 6C A0  1 58 46 A0  1 

also magic-device-types definitions
: display  ( -- )
1A25070 	64 69 73 70 6C 61 79 87 
1A25078 	 0  0 A0  1 20 40 A0  1 
   'fb-node token@ origin =  if  current-device phandle>voc  'fb-node token!  then
1A25080 	CC 4B A2  1  C 54 A0  1 
1A25088 	50 55 A0  1 24 48 A0  1 
1A25090 	DC 41 A0  1 14  0  0  0 
1A25098 	40 F9 A1  1 58 F8 A1  1 
1A250A0 	CC 4B A2  1 20 54 A0  1 
;
1A250A8 	58 46 A0  1 
previous definitions

\ From sysnodes.fth
purpose: 

defer client-services
1A250AC 	63 6C 69 65 
1A250B0 	6E 74 2D 73 65 72 76 69 
1A250B8 	63 65 73 8F 5C 50 A2  1 
1A250C0 	5C 40 A0  1 D0  6  0  0 

\ Create the standard system nodes

hex
\ debug devc
root-device  HERE TO packages-device \ mmo
   new-device				\ Node for software "library" packages
1A250C8 	E0 B6 A0  1 D4  6  0  0 
1A250D0 	B8 10 A2  1 E0 B6 A0  1 
1A250D8 	F4  6  0  0 
      " packages" device-name
1A250DC 	70 61 63 6B 
1A250E0 	61 67 65 73  0  0  0 6E 
1A250E8 	61 6D 65 84  0  0 A0  1 
1A250F0 	BC 13 A2  1 18  0  0  0 
1A250F8 	 9  0  0  0 

      new-device     current-device-t phandle>voc  to client-services \ mmo
1A250FC 	E0 B6 A0  1 
1A25100 	F8  6  0  0 C8 50 A2  1 
1A25108 	E0 B6 A0  1 18  7  0  0 
         " client-services" device-name
1A25110 	63 6C 69 65 6E 74 2D 73 
1A25118 	65 72 76 69 63 65 73  0 
1A25120 	 0  0  0 6E 61 6D 65 84 
1A25128 	 0  0 A0  1 BC 13 A2  1 
1A25130 	20  0  0  0 10  0  0  0 
      finish-device
1A25138 	 0  0  0  0  0  0  0  0 
1A25140 	 0  0  0  0  0  0  0  0 
1A25148 	 0  0  0  0  0  0  0  0 

   finish-device  here to chosen-device \ mmo
1A25150 	 0  0  0  0  0  0  0  0 
1A25158 	 0  0  0  0  0  0  0  0 
1A25160 	 0  0  0  0  0  0  0  0 
   new-device				\ Reports firmware run-time choices
1A25168 	E0 B6 A0  1 1C  7  0  0 
1A25170 	B8 10 A2  1 E0 B6 A0  1 
1A25178 	3C  7  0  0 
      " chosen" device-name
1A2517C 	63 68 6F 73 
1A25180 	65 6E  0 6E 61 6D 65 84 
1A25188 	 0  0 A0  1 BC 13 A2  1 
1A25190 	14  0  0  0  7  0  0  0 
   finish-device
1A25198 	 0  0  0  0  0  0  0  0 
1A251A0 	 0  0  0  0  0  0  0  0 
1A251A8 	 0  0  0  0  0  0  0  0 

   new-device				\ Node describing the firmware
1A251B0 	E0 B6 A0  1 40  7  0  0 
1A251B8 	B8 10 A2  1 E0 B6 A0  1 
1A251C0 	60  7  0  0 
      " openprom" device-name
1A251C4 	6F 70 65 6E 
1A251C8 	70 72 6F 6D  0  0  0 6E 
1A251D0 	61 6D 65 84  0  0 A0  1 
1A251D8 	BC 13 A2  1 18  0  0  0 
1A251E0 	 9  0  0  0 
      0 0 " relative-addressing" property
1A251E4 	72 65 6C 61 
1A251E8 	74 69 76 65 2D 61 64 64 
1A251F0 	72 65 73 73 69 6E 67 93 
1A251F8 	D8 51 A2  1 BC 13 A2  1 
1A25200 	 0 52 A2  1  0  0  0  0 
      0 0 " aligned-allocator"	 property
1A25208 	 0  0 61 6C 69 67 6E 65 
1A25210 	64 2D 61 6C 6C 6F 63 61 
1A25218 	74 6F 72 91 FC 51 A2  1 
1A25220 	BC 13 A2  1 24 52 A2  1 
1A25228 	 0  0  0  0 
   finish-device
1A2522C 	 0  0  0  0 
1A25230 	 0  0  0  0  0  0  0  0 
1A25238 	 0  0  0  0  0  0  0  0 
1A25240 	 0  0  0  0 

   new-device				\ Node for configuration options
1A25244 	E0 B6 A0  1 
1A25248 	64  7  0  0 B8 10 A2  1 
1A25250 	E0 B6 A0  1 84  7  0  0 
      ' options 'properties token!	\ "options" voc is node's property list
      " options" device-name
1A25258 	6F 70 74 69 6F 6E 73  0 
1A25260 	 0  0  0 6E 61 6D 65 84 
1A25268 	 0  0 A0  1 BC 13 A2  1 
1A25270 	18  0  0  0  8  0  0  0 
\ only forth \eof   zzzzzzzzzzzzzz
   finish-device
1A25278 	 0  0  0  0  0  0  0  0 
1A25280 	 0  0  0  0  0  0  0  0 
1A25288 	 0  0  0  0  0  0  0  0 

   new-device				\ Node for configuration options
1A25290 	E0 B6 A0  1 88  7  0  0 
1A25298 	B8 10 A2  1 E0 B6 A0  1 
1A252A0 	A8  7  0  0 
      ' aliases 'properties token!	\ "options" voc is node's property list
      " aliases" device-name
1A252A4 	61 6C 69 61 
1A252A8 	73 65 73  0  0  0  0 6E 
1A252B0 	61 6D 65 84  0  0 A0  1 
1A252B8 	BC 13 A2  1 18  0  0  0 
1A252C0 	 8  0  0  0 
   finish-device
1A252C4 	 0  0  0  0 
1A252C8 	 0  0  0  0  0  0  0  0 
1A252D0 	 0  0  0  0  0  0  0  0 
1A252D8 	 0  0  0  0 
device-end

headerless
\ "chosen-variable" is a convenient way to report the contents of a
\ variable in a "/chosen" property.  Example: stdout " stdout" chosen-variable
5 actions
1A252DC 	58 53 A2  1 
1A252E0 	4C 53 A2  1 3C 53 A2  1 
1A252E8 	1C 53 A2  1  5  0  0  0 
action:  token@ execute @ encode-cell over here - allot  ;   \ get
1A252F0 	90 90 90 E8 84 ED FD FF 
1A252F8 	 C 54 A0  1 98 41 A0  1 
1A25300 	5C 4C A0  1 C0 F7 A1  1 
1A25308 	54 49 A0  1 70 54 A0  1 
1A25310 	18 45 A0  1 E4 54 A0  1 
1A25318 	58 46 A0  1 
action:  token@ execute >r get-encoded-cell r> !   ;         \ set
1A2531C 	20 40 A0  1 
1A25320 	 C 54 A0  1 98 41 A0  1 
1A25328 	BC 45 A0  1 20 F8 A1  1 
1A25330 	D0 45 A0  1 54 4D A0  1 
1A25338 	58 46 A0  1 
action:  token@ execute  ;                                   \ addr
1A2533C 	20 40 A0  1 
1A25340 	 C 54 A0  1 98 41 A0  1 
1A25348 	58 46 A0  1 
action:  drop  ;
1A2534C 	20 40 A0  1 
1A25350 	30 49 A0  1 58 46 A0  1 
action:  drop  ;
1A25358 	20 40 A0  1 30 49 A0  1 
1A25360 	58 46 A0  1 

: chosen-variable  ( acf adr len -- )
1A25364 	63 68 6F 73 
1A25368 	65 6E 2D 76 61 72 69 61 
1A25370 	62 6C 65 8F C0 50 A2  1 
1A25378 	20 40 A0  1 
   " /chosen" find-device
1A2537C 	9C 53 A0  1 
1A25380 	 7 2F 63 68 6F 73 65 6E 
1A25388 	 0  0  0  0 BC 22 A2  1 
      make-property-name token, use-actions
1A25390 	18 13 A2  1 2C 55 A0  1 
1A25398 	60 53 A0  1 F0 52 A2  1 
1A253A0 	E0 57 A0  1 
   device-end
1A253A4 	94  F A2  1 
;
1A253A8 	58 46 A0  1 
action-adr-t to dochosen-variable

\ "chosen-value" is like chosen-variable, but with value semantics
\ variable in a "/chosen" property.  Example: stdout " stdout" chosen-variable
5 actions
1A253AC 	28 54 A2  1 
1A253B0 	1C 54 A2  1  8 54 A2  1 
1A253B8 	E8 53 A2  1  5  0  0  0 
action:  token@ execute encode-cell over here - allot  ;     \ get
1A253C0 	90 90 90 E8 B4 EC FD FF 
1A253C8 	 C 54 A0  1 98 41 A0  1 
1A253D0 	C0 F7 A1  1 54 49 A0  1 
1A253D8 	70 54 A0  1 18 45 A0  1 
1A253E0 	E4 54 A0  1 58 46 A0  1 
action:  token@ >r get-encoded-cell r> 1 perform-action  ;   \ set
1A253E8 	20 40 A0  1  C 54 A0  1 
1A253F0 	BC 45 A0  1 20 F8 A1  1 
1A253F8 	D0 45 A0  1 80 6F A0  1 
1A25400 	10 B8 A1  1 58 46 A0  1 
action:  token@ 2 perform-action  ;                          \ addr
1A25408 	20 40 A0  1  C 54 A0  1 
1A25410 	90 6F A0  1 10 B8 A1  1 
1A25418 	58 46 A0  1 
action:  drop  ;
1A2541C 	20 40 A0  1 
1A25420 	30 49 A0  1 58 46 A0  1 
action:  drop  ;
1A25428 	20 40 A0  1 30 49 A0  1 
1A25430 	58 46 A0  1 

: chosen-value  ( acf adr len -- )
1A25434 	 0  0  0 63 
1A25438 	68 6F 73 65 6E 2D 76 61 
1A25440 	6C 75 65 8C 78 53 A2  1 
1A25448 	20 40 A0  1 
   " /chosen" find-device
1A2544C 	9C 53 A0  1 
1A25450 	 7 2F 63 68 6F 73 65 6E 
1A25458 	 0  0  0  0 BC 22 A2  1 
      make-property-name token, use-actions
1A25460 	18 13 A2  1 2C 55 A0  1 
1A25468 	60 53 A0  1 C0 53 A2  1 
1A25470 	E0 57 A0  1 
   device-end
1A25474 	94  F A2  1 
;
1A25478 	58 46 A0  1 
action-adr-t to dochosen-value

5 actions
1A2547C 	EC 54 A2  1 
1A25480 	E0 54 A2  1 D0 54 A2  1 
1A25488 	AC 54 A2  1  5  0  0  0 
\ Add NULL at the end of the string to the length
action:  token@ execute cscount 1+ ( adr len )  ;          \ get
1A25490 	90 90 90 E8 E4 EB FD FF 
1A25498 	 C 54 A0  1 98 41 A0  1 
1A254A0 	AC DF A0  1 30 4B A0  1 
1A254A8 	58 46 A0  1 
action:  token@ execute >r cscount r> place-cstr drop  ;   \ set
1A254AC 	20 40 A0  1 
1A254B0 	 C 54 A0  1 98 41 A0  1 
1A254B8 	BC 45 A0  1 AC DF A0  1 
1A254C0 	D0 45 A0  1 B4 8A A0  1 
1A254C8 	30 49 A0  1 58 46 A0  1 
action:  token@ execute  ;                                 \ addr
1A254D0 	20 40 A0  1  C 54 A0  1 
1A254D8 	98 41 A0  1 58 46 A0  1 
action:  drop  ;
1A254E0 	20 40 A0  1 30 49 A0  1 
1A254E8 	58 46 A0  1 
action:  drop  ;
1A254EC 	20 40 A0  1 
1A254F0 	30 49 A0  1 58 46 A0  1 

: chosen-string  ( acf adr len -- )
1A254F8 	 0  0 63 68 6F 73 65 6E 
1A25500 	2D 73 74 72 69 6E 67 8D 
1A25508 	48 54 A2  1 20 40 A0  1 
   " /chosen" find-package drop  push-package
1A25510 	9C 53 A0  1  7 2F 63 68 
1A25518 	6F 73 65 6E  0  0  0  0 
1A25520 	E0 39 A2  1 30 49 A0  1 
1A25528 	7C FB A1  1 
      make-property-name token, use-actions
1A2552C 	18 13 A2  1 
1A25530 	2C 55 A0  1 60 53 A0  1 
1A25538 	90 54 A2  1 E0 57 A0  1 
   pop-package
1A25540 	D8 FB A1  1 
;
1A25544 	58 46 A0  1 
action-adr-t to dochosen-string

headers

\ From console.fth
purpose: Implements console character I/O

\ Input and output selection mechanism

headers
nuser stdin   0 stdin !
1A25548 	 0  0 73 74 64 69 6E 85 
1A25550 	 C 55 A2  1 48 40 A0  1 
1A25558 	AC  7  0  0 
nuser stdout  0 stdout !
1A2555C 	 0 73 74 64 
1A25560 	6F 75 74 86 54 55 A2  1 
1A25568 	48 40 A0  1 B0  7  0  0 

headerless
nuser pending-char
1A25570 	 0  0  0 70 65 6E 64 69 
1A25578 	6E 67 2D 63 68 61 72 8C 
1A25580 	68 55 A2  1 48 40 A0  1 
1A25588 	B4  7  0  0 
nuser char-pending?
1A2558C 	 0  0 63 68 
1A25590 	61 72 2D 70 65 6E 64 69 
1A25598 	6E 67 3F 8D 84 55 A2  1 
1A255A0 	48 40 A0  1 B8  7  0  0 

\ mmo defer stdin-idle  ' noop is stdin-idle  \ Hook for power savings

: "read"   ( -- adr len )  " read"   ;	\ Space savings
1A255A8 	 0 22 72 65 61 64 22 86 
1A255B0 	A0 55 A2  1 20 40 A0  1 
1A255B8 	9C 53 A0  1  4 72 65 61 
1A255C0 	64  0  0  0 58 46 A0  1 
: "write"  ( -- adr len )  " write"  ;	\ Space savings
1A255C8 	22 77 72 69 74 65 22 87 
1A255D0 	B4 55 A2  1 20 40 A0  1 
1A255D8 	9C 53 A0  1  5 77 72 69 
1A255E0 	74 65  0  0 58 46 A0  1 
: stdin-getchar  ( -- okay? )
1A255E8 	 0  0 73 74 64 69 6E 2D 
1A255F0 	67 65 74 63 68 61 72 8D 
1A255F8 	D4 55 A2  1 20 40 A0  1 
   pending-char 1  "read" stdin @ $call-method  1 =
1A25600 	84 55 A2  1 80 6F A0  1 
1A25608 	B4 55 A2  1 54 55 A2  1 
1A25610 	5C 4C A0  1 B4 31 A2  1 
1A25618 	80 6F A0  1 24 48 A0  1 
;
1A25620 	58 46 A0  1 
: console-key?  ( -- flag )
1A25624 	 0  0  0 63 
1A25628 	6F 6E 73 6F 6C 65 2D 6B 
1A25630 	65 79 3F 8C FC 55 A2  1 
1A25638 	20 40 A0  1 
   char-pending? @  if
1A2563C 	A0 55 A2  1 
1A25640 	5C 4C A0  1 DC 41 A0  1 
1A25648 	10  0  0  0 
      true
1A2564C 	 4 70 A0  1 
   else
1A25650 	C8 41 A0  1 1C  0  0  0 
      stdin-getchar dup  if  char-pending? on  then  ( flag )
1A25658 	FC 55 A2  1 40 49 A0  1 
1A25660 	DC 41 A0  1  C  0  0  0 
1A25668 	A0 55 A2  1 E0 4B A0  1 
   then
;
1A25670 	58 46 A0  1 
: console-key  ( -- char )
1A25674 	63 6F 6E 73 
1A25678 	6F 6C 65 2D 6B 65 79 8B 
1A25680 	38 56 A2  1 20 40 A0  1 
   char-pending? @  if
1A25688 	A0 55 A2  1 5C 4C A0  1 
1A25690 	DC 41 A0  1 1C  0  0  0 
      pending-char c@  char-pending? off
1A25698 	84 55 A2  1 C4 4C A0  1 
1A256A0 	A0 55 A2  1 F8 4B A0  1 
   else
1A256A8 	C8 41 A0  1 18  0  0  0 
      begin
         stdin-getchar
1A256B0 	FC 55 A2  1 
\ mmo         dup 0=  if  stdin-idle  then
      until
1A256B4 	DC 41 A0  1 
1A256B8 	F8 FF FF FF 
      pending-char c@
1A256BC 	84 55 A2  1 
1A256C0 	C4 4C A0  1 
   then
;
1A256C4 	58 46 A0  1 
nuser temp-char
1A256C8 	 0  0 74 65 6D 70 2D 63 
1A256D0 	68 61 72 89 84 56 A2  1 
1A256D8 	48 40 A0  1 BC  7  0  0 
: console-type  ( adr len -- )  "write" stdout @ $call-method  drop  ;
1A256E0 	 0  0  0 63 6F 6E 73 6F 
1A256E8 	6C 65 2D 74 79 70 65 8C 
1A256F0 	D8 56 A2  1 20 40 A0  1 
1A256F8 	D4 55 A2  1 68 55 A2  1 
1A25700 	5C 4C A0  1 B4 31 A2  1 
1A25708 	30 49 A0  1 58 46 A0  1 
: console-emit  ( char -- )  temp-char c!  temp-char 1 console-type  ;
1A25710 	 0  0  0 63 6F 6E 73 6F 
1A25718 	6C 65 2D 65 6D 69 74 8C 
1A25720 	F4 56 A2  1 20 40 A0  1 
1A25728 	D8 56 A2  1 B8 4D A0  1 
1A25730 	D8 56 A2  1 80 6F A0  1 
1A25738 	F4 56 A2  1 58 46 A0  1 

\ close the device if it is not the stdout device.
: ?close  ( ihandle|0 -- )
1A25740 	 0 3F 63 6C 6F 73 65 86 
1A25748 	24 57 A2  1 20 40 A0  1 
   ?dup  if
1A25750 	B4 70 A0  1 DC 41 A0  1 
1A25758 	2C  0  0  0 
      stdout @  over  <>  if  close-dev  else  drop  then
1A2575C 	68 55 A2  1 
1A25760 	5C 4C A0  1 54 49 A0  1 
1A25768 	44 48 A0  1 DC 41 A0  1 
1A25770 	10  0  0  0 5C 37 A2  1 
1A25778 	C8 41 A0  1  8  0  0  0 
1A25780 	30 49 A0  1 
   then
;
1A25784 	58 46 A0  1 
: has-method?  ( method-adr,len phandle -- flag )
1A25788 	68 61 73 2D 6D 65 74 68 
1A25790 	6F 64 3F 8B 4C 57 A2  1 
1A25798 	20 40 A0  1 
   find-method  dup  if  nip  then  ( flag )
1A2579C 	A0 2F A2  1 
1A257A0 	40 49 A0  1 DC 41 A0  1 
1A257A8 	 8  0  0  0 FC 46 A0  1 
;
1A257B0 	58 46 A0  1 
: .missing  ( routine-adr,len type-adr,len -- )
1A257B4 	 0  0  0 2E 
1A257B8 	6D 69 73 73 69 6E 67 88 
1A257C0 	98 57 A2  1 20 40 A0  1 
   ." The selected " type ."  device has no " type  ."  routine" cr
1A257C8 	20 7C A0  1  D 54 68 65 
1A257D0 	20 73 65 6C 65 63 74 65 
1A257D8 	64 20  0  0  4 6C A0  1 
1A257E0 	20 7C A0  1  F 20 64 65 
1A257E8 	76 69 63 65 20 68 61 73 
1A257F0 	20 6E 6F 20  0  0  0  0 
1A257F8 	 4 6C A0  1 20 7C A0  1 
1A25800 	 8 20 72 6F 75 74 69 6E 
1A25808 	65  0  0  0 80 6D A0  1 
;
1A25810 	58 46 A0  1 

: pihandle=  ( phandle ihandle -- flag )
1A25814 	 0  0 70 69 
1A25818 	68 61 6E 64 6C 65 3D 89 
1A25820 	C4 57 A2  1 20 40 A0  1 
   dup  if  ihandle>phandle =  else  2drop false  then
1A25828 	40 49 A0  1 DC 41 A0  1 
1A25830 	14  0  0  0  0 32 A2  1 
1A25838 	24 48 A0  1 C8 41 A0  1 
1A25840 	 C  0  0  0 AC 49 A0  1 
1A25848 	18 70 A0  1 
;
1A2584C 	58 46 A0  1 

: chosen-cell-property  ( n name-str -- )
1A25850 	 0  0  0 63 68 6F 73 65 
1A25858 	6E 2D 63 65 6C 6C 2D 70 
1A25860 	72 6F 70 65 72 74 79 94 
1A25868 	24 58 A2  1 20 40 A0  1 
   " /chosen" find-device
1A25870 	9C 53 A0  1  7 2F 63 68 
1A25878 	6F 73 65 6E  0  0  0  0 
1A25880 	BC 22 A2  1 
   \ XXX this eats up some space every time it's called ...
   \ We really want "set-encoded-cell"
      rot encode-cell  2swap (property)
1A25884 	7C 49 A0  1 
1A25888 	C0 F7 A1  1 F4 49 A0  1 
1A25890 	24 14 A2  1 
   device-end
1A25894 	94  F A2  1 
;
1A25898 	58 46 A0  1 
: set-stdin  ( ihandle -- )
1A2589C 	 0  0 73 65 
1A258A0 	74 2D 73 74 64 69 6E 89 
1A258A8 	6C 58 A2  1 20 40 A0  1 
   stdin @  swap stdin !			( old-ihandle )
1A258B0 	54 55 A2  1 5C 4C A0  1 
1A258B8 	68 49 A0  1 54 55 A2  1 
1A258C0 	54 4D A0  1 
   stdin @  " stdin" chosen-cell-property
1A258C4 	54 55 A2  1 
1A258C8 	5C 4C A0  1 9C 53 A0  1 
1A258D0 	 5 73 74 64 69 6E  0  0 
1A258D8 	6C 58 A2  1 

   " install-abort" stdin @ $call-method	( old-ihandle )
1A258DC 	9C 53 A0  1 
1A258E0 	 D 69 6E 73 74 61 6C 6C 
1A258E8 	2D 61 62 6F 72 74  0  0 
1A258F0 	54 55 A2  1 5C 4C A0  1 
1A258F8 	B4 31 A2  1 
   ?dup  if 					( old-ihandle )
1A258FC 	B4 70 A0  1 
1A25900 	DC 41 A0  1 28  0  0  0 
      " remove-abort" 2 pick $call-method	( old-ihandle )
1A25908 	9C 53 A0  1  C 72 65 6D 
1A25910 	6F 76 65 2D 61 62 6F 72 
1A25918 	74  0  0  0 90 6F A0  1 
1A25920 	 C 4A A0  1 B4 31 A2  1 
      close-dev
1A25928 	5C 37 A2  1 
   then
;
1A2592C 	58 46 A0  1 
headers
: input  ( pathname-adr,len -- )
1A25930 	 0  0 69 6E 70 75 74 85 
1A25938 	AC 58 A2  1 20 40 A0  1 
   2dup locate-device  if
1A25940 	C0 49 A0  1 EC 21 A2  1 
1A25948 	DC 41 A0  1 2C  0  0  0 
      type ."  not found." cr  exit
1A25950 	 4 6C A0  1 20 7C A0  1 
1A25958 	 B 20 6E 6F 74 20 66 6F 
1A25960 	75 6E 64 2E  0  0  0  0 
1A25968 	80 6D A0  1 40 46 A0  1 
   else				      ( pathname-adr,len phandle )
1A25970 	C8 41 A0  1 A0  0  0  0 
      dup stdin @ pihandle=  if  3drop exit  then  \ Same device?
1A25978 	40 49 A0  1 54 55 A2  1 
1A25980 	5C 4C A0  1 24 58 A2  1 
1A25988 	DC 41 A0  1  C  0  0  0 
1A25990 	90 52 A0  1 40 46 A0  1 
      "read" rot has-method?  if      ( pathname-adr,len )
1A25998 	B4 55 A2  1 7C 49 A0  1 
1A259A0 	98 57 A2  1 DC 41 A0  1 
1A259A8 	50  0  0  0 
	 open-dev ?dup  if				( ihandle )
1A259AC 	FC 3E A2  1 
1A259B0 	B4 70 A0  1 DC 41 A0  1 
1A259B8 	10  0  0  0 
            set-stdin
1A259BC 	AC 58 A2  1 
	 else
1A259C0 	C8 41 A0  1 2C  0  0  0 
	    ." Can't open input device." cr  exit
1A259C8 	20 7C A0  1 18 43 61 6E 
1A259D0 	27 74 20 6F 70 65 6E 20 
1A259D8 	69 6E 70 75 74 20 64 65 
1A259E0 	76 69 63 65 2E  0  0  0 
1A259E8 	80 6D A0  1 40 46 A0  1 
	 then
      else			      ( pathname-adr,len )
1A259F0 	C8 41 A0  1 20  0  0  0 
	 2drop  "read" " input" .missing  exit
1A259F8 	AC 49 A0  1 B4 55 A2  1 
1A25A00 	9C 53 A0  1  5 69 6E 70 
1A25A08 	75 74  0  0 C4 57 A2  1 
1A25A10 	40 46 A0  1 
      then
   then
;
1A25A14 	58 46 A0  1 

variable stdout-#lines		\ For communication with client program
1A25A18 	 0  0 73 74 64 6F 75 74 
1A25A20 	2D 23 6C 69 6E 65 73 8D 
1A25A28 	3C 59 A2  1 48 40 A0  1 
1A25A30 	C0  7  0  0 

' stdout-#lines  " stdout-#lines" mmochosen-variable
1A25A34 	 0  0 73 74 
1A25A38 	64 6F 75 74 2D 23 6C 69 
1A25A40 	6E 65 73 8D 8C 51 A2  1 
1A25A48 	F0 52 A2  1 2C 5A A2  1 

variable termemu-#lines		\ For communication with terminal emulator
1A25A50 	 0 74 65 72 6D 65 6D 75 
1A25A58 	2D 23 6C 69 6E 65 73 8E 
1A25A60 	2C 5A A2  1 48 40 A0  1 
1A25A68 	C4  7  0  0 

\ Set #lines in /chosen node for client programs to read
: report-#lines  ( -- )
1A25A6C 	 0  0 72 65 
1A25A70 	70 6F 72 74 2D 23 6C 69 
1A25A78 	6E 65 73 8D 64 5A A2  1 
1A25A80 	20 40 A0  1 
   termemu-#lines @ -1 <>  if   ( #lines )
1A25A84 	64 5A A2  1 
1A25A88 	5C 4C A0  1 58 41 A0  1 
1A25A90 	FF FF FF FF 44 48 A0  1 
1A25A98 	DC 41 A0  1 14  0  0  0 
      \ The terminal emulator package set termemu-#lines
      termemu-#lines @		( #lines )
1A25AA0 	64 5A A2  1 5C 4C A0  1 
   else                         ( #lines )
1A25AA8 	C8 41 A0  1 3C  0  0  0 

      \ termemu-#lines was not set, so check for a "#lines" property
      \ in the output device's package.

      " #lines"  stdout @ ihandle>phandle  get-package-property  if  ( )
1A25AB0 	9C 53 A0  1  6 23 6C 69 
1A25AB8 	6E 65 73  0 68 55 A2  1 
1A25AC0 	5C 4C A0  1  0 32 A2  1 
1A25AC8 	98 33 A2  1 DC 41 A0  1 
1A25AD0 	14  0  0  0 
         \ No "#lines" property; report "unknown"
         -1			( unknown-#lines )
1A25AD4 	58 41 A0  1 
1A25AD8 	FF FF FF FF 
      else			( adr len )
1A25ADC 	C8 41 A0  1 
1A25AE0 	 8  0  0  0 
         \ Report the value of the "#lines" property
         get-encoded-cell	( #lines )
1A25AE4 	20 F8 A1  1 
      then                      ( #lines )
   then                         ( #lines )
   stdout-#lines  !
1A25AE8 	2C 5A A2  1 54 4D A0  1 
;
1A25AF0 	58 46 A0  1 
: set-stdout  ( ihandle -- )
1A25AF4 	 0 73 65 74 
1A25AF8 	2D 73 74 64 6F 75 74 8A 
1A25B00 	80 5A A2  1 20 40 A0  1 
   stdout @  swap stdout !	( old-ihandle )
1A25B08 	68 55 A2  1 5C 4C A0  1 
1A25B10 	68 49 A0  1 68 55 A2  1 
1A25B18 	54 4D A0  1 
   ?close
1A25B1C 	4C 57 A2  1 
   stdout @  " stdout" chosen-cell-property
1A25B20 	68 55 A2  1 5C 4C A0  1 
1A25B28 	9C 53 A0  1  6 73 74 64 
1A25B30 	6F 75 74  0 6C 58 A2  1 
   report-#lines
1A25B38 	80 5A A2  1 
;
1A25B3C 	58 46 A0  1 
: output  ( pathname-adr,len -- )
1A25B40 	 0 6F 75 74 70 75 74 86 
1A25B48 	 4 5B A2  1 20 40 A0  1 
   2dup locate-device  if               ( pathname-adr,len )
1A25B50 	C0 49 A0  1 EC 21 A2  1 
1A25B58 	DC 41 A0  1 2C  0  0  0 
      type ."  not found." cr  exit
1A25B60 	 4 6C A0  1 20 7C A0  1 
1A25B68 	 B 20 6E 6F 74 20 66 6F 
1A25B70 	75 6E 64 2E  0  0  0  0 
1A25B78 	80 6D A0  1 40 46 A0  1 
   else					( pathname-adr,len phandle )
1A25B80 	C8 41 A0  1 DC  0  0  0 
      dup stdout @ pihandle=  if  3drop exit  then   \ Same device?
1A25B88 	40 49 A0  1 68 55 A2  1 
1A25B90 	5C 4C A0  1 24 58 A2  1 
1A25B98 	DC 41 A0  1  C  0  0  0 
1A25BA0 	90 52 A0  1 40 46 A0  1 
      "write" rot has-method?  if	( pathname-adr,len )
1A25BA8 	D4 55 A2  1 7C 49 A0  1 
1A25BB0 	98 57 A2  1 DC 41 A0  1 
1A25BB8 	8C  0  0  0 
         -1 termemu-#lines !	\ Set value for terminal emulator to change
1A25BBC 	58 41 A0  1 
1A25BC0 	FF FF FF FF 64 5A A2  1 
1A25BC8 	54 4D A0  1 
         \ Set behavior of "light" to default value, remembering the old
         \ value so we can restore it if the open fails.
         ['] light behavior -rot        ( xt pathname-adr,len )
1A25BCC 	60 53 A0  1 
1A25BD0 	18 F8 A0  1 10 C7 A0  1 
1A25BD8 	94 49 A0  1 
         ['] cancel to light            ( xt pathname-adr,len )
1A25BDC 	60 53 A0  1 
1A25BE0 	BC F7 A0  1 98 40 A0  1 
1A25BE8 	18 F8 A0  1 
	 open-dev ?dup  if		( xt ihandle )
1A25BEC 	FC 3E A2  1 
1A25BF0 	B4 70 A0  1 DC 41 A0  1 
1A25BF8 	14  0  0  0 
            \ If a different behavior for "light" is appropriate, it will
            \ have been established during "open-dev" (e.g. by fb8-install)
            nip                         ( ihandle )
1A25BFC 	FC 46 A0  1 
	    set-stdout
1A25C00 	 4 5B A2  1 
	 else                           ( xt )
1A25C04 	C8 41 A0  1 
1A25C08 	34  0  0  0 
            to light                    ( )
1A25C0C 	98 40 A0  1 
1A25C10 	18 F8 A0  1 
	    ." Can't open output device." cr  exit
1A25C14 	20 7C A0  1 
1A25C18 	19 43 61 6E 27 74 20 6F 
1A25C20 	70 65 6E 20 6F 75 74 70 
1A25C28 	75 74 20 64 65 76 69 63 
1A25C30 	65 2E  0  0 80 6D A0  1 
1A25C38 	40 46 A0  1 
	 then
      else                             ( pathname-adr,len )
1A25C3C 	C8 41 A0  1 
1A25C40 	20  0  0  0 
	 2drop  "write" " output" .missing  exit
1A25C44 	AC 49 A0  1 
1A25C48 	D4 55 A2  1 9C 53 A0  1 
1A25C50 	 6 6F 75 74 70 75 74  0 
1A25C58 	C4 57 A2  1 40 46 A0  1 
      then
   then
;
1A25C60 	58 46 A0  1 

: io  ( pathname-adr,len -- )
1A25C64 	 0 69 6F 82 
1A25C68 	4C 5B A2  1 20 40 A0  1 
   2dup input
1A25C70 	C0 49 A0  1 3C 59 A2  1 
   output
1A25C78 	4C 5B A2  1 
; 
1A25C7C 	58 46 A0  1 

\ For compatibility with Campus PROMs; allows you to type, for instance,
\ "keyboard input"
: keyboard   ( -- adr len )  " keyboard"  ;
1A25C80 	 0  0  0 6B 65 79 62 6F 
1A25C88 	61 72 64 88 6C 5C A2  1 
1A25C90 	20 40 A0  1 9C 53 A0  1 
1A25C98 	 8 6B 65 79 62 6F 61 72 
1A25CA0 	64  0  0  0 58 46 A0  1 
: screen     ( -- adr len )  " screen"  ;
1A25CA8 	 0 73 63 72 65 65 6E 86 
1A25CB0 	90 5C A2  1 20 40 A0  1 
1A25CB8 	9C 53 A0  1  6 73 63 72 
1A25CC0 	65 65 6E  0 58 46 A0  1 
: ttya       ( -- adr len )  " ttya"  ;
1A25CC8 	 0  0  0 74 74 79 61 84 
1A25CD0 	B4 5C A2  1 20 40 A0  1 
1A25CD8 	9C 53 A0  1  4 74 74 79 
1A25CE0 	61  0  0  0 58 46 A0  1 
: ttyb       ( -- adr len )  " ttyb"  ;
1A25CE8 	 0  0  0 74 74 79 62 84 
1A25CF0 	D4 5C A2  1 20 40 A0  1 
1A25CF8 	9C 53 A0  1  4 74 74 79 
1A25D00 	62  0  0  0 58 46 A0  1 

: console-io  ( -- )
1A25D08 	 0 63 6F 6E 73 6F 6C 65 
1A25D10 	2D 69 6F 8A F4 5C A2  1 
1A25D18 	20 40 A0  1 
   stdin  @ 0<>
1A25D1C 	54 55 A2  1 
1A25D20 	5C 4C A0  1 44 47 A0  1 
   stdout @ 0<>  and  if
1A25D28 	68 55 A2  1 5C 4C A0  1 
1A25D30 	44 47 A0  1 5C 44 A0  1 
1A25D38 	DC 41 A0  1 4C  0  0  0 
      char-pending? off
1A25D40 	A0 55 A2  1 F8 4B A0  1 
      ['] console-key?  is key?
1A25D48 	60 53 A0  1 38 56 A2  1 
1A25D50 	98 40 A0  1 64 6C A0  1 
      ['] console-key   is (key
1A25D58 	60 53 A0  1 84 56 A2  1 
1A25D60 	98 40 A0  1 40 6C A0  1 
      ['] console-emit  is (emit
1A25D68 	60 53 A0  1 24 57 A2  1 
1A25D70 	98 40 A0  1 18 6C A0  1 
      ['] console-type  is (type
1A25D78 	60 53 A0  1 F4 56 A2  1 
1A25D80 	98 40 A0  1 F0 6B A0  1 
   then
;
1A25D88 	58 46 A0  1 
: ks-io  ( -- )  keyboard input  screen output  ;
1A25D8C 	 0  0 6B 73 
1A25D90 	2D 69 6F 85 18 5D A2  1 
1A25D98 	20 40 A0  1 90 5C A2  1 
1A25DA0 	3C 59 A2  1 B4 5C A2  1 
1A25DA8 	4C 5B A2  1 58 46 A0  1 
: use-ks  ( -- )
1A25DB0 	 0 75 73 65 2D 6B 73 86 
1A25DB8 	98 5D A2  1 20 40 A0  1 
   " keyboard" " input-device" $setenv
1A25DC0 	9C 53 A0  1  8 6B 65 79 
1A25DC8 	62 6F 61 72 64  0  0  0 
1A25DD0 	9C 53 A0  1  C 69 6E 70 
1A25DD8 	75 74 2D 64 65 76 69 63 
1A25DE0 	65  0  0  0 C4 F1 A1  1 
   " screen" " output-device" $setenv
1A25DE8 	9C 53 A0  1  6 73 63 72 
1A25DF0 	65 65 6E  0 9C 53 A0  1 
1A25DF8 	 D 6F 75 74 70 75 74 2D 
1A25E00 	64 65 76 69 63 65  0  0 
1A25E08 	C4 F1 A1  1 
;
1A25E0C 	58 46 A0  1 

\ From execall.fth
purpose: 

headerless

defer the-action    ( phandle -- )
1A25E10 	 0 74 68 65 2D 61 63 74 
1A25E18 	69 6F 6E 8A BC 5D A2  1 
1A25E20 	5C 40 A0  1 C8  7  0  0 
: execute-action  ( -- false )
1A25E28 	 0 65 78 65 63 75 74 65 
1A25E30 	2D 61 63 74 69 6F 6E 8E 
1A25E38 	20 5E A2  1 20 40 A0  1 
   current-device >r  the-action  false  r> push-device
1A25E40 	40 F9 A1  1 BC 45 A0  1 
1A25E48 	20 5E A2  1 18 70 A0  1 
1A25E50 	D0 45 A0  1 F8 FB A1  1 
;
1A25E58 	58 46 A0  1 

\ "action-acf" is executed for each device node in the subtree
\ rooted at dev-addr,len , with current-device set to the
\ node in question.  "action-acf" can perform arbitrary tests
\ on the node to determine if that node is appropriate for
\ the action that it wished to undertake.

: scan-subtree  ( dev-addr,len action-acf -- )
1A25E5C 	 0  0  0 73 
1A25E60 	63 61 6E 2D 73 75 62 74 
1A25E68 	72 65 65 8C 3C 5E A2  1 
1A25E70 	20 40 A0  1 
   current-device >r                ( dev-addr,len action-acf r: phandle )
1A25E74 	40 F9 A1  1 
1A25E78 	BC 45 A0  1 
   ['] the-action behavior >r       ( dev-addr,len action-acf r: phandle xt )
1A25E7C 	60 53 A0  1 
1A25E80 	20 5E A2  1 10 C7 A0  1 
1A25E88 	BC 45 A0  1 
   is the-action                    ( dev-addr,len r: phandle xt )
1A25E8C 	98 40 A0  1 
1A25E90 	20 5E A2  1 
   find-device                      ( r: phandle xt )
1A25E94 	BC 22 A2  1 
   ['] execute-action  ['] (search-preorder)  catch  2drop  ( r: phandle xt )
1A25E98 	60 53 A0  1 3C 5E A2  1 
1A25EA0 	60 53 A0  1 24 17 A2  1 
1A25EA8 	14 7F A0  1 AC 49 A0  1 
   r> is the-action r> push-device  ( )
1A25EB0 	D0 45 A0  1 98 40 A0  1 
1A25EB8 	20 5E A2  1 D0 45 A0  1 
1A25EC0 	F8 FB A1  1 
;
1A25EC4 	58 46 A0  1 

headerless

2variable method-name
1A25EC8 	6D 65 74 68 6F 64 2D 6E 
1A25ED0 	61 6D 65 8B 70 5E A2  1 
1A25ED8 	48 40 A0  1 CC  7  0  0 

\ do-method? is an action routine for "scan-subtree" that is used
\ by execute-all-methods.  For each device node, excluding the current
\ output device, that has a method whose name is given by method-name ,
\ that method is executed.

false value verbose-do-method?
1A25EE0 	 0 76 65 72 62 6F 73 65 
1A25EE8 	2D 64 6F 2D 6D 65 74 68 
1A25EF0 	6F 64 3F 92 D8 5E A2  1 
1A25EF8 	50 40 A0  1 D4  7  0  0 

: do-method?  ( -- )
1A25F00 	 0 64 6F 2D 6D 65 74 68 
1A25F08 	6F 64 3F 8A F8 5E A2  1 
1A25F10 	20 40 A0  1 
   method-name 2@  current-device phandle>voc (search-wordlist)  if  ( xt )
1A25F14 	D8 5E A2  1 
1A25F18 	CC 4D A0  1 40 F9 A1  1 
1A25F20 	58 F8 A1  1  0 BB A0  1 
1A25F28 	DC 41 A0  1 38  0  0  0 
      drop  pwd$                               ( path-adr,len )
1A25F30 	30 49 A0  1 F0 4D A2  1 
      verbose-do-method?  if  2dup type cr  then
1A25F38 	F8 5E A2  1 DC 41 A0  1 
1A25F40 	10  0  0  0 C0 49 A0  1 
1A25F48 	 4 6C A0  1 80 6D A0  1 
      method-name 2@  execute-device-method drop cr  (  )
1A25F50 	D8 5E A2  1 CC 4D A0  1 
1A25F58 	84 3F A2  1 30 49 A0  1 
1A25F60 	80 6D A0  1 
   then                                              (  )
;   
1A25F64 	58 46 A0  1 

headers

: execute-all-methods  ( dev-addr,len method-adr,len -- )
1A25F68 	65 78 65 63 75 74 65 2D 
1A25F70 	61 6C 6C 2D 6D 65 74 68 
1A25F78 	6F 64 73 93 10 5F A2  1 
1A25F80 	20 40 A0  1 
   method-name 2!
1A25F84 	D8 5E A2  1 
1A25F88 	E4 4D A0  1 
   ['] do-method?  scan-subtree
1A25F8C 	60 53 A0  1 
1A25F90 	10 5F A2  1 70 5E A2  1 
;
1A25F98 	58 46 A0  1 

: flush-keyboard  ( -- )  begin  key?  while  key drop  repeat  ;
1A25F9C 	 0 66 6C 75 
1A25FA0 	73 68 2D 6B 65 79 62 6F 
1A25FA8 	61 72 64 8E 80 5F A2  1 
1A25FB0 	20 40 A0  1 64 6C A0  1 
1A25FB8 	DC 41 A0  1 14  0  0  0 
1A25FC0 	50 6C A0  1 30 49 A0  1 
1A25FC8 	C8 41 A0  1 E8 FF FF FF 
1A25FD0 	58 46 A0  1 
defer pause-message ( decisecs -- decisecs' )  ' noop to pause-message
1A25FD4 	 0  0 70 61 
1A25FD8 	75 73 65 2D 6D 65 73 73 
1A25FE0 	61 67 65 8D B0 5F A2  1 
1A25FE8 	5C 40 A0  1 D8  7  0  0 
defer hold-message
1A25FF0 	 0  0  0 68 6F 6C 64 2D 
1A25FF8 	6D 65 73 73 61 67 65 8C 
1A26000 	E8 5F A2  1 5C 40 A0  1 
1A26008 	DC  7  0  0 
: (hold-message)  ( ms -- exit? )
1A2600C 	 0 28 68 6F 
1A26010 	6C 64 2D 6D 65 73 73 61 
1A26018 	67 65 29 8E  4 60 A2  1 
1A26020 	20 40 A0  1 
   flush-keyboard
1A26024 	B0 5F A2  1 
   d# 100 /                                              ( decisecs )
1A26028 	58 41 A0  1 64  0  0  0 
1A26030 	98 5F A0  1 
   begin  dup  while                                     ( decisecs )
1A26034 	40 49 A0  1 
1A26038 	DC 41 A0  1 AC  0  0  0 
      dup d# 10 /mod  swap  if  drop  else  (cr .d  then ( decisecs )
1A26040 	40 49 A0  1 58 41 A0  1 
1A26048 	 A  0  0  0 50 5F A0  1 
1A26050 	68 49 A0  1 DC 41 A0  1 
1A26058 	10  0  0  0 30 49 A0  1 
1A26060 	C8 41 A0  1  C  0  0  0 
1A26068 	9C 72 A0  1 48  E A1  1 
      d# 100 ms   1-                                     ( decisecs' )
1A26070 	58 41 A0  1 64  0  0  0 
1A26078 	60 E0 A1  1 54 4B A0  1 
      pause-message                                      ( decisecs )
1A26080 	E8 5F A2  1 
      key?  if                                           ( decisecs )
1A26084 	64 6C A0  1 
1A26088 	DC 41 A0  1 54  0  0  0 
         key h# 1b =  if                                 ( decisecs )
1A26090 	50 6C A0  1 58 41 A0  1 
1A26098 	1B  0  0  0 24 48 A0  1 
1A260A0 	DC 41 A0  1 3C  0  0  0 
	    cr ." Selftest stopped from keyboard" cr     ( decisecs )
1A260A8 	80 6D A0  1 20 7C A0  1 
1A260B0 	1E 53 65 6C 66 74 65 73 
1A260B8 	74 20 73 74 6F 70 70 65 
1A260C0 	64 20 66 72 6F 6D 20 6B 
1A260C8 	65 79 62 6F 61 72 64  0 
1A260D0 	80 6D A0  1 
	    drop true  exit                              ( -- true )
1A260D4 	30 49 A0  1 
1A260D8 	 4 70 A0  1 40 46 A0  1 
	 then                                            ( decisecs )
      then                                               ( decisecs )
   repeat                                                ( decisecs )
1A260E0 	C8 41 A0  1 50 FF FF FF 
   drop  false                                           ( false )
1A260E8 	30 49 A0  1 18 70 A0  1 
;
1A260F0 	58 46 A0  1 
' (hold-message) to hold-message

: most-tests  ( -- exit? )
1A260F4 	 0 6D 6F 73 
1A260F8 	74 2D 74 65 73 74 73 8A 
1A26100 	20 60 A2  1 20 40 A0  1 
   " selftest"  current-device phandle>voc (search-wordlist)  if   ( xt )
1A26108 	9C 53 A0  1  8 73 65 6C 
1A26110 	66 74 65 73 74  0  0  0 
1A26118 	40 F9 A1  1 58 F8 A1  1 
1A26120 	 0 BB A0  1 DC 41 A0  1 
1A26128 	40  1  0  0 

      drop                                              ( )
1A2612C 	30 49 A0  1 

      \ We only want to execute the selftest routine if the device has
      \ a "reg" property.  This eliminates the execution of selftest
      \ routines for "wildcard" devices like st and sd.

      " reg"  get-property  if  false exit  then 2drop  ( )
1A26130 	9C 53 A0  1  3 72 65 67 
1A26138 	 0  0  0  0 F4  D A2  1 
1A26140 	DC 41 A0  1  C  0  0  0 
1A26148 	18 70 A0  1 40 46 A0  1 
1A26150 	AC 49 A0  1 

      \ We sometimes want to skip the testing of certain devices.
      current-device skip-test?  if  false exit  then   ( )
1A26154 	40 F9 A1  1 
1A26158 	50 42 A2  1 DC 41 A0  1 
1A26160 	 C  0  0  0 18 70 A0  1 
1A26168 	40 46 A0  1 

      ??cr ." Testing "  pwd
1A2616C 	 0 A1 A0  1 
1A26170 	20 7C A0  1  8 54 65 73 
1A26178 	74 69 6E 67 20  0  0  0 
1A26180 	D0 2B A2  1 
      " selftest"  current-device                 ( method-adr,len phandle )
1A26184 	9C 53 A0  1 
1A26188 	 8 73 65 6C 66 74 65 73 
1A26190 	74  0  0  0 40 F9 A1  1 
      execute-phandle-method  if                  ( result )
1A26198 	68 46 A2  1 DC 41 A0  1 
1A261A0 	84  0  0  0 
         ?dup  if
1A261A4 	B4 70 A0  1 
1A261A8 	DC 41 A0  1 50  0  0  0 
            red-letters
1A261B0 	A4 F9 A0  1 
            ??cr ." Selftest failed. Return code = " .d cr
1A261B4 	 0 A1 A0  1 
1A261B8 	20 7C A0  1 1F 53 65 6C 
1A261C0 	66 74 65 73 74 20 66 61 
1A261C8 	69 6C 65 64 2E 20 52 65 
1A261D0 	74 75 72 6E 20 63 6F 64 
1A261D8 	65 20 3D 20  0  0  0  0 
1A261E0 	48  E A1  1 80 6D A0  1 
            cancel
1A261E8 	BC F7 A0  1 
            d# 10000                              ( delay-ms )
1A261EC 	58 41 A0  1 
1A261F0 	10 27  0  0 
         else
1A261F4 	C8 41 A0  1 
1A261F8 	24  0  0  0 
            green-letters
1A261FC 	C0 F9 A0  1 
            ." Okay" cr
1A26200 	20 7C A0  1  4 4F 6B 61 
1A26208 	79  0  0  0 80 6D A0  1 
            cancel
1A26210 	BC F7 A0  1 
            d# 2000                               ( delay-ms )
1A26214 	58 41 A0  1 
1A26218 	D0  7  0  0 
         then                                     ( delay-ms )
      else
1A2621C 	C8 41 A0  1 
1A26220 	3C  0  0  0 
         red-letters
1A26224 	A4 F9 A0  1 
         ." Selftest failed due to abort"  cr
1A26228 	20 7C A0  1 1C 53 65 6C 
1A26230 	66 74 65 73 74 20 66 61 
1A26238 	69 6C 65 64 20 64 75 65 
1A26240 	20 74 6F 20 61 62 6F 72 
1A26248 	74  0  0  0 80 6D A0  1 
         cancel
1A26250 	BC F7 A0  1 
         d# 10000                                 ( delay-ms )
1A26254 	58 41 A0  1 
1A26258 	10 27  0  0 
      then                                        ( delay-ms )
      hold-message                                ( exit? )
1A2625C 	 4 60 A2  1 
   else
1A26260 	C8 41 A0  1  8  0  0  0 
      false                                       ( exit? )
1A26268 	18 70 A0  1 
   then                                           ( exit? )
;
1A2626C 	58 46 A0  1 

: test-subtree  ( dev-addr,len -- )
1A26270 	 0  0  0 74 65 73 74 2D 
1A26278 	73 75 62 74 72 65 65 8C 
1A26280 	 4 61 A2  1 20 40 A0  1 
   current-device >r                ( dev-addr,len r: phandle )
1A26288 	40 F9 A1  1 BC 45 A0  1 
   find-device                      ( r: phandle )
1A26290 	BC 22 A2  1 
   ['] most-tests  ['] (search-preorder)  catch  2drop  ( r: phandle )
1A26294 	60 53 A0  1 
1A26298 	 4 61 A2  1 60 53 A0  1 
1A262A0 	24 17 A2  1 14 7F A0  1 
1A262A8 	AC 49 A0  1 
   r> push-device                   ( )
1A262AC 	D0 45 A0  1 
1A262B0 	F8 FB A1  1 
;
1A262B4 	58 46 A0  1 

: test-all  ( -- )
1A262B8 	 0  0  0 74 65 73 74 2D 
1A262C0 	61 6C 6C 88 84 62 A2  1 
1A262C8 	20 40 A0  1 
   optional-arg-or-/$
1A262CC 	FC 2C A2  1 
   test-subtree
1A262D0 	84 62 A2  1 
;
1A262D4 	58 46 A0  1 

\ From siftdevs.fth
purpose: Sift through the device-tree, using the enhanced display format.

only forth also hidden also definitions

only forth also definitions

\ From malloc.fth
purpose: Heap memory allocator

\ Forth dynamic storage managment.
\
\ By Don Hopkins, University of Maryland
\ Modified by Mitch Bradley, Bradley Forthware
\ Public Domain
\
\ First fit storage allocation of blocks of varying size.
\ Blocks are prefixed with a usage flag and a length count.
\ Free blocks are collapsed downwards during free-memory and while
\ searching during allocate-memory.  Based on the algorithm described
\ in Knuth's _An_Introduction_To_Data_Structures_With_Applications_,
\ sections 5-6.2 and 5-6.3, pp. 501-511.
\
\ init-allocator  ( -- )
\     Initializes the allocator, with no memory.  Should be executed once,
\     before any other allocation operations are attempted.
\
\ add-memory  ( adr len -- )
\     Adds a region of memory to the allocation pool.  That memory will
\     be available for subsequent use by allocate-memory.  This may
\     be executed any number of times.
\
\ allocate-memory  ( size -- adr false  |  error true )
\     Tries to allocate a chunk of memory at least size bytes long.
\     Returns error code and true on failure, or the address of the
\     first byte of usable data and false on success.
\
\ free-memory  ( adr -- )
\     Frees a chunk of memory allocated by malloc.  adr should be an
\     address returned by allocate-memory.  Error if adr is not a
\     valid address.
\
\ memory-available  ( -- size )
\     Returns the size in bytes of the largest contiguous chunk of memory
\     that can be allocated by allocate-memory .

vocabulary allocator
1A262D8 	 0  0 61 6C 6C 6F 63 61 
1A262E0 	74 6F 72 89 C8 62 A2  1 
1A262E8 	E0 B6 A0  1 E0  7  0  0 
1A262F0 	6C 26 A2  1  0  0  0  0 
also allocator also definitions

headerless
8 constant #dalign	\ Machine-dependent worst-case alignment boundary
1A262F8 	23 64 61 6C 69 67 6E 87 
1A26300 	 0  0 A0  1 68 40 A0  1 
1A26308 	 8  0  0  0 

2 base !
1110000000000111 constant *dbuf-free*
1A2630C 	2A 64 62 75 
1A26310 	66 2D 66 72 65 65 2A 8B 
1A26318 	 4 63 A2  1 68 40 A0  1 
1A26320 	 7 E0  0  0 
1111010101011111 constant *dbuf-used*
1A26324 	2A 64 62 75 
1A26328 	66 2D 75 73 65 64 2A 8B 
1A26330 	1C 63 A2  1 68 40 A0  1 
1A26338 	5F F5  0  0 
decimal

\ : field  \ name  ( offset size -- offset' )
\    create over , +  does> @ +
\ ;

struct
   /n field >dbuf-flag
1A2633C 	 0 3E 64 62 
1A26340 	75 66 2D 66 6C 61 67 8A 
1A26348 	34 63 A2  1 50 EE A0  1 
1A26350 	 0  0  0  0 
   /n field >dbuf-size
1A26354 	 0 3E 64 62 
1A26358 	75 66 2D 73 69 7A 65 8A 
1A26360 	4C 63 A2  1 50 EE A0  1 
1A26368 	 4  0  0  0 
aligned
   0  field >dbuf-data
1A2636C 	 0 3E 64 62 
1A26370 	75 66 2D 64 61 74 61 8A 
1A26378 	64 63 A2  1 50 EE A0  1 
1A26380 	 8  0  0  0 
   /n field >dbuf-suc
1A26384 	 0  0 3E 64 
1A26388 	62 75 66 2D 73 75 63 89 
1A26390 	7C 63 A2  1 50 EE A0  1 
1A26398 	 8  0  0  0 
   /n field >dbuf-pred
1A2639C 	 0 3E 64 62 
1A263A0 	75 66 2D 70 72 65 64 8A 
1A263A8 	94 63 A2  1 50 EE A0  1 
1A263B0 	 C  0  0  0 
constant dbuf-min
1A263B4 	 0  0  0 64 
1A263B8 	62 75 66 2D 6D 69 6E 88 
1A263C0 	AC 63 A2  1 68 40 A0  1 
1A263C8 	10  0  0  0 

\ In a multitasking system, the memory allocator head node should
\ be located in a global area, instead in the per-task user area.

dbuf-min ualloc user dbuf-head
1A263CC 	 0  0 64 62 
1A263D0 	75 66 2D 68 65 61 64 89 
1A263D8 	C4 63 A2  1 48 40 A0  1 
1A263E0 	E4  7  0  0 

: dbuf-data>  ( adr -- 'dbuf )  0 >dbuf-data -  ;
1A263E4 	 0 64 62 75 
1A263E8 	66 2D 64 61 74 61 3E 8A 
1A263F0 	DC 63 A2  1 20 40 A0  1 
1A263F8 	70 6F A0  1 7C 63 A2  1 
1A26400 	18 45 A0  1 58 46 A0  1 

: dbuf-flag!  ( flag 'dbuf -- )   >dbuf-flag !   ;
1A26408 	 0 64 62 75 66 2D 66 6C 
1A26410 	61 67 21 8A F4 63 A2  1 
1A26418 	20 40 A0  1 4C 63 A2  1 
1A26420 	54 4D A0  1 58 46 A0  1 
: dbuf-flag@  ( 'dbuf -- flag )   >dbuf-flag @   ;
1A26428 	 0 64 62 75 66 2D 66 6C 
1A26430 	61 67 40 8A 18 64 A2  1 
1A26438 	20 40 A0  1 4C 63 A2  1 
1A26440 	5C 4C A0  1 58 46 A0  1 
: dbuf-size!  ( size 'dbuf -- )   >dbuf-size !   ;
1A26448 	 0 64 62 75 66 2D 73 69 
1A26450 	7A 65 21 8A 38 64 A2  1 
1A26458 	20 40 A0  1 64 63 A2  1 
1A26460 	54 4D A0  1 58 46 A0  1 
: dbuf-size@  ( 'dbuf -- size )   >dbuf-size @   ;
1A26468 	 0 64 62 75 66 2D 73 69 
1A26470 	7A 65 40 8A 58 64 A2  1 
1A26478 	20 40 A0  1 64 63 A2  1 
1A26480 	5C 4C A0  1 58 46 A0  1 
: dbuf-suc!   ( suc 'dbuf -- )    >dbuf-suc  !   ;
1A26488 	 0  0 64 62 75 66 2D 73 
1A26490 	75 63 21 89 78 64 A2  1 
1A26498 	20 40 A0  1 94 63 A2  1 
1A264A0 	54 4D A0  1 58 46 A0  1 
: dbuf-suc@   ( 'dbuf -- 'dbuf )  >dbuf-suc  @   ;
1A264A8 	 0  0 64 62 75 66 2D 73 
1A264B0 	75 63 40 89 98 64 A2  1 
1A264B8 	20 40 A0  1 94 63 A2  1 
1A264C0 	5C 4C A0  1 58 46 A0  1 
: dbuf-pred!  ( pred 'dbuf -- )   >dbuf-pred !   ;
1A264C8 	 0 64 62 75 66 2D 70 72 
1A264D0 	65 64 21 8A B8 64 A2  1 
1A264D8 	20 40 A0  1 AC 63 A2  1 
1A264E0 	54 4D A0  1 58 46 A0  1 
: dbuf-pred@  ( 'dbuf -- 'dbuf )  >dbuf-pred @   ;
1A264E8 	 0 64 62 75 66 2D 70 72 
1A264F0 	65 64 40 8A D8 64 A2  1 
1A264F8 	20 40 A0  1 AC 63 A2  1 
1A26500 	5C 4C A0  1 58 46 A0  1 

: next-dbuf   ( 'dbuf -- 'next-dbuf )  dup dbuf-size@ +  ;
1A26508 	 0  0 6E 65 78 74 2D 64 
1A26510 	62 75 66 89 F8 64 A2  1 
1A26518 	20 40 A0  1 40 49 A0  1 
1A26520 	78 64 A2  1  4 45 A0  1 
1A26528 	58 46 A0  1 

\ Insert new-node into doubly-linked list after old-node
: insert-after  ( new-node old-node -- )
1A2652C 	 0  0  0 69 
1A26530 	6E 73 65 72 74 2D 61 66 
1A26538 	74 65 72 8C 18 65 A2  1 
1A26540 	20 40 A0  1 
   >r  r@ dbuf-suc@  over  dbuf-suc!	\ old's suc is now new's suc
1A26544 	BC 45 A0  1 
1A26548 	E4 45 A0  1 B8 64 A2  1 
1A26550 	54 49 A0  1 98 64 A2  1 
   dup r@ dbuf-suc!			\ new is now old's suc
1A26558 	40 49 A0  1 E4 45 A0  1 
1A26560 	98 64 A2  1 
   r> over dbuf-pred!			\ old is now new's pred
1A26564 	D0 45 A0  1 
1A26568 	54 49 A0  1 D8 64 A2  1 
   dup dbuf-suc@ dbuf-pred!		\ new is now new's suc's pred
1A26570 	40 49 A0  1 B8 64 A2  1 
1A26578 	D8 64 A2  1 
;
1A2657C 	58 46 A0  1 
: link-with-free  ( 'dbuf -- )
1A26580 	 0 6C 69 6E 6B 2D 77 69 
1A26588 	74 68 2D 66 72 65 65 8E 
1A26590 	40 65 A2  1 20 40 A0  1 
   *dbuf-free*  over  dbuf-flag!	\ Set node status to "free"
1A26598 	1C 63 A2  1 54 49 A0  1 
1A265A0 	18 64 A2  1 
   dbuf-head insert-after		\ Insert in list after head node
1A265A4 	DC 63 A2  1 
1A265A8 	40 65 A2  1 
;
1A265AC 	58 46 A0  1 

\ Remove node from doubly-linked list

: remove-node  ( node -- )
1A265B0 	72 65 6D 6F 76 65 2D 6E 
1A265B8 	6F 64 65 8B 94 65 A2  1 
1A265C0 	20 40 A0  1 
   dup dbuf-pred@  over dbuf-suc@ dbuf-pred!
1A265C4 	40 49 A0  1 
1A265C8 	F8 64 A2  1 54 49 A0  1 
1A265D0 	B8 64 A2  1 D8 64 A2  1 
   dup dbuf-suc@   swap dbuf-pred@ dbuf-suc!
1A265D8 	40 49 A0  1 B8 64 A2  1 
1A265E0 	68 49 A0  1 F8 64 A2  1 
1A265E8 	98 64 A2  1 
;
1A265EC 	58 46 A0  1 

\ Collapse the next node into the current node

: merge-with-next  ( 'dbuf -- )
1A265F0 	6D 65 72 67 65 2D 77 69 
1A265F8 	74 68 2D 6E 65 78 74 8F 
1A26600 	C0 65 A2  1 20 40 A0  1 
   dup next-dbuf dup remove-node  ( 'dbuf >next-dbuf )   \ Off of free list
1A26608 	40 49 A0  1 18 65 A2  1 
1A26610 	40 49 A0  1 C0 65 A2  1 

   over dbuf-size@ swap dbuf-size@ +  rot dbuf-size!     \ Increase size
1A26618 	54 49 A0  1 78 64 A2  1 
1A26620 	68 49 A0  1 78 64 A2  1 
1A26628 	 4 45 A0  1 7C 49 A0  1 
1A26630 	58 64 A2  1 
;
1A26634 	58 46 A0  1 

\ 'dbuf is a free node.  Merge all free nodes immediately following
\ into the node.

: merge-down  ( 'dbuf -- 'dbuf )
1A26638 	 0 6D 65 72 67 65 2D 64 
1A26640 	6F 77 6E 8A  4 66 A2  1 
1A26648 	20 40 A0  1 
   begin
      dup next-dbuf dbuf-flag@  *dbuf-free*  =
1A2664C 	40 49 A0  1 
1A26650 	18 65 A2  1 38 64 A2  1 
1A26658 	1C 63 A2  1 24 48 A0  1 
   while
1A26660 	DC 41 A0  1 14  0  0  0 
      dup merge-with-next
1A26668 	40 49 A0  1  4 66 A2  1 
   repeat
1A26670 	C8 41 A0  1 D8 FF FF FF 
;
1A26678 	58 46 A0  1 

forth definitions

: msize  ( adr -- count )  dbuf-data>  dbuf-size@  dbuf-data>  ;
1A2667C 	 0  0 6D 73 
1A26680 	69 7A 65 85 E8 62 A2  1 
1A26688 	20 40 A0  1 F4 63 A2  1 
1A26690 	78 64 A2  1 F4 63 A2  1 
1A26698 	58 46 A0  1 

: >dbuf-header  ( adr -- 'dbuf )
1A2669C 	 0  0  0 3E 
1A266A0 	64 62 75 66 2D 68 65 61 
1A266A8 	64 65 72 8C 88 66 A2  1 
1A266B0 	20 40 A0  1 
   dbuf-data>                ( 'dbuf )
1A266B4 	F4 63 A2  1 
   dup dbuf-flag@ case       ( 'dbuf )
1A266B8 	40 49 A0  1 38 64 A2  1 
      *dbuf-used* of  endof  ( 'dbuf )
1A266C0 	34 63 A2  1 48 43 A0  1 
1A266C8 	 C  0  0  0 6C 43 A0  1 
1A266D0 	6C  0  0  0 
      *dbuf-free* of
1A266D4 	1C 63 A2  1 
1A266D8 	48 43 A0  1 40  0  0  0 
         true abort" Freeing or resizing already-free memory"
1A266E0 	 4 70 A0  1  8 81 A0  1 
1A266E8 	27 46 72 65 65 69 6E 67 
1A266F0 	20 6F 72 20 72 65 73 69 
1A266F8 	7A 69 6E 67 20 61 6C 72 
1A26700 	65 61 64 79 2D 66 72 65 
1A26708 	65 20 6D 65 6D 6F 72 79 
1A26710 	 0  0  0  0 
      endof
1A26714 	6C 43 A0  1 
1A26718 	24  0  0  0 
      true abort" bad heap address."
1A2671C 	 4 70 A0  1 
1A26720 	 8 81 A0  1 11 62 61 64 
1A26728 	20 68 65 61 70 20 61 64 
1A26730 	64 72 65 73 73 2E  0  0 
   endcase                   ( 'dbuf )
1A26738 	84 43 A0  1 
;
1A2673C 	58 46 A0  1 
: free-memory  ( adr -- )
1A26740 	66 72 65 65 2D 6D 65 6D 
1A26748 	6F 72 79 8B B0 66 A2  1 
1A26750 	20 40 A0  1 
   >dbuf-header  merge-down link-with-free
1A26754 	B0 66 A2  1 
1A26758 	48 66 A2  1 94 65 A2  1 
;
1A26760 	58 46 A0  1 

: add-memory  ( adr len -- )
1A26764 	 0 61 64 64 
1A26768 	2D 6D 65 6D 6F 72 79 8A 
1A26770 	50 67 A2  1 20 40 A0  1 
   \ Align the starting address to a "worst-case" boundary.  This helps
   \ guarantee that allocated data areas will be on a "worst-case"
   \ alignment boundary.

   swap dup  #dalign round-up      ( len adr adr' )
1A26778 	68 49 A0  1 40 49 A0  1 
1A26780 	 4 63 A2  1 A4 91 A0  1 
   dup rot -                       ( len adr' diff )
1A26788 	40 49 A0  1 7C 49 A0  1 
1A26790 	18 45 A0  1 
   rot swap -                      ( adr' len' )
1A26794 	7C 49 A0  1 
1A26798 	68 49 A0  1 18 45 A0  1 
   #dalign round-down              ( adr' len'' )
1A267A0 	 4 63 A2  1 80 91 A0  1 

   \ Set size and flags fields for first piece

   \ Subtract off the size of one node header, because we carve out
   \ a node header from the end of the piece to use as a "stopper".
   \ That "stopper" is marked "used", and prevents merge-down from
   \ trying to merge past the end of the piece.

   dbuf-data>                      ( 'dbuf-first #dbuf-first )
1A267A8 	F4 63 A2  1 

   \ Ensure that the piece is big enough to be useable.
   \ A piece of size dbuf-min (after having subtracted off the "stopper"
   \ header) is barely useable, because the space used by the free list
   \ links can be used as the data space.  If it's too small, we just
   \ exit, wasting the (miniscule amount of) memory.

   dup dbuf-min <  if  2drop exit  then
1A267AC 	40 49 A0  1 
1A267B0 	C4 63 A2  1 E4 47 A0  1 
1A267B8 	DC 41 A0  1  C  0  0  0 
1A267C0 	AC 49 A0  1 40 46 A0  1 

   \ Set the size and flag for the new free piece

   *dbuf-free* 2 pick dbuf-flag!   ( 'dbuf-first #dbuf-first )
1A267C8 	1C 63 A2  1 90 6F A0  1 
1A267D0 	 C 4A A0  1 18 64 A2  1 
   2dup swap dbuf-size!            ( 'dbuf-first #dbuf-first )
1A267D8 	C0 49 A0  1 68 49 A0  1 
1A267E0 	58 64 A2  1 

   \ Create the "stopper" header

   \ XXX The stopper piece should be linked into a piece list,
   \ and the flags should be set to a different value.  The size
   \ field should indicate the total size for this piece.
   \ The piece list should be consulted when adding memory, and
   \ if there is a piece immediately following the new piece, they
   \ should be merged.

   over +                          ( 'dbuf-first 'dbuf-limit )
1A267E4 	54 49 A0  1 
1A267E8 	 4 45 A0  1 
   *dbuf-used* swap dbuf-flag!     ( 'dbuf-first )
1A267EC 	34 63 A2  1 
1A267F0 	68 49 A0  1 18 64 A2  1 

   link-with-free
1A267F8 	94 65 A2  1 
;
1A267FC 	58 46 A0  1 

: allocate-memory  ( size -- adr false  |  error-code true )
1A26800 	61 6C 6C 6F 63 61 74 65 
1A26808 	2D 6D 65 6D 6F 72 79 8F 
1A26810 	74 67 A2  1 20 40 A0  1 
   \ Keep pieces aligned on "worst-case" hardware boundaries
   #dalign round-up                 ( size' )
1A26818 	 4 63 A2  1 A4 91 A0  1 

   >dbuf-data dbuf-min max          ( size )
1A26820 	7C 63 A2  1 C4 63 A2  1 
1A26828 	9C 4A A0  1 

   \ Search for a sufficiently-large free piece
   dbuf-head                        ( size 'dbuf )
1A2682C 	DC 63 A2  1 
   begin                            ( size 'dbuf )
      dbuf-suc@                     ( size 'dbuf )
1A26830 	B8 64 A2  1 
      dup dbuf-head =  if           \ Bail out if we've already been around
1A26834 	40 49 A0  1 
1A26838 	DC 63 A2  1 24 48 A0  1 
1A26840 	DC 41 A0  1 14  0  0  0 
         2drop 1 true exit          ( error-code true )
1A26848 	AC 49 A0  1 80 6F A0  1 
1A26850 	 4 70 A0  1 40 46 A0  1 
      then                          ( size 'dbuf-suc )
      merge-down                    ( size 'dbuf )
1A26858 	48 66 A2  1 
      dup dbuf-size@                ( size 'dbuf dbuf-size )
1A2685C 	40 49 A0  1 
1A26860 	78 64 A2  1 
      2 pick >=                     ( size 'dbuf big-enough? )
1A26864 	90 6F A0  1 
1A26868 	 C 4A A0  1 EC 48 A0  1 
   until                            ( size 'dbuf )
1A26870 	DC 41 A0  1 BC FF FF FF 

   dup dbuf-size@ 2 pick -          ( size 'dbuf left-over )
1A26878 	40 49 A0  1 78 64 A2  1 
1A26880 	90 6F A0  1  C 4A A0  1 
1A26888 	18 45 A0  1 
   dup dbuf-min <=  if              \ Too small to fragment?
1A2688C 	40 49 A0  1 
1A26890 	C4 63 A2  1  C 49 A0  1 
1A26898 	DC 41 A0  1 1C  0  0  0 

      \ The piece is too small to split, so we just remove the whole
      \ thing from the free list.

      drop nip                      ( 'dbuf )
1A268A0 	30 49 A0  1 FC 46 A0  1 
      dup remove-node               ( 'dbuf )
1A268A8 	40 49 A0  1 C0 65 A2  1 
   else                             ( size 'dbuf left-over )
1A268B0 	C8 41 A0  1 1C  0  0  0 

      \ The piece is big enough to split up, so we make the free piece
      \ smaller and take the stuff after it as the allocated piece.

      2dup swap dbuf-size!          ( size 'dbuf left-over) \ Set frag size
1A268B8 	C0 49 A0  1 68 49 A0  1 
1A268C0 	58 64 A2  1 
      +                             ( size 'dbuf' )
1A268C4 	 4 45 A0  1 
      tuck dbuf-size!               ( 'dbuf' )
1A268C8 	E8 46 A0  1 58 64 A2  1 
   then
   *dbuf-used* over dbuf-flag!      \ Mark as used
1A268D0 	34 63 A2  1 54 49 A0  1 
1A268D8 	18 64 A2  1 
   >dbuf-data false                 ( adr false )
1A268DC 	7C 63 A2  1 
1A268E0 	18 70 A0  1 
;
1A268E4 	58 46 A0  1 

: memory-available  ( -- size )
1A268E8 	 0  0  0 6D 65 6D 6F 72 
1A268F0 	79 2D 61 76 61 69 6C 61 
1A268F8 	62 6C 65 90 14 68 A2  1 
1A26900 	20 40 A0  1 
   0 >dbuf-data                     ( current-largest-size )
1A26904 	70 6F A0  1 
1A26908 	7C 63 A2  1 

   dbuf-head                        ( size 'dbuf )
1A2690C 	DC 63 A2  1 
   begin                            ( size 'dbuf )
      dbuf-suc@  dup dbuf-head <>   ( size 'dbuf more? )
1A26910 	B8 64 A2  1 40 49 A0  1 
1A26918 	DC 63 A2  1 44 48 A0  1 
   while                            \ Go once around the free list
1A26920 	DC 41 A0  1 24  0  0  0 
      merge-down                    ( size 'dbuf )
1A26928 	48 66 A2  1 
      dup dbuf-size@                ( size 'dbuf dbuf-size )
1A2692C 	40 49 A0  1 
1A26930 	78 64 A2  1 
      rot max swap                  ( size' 'dbuf )
1A26934 	7C 49 A0  1 
1A26938 	9C 4A A0  1 68 49 A0  1 
   repeat
1A26940 	C8 41 A0  1 CC FF FF FF 
   drop  dbuf-data>                 ( largest-data-size )
1A26948 	30 49 A0  1 F4 63 A2  1 
;
1A26950 	58 46 A0  1 

\ Head node has 0 size, is not free, and is initially linked to itself

: init-allocator  ( -- )
1A26954 	 0 69 6E 69 
1A26958 	74 2D 61 6C 6C 6F 63 61 
1A26960 	74 6F 72 8E  0 69 A2  1 
1A26968 	20 40 A0  1 
   *dbuf-used* dbuf-head dbuf-flag!
1A2696C 	34 63 A2  1 
1A26970 	DC 63 A2  1 18 64 A2  1 
   0 dbuf-head dbuf-size!	\ Must be 0 so the allocator won't find it.
1A26978 	70 6F A0  1 DC 63 A2  1 
1A26980 	58 64 A2  1 
   dbuf-head  dup  dbuf-suc!	\ Link to self
1A26984 	DC 63 A2  1 
1A26988 	40 49 A0  1 98 64 A2  1 
   dbuf-head  dup  dbuf-pred!
1A26990 	DC 63 A2  1 40 49 A0  1 
1A26998 	D8 64 A2  1 
;
1A2699C 	58 46 A0  1 

previous previous definitions

\ Tries to allocate, and if that fails, requests more memory from the system

also allocator also

defer more-memory  ( request-size -- adr actual-size false | error-code true )
1A269A0 	6D 6F 72 65 2D 6D 65 6D 
1A269A8 	6F 72 79 8B 68 69 A2  1 
1A269B0 	5C 40 A0  1 F4  7  0  0 

headerless
: allocate-memory  ( size -- adr false  |  error-code true )
1A269B8 	61 6C 6C 6F 63 61 74 65 
1A269C0 	2D 6D 65 6D 6F 72 79 8F 
1A269C8 	B0 69 A2  1 20 40 A0  1 
   dup allocate-memory  if	      ( size error-code )
1A269D0 	40 49 A0  1 14 68 A2  1 
1A269D8 	DC 41 A0  1 48  0  0  0 
      \ No more memory in the heap; try to get some more from the system
      drop                            ( size )
1A269E0 	30 49 A0  1 
      dup #dalign + >dbuf-data >dbuf-data
1A269E4 	40 49 A0  1 
1A269E8 	 4 63 A2  1  4 45 A0  1 
1A269F0 	7C 63 A2  1 7C 63 A2  1 
      more-memory  if                 ( size error-code )
1A269F8 	B0 69 A2  1 DC 41 A0  1 
1A26A00 	14  0  0  0 
         nip true                     ( error-code true )
1A26A04 	FC 46 A0  1 
1A26A08 	 4 70 A0  1 
      else                            ( size adr actual )
1A26A0C 	C8 41 A0  1 
1A26A10 	 C  0  0  0 
         add-memory                   ( size )
1A26A14 	74 67 A2  1 
	 allocate-memory              ( adr false  |  error-code true )
1A26A18 	14 68 A2  1 
      then                            ( adr false  |  error-code true )
   else                               ( size adr )
1A26A1C 	C8 41 A0  1 
1A26A20 	 C  0  0  0 
      nip false                       ( adr false )
1A26A24 	FC 46 A0  1 
1A26A28 	18 70 A0  1 
   then                               ( adr false  |  error-code true )
;
1A26A2C 	58 46 A0  1 

: adjust-piece  ( size 'dbuf -- actual-size )
1A26A30 	 0  0  0 61 64 6A 75 73 
1A26A38 	74 2D 70 69 65 63 65 8C 
1A26A40 	CC 69 A2  1 20 40 A0  1 
   dup dbuf-size@ 2 pick -          ( size 'dbuf left-over )
1A26A48 	40 49 A0  1 78 64 A2  1 
1A26A50 	90 6F A0  1  C 4A A0  1 
1A26A58 	18 45 A0  1 
   dup dbuf-min <=  if              ( size 'dbuf left-over )
1A26A5C 	40 49 A0  1 
1A26A60 	C4 63 A2  1  C 49 A0  1 
1A26A68 	DC 41 A0  1 20  0  0  0 
      \ The piece is too small to split, so we just remove the whole
      \ thing from the free list.

      drop nip                      ( 'dbuf )
1A26A70 	30 49 A0  1 FC 46 A0  1 
      dup remove-node               ( 'dbuf )
1A26A78 	40 49 A0  1 C0 65 A2  1 
      dbuf-size@                    ( actual-size )
1A26A80 	78 64 A2  1 
   else                             ( size 'dbuf left-over )
1A26A84 	C8 41 A0  1 
1A26A88 	64  0  0  0 

      \ The piece is big enough to split up, so we shrink the
      \ free part by moving the header up.

      \ Compute address of new header
      3dup drop +  >r               ( size 'dbuf left-over r: 'dbuf1 )
1A26A8C 	A4 52 A0  1 
1A26A90 	30 49 A0  1  4 45 A0  1 
1A26A98 	BC 45 A0  1 

      \ Prepare the new header
      *dbuf-free*  r@ dbuf-flag!    ( size 'dbuf left-over 'dbuf1 )
1A26A9C 	1C 63 A2  1 
1A26AA0 	E4 45 A0  1 18 64 A2  1 
      r@ dbuf-size!                 ( size 'dbuf )
1A26AA8 	E4 45 A0  1 58 64 A2  1 
      dup dbuf-suc@  r@ dbuf-suc!   ( size 'dbuf )
1A26AB0 	40 49 A0  1 B8 64 A2  1 
1A26AB8 	E4 45 A0  1 98 64 A2  1 
      dbuf-pred@  r@ dbuf-pred!     ( size )
1A26AC0 	F8 64 A2  1 E4 45 A0  1 
1A26AC8 	D8 64 A2  1 

      \ Fix the free list to point to the new header instead of the old one
      r@  dup dbuf-suc@  dbuf-pred! ( size 'dbuf1 )
1A26ACC 	E4 45 A0  1 
1A26AD0 	40 49 A0  1 B8 64 A2  1 
1A26AD8 	D8 64 A2  1 
      r>  dup dbuf-pred@ dbuf-suc!  ( size )
1A26ADC 	D0 45 A0  1 
1A26AE0 	40 49 A0  1 F8 64 A2  1 
1A26AE8 	98 64 A2  1 
   then
;
1A26AEC 	58 46 A0  1 

\ Returns true if adr is the address of a free buffer header.
\ It is tempting to just look for a *dbuf-free* signature at adr, but
\ that could fail if adr is at the end of the heap area and is not mapped.
: dbuf-free?  ( adr -- free? )
1A26AF0 	 0 64 62 75 66 2D 66 72 
1A26AF8 	65 65 3F 8A 44 6A A2  1 
1A26B00 	20 40 A0  1 
   \ Search for a sufficiently-large free piece
   dbuf-head                        ( adr 'dbuf )
1A26B04 	DC 63 A2  1 
   begin                            ( adr 'dbuf )
      dbuf-suc@                     ( adr 'dbuf )
1A26B08 	B8 64 A2  1 
      dup dbuf-head =  if           \ Bail out if we've already been around
1A26B0C 	40 49 A0  1 
1A26B10 	DC 63 A2  1 24 48 A0  1 
1A26B18 	DC 41 A0  1 10  0  0  0 
         2drop false exit           ( false )
1A26B20 	AC 49 A0  1 18 70 A0  1 
1A26B28 	40 46 A0  1 
      then                          ( adr 'dbuf-suc )
      merge-down                    ( adr 'dbuf )
1A26B2C 	48 66 A2  1 
      2dup =                        ( adr 'dbuf match? )
1A26B30 	C0 49 A0  1 24 48 A0  1 
   until                            ( adr 'dbuf )
1A26B38 	DC 41 A0  1 CC FF FF FF 
   2drop true                       ( true )
1A26B40 	AC 49 A0  1  4 70 A0  1 
;
1A26B48 	58 46 A0  1 

: resize-memory  ( adr newlen -- adr' ior )
1A26B4C 	 0  0 72 65 
1A26B50 	73 69 7A 65 2D 6D 65 6D 
1A26B58 	6F 72 79 8D  0 6B A2  1 
1A26B60 	20 40 A0  1 
   \ Keep pieces aligned on "worst-case" hardware boundaries
   #dalign round-up  dbuf-min max  ( adr newlen' )
1A26B64 	 4 63 A2  1 
1A26B68 	A4 91 A0  1 C4 63 A2  1 
1A26B70 	9C 4A A0  1 

   swap >dbuf-header  >r           ( newlen r: 'dbuf )
1A26B74 	68 49 A0  1 
1A26B78 	B0 66 A2  1 BC 45 A0  1 
   r@ dbuf-size@                   ( newlen old-size r: 'dbuf )
1A26B80 	E4 45 A0  1 78 64 A2  1 

   \ If the new size is smaller than the old, just return success.
   \ It might be nice to give back the unused piece, but we can
   \ implement that later if it turns out to be needed.
   dbuf-data> 2dup <=  if          ( newlen old-dsize r: 'dbuf )
1A26B88 	F4 63 A2  1 C0 49 A0  1 
1A26B90 	 C 49 A0  1 DC 41 A0  1 
1A26B98 	18  0  0  0 
      2drop r> >dbuf-data 0        ( adr ior )
1A26B9C 	AC 49 A0  1 
1A26BA0 	D0 45 A0  1 7C 63 A2  1 
1A26BA8 	70 6F A0  1 
      exit
1A26BAC 	40 46 A0  1 
   then                            ( newlen old-dsize r: 'dbuf )

   \ If there is a sufficiently-large free piece following the old
   \ piece, then we can just extend the old piece "in place".
   dup >dbuf-data  r@ +            ( newlen old-dsize 'dbuf1 r: 'dbuf )
1A26BB0 	40 49 A0  1 7C 63 A2  1 
1A26BB8 	E4 45 A0  1  4 45 A0  1 
   dup dbuf-free?  if              ( newlen old-dsize 'dbuf1 r: 'dbuf )
1A26BC0 	40 49 A0  1  0 6B A2  1 
1A26BC8 	DC 41 A0  1 58  0  0  0 
      >r                           ( newlen old-dsize r: 'dbuf 'dbuf1 )
1A26BD0 	BC 45 A0  1 
      2dup -                       ( newlen old-dsize need-size r: .. )
1A26BD4 	C0 49 A0  1 
1A26BD8 	18 45 A0  1 
      r@ dbuf-size@                ( newlen old-dsize need-size size1 r: .. )
1A26BDC 	E4 45 A0  1 
1A26BE0 	78 64 A2  1 
      <=  if                       ( newlen old-dsize r: .. )
1A26BE4 	 C 49 A0  1 
1A26BE8 	DC 41 A0  1 34  0  0  0 
         \ The piece is large enough
         tuck -                    ( old-dsize need-size r: .. )
1A26BF0 	E8 46 A0  1 18 45 A0  1 
         r> adjust-piece           ( old-dsize got-size  r: 'dbuf )
1A26BF8 	D0 45 A0  1 44 6A A2  1 
         + >dbuf-data  r@ dbuf-size!  ( r: 'dbuf )
1A26C00 	 4 45 A0  1 7C 63 A2  1 
1A26C08 	E4 45 A0  1 58 64 A2  1 
         r> >dbuf-data 0              ( adr ior )
1A26C10 	D0 45 A0  1 7C 63 A2  1 
1A26C18 	70 6F A0  1 
         exit
1A26C1C 	40 46 A0  1 
      then                         ( newlen old-dsize r: 'dbuf 'dbuf1 )
      r>                           ( newlen old-dsize 'dbuf1 r: 'dbuf )
1A26C20 	D0 45 A0  1 
   then                            ( newlen old-dsize 'dbuf1 r: 'dbuf )

   drop                            ( newlen old-dsize r: 'dbuf )
1A26C24 	30 49 A0  1 

   \ We can't extend the existing piece, so we must get a new one
   \ and copy in the old data
   swap allocate-memory  if        ( old-dsize error-code r: 'dbuf )
1A26C28 	68 49 A0  1 CC 69 A2  1 
1A26C30 	DC 41 A0  1 1C  0  0  0 
      2drop  r> >dbuf-data -1      ( adr ior )
1A26C38 	AC 49 A0  1 D0 45 A0  1 
1A26C40 	7C 63 A2  1 58 41 A0  1 
1A26C48 	FF FF FF FF 
      exit
1A26C4C 	40 46 A0  1 
   then                               ( old-dsize adr1 r: 'dbuf )

   dup rot  r@ >dbuf-data -rot move   ( adr1 r: 'dbuf )
1A26C50 	40 49 A0  1 7C 49 A0  1 
1A26C58 	E4 45 A0  1 7C 63 A2  1 
1A26C60 	94 49 A0  1 F4 4A A0  1 
   r> >dbuf-data free-memory          ( adr1 )
1A26C68 	D0 45 A0  1 7C 63 A2  1 
1A26C70 	50 67 A2  1 
   0
1A26C74 	70 6F A0  1 
;
1A26C78 	58 46 A0  1 

\ [ifdef] debug-mallocator
\ .( Memory allocator debug words are included) cr
: .previous  ( adr -- )
1A26C7C 	 0  0 2E 70 
1A26C80 	72 65 76 69 6F 75 73 89 
1A26C88 	60 6B A2  1 20 40 A0  1 
   begin  /n -  dup @  *dbuf-used* =  until
1A26C90 	40 51 A0  1 18 45 A0  1 
1A26C98 	40 49 A0  1 5C 4C A0  1 
1A26CA0 	34 63 A2  1 24 48 A0  1 
1A26CA8 	DC 41 A0  1 E4 FF FF FF 
   ." Preceding used heap node at " .x cr
1A26CB0 	20 7C A0  1 1C 50 72 65 
1A26CB8 	63 65 64 69 6E 67 20 75 
1A26CC0 	73 65 64 20 68 65 61 70 
1A26CC8 	20 6E 6F 64 65 20 61 74 
1A26CD0 	20  0  0  0 2C  E A1  1 
1A26CD8 	80 6D A0  1 
;
1A26CDC 	58 46 A0  1 
: check-node  ( 'dbuf -- )
1A26CE0 	 0 63 68 65 63 6B 2D 6E 
1A26CE8 	6F 64 65 8A 8C 6C A2  1 
1A26CF0 	20 40 A0  1 
   dup dbuf-flag@ *dbuf-free* <>  if
1A26CF4 	40 49 A0  1 
1A26CF8 	38 64 A2  1 1C 63 A2  1 
1A26D00 	44 48 A0  1 DC 41 A0  1 
1A26D08 	34  0  0  0 
      ." Bad heap node at " dup .x
1A26D0C 	20 7C A0  1 
1A26D10 	11 42 61 64 20 68 65 61 
1A26D18 	70 20 6E 6F 64 65 20 61 
1A26D20 	74 20  0  0 40 49 A0  1 
1A26D28 	2C  E A1  1 
      .previous
1A26D2C 	8C 6C A2  1 
      abort
1A26D30 	28 91 A0  1 
   else
1A26D34 	C8 41 A0  1 
1A26D38 	 8  0  0  0 
      drop
1A26D3C 	30 49 A0  1 
   then
;
1A26D40 	58 46 A0  1 
: check-heap  ( -- )
1A26D44 	 0 63 68 65 
1A26D48 	63 6B 2D 68 65 61 70 8A 
1A26D50 	F0 6C A2  1 20 40 A0  1 
   dbuf-head
1A26D58 	DC 63 A2  1 
   begin  dbuf-suc@ dup  dbuf-head <>  while  dup check-node  repeat
1A26D5C 	B8 64 A2  1 
1A26D60 	40 49 A0  1 DC 63 A2  1 
1A26D68 	44 48 A0  1 DC 41 A0  1 
1A26D70 	14  0  0  0 40 49 A0  1 
1A26D78 	F0 6C A2  1 C8 41 A0  1 
1A26D80 	DC FF FF FF 
   drop
1A26D84 	30 49 A0  1 
;
1A26D88 	58 46 A0  1 

: .node  ( 'dbuf -- )
1A26D8C 	 0  0 2E 6E 
1A26D90 	6F 64 65 85 54 6D A2  1 
1A26D98 	20 40 A0  1 
   push-hex
1A26D9C 	5C F4 A0  1 
   dup 8 u.r  3 spaces
1A26DA0 	40 49 A0  1 F0 6F A0  1 
1A26DA8 	E4 77 A0  1 A0 6F A0  1 
1A26DB0 	E8 71 A0  1 
   dup dbuf-flag@  5 u.r
1A26DB4 	40 49 A0  1 
1A26DB8 	38 64 A2  1 C0 6F A0  1 
1A26DC0 	E4 77 A0  1 
   dup dbuf-size@  9 u.r
1A26DC4 	40 49 A0  1 
1A26DC8 	78 64 A2  1 58 41 A0  1 
1A26DD0 	 9  0  0  0 E4 77 A0  1 
   dup dbuf-suc@   9 u.r
1A26DD8 	40 49 A0  1 B8 64 A2  1 
1A26DE0 	58 41 A0  1  9  0  0  0 
1A26DE8 	E4 77 A0  1 
   dbuf-pred@      9 u.r
1A26DEC 	F8 64 A2  1 
1A26DF0 	58 41 A0  1  9  0  0  0 
1A26DF8 	E4 77 A0  1 
   cr
1A26DFC 	80 6D A0  1 
   pop-base
1A26E00 	9C F4 A0  1 
;
1A26E04 	58 46 A0  1 

: .heap  ( -- )
1A26E08 	 0  0 2E 68 65 61 70 85 
1A26E10 	98 6D A2  1 20 40 A0  1 
   dbuf-head
1A26E18 	DC 63 A2  1 
   begin  dbuf-suc@ dup  dbuf-head <>  while  dup check-node  dup .node  repeat
1A26E1C 	B8 64 A2  1 
1A26E20 	40 49 A0  1 DC 63 A2  1 
1A26E28 	44 48 A0  1 DC 41 A0  1 
1A26E30 	1C  0  0  0 40 49 A0  1 
1A26E38 	F0 6C A2  1 40 49 A0  1 
1A26E40 	98 6D A2  1 C8 41 A0  1 
1A26E48 	D4 FF FF FF 
   drop
1A26E4C 	30 49 A0  1 
;
1A26E50 	58 46 A0  1 
\ [then] \  debug-mallocator

previous  previous

: heap-alloc-mem  ( bytes -- adr )
1A26E54 	 0 68 65 61 
1A26E58 	70 2D 61 6C 6C 6F 63 2D 
1A26E60 	6D 65 6D 8E 14 6E A2  1 
1A26E68 	20 40 A0  1 
   allocate-memory abort" Out of memory"
1A26E6C 	CC 69 A2  1 
1A26E70 	 8 81 A0  1  D 4F 75 74 
1A26E78 	20 6F 66 20 6D 65 6D 6F 
1A26E80 	72 79  0  0 
;
1A26E84 	58 46 A0  1 

: heap-free-mem  ( adr size -- )  drop free-memory  ;
1A26E88 	 0  0 68 65 61 70 2D 66 
1A26E90 	72 65 65 2D 6D 65 6D 8D 
1A26E98 	68 6E A2  1 20 40 A0  1 
1A26EA0 	30 49 A0  1 50 67 A2  1 
1A26EA8 	58 46 A0  1 

init-allocator

headers
h# 100000 constant 1meg
1A26EAC 	 0  0  0 31 
1A26EB0 	6D 65 67 84 9C 6E A2  1 
1A26EB8 	68 40 A0  1  0  0 10  0 

\ From instmall.fth
purpose: 

\ Install heap memory allocator.

defer initial-heap  ' no-memory is initial-heap
1A26EC0 	 0  0  0 69 6E 69 74 69 
1A26EC8 	61 6C 2D 68 65 61 70 8C 
1A26ED0 	B8 6E A2  1 5C 40 A0  1 
1A26ED8 	F8  7  0  0 

headerless
: no-more-memory  ( request-size -- adr actual-size false | error true )
1A26EDC 	 0 6E 6F 2D 
1A26EE0 	6D 6F 72 65 2D 6D 65 6D 
1A26EE8 	6F 72 79 8E D4 6E A2  1 
1A26EF0 	20 40 A0  1 
   drop 0 true
1A26EF4 	30 49 A0  1 
1A26EF8 	70 6F A0  1  4 70 A0  1 
;
1A26F00 	58 46 A0  1 

: stand-init-io  ( -- )
1A26F04 	 0  0 73 74 
1A26F08 	61 6E 64 2D 69 6E 69 74 
1A26F10 	2D 69 6F 8D F0 6E A2  1 
1A26F18 	20 40 A0  1 
   stand-init-io
1A26F1C 	E8 DF A1  1 
   init-allocator
1A26F20 	68 69 A2  1 
   initial-heap add-memory
1A26F24 	D4 6E A2  1 
1A26F28 	74 67 A2  1 
   ['] no-more-memory is more-memory
1A26F2C 	60 53 A0  1 
1A26F30 	F0 6E A2  1 98 40 A0  1 
1A26F38 	B0 69 A2  1 
   ['] heap-alloc-mem is alloc-mem
1A26F3C 	60 53 A0  1 
1A26F40 	68 6E A2  1 98 40 A0  1 
1A26F48 	F0 6C A0  1 
   ['] heap-free-mem  is free-mem
1A26F4C 	60 53 A0  1 
1A26F50 	9C 6E A2  1 98 40 A0  1 
1A26F58 	 8 6D A0  1 
   ['] resize-memory  is resize
1A26F5C 	60 53 A0  1 
1A26F60 	60 6B A2  1 98 40 A0  1 
1A26F68 	1C 6D A0  1 
   ['] ofw-$getenv    is $getenv
1A26F6C 	60 53 A0  1 
1A26F70 	18 F1 A1  1 98 40 A0  1 
1A26F78 	48 6D A0  1 
;
1A26F7C 	58 46 A0  1 
\ From alarm.fth
purpose: Alarm dispatcher
\ alarm function.
\ To install an alarm:  ['] forth-function #msecs alarm
\ To uninstall alarm:   ['] forth-function 0      alarm
\
headerless
list: alarm-list
1A26F80 	 0 61 6C 61 72 6D 2D 6C 
1A26F88 	69 73 74 8A 18 6F A2  1 
1A26F90 	48 40 A0  1 FC  7  0  0 
listnode
   /n  field  >time-out
1A26F98 	 0  0 3E 74 69 6D 65 2D 
1A26FA0 	6F 75 74 89 90 6F A2  1 
1A26FA8 	50 EE A0  1  4  0  0  0 
   /n  field  >time-remain
1A26FB0 	 0  0  0 3E 74 69 6D 65 
1A26FB8 	2D 72 65 6D 61 69 6E 8C 
1A26FC0 	A8 6F A2  1 50 EE A0  1 
1A26FC8 	 8  0  0  0 
   /n  field  >acf
1A26FCC 	 0  0  0 3E 
1A26FD0 	61 63 66 84 C4 6F A2  1 
1A26FD8 	50 EE A0  1  C  0  0  0 
   /n  field  >ihandle
1A26FE0 	 0  0  0 3E 69 68 61 6E 
1A26FE8 	64 6C 65 88 D8 6F A2  1 
1A26FF0 	50 EE A0  1 10  0  0  0 
nodetype: alarm-node
1A26FF8 	 0 61 6C 61 72 6D 2D 6E 
1A27000 	6F 64 65 8A F0 6F A2  1 
1A27008 	AC 71 A1  1  0  8  0  0 

0 alarm-node !          \ Initialize to empty at compile time
0 alarm-list !          \ Initialize to empty at compile time

: show-alarm  ( node -- flag )
1A27010 	 0 73 68 6F 77 2D 61 6C 
1A27018 	61 72 6D 8A  8 70 A2  1 
1A27020 	20 40 A0  1 
   dup >acf @ .name  d# 20 to-column  dup >ihandle @ 9 u.r
1A27024 	40 49 A0  1 
1A27028 	D8 6F A2  1 5C 4C A0  1 
1A27030 	C8 9A A0  1 58 41 A0  1 
1A27038 	14  0  0  0  8 14 A1  1 
1A27040 	40 49 A0  1 F0 6F A2  1 
1A27048 	5C 4C A0  1 58 41 A0  1 
1A27050 	 9  0  0  0 E4 77 A0  1 
   dup >time-out @ d# 7 u.r  >time-remain @ d# 10 u.r  cr
1A27058 	40 49 A0  1 A8 6F A2  1 
1A27060 	5C 4C A0  1 58 41 A0  1 
1A27068 	 7  0  0  0 E4 77 A0  1 
1A27070 	C4 6F A2  1 5C 4C A0  1 
1A27078 	58 41 A0  1  A  0  0  0 
1A27080 	E4 77 A0  1 80 6D A0  1 
   false
1A27088 	18 70 A0  1 
;
1A2708C 	58 46 A0  1 
headers
: .alarms  ( -- )
1A27090 	2E 61 6C 61 72 6D 73 87 
1A27098 	20 70 A2  1 20 40 A0  1 
   ." Action                Ihandle  Interval  Remaining" cr
1A270A0 	20 7C A0  1 32 41 63 74 
1A270A8 	69 6F 6E 20 20 20 20 20 
1A270B0 	20 20 20 20 20 20 20 20 
1A270B8 	20 20 20 49 68 61 6E 64 
1A270C0 	6C 65 20 20 49 6E 74 65 
1A270C8 	72 76 61 6C 20 20 52 65 
1A270D0 	6D 61 69 6E 69 6E 67  0 
1A270D8 	80 6D A0  1 
   alarm-list  ['] show-alarm  find-node  2drop
1A270DC 	90 6F A2  1 
1A270E0 	60 53 A0  1 20 70 A2  1 
1A270E8 	88 72 A1  1 AC 49 A0  1 
;
1A270F0 	58 46 A0  1 
headerless

\ Return flag will be true if the acf of the give node is equal to
\ the given acf.
: target-node?  ( ihandle acf node -- ihandle acf flag )
1A270F4 	 0  0  0 74 
1A270F8 	61 72 67 65 74 2D 6E 6F 
1A27100 	64 65 3F 8C 9C 70 A2  1 
1A27108 	20 40 A0  1 
   2dup >acf @  =                 ( ihandle acf node flag )
1A2710C 	C0 49 A0  1 
1A27110 	D8 6F A2  1 5C 4C A0  1 
1A27118 	24 48 A0  1 
   3 pick rot >ihandle @  = and   ( ihandle acf flag )
1A2711C 	A0 6F A0  1 
1A27120 	 C 4A A0  1 7C 49 A0  1 
1A27128 	F0 6F A2  1 5C 4C A0  1 
1A27130 	24 48 A0  1 5C 44 A0  1 
;
1A27138 	58 46 A0  1 


\ If a node with "acf" is already in the alarm-list, then just set the
\ time-out and time-remain with the new value "n"; else allocate a
\ new node and set up all fields with the given info.
: set-alarm-node	( ihandle acf n -- )
1A2713C 	 0 73 65 74 
1A27140 	2D 61 6C 61 72 6D 2D 6E 
1A27148 	6F 64 65 8E  8 71 A2  1 
1A27150 	20 40 A0  1 
   \ convert n miliseconds to #clock-ticks.
   ms/tick /mod  swap 0<>  if  1+  then		( ihandle acf #clock-ticks )
1A27154 	38 E0 A1  1 
1A27158 	50 5F A0  1 68 49 A0  1 
1A27160 	44 47 A0  1 DC 41 A0  1 
1A27168 	 8  0  0  0 30 4B A0  1 

   >r alarm-list ['] target-node? find-node	( ihandle acf prev next|0 )
1A27170 	BC 45 A0  1 90 6F A2  1 
1A27178 	60 53 A0  1  8 71 A2  1 
1A27180 	88 72 A1  1 
   ?dup if					( ihandle acf prev next )
1A27184 	B4 70 A0  1 
1A27188 	DC 41 A0  1 10  0  0  0 
      nip					( ihandle acf next )
1A27190 	FC 46 A0  1 
   else						( ihandle acf last-node )
1A27194 	C8 41 A0  1 
1A27198 	18  0  0  0 
      alarm-node allocate-node  		( ihandle acf last-node node )
1A2719C 	 8 70 A2  1 
1A271A0 	34 74 A1  1 
      tuck swap insert-after			( ihandle acf node )
1A271A4 	E8 46 A0  1 
1A271A8 	68 49 A0  1 28 72 A1  1 
   then						( ihandle acf node )
   tuck >acf !					( ihandle node )
1A271B0 	E8 46 A0  1 D8 6F A2  1 
1A271B8 	54 4D A0  1 
   r@ over >time-out !				( ihandle node )
1A271BC 	E4 45 A0  1 
1A271C0 	54 49 A0  1 A8 6F A2  1 
1A271C8 	54 4D A0  1 
   r> over >time-remain !			( ihandle node )
1A271CC 	D0 45 A0  1 
1A271D0 	54 49 A0  1 C4 6F A2  1 
1A271D8 	54 4D A0  1 
   >ihandle !                                   ( )
1A271DC 	F0 6F A2  1 
1A271E0 	54 4D A0  1 
;
1A271E4 	58 46 A0  1 


\ Search thru alarm-list, if node is found, then zero out the time-out
\ and time-remain field; else print out error message.
: turn-off-alarm 	( ihandle acf -- )
1A271E8 	 0 74 75 72 6E 2D 6F 66 
1A271F0 	66 2D 61 6C 61 72 6D 8E 
1A271F8 	50 71 A2  1 20 40 A0  1 
   lock[	\ Lock out the alarm handler while modifying the list.
1A27200 	84 E0 A1  1 
   alarm-list ['] target-node? find-node  if	    ( ihandle acf prev )
1A27204 	90 6F A2  1 
1A27208 	60 53 A0  1  8 71 A2  1 
1A27210 	88 72 A1  1 DC 41 A0  1 
1A27218 	1C  0  0  0 
      delete-after alarm-node free-node             ( ihandle acf )
1A2721C 	58 72 A1  1 
1A27220 	 8 70 A2  1 88 74 A1  1 
      2drop                                         ( )
1A27228 	AC 49 A0  1 
   else                                             ( ihandle acf prev )
1A2722C 	C8 41 A0  1 
1A27230 	38  0  0  0 
      drop  ." No alarm was installed for " .h  cr  ( ihandle )
1A27234 	30 49 A0  1 
1A27238 	20 7C A0  1 1B 4E 6F 20 
1A27240 	61 6C 61 72 6D 20 77 61 
1A27248 	73 20 69 6E 73 74 61 6C 
1A27250 	6C 65 64 20 66 6F 72 20 
1A27258 	 0  0  0  0 10  E A1  1 
1A27260 	80 6D A0  1 
      drop                                          ( )
1A27264 	30 49 A0  1 
   then
   ]unlock
1A27268 	98 E0 A1  1 
;
1A2726C 	58 46 A0  1 


\ First check to see if the alarm is on (time-out >0).  If it is,
\ then check to see if the time is expired (time-remain = 0).
\ If time is not expired, decrement the time-remain.

: run-alarm 	( node -- )
1A27270 	 0  0 72 75 6E 2D 61 6C 
1A27278 	61 72 6D 89 FC 71 A2  1 
1A27280 	20 40 A0  1 
   dup  >time-remain @  1- dup 0<=  if  ( node time-remain )
1A27284 	40 49 A0  1 
1A27288 	C4 6F A2  1 5C 4C A0  1 
1A27290 	54 4B A0  1 40 49 A0  1 
1A27298 	84 47 A0  1 DC 41 A0  1 
1A272A0 	48  0  0  0 
      drop  dup >time-out @  over       ( node time-out node )
1A272A4 	30 49 A0  1 
1A272A8 	40 49 A0  1 A8 6F A2  1 
1A272B0 	5C 4C A0  1 54 49 A0  1 
      dup >acf @  swap >ihandle @       ( node time-out acf ihandle )
1A272B8 	40 49 A0  1 D8 6F A2  1 
1A272C0 	5C 4C A0  1 68 49 A0  1 
1A272C8 	F0 6F A2  1 5C 4C A0  1 
      ['] call-package  catch  if       ( node time-out acf ihandle )
1A272D0 	60 53 A0  1 8C 31 A2  1 
1A272D8 	14 7F A0  1 DC 41 A0  1 
1A272E0 	 8  0  0  0 
	 2drop                          ( node time-out )
1A272E4 	AC 49 A0  1 
      then                              ( node time-out )
   then  swap >time-remain !            ( )
1A272E8 	68 49 A0  1 C4 6F A2  1 
1A272F0 	54 4D A0  1 
;
1A272F4 	58 46 A0  1 

headers
\ We do this manually instead of using find-node because we need
\ to do >next-node before calling time-expired? in case the alarm
\ routine uninstalls itself, which could cause a crash if the
\ pointer to the next node were overwritten while being freed.
: check-alarm  ( -- )
1A272F8 	63 68 65 63 6B 2D 61 6C 
1A27300 	61 72 6D 8B 80 72 A2  1 
1A27308 	20 40 A0  1 
   alarm-list  >next-node      ( node )
1A2730C 	90 6F A2  1 
1A27310 	5C 4C A0  1 
   begin  ?dup  while          ( node )
1A27314 	B4 70 A0  1 
1A27318 	DC 41 A0  1 1C  0  0  0 
      dup >next-node  swap     ( next node )
1A27320 	40 49 A0  1 5C 4C A0  1 
1A27328 	68 49 A0  1 
      run-alarm                ( next )
1A2732C 	80 72 A2  1 
   repeat                      ( )
1A27330 	C8 41 A0  1 E0 FF FF FF 
;
1A27338 	58 46 A0  1 

: alarm 	( acf n -- )
1A2733C 	 0  0 61 6C 
1A27340 	61 72 6D 85  8 73 A2  1 
1A27348 	20 40 A0  1 
   my-self -rot                 ( ihandle acf n )
1A2734C 	EC 7E A0  1 
1A27350 	94 49 A0  1 
   ?dup if  set-alarm-node  else  turn-off-alarm  then
1A27354 	B4 70 A0  1 
1A27358 	DC 41 A0  1 10  0  0  0 
1A27360 	50 71 A2  1 C8 41 A0  1 
1A27368 	 8  0  0  0 FC 71 A2  1 
;
1A27370 	58 46 A0  1 

\ From clientif.fth
purpose: Client interface handler

headerless
only forth also definitions
\
\  Client Interface Handler
\

headers
forth also definitions

: setnode  ( nodeid | 0 -- )
1A27374 	73 65 74 6E 
1A27378 	6F 64 65 87 48 73 A2  1 
1A27380 	20 40 A0  1 
   dup 0=  if  drop root-phandle then  (push-package)
1A27384 	40 49 A0  1 
1A27388 	24 47 A0  1 DC 41 A0  1 
1A27390 	 C  0  0  0 30 49 A0  1 
1A27398 	F8 10 A2  1 38 FB A1  1 
;
1A273A0 	58 46 A0  1 

false value canonical-properties?
1A273A4 	 0  0 63 61 
1A273A8 	6E 6F 6E 69 63 61 6C 2D 
1A273B0 	70 72 6F 70 65 72 74 69 
1A273B8 	65 73 3F 95 80 73 A2  1 
1A273C0 	50 40 A0  1  8  8  0  0 
d# 32 buffer: canon-prop
1A273C8 	 0 63 61 6E 6F 6E 2D 70 
1A273D0 	72 6F 70 8A C0 73 A2  1 
1A273D8 	B4 A9 A0  1  C  8  0  0 
1A273E0 	20  0  0  0 D4 4D A2  1 
: $find-property  ( adr len -- adr len false | acf true )
1A273E8 	 0 24 66 69 6E 64 2D 70 
1A273F0 	72 6F 70 65 72 74 79 8E 
1A273F8 	D8 73 A2  1 20 40 A0  1 
   canonical-properties?  if  d# 31 min canon-prop $save 2dup lower  then
1A27400 	C0 73 A2  1 DC 41 A0  1 
1A27408 	20  0  0  0 58 41 A0  1 
1A27410 	1F  0  0  0 74 4A A0  1 
1A27418 	D8 73 A2  1 68 7E A0  1 
1A27420 	C0 49 A0  1 A4 85 A0  1 
   2dup current-properties (search-wordlist)  dup  if  2swap 2drop  then
1A27428 	C0 49 A0  1 98  C A2  1 
1A27430 	 0 BB A0  1 40 49 A0  1 
1A27438 	DC 41 A0  1  C  0  0  0 
1A27440 	F4 49 A0  1 AC 49 A0  1 
;
1A27448 	58 46 A0  1 
\
\ Generic Client Interface Services
\

only forth  ( also hidden  also forth )  also
  definitions
headers
caps @ caps off

: child  ( phandle -- phandle' )
1A2744C 	 0  0 63 68 
1A27450 	69 6C 64 85 FC 73 A2  1 
1A27458 	20 40 A0  1 
   setnode                           ( )
1A2745C 	80 73 A2  1 
   0  'child                         ( last-nodeid &next-nodeid )
1A27460 	70 6F A0  1  8 FA A1  1 
   begin  get-token?  while          ( last-nodeid next-nodeid )
1A27468 	6C 59 A0  1 DC 41 A0  1 
1A27470 	20  0  0  0 
      nip  dup voc>phandle (select-package)      ( next-nodeid )
1A27474 	FC 46 A0  1 
1A27478 	40 49 A0  1 40 F8 A1  1 
1A27480 	14 FB A1  1 
      'peer                          ( last-nodeid' &next-nodeid )
1A27484 	1C FA A1  1 
   repeat                            ( last-nodeid' )
1A27488 	C8 41 A0  1 DC FF FF FF 
   (pop-package)                     ( nodeid )
1A27490 	5C FB A1  1 
   dup  if  voc>phandle  then
1A27494 	40 49 A0  1 
1A27498 	DC 41 A0  1  8  0  0  0 
1A274A0 	40 F8 A1  1 
;
1A274A4 	58 46 A0  1 

: peer  ( phandle -- phandle' )
1A274A8 	 0  0  0 70 65 65 72 84 
1A274B0 	58 74 A2  1 20 40 A0  1 
   dup 0=  if
1A274B8 	40 49 A0  1 24 47 A0  1 
1A274C0 	DC 41 A0  1 10  0  0  0 
      drop root-phandle exit
1A274C8 	30 49 A0  1 F8 10 A2  1 
1A274D0 	40 46 A0  1 
   then                              ( nodeid )

   dup  root-phandle  =  if
1A274D4 	40 49 A0  1 
1A274D8 	F8 10 A2  1 24 48 A0  1 
1A274E0 	DC 41 A0  1 10  0  0  0 
      drop 0  exit
1A274E8 	30 49 A0  1 70 6F A0  1 
1A274F0 	40 46 A0  1 
   then                              ( nodeid )

   \ Select the first child of our parent
   dup >parent (push-package)        ( nodeid )
1A274F4 	40 49 A0  1 
1A274F8 	C0 FA A1  1 38 FB A1  1 
   'child token@ voc>phandle (select-package)    ( nodeid )
1A27500 	 8 FA A1  1  C 54 A0  1 
1A27508 	40 F8 A1  1 14 FB A1  1 

   dup current-device  =  if         ( nodeid )
1A27510 	40 49 A0  1 40 F9 A1  1 
1A27518 	24 48 A0  1 DC 41 A0  1 
1A27520 	14  0  0  0 
      \ Argument node is first child of parent; return "no more nodes"
      drop 0                         ( 0 )
1A27524 	30 49 A0  1 
1A27528 	70 6F A0  1 
   else                              ( nodeid )
1A2752C 	C8 41 A0  1 
1A27530 	34  0  0  0 
      \ Search for the node preceding the argument node
      begin                          ( nodeid )
         'peer token@ voc>phandle 2dup  <>       ( nodeid next-nodeid flag )
1A27534 	1C FA A1  1 
1A27538 	 C 54 A0  1 40 F8 A1  1 
1A27540 	C0 49 A0  1 44 48 A0  1 
      while                          ( nodeid next-nodeid )
1A27548 	DC 41 A0  1 10  0  0  0 
         push-device                 ( nodeid )
1A27550 	F8 FB A1  1 
      repeat                         ( nodeid )
1A27554 	C8 41 A0  1 
1A27558 	DC FF FF FF 
      2drop current-device           ( nodeid' )
1A2755C 	AC 49 A0  1 
1A27560 	40 F9 A1  1 
   then                              ( nodeid | 0 )
   (pop-package)                     ( nodeid | 0 )
1A27564 	5C FB A1  1 
;
1A27568 	58 46 A0  1 

: instance-to-package  ( ihandle -- phandle )  ihandle>phandle  ;
1A2756C 	69 6E 73 74 
1A27570 	61 6E 63 65 2D 74 6F 2D 
1A27578 	70 61 63 6B 61 67 65 93 
1A27580 	B4 74 A2  1 20 40 A0  1 
1A27588 	 0 32 A2  1 58 46 A0  1 

: milliseconds ( -- )  get-msecs   ;
1A27590 	 0  0  0 6D 69 6C 6C 69 
1A27598 	73 65 63 6F 6E 64 73 8C 
1A275A0 	84 75 A2  1 20 40 A0  1 
1A275A8 	50 E0 A1  1 58 46 A0  1 

: execute-buffer ( adr len -- )  'execute-buffer execute  ;
1A275B0 	 0 65 78 65 63 75 74 65 
1A275B8 	2D 62 75 66 66 65 72 8E 
1A275C0 	A4 75 A2  1 20 40 A0  1 
1A275C8 	50 E6 A1  1 98 41 A0  1 
1A275D0 	58 46 A0  1 
caps !

also forth definitions
alias child child	\ Make visible outside the client-services package
1A275D4 	 0  0 63 68 
1A275D8 	69 6C 64 A5 C4 75 A2  1 
1A275E0 	58 74 A2  1 
alias peer peer		\ Make visible outside the client-services package
1A275E4 	 0  0  0 70 
1A275E8 	65 65 72 A4 E0 75 A2  1 
1A275F0 	B4 74 A2  1 

only forth also definitions


previous definitions

\ From deladdr.fth
purpose: Delete stale address properties for virtual addresses
copyright: Copyright 1990-1994 Sun Microsystems, Inc.  All Rights Reserved

\ When freeing virtual memory, if the address property of the current
\ device refers to that virtual memory, delete the address property.

headerless
: ?delete-address  ( adr len -- adr len )
1A275F4 	3F 64 65 6C 
1A275F8 	65 74 65 2D 61 64 64 72 
1A27600 	65 73 73 8F F0 75 A2  1 
1A27608 	20 40 A0  1 
   my-self  if                                       ( adr len )
1A2760C 	EC 7E A0  1 
1A27610 	DC 41 A0  1 5C  0  0  0 
      my-voc (push-package)                          ( adr len )
1A27618 	10  4 A2  1 38 FB A1  1 
      " address" get-property  0=  if                ( adr len value-adr,len )
1A27620 	9C 53 A0  1  7 61 64 64 
1A27628 	72 65 73 73  0  0  0  0 
1A27630 	F4  D A2  1 24 47 A0  1 
1A27638 	DC 41 A0  1 30  0  0  0 
         get-encoded-cell  2 pick  =  if             ( adr len )
1A27640 	20 F8 A1  1 90 6F A0  1 
1A27648 	 C 4A A0  1 24 48 A0  1 
1A27650 	DC 41 A0  1 18  0  0  0 
            " address" delete-property               ( adr len )
1A27658 	9C 53 A0  1  7 61 64 64 
1A27660 	72 65 73 73  0  0  0  0 
1A27668 	14 15 A2  1 
         then                                        ( adr len )
      then                                           ( adr len )
      (pop-package)                                  ( adr len )
1A2766C 	5C FB A1  1 
   then                                              ( adr len )
;
1A27670 	58 46 A0  1 
headers
: free-virtual  ( adr len -- )  ?delete-address  " map-out" $call-parent  ;
1A27674 	 0  0  0 66 
1A27678 	72 65 65 2D 76 69 72 74 
1A27680 	75 61 6C 8C  8 76 A2  1 
1A27688 	20 40 A0  1  8 76 A2  1 
1A27690 	9C 53 A0  1  7 6D 61 70 
1A27698 	2D 6F 75 74  0  0  0  0 
1A276A0 	DC 31 A2  1 58 46 A0  1 

also hidden
: method-call?  ( xt -- flag )
1A276A8 	 0  0  0 6D 65 74 68 6F 
1A276B0 	64 2D 63 61 6C 6C 3F 8C 
1A276B8 	88 76 A2  1 20 40 A0  1 
   dup (indirect-call?)  if  drop true exit  then  ( xt )
1A276C0 	40 49 A0  1 60 C5 A1  1 
1A276C8 	DC 41 A0  1 10  0  0  0 
1A276D0 	30 49 A0  1  4 70 A0  1 
1A276D8 	40 46 A0  1 
   dup ['] $call-self =  if  drop true exit  then  ( xt )
1A276DC 	40 49 A0  1 
1A276E0 	60 53 A0  1 B4 30 A2  1 
1A276E8 	24 48 A0  1 DC 41 A0  1 
1A276F0 	10  0  0  0 30 49 A0  1 
1A276F8 	 4 70 A0  1 40 46 A0  1 
   dup ['] $call-method =  if  drop true exit  then  ( xt )
1A27700 	40 49 A0  1 60 53 A0  1 
1A27708 	B4 31 A2  1 24 48 A0  1 
1A27710 	DC 41 A0  1 10  0  0  0 
1A27718 	30 49 A0  1  4 70 A0  1 
1A27720 	40 46 A0  1 
   dup ['] $call-parent =  if  drop true exit  then  ( xt )
1A27724 	40 49 A0  1 
1A27728 	60 53 A0  1 DC 31 A2  1 
1A27730 	24 48 A0  1 DC 41 A0  1 
1A27738 	10  0  0  0 30 49 A0  1 
1A27740 	 4 70 A0  1 40 46 A0  1 
   dup ['] call-package =  if  drop true exit  then  ( xt )
1A27748 	40 49 A0  1 60 53 A0  1 
1A27750 	8C 31 A2  1 24 48 A0  1 
1A27758 	DC 41 A0  1 10  0  0  0 
1A27760 	30 49 A0  1  4 70 A0  1 
1A27768 	40 46 A0  1 
   dup ['] $vexecute    =  if  drop true exit  then  ( xt )
1A2776C 	40 49 A0  1 
1A27770 	60 53 A0  1 D0  D A2  1 
1A27778 	24 48 A0  1 DC 41 A0  1 
1A27780 	10  0  0  0 30 49 A0  1 
1A27788 	 4 70 A0  1 40 46 A0  1 
   dup ['] $vexecute?   =  if  drop true exit  then  ( xt )
1A27790 	40 49 A0  1 60 53 A0  1 
1A27798 	54  D A2  1 24 48 A0  1 
1A277A0 	DC 41 A0  1 10  0  0  0 
1A277A8 	30 49 A0  1  4 70 A0  1 
1A277B0 	40 46 A0  1 
   dup ['] $package-execute? =  if  drop true exit  then  ( xt )
1A277B4 	40 49 A0  1 
1A277B8 	60 53 A0  1 94  D A2  1 
1A277C0 	24 48 A0  1 DC 41 A0  1 
1A277C8 	10  0  0  0 30 49 A0  1 
1A277D0 	 4 70 A0  1 40 46 A0  1 
   dup ['] package-execute   =  if  drop true exit  then  ( xt )
1A277D8 	40 49 A0  1 60 53 A0  1 
1A277E0 	E8 19 A2  1 24 48 A0  1 
1A277E8 	DC 41 A0  1 10  0  0  0 
1A277F0 	30 49 A0  1  4 70 A0  1 
1A277F8 	40 46 A0  1 
   dup ['] apply-method      =  if  drop true exit  then  ( xt )
1A277FC 	40 49 A0  1 
1A27800 	60 53 A0  1 A0 38 A2  1 
1A27808 	24 48 A0  1 DC 41 A0  1 
1A27810 	10  0  0  0 30 49 A0  1 
1A27818 	 4 70 A0  1 40 46 A0  1 
   dup ['] (apply-method)    =  if  drop true exit  then  ( xt )
1A27820 	40 49 A0  1 60 53 A0  1 
1A27828 	20 3C A2  1 24 48 A0  1 
1A27830 	DC 41 A0  1 10  0  0  0 
1A27838 	30 49 A0  1  4 70 A0  1 
1A27840 	40 46 A0  1 
   dup ['] (execute-method)  =  if  drop true exit  then  ( xt )
1A27844 	40 49 A0  1 
1A27848 	60 53 A0  1 54 3F A2  1 
1A27850 	24 48 A0  1 DC 41 A0  1 
1A27858 	10  0  0  0 30 49 A0  1 
1A27860 	 4 70 A0  1 40 46 A0  1 
   dup ['] execute-device-method  =  if  drop true exit  then  ( xt )
1A27868 	40 49 A0  1 60 53 A0  1 
1A27870 	84 3F A2  1 24 48 A0  1 
1A27878 	DC 41 A0  1 10  0  0  0 
1A27880 	30 49 A0  1  4 70 A0  1 
1A27888 	40 46 A0  1 
   drop false
1A2788C 	30 49 A0  1 
1A27890 	18 70 A0  1 
;
1A27894 	58 46 A0  1 
' method-call? to indirect-call?
previous

OpenFirmware/ofw/core/ofwcore.fth_AL	MEG=39189 1A27898 
stand-init0=1A27E2C \ From date.fth
purpose: Time and date decoding functions

variable clock-node  ' clock-node  " clock" chosen-variable
1A27898 	 0 63 6C 6F 63 6B 2D 6E 
1A278A0 	6F 64 65 8A BC 76 A2  1 
1A278A8 	48 40 A0  1 10  8  0  0 
1A278B0 	 0  0 63 6C 6F 63 6B 85 
1A278B8 	48 5A A2  1 F0 52 A2  1 
1A278C0 	A8 78 A2  1 

: ofw-time&date  ( -- s m h d m y )
1A278C4 	 0  0 6F 66 
1A278C8 	77 2D 74 69 6D 65 26 64 
1A278D0 	61 74 65 8D A8 78 A2  1 
1A278D8 	20 40 A0  1 
   " get-date" clock-node @ ihandle>phandle find-method  if
1A278DC 	9C 53 A0  1 
1A278E0 	 8 67 65 74 2D 64 61 74 
1A278E8 	65  0  0  0 A8 78 A2  1 
1A278F0 	5C 4C A0  1  0 32 A2  1 
1A278F8 	A0 2F A2  1 DC 41 A0  1 
1A27900 	58  0  0  0 
      drop
1A27904 	30 49 A0  1 
      " get-time" clock-node @  $call-method  swap rot
1A27908 	9C 53 A0  1  8 67 65 74 
1A27910 	2D 74 69 6D 65  0  0  0 
1A27918 	A8 78 A2  1 5C 4C A0  1 
1A27920 	B4 31 A2  1 68 49 A0  1 
1A27928 	7C 49 A0  1 
      " get-date" clock-node @  $call-method  swap rot
1A2792C 	9C 53 A0  1 
1A27930 	 8 67 65 74 2D 64 61 74 
1A27938 	65  0  0  0 A8 78 A2  1 
1A27940 	5C 4C A0  1 B4 31 A2  1 
1A27948 	68 49 A0  1 7C 49 A0  1 
   else
1A27950 	C8 41 A0  1 20  0  0  0 
      " get-time" clock-node @  $call-method
1A27958 	9C 53 A0  1  8 67 65 74 
1A27960 	2D 74 69 6D 65  0  0  0 
1A27968 	A8 78 A2  1 5C 4C A0  1 
1A27970 	B4 31 A2  1 
   then
;
1A27974 	58 46 A0  1 
stand-init:
1A27978 	 0 73 74 61 6E 64 2D 69 
1A27980 	6E 69 74 8A D8 78 A2  1 
1A27988 	20 40 A0  1 
   ['] ofw-time&date to time&date
1A2798C 	60 53 A0  1 
1A27990 	D8 78 A2  1 98 40 A0  1 
1A27998 	F4 EC A0  1 
;
1A2799C 	58 46 A0  1 

headerless
: 2.d  ( n -- )   push-decimal  (.2)  type  pop-base  ;
1A279A0 	32 2E 64 83 88 79 A2  1 
1A279A8 	20 40 A0  1 48 F4 A0  1 
1A279B0 	D8 78 A0  1  4 6C A0  1 
1A279B8 	9C F4 A0  1 58 46 A0  1 
: 4.d  ( n -- )   push-decimal  <# u# u# u# u# u#>  type  pop-base  ;
1A279C0 	34 2E 64 83 A8 79 A2  1 
1A279C8 	20 40 A0  1 48 F4 A0  1 
1A279D0 	 8 76 A0  1 94 76 A0  1 
1A279D8 	94 76 A0  1 94 76 A0  1 
1A279E0 	94 76 A0  1 E0 76 A0  1 
1A279E8 	 4 6C A0  1 9C F4 A0  1 
1A279F0 	58 46 A0  1 

headers
: .date  ( d m y -- )   4.d ." -" 2.d ." -" 2.d  ;
1A279F4 	 0  0 2E 64 
1A279F8 	61 74 65 85 C8 79 A2  1 
1A27A00 	20 40 A0  1 C8 79 A2  1 
1A27A08 	20 7C A0  1  1 2D  0  0 
1A27A10 	A8 79 A2  1 20 7C A0  1 
1A27A18 	 1 2D  0  0 A8 79 A2  1 
1A27A20 	58 46 A0  1 
: .time  ( s m h -- )   2.d ." :" 2.d ." :" 2.d  ;
1A27A24 	 0  0 2E 74 
1A27A28 	69 6D 65 85  0 7A A2  1 
1A27A30 	20 40 A0  1 A8 79 A2  1 
1A27A38 	20 7C A0  1  1 3A  0  0 
1A27A40 	A8 79 A2  1 20 7C A0  1 
1A27A48 	 1 3A  0  0 A8 79 A2  1 
1A27A50 	58 46 A0  1 

\ Interactive diagnostic
: watch-clock  ( -- )
1A27A54 	77 61 74 63 
1A27A58 	68 2D 63 6C 6F 63 6B 8B 
1A27A60 	30 7A A2  1 20 40 A0  1 
   ." Watching the 'seconds' register of the real time clock chip."  cr
1A27A68 	20 7C A0  1 3C 57 61 74 
1A27A70 	63 68 69 6E 67 20 74 68 
1A27A78 	65 20 27 73 65 63 6F 6E 
1A27A80 	64 73 27 20 72 65 67 69 
1A27A88 	73 74 65 72 20 6F 66 20 
1A27A90 	74 68 65 20 72 65 61 6C 
1A27A98 	20 74 69 6D 65 20 63 6C 
1A27AA0 	6F 63 6B 20 63 68 69 70 
1A27AA8 	2E  0  0  0 80 6D A0  1 
   ." It should be 'ticking' once a second." cr
1A27AB0 	20 7C A0  1 25 49 74 20 
1A27AB8 	73 68 6F 75 6C 64 20 62 
1A27AC0 	65 20 27 74 69 63 6B 69 
1A27AC8 	6E 67 27 20 6F 6E 63 65 
1A27AD0 	20 61 20 73 65 63 6F 6E 
1A27AD8 	64 2E  0  0 80 6D A0  1 
   ." Type any key to stop."  cr
1A27AE0 	20 7C A0  1 15 54 79 70 
1A27AE8 	65 20 61 6E 79 20 6B 65 
1A27AF0 	79 20 74 6F 20 73 74 6F 
1A27AF8 	70 2E  0  0 80 6D A0  1 
   -1
1A27B00 	58 41 A0  1 FF FF FF FF 
   begin    ( old-seconds )
      begin
         key?  if  key drop  drop exit  then
1A27B08 	64 6C A0  1 DC 41 A0  1 
1A27B10 	14  0  0  0 50 6C A0  1 
1A27B18 	30 49 A0  1 30 49 A0  1 
1A27B20 	40 46 A0  1 
         now 2drop
1A27B24 	 4 ED A0  1 
1A27B28 	AC 49 A0  1 
      2dup =  while   ( old-seconds old-seconds )
1A27B2C 	C0 49 A0  1 
1A27B30 	24 48 A0  1 DC 41 A0  1 
1A27B38 	10  0  0  0 
         drop
1A27B3C 	30 49 A0  1 
      repeat          ( old-seconds new-seconds )
1A27B40 	C8 41 A0  1 C4 FF FF FF 
      nip (cr now .time
1A27B48 	FC 46 A0  1 9C 72 A0  1 
1A27B50 	 4 ED A0  1 30 7A A2  1 
   again
1A27B58 	C8 41 A0  1 AC FF FF FF 
   drop
1A27B60 	30 49 A0  1 
;
1A27B64 	58 46 A0  1 

: watch-rtc
1A27B68 	 0  0 77 61 74 63 68 2D 
1A27B70 	72 74 63 89 64 7A A2  1 
1A27B78 	20 40 A0  1 
   begin 
      time&date .date ."  " .time (cr 500 ms
1A27B7C 	F4 EC A0  1 
1A27B80 	 0 7A A2  1 20 7C A0  1 
1A27B88 	 1 20  0  0 30 7A A2  1 
1A27B90 	9C 72 A0  1 58 41 A0  1 
1A27B98 	F4  1  0  0 60 E0 A1  1 
   key? until
1A27BA0 	64 6C A0  1 DC 41 A0  1 
1A27BA8 	D4 FF FF FF 
   key drop
1A27BAC 	50 6C A0  1 
1A27BB0 	30 49 A0  1 
;
1A27BB4 	58 46 A0  1 

\ From fwfileop.fth
purpose: File I/O interface using Open Firmware

headerless
\ Closes an open file, freeing its descriptor for reuse.

: _ofclose  ( file# -- )
1A27BB8 	 0  0  0 5F 6F 66 63 6C 
1A27BC0 	6F 73 65 88 78 7B A2  1 
1A27BC8 	20 40 A0  1 
   bfbase @  bflimit @ over -  free-mem   \ Hack!  Hack!
1A27BCC 	98 AB A0  1 
1A27BD0 	5C 4C A0  1 BC AB A0  1 
1A27BD8 	5C 4C A0  1 54 49 A0  1 
1A27BE0 	18 45 A0  1  8 6D A0  1 
   close-dev
1A27BE8 	5C 37 A2  1 
;
1A27BEC 	58 46 A0  1 

\ Writes "count" bytes from the buffer at address "adr" to a file.
\ Returns the number of bytes actually written.

: _ofwrite  ( adr #bytes file# -- #written )  " write" rot $call-method  ;
1A27BF0 	 0  0  0 5F 6F 66 77 72 
1A27BF8 	69 74 65 88 C8 7B A2  1 
1A27C00 	20 40 A0  1 9C 53 A0  1 
1A27C08 	 5 77 72 69 74 65  0  0 
1A27C10 	7C 49 A0  1 B4 31 A2  1 
1A27C18 	58 46 A0  1 

\ Reads at most "count" bytes into the buffer at address "adr" from a file.
\ Returns the number of bytes actually read.

: _ofread  ( adr #bytes file# -- #read )  " read" rot $call-method  ;
1A27C1C 	5F 6F 66 72 
1A27C20 	65 61 64 87  0 7C A2  1 
1A27C28 	20 40 A0  1 9C 53 A0  1 
1A27C30 	 4 72 65 61 64  0  0  0 
1A27C38 	7C 49 A0  1 B4 31 A2  1 
1A27C40 	58 46 A0  1 

\ Positions to byte number "l.byte#" in a file

: _ofseek  ( d.byte# file# -- )  " seek" rot $call-method  drop  ;
1A27C44 	5F 6F 66 73 
1A27C48 	65 65 6B 87 28 7C A2  1 
1A27C50 	20 40 A0  1 9C 53 A0  1 
1A27C58 	 4 73 65 65 6B  0  0  0 
1A27C60 	7C 49 A0  1 B4 31 A2  1 
1A27C68 	30 49 A0  1 58 46 A0  1 

\ Returns the current size "l.size" of a file

: _ofsize  ( file# -- d.size )  " size" rot $call-method  ;
1A27C70 	5F 6F 66 73 69 7A 65 87 
1A27C78 	50 7C A2  1 20 40 A0  1 
1A27C80 	9C 53 A0  1  4 73 69 7A 
1A27C88 	65  0  0  0 7C 49 A0  1 
1A27C90 	B4 31 A2  1 58 46 A0  1 

\ Prepares a file for later access.  Name is the pathname of the file
\ and mode is the mode (0 read, 1 write, 2 modify).  If the operation
\ succeeds, returns the addresses of routines to perform I/O on the
\ open file and true.  If the operation fails, returns false.


defer _ofcreate
1A27C98 	 0  0 5F 6F 66 63 72 65 
1A27CA0 	61 74 65 89 7C 7C A2  1 
1A27CA8 	5C 40 A0  1 14  8  0  0 
: null-create  ( name -- 0 )  2drop 0  ;
1A27CB0 	6E 75 6C 6C 2D 63 72 65 
1A27CB8 	61 74 65 8B A8 7C A2  1 
1A27CC0 	20 40 A0  1 AC 49 A0  1 
1A27CC8 	70 6F A0  1 58 46 A0  1 
' null-create to _ofcreate

defer _ofdelete
1A27CD0 	 0  0 5F 6F 66 64 65 6C 
1A27CD8 	65 74 65 89 C0 7C A2  1 
1A27CE0 	5C 40 A0  1 18  8  0  0 
' 2drop to _ofdelete

: _ofopen
1A27CE8 	5F 6F 66 6F 70 65 6E 87 
1A27CF0 	E0 7C A2  1 20 40 A0  1 
   ( name mode -- [ fid mode sizeop alignop closeop writeop readop ] okay? )
   >r count                                     ( name$  r: mode )
1A27CF8 	BC 45 A0  1 BC 53 A0  1 
   r@ create-flag and  if                       ( name$  r: mode )
1A27D00 	E4 45 A0  1 64 D6 A0  1 
1A27D08 	5C 44 A0  1 DC 41 A0  1 
1A27D10 	20  0  0  0 
      2dup ['] _ofdelete catch  if  2drop  then ( name$  r: mode )
1A27D14 	C0 49 A0  1 
1A27D18 	60 53 A0  1 E0 7C A2  1 
1A27D20 	14 7F A0  1 DC 41 A0  1 
1A27D28 	 8  0  0  0 AC 49 A0  1 
   then                                         ( name$  r: mode )

   2dup open-dev  ?dup  0=  if                  ( name$    r: mode )
1A27D30 	C0 49 A0  1 FC 3E A2  1 
1A27D38 	B4 70 A0  1 24 47 A0  1 
1A27D40 	DC 41 A0  1 4C  0  0  0 
      r@ r/o =  if                              ( name$    r: mode )
1A27D48 	E4 45 A0  1 1C D6 A0  1 
1A27D50 	24 48 A0  1 DC 41 A0  1 
1A27D58 	10  0  0  0 
         0                                      ( name$ 0  r: mode )
1A27D5C 	70 6F A0  1 
      else                                      ( name$    r: mode )
1A27D60 	C8 41 A0  1  C  0  0  0 
         2dup _ofcreate                         ( name$ ih r: mode )
1A27D68 	C0 49 A0  1 A8 7C A2  1 
      then                                      ( name$ ih r: mode )
      ?dup 0=  if  r> 3drop  false exit  then   ( name$ ih r: mode )
1A27D70 	B4 70 A0  1 24 47 A0  1 
1A27D78 	DC 41 A0  1 14  0  0  0 
1A27D80 	D0 45 A0  1 90 52 A0  1 
1A27D88 	18 70 A0  1 40 46 A0  1 
   then                                         ( name$ ih r: mode )
   nip nip                                      ( ih       r: mode )
1A27D90 	FC 46 A0  1 FC 46 A0  1 
   r@   ['] _ofsize   ['] _dfalign   ['] _ofclose   ['] _ofseek
1A27D98 	E4 45 A0  1 60 53 A0  1 
1A27DA0 	7C 7C A2  1 60 53 A0  1 
1A27DA8 	D8 EE A0  1 60 53 A0  1 
1A27DB0 	C8 7B A2  1 60 53 A0  1 
1A27DB8 	50 7C A2  1 
   r@ r/o  =  if  ['] nullwrite  else  ['] _ofwrite  then
1A27DBC 	E4 45 A0  1 
1A27DC0 	1C D6 A0  1 24 48 A0  1 
1A27DC8 	DC 41 A0  1 14  0  0  0 
1A27DD0 	60 53 A0  1 40 CA A0  1 
1A27DD8 	C8 41 A0  1  C  0  0  0 
1A27DE0 	60 53 A0  1  0 7C A2  1 
   r> w/o  =  if  ['] nullread   else  ['] _ofread   then
1A27DE8 	D0 45 A0  1 2C D6 A0  1 
1A27DF0 	24 48 A0  1 DC 41 A0  1 
1A27DF8 	14  0  0  0 60 53 A0  1 
1A27E00 	9C CA A0  1 C8 41 A0  1 
1A27E08 	 C  0  0  0 60 53 A0  1 
1A27E10 	28 7C A2  1 
   true
1A27E14 	 4 70 A0  1 
;
1A27E18 	58 46 A0  1 

headers

: stand-init  ( -- )  stand-init  ['] _ofopen to do-fopen  ;
1A27E1C 	 0 73 74 61 
1A27E20 	6E 64 2D 69 6E 69 74 8A 
1A27E28 	F4 7C A2  1 20 40 A0  1 
1A27E30 	88 79 A2  1 60 53 A0  1 
1A27E38 	F4 7C A2  1 98 40 A0  1 
1A27E40 	50 D5 A0  1 58 46 A0  1 

CR .( stand-init0=)
' stand-init DUP H. to 'stand-init0

OpenFirmware/ofw/core/ofwfw.fth_AL	1456 1A27E48 purpose: Internal interfaces to memory node operations

headers
variable memory-node   ' memory-node  " memory" chosen-variable
1A27E48 	6D 65 6D 6F 72 79 2D 6E 
1A27E50 	6F 64 65 8B 2C 7E A2  1 
1A27E58 	48 40 A0  1 1C  8  0  0 
1A27E60 	 0 6D 65 6D 6F 72 79 86 
1A27E68 	BC 78 A2  1 F0 52 A2  1 
1A27E70 	58 7E A2  1 

: $call-mem-method ( ??? method$ -- ???  )  memory-node @  $call-method  ;
1A27E74 	 0  0  0 24 
1A27E78 	63 61 6C 6C 2D 6D 65 6D 
1A27E80 	2D 6D 65 74 68 6F 64 90 
1A27E88 	58 7E A2  1 20 40 A0  1 
1A27E90 	58 7E A2  1 5C 4C A0  1 
1A27E98 	B4 31 A2  1 58 46 A0  1 

: mem-claim  ( [ phys.. ] size align -- base.. )  " claim" $call-mem-method  ;
1A27EA0 	 0  0 6D 65 6D 2D 63 6C 
1A27EA8 	61 69 6D 89 8C 7E A2  1 
1A27EB0 	20 40 A0  1 9C 53 A0  1 
1A27EB8 	 5 63 6C 61 69 6D  0  0 
1A27EC0 	8C 7E A2  1 58 46 A0  1 
: mem-release  ( phys.. size -- )  " release" $call-mem-method  ;
1A27EC8 	6D 65 6D 2D 72 65 6C 65 
1A27ED0 	61 73 65 8B B0 7E A2  1 
1A27ED8 	20 40 A0  1 9C 53 A0  1 
1A27EE0 	 7 72 65 6C 65 61 73 65 
1A27EE8 	 0  0  0  0 8C 7E A2  1 
1A27EF0 	58 46 A0  1 
: mem-mode  ( -- mode )  " mode" $call-mem-method  ;
1A27EF4 	 0  0  0 6D 
1A27EF8 	65 6D 2D 6D 6F 64 65 88 
1A27F00 	D8 7E A2  1 20 40 A0  1 
1A27F08 	9C 53 A0  1  4 6D 6F 64 
1A27F10 	65  0  0  0 8C 7E A2  1 
1A27F18 	58 46 A0  1 

\ get-memory can be used by init-program modules instead of mem-claim
\ to avoid the need to know system-specific details
: get-memory  ( adr len -- )
1A27F1C 	 0 67 65 74 
1A27F20 	2D 6D 65 6D 6F 72 79 8A 
1A27F28 	 4 7F A2  1 20 40 A0  1 
\ [ '#adr-cells @ 2 = ] [if]
\   0 swap  0 mem-claim 2drop
\ [else]
   0 mem-claim drop
1A27F30 	70 6F A0  1 B0 7E A2  1 
1A27F38 	30 49 A0  1 
\ [then]
;
1A27F3C 	58 46 A0  1 

OpenFirmware/ofw/core/memops.fth_AL	248 1A27F40 purpose: Call MMU node methods

0 value pagesize
1A27F40 	 0  0  0 70 61 67 65 73 
1A27F48 	69 7A 65 88 2C 7F A2  1 
1A27F50 	50 40 A0  1 20  8  0  0 
headerless
0 value pageshift
1A27F58 	 0  0 70 61 67 65 73 68 
1A27F60 	69 66 74 89 50 7F A2  1 
1A27F68 	50 40 A0  1 24  8  0  0 

headers
variable mmu-node   ' mmu-node  " mmu" chosen-variable
1A27F70 	 0  0  0 6D 6D 75 2D 6E 
1A27F78 	6F 64 65 88 68 7F A2  1 
1A27F80 	48 40 A0  1 28  8  0  0 
1A27F88 	6D 6D 75 83 6C 7E A2  1 
1A27F90 	F0 52 A2  1 80 7F A2  1 

: $call-mmu-method ( ??? method$ -- ???  )  mmu-node @  $call-method  ;
1A27F98 	 0  0  0 24 63 61 6C 6C 
1A27FA0 	2D 6D 6D 75 2D 6D 65 74 
1A27FA8 	68 6F 64 90 80 7F A2  1 
1A27FB0 	20 40 A0  1 80 7F A2  1 
1A27FB8 	5C 4C A0  1 B4 31 A2  1 
1A27FC0 	58 46 A0  1 

: mmu-translate  ( virt -- false | phys.. mode true )
1A27FC4 	 0  0 6D 6D 
1A27FC8 	75 2D 74 72 61 6E 73 6C 
1A27FD0 	61 74 65 8D B0 7F A2  1 
1A27FD8 	20 40 A0  1 
   " translate" $call-mmu-method
1A27FDC 	9C 53 A0  1 
1A27FE0 	 9 74 72 61 6E 73 6C 61 
1A27FE8 	74 65  0  0 B0 7F A2  1 
;
1A27FF0 	58 46 A0  1 

: mmu-map  ( phys.. virt size mode -- )  " map" $call-mmu-method  ;
1A27FF4 	6D 6D 75 2D 
1A27FF8 	6D 61 70 87 D8 7F A2  1 
1A28000 	20 40 A0  1 9C 53 A0  1 
1A28008 	 3 6D 61 70  0  0  0  0 
1A28010 	B0 7F A2  1 58 46 A0  1 
: mmu-claim  ( [ virt ] size align -- base )  " claim" $call-mmu-method  ;
1A28018 	 0  0 6D 6D 75 2D 63 6C 
1A28020 	61 69 6D 89  0 80 A2  1 
1A28028 	20 40 A0  1 9C 53 A0  1 
1A28030 	 5 63 6C 61 69 6D  0  0 
1A28038 	B0 7F A2  1 58 46 A0  1 
: mmu-release  ( virt size -- )  " release" $call-mmu-method  ;
1A28040 	6D 6D 75 2D 72 65 6C 65 
1A28048 	61 73 65 8B 28 80 A2  1 
1A28050 	20 40 A0  1 9C 53 A0  1 
1A28058 	 7 72 65 6C 65 61 73 65 
1A28060 	 0  0  0  0 B0 7F A2  1 
1A28068 	58 46 A0  1 
: mmu-unmap  ( virt size -- )  " unmap" $call-mmu-method  ;
1A2806C 	 0  0 6D 6D 
1A28070 	75 2D 75 6E 6D 61 70 89 
1A28078 	50 80 A2  1 20 40 A0  1 
1A28080 	9C 53 A0  1  5 75 6E 6D 
1A28088 	61 70  0  0 B0 7F A2  1 
1A28090 	58 46 A0  1 

: mmu-lowbits   ( adr1 -- lowbits  )  pagesize  1-     and  ;
1A28094 	6D 6D 75 2D 
1A28098 	6C 6F 77 62 69 74 73 8B 
1A280A0 	7C 80 A2  1 20 40 A0  1 
1A280A8 	50 7F A2  1 54 4B A0  1 
1A280B0 	5C 44 A0  1 58 46 A0  1 
: mmu-highbits  ( adr1 -- highbits )  pagesize  round-down  ;
1A280B8 	 0  0  0 6D 6D 75 2D 68 
1A280C0 	69 67 68 62 69 74 73 8C 
1A280C8 	A4 80 A2  1 20 40 A0  1 
1A280D0 	50 7F A2  1 80 91 A0  1 
1A280D8 	58 46 A0  1 

: >physical  ( virt -- phys.. )
1A280DC 	 0  0 3E 70 
1A280E0 	68 79 73 69 63 61 6C 89 
1A280E8 	CC 80 A2  1 20 40 A0  1 
   >r r@ mmu-translate  if  drop r> drop  else  r>  then
1A280F0 	BC 45 A0  1 E4 45 A0  1 
1A280F8 	D8 7F A2  1 DC 41 A0  1 
1A28100 	18  0  0  0 30 49 A0  1 
1A28108 	D0 45 A0  1 30 49 A0  1 
1A28110 	C8 41 A0  1  8  0  0  0 
1A28118 	D0 45 A0  1 
;
1A2811C 	58 46 A0  1 

defer memory?  ( phys.. -- flag )
1A28120 	6D 65 6D 6F 72 79 3F 87 
1A28128 	EC 80 A2  1 5C 40 A0  1 
1A28130 	2C  8  0  0 

OpenFirmware/ofw/core/mmuops.fth_AL	500 1A28134 \ Access to alternate segments

code spacec@  ( adr space -- byte )
1A28134 	73 70 61 63 
1A28138 	65 63 40 87 2C 81 A2  1 
1A28140 	44 81 A2  1 
   ax pop   ax fs mov   bx pop   ax ax sub  fs: 0 [bx] al mov  1push
1A28144 	58 8E E0 5B 
1A28148 	29 C0 64 8A  3 50 
c;
1A2814E 	FF E7 

code spacec!  ( byte adr space -- )
1A28150 	73 70 61 63 65 63 21 87 
1A28158 	40 81 A2  1 60 81 A2  1 
   ax pop   ax fs mov   bx pop   ax pop  fs: al 0 [bx] mov
1A28160 	58 8E E0 5B 58 64 88  3 
c;
1A28168 	FF E7 

code spacel@  ( adr space -- byte )
1A2816A 	 0  0 73 70 61 63 
1A28170 	65 6C 40 87 5C 81 A2  1 
1A28178 	7C 81 A2  1 
   ax pop   ax fs mov   bx pop   fs: 0 [bx] ax mov  1push
1A2817C 	58 8E E0 5B 
1A28180 	64 8B  3 50 
c;
1A28184 	FF E7 

code spacel!  ( byte adr space -- )
1A28186 	 0  0 
1A28188 	73 70 61 63 65 6C 21 87 
1A28190 	78 81 A2  1 98 81 A2  1 
   ax pop   ax fs mov   bx pop   ax pop  fs: ax 0 [bx] mov
1A28198 	58 8E E0 5B 58 64 89  3 
c;
1A281A0 	FF E7 

\ I/O space access via IN and OUT instructions

code pc@  ( b adr -- )  dx pop  ax ax xor      dx al in  ax push   c;
1A281A2 	 0  0 70 63 40 83 
1A281A8 	94 81 A2  1 B0 81 A2  1 
1A281B0 	5A 31 C0 EC 50 FF E7 
code pw@  ( adr -- w )  dx pop  ax ax xor  op: dx ax in  ax push  c;
1A281B7 	 0 
1A281B8 	70 77 40 83 AC 81 A2  1 
1A281C0 	C4 81 A2  1 5A 31 C0 66 
1A281C8 	ED 50 FF E7 
code pl@  ( adr -- l )  dx pop                 dx ax in  ax push  c;
1A281CC 	70 6C 40 83 
1A281D0 	C0 81 A2  1 D8 81 A2  1 
1A281D8 	5A ED 50 FF E7 
code pc!  ( adr -- b )  dx pop  ax pop         al dx out  c;
1A281DD 	 0  0  0 
1A281E0 	70 63 21 83 D4 81 A2  1 
1A281E8 	EC 81 A2  1 5A 58 EE FF 
1A281F0 	E7 
code pw!  ( w adr -- )  dx pop  ax pop     op: ax dx out  c;
1A281F1 	 0  0  0 70 77 21 83 
1A281F8 	E8 81 A2  1  0 82 A2  1 
1A28200 	5A 58 66 EF FF E7 
code pl!  ( l adr -- )  dx pop  ax pop         ax dx out  c;
1A28206 	 0  0 
1A28208 	70 6C 21 83 FC 81 A2  1 
1A28210 	14 82 A2  1 5A 58 EF FF 
1A28218 	E7 

OpenFirmware/cpu/x86/segments.fth_AL	229 1A28219 purpose: Access primitives for descriptor tables.

\ Far pointers to the beginnings of descriptor tables
\ "farp" is "offset selector"

defer idt  ( -- farp )
1A28219 	 0  0  0 69 64 74 83 
1A28220 	10 82 A2  1 5C 40 A0  1 
1A28228 	30  8  0  0 
defer gdt  ( -- farp )
1A2822C 	67 64 74 83 
1A28230 	24 82 A2  1 5C 40 A0  1 
1A28238 	34  8  0  0 
defer ldt  ( -- farp )
1A2823C 	6C 64 74 83 
1A28240 	34 82 A2  1 5C 40 A0  1 
1A28248 	38  8  0  0 
defer environ-ptr  ( -- farp )
1A2824C 	65 6E 76 69 
1A28250 	72 6F 6E 2D 70 74 72 8B 
1A28258 	44 82 A2  1 5C 40 A0  1 
1A28260 	3C  8  0  0 

: (ldt)    ( -- farp )  0  ldtr@  ;
1A28264 	 0  0 28 6C 
1A28268 	64 74 29 85 5C 82 A2  1 
1A28270 	20 40 A0  1 70 6F A0  1 
1A28278 	90 76 A1  1 58 46 A0  1 
' (ldt) is ldt

\ Add an offset to a far pointer.
: far+  ( farp-offset farp-sel offset -- farp-offset' farp-sel )  rot + swap  ;
1A28280 	 0  0  0 66 61 72 2B 84 
1A28288 	70 82 A2  1 20 40 A0  1 
1A28290 	7C 49 A0  1  4 45 A0  1 
1A28298 	68 49 A0  1 58 46 A0  1 

\ Fetch and store far pointers
: farp@  ( adr -- offset sel )  dup le-l@  swap la1+ le-w@  ;
1A282A0 	 0  0 66 61 72 70 40 85 
1A282A8 	8C 82 A2  1 20 40 A0  1 
1A282B0 	40 49 A0  1 4C 4C A0  1 
1A282B8 	68 49 A0  1 B4 50 A0  1 
1A282C0 	80 4C A0  1 58 46 A0  1 
: farp!  ( offset sel adr -- )  tuck la1+ le-w!  le-l!  ;
1A282C8 	 0  0 66 61 72 70 21 85 
1A282D0 	AC 82 A2  1 20 40 A0  1 
1A282D8 	E8 46 A0  1 B4 50 A0  1 
1A282E0 	90 4D A0  1 44 4D A0  1 
1A282E8 	58 46 A0  1 

\ 4-byte far access
: far-l@  ( farp -- l )  spacel@  ;
1A282EC 	 0 66 61 72 
1A282F0 	2D 6C 40 86 D4 82 A2  1 
1A282F8 	20 40 A0  1 78 81 A2  1 
1A28300 	58 46 A0  1 
: far-l!  ( l farp -- )  spacel!  ;
1A28304 	 0 66 61 72 
1A28308 	2D 6C 21 86 F8 82 A2  1 
1A28310 	20 40 A0  1 94 81 A2  1 
1A28318 	58 46 A0  1 

\ 8-byte far access
: far-x@  ( farp -- ls ms )  2dup far-l@  -rot  4 far+ far-l@  ;
1A2831C 	 0 66 61 72 
1A28320 	2D 78 40 86 10 83 A2  1 
1A28328 	20 40 A0  1 C0 49 A0  1 
1A28330 	F8 82 A2  1 94 49 A0  1 
1A28338 	B0 6F A0  1 8C 82 A2  1 
1A28340 	F8 82 A2  1 58 46 A0  1 
: far-x!  ( ls ms farp -- )  rot 2 pick 2 pick 4 far+  far-l!  far-l!  ;
1A28348 	 0 66 61 72 2D 78 21 86 
1A28350 	28 83 A2  1 20 40 A0  1 
1A28358 	7C 49 A0  1 90 6F A0  1 
1A28360 	 C 4A A0  1 90 6F A0  1 
1A28368 	 C 4A A0  1 B0 6F A0  1 
1A28370 	8C 82 A2  1 10 83 A2  1 
1A28378 	10 83 A2  1 58 46 A0  1 

OpenFirmware/cpu/x86/dt.fth_AL	359 1A28380 id: @(#)datatype.fth 1.4 00/04/25
purpose: Defines terminal-emulator-specific data types

headers

d# 34 value screen-#rows       \ EEPROM parameter
1A28380 	 0  0  0 73 63 72 65 65 
1A28388 	6E 2D 23 72 6F 77 73 8C 
1A28390 	54 83 A2  1 50 40 A0  1 
1A28398 	40  8  0  0 
d# 80 value screen-#columns    \ EEPROM parameter
1A2839C 	73 63 72 65 
1A283A0 	65 6E 2D 23 63 6F 6C 75 
1A283A8 	6D 6E 73 8F 94 83 A2  1 
1A283B0 	50 40 A0  1 44  8  0  0 

\ Used to prevent re-entering the terminal emulator from a keyboard abort
variable terminal-locked?  terminal-locked? off
1A283B8 	 0  0  0 74 65 72 6D 69 
1A283C0 	6E 61 6C 2D 6C 6F 63 6B 
1A283C8 	65 64 3F 90 B0 83 A2  1 
1A283D0 	48 40 A0  1 48  8  0  0 

headerless
\ Will be initialized to (escape-state in fwritestr.fth
defer escape-state	\ Forward reference
1A283D8 	 0  0  0 65 73 63 61 70 
1A283E0 	65 2D 73 74 61 74 65 8C 
1A283E8 	D0 83 A2  1 5C 40 A0  1 
1A283F0 	4C  8  0  0 

: >termemu-data  ( pfa -- adr )  @  my-termemu +  ;
1A283F4 	 0  0 3E 74 
1A283F8 	65 72 6D 65 6D 75 2D 64 
1A28400 	61 74 61 8D EC 83 A2  1 
1A28408 	20 40 A0  1 5C 4C A0  1 
1A28410 	E4  3 A2  1  4 45 A0  1 
1A28418 	58 46 A0  1 
: forth-create  ( -- )
1A2841C 	 0  0  0 66 
1A28420 	6F 72 74 68 2D 63 72 65 
1A28428 	61 74 65 8C  8 84 A2  1 
1A28430 	20 40 A0  1 
   also forth definitions  create  previous definitions
1A28434 	C8 C1 A0  1 
1A28438 	 8 C5 A0  1 2C C4 A0  1 
1A28440 	A8 A2 A0  1 E4 C3 A0  1 
1A28448 	2C C4 A0  1 
;
1A2844C 	58 46 A0  1 

headers

3 actions
1A28450 	84 84 A2  1 74 84 A2  1 
1A28458 	 3  0  0  0 
action:  >termemu-data token@ execute  ;
1A2845C 	90 90 90 E8 
1A28460 	18 BC FD FF  8 84 A2  1 
1A28468 	 C 54 A0  1 98 41 A0  1 
1A28470 	58 46 A0  1 
action:  >termemu-data token!  ;
1A28474 	20 40 A0  1 
1A28478 	 8 84 A2  1 20 54 A0  1 
1A28480 	58 46 A0  1 
action:  >termemu-data token@  ;
1A28484 	20 40 A0  1 
1A28488 	 8 84 A2  1  C 54 A0  1 
1A28490 	58 46 A0  1 

: termemu-defer  \ name  ( -- )
1A28494 	 0  0 74 65 
1A28498 	72 6D 65 6D 75 2D 64 65 
1A284A0 	66 65 72 8D 30 84 A2  1 
1A284A8 	20 40 A0  1 
   forth-create
1A284AC 	30 84 A2  1 
   ['] crash /token  ( value data-size )
1A284B0 	60 53 A0  1 C8 A7 A0  1 
1A284B8 	B4 46 A0  1 
   use-actions value#, ( value adr )
1A284BC 	60 53 A0  1 
1A284C0 	5C 84 A2  1 E0 57 A0  1 
1A284C8 	2C FE A1  1 
   token!
1A284CC 	20 54 A0  1 
;  action-adr-t to  dotermemu-defer  \ mmo
1A284D0 	58 46 A0  1 

3 actions
1A284D4 	 4 85 A2  1 
1A284D8 	F4 84 A2  1  3  0  0  0 
action:  >termemu-data @  ;
1A284E0 	90 90 90 E8 94 BB FD FF 
1A284E8 	 8 84 A2  1 5C 4C A0  1 
1A284F0 	58 46 A0  1 
action:  >termemu-data !  ;
1A284F4 	20 40 A0  1 
1A284F8 	 8 84 A2  1 54 4D A0  1 
1A28500 	58 46 A0  1 
action:  >termemu-data    ;
1A28504 	20 40 A0  1 
1A28508 	 8 84 A2  1 58 46 A0  1 

: termemu-value  \ name  ( initial-value -- )
1A28510 	 0  0 74 65 72 6D 65 6D 
1A28518 	75 2D 76 61 6C 75 65 8D 
1A28520 	A8 84 A2  1 20 40 A0  1 
   forth-create
1A28528 	30 84 A2  1 
   /n  ( value data-size )
1A2852C 	40 51 A0  1 
   use-actions  value#,  ( value adr )
1A28530 	60 53 A0  1 E0 84 A2  1 
1A28538 	E0 57 A0  1 2C FE A1  1 
   !
1A28540 	54 4D A0  1 
;
1A28544 	58 46 A0  1 
action-adr-t to dotermemu-value \ mmo

3 actions
1A28548 	88 85 A2  1 70 85 A2  1 
1A28550 	 3  0  0  0 
action:  >termemu-data swap na+ @  ;  ( index -- value )
1A28554 	90 90 90 E8 
1A28558 	20 BB FD FF  8 84 A2  1 
1A28560 	68 49 A0  1 48 50 A0  1 
1A28568 	5C 4C A0  1 58 46 A0  1 
action:  >termemu-data swap na+ !  ;  ( value index -- )
1A28570 	20 40 A0  1  8 84 A2  1 
1A28578 	68 49 A0  1 48 50 A0  1 
1A28580 	54 4D A0  1 58 46 A0  1 
action:  >termemu-data swap na+    ;  ( index -- adr )
1A28588 	20 40 A0  1  8 84 A2  1 
1A28590 	68 49 A0  1 48 50 A0  1 
1A28598 	58 46 A0  1 

: termemu-array  \ name  ( #entries -- )
1A2859C 	 0  0 74 65 
1A285A0 	72 6D 65 6D 75 2D 61 72 
1A285A8 	72 61 79 8D 24 85 A2  1 
1A285B0 	20 40 A0  1 
   forth-create              ( #entries )
1A285B4 	30 84 A2  1 
   use-actions  /n* value#,  ( adr )
1A285B8 	60 53 A0  1 54 85 A2  1 
1A285C0 	E0 57 A0  1 98 51 A0  1 
1A285C8 	2C FE A1  1 
   drop
1A285CC 	30 49 A0  1 
;
1A285D0 	58 46 A0  1 


headers

OpenFirmware/ofw/termemu/datatype.fth_AL	596 1A285D4 
propset=1A285E8 B441D57 1A00890 
vocset=B441D57 1A00890 1A285E8 
new-node=B441D6B 1A00870 
vocset=B441D6B 1A00870 1A285E8 
terminal-emulator
1A28604 1A28628 id: @(#)framebuf.fth 3.4 01/04/06
purpose: Variables and defer words used by many frame buffers drivers

\ Variables that are useful for most kinds of frame buffers.
headers

\ The definition of frame-buffer-adr has been moved to devtree.fth, as
\ frame-buffer-adr is now a fixed instance value.  This was done as a
\ workaround for a problem with old FCode display drivers, some of which
\ use frame-buffer-adr for their selftest routines.  With multiple frame
\ buffers on the same machine, a "test" command directed to a frame buffer
\ can screw up the console device.
\ 0 termemu-value frame-buffer-adr

0 termemu-value column#			\ Cursor column number
1A28634 	63 6F 6C 75 
1A28638 	6D 6E 23 87 B0 85 A2  1 
1A28640 	E0 84 A2  1 18  0  0  0 
0 termemu-value line#			\ Cursor line number
1A28648 	 0  0 6C 69 6E 65 23 85 
1A28650 	40 86 A2  1 E0 84 A2  1 
1A28658 	1C  0  0  0 

d# 1152 termemu-value screen-width
1A2865C 	 0  0  0 73 
1A28660 	63 72 65 65 6E 2D 77 69 
1A28668 	64 74 68 8C 54 86 A2  1 
1A28670 	E0 84 A2  1 20  0  0  0 
d#  900 termemu-value screen-height
1A28678 	 0  0 73 63 72 65 65 6E 
1A28680 	2D 68 65 69 67 68 74 8D 
1A28688 	70 86 A2  1 E0 84 A2  1 
1A28690 	24  0  0  0 

0 termemu-value window-top		\ Pixel position of top of text area
1A28694 	 0 77 69 6E 
1A28698 	64 6F 77 2D 74 6F 70 8A 
1A286A0 	8C 86 A2  1 E0 84 A2  1 
1A286A8 	28  0  0  0 
0 termemu-value window-left		\ Pixel position of left of text area
1A286AC 	77 69 6E 64 
1A286B0 	6F 77 2D 6C 65 66 74 8B 
1A286B8 	A4 86 A2  1 E0 84 A2  1 
1A286C0 	2C  0  0  0 

0 termemu-value emu-bytes/line
1A286C4 	 0 65 6D 75 
1A286C8 	2D 62 79 74 65 73 2F 6C 
1A286D0 	69 6E 65 8E BC 86 A2  1 
1A286D8 	E0 84 A2  1 30  0  0  0 
0 termemu-value bytes/line		\ Framebuffer pitch
1A286E0 	 0 62 79 74 65 73 2F 6C 
1A286E8 	69 6E 65 8A D8 86 A2  1 
1A286F0 	E0 84 A2  1 34  0  0  0 

\ Interfaces to device-dependent graphics primitives:
d# 34 termemu-value #lines
1A286F8 	 0 23 6C 69 6E 65 73 86 
1A28700 	F0 86 A2  1 E0 84 A2  1 
1A28708 	38  0  0  0 
d# 80 termemu-value #columns
1A2870C 	 0  0  0 23 
1A28710 	63 6F 6C 75 6D 6E 73 88 
1A28718 	 4 87 A2  1 E0 84 A2  1 
1A28720 	3C  0  0  0 

\ Things that change for different pixel depths
termemu-defer pix*
1A28724 	 0  0  0 70 
1A28728 	69 78 2A 84 1C 87 A2  1 
1A28730 	5C 84 A2  1 40  0  0  0 
termemu-defer fb-invert
1A28738 	 0  0 66 62 2D 69 6E 76 
1A28740 	65 72 74 89 30 87 A2  1 
1A28748 	5C 84 A2  1 44  0  0  0 
termemu-defer fb-fill
1A28750 	66 62 2D 66 69 6C 6C 87 
1A28758 	48 87 A2  1 5C 84 A2  1 
1A28760 	48  0  0  0 
termemu-defer fb-paint
1A28764 	 0  0  0 66 
1A28768 	62 2D 70 61 69 6E 74 88 
1A28770 	5C 87 A2  1 5C 84 A2  1 
1A28778 	4C  0  0  0 
termemu-defer fb-16map
1A2877C 	 0  0  0 66 
1A28780 	62 2D 31 36 6D 61 70 88 
1A28788 	74 87 A2  1 5C 84 A2  1 
1A28790 	50  0  0  0 
termemu-defer fb-merge
1A28794 	 0  0  0 66 
1A28798 	62 2D 6D 65 72 67 65 88 
1A287A0 	8C 87 A2  1 5C 84 A2  1 
1A287A8 	54  0  0  0 

termemu-defer draw-character
1A287AC 	 0 64 72 61 
1A287B0 	77 2D 63 68 61 72 61 63 
1A287B8 	74 65 72 8E A4 87 A2  1 
1A287C0 	5C 84 A2  1 58  0  0  0 
termemu-defer insert-characters
1A287C8 	 0  0 69 6E 73 65 72 74 
1A287D0 	2D 63 68 61 72 61 63 74 
1A287D8 	65 72 73 91 C0 87 A2  1 
1A287E0 	5C 84 A2  1 5C  0  0  0 
termemu-defer delete-characters
1A287E8 	 0  0 64 65 6C 65 74 65 
1A287F0 	2D 63 68 61 72 61 63 74 
1A287F8 	65 72 73 91 E0 87 A2  1 
1A28800 	5C 84 A2  1 60  0  0  0 
termemu-defer insert-lines
1A28808 	 0  0  0 69 6E 73 65 72 
1A28810 	74 2D 6C 69 6E 65 73 8C 
1A28818 	 0 88 A2  1 5C 84 A2  1 
1A28820 	64  0  0  0 
termemu-defer delete-lines
1A28824 	 0  0  0 64 
1A28828 	65 6C 65 74 65 2D 6C 69 
1A28830 	6E 65 73 8C 1C 88 A2  1 
1A28838 	5C 84 A2  1 68  0  0  0 
termemu-defer blink-screen
1A28840 	 0  0  0 62 6C 69 6E 6B 
1A28848 	2D 73 63 72 65 65 6E 8C 
1A28850 	38 88 A2  1 5C 84 A2  1 
1A28858 	6C  0  0  0 
termemu-defer invert-screen
1A2885C 	 0  0 69 6E 
1A28860 	76 65 72 74 2D 73 63 72 
1A28868 	65 65 6E 8D 54 88 A2  1 
1A28870 	5C 84 A2  1 70  0  0  0 
termemu-defer reset-screen
1A28878 	 0  0  0 72 65 73 65 74 
1A28880 	2D 73 63 72 65 65 6E 8C 
1A28888 	70 88 A2  1 5C 84 A2  1 
1A28890 	74  0  0  0 
termemu-defer erase-screen
1A28894 	 0  0  0 65 
1A28898 	72 61 73 65 2D 73 63 72 
1A288A0 	65 65 6E 8C 8C 88 A2  1 
1A288A8 	5C 84 A2  1 78  0  0  0 
termemu-defer toggle-cursor
1A288B0 	 0  0 74 6F 67 67 6C 65 
1A288B8 	2D 63 75 72 73 6F 72 8D 
1A288C0 	A8 88 A2  1 5C 84 A2  1 
1A288C8 	7C  0  0  0 

termemu-defer draw-logo
1A288CC 	 0  0 64 72 
1A288D0 	61 77 2D 6C 6F 67 6F 89 
1A288D8 	C4 88 A2  1 5C 84 A2  1 
1A288E0 	80  0  0  0 

\ These values are available to the device-dependent routines.
\ The behavior of the device-dependent routines implicitly depends
\ on their values.

true  termemu-value showing-cursor?	\ True to display text cursor
1A288E4 	73 68 6F 77 
1A288E8 	69 6E 67 2D 63 75 72 73 
1A288F0 	6F 72 3F 8F DC 88 A2  1 
1A288F8 	E0 84 A2  1 84  0  0  0 
false termemu-value inverse-screen?	\ True for overall black background
1A28900 	69 6E 76 65 72 73 65 2D 
1A28908 	73 63 72 65 65 6E 3F 8F 
1A28910 	F8 88 A2  1 E0 84 A2  1 
1A28918 	88  0  0  0 
false termemu-value inverse?		\ True for white characters on black background
1A2891C 	 0  0  0 69 
1A28920 	6E 76 65 72 73 65 3F 88 
1A28928 	14 89 A2  1 E0 84 A2  1 
1A28930 	8C  0  0  0 
headerless
\  true value frame-buffer-busy?	\ If true, drivers must assume that the frame
\  				\ buffer is in use by another program, which
\  				\ may require extra action to ensure the
\  				\ visibility of the displayed text.
\  	\ For example, a frame buffer with an enable plane might require
\  	\ that the enable plane be written to expose the character.
\

termemu-defer ansi-emit
1A28934 	 0  0 61 6E 
1A28938 	73 69 2D 65 6D 69 74 89 
1A28940 	2C 89 A2  1 5C 84 A2  1 
1A28948 	90  0  0  0 
false termemu-value pending-newline?
1A2894C 	 0  0  0 70 
1A28950 	65 6E 64 69 6E 67 2D 6E 
1A28958 	65 77 6C 69 6E 65 3F 90 
1A28960 	44 89 A2  1 E0 84 A2  1 
1A28968 	94  0  0  0 
\ True if the cursor is at the rightmost column but the next character
\ should be displayed on the next line

1 termemu-value #scroll-lines			\ Number of lines to scroll
1A2896C 	 0  0 23 73 
1A28970 	63 72 6F 6C 6C 2D 6C 69 
1A28978 	6E 65 73 8D 64 89 A2  1 
1A28980 	E0 84 A2  1 98  0  0  0 

\ These variables are used to accumulate the optional numeric
\ argument or arguments of the escape sequence.
4 termemu-array arg
1A28988 	61 72 67 83 80 89 A2  1 
1A28990 	54 85 A2  1 9C  0  0  0 
0 termemu-value next-arg
1A28998 	 0  0  0 6E 65 78 74 2D 
1A289A0 	61 72 67 88 90 89 A2  1 
1A289A8 	E0 84 A2  1 AC  0  0  0 
0 termemu-value arginit		\ Remembers the "real" value of argument 0.
1A289B0 	61 72 67 69 6E 69 74 87 
1A289B8 	A8 89 A2  1 E0 84 A2  1 
1A289C0 	B0  0  0  0 
				\ If arg0 is 0, it is changed to 1.

    0 termemu-value foreground-color	\ Color index for foreground
1A289C4 	 0  0  0 66 
1A289C8 	6F 72 65 67 72 6F 75 6E 
1A289D0 	64 2D 63 6F 6C 6F 72 90 
1A289D8 	BC 89 A2  1 E0 84 A2  1 
1A289E0 	B4  0  0  0 
d# 15 termemu-value background-color	\ Color index for background
1A289E4 	 0  0  0 62 
1A289E8 	61 63 6B 67 72 6F 75 6E 
1A289F0 	64 2D 63 6F 6C 6F 72 90 
1A289F8 	DC 89 A2  1 E0 84 A2  1 
1A28A00 	B8  0  0  0 
false termemu-value 16-color?		\ True if 16-color text is enabled
1A28A04 	 0  0 31 36 
1A28A08 	2D 63 6F 6C 6F 72 3F 89 
1A28A10 	FC 89 A2  1 E0 84 A2  1 
1A28A18 	BC  0  0  0 


OpenFirmware/ofw/termemu/framebuf.fth_AL	1000 1A28A1C purpose: FCode interface to default font

decimal
headers
0 termemu-value font-base		\ Base address of font
1A28A1C 	 0  0 66 6F 
1A28A20 	6E 74 2D 62 61 73 65 89 
1A28A28 	14 8A A2  1 E0 84 A2  1 
1A28A30 	C0  0  0  0 

0 termemu-value char-width		\ FCode character width in pixels
1A28A34 	 0 63 68 61 
1A28A38 	72 2D 77 69 64 74 68 8A 
1A28A40 	2C 8A A2  1 E0 84 A2  1 
1A28A48 	C4  0  0  0 
0 termemu-value char-height		\ FCode character height in pixels (scan lines)
1A28A4C 	63 68 61 72 
1A28A50 	2D 68 65 69 67 68 74 8B 
1A28A58 	44 8A A2  1 E0 84 A2  1 
1A28A60 	C8  0  0  0 
0 termemu-value fontbytes		\ FCode distance in bytes from one scan line of
1A28A64 	 0  0 66 6F 
1A28A68 	6E 74 62 79 74 65 73 89 
1A28A70 	5C 8A A2  1 E0 84 A2  1 
1A28A78 	CC  0  0  0 
					\ a glyph to the next
0 termemu-value glyph-bytes		\ distance between glyphs
1A28A7C 	67 6C 79 70 
1A28A80 	68 2D 62 79 74 65 73 8B 
1A28A88 	74 8A A2  1 E0 84 A2  1 
1A28A90 	D0  0  0  0 
headerless
0 termemu-value min-char		\ The lowest character in the font
1A28A94 	 0  0  0 6D 
1A28A98 	69 6E 2D 63 68 61 72 88 
1A28AA0 	8C 8A A2  1 E0 84 A2  1 
1A28AA8 	D4  0  0  0 
0 termemu-value #glyphs			\ The number of glyphs in the font
1A28AAC 	23 67 6C 79 
1A28AB0 	70 68 73 87 A4 8A A2  1 
1A28AB8 	E0 84 A2  1 D8  0  0  0 

headers
defer font
1A28AC0 	 0  0  0 66 6F 6E 74 84 
1A28AC8 	 0  0 A0  1 5C 40 A0  1 
1A28AD0 	74  8  0  0 
' romfont is font

headerless
: decode-font  ( hdr-adr -- bits-adr width height advance min-char #glyphs )
1A28AD4 	64 65 63 6F 
1A28AD8 	64 65 2D 66 6F 6E 74 8B 
1A28AE0 	CC 8A A2  1 20 40 A0  1 
   dup " font" comp 0=  if   ( hdr-adr )   \ OBF font format
1A28AE8 	40 49 A0  1 9C 53 A0  1 
1A28AF0 	 4 66 6F 6E 74  0  0  0 
1A28AF8 	38 52 A0  1 24 47 A0  1 
1A28B00 	DC 41 A0  1 50  0  0  0 
      dup d# 24 +  swap              ( bit-adr hdr-adr )
1A28B08 	40 49 A0  1 58 41 A0  1 
1A28B10 	18  0  0  0  4 45 A0  1 
1A28B18 	68 49 A0  1 
      4 +  d# 20                     ( bit-adr hdr-adr' hdr-len )
1A28B1C 	B0 6F A0  1 
1A28B20 	 4 45 A0  1 58 41 A0  1 
1A28B28 	14  0  0  0 
      5 0 do  decode-int -rot  loop  ( bits-adr width height advance min #gl str )
1A28B2C 	C0 6F A0  1 
1A28B30 	70 6F A0  1 88 42 A0  1 
1A28B38 	14  0  0  0 68 F7 A1  1 
1A28B40 	94 49 A0  1 F8 41 A0  1 
1A28B48 	F4 FF FF FF 
      2drop                  ( bits-adr width height advance min-char #glyphs )
1A28B4C 	AC 49 A0  1 
      exit
1A28B50 	40 46 A0  1 
   then                      ( hdr-adr )

   \ http://www.win.tue.nl/~aeb/linux/kbd/font-formats-1.html
   dup le-l@ h# 864ab572 =  if  ( hdr-adr )   \ PSF2 format, little endian
1A28B54 	40 49 A0  1 
1A28B58 	4C 4C A0  1 58 41 A0  1 
1A28B60 	72 B5 4A 86 24 48 A0  1 
1A28B68 	DC 41 A0  1 84  0  0  0 
      >r                        ( r: hdr-adr )
1A28B70 	BC 45 A0  1 
      r@  r@ 8 + le-l@ +        ( bits-adr r: hdr-adr )
1A28B74 	E4 45 A0  1 
1A28B78 	E4 45 A0  1 F0 6F A0  1 
1A28B80 	 4 45 A0  1 4C 4C A0  1 
1A28B88 	 4 45 A0  1 
      r@ h# 1c + le-l@          ( bits-adr width r: hdr-adr )
1A28B8C 	E4 45 A0  1 
1A28B90 	58 41 A0  1 1C  0  0  0 
1A28B98 	 4 45 A0  1 4C 4C A0  1 
      r@ h# 18 + le-l@ negate   ( bits-adr width height r: hdr-adr )
1A28BA0 	E4 45 A0  1 58 41 A0  1 
1A28BA8 	18  0  0  0  4 45 A0  1 
1A28BB0 	4C 4C A0  1 48 45 A0  1 
      over 7 + 8 /              ( bits-adr width height advance r: hdr-adr )
1A28BB8 	54 49 A0  1 E0 6F A0  1 
1A28BC0 	 4 45 A0  1 F0 6F A0  1 
1A28BC8 	98 5F A0  1 
      0                         ( bits-adr width height advance min r: hdr-adr )
1A28BCC 	70 6F A0  1 
      r@ h# 10 + le-l@          ( bits-adr width height advance #glyphs r: hdr-adr )
1A28BD0 	E4 45 A0  1 58 41 A0  1 
1A28BD8 	10  0  0  0  4 45 A0  1 
1A28BE0 	4C 4C A0  1 
      r> drop                   ( bits-adr width height advance #glyphs )
1A28BE4 	D0 45 A0  1 
1A28BE8 	30 49 A0  1 
      exit
1A28BEC 	40 46 A0  1 
   then                         ( hdr-adr )

   true abort" Not a font"
1A28BF0 	 4 70 A0  1  8 81 A0  1 
1A28BF8 	 A 4E 6F 74 20 61 20 66 
1A28C00 	6F 6E 74  0 
;
1A28C04 	58 46 A0  1 
headers
also forth definitions
\ There are no glyphs for control characters, so the font bitmaps actually
\ begin with the glyph for the space (blank) character.

\ The 1- after char-height is due to the way that the PROM stores character
\ bitmaps.  Since the top and bottom scan lines of the character are both 0,
\ only  char-height 1-  scan-lines are actually stored, and the bottom zero
\ scan line of a glyph is overlapped with the top zero scan line of the
\ next glyph.  This is probably a bad idea in the long run.

: >font  ( char -- adr )					\ FCode
1A28C08 	 0  0 3E 66 6F 6E 74 85 
1A28C10 	B8 8A A2  1 20 40 A0  1 
   min-char -  0 max  #glyphs min   ( char# )	\ Clip the glyph number
1A28C18 	A4 8A A2  1 18 45 A0  1 
1A28C20 	70 6F A0  1 9C 4A A0  1 
1A28C28 	B8 8A A2  1 74 4A A0  1 
   glyph-bytes * font-base +
1A28C30 	8C 8A A2  1 1C 5F A0  1 
1A28C38 	2C 8A A2  1  4 45 A0  1 
;
1A28C40 	58 46 A0  1 

headerless
: character-set ( -- )
1A28C44 	 0  0 63 68 
1A28C48 	61 72 61 63 74 65 72 2D 
1A28C50 	73 65 74 8D 14 8C A2  1 
1A28C58 	20 40 A0  1 
   " character-set"  2dup get-my-property  if  ( adr,len )
1A28C5C 	9C 53 A0  1 
1A28C60 	 D 63 68 61 72 61 63 74 
1A28C68 	65 72 2D 73 65 74  0  0 
1A28C70 	C0 49 A0  1 1C 34 A2  1 
1A28C78 	DC 41 A0  1 28  0  0  0 
      " ISO8859-1" encode-string 2swap  property   (  )
1A28C80 	9C 53 A0  1  9 49 53 4F 
1A28C88 	38 38 35 39 2D 31  0  0 
1A28C90 	A0 F6 A1  1 F4 49 A0  1 
1A28C98 	BC 14 A2  1 
   else                                         ( adr,len adr,len' )
1A28C9C 	C8 41 A0  1 
1A28CA0 	 C  0  0  0 
      2drop 2drop                               (  )
1A28CA4 	AC 49 A0  1 
1A28CA8 	AC 49 A0  1 
   then                                         (  )
;
1A28CAC 	58 46 A0  1 
headers
: default-font  ( -- adr width height advance min-char #glyphs ) \ FCode
1A28CB0 	 0  0  0 64 65 66 61 75 
1A28CB8 	6C 74 2D 66 6F 6E 74 8C 
1A28CC0 	58 8C A2  1 20 40 A0  1 
   character-set  font decode-font
1A28CC8 	58 8C A2  1 CC 8A A2  1 
1A28CD0 	E4 8A A2  1 
;
1A28CD4 	58 46 A0  1 

: set-font  ( adr width +-height advance min-char #glyphs -- )	\ FCode
1A28CD8 	 0  0  0 73 65 74 2D 66 
1A28CE0 	6F 6E 74 88 C4 8C A2  1 
1A28CE8 	20 40 A0  1 
   is #glyphs  is min-char
1A28CEC 	48 B8 A1  1 
1A28CF0 	B8 8A A2  1 48 B8 A1  1 
1A28CF8 	A4 8A A2  1 
   is fontbytes
1A28CFC 	48 B8 A1  1 
1A28D00 	74 8A A2  1 
   dup >r abs is char-height  is char-width  ( r: +-height )
1A28D04 	40 49 A0  1 
1A28D08 	BC 45 A0  1 24 4A A0  1 
1A28D10 	48 B8 A1  1 5C 8A A2  1 
1A28D18 	48 B8 A1  1 44 8A A2  1 
   is font-base
1A28D20 	48 B8 A1  1 2C 8A A2  1 

   \ If +-height is positive, then we use the original packed font
   \ storage format in which the last scan line of one glyph overlaps
   \ the first scan line of the next.  If +-height is negative, we
   \ use an unpacked format in which each glyph is self-contained.
   r>  dup 0>  if  1-  else  negate  then  fontbytes *  to glyph-bytes
1A28D28 	D0 45 A0  1 40 49 A0  1 
1A28D30 	A4 47 A0  1 DC 41 A0  1 
1A28D38 	10  0  0  0 54 4B A0  1 
1A28D40 	C8 41 A0  1  8  0  0  0 
1A28D48 	48 45 A0  1 74 8A A2  1 
1A28D50 	1C 5F A0  1 48 B8 A1  1 
1A28D58 	8C 8A A2  1 
;
1A28D5C 	58 46 A0  1 
previous definitions

OpenFirmware/ofw/termemu/font.fth_AL	836 1A28D60 purpose: ANSI X3.64 terminal emulator (escape sequence parser)

\ ANSI 3.64 Terminal Emulator.
decimal
headerless
\ ansi-emit is the routine which handles the current character.
\ It is deferred because the terminal emulator can be in one of several
\ states, depending on the previous characters.  For each distinct state,
\ a different routine is installed as the action performed by ansi-emit.
\ The states are:
\
\   alpha-state		This is the "normal" state.  Printable characters
\			are displayed, control characters are interpreted,
\			and the ESCAPE character switches to escape-state .
\
\   escape-state 	In this state, an ESCAPE has been seen and we
\			are expecting a "[" character to switch us to
\			escbrkt-state.  In escape-state, a few control
\			characters are recognized, and apart from that,
\			any non-"[" character switches to alpha-state .
\
\   escbrkt-state	An ESCAPE [  pair has been seen.  We collect numeric
\			arguments until an alphabetic command character
\			is received, then we execute the command and switch
\			to alpha-state .  Command characters are those
\			with ASCII codes numerically greater than or equal
\			to the ASCII code for the "@" character.
\
\   skipping-state	Entered from escbrkt-state if an invalid character
\			is received while waiting for a command character.
\			In skipping state, all non-command characters are
\			ignored, and the next command character switches
\			to alpha-state .

: ring-bell  ( -- )
1A28D60 	 0  0 72 69 6E 67 2D 62 
1A28D68 	65 6C 6C 89 E4 8A A2  1 
1A28D70 	20 40 A0  1 
   " ring-bell" stdin @  ['] $call-method catch  if
1A28D74 	9C 53 A0  1 
1A28D78 	 9 72 69 6E 67 2D 62 65 
1A28D80 	6C 6C  0  0 54 55 A2  1 
1A28D88 	5C 4C A0  1 60 53 A0  1 
1A28D90 	B4 31 A2  1 14 7F A0  1 
1A28D98 	DC 41 A0  1  C  0  0  0 
      3drop blink-screen
1A28DA0 	90 52 A0  1 54 88 A2  1 
   then
;
1A28DA8 	58 46 A0  1 

\ set-line is also used by fb1-draw-logo
\ which is defined outside the termemu package
also forth definitions
: set-line  ( line -- )
1A28DAC 	 0  0  0 73 
1A28DB0 	65 74 2D 6C 69 6E 65 88 
1A28DB8 	E8 8C A2  1 20 40 A0  1 
   0 max  #lines    1- min  is line#    \ ['] line#    >body >user !
1A28DC0 	70 6F A0  1 9C 4A A0  1 
1A28DC8 	 4 87 A2  1 54 4B A0  1 
1A28DD0 	74 4A A0  1 48 B8 A1  1 
1A28DD8 	54 86 A2  1 
;
1A28DDC 	58 46 A0  1 
previous definitions

: set-column  ( column# -- )
1A28DE0 	 0 73 65 74 2D 63 6F 6C 
1A28DE8 	75 6D 6E 8A 70 8D A2  1 
1A28DF0 	20 40 A0  1 
   0 max  #columns  1- min  is column#  \ ['] column#  >body >user !
1A28DF4 	70 6F A0  1 
1A28DF8 	9C 4A A0  1 1C 87 A2  1 
1A28E00 	54 4B A0  1 74 4A A0  1 
1A28E08 	48 B8 A1  1 40 86 A2  1 
;
1A28E10 	58 46 A0  1 
: +column  ( delta-columns -- )  column# +   set-column  ;
1A28E14 	2B 63 6F 6C 
1A28E18 	75 6D 6E 87 F0 8D A2  1 
1A28E20 	20 40 A0  1 40 86 A2  1 
1A28E28 	 4 45 A0  1 F0 8D A2  1 
1A28E30 	58 46 A0  1 
: +line  ( delta-lines -- )  line# +  set-line  ;
1A28E34 	 0  0 2B 6C 
1A28E38 	69 6E 65 85 20 8E A2  1 
1A28E40 	20 40 A0  1 54 86 A2  1 
1A28E48 	 4 45 A0  1 BC 8D A2  1 
1A28E50 	58 46 A0  1 

: /string  ( adr len n -- adr+n len-n )  over min  rot over + -rot -  ;
1A28E54 	2F 73 74 72 
1A28E58 	69 6E 67 87 40 8E A2  1 
1A28E60 	20 40 A0  1 54 49 A0  1 
1A28E68 	74 4A A0  1 7C 49 A0  1 
1A28E70 	54 49 A0  1  4 45 A0  1 
1A28E78 	94 49 A0  1 18 45 A0  1 
1A28E80 	58 46 A0  1 

\ #newlines counts the number of newlines up to the end of the
\ string to be printed, or up to the next escape or form feed.
\ This is used to "batch" scrolls.
: #newlines  ( adr len -- adr len #newlines )
1A28E84 	 0  0 23 6E 
1A28E88 	65 77 6C 69 6E 65 73 89 
1A28E90 	60 8E A2  1 20 40 A0  1 
   2dup 1 -rot                          ( adr len 1 adr len )
1A28E98 	C0 49 A0  1 80 6F A0  1 
1A28EA0 	94 49 A0  1 
   1 /string   bounds  ?do              ( adr len #newlines-so-far )
1A28EA4 	80 6F A0  1 
1A28EA8 	60 8E A2  1 F0 6D A0  1 
1A28EB0 	50 42 A0  1 84  0  0  0 
      i c@  bl <  if                    ( adr len #newlines-so-far )
1A28EB8 	B4 42 A0  1 C4 4C A0  1 
1A28EC0 	28 70 A0  1 E4 47 A0  1 
1A28EC8 	DC 41 A0  1 64  0  0  0 
         i c@  case
1A28ED0 	B4 42 A0  1 C4 4C A0  1 
	    control J  of 1+     endof  \ Count linefeeds
1A28ED8 	58 41 A0  1  A  0  0  0 
1A28EE0 	48 43 A0  1 10  0  0  0 
1A28EE8 	30 4B A0  1 6C 43 A0  1 
1A28EF0 	40  0  0  0 
	    control [  of leave  endof  \ Bail out on escapes
1A28EF4 	58 41 A0  1 
1A28EF8 	1B  0  0  0 48 43 A0  1 
1A28F00 	10  0  0  0 18 43 A0  1 
1A28F08 	6C 43 A0  1 24  0  0  0 
	    control L  of leave  endof  \ Bail out on formfeeds
1A28F10 	58 41 A0  1  C  0  0  0 
1A28F18 	48 43 A0  1 10  0  0  0 
1A28F20 	18 43 A0  1 6C 43 A0  1 
1A28F28 	 8  0  0  0 
         endcase
1A28F2C 	84 43 A0  1 
      then
   loop   ( adr len #newlines )
1A28F30 	F8 41 A0  1 84 FF FF FF 
;
1A28F38 	58 46 A0  1 

: kill-1line  ( -- )  #columns column# -  delete-characters  ;
1A28F3C 	 0 6B 69 6C 
1A28F40 	6C 2D 31 6C 69 6E 65 8A 
1A28F48 	94 8E A2  1 20 40 A0  1 
1A28F50 	1C 87 A2  1 40 86 A2  1 
1A28F58 	18 45 A0  1  0 88 A2  1 
1A28F60 	58 46 A0  1 

: kill-line  ( -- )
1A28F64 	 0  0 6B 69 
1A28F68 	6C 6C 2D 6C 69 6E 65 89 
1A28F70 	4C 8F A2  1 20 40 A0  1 
   column#
1A28F78 	40 86 A2  1 
   arginit  case
1A28F7C 	BC 89 A2  1 
      1  of		\ Erase from beginning of line to cursor
1A28F80 	80 6F A0  1 48 43 A0  1 
1A28F88 	24  0  0  0 
         0 set-column  dup delete-characters dup insert-characters
1A28F8C 	70 6F A0  1 
1A28F90 	F0 8D A2  1 40 49 A0  1 
1A28F98 	 0 88 A2  1 40 49 A0  1 
1A28FA0 	E0 87 A2  1 
      endof
1A28FA4 	6C 43 A0  1 
1A28FA8 	30  0  0  0 
      2  of		\ Erase entire line
1A28FAC 	90 6F A0  1 
1A28FB0 	48 43 A0  1 1C  0  0  0 
         0 set-column  #columns delete-characters
1A28FB8 	70 6F A0  1 F0 8D A2  1 
1A28FC0 	1C 87 A2  1  0 88 A2  1 
      endof
1A28FC8 	6C 43 A0  1  C  0  0  0 
      ( default, and 0 case )  kill-1line   \ Erase from cursor to end of line
1A28FD0 	4C 8F A2  1 
   endcase
1A28FD4 	84 43 A0  1 
   set-column
1A28FD8 	F0 8D A2  1 
;
1A28FDC 	58 46 A0  1 

: do-newline  ( adr len -- adr len )
1A28FE0 	 0 64 6F 2D 6E 65 77 6C 
1A28FE8 	69 6E 65 8A 74 8F A2  1 
1A28FF0 	20 40 A0  1 
   line#  #lines 1-  <  if
1A28FF4 	54 86 A2  1 
1A28FF8 	 4 87 A2  1 54 4B A0  1 
1A29000 	E4 47 A0  1 DC 41 A0  1 
1A29008 	2C  0  0  0 

      \ We're not at the bottom of the screen, so we don't need to scroll
      line# 1+ set-line  ( adr len )
1A2900C 	54 86 A2  1 
1A29010 	30 4B A0  1 BC 8D A2  1 

      \ Clear next line unless we're in wrap mode
      #scroll-lines 0=  if   kill-1line   then
1A29018 	80 89 A2  1 24 47 A0  1 
1A29020 	DC 41 A0  1  8  0  0  0 
1A29028 	4C 8F A2  1 

   else  \ We're at the bottom of the screen, so we have to scroll
1A2902C 	C8 41 A0  1 
1A29030 	54  0  0  0 

      \ In wrap mode, we just go to the top of the screen
      #scroll-lines 0=  if  0 set-line  kill-1line  exit  then
1A29034 	80 89 A2  1 
1A29038 	24 47 A0  1 DC 41 A0  1 
1A29040 	14  0  0  0 70 6F A0  1 
1A29048 	BC 8D A2  1 4C 8F A2  1 
1A29050 	40 46 A0  1 

      \ In single-line scroll mode, we try to optimize out multiple scrolls
\        #scroll-lines  1 =  if               ( adr len )
\           #newlines                         ( adr len #newlines )
\        else
\           #scroll-lines                     ( adr len #scroll-lines )
\        then

      #scroll-lines                        ( adr len #scroll-lines )
1A29054 	80 89 A2  1 

      #lines min                           ( adr len #lines-to-scroll )
1A29058 	 4 87 A2  1 74 4A A0  1 
      line#                                ( adr len #lines line# )
1A29060 	54 86 A2  1 
      0 set-line   swap dup delete-lines   ( adr len line# #lines-to-scroll )
1A29064 	70 6F A0  1 
1A29068 	BC 8D A2  1 68 49 A0  1 
1A29070 	40 49 A0  1 38 88 A2  1 
      - 1+  set-line                       ( adr len )
1A29078 	18 45 A0  1 30 4B A0  1 
1A29080 	BC 8D A2  1 
   then
;
1A29084 	58 46 A0  1 

\ Moves the cursor to the position indicated by arg0 and arg1
: move-cursor  ( -- )
1A29088 	6D 6F 76 65 2D 63 75 72 
1A29090 	73 6F 72 8B F0 8F A2  1 
1A29098 	20 40 A0  1 
   next-arg 0=  if  0  else  1 arg 1-  then  0 arg 1-
1A2909C 	A8 89 A2  1 
1A290A0 	24 47 A0  1 DC 41 A0  1 
1A290A8 	10  0  0  0 70 6F A0  1 
1A290B0 	C8 41 A0  1 10  0  0  0 
1A290B8 	80 6F A0  1 90 89 A2  1 
1A290C0 	54 4B A0  1 70 6F A0  1 
1A290C8 	90 89 A2  1 54 4B A0  1 
   set-line set-column
1A290D0 	BC 8D A2  1 F0 8D A2  1 
;
1A290D8 	58 46 A0  1 
: kill-screen  ( -- )
1A290DC 	6B 69 6C 6C 
1A290E0 	2D 73 63 72 65 65 6E 8B 
1A290E8 	98 90 A2  1 20 40 A0  1 
   line# column#       ( line# column# )
1A290F0 	54 86 A2  1 40 86 A2  1 
   arginit case
1A290F8 	BC 89 A2  1 
      1 of		\ Erase from beginning of screen to cursor
1A290FC 	80 6F A0  1 
1A29100 	48 43 A0  1 40  0  0  0 
         0 set-column  dup delete-characters  dup insert-characters
1A29108 	70 6F A0  1 F0 8D A2  1 
1A29110 	40 49 A0  1  0 88 A2  1 
1A29118 	40 49 A0  1 E0 87 A2  1 
         0 set-line    over delete-lines  over insert-lines
1A29120 	70 6F A0  1 BC 8D A2  1 
1A29128 	54 49 A0  1 38 88 A2  1 
1A29130 	54 49 A0  1 1C 88 A2  1 
         dup
1A29138 	40 49 A0  1 
      endof
1A2913C 	6C 43 A0  1 
1A29140 	50  0  0  0 

      2 of		\ Erase entire screen
1A29144 	90 6F A0  1 
1A29148 	48 43 A0  1 24  0  0  0 
         0 set-line  0 set-column
1A29150 	70 6F A0  1 BC 8D A2  1 
1A29158 	70 6F A0  1 F0 8D A2  1 
         #lines delete-lines
1A29160 	 4 87 A2  1 38 88 A2  1 
      endof
1A29168 	6C 43 A0  1 24  0  0  0 

      ( default, also explicitly the "0" case )
      kill-1line	\ Erase from cursor to end of screen
1A29170 	4C 8F A2  1 
      1 +line  #lines  line# -  delete-lines
1A29174 	80 6F A0  1 
1A29178 	40 8E A2  1  4 87 A2  1 
1A29180 	54 86 A2  1 18 45 A0  1 
1A29188 	38 88 A2  1 
   endcase
1A2918C 	84 43 A0  1 
   set-column set-line
1A29190 	F0 8D A2  1 BC 8D A2  1 
;
1A29198 	58 46 A0  1 
: form-feed  ( -- )  0 set-line 0 set-column  erase-screen  ;
1A2919C 	 0  0 66 6F 
1A291A0 	72 6D 2D 66 65 65 64 89 
1A291A8 	EC 90 A2  1 20 40 A0  1 
1A291B0 	70 6F A0  1 BC 8D A2  1 
1A291B8 	70 6F A0  1 F0 8D A2  1 
1A291C0 	A8 88 A2  1 58 46 A0  1 

headers
 true value ansi-terminal?
1A291C8 	 0 61 6E 73 69 2D 74 65 
1A291D0 	72 6D 69 6E 61 6C 3F 8E 
1A291D8 	AC 91 A2  1 50 40 A0  1 
1A291E0 	78  8  0  0 
headerless

\   alpha-state		This is the "normal" state.  Printable characters
\			are displayed, control characters are interpreted,
\			and the ESCAPE character switches to escape-state .
\
: alpha-emit  ( adr len char -- adr len )
1A291E4 	 0 61 6C 70 
1A291E8 	68 61 2D 65 6D 69 74 8A 
1A291F0 	DC 91 A2  1 20 40 A0  1 
[ifdef] nt-support
\ In order to support NT's screen-oriented installation stuff, we have
\ to suppress scrolling when the last line of the screen is exactly filled,
\ but no additional characters are output.
   pending-newline?  if
      false to pending-newline?  0 set-column  >r do-newline r>
   then
   draw-character
   column# #columns 1- u<  if  1 +column  else  true to pending-newline?  then
[else]
\ However, the above behavior doesn't work right with vi.
   draw-character
1A291F8 	C0 87 A2  1 
   column# #columns 1- u<  if  1 +column  else  0 set-column   do-newline then
1A291FC 	40 86 A2  1 
1A29200 	1C 87 A2  1 54 4B A0  1 
1A29208 	A8 48 A0  1 DC 41 A0  1 
1A29210 	14  0  0  0 80 6F A0  1 
1A29218 	20 8E A2  1 C8 41 A0  1 
1A29220 	10  0  0  0 70 6F A0  1 
1A29228 	F0 8D A2  1 F0 8F A2  1 
[then]
;
1A29230 	58 46 A0  1 

: alpha-state  ( adr len char -- adr len )
1A29234 	61 6C 70 68 
1A29238 	61 2D 73 74 61 74 65 8B 
1A29240 	F4 91 A2  1 20 40 A0  1 
   dup h# 7f and bl >=  if		\ Printable character
1A29248 	40 49 A0  1 58 41 A0  1 
1A29250 	7F  0  0  0 5C 44 A0  1 
1A29258 	28 70 A0  1 EC 48 A0  1 
1A29260 	DC 41 A0  1 10  0  0  0 
      alpha-emit  ( adr len )
1A29268 	F4 91 A2  1 
   else					\ Control character
1A2926C 	C8 41 A0  1 
1A29270 	A8  1  0  0 
      false to pending-newline?
1A29274 	18 70 A0  1 
1A29278 	48 B8 A1  1 64 89 A2  1 
      case
         control G of  ring-bell                                endof
1A29280 	58 41 A0  1  7  0  0  0 
1A29288 	48 43 A0  1 10  0  0  0 
1A29290 	70 8D A2  1 6C 43 A0  1 
1A29298 	80  1  0  0 
         control H of  -1 +column                               endof
1A2929C 	58 41 A0  1 
1A292A0 	 8  0  0  0 48 43 A0  1 
1A292A8 	18  0  0  0 58 41 A0  1 
1A292B0 	FF FF FF FF 20 8E A2  1 
1A292B8 	6C 43 A0  1 5C  1  0  0 
         control I of  column# -8 and 8 +  set-column           endof
1A292C0 	58 41 A0  1  9  0  0  0 
1A292C8 	48 43 A0  1 28  0  0  0 
1A292D0 	40 86 A2  1 58 41 A0  1 
1A292D8 	F8 FF FF FF 5C 44 A0  1 
1A292E0 	F0 6F A0  1  4 45 A0  1 
1A292E8 	F0 8D A2  1 6C 43 A0  1 
1A292F0 	28  1  0  0 
         control J of  ( adr len )  do-newline  ( adr len )     endof
1A292F4 	58 41 A0  1 
1A292F8 	 A  0  0  0 48 43 A0  1 
1A29300 	10  0  0  0 F0 8F A2  1 
1A29308 	6C 43 A0  1  C  1  0  0 
         control M of  0 set-column                             endof
1A29310 	58 41 A0  1  D  0  0  0 
1A29318 	48 43 A0  1 14  0  0  0 
1A29320 	70 6F A0  1 F0 8D A2  1 
1A29328 	6C 43 A0  1 EC  0  0  0 
         control [ of  ansi-terminal?  if
1A29330 	58 41 A0  1 1B  0  0  0 
1A29338 	48 43 A0  1 48  0  0  0 
1A29340 	DC 91 A2  1 DC 41 A0  1 
1A29348 	1C  0  0  0 
			  ['] escape-state is ansi-emit
1A2934C 	60 53 A0  1 
1A29350 	EC 83 A2  1 48 B8 A1  1 
1A29358 	44 89 A2  1 
		       else
1A2935C 	C8 41 A0  1 
1A29360 	1C  0  0  0 
			  ascii ^ alpha-emit  ascii [ alpha-emit
1A29364 	58 41 A0  1 
1A29368 	5E  0  0  0 F4 91 A2  1 
1A29370 	58 41 A0  1 5B  0  0  0 
1A29378 	F4 91 A2  1 
		       then					endof
1A2937C 	6C 43 A0  1 
1A29380 	98  0  0  0 
         h# 9b     of  ansi-terminal?  if
1A29384 	58 41 A0  1 
1A29388 	9B  0  0  0 48 43 A0  1 
1A29390 	44  0  0  0 DC 91 A2  1 
1A29398 	DC 41 A0  1 18  0  0  0 
			  ascii [ escape-state
1A293A0 	58 41 A0  1 5B  0  0  0 
1A293A8 	EC 83 A2  1 
		       else
1A293AC 	C8 41 A0  1 
1A293B0 	1C  0  0  0 
			  ascii ^ alpha-emit  ascii [ alpha-emit
1A293B4 	58 41 A0  1 
1A293B8 	5E  0  0  0 F4 91 A2  1 
1A293C0 	58 41 A0  1 5B  0  0  0 
1A293C8 	F4 91 A2  1 
		       then					endof
1A293CC 	6C 43 A0  1 
1A293D0 	48  0  0  0 
         \ ARC wants FF (^L) to be handled like linefeed
         control L of  form-feed                                endof
1A293D4 	58 41 A0  1 
1A293D8 	 C  0  0  0 48 43 A0  1 
1A293E0 	10  0  0  0 AC 91 A2  1 
1A293E8 	6C 43 A0  1 2C  0  0  0 
         \ ARC wants VT (^K) to be handled like linefeed
         control K of  -1 +line                                 endof
1A293F0 	58 41 A0  1  B  0  0  0 
1A293F8 	48 43 A0  1 18  0  0  0 
1A29400 	58 41 A0  1 FF FF FF FF 
1A29408 	40 8E A2  1 6C 43 A0  1 
1A29410 	 8  0  0  0 
      endcase
1A29414 	84 43 A0  1 
   then
;
1A29418 	58 46 A0  1 
: enter-alpha-state  ( -- )  ['] alpha-state is ansi-emit  ;
1A2941C 	 0  0 65 6E 
1A29420 	74 65 72 2D 61 6C 70 68 
1A29428 	61 2D 73 74 61 74 65 91 
1A29430 	44 92 A2  1 20 40 A0  1 
1A29438 	60 53 A0  1 44 92 A2  1 
1A29440 	48 B8 A1  1 44 89 A2  1 
1A29448 	58 46 A0  1 
: reset-modes  ( -- )
1A2944C 	72 65 73 65 
1A29450 	74 2D 6D 6F 64 65 73 8B 
1A29458 	34 94 A2  1 20 40 A0  1 
   1 is #scroll-lines
1A29460 	80 6F A0  1 48 B8 A1  1 
1A29468 	80 89 A2  1 
   enter-alpha-state
1A2946C 	34 94 A2  1 
;
1A29470 	58 46 A0  1 
headers
also forth definitions
\ XXX we should probably do this with an escape sequence. Does ANSI define one?
: hide-text-cursor  ( -- )  false to showing-cursor?  toggle-cursor  ;
1A29474 	 0  0  0 68 
1A29478 	69 64 65 2D 74 65 78 74 
1A29480 	2D 63 75 72 73 6F 72 90 
1A29488 	BC 8D A2  1 20 40 A0  1 
1A29490 	18 70 A0  1 48 B8 A1  1 
1A29498 	F8 88 A2  1 C4 88 A2  1 
1A294A0 	58 46 A0  1 
: reveal-text-cursor  ( -- )  true to showing-cursor?  toggle-cursor  ;
1A294A4 	 0 72 65 76 
1A294A8 	65 61 6C 2D 74 65 78 74 
1A294B0 	2D 63 75 72 73 6F 72 92 
1A294B8 	8C 94 A2  1 20 40 A0  1 
1A294C0 	 4 70 A0  1 48 B8 A1  1 
1A294C8 	F8 88 A2  1 C4 88 A2  1 
1A294D0 	58 46 A0  1 
: reset-emulator  ( -- )  0 set-line  reset-modes  ;
1A294D4 	 0 72 65 73 
1A294D8 	65 74 2D 65 6D 75 6C 61 
1A294E0 	74 6F 72 8E BC 94 A2  1 
1A294E8 	20 40 A0  1 70 6F A0  1 
1A294F0 	BC 8D A2  1 5C 94 A2  1 
1A294F8 	58 46 A0  1 
previous definitions

headerless

: bold  ( -- mask )  foreground-color 8 and  ;
1A294FC 	 0  0  0 62 
1A29500 	6F 6C 64 84 5C 94 A2  1 
1A29508 	20 40 A0  1 DC 89 A2  1 
1A29510 	F0 6F A0  1 5C 44 A0  1 
1A29518 	58 46 A0  1 
: bold-on  ( -- )
1A2951C 	62 6F 6C 64 
1A29520 	2D 6F 6E 87  8 95 A2  1 
1A29528 	20 40 A0  1 
   foreground-color 8 or  to foreground-color
1A2952C 	DC 89 A2  1 
1A29530 	F0 6F A0  1 70 44 A0  1 
1A29538 	48 B8 A1  1 DC 89 A2  1 
;
1A29540 	58 46 A0  1 
: bold-off  ( -- )
1A29544 	 0  0  0 62 
1A29548 	6F 6C 64 2D 6F 66 66 88 
1A29550 	28 95 A2  1 20 40 A0  1 
   foreground-color 8 invert and  to foreground-color
1A29558 	DC 89 A2  1 F0 6F A0  1 
1A29560 	30 45 A0  1 5C 44 A0  1 
1A29568 	48 B8 A1  1 DC 89 A2  1 
;
1A29570 	58 46 A0  1 
: default-attributes  ( -- )  false to inverse?  0 to foreground-color  ;
1A29574 	 0 64 65 66 
1A29578 	61 75 6C 74 2D 61 74 74 
1A29580 	72 69 62 75 74 65 73 92 
1A29588 	54 95 A2  1 20 40 A0  1 
1A29590 	18 70 A0  1 48 B8 A1  1 
1A29598 	2C 89 A2  1 70 6F A0  1 
1A295A0 	48 B8 A1  1 DC 89 A2  1 
1A295A8 	58 46 A0  1 
: >color#  ( ansi-color-code -- palette# )
1A295AC 	3E 63 6F 6C 
1A295B0 	6F 72 23 87 8C 95 A2  1 
1A295B8 	20 40 A0  1 
   10 mod  " "(00 04 02 06 01 05 03 07)" drop + c@
1A295BC 	58 41 A0  1 
1A295C0 	 A  0  0  0 B0 5F A0  1 
1A295C8 	9C 53 A0  1  8  0  4  2 
1A295D0 	 6  1  5  3  7  0  0  0 
1A295D8 	30 49 A0  1  4 45 A0  1 
1A295E0 	C4 4C A0  1 
;
1A295E4 	58 46 A0  1 
: do-color  ( param -- )
1A295E8 	 0  0  0 64 6F 2D 63 6F 
1A295F0 	6C 6F 72 88 B8 95 A2  1 
1A295F8 	20 40 A0  1 
   case
       0  of  default-attributes   endof
1A295FC 	70 6F A0  1 
1A29600 	48 43 A0  1 10  0  0  0 
1A29608 	8C 95 A2  1 6C 43 A0  1 
1A29610 	EC  0  0  0 
       1  of  bold-on              endof
1A29614 	80 6F A0  1 
1A29618 	48 43 A0  1 10  0  0  0 
1A29620 	28 95 A2  1 6C 43 A0  1 
1A29628 	D4  0  0  0 
       2  of  bold-off             endof
1A2962C 	90 6F A0  1 
1A29630 	48 43 A0  1 10  0  0  0 
1A29638 	54 95 A2  1 6C 43 A0  1 
1A29640 	BC  0  0  0 
       7  of  true  to inverse?    endof
1A29644 	E0 6F A0  1 
1A29648 	48 43 A0  1 18  0  0  0 
1A29650 	 4 70 A0  1 48 B8 A1  1 
1A29658 	2C 89 A2  1 6C 43 A0  1 
1A29660 	9C  0  0  0 
   d# 27  of  false to inverse?    endof
1A29664 	58 41 A0  1 
1A29668 	1B  0  0  0 48 43 A0  1 
1A29670 	18  0  0  0 18 70 A0  1 
1A29678 	48 B8 A1  1 2C 89 A2  1 
1A29680 	6C 43 A0  1 78  0  0  0 
   ( default )
      dup d# 30 d# 37 between  if
1A29688 	40 49 A0  1 58 41 A0  1 
1A29690 	1E  0  0  0 58 41 A0  1 
1A29698 	25  0  0  0 D8 70 A0  1 
1A296A0 	DC 41 A0  1 24  0  0  0 
         dup >color#  bold or  to foreground-color
1A296A8 	40 49 A0  1 B8 95 A2  1 
1A296B0 	 8 95 A2  1 70 44 A0  1 
1A296B8 	48 B8 A1  1 DC 89 A2  1 
      else
1A296C0 	C8 41 A0  1 34  0  0  0 
         dup d# 40 d# 47 between  if
1A296C8 	40 49 A0  1 58 41 A0  1 
1A296D0 	28  0  0  0 58 41 A0  1 
1A296D8 	2F  0  0  0 D8 70 A0  1 
1A296E0 	DC 41 A0  1 14  0  0  0 
            dup >color# to background-color	\ Only embolden foreground.
1A296E8 	40 49 A0  1 B8 95 A2  1 
1A296F0 	48 B8 A1  1 FC 89 A2  1 
         then
      then
   endcase
1A296F8 	84 43 A0  1 
;
1A296FC 	58 46 A0  1 
0 value no-args?
1A29700 	 0  0  0 6E 6F 2D 61 72 
1A29708 	67 73 3F 88 F8 95 A2  1 
1A29710 	50 40 A0  1 7C  8  0  0 
: set-colors  ( -- )
1A29718 	 0 73 65 74 2D 63 6F 6C 
1A29720 	6F 72 73 8A 10 97 A2  1 
1A29728 	20 40 A0  1 
   16-color?  if
1A2972C 	14 8A A2  1 
1A29730 	DC 41 A0  1 34  0  0  0 
      next-arg 1+  0  do  i arg do-color  loop
1A29738 	A8 89 A2  1 30 4B A0  1 
1A29740 	70 6F A0  1 88 42 A0  1 
1A29748 	18  0  0  0 B4 42 A0  1 
1A29750 	90 89 A2  1 F8 95 A2  1 
1A29758 	F8 41 A0  1 F0 FF FF FF 
   else
1A29760 	C8 41 A0  1 1C  0  0  0 
      inverse-screen?  arginit 0<>  xor  is inverse?
1A29768 	14 89 A2  1 BC 89 A2  1 
1A29770 	44 47 A0  1 84 44 A0  1 
1A29778 	48 B8 A1  1 2C 89 A2  1 
   then
;
1A29780 	58 46 A0  1 
: handle-modes  ( flag -- )
1A29784 	 0  0  0 68 
1A29788 	61 6E 64 6C 65 2D 6D 6F 
1A29790 	64 65 73 8C 28 97 A2  1 
1A29798 	20 40 A0  1 
   next-arg 1+  0  do
1A2979C 	A8 89 A2  1 
1A297A0 	30 4B A0  1 70 6F A0  1 
1A297A8 	88 42 A0  1 3C  0  0  0 
      i arg  case
1A297B0 	B4 42 A0  1 90 89 A2  1 
\ This doesn't work because turning off the escape sequence parser prevents
\ parsing the sequence to return to ANSI mode.
\        d#  3 of  dup to ansi-terminal?   endof
         d# 25 of  dup to showing-cursor?  endof
1A297B8 	58 41 A0  1 19  0  0  0 
1A297C0 	48 43 A0  1 18  0  0  0 
1A297C8 	40 49 A0  1 48 B8 A1  1 
1A297D0 	F8 88 A2  1 6C 43 A0  1 
1A297D8 	 8  0  0  0 
      endcase
1A297DC 	84 43 A0  1 
   loop
1A297E0 	F8 41 A0  1 CC FF FF FF 
   drop
1A297E8 	30 49 A0  1 
;
1A297EC 	58 46 A0  1 
: set-ansi-modes    ( -- )  true  handle-modes  ;
1A297F0 	 0 73 65 74 2D 61 6E 73 
1A297F8 	69 2D 6D 6F 64 65 73 8E 
1A29800 	98 97 A2  1 20 40 A0  1 
1A29808 	 4 70 A0  1 98 97 A2  1 
1A29810 	58 46 A0  1 
: reset-ansi-modes  ( -- )  false handle-modes  ;
1A29814 	 0  0  0 72 
1A29818 	65 73 65 74 2D 61 6E 73 
1A29820 	69 2D 6D 6F 64 65 73 90 
1A29828 	 4 98 A2  1 20 40 A0  1 
1A29830 	18 70 A0  1 98 97 A2  1 
1A29838 	58 46 A0  1 
: skipping-state  ( char -- )
1A2983C 	 0 73 6B 69 
1A29840 	70 70 69 6E 67 2D 73 74 
1A29848 	61 74 65 8E 2C 98 A2  1 
1A29850 	20 40 A0  1 
   ascii @  >=  if  enter-alpha-state  then
1A29854 	58 41 A0  1 
1A29858 	40  0  0  0 EC 48 A0  1 
1A29860 	DC 41 A0  1  8  0  0  0 
1A29868 	34 94 A2  1 
;
1A2986C 	58 46 A0  1 
: arg0  ( -- n )  0 arg  ?dup  0=  if  1  then  ;
1A29870 	 0  0  0 61 72 67 30 84 
1A29878 	50 98 A2  1 20 40 A0  1 
1A29880 	70 6F A0  1 90 89 A2  1 
1A29888 	B4 70 A0  1 24 47 A0  1 
1A29890 	DC 41 A0  1  8  0  0  0 
1A29898 	80 6F A0  1 58 46 A0  1 
: do-command  ( char -- )
1A298A0 	 0 64 6F 2D 63 6F 6D 6D 
1A298A8 	61 6E 64 8A 7C 98 A2  1 
1A298B0 	20 40 A0  1 
   enter-alpha-state
1A298B4 	34 94 A2  1 
   0 arg  to arginit
1A298B8 	70 6F A0  1 90 89 A2  1 
1A298C0 	48 B8 A1  1 BC 89 A2  1 
   case
      ascii @  of  arg0 insert-characters  endof
1A298C8 	58 41 A0  1 40  0  0  0 
1A298D0 	48 43 A0  1 14  0  0  0 
1A298D8 	7C 98 A2  1 E0 87 A2  1 
1A298E0 	6C 43 A0  1 D4  2  0  0 
      ascii A  of  arg0 negate  +line      endof
1A298E8 	58 41 A0  1 41  0  0  0 
1A298F0 	48 43 A0  1 18  0  0  0 
1A298F8 	7C 98 A2  1 48 45 A0  1 
1A29900 	40 8E A2  1 6C 43 A0  1 
1A29908 	B0  2  0  0 
      ascii B  of  arg0         +line      endof
1A2990C 	58 41 A0  1 
1A29910 	42  0  0  0 48 43 A0  1 
1A29918 	14  0  0  0 7C 98 A2  1 
1A29920 	40 8E A2  1 6C 43 A0  1 
1A29928 	90  2  0  0 
      ascii C  of  arg0         +column    endof
1A2992C 	58 41 A0  1 
1A29930 	43  0  0  0 48 43 A0  1 
1A29938 	14  0  0  0 7C 98 A2  1 
1A29940 	20 8E A2  1 6C 43 A0  1 
1A29948 	70  2  0  0 
      ascii D  of  arg0 negate  +column    endof
1A2994C 	58 41 A0  1 
1A29950 	44  0  0  0 48 43 A0  1 
1A29958 	18  0  0  0 7C 98 A2  1 
1A29960 	48 45 A0  1 20 8E A2  1 
1A29968 	6C 43 A0  1 4C  2  0  0 
      ascii E  of  line# arg0 +  set-line  endof
1A29970 	58 41 A0  1 45  0  0  0 
1A29978 	48 43 A0  1 1C  0  0  0 
1A29980 	54 86 A2  1 7C 98 A2  1 
1A29988 	 4 45 A0  1 BC 8D A2  1 
1A29990 	6C 43 A0  1 24  2  0  0 
      ascii f  of  move-cursor  endof
1A29998 	58 41 A0  1 66  0  0  0 
1A299A0 	48 43 A0  1 10  0  0  0 
1A299A8 	98 90 A2  1 6C 43 A0  1 
1A299B0 	 8  2  0  0 
      ascii h  of  set-ansi-modes     endof
1A299B4 	58 41 A0  1 
1A299B8 	68  0  0  0 48 43 A0  1 
1A299C0 	10  0  0  0  4 98 A2  1 
1A299C8 	6C 43 A0  1 EC  1  0  0 
      ascii l  of  reset-ansi-modes   endof
1A299D0 	58 41 A0  1 6C  0  0  0 
1A299D8 	48 43 A0  1 10  0  0  0 
1A299E0 	2C 98 A2  1 6C 43 A0  1 
1A299E8 	D0  1  0  0 
      ascii H  of  move-cursor  endof
1A299EC 	58 41 A0  1 
1A299F0 	48  0  0  0 48 43 A0  1 
1A299F8 	10  0  0  0 98 90 A2  1 
1A29A00 	6C 43 A0  1 B4  1  0  0 
      ascii J  of  kill-screen  endof
1A29A08 	58 41 A0  1 4A  0  0  0 
1A29A10 	48 43 A0  1 10  0  0  0 
1A29A18 	EC 90 A2  1 6C 43 A0  1 
1A29A20 	98  1  0  0 
      ascii K  of  kill-line    endof
1A29A24 	58 41 A0  1 
1A29A28 	4B  0  0  0 48 43 A0  1 
1A29A30 	10  0  0  0 74 8F A2  1 
1A29A38 	6C 43 A0  1 7C  1  0  0 
      ascii L  of  arg0 insert-lines    endof
1A29A40 	58 41 A0  1 4C  0  0  0 
1A29A48 	48 43 A0  1 14  0  0  0 
1A29A50 	7C 98 A2  1 1C 88 A2  1 
1A29A58 	6C 43 A0  1 5C  1  0  0 
      ascii M  of  arg0 delete-lines    endof
1A29A60 	58 41 A0  1 4D  0  0  0 
1A29A68 	48 43 A0  1 14  0  0  0 
1A29A70 	7C 98 A2  1 38 88 A2  1 
1A29A78 	6C 43 A0  1 3C  1  0  0 
      ascii P  of  arg0 delete-characters    endof
1A29A80 	58 41 A0  1 50  0  0  0 
1A29A88 	48 43 A0  1 14  0  0  0 
1A29A90 	7C 98 A2  1  0 88 A2  1 
1A29A98 	6C 43 A0  1 1C  1  0  0 
      ascii m  of  set-colors  endof
1A29AA0 	58 41 A0  1 6D  0  0  0 
1A29AA8 	48 43 A0  1 10  0  0  0 
1A29AB0 	28 97 A2  1 6C 43 A0  1 
1A29AB8 	 0  1  0  0 
      ascii p  of  inverse-screen?  if
1A29ABC 	58 41 A0  1 
1A29AC0 	70  0  0  0 48 43 A0  1 
1A29AC8 	38  0  0  0 14 89 A2  1 
1A29AD0 	DC 41 A0  1 24  0  0  0 
                      invert-screen
1A29AD8 	70 88 A2  1 
                      inverse? 0= is inverse?
1A29ADC 	2C 89 A2  1 
1A29AE0 	24 47 A0  1 48 B8 A1  1 
1A29AE8 	2C 89 A2  1 
                      false is inverse-screen?
1A29AEC 	18 70 A0  1 
1A29AF0 	48 B8 A1  1 14 89 A2  1 
		   then  endof
1A29AF8 	6C 43 A0  1 BC  0  0  0 
      ascii q  of  inverse-screen? 0=  if
1A29B00 	58 41 A0  1 71  0  0  0 
1A29B08 	48 43 A0  1 3C  0  0  0 
1A29B10 	14 89 A2  1 24 47 A0  1 
1A29B18 	DC 41 A0  1 24  0  0  0 
	              invert-screen
1A29B20 	70 88 A2  1 
                      inverse? 0= is inverse?
1A29B24 	2C 89 A2  1 
1A29B28 	24 47 A0  1 48 B8 A1  1 
1A29B30 	2C 89 A2  1 
                      true is inverse-screen?
1A29B34 	 4 70 A0  1 
1A29B38 	48 B8 A1  1 14 89 A2  1 
		   then  endof
1A29B40 	6C 43 A0  1 74  0  0  0 
      ascii r  of  arginit is #scroll-lines  endof
1A29B48 	58 41 A0  1 72  0  0  0 
1A29B50 	48 43 A0  1 18  0  0  0 
1A29B58 	BC 89 A2  1 48 B8 A1  1 
1A29B60 	80 89 A2  1 6C 43 A0  1 
1A29B68 	50  0  0  0 
      ascii s  of  reset-modes  reset-screen  endof
1A29B6C 	58 41 A0  1 
1A29B70 	73  0  0  0 48 43 A0  1 
1A29B78 	14  0  0  0 5C 94 A2  1 
1A29B80 	8C 88 A2  1 6C 43 A0  1 
1A29B88 	30  0  0  0 
         ( default )  dup ascii @  <  if  ['] skipping-state is ansi-emit  then
1A29B8C 	40 49 A0  1 
1A29B90 	58 41 A0  1 40  0  0  0 
1A29B98 	E4 47 A0  1 DC 41 A0  1 
1A29BA0 	14  0  0  0 60 53 A0  1 
1A29BA8 	50 98 A2  1 48 B8 A1  1 
1A29BB0 	44 89 A2  1 
   endcase
1A29BB4 	84 43 A0  1 
;
1A29BB8 	58 46 A0  1 
: escbrkt-state  ( char -- )
1A29BBC 	 0  0 65 73 
1A29BC0 	63 62 72 6B 74 2D 73 74 
1A29BC8 	61 74 65 8D B0 98 A2  1 
1A29BD0 	20 40 A0  1 
   dup  ascii 0  ascii 9  between  if	\ Collect number
1A29BD4 	40 49 A0  1 
1A29BD8 	58 41 A0  1 30  0  0  0 
1A29BE0 	58 41 A0  1 39  0  0  0 
1A29BE8 	D8 70 A0  1 DC 41 A0  1 
1A29BF0 	3C  0  0  0 
      next-arg arg  10 *  ascii 0  -  +  next-arg to arg
1A29BF4 	A8 89 A2  1 
1A29BF8 	90 89 A2  1 58 41 A0  1 
1A29C00 	 A  0  0  0 1C 5F A0  1 
1A29C08 	58 41 A0  1 30  0  0  0 
1A29C10 	18 45 A0  1  4 45 A0  1 
1A29C18 	A8 89 A2  1 48 B8 A1  1 
1A29C20 	90 89 A2  1 
   else  dup  ascii ;  =  if		\ Shift arguments
1A29C24 	C8 41 A0  1 
1A29C28 	4C  0  0  0 40 49 A0  1 
1A29C30 	58 41 A0  1 3B  0  0  0 
1A29C38 	24 48 A0  1 DC 41 A0  1 
1A29C40 	30  0  0  0 
      drop
1A29C44 	30 49 A0  1 
      next-arg 1+ to next-arg
1A29C48 	A8 89 A2  1 30 4B A0  1 
1A29C50 	48 B8 A1  1 A8 89 A2  1 
      0 next-arg  to arg
1A29C58 	70 6F A0  1 A8 89 A2  1 
1A29C60 	48 B8 A1  1 90 89 A2  1 
   else
1A29C68 	C8 41 A0  1  8  0  0  0 
      do-command
1A29C70 	B0 98 A2  1 
   then then
;
1A29C74 	58 46 A0  1 
: (escape-state  ( char -- )
1A29C78 	 0  0 28 65 73 63 61 70 
1A29C80 	65 2D 73 74 61 74 65 8D 
1A29C88 	D0 9B A2  1 20 40 A0  1 
   0 to next-arg
1A29C90 	70 6F A0  1 48 B8 A1  1 
1A29C98 	A8 89 A2  1 
   0 0  to arg
1A29C9C 	70 6F A0  1 
1A29CA0 	70 6F A0  1 48 B8 A1  1 
1A29CA8 	90 89 A2  1 
   case
      ascii [    of  ['] escbrkt-state is ansi-emit    endof
1A29CAC 	58 41 A0  1 
1A29CB0 	5B  0  0  0 48 43 A0  1 
1A29CB8 	1C  0  0  0 60 53 A0  1 
1A29CC0 	D0 9B A2  1 48 B8 A1  1 
1A29CC8 	44 89 A2  1 6C 43 A0  1 
1A29CD0 	8C  0  0  0 
      control L  of  enter-alpha-state  form-feed      endof
1A29CD4 	58 41 A0  1 
1A29CD8 	 C  0  0  0 48 43 A0  1 
1A29CE0 	14  0  0  0 34 94 A2  1 
1A29CE8 	AC 91 A2  1 6C 43 A0  1 
1A29CF0 	6C  0  0  0 
      control J  of  endof
1A29CF4 	58 41 A0  1 
1A29CF8 	 A  0  0  0 48 43 A0  1 
1A29D00 	 C  0  0  0 6C 43 A0  1 
1A29D08 	54  0  0  0 
      control M  of  endof
1A29D0C 	58 41 A0  1 
1A29D10 	 D  0  0  0 48 43 A0  1 
1A29D18 	 C  0  0  0 6C 43 A0  1 
1A29D20 	3C  0  0  0 
      control [  of  endof
1A29D24 	58 41 A0  1 
1A29D28 	1B  0  0  0 48 43 A0  1 
1A29D30 	 C  0  0  0 6C 43 A0  1 
1A29D38 	24  0  0  0 
      control ?  of  endof
1A29D3C 	58 41 A0  1 
1A29D40 	1F  0  0  0 48 43 A0  1 
1A29D48 	 C  0  0  0 6C 43 A0  1 
1A29D50 	 C  0  0  0 
      ( default )    enter-alpha-state
1A29D54 	34 94 A2  1 
   endcase
1A29D58 	84 43 A0  1 
;
1A29D5C 	58 46 A0  1 
\ Fix the forward reference
' (escape-state is escape-state

also forth definitions
headers
: ansi-type  ( adr len -- )
1A29D60 	 0  0 61 6E 73 69 2D 74 
1A29D68 	79 70 65 89 E8 94 A2  1 
1A29D70 	20 40 A0  1 
\ XXX here we should test for terminal locked, and if it is already
\ locked, we are being re-entered, so we save the current state
\ and switch to alpha state.
   terminal-locked? on
1A29D74 	D0 83 A2  1 
1A29D78 	E0 4B A0  1 
   showing-cursor?  if  toggle-cursor  then         ( adr len )
1A29D7C 	F8 88 A2  1 
1A29D80 	DC 41 A0  1  8  0  0  0 
1A29D88 	C4 88 A2  1 
   \ We save the string extent in variables so #newlines can
   \ find the current position.
   begin  dup  while       ( adr len )
1A29D8C 	40 49 A0  1 
1A29D90 	DC 41 A0  1 20  0  0  0 
      over c@  ansi-emit   ( adr len )
1A29D98 	54 49 A0  1 C4 4C A0  1 
1A29DA0 	44 89 A2  1 
      1 /string            ( adr' len' )
1A29DA4 	80 6F A0  1 
1A29DA8 	3C 85 A0  1 
   repeat                  ( adr 0 )
1A29DAC 	C8 41 A0  1 
1A29DB0 	DC FF FF FF 
   2drop                   ( )
1A29DB4 	AC 49 A0  1 
   showing-cursor?  if  toggle-cursor  then
1A29DB8 	F8 88 A2  1 DC 41 A0  1 
1A29DC0 	 8  0  0  0 C4 88 A2  1 
\ XXX Here we should restore the previous state if necessary.
   terminal-locked? off
1A29DC8 	D0 83 A2  1 F8 4B A0  1 
;
1A29DD0 	58 46 A0  1 

: install-terminal-emulator  ( -- )
1A29DD4 	 0  0 69 6E 
1A29DD8 	73 74 61 6C 6C 2D 74 65 
1A29DE0 	72 6D 69 6E 61 6C 2D 65 
1A29DE8 	6D 75 6C 61 74 6F 72 99 
1A29DF0 	70 9D A2  1 20 40 A0  1 
   \ Set the terminal emulator's frame-buffer-adr
   \ to be the same as the device that opened it
   \ in the first place.
   frame-buffer-adr my-termemu package( is frame-buffer-adr )package
1A29DF8 	CC  3 A2  1 E4  3 A2  1 
1A29E00 	2C 31 A2  1 48 B8 A1  1 
1A29E08 	CC  3 A2  1 5C 31 A2  1 
[ifdef] reboot-saves-cursor
   reboot?  if
      \ Restore the cursor to the position that was saved before the reset
      get-reboot-info          ( bootpath,len line# column# )
      #columns min  is column# ( bootpath,len line# )
      #lines  min  is line#    ( bootpath,len )
      2drop                    (  )
      line# column# or 0= if  erase-screen  then
   else
      erase-screen
   then
[else]
   erase-screen
1A29E10 	A8 88 A2  1 
[then]

   reset-screen     \ Enables video
1A29E14 	8C 88 A2  1 
   #lines termemu-#lines !
1A29E18 	 4 87 A2  1 64 5A A2  1 
1A29E20 	54 4D A0  1 
   toggle-cursor
1A29E24 	C4 88 A2  1 
;
1A29E28 	58 46 A0  1 
\ Don't use this for now; we need to fix the escape sequence parser so that
\ it will look for the "ansi-terminal" sequence even when in "dumb-terminal"
\ mode.
\ : dumb-terminal  ( -- )  " "(9b)25h" type  ;
\ : ansi-terminal  ( -- )  " "(9b)25l" type  ;
previous definitions

headers
: open ( -- success? )
1A29E2C 	 0  0  0 6F 
1A29E30 	70 65 6E 84 8C 9C A2  1 
1A29E38 	20 40 A0  1 
   my-self is my-termemu
1A29E3C 	EC 7E A0  1 
1A29E40 	48 B8 A1  1 E4  3 A2  1 
   ['] romfont is font
1A29E48 	60 53 A0  1 3C E4 A1  1 
1A29E50 	98 40 A0  1 CC 8A A2  1 
   reset-emulator
1A29E58 	E8 94 A2  1 
   true
1A29E5C 	 4 70 A0  1 
;
1A29E60 	58 46 A0  1 
: close ( -- )  ;
1A29E64 	 0  0 63 6C 
1A29E68 	6F 73 65 85 38 9E A2  1 
1A29E70 	20 40 A0  1 58 46 A0  1 

OpenFirmware/ofw/termemu/fwritstr.fth_AL	4376 1A29E78 
99CD7C4   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99CD7D4   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99CD7E4   80 04 00 00  84 03 00 00  00 00 00 00  00 00 00 00 ..............
99CD7F4   00 00 00 00  00 00 00 00  22 00 00 00  50 00 00 00 ........"...P...
99CD804   A8 D9 1F 40  A8 D9 1F 40  A8 D9 1F 40  A8 D9 1F 40 +.@+.@+.@+.@
99CD814   A8 D9 1F 40  A8 D9 1F 40  A8 D9 1F 40  A8 D9 1F 40 +.@+.@+.@+.@
99CD824   A8 D9 1F 40  A8 D9 1F 40  A8 D9 1F 40  A8 D9 1F 40 +.@+.@+.@+.@
99CD834   A8 D9 1F 40  A8 D9 1F 40  A8 D9 1F 40  A8 D9 1F 40 +.@+.@+.@+.@
99CD844   A8 D9 1F 40  FF FF FF FF  00 00 00 00  00 00 00 00 +.@........
99CD854   A8 D9 1F 40  00 00 00 00  01 00 00 00  00 00 00 00 +.@............
99CD864   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99CD874   00 00 00 00  00 00 00 00  0F 00 00 00  00 00 00 00 ................
99CD884   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99CD894   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
headers
\ Compatibility package to present a package-style interface for
\ old-style display drivers.

: $makealias  ( xt adr len -- )
1A29F54 	 0 24 6D 61 
1A29F58 	6B 65 61 6C 69 61 73 8A 
1A29F60 	F4 9D A2  1 20 40 A0  1 
   2dup my-voc find-method  if  ( xt adr len acf' )
1A29F68 	C0 49 A0  1 10  4 A2  1 
1A29F70 	A0 2F A2  1 DC 41 A0  1 
1A29F78 	14  0  0  0 
      2drop 2drop
1A29F7C 	AC 49 A0  1 
1A29F80 	AC 49 A0  1 
   else                         ( xt adr len )
1A29F84 	C8 41 A0  1 
1A29F88 	14  0  0  0 
      $create -1 setalias
1A29F8C 	8C A2 A0  1 
1A29F90 	58 41 A0  1 FF FF FF FF 
1A29F98 	CC DF A0  1 
   then
;
1A29F9C 	58 46 A0  1 

headerless
: disp-selftest ( -- failed? )
1A29FA0 	 0  0 64 69 73 70 2D 73 
1A29FA8 	65 6C 66 74 65 73 74 8D 
1A29FB0 	64 9F A2  1 20 40 A0  1 
   my-self >r
1A29FB8 	EC 7E A0  1 BC 45 A0  1 
   initial-addr my-termemu @  ( first-ihandle )
1A29FC0 	5C B8 A1  1 E4  3 A2  1 
1A29FC8 	A4  7 A2  1 5C 4C A0  1 
   ?dup  if  is  my-self  then (  )
1A29FD0 	B4 70 A0  1 DC 41 A0  1 
1A29FD8 	 C  0  0  0 B8 40 A0  1 
1A29FE0 	EC 7E A0  1 
   " disp-test" $call-self     ( failed? )
1A29FE4 	9C 53 A0  1 
1A29FE8 	 9 64 69 73 70 2D 74 65 
1A29FF0 	73 74  0  0 B4 30 A2  1 
   r> is my-self               ( failed? )
1A29FF8 	D0 45 A0  1 B8 40 A0  1 
1A2A000 	EC 7E A0  1 
;
1A2A004 	58 46 A0  1 

: disp-close  ( -- )
1A2A008 	 0 64 69 73 70 2D 63 6C 
1A2A010 	6F 73 65 8A B4 9F A2  1 
1A2A018 	20 40 A0  1 
   current-device >r  my-voc push-device
1A2A01C 	40 F9 A1  1 
1A2A020 	BC 45 A0  1 10  4 A2  1 
1A2A028 	F8 FB A1  1 
   \ Reset the my-termemu value in the instance record
   my-termemu  if
1A2A02C 	E4  3 A2  1 
1A2A030 	DC 41 A0  1 3C  0  0  0 
      initial-addr my-termemu       off
1A2A038 	5C B8 A1  1 E4  3 A2  1 
1A2A040 	A4  7 A2  1 F8 4B A0  1 
      initial-addr frame-buffer-adr off
1A2A048 	5C B8 A1  1 CC  3 A2  1 
1A2A050 	A4  7 A2  1 F8 4B A0  1 
      my-termemu " remove" $call-self    close-package
1A2A058 	E4  3 A2  1 9C 53 A0  1 
1A2A060 	 6 72 65 6D 6F 76 65  0 
1A2A068 	B4 30 A2  1 A4 36 A2  1 
   then
   r> push-device
1A2A070 	D0 45 A0  1 F8 FB A1  1 
;
1A2A078 	58 46 A0  1 
: disp-open   ( -- flag )
1A2A07C 	 0  0 64 69 
1A2A080 	73 70 2D 6F 70 65 6E 89 
1A2A088 	18 A0 A2  1 20 40 A0  1 
   \ If this device is already open
   \ then my-termemu will be initialized
   \ with the ihandle from the prev. open
   my-termemu ?dup  if  ( first-ihandle )
1A2A090 	E4  3 A2  1 B4 70 A0  1 
1A2A098 	DC 41 A0  1 18  0  0  0 
      close-chain    is my-self
1A2A0A0 	3C 37 A2  1 B8 40 A0  1 
1A2A0A8 	EC 7E A0  1 
   else
1A2A0AC 	C8 41 A0  1 
1A2A0B0 	70  0  0  0 
      \ Open an instance of the terminal emulator
      0 0  " terminal-emulator" $open-package  to my-termemu
1A2A0B4 	70 6F A0  1 
1A2A0B8 	70 6F A0  1 9C 53 A0  1 
1A2A0C0 	11 74 65 72 6D 69 6E 61 
1A2A0C8 	6C 2D 65 6D 75 6C 61 74 
1A2A0D0 	6F 72  0  0 80 3A A2  1 
1A2A0D8 	48 B8 A1  1 E4  3 A2  1 

      " install" $call-self
1A2A0E0 	9C 53 A0  1  7 69 6E 73 
1A2A0E8 	74 61 6C 6C  0  0  0  0 
1A2A0F0 	B4 30 A2  1 
      install-terminal-emulator
1A2A0F4 	F4 9D A2  1 
      \ Save the ihandle in the instance record
      my-self           initial-addr my-termemu       !
1A2A0F8 	EC 7E A0  1 5C B8 A1  1 
1A2A100 	E4  3 A2  1 A4  7 A2  1 
1A2A108 	54 4D A0  1 
      frame-buffer-adr  initial-addr frame-buffer-adr !
1A2A10C 	CC  3 A2  1 
1A2A110 	5C B8 A1  1 CC  3 A2  1 
1A2A118 	A4  7 A2  1 54 4D A0  1 
   then  true
1A2A120 	 4 70 A0  1 
;
1A2A124 	58 46 A0  1 
: disp-write  ( adr len -- len )  tuck ansi-type  ;
1A2A128 	 0 64 69 73 70 2D 77 72 
1A2A130 	69 74 65 8A 8C A0 A2  1 
1A2A138 	20 40 A0  1 E8 46 A0  1 
1A2A140 	70 9D A2  1 58 46 A0  1 

: stdout-execute  ( xt -- )  stdout @ package( execute )package  ;
1A2A148 	 0 73 74 64 6F 75 74 2D 
1A2A150 	65 78 65 63 75 74 65 8E 
1A2A158 	38 A1 A2  1 20 40 A0  1 
1A2A160 	68 55 A2  1 5C 4C A0  1 
1A2A168 	2C 31 A2  1 98 41 A0  1 
1A2A170 	5C 31 A2  1 58 46 A0  1 
: stdout-termemu   ( -- flag )  ['] my-termemu stdout-execute   ;
1A2A178 	 0 73 74 64 6F 75 74 2D 
1A2A180 	74 65 72 6D 65 6D 75 8E 
1A2A188 	5C A1 A2  1 20 40 A0  1 
1A2A190 	60 53 A0  1 E4  3 A2  1 
1A2A198 	5C A1 A2  1 58 46 A0  1 
: stdout-value  ( xt -- n )
1A2A1A0 	 0  0  0 73 74 64 6F 75 
1A2A1A8 	74 2D 76 61 6C 75 65 8C 
1A2A1B0 	8C A1 A2  1 20 40 A0  1 
   stdout-termemu  if  stdout-execute  else  drop 0  then
1A2A1B8 	8C A1 A2  1 DC 41 A0  1 
1A2A1C0 	10  0  0  0 5C A1 A2  1 
1A2A1C8 	C8 41 A0  1  C  0  0  0 
1A2A1D0 	30 49 A0  1 70 6F A0  1 
;
1A2A1D8 	58 46 A0  1 

: stdout-line#      ( -- line# )    ['] line#      stdout-value  ;
1A2A1DC 	 0  0  0 73 
1A2A1E0 	74 64 6F 75 74 2D 6C 69 
1A2A1E8 	6E 65 23 8C B4 A1 A2  1 
1A2A1F0 	20 40 A0  1 60 53 A0  1 
1A2A1F8 	54 86 A2  1 B4 A1 A2  1 
1A2A200 	58 46 A0  1 
: stdout-column#    ( -- column# )  ['] column#    stdout-value  ;
1A2A204 	 0 73 74 64 
1A2A208 	6F 75 74 2D 63 6F 6C 75 
1A2A210 	6D 6E 23 8E F0 A1 A2  1 
1A2A218 	20 40 A0  1 60 53 A0  1 
1A2A220 	40 86 A2  1 B4 A1 A2  1 
1A2A228 	58 46 A0  1 
: stdout-char-width ( -- pixels )   ['] char-width stdout-value  ;
1A2A22C 	 0  0 73 74 
1A2A230 	64 6F 75 74 2D 63 68 61 
1A2A238 	72 2D 77 69 64 74 68 91 
1A2A240 	18 A2 A2  1 20 40 A0  1 
1A2A248 	60 53 A0  1 44 8A A2  1 
1A2A250 	B4 A1 A2  1 58 46 A0  1 
: stdout-draw-logo  ( -- )
1A2A258 	 0  0  0 73 74 64 6F 75 
1A2A260 	74 2D 64 72 61 77 2D 6C 
1A2A268 	6F 67 6F 90 44 A2 A2  1 
1A2A270 	20 40 A0  1 
   stdout-termemu  if  ['] draw-logo  stdout-execute  else  2drop  then
1A2A274 	8C A1 A2  1 
1A2A278 	DC 41 A0  1 18  0  0  0 
1A2A280 	60 53 A0  1 DC 88 A2  1 
1A2A288 	5C A1 A2  1 C8 41 A0  1 
1A2A290 	 8  0  0  0 AC 49 A0  1 
;
1A2A298 	58 46 A0  1 

headers
: is-install   ( xt -- )
1A2A29C 	 0 69 73 2D 
1A2A2A0 	69 6E 73 74 61 6C 6C 8A 
1A2A2A8 	70 A2 A2  1 20 40 A0  1 
   ( xt )            " install"   $makealias
1A2A2B0 	9C 53 A0  1  7 69 6E 73 
1A2A2B8 	74 61 6C 6C  0  0  0  0 
1A2A2C0 	64 9F A2  1 
   ['] disp-open     " open"      $makealias
1A2A2C4 	60 53 A0  1 
1A2A2C8 	8C A0 A2  1 9C 53 A0  1 
1A2A2D0 	 4 6F 70 65 6E  0  0  0 
1A2A2D8 	64 9F A2  1 
   ['] disp-write    " write"     $makealias
1A2A2DC 	60 53 A0  1 
1A2A2E0 	38 A1 A2  1 9C 53 A0  1 
1A2A2E8 	 5 77 72 69 74 65  0  0 
1A2A2F0 	64 9F A2  1 
   ['] draw-logo     " draw-logo" $makealias
1A2A2F4 	60 53 A0  1 
1A2A2F8 	DC 88 A2  1 9C 53 A0  1 
1A2A300 	 9 64 72 61 77 2D 6C 6F 
1A2A308 	67 6F  0  0 64 9F A2  1 
   ['] reset-screen  " restore"   $makealias
1A2A310 	60 53 A0  1 8C 88 A2  1 
1A2A318 	9C 53 A0  1  7 72 65 73 
1A2A320 	74 6F 72 65  0  0  0  0 
1A2A328 	64 9F A2  1 
;
1A2A32C 	58 46 A0  1 
: is-remove    ( xt -- )
1A2A330 	 0  0 69 73 2D 72 65 6D 
1A2A338 	6F 76 65 89 AC A2 A2  1 
1A2A340 	20 40 A0  1 
   ( xt )            " remove"    $makealias
1A2A344 	9C 53 A0  1 
1A2A348 	 6 72 65 6D 6F 76 65  0 
1A2A350 	64 9F A2  1 
   ['] disp-close    " close"     $makealias
1A2A354 	60 53 A0  1 
1A2A358 	18 A0 A2  1 9C 53 A0  1 
1A2A360 	 5 63 6C 6F 73 65  0  0 
1A2A368 	64 9F A2  1 
;
1A2A36C 	58 46 A0  1 
: is-selftest  ( xt -- )
1A2A370 	69 73 2D 73 65 6C 66 74 
1A2A378 	65 73 74 8B 40 A3 A2  1 
1A2A380 	20 40 A0  1 
   ( xt )             " disp-test"  $makealias
1A2A384 	9C 53 A0  1 
1A2A388 	 9 64 69 73 70 2D 74 65 
1A2A390 	73 74  0  0 64 9F A2  1 
   ['] disp-selftest  " selftest"   $makealias
1A2A398 	60 53 A0  1 B4 9F A2  1 
1A2A3A0 	9C 53 A0  1  8 73 65 6C 
1A2A3A8 	66 74 65 73 74  0  0  0 
1A2A3B0 	64 9F A2  1 
;
1A2A3B4 	58 46 A0  1 

OpenFirmware/ofw/termemu/install.fth_AL	1124 1A2A3B8 \needs load-base 0  value load-base	\ The default value can be changed later
1A2A3B8 	 0  0 6C 6F 61 64 2D 62 
1A2A3C0 	61 73 65 89 80 A3 A2  1 
1A2A3C8 	50 40 A0  1 80  8  0  0 

OpenFirmware/ofw/core/bootparm.fth_AL	24 1A2A3D0 
headerless

nuser vector     0 vector !
1A2A3D0 	 0 76 65 63 74 6F 72 86 
1A2A3D8 	C8 A3 A2  1 48 40 A0  1 
1A2A3E0 	84  8  0  0 

\ Max#rets (6) + max#args (20) + service + n_args + n_returns
6 d# 20 + 3 + /n* buffer: cb-array
1A2A3E4 	 0  0  0 63 
1A2A3E8 	62 2D 61 72 72 61 79 88 
1A2A3F0 	DC A3 A2  1 B4 A9 A0  1 
1A2A3F8 	88  8  0  0 74  0  0  0 
1A2A400 	D8 73 A2  1 

\ #rets (1) + #args (1) + service + n_args + n_returns
1 1 + 3 + /n* buffer: int-cb-array
1A2A404 	 0  0  0 69 
1A2A408 	6E 74 2D 63 62 2D 61 72 
1A2A410 	72 61 79 8C F4 A3 A2  1 
1A2A418 	B4 A9 A0  1 8C  8  0  0 
1A2A420 	14  0  0  0 F4 A3 A2  1 

/n negate constant -/n
1A2A428 	2D 2F 6E 83 18 A4 A2  1 
1A2A430 	68 40 A0  1 FC FF FF FF 
: !+  ( n adr -- adr' )  tuck ! na1+  ;
1A2A438 	 0 21 2B 82 30 A4 A2  1 
1A2A440 	20 40 A0  1 E8 46 A0  1 
1A2A448 	54 4D A0  1 CC 50 A0  1 
1A2A450 	58 46 A0  1 

headers

\ This version is for the special case where there is one argument, we
\ have already checked the vector, and we don't care about the result.
\ It uses a private copy of the callback array so it can be used for
\ timer tick callbacks, which may happen during the execution of other
\ callbacks.
: ($callback1)  ( arg1 adr len -- )
1A2A454 	 0  0  0 28 
1A2A458 	24 63 61 6C 6C 62 61 63 
1A2A460 	6B 31 29 8C 40 A4 A2  1 
1A2A468 	20 40 A0  1 
   vector @  0=  if  3drop exit  then
1A2A46C 	DC A3 A2  1 
1A2A470 	5C 4C A0  1 24 47 A0  1 
1A2A478 	DC 41 A0  1  C  0  0  0 
1A2A480 	90 52 A0  1 40 46 A0  1 
;
1A2A488 	58 46 A0  1 



: ($callback)
1A2A48C 	28 24 63 61 
1A2A490 	6C 6C 62 61 63 6B 29 8B 
1A2A498 	68 A4 A2  1 20 40 A0  1 
   ( argn .. arg1 nargs adr len -- [ retn .. ret2 Nreturns-1 ] ret1  )
   vector @  0=  if
1A2A4A0 	DC A3 A2  1 5C 4C A0  1 
1A2A4A8 	24 47 A0  1 DC 41 A0  1 
1A2A4B0 	28  0  0  0 
      2drop  0  ?do  drop  loop  true exit
1A2A4B4 	AC 49 A0  1 
1A2A4B8 	70 6F A0  1 50 42 A0  1 
1A2A4C0 	10  0  0  0 30 49 A0  1 
1A2A4C8 	F8 41 A0  1 F8 FF FF FF 
1A2A4D0 	 4 70 A0  1 40 46 A0  1 
   then
;
1A2A4D8 	58 46 A0  1 
: $callback  ( argn .. arg1 nargs adr len -- retn .. ret2 Nreturns-1 )
1A2A4DC 	 0  0 24 63 
1A2A4E0 	61 6C 6C 62 61 63 6B 89 
1A2A4E8 	9C A4 A2  1 20 40 A0  1 
   ($callback)  throw
1A2A4F0 	9C A4 A2  1 74 7F A0  1 
;
1A2A4F8 	58 46 A0  1 
: sync  ( -- )  0 " sync" $callback drop  ;
1A2A4FC 	 0  0  0 73 
1A2A500 	79 6E 63 84 EC A4 A2  1 
1A2A508 	20 40 A0  1 70 6F A0  1 
1A2A510 	9C 53 A0  1  4 73 79 6E 
1A2A518 	63  0  0  0 EC A4 A2  1 
1A2A520 	30 49 A0  1 58 46 A0  1 
: callback  \ service-name  rest of line  ( -- )
1A2A528 	 0  0  0 63 61 6C 6C 62 
1A2A530 	61 63 6B 88  8 A5 A2  1 
1A2A538 	20 40 A0  1 
   parse-word  -1 parse  dup over + 0 swap c!  ( adr len arg-adr )
1A2A53C 	34 93 A0  1 
1A2A540 	58 41 A0  1 FF FF FF FF 
1A2A548 	E4 85 A0  1 40 49 A0  1 
1A2A550 	54 49 A0  1  4 45 A0  1 
1A2A558 	70 6F A0  1 68 49 A0  1 
1A2A560 	B8 4D A0  1 
   -rot 1 -rot  $callback
1A2A564 	94 49 A0  1 
1A2A568 	80 6F A0  1 94 49 A0  1 
1A2A570 	EC A4 A2  1 
;
1A2A574 	58 46 A0  1 

also client-services definitions
: interpret  ( arg-P .. arg1 cstr -- res-Q ... res-1 catch-result )
1A2A578 	 0  0 69 6E 74 65 72 70 
1A2A580 	72 65 74 89  0  0 A0  1 
1A2A588 	20 40 A0  1 
   cscount  ['] interpret-string  catch  dup  if  nip nip  then
1A2A58C 	AC DF A0  1 
1A2A590 	60 53 A0  1 1C E5 A1  1 
1A2A598 	14 7F A0  1 40 49 A0  1 
1A2A5A0 	DC 41 A0  1  C  0  0  0 
1A2A5A8 	FC 46 A0  1 FC 46 A0  1 
;
1A2A5B0 	58 46 A0  1 

: set-callback  ( newfunc -- oldfunc )
1A2A5B4 	 0  0  0 73 
1A2A5B8 	65 74 2D 63 61 6C 6C 62 
1A2A5C0 	61 63 6B 8C 88 A5 A2  1 
1A2A5C8 	20 40 A0  1 
   vector @  swap vector !
1A2A5CC 	DC A3 A2  1 
1A2A5D0 	5C 4C A0  1 68 49 A0  1 
1A2A5D8 	DC A3 A2  1 54 4D A0  1 
   cb-array drop		\ Force allocation now
1A2A5E0 	F4 A3 A2  1 30 49 A0  1 
   int-cb-array drop
1A2A5E8 	18 A4 A2  1 30 49 A0  1 
;
1A2A5F0 	58 46 A0  1 
previous definitions

OpenFirmware/ofw/core/callback.fth_AL	548 1A2A5F4 
propset=1A2A608 B441DCD 1A008D0 
vocset=B441DCD 1A008D0 1A2A608 
new-node=B441DE1 1A008B0 
vocset=B441DE1 1A008B0 1A2A608 
deblocker
1A2A9B8 1A2A9D8 
99CE864   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99CE874   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99CE884   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
headerless
decimal

packages-device push-device \ mmo " /packages" find-device
new-device
1A2A5F4 	E0 B6 A0  1 
1A2A5F8 	90  8  0  0 C8 50 A2  1 
1A2A600 	E0 B6 A0  1 B0  8  0  0 

0 invert 1 >> constant maxint	\ Assumes 2's complement, I suppose
1A2A608 	 0 6D 61 78 69 6E 74 86 
1A2A610 	 0  0 A0  1 68 40 A0  1 
1A2A618 	FF FF FF 7F 

0 instance value block#         \ Internal state; holds offset from last seek
1A2A61C 	 0 62 6C 6F 
1A2A620 	63 6B 23 86 14 A6 A2  1 
1A2A628 	C0 FE A1  1 18  0  0  0 
0 instance value buffer         \ Buffer we use for file I/O
1A2A630 	 0 62 75 66 66 65 72 86 
1A2A638 	28 A6 A2  1 C0 FE A1  1 
1A2A640 	1C  0  0  0 
0 instance value bufsize 	\ Size of buffer
1A2A644 	62 75 66 73 
1A2A648 	69 7A 65 87 3C A6 A2  1 
1A2A650 	C0 FE A1  1 20  0  0  0 
0 instance value blocksize	\ Sector size of underlying device
1A2A658 	 0  0 62 6C 6F 63 6B 73 
1A2A660 	69 7A 65 89 50 A6 A2  1 
1A2A668 	C0 FE A1  1 24  0  0  0 
0 instance value #blocks	\ The maximum number of blocks on the device
1A2A670 	23 62 6C 6F 63 6B 73 87 
1A2A678 	68 A6 A2  1 C0 FE A1  1 
1A2A680 	28  0  0  0 
/fd instance buffer: deblock-fd
1A2A684 	 0 64 65 62 
1A2A688 	6C 6F 63 6B 2D 66 64 8A 
1A2A690 	7C A6 A2  1 4C  0 A2  1 
1A2A698 	4C FF FF FF 

\ Closes an open file, freeing its descriptor for reuse.

: block-fclose  ( fid -- )
1A2A69C 	 0  0  0 62 
1A2A6A0 	6C 6F 63 6B 2D 66 63 6C 
1A2A6A8 	6F 73 65 8C 94 A6 A2  1 
1A2A6B0 	20 40 A0  1 
   drop   buffer  if
1A2A6B4 	30 49 A0  1 
1A2A6B8 	3C A6 A2  1 DC 41 A0  1 
1A2A6C0 	40  0  0  0 
      buffer  bufsize " dma-free" ['] $call-parent catch  if
1A2A6C4 	3C A6 A2  1 
1A2A6C8 	50 A6 A2  1 9C 53 A0  1 
1A2A6D0 	 8 64 6D 61 2D 66 72 65 
1A2A6D8 	65  0  0  0 60 53 A0  1 
1A2A6E0 	DC 31 A2  1 14 7F A0  1 
1A2A6E8 	DC 41 A0  1 14  0  0  0 
         \ If dma-free method doesn't exist, we fall back on the
         \ system free-virtual function.  This is a hack, and can
         \ probably be eliminated in future systems.
         4drop  buffer bufsize free-virtual
1A2A6F0 	38 53 A0  1 3C A6 A2  1 
1A2A6F8 	50 A6 A2  1 88 76 A2  1 
      then
   then
;
1A2A700 	58 46 A0  1 

\ Reduce #blocks if necessary to ensure that block# + #blocks does not
\ exceed the size of the device.

: clip-#blocks  ( block# #blocks -- block# #blocks' )
1A2A704 	 0  0  0 63 
1A2A708 	6C 69 70 2D 23 62 6C 6F 
1A2A710 	63 6B 73 8C B0 A6 A2  1 
1A2A718 	20 40 A0  1 
   #blocks  if                   ( block# #blocks )
1A2A71C 	7C A6 A2  1 
1A2A720 	DC 41 A0  1 1C  0  0  0 
      over +  #blocks umin       ( block# top-block# )
1A2A728 	54 49 A0  1  4 45 A0  1 
1A2A730 	7C A6 A2  1 4C 4A A0  1 
      over -                     ( block# #blocks' )
1A2A738 	54 49 A0  1 18 45 A0  1 
   then
;
1A2A740 	58 46 A0  1 

\ Writes "count" bytes from the buffer at address "adr" to a file.
\ Returns the number of bytes actually written.

: block-fwrite  ( adr #bytes fid -- #written )
1A2A744 	 0  0  0 62 
1A2A748 	6C 6F 63 6B 2D 66 77 72 
1A2A750 	69 74 65 8C 18 A7 A2  1 
1A2A758 	20 40 A0  1 
   drop  block#                  ( adr #bytes block# )
1A2A75C 	30 49 A0  1 
1A2A760 	28 A6 A2  1 
   swap blocksize  /             ( adr #blocks block# )
1A2A764 	68 49 A0  1 
1A2A768 	68 A6 A2  1 98 5F A0  1 
   clip-#blocks                  ( adr block# #blocks' )
1A2A770 	18 A7 A2  1 
   " write-blocks" $call-parent  ( actual-#blocks )
1A2A774 	9C 53 A0  1 
1A2A778 	 C 77 72 69 74 65 2D 62 
1A2A780 	6C 6F 63 6B 73  0  0  0 
1A2A788 	DC 31 A2  1 
   blocksize *                   ( #bytes-written )
1A2A78C 	68 A6 A2  1 
1A2A790 	1C 5F A0  1 
;
1A2A794 	58 46 A0  1 

\ Reads at most "count" bytes into the buffer at address "adr" from a file.
\ Returns the number of bytes actually read.

: block-fread  ( adr #bytes fid -- #read )
1A2A798 	62 6C 6F 63 6B 2D 66 72 
1A2A7A0 	65 61 64 8B 58 A7 A2  1 
1A2A7A8 	20 40 A0  1 
   drop  block#                  ( adr #bytes block# )
1A2A7AC 	30 49 A0  1 
1A2A7B0 	28 A6 A2  1 
   swap blocksize  /             ( adr block# #blocks )
1A2A7B4 	68 49 A0  1 
1A2A7B8 	68 A6 A2  1 98 5F A0  1 
   clip-#blocks                  ( adr block# #blocks' )
1A2A7C0 	18 A7 A2  1 
   " read-blocks" $call-parent   ( actual-#blocks )
1A2A7C4 	9C 53 A0  1 
1A2A7C8 	 B 72 65 61 64 2D 62 6C 
1A2A7D0 	6F 63 6B 73  0  0  0  0 
1A2A7D8 	DC 31 A2  1 
   blocksize  *                  ( #bytes-read )
1A2A7DC 	68 A6 A2  1 
1A2A7E0 	1C 5F A0  1 
;
1A2A7E4 	58 46 A0  1 


\ Positions to byte number "d.byte#" in a file

: block-fseek  ( d.byte# fid -- )
1A2A7E8 	62 6C 6F 63 6B 2D 66 73 
1A2A7F0 	65 65 6B 8B A8 A7 A2  1 
1A2A7F8 	20 40 A0  1 
   drop  blocksize um/mod nip        ( block# )
1A2A7FC 	30 49 A0  1 
1A2A800 	68 A6 A2  1 7C 5D A0  1 
1A2A808 	FC 46 A0  1 
   #blocks  if  #blocks umin  then   ( block#' )
1A2A80C 	7C A6 A2  1 
1A2A810 	DC 41 A0  1  C  0  0  0 
1A2A818 	7C A6 A2  1 4C 4A A0  1 
   to block#
1A2A820 	48 B8 A1  1 28 A6 A2  1 
;
1A2A828 	58 46 A0  1 


\ Returns the current size "d.size" of a file

: block-fsize  ( fid -- d.size )
1A2A82C 	62 6C 6F 63 
1A2A830 	6B 2D 66 73 69 7A 65 8B 
1A2A838 	F8 A7 A2  1 20 40 A0  1 
   drop                                             ( )
1A2A840 	30 49 A0  1 
   " current-#blocks" ['] $call-parent catch  if    ( x x )
1A2A844 	9C 53 A0  1 
1A2A848 	 F 63 75 72 72 65 6E 74 
1A2A850 	2D 23 62 6C 6F 63 6B 73 
1A2A858 	 0  0  0  0 60 53 A0  1 
1A2A860 	DC 31 A2  1 14 7F A0  1 
1A2A868 	DC 41 A0  1 3C  0  0  0 
      2drop                                         ( )
1A2A870 	AC 49 A0  1 
      #blocks  if  #blocks blocksize um*  else  -1 maxint  then  ( d.size )
1A2A874 	7C A6 A2  1 
1A2A878 	DC 41 A0  1 18  0  0  0 
1A2A880 	7C A6 A2  1 68 A6 A2  1 
1A2A888 	50 5D A0  1 C8 41 A0  1 
1A2A890 	10  0  0  0 58 41 A0  1 
1A2A898 	FF FF FF FF 14 A6 A2  1 
   else                                             ( #blocks )
1A2A8A0 	C8 41 A0  1  C  0  0  0 
      blocksize um*                                 ( d.size )
1A2A8A8 	68 A6 A2  1 50 5D A0  1 
   then
;
1A2A8B0 	58 46 A0  1 


\ Aligns a number to a block boundary.

: block-falign  ( d.byte# fid -- d.aligned-byte# )
1A2A8B4 	 0  0  0 62 
1A2A8B8 	6C 6F 63 6B 2D 66 61 6C 
1A2A8C0 	69 67 6E 8C 3C A8 A2  1 
1A2A8C8 	20 40 A0  1 
   drop  blocksize um/mod nip  blocksize um*
1A2A8CC 	30 49 A0  1 
1A2A8D0 	68 A6 A2  1 7C 5D A0  1 
1A2A8D8 	FC 46 A0  1 68 A6 A2  1 
1A2A8E0 	50 5D A0  1 
;
1A2A8E4 	58 46 A0  1 

: block-size    ( -- n )
1A2A8E8 	 0 62 6C 6F 63 6B 2D 73 
1A2A8F0 	69 7A 65 8A C8 A8 A2  1 
1A2A8F8 	20 40 A0  1 
   " block-size"  ['] $call-parent catch  if  2drop d# 512  then
1A2A8FC 	9C 53 A0  1 
1A2A900 	 A 62 6C 6F 63 6B 2D 73 
1A2A908 	69 7A 65  0 60 53 A0  1 
1A2A910 	DC 31 A2  1 14 7F A0  1 
1A2A918 	DC 41 A0  1 10  0  0  0 
1A2A920 	AC 49 A0  1 58 41 A0  1 
1A2A928 	 0  2  0  0 
;
1A2A92C 	58 46 A0  1 

: buffer-size  ( -- n )
1A2A930 	62 75 66 66 65 72 2D 73 
1A2A938 	69 7A 65 8B F8 A8 A2  1 
1A2A940 	20 40 A0  1 
   " max-transfer"  ['] $call-parent catch  if  2drop  h# 10000  then  ( max )
1A2A944 	9C 53 A0  1 
1A2A948 	 C 6D 61 78 2D 74 72 61 
1A2A950 	6E 73 66 65 72  0  0  0 
1A2A958 	60 53 A0  1 DC 31 A2  1 
1A2A960 	14 7F A0  1 DC 41 A0  1 
1A2A968 	10  0  0  0 AC 49 A0  1 
1A2A970 	58 41 A0  1  0  0  1  0 

   \ For fixed-length devices, block-size is greater than 1.  In that
   \ case, we use a buffer that is at least the size of a block, and
   \ preferably somewhat larger, to avoid blowing disk revs.  We don't
   \ want it to be too large though, or we will lose performance when
   \ accessing files, which may require accessing relatively-small index
   \ or directory blocks.
   \ For variable-length devices, block-size is 1.  In that case, we
   \ use a buffer the size of max-transfer.  If we use a smaller one,
   \ the device may try to map too much space.
   block-size 1 >  if  h# 4000 min  block-size max  then
1A2A978 	F8 A8 A2  1 80 6F A0  1 
1A2A980 	 4 48 A0  1 DC 41 A0  1 
1A2A988 	18  0  0  0 58 41 A0  1 
1A2A990 	 0 40  0  0 74 4A A0  1 
1A2A998 	F8 A8 A2  1 9C 4A A0  1 
;
1A2A9A0 	58 46 A0  1 

headers
\ Externally-visible routines follow.

" deblocker" device-name
1A2A9A4 	64 65 62 6C 
1A2A9A8 	6F 63 6B 65 72  0  0 6E 
1A2A9B0 	61 6D 65 84  0  0 A0  1 
1A2A9B8 	BC 13 A2  1 18  0  0  0 
1A2A9C0 	 A  0  0  0 

\ This property indicates that bug 1074409 has been fixed.
\ If this property is not present, client programs must install a patch.
0 0 " disk-write-fix" property
1A2A9C4 	 0 64 69 73 
1A2A9C8 	6B 2D 77 72 69 74 65 2D 
1A2A9D0 	66 69 78 8E B8 A9 A2  1 
1A2A9D8 	BC 13 A2  1 DC A9 A2  1 
1A2A9E0 	 0  0  0  0 
: open  ( -- okay? )
1A2A9E4 	 0  0  0 6F 
1A2A9E8 	70 65 6E 84 40 A9 A2  1 
1A2A9F0 	20 40 A0  1 

   0 to block#                          ( )
1A2A9F4 	70 6F A0  1 
1A2A9F8 	48 B8 A1  1 28 A6 A2  1 
   0 to buffer                          ( )
1A2AA00 	70 6F A0  1 48 B8 A1  1 
1A2AA08 	3C A6 A2  1 

   block-size   to blocksize            ( )
1A2AA0C 	F8 A8 A2  1 
1A2AA10 	48 B8 A1  1 68 A6 A2  1 
   buffer-size  to bufsize              ( )
1A2AA18 	40 A9 A2  1 48 B8 A1  1 
1A2AA20 	50 A6 A2  1 

   bufsize  " dma-alloc"                ( size adr len )
1A2AA24 	50 A6 A2  1 
1A2AA28 	9C 53 A0  1  9 64 6D 61 
1A2AA30 	2D 61 6C 6C 6F 63  0  0 
   ['] $call-parent  catch  if          ( x y z )
1A2AA38 	60 53 A0  1 DC 31 A2  1 
1A2AA40 	14 7F A0  1 DC 41 A0  1 
1A2AA48 	24  0  0  0 
      3drop  bufsize allocate-dma       ( dma-addr|0 )
1A2AA4C 	90 52 A0  1 
1A2AA50 	50 A6 A2  1 1C E1 A1  1 
      dup 0=  if  exit  then            ( dma-addr )
1A2AA58 	40 49 A0  1 24 47 A0  1 
1A2AA60 	DC 41 A0  1  8  0  0  0 
1A2AA68 	40 46 A0  1 
   then                                 ( dma-addr )
   to buffer                            ( )
1A2AA6C 	48 B8 A1  1 
1A2AA70 	3C A6 A2  1 

   " #blocks" ['] $call-parent  catch  if  ( x x )
1A2AA74 	9C 53 A0  1 
1A2AA78 	 7 23 62 6C 6F 63 6B 73 
1A2AA80 	 0  0  0  0 60 53 A0  1 
1A2AA88 	DC 31 A2  1 14 7F A0  1 
1A2AA90 	DC 41 A0  1 10  0  0  0 
      2drop
1A2AA98 	AC 49 A0  1 
   else                                 ( true | n false )
1A2AA9C 	C8 41 A0  1 
1A2AAA0 	 C  0  0  0 
      to #blocks                        ( )
1A2AAA4 	48 B8 A1  1 
1A2AAA8 	7C A6 A2  1 
   then


   file @ >r  deblock-fd file !         ( )
1A2AAAC 	84 AB A0  1 
1A2AAB0 	5C 4C A0  1 BC 45 A0  1 
1A2AAB8 	94 A6 A2  1 84 AB A0  1 
1A2AAC0 	54 4D A0  1 

   buffer  bufsize  initbuf             ( )
1A2AAC4 	3C A6 A2  1 
1A2AAC8 	50 A6 A2  1 F4 CA A0  1 

   my-self  modify                      ( fid mode )
1A2AAD0 	EC 7E A0  1 10 CA A0  1 
   ['] block-fsize   ['] block-falign   ( fid mode ops.. )
1A2AAD8 	60 53 A0  1 3C A8 A2  1 
1A2AAE0 	60 53 A0  1 C8 A8 A2  1 
   ['] block-fclose  ['] block-fseek    ( fid mode ops.. )
1A2AAE8 	60 53 A0  1 B0 A6 A2  1 
1A2AAF0 	60 53 A0  1 F8 A7 A2  1 
   ['] block-fwrite  ['] block-fread    ( fid mode ops.. )
1A2AAF8 	60 53 A0  1 58 A7 A2  1 
1A2AB00 	60 53 A0  1 A8 A7 A2  1 
   setupfd                              ( )
1A2AB08 	64 C9 A0  1 

   true                                 ( true )
1A2AB0C 	 4 70 A0  1 
   r> file !
1A2AB10 	D0 45 A0  1 84 AB A0  1 
1A2AB18 	54 4D A0  1 
;
1A2AB1C 	58 46 A0  1 

: seek   ( offset.low offset.high -- error? )
1A2AB20 	 0  0  0 73 65 65 6B 84 
1A2AB28 	F0 A9 A2  1 20 40 A0  1 
   deblock-fd  ['] dfseek catch  if  3drop true  else  false  then
1A2AB30 	94 A6 A2  1 60 53 A0  1 
1A2AB38 	F8 D1 A0  1 14 7F A0  1 
1A2AB40 	DC 41 A0  1 14  0  0  0 
1A2AB48 	90 52 A0  1  4 70 A0  1 
1A2AB50 	C8 41 A0  1  8  0  0  0 
1A2AB58 	18 70 A0  1 
;
1A2AB5C 	58 46 A0  1 
: read   ( adr len -- actual-len )
1A2AB60 	 0  0  0 72 65 61 64 84 
1A2AB68 	2C AB A2  1 20 40 A0  1 
   deblock-fd  ['] fgets catch  if  3drop 0  then
1A2AB70 	94 A6 A2  1 60 53 A0  1 
1A2AB78 	1C D4 A0  1 14 7F A0  1 
1A2AB80 	DC 41 A0  1  C  0  0  0 
1A2AB88 	90 52 A0  1 70 6F A0  1 
;
1A2AB90 	58 46 A0  1 
finish-device
1A2AB94 	 0  0  0  0 
1A2AB98 	 0  0  0  0  0  0  0  0 
1A2ABA0 	 0  0  0  0  0  0  0  0 
1A2ABA8 	 0  0  0  0  0  0  0  0 
1A2ABB0 	 0  0  0  0  0  0  0  0 
1A2ABB8 	 0  0  0  0  0  0  0  0 
device-end

OpenFirmware/ofw/core/deblock.fth_AL	1484 1A2ABC0 
5D9288   6B 65 79 62  6F 61 72 64  72 6B 73 65  74 61 74 6F keyboardrksetato
5D8F85   73 63 72 65  65 6E 72 69  74 65 2D 66  69 78 73 6C screenrite-fixslpurpose: Select and install console I/O devices

headers
" keyboard" d# 32  config-string input-device
1A2ABC0 	 0  0  0 69 6E 70 75 74 
1A2ABC8 	2D 64 65 76 69 63 65 8C 
1A2ABD0 	6C 52 A2  1  0  0  0  0 
1A2ABD8 	B4  8  0 40  4  0  0  0 
1A2ABE0 	6B 65 79 62 6F 61 72 64 
1A2ABE8 	 0  0  0  0 
" screen"   d# 32  config-string output-device
1A2ABEC 	 0  0 6F 75 
1A2ABF0 	74 70 75 74 2D 64 65 76 
1A2ABF8 	69 63 65 8D D4 AB A2  1 
1A2AC00 	 0  0  0  0 B8  8  0 40 
1A2AC08 	 4  0  0  0 73 63 72 65 
1A2AC10 	65 6E  0  0 

variable prev-stdin
1A2AC14 	 0 70 72 65 
1A2AC18 	76 2D 73 74 64 69 6E 8A 
1A2AC20 	38 A5 A2  1 48 40 A0  1 
1A2AC28 	BC  8  0  0 

headerless
: report-fb  ( -- )
1A2AC2C 	 0  0 72 65 
1A2AC30 	70 6F 72 74 2D 66 62 89 
1A2AC38 	24 AC A2  1 20 40 A0  1 
   'fb-node token@  origin <>  if            ( phandle )
1A2AC40 	CC 4B A2  1  C 54 A0  1 
1A2AC48 	50 55 A0  1 44 48 A0  1 
1A2AC50 	DC 41 A0  1 40  0  0  0 
      'fb-node token@  " screen" 2dup aliased?  if  ( phandle name$ alias$ )
1A2AC58 	CC 4B A2  1  C 54 A0  1 
1A2AC60 	9C 53 A0  1  6 73 63 72 
1A2AC68 	65 65 6E  0 C0 49 A0  1 
1A2AC70 	 4 1F A2  1 DC 41 A0  1 
1A2AC78 	14  0  0  0 
	 \ There is already an alias called screen
	 2drop 3drop                                (  )
1A2AC7C 	AC 49 A0  1 
1A2AC80 	90 52 A0  1 
      else                                          ( phandle name$ alias$ )
1A2AC84 	C8 41 A0  1 
1A2AC88 	 C  0  0  0 
	 2drop make-node-alias                      (  )
1A2AC8C 	AC 49 A0  1 
1A2AC90 	58 4E A2  1 
      then
   then
;
1A2AC94 	58 46 A0  1 

headers
: install-console  ( -- )
1A2AC98 	69 6E 73 74 61 6C 6C 2D 
1A2ACA0 	63 6F 6E 73 6F 6C 65 8F 
1A2ACA8 	3C AC A2  1 20 40 A0  1 
   report-fb
1A2ACB0 	3C AC A2  1 

   \ Switch to romvec I/O and use ttya at first.
   fallback-device io  console-io
1A2ACB4 	EC E3 A1  1 
1A2ACB8 	6C 5C A2  1 18 5D A2  1 

   \ Open NVRAM output-device as the output device
   output-device output
1A2ACC0 	 0 AC A2  1 4C 5B A2  1 

   \ Open NVRAM input-device as the input device
   stdin @  prev-stdin !  input-device  input
1A2ACC8 	54 55 A2  1 5C 4C A0  1 
1A2ACD0 	24 AC A2  1 54 4D A0  1 
1A2ACD8 	D4 AB A2  1 3C 59 A2  1 

   prev-stdin @ stdin @  =   input-device " keyboard" $=   and  if
1A2ACE0 	24 AC A2  1 5C 4C A0  1 
1A2ACE8 	54 55 A2  1 5C 4C A0  1 
1A2ACF0 	24 48 A0  1 D4 AB A2  1 
1A2ACF8 	9C 53 A0  1  8 6B 65 79 
1A2AD00 	62 6F 61 72 64  0  0  0 
1A2AD08 	88 8D A0  1 5C 44 A0  1 
1A2AD10 	DC 41 A0  1 90  0  0  0 
      \ NVRAM input-device was keyboard but could not open it.

      output-device " screen"   $=  stdout @ 0<>  and  if
1A2AD18 	 0 AC A2  1 9C 53 A0  1 
1A2AD20 	 6 73 63 72 65 65 6E  0 
1A2AD28 	88 8D A0  1 68 55 A2  1 
1A2AD30 	5C 4C A0  1 44 47 A0  1 
1A2AD38 	5C 44 A0  1 DC 41 A0  1 
1A2AD40 	5C  0  0  0 

         ." Keyboard not present.  Using "  fallback-device type
1A2AD44 	20 7C A0  1 
1A2AD48 	1D 4B 65 79 62 6F 61 72 
1A2AD50 	64 20 6E 6F 74 20 70 72 
1A2AD58 	65 73 65 6E 74 2E 20 20 
1A2AD60 	55 73 69 6E 67 20  0  0 
1A2AD68 	EC E3 A1  1  4 6C A0  1 
         ."  for input and output." cr
1A2AD70 	20 7C A0  1 16 20 66 6F 
1A2AD78 	72 20 69 6E 70 75 74 20 
1A2AD80 	61 6E 64 20 6F 75 74 70 
1A2AD88 	75 74 2E  0 80 6D A0  1 

         \ Give the user time to see the message before the screen goes blank
         d# 4000 ms
1A2AD90 	58 41 A0  1 A0  F  0  0 
1A2AD98 	60 E0 A1  1 
      then
      fallback-device io
1A2AD9C 	EC E3 A1  1 
1A2ADA0 	6C 5C A2  1 
   then

   \ Fail-safe in case of bad input or output device
   stdin  @  0=  if  fallback-device input   then
1A2ADA4 	54 55 A2  1 
1A2ADA8 	5C 4C A0  1 24 47 A0  1 
1A2ADB0 	DC 41 A0  1  C  0  0  0 
1A2ADB8 	EC E3 A1  1 3C 59 A2  1 
   stdout @  0=  if  fallback-device output  then
1A2ADC0 	68 55 A2  1 5C 4C A0  1 
1A2ADC8 	24 47 A0  1 DC 41 A0  1 
1A2ADD0 	 C  0  0  0 EC E3 A1  1 
1A2ADD8 	4C 5B A2  1 
;
1A2ADDC 	58 46 A0  1 

OpenFirmware/ofw/core/instcons.fth_AL	544 1A2ADE0 
hex
headerless
true value auto-banner?
1A2ADE0 	 0  0  0 61 75 74 6F 2D 
1A2ADE8 	62 61 6E 6E 65 72 3F 8C 
1A2ADF0 	AC AC A2  1 50 40 A0  1 
1A2ADF8 	C0  8  0  0 

headers
: suppress-banner  ( -- )  false to auto-banner?  ;
1A2ADFC 	73 75 70 70 
1A2AE00 	72 65 73 73 2D 62 61 6E 
1A2AE08 	6E 65 72 8F F4 AD A2  1 
1A2AE10 	20 40 A0  1 18 70 A0  1 
1A2AE18 	B8 40 A0  1 F4 AD A2  1 
1A2AE20 	58 46 A0  1 

 false value oem-banner?
1A2AE24 	6F 65 6D 2D 
1A2AE28 	62 61 6E 6E 65 72 3F 8B 
1A2AE30 	10 AE A2  1 50 40 A0  1 
1A2AE38 	C4  8  0  0 
" "  d# 80  config-string oem-banner
1A2AE3C 	 0 6F 65 6D 
1A2AE40 	2D 62 61 6E 6E 65 72 8A 
1A2AE48 	 0 AC A2  1  0  0  0  0 
1A2AE50 	C8  8  0 40  4  0  0  0 
1A2AE58 	 0  0  0  0 

false config-flag oem-logo?
1A2AE5C 	 0  0 6F 65 
1A2AE60 	6D 2D 6C 6F 67 6F 3F 89 
1A2AE68 	4C AE A2  1  0  0  0  0 
1A2AE70 	CC  8  0 40  0  0  0  0 

headerless

d# 128 constant max-logo-width
1A2AE78 	 0 6D 61 78 2D 6C 6F 67 
1A2AE80 	6F 2D 77 69 64 74 68 8E 
1A2AE88 	34 AE A2  1 68 40 A0  1 
1A2AE90 	80  0  0  0 

defer .firmware  ' noop to .firmware
1A2AE94 	 0  0 2E 66 
1A2AE98 	69 72 6D 77 61 72 65 89 
1A2AEA0 	8C AE A2  1 5C 40 A0  1 
1A2AEA8 	D0  8  0  0 

: memory-size ( -- #megs )
1A2AEAC 	6D 65 6D 6F 
1A2AEB0 	72 79 2D 73 69 7A 65 8B 
1A2AEB8 	A4 AE A2  1 20 40 A0  1 
   " size" memory-node @ $call-method 1meg um/mod nip
1A2AEC0 	9C 53 A0  1  4 73 69 7A 
1A2AEC8 	65  0  0  0 58 7E A2  1 
1A2AED0 	5C 4C A0  1 B4 31 A2  1 
1A2AED8 	B8 6E A2  1 7C 5D A0  1 
1A2AEE0 	FC 46 A0  1 
;
1A2AEE4 	58 46 A0  1 
: .memory  ( -- )
1A2AEE8 	2E 6D 65 6D 6F 72 79 87 
1A2AEF0 	BC AE A2  1 20 40 A0  1 
   memory-size dup d# 1024 / ?dup  if  ( mb gb )
1A2AEF8 	BC AE A2  1 40 49 A0  1 
1A2AF00 	58 41 A0  1  0  4  0  0 
1A2AF08 	98 5F A0  1 B4 70 A0  1 
1A2AF10 	DC 41 A0  1 20  0  0  0 
      nip " GiB" rot                   ( gb$ gb )
1A2AF18 	FC 46 A0  1 9C 53 A0  1 
1A2AF20 	 3 47 69 42  0  0  0  0 
1A2AF28 	7C 49 A0  1 
   else                                ( mb )
1A2AF2C 	C8 41 A0  1 
1A2AF30 	14  0  0  0 
      " MiB" rot                       ( mb$ mb )
1A2AF34 	9C 53 A0  1 
1A2AF38 	 3 4D 69 42  0  0  0  0 
1A2AF40 	7C 49 A0  1 
   then                                ( m$ m )
   .d  type ."  memory installed"      ( )
1A2AF44 	48  E A1  1 
1A2AF48 	 4 6C A0  1 20 7C A0  1 
1A2AF50 	11 20 6D 65 6D 6F 72 79 
1A2AF58 	20 69 6E 73 74 61 6C 6C 
1A2AF60 	65 64  0  0 
;
1A2AF64 	58 46 A0  1 
: .serial  ( -- )
1A2AF68 	2E 73 65 72 69 61 6C 87 
1A2AF70 	F4 AE A2  1 20 40 A0  1 
   push-decimal  ." Serial #"  serial# (.) type
1A2AF78 	48 F4 A0  1 20 7C A0  1 
1A2AF80 	 8 53 65 72 69 61 6C 20 
1A2AF88 	23  0  0  0 B0 E3 A1  1 
1A2AF90 	10 78 A0  1  4 6C A0  1 
   \   ." ."
   pop-base
1A2AF98 	9C F4 A0  1 
;
1A2AF9C 	58 46 A0  1 

variable logo?
1A2AFA0 	 0  0 6C 6F 67 6F 3F 85 
1A2AFA8 	74 AF A2  1 48 40 A0  1 
1A2AFB0 	D4  8  0  0 
: ?spaces  ( -- )
1A2AFB4 	3F 73 70 61 
1A2AFB8 	63 65 73 87 AC AF A2  1 
1A2AFC0 	20 40 A0  1 
   logo? @  if  max-logo-width  stdout-char-width  / 2+  spaces  then
1A2AFC4 	AC AF A2  1 
1A2AFC8 	5C 4C A0  1 DC 41 A0  1 
1A2AFD0 	18  0  0  0 8C AE A2  1 
1A2AFD8 	44 A2 A2  1 98 5F A0  1 
1A2AFE0 	40 4B A0  1 E8 71 A0  1 
;
1A2AFE8 	58 46 A0  1 


: display?  ( -- flag )
1A2AFEC 	 0  0  0 64 
1A2AFF0 	69 73 70 6C 61 79 3F 88 
1A2AFF8 	C0 AF A2  1 20 40 A0  1 
   stdout @  if
1A2B000 	68 55 A2  1 5C 4C A0  1 
1A2B008 	DC 41 A0  1 50  0  0  0 
      " device_type"  stdout @  ihandle>phandle  get-package-property  0= if
1A2B010 	9C 53 A0  1  B 64 65 76 
1A2B018 	69 63 65 5F 74 79 70 65 
1A2B020 	 0  0  0  0 68 55 A2  1 
1A2B028 	5C 4C A0  1  0 32 A2  1 
1A2B030 	98 33 A2  1 24 47 A0  1 
1A2B038 	DC 41 A0  1 20  0  0  0 
         ( adr len )  get-encoded-string  " display"  $= exit
1A2B040 	24 F7 A1  1 9C 53 A0  1 
1A2B048 	 7 64 69 73 70 6C 61 79 
1A2B050 	 0  0  0  0 88 8D A0  1 
1A2B058 	40 46 A0  1 
      then
   then
   false
1A2B05C 	18 70 A0  1 
;
1A2B060 	58 46 A0  1 

: cpu-model  ( -- adr len )
1A2B064 	 0  0 63 70 
1A2B068 	75 2D 6D 6F 64 65 6C 89 
1A2B070 	FC AF A2  1 20 40 A0  1 
   current-device >r  root-device
1A2B078 	40 F9 A1  1 BC 45 A0  1 
1A2B080 	1C 11 A2  1 
   " banner-name" get-property  if  " model" get-property  else  false  then
1A2B084 	9C 53 A0  1 
1A2B088 	 B 62 61 6E 6E 65 72 2D 
1A2B090 	6E 61 6D 65  0  0  0  0 
1A2B098 	F4  D A2  1 DC 41 A0  1 
1A2B0A0 	1C  0  0  0 9C 53 A0  1 
1A2B0A8 	 5 6D 6F 64 65 6C  0  0 
1A2B0B0 	F4  D A2  1 C8 41 A0  1 
1A2B0B8 	 8  0  0  0 18 70 A0  1 
   r> push-device  if  " "  else  get-encoded-string  then
1A2B0C0 	D0 45 A0  1 F8 FB A1  1 
1A2B0C8 	DC 41 A0  1 14  0  0  0 
1A2B0D0 	9C 53 A0  1  0  0  0  0 
1A2B0D8 	C8 41 A0  1  8  0  0  0 
1A2B0E0 	24 F7 A1  1 
;
1A2B0E4 	58 46 A0  1 


: .built  ( -- )
1A2B0E8 	 0 2E 62 75 69 6C 74 86 
1A2B0F0 	74 B0 A2  1 20 40 A0  1 
   " build-date" $find  if
1A2B0F8 	9C 53 A0  1  A 62 75 69 
1A2B100 	6C 64 2D 64 61 74 65  0 
1A2B108 	C4 93 A0  1 DC 41 A0  1 
1A2B110 	20  0  0  0 
      ." Built " execute type
1A2B114 	20 7C A0  1 
1A2B118 	 6 42 75 69 6C 74 20  0 
1A2B120 	98 41 A0  1  4 6C A0  1 
   else
1A2B128 	C8 41 A0  1  8  0  0  0 
      2drop
1A2B130 	AC 49 A0  1 
   then
;
1A2B134 	58 46 A0  1 
: .version  ( -- )
1A2B138 	 0  0  0 2E 76 65 72 73 
1A2B140 	69 6F 6E 88 F4 B0 A2  1 
1A2B148 	20 40 A0  1 
   " /openprom" find-package  if
1A2B14C 	9C 53 A0  1 
1A2B150 	 9 2F 6F 70 65 6E 70 72 
1A2B158 	6F 6D  0  0 E0 39 A2  1 
1A2B160 	DC 41 A0  1 30  0  0  0 
      " model"  rot get-package-property  0=  if
1A2B168 	9C 53 A0  1  5 6D 6F 64 
1A2B170 	65 6C  0  0 7C 49 A0  1 
1A2B178 	98 33 A2  1 24 47 A0  1 
1A2B180 	DC 41 A0  1 10  0  0  0 
         get-encoded-string  type cr
1A2B188 	24 F7 A1  1  4 6C A0  1 
1A2B190 	80 6D A0  1 
      then
   then
   .built cr
1A2B194 	F4 B0 A2  1 
1A2B198 	80 6D A0  1 
;
1A2B19C 	58 46 A0  1 

OpenFirmware/ofw/core/banner.fth_AL	3C0 1A2B1A0 purpose: Register access words

\ These versions of the "r" words treat addresses in the top 64K
\ as I/O addresses, performing I/O cycles instead of memory cycles.

\ Equivalent to:
\ : rb@  ( adr -- b )
\    dup h# ffff.0000 u>=  if  h# ffff and pc@  else  c@  then
\ ;

code rb@  ( adr -- b )
1A2B1A0 	72 62 40 83 48 B1 A2  1 
1A2B1A8 	AC B1 A2  1 
   dx pop
1A2B1AC 	5A 
   ax  ax  xor
1A2B1AD 	31 C0 
   h# ffff0000 #  dx  cmp
1A2B1AF 	81 
1A2B1B0 	FA  0  0 FF FF 
   u>=  if
1A2B1B5 	72  9 
      h# ffff #  dx  and
1A2B1B7 	81 
1A2B1B8 	E2 FF FF  0  0 
      dx  al  in
1A2B1BD 	EC 
   else
1A2B1BE 	EB  2 
      0 [dx]  al  mov
1A2B1C0 	8A  2 
   then
   ax push
1A2B1C2 	50 
c;
1A2B1C3 	FF E7 
code rw@  ( adr -- w )
1A2B1C5 	 0  0  0 
1A2B1C8 	72 77 40 83 A8 B1 A2  1 
1A2B1D0 	D4 B1 A2  1 
   dx pop
1A2B1D4 	5A 
   ax  ax  xor
1A2B1D5 	31 C0 
   h# ffff0000 #  dx  cmp
1A2B1D7 	81 
1A2B1D8 	FA  0  0 FF FF 
   u>=  if
1A2B1DD 	72  A 
      h# ffff #  dx  and
1A2B1DF 	81 
1A2B1E0 	E2 FF FF  0  0 
      op:  dx  ax  in
1A2B1E5 	66 ED 
   else
1A2B1E7 	EB 
1A2B1E8 	 3 
      op:  0 [dx]  ax  mov
1A2B1E9 	66 8B  2 
   then
   ax push
1A2B1EC 	50 
c;
1A2B1ED 	FF E7 
code rl@  ( adr -- l )
1A2B1EF 	 0 
1A2B1F0 	72 6C 40 83 D0 B1 A2  1 
1A2B1F8 	FC B1 A2  1 
   dx pop
1A2B1FC 	5A 
   h# ffff0000 #  dx  cmp
1A2B1FD 	81 FA  0 
1A2B200 	 0 FF FF 
   u>=  if
1A2B203 	72  9 
      h# ffff #  dx  and
1A2B205 	81 E2 FF 
1A2B208 	FF  0  0 
      dx  ax  in
1A2B20B 	ED 
   else
1A2B20C 	EB  2 
      0 [dx]  ax  mov
1A2B20E 	8B  2 
   then
   ax push
1A2B210 	50 
c;
1A2B211 	FF E7 
code rb!  ( b adr -- )
1A2B213 	 0 72 62 21 83 
1A2B218 	F8 B1 A2  1 20 B2 A2  1 
   dx pop
1A2B220 	5A 
   ax pop
1A2B221 	58 
   h# ffff0000 #  dx  cmp
1A2B222 	81 FA  0  0 FF FF 
   u>=  if
1A2B228 	72  9 
      h# ffff #  dx  and
1A2B22A 	81 E2 FF FF  0  0 
      al  dx  out
1A2B230 	EE 
   else
1A2B231 	EB  2 
      al  0 [dx]  mov
1A2B233 	88  2 
   then
c;
1A2B235 	FF E7 
code rw!  ( w adr -- )
1A2B237 	 0 
1A2B238 	72 77 21 83 1C B2 A2  1 
1A2B240 	44 B2 A2  1 
   dx pop
1A2B244 	5A 
   ax pop
1A2B245 	58 
   h# ffff0000 #  dx  cmp
1A2B246 	81 FA 
1A2B248 	 0  0 FF FF 
   u>=  if
1A2B24C 	72  A 
      h# ffff #  dx  and
1A2B24E 	81 E2 
1A2B250 	FF FF  0  0 
      op:  ax  dx  out
1A2B254 	66 EF 
   else
1A2B256 	EB  3 
      op:  ax  0 [dx]  mov
1A2B258 	66 89  2 
   then
c;
1A2B25B 	FF E7 
code rl!  ( l adr -- )
1A2B25D 	 0  0  0 
1A2B260 	72 6C 21 83 40 B2 A2  1 
1A2B268 	6C B2 A2  1 
   dx pop
1A2B26C 	5A 
   ax pop
1A2B26D 	58 
   h# ffff0000 #  dx  cmp
1A2B26E 	81 FA 
1A2B270 	 0  0 FF FF 
   u>=  if
1A2B274 	72  9 
      h# ffff #  dx  and
1A2B276 	81 E2 
1A2B278 	FF FF  0  0 
      ax  dx  out
1A2B27C 	EF 
   else
1A2B27D 	EB  2 
      ax  0 [dx]  mov
1A2B27F 	89 
1A2B280 	 2 
   then
c;
1A2B281 	FF E7 

OpenFirmware/cpu/x86/regacc.fth_AL	E3 1A2B283 
propset=1A2B2F8 B441E8D 1A00918 
vocset=B441E8D 1A00918 1A2B2F8 
new-node=B441EA1 1A008F8 
vocset=B441EA1 1A008F8 1A2B2F8 1A2B314 1A2B32C purpose: Setup for FAT file system

support-package: fat-file-system
1A2B2E4 	E0 B6 A0  1 
1A2B2E8 	D8  8  0  0 C8 50 A2  1 
1A2B2F0 	E0 B6 A0  1 F8  8  0  0 
1A2B2F8 	66 61 74 2D 66 69 6C 65 
1A2B300 	2D 73 79 73 74 65 6D  0 
1A2B308 	 0  0  0 6E 61 6D 65 84 
1A2B310 	 0  0 A0  1 BC 13 A2  1 
1A2B318 	20  0  0  0 10  0  0  0 

0 0  " support" property
1A2B320 	73 75 70 70 6F 72 74 87 
1A2B328 	14 B3 A2  1 BC 13 A2  1 
1A2B330 	30 B3 A2  1  0  0  0  0 

transient
\ mmo : private  headerless  ;
\ mmo : internal headerless  ;
\ mmo : public   headers     ;
resident

\ mmo private
/fd instance buffer: dos-fd		\ Forthmacs file descriptor
1A2B338 	 0 64 6F 73 2D 66 64 86 
1A2B340 	 0  0 A0  1 4C  0 A2  1 
1A2B348 	4C FF FF FF 

: 1+!  1 swap +!  ;
1A2B34C 	31 2B 21 83 
1A2B350 	44 B3 A2  1 20 40 A0  1 
1A2B358 	80 6F A0  1 68 49 A0  1 
1A2B360 	 C 4C A0  1 58 46 A0  1 

create "cao ,"  Can't open "
1A2B368 	 0  0  0 22 63 61 6F 84 
1A2B370 	54 B3 A2  1 30 40 A0  1 
1A2B378 	 C 20 43 61 6E 27 74 20 
1A2B380 	6F 70 65 6E 20  0  0  0 
create "cac ,"  Can't create "
1A2B388 	 0  0  0 22 63 61 63 84 
1A2B390 	74 B3 A2  1 30 40 A0  1 
1A2B398 	 E 20 43 61 6E 27 74 20 
1A2B3A0 	63 72 65 61 74 65 20  0 
create "car ,"  Can't read "
1A2B3A8 	 0  0  0 22 63 61 72 84 
1A2B3B0 	94 B3 A2  1 30 40 A0  1 
1A2B3B8 	 C 20 43 61 6E 27 74 20 
1A2B3C0 	72 65 61 64 20  0  0  0 
create "caw ,"  Can't write "
1A2B3C8 	 0  0  0 22 63 61 77 84 
1A2B3D0 	B4 B3 A2  1 30 40 A0  1 
1A2B3D8 	 D 20 43 61 6E 27 74 20 
1A2B3E0 	77 72 69 74 65 20  0  0 
create "cad ,"  Can't delete "
1A2B3E8 	 0  0  0 22 63 61 64 84 
1A2B3F0 	D4 B3 A2  1 30 40 A0  1 
1A2B3F8 	 E 20 43 61 6E 27 74 20 
1A2B400 	64 65 6C 65 74 65 20  0 
create "cof ,"  Couldn't find "
1A2B408 	 0  0  0 22 63 6F 66 84 
1A2B410 	F4 B3 A2  1 30 40 A0  1 
1A2B418 	 F 20 43 6F 75 6C 64 6E 
1A2B420 	27 74 20 66 69 6E 64 20 
1A2B428 	 0  0  0  0 
create "dir ," directory "
1A2B42C 	 0  0  0 22 
1A2B430 	64 69 72 84 14 B4 A2  1 
1A2B438 	30 40 A0  1  A 64 69 72 
1A2B440 	65 63 74 6F 72 79 20  0 

[ifdef] dos-ui
alias \40 \
alias \20 \

\ Display management
: (dark ;  : (light ;


\ For floppy formatting

: 2ed-den ;	\ Select 2.88 MB density for formatting
: 2hd-den ;	\ Select 1.44 MB density for formatting
: init-floppy  ;
: track-format  ( track# -- )  ." Trying to format track " . (cr  ;
[then]

alias dos-lock   noop
1A2B448 	 0  0  0 64 6F 73 2D 6C 
1A2B450 	6F 63 6B A8 38 B4 A2  1 
1A2B458 	64 4F A0  1 
alias dos-unlock noop
1A2B45C 	 0 64 6F 73 
1A2B460 	2D 75 6E 6C 6F 63 6B AA 
1A2B468 	58 B4 A2  1 64 4F A0  1 
\

OpenFirmware/ofw/fs/fatfs/setup.fth_AL	18C 1A2B470 \ "Little-endian" memory operations.  The least-significant byte is
\ stored at the lowest address.  "Intel byte order".

\ mmo private

: lew@  ( adr -- w )  dup c@  swap 1+ c@  bwjoin  ;
1A2B470 	 0  0  0 6C 65 77 40 84 
1A2B478 	6C B4 A2  1 20 40 A0  1 
1A2B480 	40 49 A0  1 C4 4C A0  1 
1A2B488 	68 49 A0  1 30 4B A0  1 
1A2B490 	C4 4C A0  1 84 FB A0  1 
1A2B498 	58 46 A0  1 
: lew!  ( w adr -- )  2dup c!  swap 8 >> swap 1+ c!  ;
1A2B49C 	 0  0  0 6C 
1A2B4A0 	65 77 21 84 7C B4 A2  1 
1A2B4A8 	20 40 A0  1 C0 49 A0  1 
1A2B4B0 	B8 4D A0  1 68 49 A0  1 
1A2B4B8 	F0 6F A0  1 DC 44 A0  1 
1A2B4C0 	68 49 A0  1 30 4B A0  1 
1A2B4C8 	B8 4D A0  1 58 46 A0  1 
: lel@  ( adr -- l )  dup lew@ swap 2+ lew@ wljoin  ;
1A2B4D0 	 0  0  0 6C 65 6C 40 84 
1A2B4D8 	A8 B4 A2  1 20 40 A0  1 
1A2B4E0 	40 49 A0  1 7C B4 A2  1 
1A2B4E8 	68 49 A0  1 40 4B A0  1 
1A2B4F0 	7C B4 A2  1 D4 4F A0  1 
1A2B4F8 	58 46 A0  1 
: lel!  ( l adr -- )  >r lwsplit r@ 2+ lew! r> lew!  ;
1A2B4FC 	 0  0  0 6C 
1A2B500 	65 6C 21 84 DC B4 A2  1 
1A2B508 	20 40 A0  1 BC 45 A0  1 
1A2B510 	A0 4F A0  1 E4 45 A0  1 
1A2B518 	40 4B A0  1 A8 B4 A2  1 
1A2B520 	D0 45 A0  1 A8 B4 A2  1 
1A2B528 	58 46 A0  1 

\ Fetches 3 consecutive bytes in Intel byte order - least significant
\ at the lowest address
: le24@  ( adr -- l )  >r  r@ c@  r@ 1+ c@  r> 2+ c@  0 bljoin  ;
1A2B52C 	 0  0 6C 65 
1A2B530 	32 34 40 85  8 B5 A2  1 
1A2B538 	20 40 A0  1 BC 45 A0  1 
1A2B540 	E4 45 A0  1 C4 4C A0  1 
1A2B548 	E4 45 A0  1 30 4B A0  1 
1A2B550 	C4 4C A0  1 D0 45 A0  1 
1A2B558 	40 4B A0  1 C4 4C A0  1 
1A2B560 	70 6F A0  1 DC FB A0  1 
1A2B568 	58 46 A0  1 

\ Stores 3 consecutive bytes in Intel byte order - least significant
\ at the lowest address
: le24!  ( l adr -- )  >r lbsplit drop  r@ 2+ c!  r@ 1+ c!  r> c!  ;
1A2B56C 	 0  0 6C 65 
1A2B570 	32 34 21 85 38 B5 A2  1 
1A2B578 	20 40 A0  1 BC 45 A0  1 
1A2B580 	B4 FB A0  1 30 49 A0  1 
1A2B588 	E4 45 A0  1 40 4B A0  1 
1A2B590 	B8 4D A0  1 E4 45 A0  1 
1A2B598 	30 4B A0  1 B8 4D A0  1 
1A2B5A0 	D0 45 A0  1 B8 4D A0  1 
1A2B5A8 	58 46 A0  1 

OpenFirmware/ofw/fs/fatfs/leops.fth_AL	13C 1A2B5AC purpose: Convert date and time to DOS packed format

: >hms  ( dos-packed-time -- secs mins hours )
1A2B5AC 	 0  0  0 3E 
1A2B5B0 	68 6D 73 84 78 B5 A2  1 
1A2B5B8 	20 40 A0  1 
   dup h#   1f and      2*   swap  ( secs packed )
1A2B5BC 	40 49 A0  1 
1A2B5C0 	58 41 A0  1 1F  0  0  0 
1A2B5C8 	5C 44 A0  1 A0 4B A0  1 
1A2B5D0 	68 49 A0  1 
   dup h# 07e0 and      5 >> swap  ( secs mins packed )
1A2B5D4 	40 49 A0  1 
1A2B5D8 	58 41 A0  1 E0  7  0  0 
1A2B5E0 	5C 44 A0  1 C0 6F A0  1 
1A2B5E8 	DC 44 A0  1 68 49 A0  1 
       h# f800 and  d# 11 >>       ( secs mins hours )
1A2B5F0 	58 41 A0  1  0 F8  0  0 
1A2B5F8 	5C 44 A0  1 58 41 A0  1 
1A2B600 	 B  0  0  0 DC 44 A0  1 
;  
1A2B608 	58 46 A0  1 
: hms>  ( secs mins hours -- dos-packed-time )
1A2B60C 	 0  0  0 68 
1A2B610 	6D 73 3E 84 B8 B5 A2  1 
1A2B618 	20 40 A0  1 
   d# 11 << h# f800 and swap      ( secs packed mins )
1A2B61C 	58 41 A0  1 
1A2B620 	 B  0  0  0 C8 44 A0  1 
1A2B628 	58 41 A0  1  0 F8  0  0 
1A2B630 	5C 44 A0  1 68 49 A0  1 
       5 << h# 07e0 and + swap    ( packed secs )
1A2B638 	C0 6F A0  1 C8 44 A0  1 
1A2B640 	58 41 A0  1 E0  7  0  0 
1A2B648 	5C 44 A0  1  4 45 A0  1 
1A2B650 	68 49 A0  1 
         2/ h# 001f and +         ( packed )
1A2B654 	78 4B A0  1 
1A2B658 	58 41 A0  1 1F  0  0  0 
1A2B660 	5C 44 A0  1  4 45 A0  1 
;
1A2B668 	58 46 A0  1 
: >dmy  ( dos-packed-date -- day month year )
1A2B66C 	 0  0  0 3E 
1A2B670 	64 6D 79 84 18 B6 A2  1 
1A2B678 	20 40 A0  1 
   dup h#   1f and          swap   ( day packed )
1A2B67C 	40 49 A0  1 
1A2B680 	58 41 A0  1 1F  0  0  0 
1A2B688 	5C 44 A0  1 68 49 A0  1 
   dup h# 01e0 and  5 >>    swap   ( day month packed )
1A2B690 	40 49 A0  1 58 41 A0  1 
1A2B698 	E0  1  0  0 5C 44 A0  1 
1A2B6A0 	C0 6F A0  1 DC 44 A0  1 
1A2B6A8 	68 49 A0  1 
       h# fe00 and  9 >> d# 1980 + ( day month year )
1A2B6AC 	58 41 A0  1 
1A2B6B0 	 0 FE  0  0 5C 44 A0  1 
1A2B6B8 	58 41 A0  1  9  0  0  0 
1A2B6C0 	DC 44 A0  1 58 41 A0  1 
1A2B6C8 	BC  7  0  0  4 45 A0  1 
;  
1A2B6D0 	58 46 A0  1 
: dmy>  ( day month year -- dos-packed-date )
1A2B6D4 	 0  0  0 64 
1A2B6D8 	6D 79 3E 84 78 B6 A2  1 
1A2B6E0 	20 40 A0  1 
   d# 1980 -
1A2B6E4 	58 41 A0  1 
1A2B6E8 	BC  7  0  0 18 45 A0  1 
   9 << h# fe00 and   swap    ( day packed month )
1A2B6F0 	58 41 A0  1  9  0  0  0 
1A2B6F8 	C8 44 A0  1 58 41 A0  1 
1A2B700 	 0 FE  0  0 5C 44 A0  1 
1A2B708 	68 49 A0  1 
   5 << h# 01e0 and + swap    ( packed day )
1A2B70C 	C0 6F A0  1 
1A2B710 	C8 44 A0  1 58 41 A0  1 
1A2B718 	E0  1  0  0 5C 44 A0  1 
1A2B720 	 4 45 A0  1 68 49 A0  1 
        h# 001f and +         ( packed )
1A2B728 	58 41 A0  1 1F  0  0  0 
1A2B730 	5C 44 A0  1  4 45 A0  1 
;
1A2B738 	58 46 A0  1 

OpenFirmware/ofw/fs/fatfs/dosdate.fth_AL	190 1A2B73C purpose: Data structures describing the overall media layout parameters

hex

\ DOS 2.x and 3.2 and Windows 95 BIOS Parameter Block

\ mmo private

variable bpb
1A2B73C 	62 70 62 83 
1A2B740 	E0 B6 A2  1 48 40 A0  1 
1A2B748 	FC  8  0  0 

: bfield  \ name  ( bpb-offset size -- bpb-offset' )
1A2B74C 	 0 62 66 69 
1A2B750 	65 6C 64 86 44 B7 A2  1 
1A2B758 	20 40 A0  1 
   create over , +   does>  @ bpb @ +
1A2B75C 	A8 A2 A0  1 
1A2B760 	54 49 A0  1 98 55 A0  1 
1A2B768 	 4 45 A0  1 50 A3 A0  1 
1A2B770 	90 90 90 E8  4 89 FD FF 
1A2B778 	5C 4C A0  1 44 B7 A2  1 
1A2B780 	5C 4C A0  1  4 45 A0  1 
;
1A2B788 	58 46 A0  1 

struct  \ bpb
   3 bfield bp_branch	\  0  "branch to boot code" instruction 
1A2B78C 	 0  0 62 70 
1A2B790 	5F 62 72 61 6E 63 68 89 
1A2B798 	58 B7 A2  1 70 B7 A2  1 
1A2B7A0 	 0  0  0  0 
   8 bfield bp_name	\  3  System name
1A2B7A4 	62 70 5F 6E 
1A2B7A8 	61 6D 65 87 9C B7 A2  1 
1A2B7B0 	70 B7 A2  1  3  0  0  0 
   2 bfield bp_bps	\  b  bytes/sector        (leword)
1A2B7B8 	 0 62 70 5F 62 70 73 86 
1A2B7C0 	B0 B7 A2  1 70 B7 A2  1 
1A2B7C8 	 B  0  0  0 
   1 bfield bp_spc	\  d  sectors/cluster
1A2B7CC 	 0 62 70 5F 
1A2B7D0 	73 70 63 86 C4 B7 A2  1 
1A2B7D8 	70 B7 A2  1  D  0  0  0 
   2 bfield bp_res	\  e  #reserved-sectors   (leword)
1A2B7E0 	 0 62 70 5F 72 65 73 86 
1A2B7E8 	D8 B7 A2  1 70 B7 A2  1 
1A2B7F0 	 E  0  0  0 
   1 bfield bp_nfats	\ 10  #FATs
1A2B7F4 	 0  0  0 62 
1A2B7F8 	70 5F 6E 66 61 74 73 88 
1A2B800 	EC B7 A2  1 70 B7 A2  1 
1A2B808 	10  0  0  0 
   2 bfield bp_ndirs	\ 11  #directory-entries  (leword)
1A2B80C 	 0  0  0 62 
1A2B810 	70 5F 6E 64 69 72 73 88 
1A2B818 	 4 B8 A2  1 70 B7 A2  1 
1A2B820 	11  0  0  0 
   2 bfield bp_nsects	\ 13  total-#sectors (with reserved) (leword)
1A2B824 	 0  0 62 70 
1A2B828 	5F 6E 73 65 63 74 73 89 
1A2B830 	1C B8 A2  1 70 B7 A2  1 
1A2B838 	13  0  0  0 
   1 bfield bp_media	\ 15  media descriptor ("magic" number)
1A2B83C 	 0  0  0 62 
1A2B840 	70 5F 6D 65 64 69 61 88 
1A2B848 	34 B8 A2  1 70 B7 A2  1 
1A2B850 	15  0  0  0 
   2 bfield bp_spf	\ 16  sectors/FAT         (leword)
1A2B854 	 0 62 70 5F 
1A2B858 	73 70 66 86 4C B8 A2  1 
1A2B860 	70 B7 A2  1 16  0  0  0 
   2 bfield bp_spt	\ 18  sectors/track       (leword)
1A2B868 	 0 62 70 5F 73 70 74 86 
1A2B870 	60 B8 A2  1 70 B7 A2  1 
1A2B878 	18  0  0  0 
   2 bfield bp_nsides	\ 1a  #sides (#heads)     (leword)
1A2B87C 	 0  0 62 70 
1A2B880 	5F 6E 73 69 64 65 73 89 
1A2B888 	74 B8 A2  1 70 B7 A2  1 
1A2B890 	1A  0  0  0 
   4 bfield bp_nhid	\ 1c  #hidden-sectors                  (lelong)
1A2B894 	62 70 5F 6E 
1A2B898 	68 69 64 87 8C B8 A2  1 
1A2B8A0 	70 B7 A2  1 1C  0  0  0 
   4 bfield bp_xnsects	\ 20  total#sectors if bp_nsects is 0  (lelong)
1A2B8A8 	 0 62 70 5F 78 6E 73 65 
1A2B8B0 	63 74 73 8A A0 B8 A2  1 
1A2B8B8 	70 B7 A2  1 20  0  0  0 

   \ Windows95 FAT32 BPB entries
   4 bfield bp_bspf	\ 24  big sectors/FAT	  (lelong)
1A2B8C0 	62 70 5F 62 73 70 66 87 
1A2B8C8 	B8 B8 A2  1 70 B7 A2  1 
1A2B8D0 	24  0  0  0 
   2 bfield bp_flags	\ 28  extended flags	  (leword)
1A2B8D4 	 0  0  0 62 
1A2B8D8 	70 5F 66 6C 61 67 73 88 
1A2B8E0 	CC B8 A2  1 70 B7 A2  1 
1A2B8E8 	28  0  0  0 
   2 bfield bp_fsver	\ 2a  file system version (leword)
1A2B8EC 	 0  0  0 62 
1A2B8F0 	70 5F 66 73 76 65 72 88 
1A2B8F8 	E4 B8 A2  1 70 B7 A2  1 
1A2B900 	2A  0  0  0 
   4 bfield bp_rdirclus	\ 2c  root directory starting cluster  (lelong)
1A2B904 	62 70 5F 72 
1A2B908 	64 69 72 63 6C 75 73 8B 
1A2B910 	FC B8 A2  1 70 B7 A2  1 
1A2B918 	2C  0  0  0 
   2 bfield bp_fsinfos	\ 30  file system info sector	       (leword)
1A2B91C 	 0 62 70 5F 
1A2B920 	66 73 69 6E 66 6F 73 8A 
1A2B928 	14 B9 A2  1 70 B7 A2  1 
1A2B930 	30  0  0  0 
   2 bfield bp_bkboots	\ 32  backup boot sector  (leword)
1A2B934 	 0 62 70 5F 
1A2B938 	62 6B 62 6F 6F 74 73 8A 
1A2B940 	2C B9 A2  1 70 B7 A2  1 
1A2B948 	32  0  0  0 
   c bfield bp_reserved	\ 34  reserved
1A2B94C 	62 70 5F 72 
1A2B950 	65 73 65 72 76 65 64 8B 
1A2B958 	44 B9 A2  1 70 B7 A2  1 
1A2B960 	34  0  0  0 
   
   \ The rest of the sector contains boot code, and a magic number (55aa)
   \ in the last 2 bytes.  (aa is in the last byte).
aligned
constant   /bpb
1A2B964 	 0  0  0 2F 
1A2B968 	62 70 62 84 5C B9 A2  1 
1A2B970 	68 40 A0  1 40  0  0  0 

create fssignature0 h# 52 c, h# 52 c, h# 61 c, h# 41 c,
1A2B978 	 0  0  0 66 73 73 69 67 
1A2B980 	6E 61 74 75 72 65 30 8C 
1A2B988 	70 B9 A2  1 30 40 A0  1 
1A2B990 	52 52 61 41 
create fssignature  h# 72 c, h# 72 c, h# 41 c, h# 61 c,
1A2B994 	66 73 73 69 
1A2B998 	67 6E 61 74 75 72 65 8B 
1A2B9A0 	8C B9 A2  1 30 40 A0  1 
1A2B9A8 	72 72 41 61 
variable fssector
1A2B9AC 	 0  0  0 66 
1A2B9B0 	73 73 65 63 74 6F 72 88 
1A2B9B8 	A4 B9 A2  1 48 40 A0  1 
1A2B9C0 	 0  9  0  0 
variable fsinfo
1A2B9C4 	 0 66 73 69 
1A2B9C8 	6E 66 6F 86 BC B9 A2  1 
1A2B9D0 	48 40 A0  1  4  9  0  0 

: fsfield  \ name  ( fsinfo-offset size -- fsinfo-offset' )
1A2B9D8 	66 73 66 69 65 6C 64 87 
1A2B9E0 	D0 B9 A2  1 20 40 A0  1 
   create over , +   does>  @ fsinfo @ +
1A2B9E8 	A8 A2 A0  1 54 49 A0  1 
1A2B9F0 	98 55 A0  1  4 45 A0  1 
1A2B9F8 	50 A3 A0  1 90 90 90 E8 
1A2BA00 	78 86 FD FF 5C 4C A0  1 
1A2BA08 	D0 B9 A2  1 5C 4C A0  1 
1A2BA10 	 4 45 A0  1 
;
1A2BA14 	58 46 A0  1 

struct  \ fsinfo
   /n fsfield fs_sig		\ signature
1A2BA18 	 0 66 73 5F 73 69 67 86 
1A2BA20 	E4 B9 A2  1 FC B9 A2  1 
1A2BA28 	 0  0  0  0 
   /n fsfield fs_#freeclusters	\ # of free clusters	(lelong)
1A2BA2C 	 0  0  0 66 
1A2BA30 	73 5F 23 66 72 65 65 63 
1A2BA38 	6C 75 73 74 65 72 73 90 
1A2BA40 	24 BA A2  1 FC B9 A2  1 
1A2BA48 	 4  0  0  0 
   /n fsfield fs_freecluster#	\ next free cluster #	(lelong)
1A2BA4C 	66 73 5F 66 
1A2BA50 	72 65 65 63 6C 75 73 74 
1A2BA58 	65 72 23 8F 44 BA A2  1 
1A2BA60 	FC B9 A2  1  8  0  0  0 
3 /n * fsfield fs_reserved
1A2BA68 	66 73 5F 72 65 73 65 72 
1A2BA70 	76 65 64 8B 60 BA A2  1 
1A2BA78 	FC B9 A2  1  C  0  0  0 
constant  /fsinfo
1A2BA80 	2F 66 73 69 6E 66 6F 87 
1A2BA88 	78 BA A2  1 68 40 A0  1 
1A2BA90 	18  0  0  0 
 
instance variable current-device  -1 current-device !
1A2BA94 	 0 63 75 72 
1A2BA98 	72 65 6E 74 2D 64 65 76 
1A2BAA0 	69 63 65 8E 8C BA A2  1 
1A2BAA8 	40  1 A2  1 18  0  0  0 

: dfield \ name ( dev-offset size -- dev-offset')
1A2BAB0 	 0 64 66 69 65 6C 64 86 
1A2BAB8 	A8 BA A2  1 20 40 A0  1 
   create over , +  does>  @ current-device @ +
1A2BAC0 	A8 A2 A0  1 54 49 A0  1 
1A2BAC8 	98 55 A0  1  4 45 A0  1 
1A2BAD0 	50 A3 A0  1 90 90 90 E8 
1A2BAD8 	A0 85 FD FF 5C 4C A0  1 
1A2BAE0 	A8 BA A2  1 5C 4C A0  1 
1A2BAE8 	 4 45 A0  1 
;
1A2BAEC 	58 46 A0  1 

struct \ device
/n dfield fat-cache         \ Address of the FAT cache for this device
1A2BAF0 	 0  0 66 61 74 2D 63 61 
1A2BAF8 	63 68 65 89 BC BA A2  1 
1A2BB00 	D4 BA A2  1  0  0  0  0 
/n dfield fat-sector        \ First sector of the FAT that is in the cache
1A2BB08 	 0 66 61 74 2D 73 65 63 
1A2BB10 	74 6F 72 8A  0 BB A2  1 
1A2BB18 	D4 BA A2  1  4  0  0  0 
/n dfield spf		    \ Sectors per fat     (from BPB)
1A2BB20 	73 70 66 83 18 BB A2  1 
1A2BB28 	D4 BA A2  1  8  0  0  0 
/n dfield rdirclus	    \ Root directory starting cluster
1A2BB30 	 0  0  0 72 64 69 72 63 
1A2BB38 	6C 75 73 88 28 BB A2  1 
1A2BB40 	D4 BA A2  1  C  0  0  0 
/n dfield max-cl#           \ last cluster on device (0.. ** 9/28/90 cpt)
1A2BB48 	6D 61 78 2D 63 6C 23 87 
1A2BB50 	40 BB A2  1 D4 BA A2  1 
1A2BB58 	10  0  0  0 
/n dfield cl-sector0        \ device relative start sector of cluster 0
1A2BB5C 	 0 63 6C 2D 
1A2BB60 	73 65 63 74 6F 72 30 8A 
1A2BB68 	54 BB A2  1 D4 BA A2  1 
1A2BB70 	14  0  0  0 
/n dfield dv_cwd-cl         \ Working directory starting cluster
1A2BB74 	 0  0 64 76 
1A2BB78 	5F 63 77 64 2D 63 6C 89 
1A2BB80 	6C BB A2  1 D4 BA A2  1 
1A2BB88 	18  0  0  0 
/w dfield sectors/fat-cache \ Size of the FAT cache for this device
1A2BB8C 	 0  0 73 65 
1A2BB90 	63 74 6F 72 73 2F 66 61 
1A2BB98 	74 2D 63 61 63 68 65 91 
1A2BBA0 	84 BB A2  1 D4 BA A2  1 
1A2BBA8 	1C  0  0  0 
/w dfield fat-dirty         \ Does the FAT need to be flushed to disk?
1A2BBAC 	 0  0 66 61 
1A2BBB0 	74 2D 64 69 72 74 79 89 
1A2BBB8 	A4 BB A2  1 D4 BA A2  1 
1A2BBC0 	1E  0  0  0 
/w dfield cl#/fat-cache     \ Number of cluster entries in the FAT cache
1A2BBC4 	 0  0 63 6C 
1A2BBC8 	23 2F 66 61 74 2D 63 61 
1A2BBD0 	63 68 65 8D BC BB A2  1 
1A2BBD8 	D4 BA A2  1 20  0  0  0 
/w dfield fat-sector0       \ device relative start sector of FAT 1
1A2BBE0 	66 61 74 2D 73 65 63 74 
1A2BBE8 	6F 72 30 8B D8 BB A2  1 
1A2BBF0 	D4 BA A2  1 22  0  0  0 
/w dfield dir-sector0       \ device relative start sector of root dir.
1A2BBF8 	64 69 72 2D 73 65 63 74 
1A2BC00 	6F 72 30 8B F0 BB A2  1 
1A2BC08 	D4 BA A2  1 24  0  0  0 
/w dfield #dir-sectors      \ of root directory
1A2BC10 	 0  0  0 23 64 69 72 2D 
1A2BC18 	73 65 63 74 6F 72 73 8C 
1A2BC20 	 8 BC A2  1 D4 BA A2  1 
1A2BC28 	26  0  0  0 
/w dfield bps		    \ Bytes per sector    (from BPB)
1A2BC2C 	62 70 73 83 
1A2BC30 	24 BC A2  1 D4 BA A2  1 
1A2BC38 	28  0  0  0 
/w dfield fsinfos	    \ File system info sector #  (from BPB)
1A2BC3C 	66 73 69 6E 
1A2BC40 	66 6F 73 87 34 BC A2  1 
1A2BC48 	D4 BA A2  1 2A  0  0  0 
/c dfield spc		    \ Sectors per cluster (from BPB)
1A2BC50 	73 70 63 83 48 BC A2  1 
1A2BC58 	D4 BA A2  1 2C  0  0  0 
/c dfield media		    \ Media type (f8 for hard disk, f0 for 3.5" floppy)
1A2BC60 	 0  0 6D 65 64 69 61 85 
1A2BC68 	58 BC A2  1 D4 BA A2  1 
1A2BC70 	2D  0  0  0 
/c dfield fat-type	    \ Bytes per cluster number
1A2BC74 	 0  0  0 66 
1A2BC78 	61 74 2D 74 79 70 65 88 
1A2BC80 	6C BC A2  1 D4 BA A2  1 
1A2BC88 	2E  0  0  0 
/c dfield fsinfos-dirty	    \ Does the file system info need to be written to disk?
1A2BC8C 	 0  0 66 73 
1A2BC90 	69 6E 66 6F 73 2D 64 69 
1A2BC98 	72 74 79 8D 84 BC A2  1 
1A2BCA0 	D4 BA A2  1 2F  0  0  0 
constant /device
1A2BCA8 	2F 64 65 76 69 63 65 87 
1A2BCB0 	A0 BC A2  1 68 40 A0  1 
1A2BCB8 	30  0  0  0 

d# 12 constant fat12
1A2BCBC 	 0  0 66 61 
1A2BCC0 	74 31 32 85 B4 BC A2  1 
1A2BCC8 	68 40 A0  1  C  0  0  0 
d# 16 constant fat16
1A2BCD0 	 0  0 66 61 74 31 36 85 
1A2BCD8 	C8 BC A2  1 68 40 A0  1 
1A2BCE0 	10  0  0  0 
d# 32 constant fat32
1A2BCE4 	 0  0 66 61 
1A2BCE8 	74 33 32 85 DC BC A2  1 
1A2BCF0 	68 40 A0  1 20  0  0  0 

: +fs-#free  ( incr -- )
1A2BCF8 	 0  0 2B 66 73 2D 23 66 
1A2BD00 	72 65 65 89 F0 BC A2  1 
1A2BD08 	20 40 A0  1 
   fs_#freeclusters  dup lel@                ( incr adr n )
1A2BD0C 	44 BA A2  1 
1A2BD10 	40 49 A0  1 DC B4 A2  1 
   dup h# ffffffff =  if  3drop exit  then   ( incr adr n )
1A2BD18 	40 49 A0  1 58 41 A0  1 
1A2BD20 	FF FF FF FF 24 48 A0  1 
1A2BD28 	DC 41 A0  1  C  0  0  0 
1A2BD30 	90 52 A0  1 40 46 A0  1 
   rot +  swap lel!
1A2BD38 	7C 49 A0  1  4 45 A0  1 
1A2BD40 	68 49 A0  1  8 B5 A2  1 
   true fsinfos-dirty c!
1A2BD48 	 4 70 A0  1 A0 BC A2  1 
1A2BD50 	B8 4D A0  1 
;
1A2BD54 	58 46 A0  1 
: fs-free#!  ( cluster# -- )  fs_freecluster# lel!  true fsinfos-dirty c!  ;
1A2BD58 	 0  0 66 73 2D 66 72 65 
1A2BD60 	65 23 21 89  8 BD A2  1 
1A2BD68 	20 40 A0  1 60 BA A2  1 
1A2BD70 	 8 B5 A2  1  4 70 A0  1 
1A2BD78 	A0 BC A2  1 B8 4D A0  1 
1A2BD80 	58 46 A0  1 



OpenFirmware/ofw/fs/fatfs/bpb.fth_AL	648 1A2BD84 \ Implementation of the device driver interface used by the DOS file
\ system code.  This file knows some details of both the underlying
\ device level and the DOS file level above.  It is responsible for
\ translating between those levels; for instance, it translates DOS
\ device numbers to the corresponding SCSI logical unit numbers.
\
\ Exports:
\
\   read-sectors   (S sector# #sectors addr -- error? )   Reads sectors
\   write-sectors  (S sector# #sectors addr -- error? )   Writes sectors
\   r/w-sectors  (S sector# #sectors addr lun read? -- error? )
\
\ Imports:
\   current-device

\ mmo private

: init-sector-size  ( -- )  " block-size" $call-parent  bps w!  ;
1A2BD84 	 0  0  0 69 
1A2BD88 	6E 69 74 2D 73 65 63 74 
1A2BD90 	6F 72 2D 73 69 7A 65 90 
1A2BD98 	68 BD A2  1 20 40 A0  1 
1A2BDA0 	9C 53 A0  1  A 62 6C 6F 
1A2BDA8 	63 6B 2D 73 69 7A 65  0 
1A2BDB0 	DC 31 A2  1 34 BC A2  1 
1A2BDB8 	A4 4D A0  1 58 46 A0  1 
: translate-params  (S sector# #sectors addr -- addr #bytes )
1A2BDC0 	 0  0  0 74 72 61 6E 73 
1A2BDC8 	6C 61 74 65 2D 70 61 72 
1A2BDD0 	61 6D 73 90 9C BD A2  1 
1A2BDD8 	20 40 A0  1 
   rot bps w@ um*  " seek"  $call-parent  ( #sectors addr err? )
1A2BDDC 	7C 49 A0  1 
1A2BDE0 	34 BC A2  1 94 4C A0  1 
1A2BDE8 	50 5D A0  1 9C 53 A0  1 
1A2BDF0 	 4 73 65 65 6B  0  0  0 
1A2BDF8 	DC 31 A2  1 
   abort" seek failed in translate-params" 
1A2BDFC 	 8 81 A0  1 
1A2BE00 	1F 73 65 65 6B 20 66 61 
1A2BE08 	69 6C 65 64 20 69 6E 20 
1A2BE10 	74 72 61 6E 73 6C 61 74 
1A2BE18 	65 2D 70 61 72 61 6D 73 
1A2BE20 	 0  0  0  0 
   swap bps w@ *
1A2BE24 	68 49 A0  1 
1A2BE28 	34 BC A2  1 94 4C A0  1 
1A2BE30 	1C 5F A0  1 
;
1A2BE34 	58 46 A0  1 

: read-sectors   (S sector# #sectors addr -- error? )
1A2BE38 	 0  0  0 72 65 61 64 2D 
1A2BE40 	73 65 63 74 6F 72 73 8C 
1A2BE48 	D8 BD A2  1 20 40 A0  1 
   translate-params  dup >r  " read"  $call-parent  r> <>
1A2BE50 	D8 BD A2  1 40 49 A0  1 
1A2BE58 	BC 45 A0  1 9C 53 A0  1 
1A2BE60 	 4 72 65 61 64  0  0  0 
1A2BE68 	DC 31 A2  1 D0 45 A0  1 
1A2BE70 	44 48 A0  1 
;
1A2BE74 	58 46 A0  1 
: write-sectors  (S sector# #sectors addr -- error? )
1A2BE78 	 0  0 77 72 69 74 65 2D 
1A2BE80 	73 65 63 74 6F 72 73 8D 
1A2BE88 	4C BE A2  1 20 40 A0  1 
   translate-params  dup >r  " write"  $call-parent  r> <>
1A2BE90 	D8 BD A2  1 40 49 A0  1 
1A2BE98 	BC 45 A0  1 9C 53 A0  1 
1A2BEA0 	 5 77 72 69 74 65  0  0 
1A2BEA8 	DC 31 A2  1 D0 45 A0  1 
1A2BEB0 	44 48 A0  1 
;
1A2BEB4 	58 46 A0  1 

[ifdef] mount-drive
4 constant #devices

string-array device-names
  ," /floppy"
  ," /floppy"
  ," disk0"
  ," disk1"
end-string-array

: ?drive#  ( drive# -- drive# )
   dup 0 #devices  within  ( drive-number okay? )
   0=  abort" Maximum drive number is 3 (D:)"
;
: (unmount)  ( drive# -- )
   ?drive#
   driver @  dup  if  ( ihandle )
      close-dev  0 driver !
   else
      2drop
   then
;
: get-drive#  \ drive-letter  ( -- true | drive# false )
   optional-arg$  dup  if
      drop c@  upc  ascii A -  false
   else
      2drop true
   then
;
: unmount  \ drive-letter  ( -- )
   get-drive#  abort" Usage: unmount drive-letter"
   (unmount)
;
: $mount  ( path$ drive# -- )
   dup (unmount)   >r   ( path$ )
   open-dev  dup  0= abort" Can't open disk device for mounting"  ( ihandle )
   r> driver !
;   
: mount  \ pathname drive-letter  ( -- )
   safe-parse-word  dup  if  ( path$ )
      get-drive#            ( path$ [ drive# ] flag )
   else
      true
   then                     ( path$ [ drive# ] flag )
   abort" Usage: mount pathname drive-letter"
   $mount
;
: ?init-device  ( -- )
   driver @ 0=  if
      current-device @  device-names  count  current-device @  $mount
   then
;
[else]
alias ?init-device noop  ( -- )
1A2BEB8 	 0  0  0 3F 69 6E 69 74 
1A2BEC0 	2D 64 65 76 69 63 65 AC 
1A2BEC8 	8C BE A2  1 64 4F A0  1 
[then]

OpenFirmware/ofw/fs/fatfs/diskio.fth_AL	14C 1A2BED0 \ DOS directory entry structure

hex

\ mmo private

variable dirent
1A2BED0 	 0 64 69 72 65 6E 74 86 
1A2BED8 	CC BE A2  1 48 40 A0  1 
1A2BEE0 	 8  9  0  0 

: efield \ name ( dirent-offset size -- dirent-offset')
1A2BEE4 	 0 65 66 69 
1A2BEE8 	65 6C 64 86 DC BE A2  1 
1A2BEF0 	20 40 A0  1 
   create over , + does> @ dirent @ +
1A2BEF4 	A8 A2 A0  1 
1A2BEF8 	54 49 A0  1 98 55 A0  1 
1A2BF00 	 4 45 A0  1 50 A3 A0  1 
1A2BF08 	90 90 90 E8 6C 81 FD FF 
1A2BF10 	5C 4C A0  1 DC BE A2  1 
1A2BF18 	5C 4C A0  1  4 45 A0  1 
;
1A2BF20 	58 46 A0  1 

struct \ dirent
 8 efield de_name          \  0  base name
1A2BF24 	64 65 5F 6E 
1A2BF28 	61 6D 65 87 F0 BE A2  1 
1A2BF30 	 8 BF A2  1  0  0  0  0 
 3 efield de_extension	   \  8  ext (first byte: 0 - empty; e5 - deleted)
1A2BF38 	 0  0  0 64 65 5F 65 78 
1A2BF40 	74 65 6E 73 69 6F 6E 8C 
1A2BF48 	30 BF A2  1  8 BF A2  1 
1A2BF50 	 8  0  0  0 
 1 efield de_attributes	   \  b  attributes
1A2BF54 	 0  0 64 65 
1A2BF58 	5F 61 74 74 72 69 62 75 
1A2BF60 	74 65 73 8D 4C BF A2  1 
1A2BF68 	 8 BF A2  1  B  0  0  0 

\ Bits in attributes byte

01 constant at_rdonly	   \ Read only
1A2BF70 	 0  0 61 74 5F 72 64 6F 
1A2BF78 	6E 6C 79 89 68 BF A2  1 
1A2BF80 	68 40 A0  1  1  0  0  0 
02 constant at_hidden	   \ Invisible in directory search
1A2BF88 	 0  0 61 74 5F 68 69 64 
1A2BF90 	64 65 6E 89 80 BF A2  1 
1A2BF98 	68 40 A0  1  2  0  0  0 
04 constant at_system	   \ System file
1A2BFA0 	 0  0 61 74 5F 73 79 73 
1A2BFA8 	74 65 6D 89 98 BF A2  1 
1A2BFB0 	68 40 A0  1  4  0  0  0 
08 constant at_vollab	   \ Volume label
1A2BFB8 	 0  0 61 74 5F 76 6F 6C 
1A2BFC0 	6C 61 62 89 B0 BF A2  1 
1A2BFC8 	68 40 A0  1  8  0  0  0 
10 constant at_subdir	   \ Subdirectory
1A2BFD0 	 0  0 61 74 5F 73 75 62 
1A2BFD8 	64 69 72 89 C8 BF A2  1 
1A2BFE0 	68 40 A0  1 10  0  0  0 
20 constant at_archiv	   \ Needs archiving (changed since last backup)
1A2BFE8 	 0  0 61 74 5F 61 72 63 
1A2BFF0 	68 69 76 89 E0 BF A2  1 
1A2BFF8 	68 40 A0  1 20  0  0  0 

 1 efield de_reserved	   \  c  reserved
1A2C000 	64 65 5F 72 65 73 65 72 
1A2C008 	76 65 64 8B F8 BF A2  1 
1A2C010 	 8 BF A2  1  C  0  0  0 
 1 efield de_csec	   \  d  # of 10 msec intervals in 2 secs (Win95)
1A2C018 	64 65 5F 63 73 65 63 87 
1A2C020 	10 C0 A2  1  8 BF A2  1 
1A2C028 	 D  0  0  0 
 2 efield de_ctime	   \  e  creation time (Win95)
1A2C02C 	 0  0  0 64 
1A2C030 	65 5F 63 74 69 6D 65 88 
1A2C038 	24 C0 A2  1  8 BF A2  1 
1A2C040 	 E  0  0  0 
 2 efield de_cdate	   \ 10  creation date (Win95)
1A2C044 	 0  0  0 64 
1A2C048 	65 5F 63 64 61 74 65 88 
1A2C050 	3C C0 A2  1  8 BF A2  1 
1A2C058 	10  0  0  0 
 2 efield de_adate	   \ 12  last access date (Win95)
1A2C05C 	 0  0  0 64 
1A2C060 	65 5F 61 64 61 74 65 88 
1A2C068 	54 C0 A2  1  8 BF A2  1 
1A2C070 	12  0  0  0 
 2 efield de_firsthi	   \ 14  upper 12 bits of beginning cluster# (Win95)
1A2C074 	 0 64 65 5F 
1A2C078 	66 69 72 73 74 68 69 8A 
1A2C080 	6C C0 A2  1  8 BF A2  1 
1A2C088 	14  0  0  0 
 2 efield de_time	   \ 16  modification time
1A2C08C 	64 65 5F 74 
1A2C090 	69 6D 65 87 84 C0 A2  1 
1A2C098 	 8 BF A2  1 16  0  0  0 
 2 efield de_date	   \ 18  modification date
1A2C0A0 	64 65 5F 64 61 74 65 87 
1A2C0A8 	98 C0 A2  1  8 BF A2  1 
1A2C0B0 	18  0  0  0 
 2 efield de_first	   \ 1a  beginning cluster#
1A2C0B4 	 0  0  0 64 
1A2C0B8 	65 5F 66 69 72 73 74 88 
1A2C0C0 	AC C0 A2  1  8 BF A2  1 
1A2C0C8 	1A  0  0  0 
 4 efield de_length	   \ 1c  #bytes in file
1A2C0CC 	 0  0 64 65 
1A2C0D0 	5F 6C 65 6E 67 74 68 89 
1A2C0D8 	C4 C0 A2  1  8 BF A2  1 
1A2C0E0 	1C  0  0  0 

constant /dirent
1A2C0E4 	2F 64 69 72 
1A2C0E8 	65 6E 74 87 DC C0 A2  1 
1A2C0F0 	68 40 A0  1 20  0  0  0 

13 buffer: file-name-buf
1A2C0F8 	 0  0 66 69 6C 65 2D 6E 
1A2C100 	61 6D 65 2D 62 75 66 8D 
1A2C108 	F0 C0 A2  1 B4 A9 A0  1 
1A2C110 	 C  9  0  0 13  0  0  0 
1A2C118 	18 A4 A2  1 

: "$append  ( pstr adr len -- pstr )
1A2C11C 	 0  0  0 22 
1A2C120 	24 61 70 70 65 6E 64 88 
1A2C128 	 C C1 A2  1 20 40 A0  1 
   dup >r   2 pick count +  swap cmove  ( pstr )
1A2C130 	40 49 A0  1 BC 45 A0  1 
1A2C138 	90 6F A0  1  C 4A A0  1 
1A2C140 	BC 53 A0  1  4 45 A0  1 
1A2C148 	68 49 A0  1 10 44 A0  1 
   dup c@ r> + over c!
1A2C150 	40 49 A0  1 C4 4C A0  1 
1A2C158 	D0 45 A0  1  4 45 A0  1 
1A2C160 	54 49 A0  1 B8 4D A0  1 
;
1A2C168 	58 46 A0  1 

: file-name  ( -- adr len )
1A2C16C 	 0  0 66 69 
1A2C170 	6C 65 2D 6E 61 6D 65 89 
1A2C178 	2C C1 A2  1 20 40 A0  1 
   de_name 8 -trailing  file-name-buf pack  ( pstr )
1A2C180 	30 BF A2  1 F0 6F A0  1 
1A2C188 	84 8C A0  1  C C1 A2  1 
1A2C190 	DC 52 A0  1 
   de_extension 3 -trailing nip  if
1A2C194 	4C BF A2  1 
1A2C198 	A0 6F A0  1 84 8C A0  1 
1A2C1A0 	FC 46 A0  1 DC 41 A0  1 
1A2C1A8 	20  0  0  0 
       " ."  "$append  de_extension 3 -trailing "$append  ( pstr )
1A2C1AC 	9C 53 A0  1 
1A2C1B0 	 1 2E  0  0 2C C1 A2  1 
1A2C1B8 	4C BF A2  1 A0 6F A0  1 
1A2C1C0 	84 8C A0  1 2C C1 A2  1 
   then
   count
1A2C1C8 	BC 53 A0  1 
;
1A2C1CC 	58 46 A0  1 

: file-size  ( -- #bytes )  de_length lel@ ;
1A2C1D0 	 0  0 66 69 6C 65 2D 73 
1A2C1D8 	69 7A 65 89 7C C1 A2  1 
1A2C1E0 	20 40 A0  1 DC C0 A2  1 
1A2C1E8 	DC B4 A2  1 58 46 A0  1 
: file-date  ( -- day month year )  de_date lew@ >dmy  ;
1A2C1F0 	 0  0 66 69 6C 65 2D 64 
1A2C1F8 	61 74 65 89 E0 C1 A2  1 
1A2C200 	20 40 A0  1 AC C0 A2  1 
1A2C208 	7C B4 A2  1 78 B6 A2  1 
1A2C210 	58 46 A0  1 
: file-time  ( -- sec min hour )  de_time lew@ >hms  ;
1A2C214 	 0  0 66 69 
1A2C218 	6C 65 2D 74 69 6D 65 89 
1A2C220 	 0 C2 A2  1 20 40 A0  1 
1A2C228 	98 C0 A2  1 7C B4 A2  1 
1A2C230 	B8 B5 A2  1 58 46 A0  1 
: file-attributes  ( -- bitmask )  de_attributes c@ ;
1A2C238 	66 69 6C 65 2D 61 74 74 
1A2C240 	72 69 62 75 74 65 73 8F 
1A2C248 	24 C2 A2  1 20 40 A0  1 
1A2C250 	68 BF A2  1 C4 4C A0  1 
1A2C258 	58 46 A0  1 

: file-cluster!  ( cluster# -- )
1A2C25C 	 0  0 66 69 
1A2C260 	6C 65 2D 63 6C 75 73 74 
1A2C268 	65 72 21 8D 4C C2 A2  1 
1A2C270 	20 40 A0  1 
   lwsplit de_firsthi lew!  de_first lew!
1A2C274 	A0 4F A0  1 
1A2C278 	84 C0 A2  1 A8 B4 A2  1 
1A2C280 	C4 C0 A2  1 A8 B4 A2  1 
;
1A2C288 	58 46 A0  1 

: file-cluster@  ( -- cluster# )
1A2C28C 	 0  0 66 69 
1A2C290 	6C 65 2D 63 6C 75 73 74 
1A2C298 	65 72 40 8D 70 C2 A2  1 
1A2C2A0 	20 40 A0  1 
   de_first lew@
1A2C2A4 	C4 C0 A2  1 
1A2C2A8 	7C B4 A2  1 
   fat-type c@  fat32 =  if  de_firsthi lew@  wljoin  then
1A2C2AC 	84 BC A2  1 
1A2C2B0 	C4 4C A0  1 F0 BC A2  1 
1A2C2B8 	24 48 A0  1 DC 41 A0  1 
1A2C2C0 	10  0  0  0 84 C0 A2  1 
1A2C2C8 	7C B4 A2  1 D4 4F A0  1 
;
1A2C2D0 	58 46 A0  1 

OpenFirmware/ofw/fs/fatfs/dirent.fth_AL	404 1A2C2D4 purpose: BPB management

hex

d# 4096 constant /sector-max
1A2C2D4 	2F 73 65 63 
1A2C2D8 	74 6F 72 2D 6D 61 78 8B 
1A2C2E0 	A0 C2 A2  1 68 40 A0  1 
1A2C2E8 	 0 10  0  0 

: /sector  ( -- n )  bps w@  ;
1A2C2EC 	2F 73 65 63 
1A2C2F0 	74 6F 72 87 E4 C2 A2  1 
1A2C2F8 	20 40 A0  1 34 BC A2  1 
1A2C300 	94 4C A0  1 58 46 A0  1 
: /cluster  ( -- n )  spc c@ /sector *  ;
1A2C308 	 0  0  0 2F 63 6C 75 73 
1A2C310 	74 65 72 88 F8 C2 A2  1 
1A2C318 	20 40 A0  1 58 BC A2  1 
1A2C320 	C4 4C A0  1 F8 C2 A2  1 
1A2C328 	1C 5F A0  1 58 46 A0  1 
: bytes>clusters  ( #bytes -- #clusters )  /cluster /mod  swap  if  1+  then  ;
1A2C330 	 0 62 79 74 65 73 3E 63 
1A2C338 	6C 75 73 74 65 72 73 8E 
1A2C340 	18 C3 A2  1 20 40 A0  1 
1A2C348 	18 C3 A2  1 50 5F A0  1 
1A2C350 	68 49 A0  1 DC 41 A0  1 
1A2C358 	 8  0  0  0 30 4B A0  1 
1A2C360 	58 46 A0  1 
: uncache-device  ( -- )  0 bps w!  ;
1A2C364 	 0 75 6E 63 
1A2C368 	61 63 68 65 2D 64 65 76 
1A2C370 	69 63 65 8E 44 C3 A2  1 
1A2C378 	20 40 A0  1 70 6F A0  1 
1A2C380 	34 BC A2  1 A4 4D A0  1 
1A2C388 	58 46 A0  1 

: bytes>cl-entries  ( #bytes -- #cl-entries )
1A2C38C 	 0  0  0 62 
1A2C390 	79 74 65 73 3E 63 6C 2D 
1A2C398 	65 6E 74 72 69 65 73 90 
1A2C3A0 	78 C3 A2  1 20 40 A0  1 
   fat-type c@  case
1A2C3A8 	84 BC A2  1 C4 4C A0  1 
      fat12  of  2 * 3 /  endof
1A2C3B0 	C8 BC A2  1 48 43 A0  1 
1A2C3B8 	1C  0  0  0 90 6F A0  1 
1A2C3C0 	1C 5F A0  1 A0 6F A0  1 
1A2C3C8 	98 5F A0  1 6C 43 A0  1 
1A2C3D0 	3C  0  0  0 
      fat16  of  2/       endof
1A2C3D4 	DC BC A2  1 
1A2C3D8 	48 43 A0  1 10  0  0  0 
1A2C3E0 	78 4B A0  1 6C 43 A0  1 
1A2C3E8 	24  0  0  0 
      fat32  of  2/ 2/    endof
1A2C3EC 	F0 BC A2  1 
1A2C3F0 	48 43 A0  1 14  0  0  0 
1A2C3F8 	78 4B A0  1 78 4B A0  1 
1A2C400 	6C 43 A0  1  8  0  0  0 
   endcase
1A2C408 	84 43 A0  1 
;
1A2C40C 	58 46 A0  1 

0 instance value dir-buf
1A2C410 	64 69 72 2D 62 75 66 87 
1A2C418 	A4 C3 A2  1 C0 FE A1  1 
1A2C420 	1C  0  0  0 

\ 3 sectors contains an integral number of FAT entries for either the
\ 12-bit or 16-bit or 32-bit FAT format, thus avoiding fragments of entries.

: init-fat-cache  ( -- )
1A2C424 	 0 69 6E 69 
1A2C428 	74 2D 66 61 74 2D 63 61 
1A2C430 	63 68 65 8E 1C C4 A2  1 
1A2C438 	20 40 A0  1 
   \ We really should verify that the sector size is the same as it
   \ used to be, in case a different floppy was inserted.
   fat-cache @ 0=  if
1A2C43C 	 0 BB A2  1 
1A2C440 	5C 4C A0  1 24 47 A0  1 
1A2C448 	DC 41 A0  1 48  0  0  0 
      3 dup  sectors/fat-cache w!        ( #cache-sectors ) 
1A2C450 	A0 6F A0  1 40 49 A0  1 
1A2C458 	A4 BB A2  1 A4 4D A0  1 
      /sector *                          ( cache-size )
1A2C460 	F8 C2 A2  1 1C 5F A0  1 
      dup alloc-mem  fat-cache !         ( cache-size )
1A2C468 	40 49 A0  1 F0 6C A0  1 
1A2C470 	 0 BB A2  1 54 4D A0  1 
      bytes>cl-entries cl#/fat-cache w!
1A2C478 	A4 C3 A2  1 D8 BB A2  1 
1A2C480 	A4 4D A0  1 

      /cluster alloc-mem  to dir-buf
1A2C484 	18 C3 A2  1 
1A2C488 	F0 6C A0  1 48 B8 A1  1 
1A2C490 	1C C4 A2  1 
   then
   -1 fat-sector !  false fat-dirty w! 
1A2C494 	58 41 A0  1 
1A2C498 	FF FF FF FF 18 BB A2  1 
1A2C4A0 	54 4D A0  1 18 70 A0  1 
1A2C4A8 	BC BB A2  1 A4 4D A0  1 
;
1A2C4B0 	58 46 A0  1 
: ?free-fat-cache  ( -- )
1A2C4B4 	3F 66 72 65 
1A2C4B8 	65 2D 66 61 74 2D 63 61 
1A2C4C0 	63 68 65 8F 38 C4 A2  1 
1A2C4C8 	20 40 A0  1 
   fat-cache @  if
1A2C4CC 	 0 BB A2  1 
1A2C4D0 	5C 4C A0  1 DC 41 A0  1 
1A2C4D8 	38  0  0  0 
      dir-buf /cluster free-mem
1A2C4DC 	1C C4 A2  1 
1A2C4E0 	18 C3 A2  1  8 6D A0  1 
      fat-cache @  sectors/fat-cache w@ /sector *  free-mem
1A2C4E8 	 0 BB A2  1 5C 4C A0  1 
1A2C4F0 	A4 BB A2  1 94 4C A0  1 
1A2C4F8 	F8 C2 A2  1 1C 5F A0  1 
1A2C500 	 8 6D A0  1 
      0 fat-cache !
1A2C504 	70 6F A0  1 
1A2C508 	 0 BB A2  1 54 4D A0  1 
   then
;
1A2C510 	58 46 A0  1 

: (set-device)  ( device# -- )  current-device !  ;
1A2C514 	 0  0  0 28 
1A2C518 	73 65 74 2D 64 65 76 69 
1A2C520 	63 65 29 8C C8 C4 A2  1 
1A2C528 	20 40 A0  1 A8 BA A2  1 
1A2C530 	54 4D A0  1 58 46 A0  1 

\ XXX There must be a better way to do this.  Right now, we just zap
\ the BPB cache for both removable devices.  This really ought to be
\ device interface procedure.
: media-changed?  ( -- flag )
1A2C538 	 0 6D 65 64 69 61 2D 63 
1A2C540 	68 61 6E 67 65 64 3F 8E 
1A2C548 	28 C5 A2  1 20 40 A0  1 
[ifdef] notdef
   current-device @
   3"floppy (set-device)  uncache-device
   5"floppy (set-device)  uncache-device
   (set-device)
   true
[else]
   false
1A2C550 	18 70 A0  1 
[then]
;
1A2C554 	58 46 A0  1 

: free-bpb  ( -- )
1A2C558 	 0  0  0 66 72 65 65 2D 
1A2C560 	62 70 62 88 4C C5 A2  1 
1A2C568 	20 40 A0  1 
   bpb @  ?dup  if  /sector-max  free-mem  0 bpb !  then
1A2C56C 	44 B7 A2  1 
1A2C570 	5C 4C A0  1 B4 70 A0  1 
1A2C578 	DC 41 A0  1 18  0  0  0 
1A2C580 	E4 C2 A2  1  8 6D A0  1 
1A2C588 	70 6F A0  1 44 B7 A2  1 
1A2C590 	54 4D A0  1 
;
1A2C594 	58 46 A0  1 
: ?read-error  ( error? -- )
1A2C598 	3F 72 65 61 64 2D 65 72 
1A2C5A0 	72 6F 72 8B 68 C5 A2  1 
1A2C5A8 	20 40 A0  1 
   if          ( )
1A2C5AC 	DC 41 A0  1 
1A2C5B0 	30  0  0  0 
      free-bpb
1A2C5B4 	68 C5 A2  1 
      "CaR ". ." BIOS Parameter Block"
1A2C5B8 	B4 B3 A2  1 A8 7C A0  1 
1A2C5C0 	20 7C A0  1 14 42 49 4F 
1A2C5C8 	53 20 50 61 72 61 6D 65 
1A2C5D0 	74 65 72 20 42 6C 6F 63 
1A2C5D8 	6B  0  0  0 
      abort
1A2C5DC 	28 91 A0  1 
   then         ( )
;
1A2C5E0 	58 46 A0  1 
: not-bpb?  ( -- error? )
1A2C5E4 	 0  0  0 6E 
1A2C5E8 	6F 74 2D 62 70 62 3F 88 
1A2C5F0 	A8 C5 A2  1 20 40 A0  1 
   bp_bps lew@                         ( bps )
1A2C5F8 	C4 B7 A2  1 7C B4 A2  1 
   dup  dup 1- and 0=                  ( bps power-of-2? )
1A2C600 	40 49 A0  1 40 49 A0  1 
1A2C608 	54 4B A0  1 5C 44 A0  1 
1A2C610 	24 47 A0  1 
   swap  d# 256  d# 4096 between  and  ( bps-ok? )
1A2C614 	68 49 A0  1 
1A2C618 	58 41 A0  1  0  1  0  0 
1A2C620 	58 41 A0  1  0 10  0  0 
1A2C628 	D8 70 A0  1 5C 44 A0  1 
   bp_nfats c@ 1 2 between and  0=     ( error? )
1A2C630 	 4 B8 A2  1 C4 4C A0  1 
1A2C638 	80 6F A0  1 90 6F A0  1 
1A2C640 	D8 70 A0  1 5C 44 A0  1 
1A2C648 	24 47 A0  1 
;
1A2C64C 	58 46 A0  1 
: find-bpb  ( -- )
1A2C650 	 0  0  0 66 69 6E 64 2D 
1A2C658 	62 70 62 88 F4 C5 A2  1 
1A2C660 	20 40 A0  1 
   ?init-device   \ Call the device's init routine
1A2C664 	64 4F A0  1 

   /sector-max alloc-mem  bpb !
1A2C668 	E4 C2 A2  1 F0 6C A0  1 
1A2C670 	44 B7 A2  1 54 4D A0  1 
   0 1 bpb @  read-sectors  ?read-error
1A2C678 	70 6F A0  1 80 6F A0  1 
1A2C680 	44 B7 A2  1 5C 4C A0  1 
1A2C688 	4C BE A2  1 A8 C5 A2  1 
   not-bpb?  if
1A2C690 	F4 C5 A2  1 DC 41 A0  1 
1A2C698 	30  0  0  0 
      free-bpb
1A2C69C 	68 C5 A2  1 
      true abort" Not an MS-DOS formatted drive"
1A2C6A0 	 4 70 A0  1  8 81 A0  1 
1A2C6A8 	1D 4E 6F 74 20 61 6E 20 
1A2C6B0 	4D 53 2D 44 4F 53 20 66 
1A2C6B8 	6F 72 6D 61 74 74 65 64 
1A2C6C0 	20 64 72 69 76 65  0  0 
   then   
;
1A2C6C8 	58 46 A0  1 

: alloc-fssector  ( -- )
1A2C6CC 	 0 61 6C 6C 
1A2C6D0 	6F 63 2D 66 73 73 65 63 
1A2C6D8 	74 6F 72 8E 60 C6 A2  1 
1A2C6E0 	20 40 A0  1 
   fssector @ 0=  if  /sector-max alloc-mem  fssector !  then
1A2C6E4 	BC B9 A2  1 
1A2C6E8 	5C 4C A0  1 24 47 A0  1 
1A2C6F0 	DC 41 A0  1 14  0  0  0 
1A2C6F8 	E4 C2 A2  1 F0 6C A0  1 
1A2C700 	BC B9 A2  1 54 4D A0  1 
;
1A2C708 	58 46 A0  1 
: free-fssector  ( -- )
1A2C70C 	 0  0 66 72 
1A2C710 	65 65 2D 66 73 73 65 63 
1A2C718 	74 6F 72 8D E0 C6 A2  1 
1A2C720 	20 40 A0  1 
   fssector @ ?dup  if  /sector-max  free-mem  0 fsinfo !  0 fssector ! then
1A2C724 	BC B9 A2  1 
1A2C728 	5C 4C A0  1 B4 70 A0  1 
1A2C730 	DC 41 A0  1 24  0  0  0 
1A2C738 	E4 C2 A2  1  8 6D A0  1 
1A2C740 	70 6F A0  1 D0 B9 A2  1 
1A2C748 	54 4D A0  1 70 6F A0  1 
1A2C750 	BC B9 A2  1 54 4D A0  1 
;
1A2C758 	58 46 A0  1 
: not-fsinfo?  ( -- error? )
1A2C75C 	6E 6F 74 2D 
1A2C760 	66 73 69 6E 66 6F 3F 8B 
1A2C768 	20 C7 A2  1 20 40 A0  1 
   0 fsinfo !
1A2C770 	70 6F A0  1 D0 B9 A2  1 
1A2C778 	54 4D A0  1 
   fssector @ /sector bounds  do
1A2C77C 	BC B9 A2  1 
1A2C780 	5C 4C A0  1 F8 C2 A2  1 
1A2C788 	F0 6D A0  1 88 42 A0  1 
1A2C790 	3C  0  0  0 
      i lel@ fssignature lel@ =  if
1A2C794 	B4 42 A0  1 
1A2C798 	DC B4 A2  1 A4 B9 A2  1 
1A2C7A0 	DC B4 A2  1 24 48 A0  1 
1A2C7A8 	DC 41 A0  1 14  0  0  0 
         i fsinfo !  leave
1A2C7B0 	B4 42 A0  1 D0 B9 A2  1 
1A2C7B8 	54 4D A0  1 18 43 A0  1 
      then
   4 +loop
1A2C7C0 	B0 6F A0  1 1C 42 A0  1 
1A2C7C8 	CC FF FF FF 
   fsinfo @ 0=
1A2C7CC 	D0 B9 A2  1 
1A2C7D0 	5C 4C A0  1 24 47 A0  1 
;
1A2C7D8 	58 46 A0  1 
: read-fsinfo  ( sector# -- )
1A2C7DC 	72 65 61 64 
1A2C7E0 	2D 66 73 69 6E 66 6F 8B 
1A2C7E8 	6C C7 A2  1 20 40 A0  1 
   false fsinfos-dirty c!
1A2C7F0 	18 70 A0  1 A0 BC A2  1 
1A2C7F8 	B8 4D A0  1 
   alloc-fssector
1A2C7FC 	E0 C6 A2  1 
   1 fssector @  read-sectors  if
1A2C800 	80 6F A0  1 BC B9 A2  1 
1A2C808 	5C 4C A0  1 4C BE A2  1 
1A2C810 	DC 41 A0  1 38  0  0  0 
      free-fssector
1A2C818 	20 C7 A2  1 
      "CaR ". ." File system information sector"
1A2C81C 	B4 B3 A2  1 
1A2C820 	A8 7C A0  1 20 7C A0  1 
1A2C828 	1E 46 69 6C 65 20 73 79 
1A2C830 	73 74 65 6D 20 69 6E 66 
1A2C838 	6F 72 6D 61 74 69 6F 6E 
1A2C840 	20 73 65 63 74 6F 72  0 
      abort
1A2C848 	28 91 A0  1 
   then
   not-fsinfo?  if  free-fssector  then
1A2C84C 	6C C7 A2  1 
1A2C850 	DC 41 A0  1  8  0  0  0 
1A2C858 	20 C7 A2  1 
;
1A2C85C 	58 46 A0  1 
: write-fsinfo  ( -- )
1A2C860 	 0  0  0 77 72 69 74 65 
1A2C868 	2D 66 73 69 6E 66 6F 8C 
1A2C870 	EC C7 A2  1 20 40 A0  1 
   fsinfos w@ 0<>  fsinfos-dirty c@ and  if
1A2C878 	48 BC A2  1 94 4C A0  1 
1A2C880 	44 47 A0  1 A0 BC A2  1 
1A2C888 	C4 4C A0  1 5C 44 A0  1 
1A2C890 	DC 41 A0  1 54  0  0  0 
      false fsinfos-dirty c!
1A2C898 	18 70 A0  1 A0 BC A2  1 
1A2C8A0 	B8 4D A0  1 
      fsinfos w@ 1 fssector @ write-sectors
1A2C8A4 	48 BC A2  1 
1A2C8A8 	94 4C A0  1 80 6F A0  1 
1A2C8B0 	BC B9 A2  1 5C 4C A0  1 
1A2C8B8 	8C BE A2  1 
      if  "CaW ". ." File info sector"  abort  then
1A2C8BC 	DC 41 A0  1 
1A2C8C0 	28  0  0  0 D4 B3 A2  1 
1A2C8C8 	A8 7C A0  1 20 7C A0  1 
1A2C8D0 	10 46 69 6C 65 20 69 6E 
1A2C8D8 	66 6F 20 73 65 63 74 6F 
1A2C8E0 	72  0  0  0 28 91 A0  1 
   then
;
1A2C8E8 	58 46 A0  1 

\ This BPB parser implements Microsoft's recommended method
\ for determining whether a filesystem is FAT-16 or FAT-32.
variable nsects
1A2C8EC 	 0 6E 73 65 
1A2C8F0 	63 74 73 86 74 C8 A2  1 
1A2C8F8 	48 40 A0  1 10  9  0  0 

: bpb>device  ( -- )
1A2C900 	 0 62 70 62 3E 64 65 76 
1A2C908 	69 63 65 8A F8 C8 A2  1 
1A2C910 	20 40 A0  1 
   bp_media c@  media c!
1A2C914 	4C B8 A2  1 
1A2C918 	C4 4C A0  1 6C BC A2  1 
1A2C920 	B8 4D A0  1 
   bp_bps lew@  bps w!
1A2C924 	C4 B7 A2  1 
1A2C928 	7C B4 A2  1 34 BC A2  1 
1A2C930 	A4 4D A0  1 
   bp_spc c@    spc c!
1A2C934 	D8 B7 A2  1 
1A2C938 	C4 4C A0  1 58 BC A2  1 
1A2C940 	B8 4D A0  1 
   bp_spf lew@  ?dup  0=  if   bp_bspf lel@  then   spf l!
1A2C944 	60 B8 A2  1 
1A2C948 	7C B4 A2  1 B4 70 A0  1 
1A2C950 	24 47 A0  1 DC 41 A0  1 
1A2C958 	 C  0  0  0 CC B8 A2  1 
1A2C960 	DC B4 A2  1 28 BB A2  1 
1A2C968 	7C 4D A0  1 
   bp_nsects lew@ ?dup 0=  if  bp_xnsects lel@  then  nsects l!
1A2C96C 	34 B8 A2  1 
1A2C970 	7C B4 A2  1 B4 70 A0  1 
1A2C978 	24 47 A0  1 DC 41 A0  1 
1A2C980 	 C  0  0  0 B8 B8 A2  1 
1A2C988 	DC B4 A2  1 F8 C8 A2  1 
1A2C990 	7C 4D A0  1 

   bp_ndirs lew@  /dirent *  /sector 1- +   /sector /  #dir-sectors w!
1A2C994 	1C B8 A2  1 
1A2C998 	7C B4 A2  1 F0 C0 A2  1 
1A2C9A0 	1C 5F A0  1 F8 C2 A2  1 
1A2C9A8 	54 4B A0  1  4 45 A0  1 
1A2C9B0 	F8 C2 A2  1 98 5F A0  1 
1A2C9B8 	24 BC A2  1 A4 4D A0  1 

   \ nsects is TotSec
   \ #dir-sectors is RootDirSectors

   \ Sector number where the FAT starts.
   \ bp_nhid is the number of sectors before the BPB sector.
   \ bp_res is the number of sectors from the BPT sector to the
   \ first FAT sector.

   \ If the underlying disk driver handles partition offsets,
   \ we don't need to handle bp_nhid here.
   bp_res lew@   ( bp_nhid lel@ + )
1A2C9C0 	EC B7 A2  1 7C B4 A2  1 
   dup fat-sector0 w!                    ( #resv-sectors )
1A2C9C8 	40 49 A0  1 F0 BB A2  1 
1A2C9D0 	A4 4D A0  1 
   spf l@  bp_nfats c@ *  +              ( #early-sectors )
1A2C9D4 	28 BB A2  1 
1A2C9D8 	6C 4C A0  1  4 B8 A2  1 
1A2C9E0 	C4 4C A0  1 1C 5F A0  1 
1A2C9E8 	 4 45 A0  1 
   dup dir-sector0 w!                    ( #early-sectors )
1A2C9EC 	40 49 A0  1 
1A2C9F0 	 8 BC A2  1 A4 4D A0  1 
   #dir-sectors w@ +  cl-sector0 l!      ( )
1A2C9F8 	24 BC A2  1 94 4C A0  1 
1A2CA00 	 4 45 A0  1 6C BB A2  1 
1A2CA08 	7C 4D A0  1 

   \ cl-sector0 is FirstDataSector

   nsects l@  #dir-sectors w@ -  spc c@ /  ( #clusters )
1A2CA0C 	F8 C8 A2  1 
1A2CA10 	6C 4C A0  1 24 BC A2  1 
1A2CA18 	94 4C A0  1 18 45 A0  1 
1A2CA20 	58 BC A2  1 C4 4C A0  1 
1A2CA28 	98 5F A0  1 
   dup d# 65525 >=  if                    ( #clusters )
1A2CA2C 	40 49 A0  1 
1A2CA30 	58 41 A0  1 F5 FF  0  0 
1A2CA38 	EC 48 A0  1 DC 41 A0  1 
1A2CA40 	50  0  0  0 
      drop  fat32 fat-type c!
1A2CA44 	30 49 A0  1 
1A2CA48 	F0 BC A2  1 84 BC A2  1 
1A2CA50 	B8 4D A0  1 
      0 dir-sector0 w!
1A2CA54 	70 6F A0  1 
1A2CA58 	 8 BC A2  1 A4 4D A0  1 
      bp_rdirclus lel@  rdirclus l!
1A2CA60 	14 B9 A2  1 DC B4 A2  1 
1A2CA68 	40 BB A2  1 7C 4D A0  1 
      bp_fsinfos lew@ dup read-fsinfo fsinfos w!
1A2CA70 	2C B9 A2  1 7C B4 A2  1 
1A2CA78 	40 49 A0  1 EC C7 A2  1 
1A2CA80 	48 BC A2  1 A4 4D A0  1 
   else
1A2CA88 	C8 41 A0  1 6C  0  0  0 
      d# 4085 >=  if  fat16  else  fat12  then  fat-type c!
1A2CA90 	58 41 A0  1 F5  F  0  0 
1A2CA98 	EC 48 A0  1 DC 41 A0  1 
1A2CAA0 	10  0  0  0 DC BC A2  1 
1A2CAA8 	C8 41 A0  1  8  0  0  0 
1A2CAB0 	C8 BC A2  1 84 BC A2  1 
1A2CAB8 	B8 4D A0  1 
      0 fsinfo !  0 fssector !  false fsinfos-dirty c!
1A2CABC 	70 6F A0  1 
1A2CAC0 	D0 B9 A2  1 54 4D A0  1 
1A2CAC8 	70 6F A0  1 BC B9 A2  1 
1A2CAD0 	54 4D A0  1 18 70 A0  1 
1A2CAD8 	A0 BC A2  1 B8 4D A0  1 
      0 fsinfos w!  0 rdirclus l!
1A2CAE0 	70 6F A0  1 48 BC A2  1 
1A2CAE8 	A4 4D A0  1 70 6F A0  1 
1A2CAF0 	40 BB A2  1 7C 4D A0  1 
   then

   \ The number of clusters is limited both by space for clusters numbers
   \ in the FAT and by disk space for storage of the actual clusters.
   \ It would be silly to waste disk space by making the FAT too small,
   \ but I am paranoid so I check both limits.

   \ Calculate the number of clusters the FAT can represent
   spf l@  /sector *    bytes>cl-entries   ( #clusters )
1A2CAF8 	28 BB A2  1 6C 4C A0  1 
1A2CB00 	F8 C2 A2  1 1C 5F A0  1 
1A2CB08 	A4 C3 A2  1 

   \ Compare it with the number of clusters for which there is disk space
   nsects l@
1A2CB0C 	F8 C8 A2  1 
1A2CB10 	6C 4C A0  1 
   cl-sector0 l@ -  spc c@ /  2 +   min  1-
1A2CB14 	6C BB A2  1 
1A2CB18 	6C 4C A0  1 18 45 A0  1 
1A2CB20 	58 BC A2  1 C4 4C A0  1 
1A2CB28 	98 5F A0  1 90 6F A0  1 
1A2CB30 	 4 45 A0  1 74 4A A0  1 
1A2CB38 	54 4B A0  1 
   max-cl# l!
1A2CB3C 	54 BB A2  1 
1A2CB40 	7C 4D A0  1 
;
1A2CB44 	58 46 A0  1 

: ?read-bpb  ( -- )
1A2CB48 	 0  0 3F 72 65 61 64 2D 
1A2CB50 	62 70 62 89 10 C9 A2  1 
1A2CB58 	20 40 A0  1 
   /sector 0=  if      \ Read bpb if necessary
1A2CB5C 	F8 C2 A2  1 
1A2CB60 	24 47 A0  1 DC 41 A0  1 
1A2CB68 	88  0  0  0 
      init-sector-size
1A2CB6C 	9C BD A2  1 
      find-bpb
1A2CB70 	60 C6 A2  1 
      bp_bps lew@  bps w@ <>  if
1A2CB74 	C4 B7 A2  1 
1A2CB78 	7C B4 A2  1 34 BC A2  1 
1A2CB80 	94 4C A0  1 44 48 A0  1 
1A2CB88 	DC 41 A0  1 48  0  0  0 
         ." WARNING: BPB sector size differs from device sector size" cr
1A2CB90 	20 7C A0  1 38 57 41 52 
1A2CB98 	4E 49 4E 47 3A 20 42 50 
1A2CBA0 	42 20 73 65 63 74 6F 72 
1A2CBA8 	20 73 69 7A 65 20 64 69 
1A2CBB0 	66 66 65 72 73 20 66 72 
1A2CBB8 	6F 6D 20 64 65 76 69 63 
1A2CBC0 	65 20 73 65 63 74 6F 72 
1A2CBC8 	20 73 69 7A 65  0  0  0 
1A2CBD0 	80 6D A0  1 
      then
      bpb>device
1A2CBD4 	10 C9 A2  1 

      init-fat-cache
1A2CBD8 	38 C4 A2  1 

      \ Start with the root directory as the current working directory
      rdirclus @  dv_cwd-cl l! 
1A2CBDC 	40 BB A2  1 
1A2CBE0 	5C 4C A0  1 84 BB A2  1 
1A2CBE8 	7C 4D A0  1 

      free-bpb
1A2CBEC 	68 C5 A2  1 
   then
;
1A2CBF0 	58 46 A0  1 

: set-device  ( device# -- )  (set-device)  ?read-bpb  ;
1A2CBF4 	 0 73 65 74 
1A2CBF8 	2D 64 65 76 69 63 65 8A 
1A2CC00 	58 CB A2  1 20 40 A0  1 
1A2CC08 	28 C5 A2  1 58 CB A2  1 
1A2CC10 	58 46 A0  1 

\ : stand-init  ( -- )  stand-init  clear-device-records  ;

OpenFirmware/ofw/fs/fatfs/device.fth_AL	940 1A2CC14 \ Cluster access

\ mmo private

: cl#>sector#  ( cluster# -- sector# )
1A2CC14 	63 6C 23 3E 
1A2CC18 	73 65 63 74 6F 72 23 8B 
1A2CC20 	 4 CC A2  1 20 40 A0  1 
   2 -  spc c@ *  cl-sector0 l@ +
1A2CC28 	90 6F A0  1 18 45 A0  1 
1A2CC30 	58 BC A2  1 C4 4C A0  1 
1A2CC38 	1C 5F A0  1 6C BB A2  1 
1A2CC40 	6C 4C A0  1  4 45 A0  1 
;
1A2CC48 	58 46 A0  1 
: cl>sector  ( cluster# #clusters -- sector# #sectors )
1A2CC4C 	 0  0 63 6C 
1A2CC50 	3E 73 65 63 74 6F 72 89 
1A2CC58 	24 CC A2  1 20 40 A0  1 
   swap  cl#>sector#                ( #clusters sector# )
1A2CC60 	68 49 A0  1 24 CC A2  1 
   swap  spc c@ *                   ( sector# #sectors )
1A2CC68 	68 49 A0  1 58 BC A2  1 
1A2CC70 	C4 4C A0  1 1C 5F A0  1 
;
1A2CC78 	58 46 A0  1 

: read-clusters  ( cluster# #clusters adr -- error? )
1A2CC7C 	 0  0 72 65 
1A2CC80 	61 64 2D 63 6C 75 73 74 
1A2CC88 	65 72 73 8D 5C CC A2  1 
1A2CC90 	20 40 A0  1 
   >r  cl>sector  r>  read-sectors
1A2CC94 	BC 45 A0  1 
1A2CC98 	5C CC A2  1 D0 45 A0  1 
1A2CCA0 	4C BE A2  1 
;
1A2CCA4 	58 46 A0  1 
: write-clusters  ( cluster# #clusters adr -- error? )
1A2CCA8 	 0 77 72 69 74 65 2D 63 
1A2CCB0 	6C 75 73 74 65 72 73 8E 
1A2CCB8 	90 CC A2  1 20 40 A0  1 
   >r  cl>sector  r>  write-sectors
1A2CCC0 	BC 45 A0  1 5C CC A2  1 
1A2CCC8 	D0 45 A0  1 8C BE A2  1 
;
1A2CCD0 	58 46 A0  1 

OpenFirmware/ofw/fs/fatfs/rwclusts.fth_AL	C0 1A2CCD4 \ File Allocation Table manipulation.

\ For performance, we cache a portion of the FAT (currently 3 sectors).
\ This also makes it easier to extract entries from the FAT, because
\ for floppy disk, FAT entries are 1.5 bytes long, and if we have 3
\ (or multiples of 3) sectors in the cache, then the cache contains
\ an integral number of FAT entries, with no fragments.

\ We keep a separate FAT cache for each device.
\ This improve performance and simplifies the code which deals with
\ flushing the cache, since switching devices does not require a cache
\ flush.  This also helps in supporting devices with sector sizes
\ > 512 bytes, because we can size the FAT cache as a multiple of the
\ device's native sector size.

hex

\ mmo private

\ Magic numbers for FAT entries

$0000000 constant fat-free
1A2CCD4 	 0  0  0 66 
1A2CCD8 	61 74 2D 66 72 65 65 88 
1A2CCE0 	BC CC A2  1 68 40 A0  1 
1A2CCE8 	 0  0  0  0 
$fffffff constant fat-eof
1A2CCEC 	66 61 74 2D 
1A2CCF0 	65 6F 66 87 E4 CC A2  1 
1A2CCF8 	68 40 A0  1 FF FF FF  F 
$ffffff7 constant fat-bad
1A2CD00 	66 61 74 2D 62 61 64 87 
1A2CD08 	F8 CC A2  1 68 40 A0  1 
1A2CD10 	F7 FF FF  F 

( external )
: fat-end?  ( cl# -- flag )
1A2CD14 	 0  0  0 66 
1A2CD18 	61 74 2D 65 6E 64 3F 88 
1A2CD20 	 C CD A2  1 20 40 A0  1 
   fat-type c@  case
1A2CD28 	84 BC A2  1 C4 4C A0  1 
      fat12  of  h# ff8  endof
1A2CD30 	C8 BC A2  1 48 43 A0  1 
1A2CD38 	14  0  0  0 58 41 A0  1 
1A2CD40 	F8  F  0  0 6C 43 A0  1 
1A2CD48 	40  0  0  0 
      fat16  of  h# fff8  endof
1A2CD4C 	DC BC A2  1 
1A2CD50 	48 43 A0  1 14  0  0  0 
1A2CD58 	58 41 A0  1 F8 FF  0  0 
1A2CD60 	6C 43 A0  1 24  0  0  0 
      fat32  of  h# ffffff8  endof
1A2CD68 	F0 BC A2  1 48 43 A0  1 
1A2CD70 	14  0  0  0 58 41 A0  1 
1A2CD78 	F8 FF FF  F 6C 43 A0  1 
1A2CD80 	 8  0  0  0 
   endcase
1A2CD84 	84 43 A0  1 
   >=
1A2CD88 	EC 48 A0  1 
;
1A2CD8C 	58 46 A0  1 

: cl#>sector  ( cl# -- entry# sector# )
1A2CD90 	 0 63 6C 23 3E 73 65 63 
1A2CD98 	74 6F 72 8A 24 CD A2  1 
1A2CDA0 	20 40 A0  1 
   cl#/fat-cache w@ /mod  sectors/fat-cache w@ *  ( entry# offset-sectors )
1A2CDA4 	D8 BB A2  1 
1A2CDA8 	94 4C A0  1 50 5F A0  1 
1A2CDB0 	A4 BB A2  1 94 4C A0  1 
1A2CDB8 	1C 5F A0  1 
   fat-sector0 w@ +                               ( entry# sector# )
1A2CDBC 	F0 BB A2  1 
1A2CDC0 	94 4C A0  1  4 45 A0  1 
;
1A2CDC8 	58 46 A0  1 

\ The number of sectors of the FAT cache which actually represent valid
\ disk sectors.  For instance, if the FAT has 5 total sectors, and the
\ FAT cache has 3 sectors, then sometimes only 2 of the sectors in the
\ FAT cache will be valid.

: #valid-sectors  ( -- n )
1A2CDCC 	 0 23 76 61 
1A2CDD0 	6C 69 64 2D 73 65 63 74 
1A2CDD8 	6F 72 73 8E A0 CD A2  1 
1A2CDE0 	20 40 A0  1 
   spf l@ fat-sector @ fat-sector0 w@ -  -  sectors/fat-cache w@ min
1A2CDE4 	28 BB A2  1 
1A2CDE8 	6C 4C A0  1 18 BB A2  1 
1A2CDF0 	5C 4C A0  1 F0 BB A2  1 
1A2CDF8 	94 4C A0  1 18 45 A0  1 
1A2CE00 	18 45 A0  1 A4 BB A2  1 
1A2CE08 	94 4C A0  1 74 4A A0  1 
;
1A2CE10 	58 46 A0  1 

create "fat ," File Allocation Table"
1A2CE14 	 0  0  0 22 
1A2CE18 	66 61 74 84 E0 CD A2  1 
1A2CE20 	30 40 A0  1 15 46 69 6C 
1A2CE28 	65 20 41 6C 6C 6F 63 61 
1A2CE30 	74 69 6F 6E 20 54 61 62 
1A2CE38 	6C 65  0  0 

\ If the FAT cache has been modified since it was last written, flush it
\ to disk.

: .sectors  ( sector# #sectors -- )
1A2CE3C 	 0  0  0 2E 
1A2CE40 	73 65 63 74 6F 72 73 88 
1A2CE48 	20 CE A2  1 20 40 A0  1 
   ."  " . ." sectors starting at " .
1A2CE50 	20 7C A0  1  1 20  0  0 
1A2CE58 	94 7A A0  1 20 7C A0  1 
1A2CE60 	14 73 65 63 74 6F 72 73 
1A2CE68 	20 73 74 61 72 74 69 6E 
1A2CE70 	67 20 61 74 20  0  0  0 
1A2CE78 	94 7A A0  1 
;
1A2CE7C 	58 46 A0  1 
: ?flush-fat-cache  ( -- )
1A2CE80 	 0  0  0 3F 66 6C 75 73 
1A2CE88 	68 2D 66 61 74 2D 63 61 
1A2CE90 	63 68 65 90 4C CE A2  1 
1A2CE98 	20 40 A0  1 
   fat-dirty w@ if
1A2CE9C 	BC BB A2  1 
1A2CEA0 	94 4C A0  1 DC 41 A0  1 
1A2CEA8 	C0  0  0  0 
      fat-sector @ #valid-sectors fat-cache @ write-sectors  ( err? )  if
1A2CEAC 	18 BB A2  1 
1A2CEB0 	5C 4C A0  1 E0 CD A2  1 
1A2CEB8 	 0 BB A2  1 5C 4C A0  1 
1A2CEC0 	8C BE A2  1 DC 41 A0  1 
1A2CEC8 	28  0  0  0 
         "CaW ".  "FAT ".
1A2CECC 	D4 B3 A2  1 
1A2CED0 	A8 7C A0  1 20 CE A2  1 
1A2CED8 	A8 7C A0  1 
         fat-sector @  #valid-sectors  .sectors
1A2CEDC 	18 BB A2  1 
1A2CEE0 	5C 4C A0  1 E0 CD A2  1 
1A2CEE8 	4C CE A2  1 
         abort
1A2CEEC 	28 91 A0  1 
      then

      fat-sector @ spf l@ + #valid-sectors fat-cache @ write-sectors  if
1A2CEF0 	18 BB A2  1 5C 4C A0  1 
1A2CEF8 	28 BB A2  1 6C 4C A0  1 
1A2CF00 	 4 45 A0  1 E0 CD A2  1 
1A2CF08 	 0 BB A2  1 5C 4C A0  1 
1A2CF10 	8C BE A2  1 DC 41 A0  1 
1A2CF18 	44  0  0  0 
         "CaW ".  ." alternate "  "FAT ".
1A2CF1C 	D4 B3 A2  1 
1A2CF20 	A8 7C A0  1 20 7C A0  1 
1A2CF28 	 A 61 6C 74 65 72 6E 61 
1A2CF30 	74 65 20  0 20 CE A2  1 
1A2CF38 	A8 7C A0  1 
         fat-sector @ spf l@ +  #valid-sectors  .sectors
1A2CF3C 	18 BB A2  1 
1A2CF40 	5C 4C A0  1 28 BB A2  1 
1A2CF48 	6C 4C A0  1  4 45 A0  1 
1A2CF50 	E0 CD A2  1 4C CE A2  1 
         abort
1A2CF58 	28 91 A0  1 
      then

      false fat-dirty w!
1A2CF5C 	18 70 A0  1 
1A2CF60 	BC BB A2  1 A4 4D A0  1 
   then
   write-fsinfo 
1A2CF68 	74 C8 A2  1 
;
1A2CF6C 	58 46 A0  1 
: get-fat-entries  ( cl# -- entry# cache-adr )
1A2CF70 	67 65 74 2D 66 61 74 2D 
1A2CF78 	65 6E 74 72 69 65 73 8F 
1A2CF80 	98 CE A2  1 20 40 A0  1 
   cl#>sector                   ( entry# sector# )
1A2CF88 	A0 CD A2  1 
   dup fat-sector @ =  if       \ Requested sector is in the FAT cache
1A2CF8C 	40 49 A0  1 
1A2CF90 	18 BB A2  1 5C 4C A0  1 
1A2CF98 	24 48 A0  1 DC 41 A0  1 
1A2CFA0 	10  0  0  0 
      drop                      ( entry# )
1A2CFA4 	30 49 A0  1 
   else                         \ Refill the FAT cache.
1A2CFA8 	C8 41 A0  1 54  0  0  0 
      ?flush-fat-cache          ( entry# sector# )
1A2CFB0 	98 CE A2  1 

      \ Invalidate fat cache in case read fails
      -1 fat-sector !
1A2CFB4 	58 41 A0  1 
1A2CFB8 	FF FF FF FF 18 BB A2  1 
1A2CFC0 	54 4D A0  1 

      dup  sectors/fat-cache w@ fat-cache @ read-sectors
1A2CFC4 	40 49 A0  1 
1A2CFC8 	A4 BB A2  1 94 4C A0  1 
1A2CFD0 	 0 BB A2  1 5C 4C A0  1 
1A2CFD8 	4C BE A2  1 
      ( entry# sector# error? )  if  "CaR ".  "FAT ".  abort  then
1A2CFDC 	DC 41 A0  1 
1A2CFE0 	18  0  0  0 B4 B3 A2  1 
1A2CFE8 	A8 7C A0  1 20 CE A2  1 
1A2CFF0 	A8 7C A0  1 28 91 A0  1 

      fat-sector !            ( entry# )
1A2CFF8 	18 BB A2  1 54 4D A0  1 
   then                       ( entry# )
   fat-cache @
1A2D000 	 0 BB A2  1 5C 4C A0  1 
;
1A2D008 	58 46 A0  1 

: cluster@  ( cl# -- cl#' )
1A2D00C 	 0  0  0 63 
1A2D010 	6C 75 73 74 65 72 40 88 
1A2D018 	84 CF A2  1 20 40 A0  1 
   dup max-cl# l@ > if  drop fat-eof exit then   \ *** cpt 06/27/90: no overrun
1A2D020 	40 49 A0  1 54 BB A2  1 
1A2D028 	6C 4C A0  1  4 48 A0  1 
1A2D030 	DC 41 A0  1 10  0  0  0 
1A2D038 	30 49 A0  1 F8 CC A2  1 
1A2D040 	40 46 A0  1 
                                                 \ *** cpt 10/30/90: >, no >= 
   get-fat-entries      ( entry# cache-adr )
1A2D044 	84 CF A2  1 
   fat-type c@  case
1A2D048 	84 BC A2  1 C4 4C A0  1 
      fat12  of
1A2D050 	C8 BC A2  1 48 43 A0  1 
1A2D058 	58  0  0  0 
	 over 2/ 3 *  +  le24@  ( entry# 2-entries )
1A2D05C 	54 49 A0  1 
1A2D060 	78 4B A0  1 A0 6F A0  1 
1A2D068 	1C 5F A0  1  4 45 A0  1 
1A2D070 	38 B5 A2  1 
         swap 1 and  if  d# 12 >>  else  000fff and  then
1A2D074 	68 49 A0  1 
1A2D078 	80 6F A0  1 5C 44 A0  1 
1A2D080 	DC 41 A0  1 18  0  0  0 
1A2D088 	58 41 A0  1  C  0  0  0 
1A2D090 	DC 44 A0  1 C8 41 A0  1 
1A2D098 	10  0  0  0 58 41 A0  1 
1A2D0A0 	FF  F  0  0 5C 44 A0  1 
      endof
1A2D0A8 	6C 43 A0  1 54  0  0  0 
      fat16  of
1A2D0B0 	DC BC A2  1 48 43 A0  1 
1A2D0B8 	18  0  0  0 
         swap wa+ lew@
1A2D0BC 	68 49 A0  1 
1A2D0C0 	18 50 A0  1 7C B4 A2  1 
      endof
1A2D0C8 	6C 43 A0  1 34  0  0  0 
      fat32  of
1A2D0D0 	F0 BC A2  1 48 43 A0  1 
1A2D0D8 	24  0  0  0 
         swap la+ lel@  h# 0fffffff and
1A2D0DC 	68 49 A0  1 
1A2D0E0 	30 50 A0  1 DC B4 A2  1 
1A2D0E8 	58 41 A0  1 FF FF FF  F 
1A2D0F0 	5C 44 A0  1 
      endof
1A2D0F4 	6C 43 A0  1 
1A2D0F8 	 8  0  0  0 
   endcase
1A2D0FC 	84 43 A0  1 
;
1A2D100 	58 46 A0  1 

: cluster!  ( new-cl# adr-cl# -- )
1A2D104 	 0  0  0 63 
1A2D108 	6C 75 73 74 65 72 21 88 
1A2D110 	1C D0 A2  1 20 40 A0  1 
   get-fat-entries        ( new-cl# entry# cache-adr )
1A2D118 	84 CF A2  1 
   fat-type c@  case
1A2D11C 	84 BC A2  1 
1A2D120 	C4 4C A0  1 
      fat12  of
1A2D124 	C8 BC A2  1 
1A2D128 	48 43 A0  1 94  0  0  0 
         rot fff and -rot
1A2D130 	7C 49 A0  1 58 41 A0  1 
1A2D138 	FF  F  0  0 5C 44 A0  1 
1A2D140 	94 49 A0  1 
         over 2/ 3 *  +  dup >r  le24@  ( cl# entry# 2-entries )  ( r: adr )
1A2D144 	54 49 A0  1 
1A2D148 	78 4B A0  1 A0 6F A0  1 
1A2D150 	1C 5F A0  1  4 45 A0  1 
1A2D158 	40 49 A0  1 BC 45 A0  1 
1A2D160 	38 B5 A2  1 
         swap 1 and  if  000fff and  swap d# 12 <<  or  else  fff000 and or  then
1A2D164 	68 49 A0  1 
1A2D168 	80 6F A0  1 5C 44 A0  1 
1A2D170 	DC 41 A0  1 2C  0  0  0 
1A2D178 	58 41 A0  1 FF  F  0  0 
1A2D180 	5C 44 A0  1 68 49 A0  1 
1A2D188 	58 41 A0  1  C  0  0  0 
1A2D190 	C8 44 A0  1 70 44 A0  1 
1A2D198 	C8 41 A0  1 14  0  0  0 
1A2D1A0 	58 41 A0  1  0 F0 FF  0 
1A2D1A8 	5C 44 A0  1 70 44 A0  1 
         r> le24!
1A2D1B0 	D0 45 A0  1 78 B5 A2  1 
      endof
1A2D1B8 	6C 43 A0  1 5C  0  0  0 
      fat16  of
1A2D1C0 	DC BC A2  1 48 43 A0  1 
1A2D1C8 	2C  0  0  0 
         rot ffff and -rot
1A2D1CC 	7C 49 A0  1 
1A2D1D0 	58 41 A0  1 FF FF  0  0 
1A2D1D8 	5C 44 A0  1 94 49 A0  1 
         swap wa+ lew!
1A2D1E0 	68 49 A0  1 18 50 A0  1 
1A2D1E8 	A8 B4 A2  1 
      endof
1A2D1EC 	6C 43 A0  1 
1A2D1F0 	28  0  0  0 
      fat32  of
1A2D1F4 	F0 BC A2  1 
1A2D1F8 	48 43 A0  1 18  0  0  0 
         swap la+ lel!
1A2D200 	68 49 A0  1 30 50 A0  1 
1A2D208 	 8 B5 A2  1 
      endof
1A2D20C 	6C 43 A0  1 
1A2D210 	 8  0  0  0 
   endcase
1A2D214 	84 43 A0  1 
   true fat-dirty w!
1A2D218 	 4 70 A0  1 BC BB A2  1 
1A2D220 	A4 4D A0  1 
;
1A2D224 	58 46 A0  1 

\ mmo private

\ For performance sake, we search for clusters physically near the
\ cluster presently at the end of the file, and we especially try to
\ find one which would be in the fat cache at the same time as the
\ previous cluster.

: search-up  ( high-cluster# low-cluster# -- cluster# true  |  false )
1A2D228 	 0  0 73 65 61 72 63 68 
1A2D230 	2D 75 70 89 14 D1 A2  1 
1A2D238 	20 40 A0  1 
   false -rot  ?do
1A2D23C 	18 70 A0  1 
1A2D240 	94 49 A0  1 50 42 A0  1 
1A2D248 	30  0  0  0 
      i cluster@ 0=  if  drop i true leave  then
1A2D24C 	B4 42 A0  1 
1A2D250 	1C D0 A2  1 24 47 A0  1 
1A2D258 	DC 41 A0  1 14  0  0  0 
1A2D260 	30 49 A0  1 B4 42 A0  1 
1A2D268 	 4 70 A0  1 18 43 A0  1 
   loop
1A2D270 	F8 41 A0  1 D8 FF FF FF 
;
1A2D278 	58 46 A0  1 
: search-down  ( low-cluster# high-cluster# -- cluster# true  |  false )
1A2D27C 	73 65 61 72 
1A2D280 	63 68 2D 64 6F 77 6E 8B 
1A2D288 	38 D2 A2  1 20 40 A0  1 
   false -rot  ?do
1A2D290 	18 70 A0  1 94 49 A0  1 
1A2D298 	50 42 A0  1 38  0  0  0 
      i cluster@ 0=  if  drop i true leave  then
1A2D2A0 	B4 42 A0  1 1C D0 A2  1 
1A2D2A8 	24 47 A0  1 DC 41 A0  1 
1A2D2B0 	14  0  0  0 30 49 A0  1 
1A2D2B8 	B4 42 A0  1  4 70 A0  1 
1A2D2C0 	18 43 A0  1 
   -1 +loop
1A2D2C4 	58 41 A0  1 
1A2D2C8 	FF FF FF FF 1C 42 A0  1 
1A2D2D0 	D0 FF FF FF 
;
1A2D2D4 	58 46 A0  1 

\ Search order for free clusters:  First search toward the nearest
\ fat cache boundary, then search toward the other fat cache boundary, then
\ search from the beginning of the disk, then search the rest of the disk.

VARIABLE hint  VARIABLE fatc-start  VARIABLE fatc-end
1A2D2D8 	 0  0  0 68 69 6E 74 84 
1A2D2E0 	8C D2 A2  1 48 40 A0  1 
1A2D2E8 	14  9  0  0  0 66 61 74 
1A2D2F0 	63 2D 73 74 61 72 74 8A 
1A2D2F8 	E4 D2 A2  1 48 40 A0  1 
1A2D300 	18  9  0  0  0  0  0 66 
1A2D308 	61 74 63 2D 65 6E 64 88 
1A2D310 	FC D2 A2  1 48 40 A0  1 
1A2D318 	1C  9  0  0 

\ Be careful to avoid cluster numbers 0 and 1, which are reserved
: set-breaks  ( hint-cluster# -- )
1A2D31C 	 0 73 65 74 
1A2D320 	2D 62 72 65 61 6B 73 8A 
1A2D328 	14 D3 A2  1 20 40 A0  1 
   2 max  dup hint !
1A2D330 	90 6F A0  1 9C 4A A0  1 
1A2D338 	40 49 A0  1 E4 D2 A2  1 
1A2D340 	54 4D A0  1 
   dup cl#/fat-cache w@ mod -  2 max  dup fatc-start !
1A2D344 	40 49 A0  1 
1A2D348 	D8 BB A2  1 94 4C A0  1 
1A2D350 	B0 5F A0  1 18 45 A0  1 
1A2D358 	90 6F A0  1 9C 4A A0  1 
1A2D360 	40 49 A0  1 FC D2 A2  1 
1A2D368 	54 4D A0  1 
   cl#/fat-cache w@ +  max-cl# l@ min  fatc-end !
1A2D36C 	D8 BB A2  1 
1A2D370 	94 4C A0  1  4 45 A0  1 
1A2D378 	54 BB A2  1 6C 4C A0  1 
1A2D380 	74 4A A0  1 14 D3 A2  1 
1A2D388 	54 4D A0  1 
;
1A2D38C 	58 46 A0  1 

\ Set the new cluster's link to "eof", thus removing it from the free list.
\ This depends on the fact that newly-allocated clusters are always attached
\ to the end of a file.

: mark-cluster  ( cluster# -- cluster# true )
1A2D390 	 0  0  0 6D 61 72 6B 2D 
1A2D398 	63 6C 75 73 74 65 72 8C 
1A2D3A0 	2C D3 A2  1 20 40 A0  1 
   \ Set the new cluster's link to "eof"
   fat-eof over cluster!   ( cluster# )
1A2D3A8 	F8 CC A2  1 54 49 A0  1 
1A2D3B0 	14 D1 A2  1 
   true
1A2D3B4 	 4 70 A0  1 
;
1A2D3B8 	58 46 A0  1 

: (allocate-cluster)  ( hint-cluster# -- cluster# true  |  false )
1A2D3BC 	 0 28 61 6C 
1A2D3C0 	6C 6F 63 61 74 65 2D 63 
1A2D3C8 	6C 75 73 74 65 72 29 92 
1A2D3D0 	A4 D3 A2  1 20 40 A0  1 
   set-breaks
1A2D3D8 	2C D3 A2  1 
   hint @ fatc-start @ -  fatc-end @ hint @ -  <  if    \ Search down first
1A2D3DC 	E4 D2 A2  1 
1A2D3E0 	5C 4C A0  1 FC D2 A2  1 
1A2D3E8 	5C 4C A0  1 18 45 A0  1 
1A2D3F0 	14 D3 A2  1 5C 4C A0  1 
1A2D3F8 	E4 D2 A2  1 5C 4C A0  1 
1A2D400 	18 45 A0  1 E4 47 A0  1 
1A2D408 	DC 41 A0  1 54  0  0  0 
      fatc-start @ hint @  search-down  if  mark-cluster exit  then
1A2D410 	FC D2 A2  1 5C 4C A0  1 
1A2D418 	E4 D2 A2  1 5C 4C A0  1 
1A2D420 	8C D2 A2  1 DC 41 A0  1 
1A2D428 	 C  0  0  0 A4 D3 A2  1 
1A2D430 	40 46 A0  1 
      fatc-end @   hint @  search-up    if  mark-cluster exit  then
1A2D434 	14 D3 A2  1 
1A2D438 	5C 4C A0  1 E4 D2 A2  1 
1A2D440 	5C 4C A0  1 38 D2 A2  1 
1A2D448 	DC 41 A0  1  C  0  0  0 
1A2D450 	A4 D3 A2  1 40 46 A0  1 
   else                                                 \ Search up first
1A2D458 	C8 41 A0  1 4C  0  0  0 
      fatc-end @   hint @  search-up    if  mark-cluster exit  then
1A2D460 	14 D3 A2  1 5C 4C A0  1 
1A2D468 	E4 D2 A2  1 5C 4C A0  1 
1A2D470 	38 D2 A2  1 DC 41 A0  1 
1A2D478 	 C  0  0  0 A4 D3 A2  1 
1A2D480 	40 46 A0  1 
      fatc-start @ hint @  search-down  if  mark-cluster exit  then
1A2D484 	FC D2 A2  1 
1A2D488 	5C 4C A0  1 E4 D2 A2  1 
1A2D490 	5C 4C A0  1 8C D2 A2  1 
1A2D498 	DC 41 A0  1  C  0  0  0 
1A2D4A0 	A4 D3 A2  1 40 46 A0  1 
   then

   \ Search up to the end of the disk ** 10/30/90 cpt: up to last cl (1+)
   max-cl# l@ 1+ fatc-end @  search-up    if  mark-cluster exit  then
1A2D4A8 	54 BB A2  1 6C 4C A0  1 
1A2D4B0 	30 4B A0  1 14 D3 A2  1 
1A2D4B8 	5C 4C A0  1 38 D2 A2  1 
1A2D4C0 	DC 41 A0  1  C  0  0  0 
1A2D4C8 	A4 D3 A2  1 40 46 A0  1 

   \ Search down to the beginning of the disk
   2         fatc-start @  search-down  if  mark-cluster exit  then
1A2D4D0 	90 6F A0  1 FC D2 A2  1 
1A2D4D8 	5C 4C A0  1 8C D2 A2  1 
1A2D4E0 	DC 41 A0  1  C  0  0  0 
1A2D4E8 	A4 D3 A2  1 40 46 A0  1 

   false
1A2D4F0 	18 70 A0  1 
;
1A2D4F4 	58 46 A0  1 
: allocate-cluster  ( hint-cluster# -- false | cluster# true )
1A2D4F8 	 0  0  0 61 6C 6C 6F 63 
1A2D500 	61 74 65 2D 63 6C 75 73 
1A2D508 	74 65 72 90 D4 D3 A2  1 
1A2D510 	20 40 A0  1 
   fsinfo @  if                                    ( hint )
1A2D514 	D0 B9 A2  1 
1A2D518 	5C 4C A0  1 DC 41 A0  1 
1A2D520 	78  0  0  0 
      fs_#freeclusters lel@   if                   ( hint )
1A2D524 	44 BA A2  1 
1A2D528 	DC B4 A2  1 DC 41 A0  1 
1A2D530 	58  0  0  0 
         fs_freecluster# lel@ max-cl# l@ <=  if    ( hint )
1A2D534 	60 BA A2  1 
1A2D538 	DC B4 A2  1 54 BB A2  1 
1A2D540 	6C 4C A0  1  C 49 A0  1 
1A2D548 	DC 41 A0  1 10  0  0  0 
            drop fs_freecluster# lel@              ( hint' )
1A2D550 	30 49 A0  1 60 BA A2  1 
1A2D558 	DC B4 A2  1 
         then                                      ( hint )
         (allocate-cluster)                        ( false | cluster# true )
1A2D55C 	D4 D3 A2  1 
         dup  if  over fs-free#!  -1 +fs-#free  then  ( false | cluster# true )
1A2D560 	40 49 A0  1 DC 41 A0  1 
1A2D568 	18  0  0  0 54 49 A0  1 
1A2D570 	68 BD A2  1 58 41 A0  1 
1A2D578 	FF FF FF FF  8 BD A2  1 
      else                                         ( hint )
1A2D580 	C8 41 A0  1  C  0  0  0 
         drop false                                ( false )
1A2D588 	30 49 A0  1 18 70 A0  1 
      then                                         ( false | cluster# true )
   else                                            ( hint )
1A2D590 	C8 41 A0  1  8  0  0  0 
      (allocate-cluster)                           ( false | cluster# true )
1A2D598 	D4 D3 A2  1 
   then                                            ( false | cluster# true )
;
1A2D59C 	58 46 A0  1 

\ Frees first-cl# and all clusters linked after it.
: deallocate-clusters  ( first-cl# -- )
1A2D5A0 	64 65 61 6C 6C 6F 63 61 
1A2D5A8 	74 65 2D 63 6C 75 73 74 
1A2D5B0 	65 72 73 93 10 D5 A2  1 
1A2D5B8 	20 40 A0  1 
   begin
      dup 0<>  over fat-end? 0= and
1A2D5BC 	40 49 A0  1 
1A2D5C0 	44 47 A0  1 54 49 A0  1 
1A2D5C8 	24 CD A2  1 24 47 A0  1 
1A2D5D0 	5C 44 A0  1 
   while                                 ( cluster# )
1A2D5D4 	DC 41 A0  1 
1A2D5D8 	38  0  0  0 
      dup  cluster@                      ( cluster# next-cluster# )
1A2D5DC 	40 49 A0  1 
1A2D5E0 	1C D0 A2  1 
      0 rot  cluster!                    ( next-cluster# )
1A2D5E4 	70 6F A0  1 
1A2D5E8 	7C 49 A0  1 14 D1 A2  1 
      fsinfo @  if  1 +fs-#free  then    ( next-cluster# )
1A2D5F0 	D0 B9 A2  1 5C 4C A0  1 
1A2D5F8 	DC 41 A0  1  C  0  0  0 
1A2D600 	80 6F A0  1  8 BD A2  1 
   repeat
1A2D608 	C8 41 A0  1 B0 FF FF FF 
   drop
1A2D610 	30 49 A0  1 
   ?flush-fat-cache
1A2D614 	98 CE A2  1 
;
1A2D618 	58 46 A0  1 

\ mmo internal

: unmount  ( device# -- )
1A2D61C 	75 6E 6D 6F 
1A2D620 	75 6E 74 87 B8 D5 A2  1 
1A2D628 	20 40 A0  1 
   current-device @ >r  ( device# )  current-device !
1A2D62C 	A8 BA A2  1 
1A2D630 	5C 4C A0  1 BC 45 A0  1 
1A2D638 	A8 BA A2  1 54 4D A0  1 
   ?flush-fat-cache
1A2D640 	98 CE A2  1 
   \ XXX should free memory for FAT cache
   uncache-device
1A2D644 	78 C3 A2  1 
   r> current-device !
1A2D648 	D0 45 A0  1 A8 BA A2  1 
1A2D650 	54 4D A0  1 
;
1A2D654 	58 46 A0  1 

: total-size  ( -- d.bytes )  max-cl# l@ 1+  /cluster *  0  ;
1A2D658 	 0 74 6F 74 61 6C 2D 73 
1A2D660 	69 7A 65 8A 28 D6 A2  1 
1A2D668 	20 40 A0  1 54 BB A2  1 
1A2D670 	6C 4C A0  1 30 4B A0  1 
1A2D678 	18 C3 A2  1 1C 5F A0  1 
1A2D680 	70 6F A0  1 58 46 A0  1 

\ mmo public
: free-bytes  ( -- d.#bytes )
1A2D688 	 0 66 72 65 65 2D 62 79 
1A2D690 	74 65 73 8A 68 D6 A2  1 
1A2D698 	20 40 A0  1 
   \ Search up to the end of the disk
   0  max-cl# l@ 1+ 2  ?do  i cluster@ 0= if  1+  then  loop ( #free-clusters )
1A2D69C 	70 6F A0  1 
1A2D6A0 	54 BB A2  1 6C 4C A0  1 
1A2D6A8 	30 4B A0  1 90 6F A0  1 
1A2D6B0 	50 42 A0  1 24  0  0  0 
1A2D6B8 	B4 42 A0  1 1C D0 A2  1 
1A2D6C0 	24 47 A0  1 DC 41 A0  1 
1A2D6C8 	 8  0  0  0 30 4B A0  1 
1A2D6D0 	F8 41 A0  1 E4 FF FF FF 
   /cluster *  ( #bytes )
1A2D6D8 	18 C3 A2  1 1C 5F A0  1 
   0
1A2D6E0 	70 6F A0  1 
;
1A2D6E4 	58 46 A0  1 

[ifdef] notdef
\ Returns the amount of total and free space on the disk
: disk-size  ( device -- #bytes )  set-device total-size drop  ;
: disk-free  ( device -- #bytes )  set-device  free-bytes drop  ;
[then]

OpenFirmware/ofw/fs/fatfs/fat.fth_AL	A14 1A2D6E8 \ XXX perhaps we should cache a sector of the directory, rather than a cluster.
\ That would simplify the handling of end conditions in the root directory,
\ especially for writing.

\ Directory search utilities

\ FAT32 root directory is just like any subdirectory.  Only the subdirectory
\ paths are taken for FAT32 directory search.

decimal
\ mmo private

\ Working drive
instance variable drive
1A2D6E8 	 0  0 64 72 69 76 65 85 
1A2D6F0 	98 D6 A2  1 40  1 A2  1 
1A2D6F8 	20  0  0  0 

\ The state of the current search is maintained in the following variables
\ We need two copies of this state, because we have to search subdirectories
\ while parsing the path name.

instance variable search-state
1A2D6FC 	 0  0  0 73 
1A2D700 	65 61 72 63 68 2D 73 74 
1A2D708 	61 74 65 8C F4 D6 A2  1 
1A2D710 	40  1 A2  1 24  0  0  0 

: lfield ( offset size -- offset')
1A2D718 	 0 6C 66 69 65 6C 64 86 
1A2D720 	10 D7 A2  1 20 40 A0  1 
   create over , + does> @ search-state @ +
1A2D728 	A8 A2 A0  1 54 49 A0  1 
1A2D730 	98 55 A0  1  4 45 A0  1 
1A2D738 	50 A3 A0  1 90 90 90 E8 
1A2D740 	38 69 FD FF 5C 4C A0  1 
1A2D748 	10 D7 A2  1 5C 4C A0  1 
1A2D750 	 4 45 A0  1 
;
1A2D754 	58 46 A0  1 

struct   \ search-state
 /n lfield  search-cl     \ Cluster containing the next entry
1A2D758 	 0  0 73 65 61 72 63 68 
1A2D760 	2D 63 6C 89 24 D7 A2  1 
1A2D768 	3C D7 A2  1  0  0  0  0 
 /n lfield  search-offset \ Offset of the next entry in its cluster
1A2D770 	 0  0 73 65 61 72 63 68 
1A2D778 	2D 6F 66 66 73 65 74 8D 
1A2D780 	68 D7 A2  1 3C D7 A2  1 
1A2D788 	 4  0  0  0 
 /n lfield  search-dev    \ Device containing directory being searched
1A2D78C 	 0 73 65 61 
1A2D790 	72 63 68 2D 64 65 76 8A 
1A2D798 	84 D7 A2  1 3C D7 A2  1 
1A2D7A0 	 8  0  0  0 
  8 lfield  search-name   \ pattern to compare with file names
1A2D7A4 	73 65 61 72 
1A2D7A8 	63 68 2D 6E 61 6D 65 8B 
1A2D7B0 	9C D7 A2  1 3C D7 A2  1 
1A2D7B8 	 C  0  0  0 
  3 lfield  search-ext    \ pattern to compare with file extensions
1A2D7BC 	 0 73 65 61 
1A2D7C0 	72 63 68 2D 65 78 74 8A 
1A2D7C8 	B4 D7 A2  1 3C D7 A2  1 
1A2D7D0 	14  0  0  0 
  8 lfield  base-name     \ Actual filename, without path portion
1A2D7D4 	 0  0 62 61 
1A2D7D8 	73 65 2D 6E 61 6D 65 89 
1A2D7E0 	CC D7 A2  1 3C D7 A2  1 
1A2D7E8 	17  0  0  0 
  3 lfield  base-ext      \ Actual extension, without path portion
1A2D7EC 	 0  0  0 62 
1A2D7F0 	61 73 65 2D 65 78 74 88 
1A2D7F8 	E4 D7 A2  1 3C D7 A2  1 
1A2D800 	1F  0  0  0 
  1 lfield  bn-len        \ base name length
1A2D804 	 0 62 6E 2D 
1A2D808 	6C 65 6E 86 FC D7 A2  1 
1A2D810 	3C D7 A2  1 22  0  0  0 
  1 lfield  be-len        \ base extension length
1A2D818 	 0 62 65 2D 6C 65 6E 86 
1A2D820 	10 D8 A2  1 3C D7 A2  1 
1A2D828 	23  0  0  0 
  1 lfield  search-attrib \ mask for file types to consider
1A2D82C 	 0  0 73 65 
1A2D830 	61 72 63 68 2D 61 74 74 
1A2D838 	72 69 62 8D 24 D8 A2  1 
1A2D840 	3C D7 A2  1 24  0  0  0 
constant /search-state
1A2D848 	 0  0 2F 73 65 61 72 63 
1A2D850 	68 2D 73 74 61 74 65 8D 
1A2D858 	40 D8 A2  1 68 40 A0  1 
1A2D860 	25  0  0  0 

d# -200 constant cl#eof  \ Invalid cluster number to mark end of file
1A2D864 	 0 63 6C 23 
1A2D868 	65 6F 66 86 5C D8 A2  1 
1A2D870 	68 40 A0  1 38 FF FF FF 

\ Starting cluster# of the directory containing the last found file
VARIABLE search-dir-cl
1A2D878 	 0  0 73 65 61 72 63 68 
1A2D880 	2D 64 69 72 2D 63 6C 8D 
1A2D888 	70 D8 A2  1 48 40 A0  1 
1A2D890 	20  9  0  0 

/search-state instance buffer: file-search-state
1A2D894 	 0  0 66 69 
1A2D898 	6C 65 2D 73 65 61 72 63 
1A2D8A0 	68 2D 73 74 61 74 65 91 
1A2D8A8 	8C D8 A2  1 4C  0 A2  1 
1A2D8B0 	24 FF FF FF 

: characters-match?  ( filename-char pattern-char -- flag )
1A2D8B4 	 0  0 63 68 
1A2D8B8 	61 72 61 63 74 65 72 73 
1A2D8C0 	2D 6D 61 74 63 68 3F 91 
1A2D8C8 	AC D8 A2  1 20 40 A0  1 
   dup ascii ? =  if  2drop true  else  =  then
1A2D8D0 	40 49 A0  1 58 41 A0  1 
1A2D8D8 	3F  0  0  0 24 48 A0  1 
1A2D8E0 	DC 41 A0  1 14  0  0  0 
1A2D8E8 	AC 49 A0  1  4 70 A0  1 
1A2D8F0 	C8 41 A0  1  8  0  0  0 
1A2D8F8 	24 48 A0  1 
;
1A2D8FC 	58 46 A0  1 
: names-match?  ( -- flag ) \ Assumes dirent address already set
1A2D900 	 0  0  0 6E 61 6D 65 73 
1A2D908 	2D 6D 61 74 63 68 3F 8C 
1A2D910 	CC D8 A2  1 20 40 A0  1 
   true
1A2D918 	 4 70 A0  1 
   de_name  ( adr )
1A2D91C 	30 BF A2  1 
   search-name d# 11 bounds  do    ( flag adr' )
1A2D920 	B4 D7 A2  1 58 41 A0  1 
1A2D928 	 B  0  0  0 F0 6D A0  1 
1A2D930 	88 42 A0  1 40  0  0  0 
      dup c@  i c@  characters-match? 0=  if  nip false swap leave  then
1A2D938 	40 49 A0  1 C4 4C A0  1 
1A2D940 	B4 42 A0  1 C4 4C A0  1 
1A2D948 	CC D8 A2  1 24 47 A0  1 
1A2D950 	DC 41 A0  1 14  0  0  0 
1A2D958 	FC 46 A0  1 18 70 A0  1 
1A2D960 	68 49 A0  1 18 43 A0  1 
      1+
1A2D968 	30 4B A0  1 
   loop   ( flag adr )
1A2D96C 	F8 41 A0  1 
1A2D970 	C8 FF FF FF 
   drop
1A2D974 	30 49 A0  1 
;
1A2D978 	58 46 A0  1 

\ Local variables used by the pattern parser "set-pattern"
variable buf-adr
1A2D97C 	62 75 66 2D 
1A2D980 	61 64 72 87 14 D9 A2  1 
1A2D988 	48 40 A0  1 24  9  0  0 
variable buf-rem
1A2D990 	62 75 66 2D 72 65 6D 87 
1A2D998 	88 D9 A2  1 48 40 A0  1 
1A2D9A0 	28  9  0  0 
variable pat-adr
1A2D9A4 	70 61 74 2D 
1A2D9A8 	61 64 72 87 9C D9 A2  1 
1A2D9B0 	48 40 A0  1 2C  9  0  0 
variable pat-rem
1A2D9B8 	70 61 74 2D 72 65 6D 87 
1A2D9C0 	B0 D9 A2  1 48 40 A0  1 
1A2D9C8 	30  9  0  0 
: set-char  ( char -- )  buf-adr @ c!  1 buf-adr +!  -1 buf-rem +!  ;
1A2D9CC 	 0  0  0 73 
1A2D9D0 	65 74 2D 63 68 61 72 88 
1A2D9D8 	C4 D9 A2  1 20 40 A0  1 
1A2D9E0 	88 D9 A2  1 5C 4C A0  1 
1A2D9E8 	B8 4D A0  1 80 6F A0  1 
1A2D9F0 	88 D9 A2  1  C 4C A0  1 
1A2D9F8 	58 41 A0  1 FF FF FF FF 
1A2DA00 	9C D9 A2  1  C 4C A0  1 
1A2DA08 	58 46 A0  1 
: set-pattern  ( pattern-adr pattern-len  buf-adr buf-len -- )
1A2DA0C 	73 65 74 2D 
1A2DA10 	70 61 74 74 65 72 6E 8B 
1A2DA18 	DC D9 A2  1 20 40 A0  1 
   2dup blank  ( pattern-adr pattern-len  buf-adr buf-len )
1A2DA20 	C0 49 A0  1  C 73 A0  1 
   rot over min -rot  ( pattern-adr pattern-len'  buf-adr buf-len )
1A2DA28 	7C 49 A0  1 54 49 A0  1 
1A2DA30 	74 4A A0  1 94 49 A0  1 
   buf-rem !  buf-adr !  pat-rem !  pat-adr !
1A2DA38 	9C D9 A2  1 54 4D A0  1 
1A2DA40 	88 D9 A2  1 54 4D A0  1 
1A2DA48 	C4 D9 A2  1 54 4D A0  1 
1A2DA50 	B0 D9 A2  1 54 4D A0  1 
   begin
      pat-rem @
1A2DA58 	C4 D9 A2  1 5C 4C A0  1 
   while
1A2DA60 	DC 41 A0  1 DC  0  0  0 
      pat-adr @ c@  1 pat-adr +!  -1 pat-rem +!
1A2DA68 	B0 D9 A2  1 5C 4C A0  1 
1A2DA70 	C4 4C A0  1 80 6F A0  1 
1A2DA78 	B0 D9 A2  1  C 4C A0  1 
1A2DA80 	58 41 A0  1 FF FF FF FF 
1A2DA88 	C4 D9 A2  1  C 4C A0  1 
      dup ascii *  =  if
1A2DA90 	40 49 A0  1 58 41 A0  1 
1A2DA98 	2A  0  0  0 24 48 A0  1 
1A2DAA0 	DC 41 A0  1 8C  0  0  0 
         drop  buf-adr @  buf-rem @  bounds  ?do  ascii ? i c!  loop
1A2DAA8 	30 49 A0  1 88 D9 A2  1 
1A2DAB0 	5C 4C A0  1 9C D9 A2  1 
1A2DAB8 	5C 4C A0  1 F0 6D A0  1 
1A2DAC0 	50 42 A0  1 1C  0  0  0 
1A2DAC8 	58 41 A0  1 3F  0  0  0 
1A2DAD0 	B4 42 A0  1 B8 4D A0  1 
1A2DAD8 	F8 41 A0  1 EC FF FF FF 
  buf-rem @  pat-rem @  >  if
1A2DAE0 	9C D9 A2  1 5C 4C A0  1 
1A2DAE8 	C4 D9 A2  1 5C 4C A0  1 
1A2DAF0 	 4 48 A0  1 DC 41 A0  1 
1A2DAF8 	30  0  0  0 
     buf-rem @  pat-rem @  -  buf-adr +!  pat-rem @ buf-rem !
1A2DAFC 	9C D9 A2  1 
1A2DB00 	5C 4C A0  1 C4 D9 A2  1 
1A2DB08 	5C 4C A0  1 18 45 A0  1 
1A2DB10 	88 D9 A2  1  C 4C A0  1 
1A2DB18 	C4 D9 A2  1 5C 4C A0  1 
1A2DB20 	9C D9 A2  1 54 4D A0  1 
         then
      else
1A2DB28 	C8 41 A0  1  C  0  0  0 
  upc set-char
1A2DB30 	D0 51 A0  1 DC D9 A2  1 
      then
   repeat
1A2DB38 	C8 41 A0  1 1C FF FF FF 
;
1A2DB40 	58 46 A0  1 
: drive#  ( adr len -- adr' len' drive# )
1A2DB44 	 0 64 72 69 
1A2DB48 	76 65 23 86 1C DA A2  1 
1A2DB50 	20 40 A0  1 
[ifdef] notdef
   ascii : left-parse-string   rot  if
      rot c@  upc  dup  ascii A  ascii Z  between  if
         ascii A -
      else
         drop  drive @
      then
   else
      rot drop  drive @
   then                ( adr' len' )
[else]
   drive @
1A2DB54 	F4 D6 A2  1 
1A2DB58 	5C 4C A0  1 
[then]
;
1A2DB5C 	58 46 A0  1 
: dot-name?  ( adr len -- flag )  2dup  " ." $=  -rot  " .." $=  or  ;
1A2DB60 	 0  0 64 6F 74 2D 6E 61 
1A2DB68 	6D 65 3F 89 50 DB A2  1 
1A2DB70 	20 40 A0  1 C0 49 A0  1 
1A2DB78 	9C 53 A0  1  1 2E  0  0 
1A2DB80 	88 8D A0  1 94 49 A0  1 
1A2DB88 	9C 53 A0  1  2 2E 2E  0 
1A2DB90 	88 8D A0  1 70 44 A0  1 
1A2DB98 	58 46 A0  1 
: set-filename  ( adr len -- )
1A2DB9C 	 0  0  0 73 
1A2DBA0 	65 74 2D 66 69 6C 65 6E 
1A2DBA8 	61 6D 65 8C 70 DB A2  1 
1A2DBB0 	20 40 A0  1 

   2dup  dot-name?  if  \ . and .. are special cases
1A2DBB4 	C0 49 A0  1 
1A2DBB8 	70 DB A2  1 DC 41 A0  1 
1A2DBC0 	14  0  0  0 
      " "
1A2DBC4 	9C 53 A0  1 
1A2DBC8 	 0  0  0  0 
   else
1A2DBCC 	C8 41 A0  1 
1A2DBD0 	14  0  0  0 
      ascii . left-parse-string  2swap
1A2DBD4 	58 41 A0  1 
1A2DBD8 	2E  0  0  0 44 D7 A0  1 
1A2DBE0 	F4 49 A0  1 
   then                                ( name-adr name-len ext-adr ext-len )

   base-ext 3 BLANK  base-name 8 BLANK  \ Prime with blanks
1A2DBE4 	FC D7 A2  1 
1A2DBE8 	A0 6F A0  1  C 73 A0  1 
1A2DBF0 	E4 D7 A2  1 F0 6F A0  1 
1A2DBF8 	 C 73 A0  1 

   2dup dup be-len c! base-ext swap cmove
1A2DBFC 	C0 49 A0  1 
1A2DC00 	40 49 A0  1 24 D8 A2  1 
1A2DC08 	B8 4D A0  1 FC D7 A2  1 
1A2DC10 	68 49 A0  1 10 44 A0  1 
   search-ext 3 set-pattern    ( name-adr name-len )
1A2DC18 	CC D7 A2  1 A0 6F A0  1 
1A2DC20 	1C DA A2  1 
   2dup dup bn-len c! base-name swap cmove
1A2DC24 	C0 49 A0  1 
1A2DC28 	40 49 A0  1 10 D8 A2  1 
1A2DC30 	B8 4D A0  1 E4 D7 A2  1 
1A2DC38 	68 49 A0  1 10 44 A0  1 
   search-name 8 set-pattern
1A2DC40 	B4 D7 A2  1 F0 6F A0  1 
1A2DC48 	1C DA A2  1 

   \ Convert all copies of the strings to upper case
   base-ext  be-len c@ upper   base-name bn-len c@ upper
1A2DC4C 	FC D7 A2  1 
1A2DC50 	24 D8 A2  1 C4 4C A0  1 
1A2DC58 	64 85 A0  1 E4 D7 A2  1 
1A2DC60 	10 D8 A2  1 C4 4C A0  1 
1A2DC68 	64 85 A0  1 
   search-ext 3 upper  search-name 8 upper
1A2DC6C 	CC D7 A2  1 
1A2DC70 	A0 6F A0  1 64 85 A0  1 
1A2DC78 	B4 D7 A2  1 F0 6F A0  1 
1A2DC80 	64 85 A0  1 
;
1A2DC84 	58 46 A0  1 

\ Write-through directory cache.

\ h# 4000 constant /cluster-max
\ /cluster-max instance buffer: dir-buf
variable dir-dev   -1 dir-dev !
1A2DC88 	64 69 72 2D 64 65 76 87 
1A2DC90 	B0 DB A2  1 48 40 A0  1 
1A2DC98 	34  9  0  0 
variable dir-cl  cl#eof dir-cl !
1A2DC9C 	 0 64 69 72 
1A2DCA0 	2D 63 6C 86 94 DC A2  1 
1A2DCA8 	48 40 A0  1 38  9  0  0 

: cl>root-sectors  ( -cl# -- #sectors )  negate  spc c@ *  ;
1A2DCB0 	63 6C 3E 72 6F 6F 74 2D 
1A2DCB8 	73 65 63 74 6F 72 73 8F 
1A2DCC0 	A8 DC A2  1 20 40 A0  1 
1A2DCC8 	48 45 A0  1 58 BC A2  1 
1A2DCD0 	C4 4C A0  1 1C 5F A0  1 
1A2DCD8 	58 46 A0  1 

: init-dir  ( -- )
1A2DCDC 	 0  0  0 69 
1A2DCE0 	6E 69 74 2D 64 69 72 88 
1A2DCE8 	C4 DC A2  1 20 40 A0  1 
   -1 dir-dev !		\ Marks the cache as empty
1A2DCF0 	58 41 A0  1 FF FF FF FF 
1A2DCF8 	94 DC A2  1 54 4D A0  1 
   rdirclus @ ?dup  0=  if  cl#eof  then  dir-cl !
1A2DD00 	40 BB A2  1 5C 4C A0  1 
1A2DD08 	B4 70 A0  1 24 47 A0  1 
1A2DD10 	DC 41 A0  1  8  0  0  0 
1A2DD18 	70 D8 A2  1 A8 DC A2  1 
1A2DD20 	54 4D A0  1 
;
1A2DD24 	58 46 A0  1 

\ Handle possible swap of removable media.
: ?media-changed  ( -- )
1A2DD28 	 0 3F 6D 65 64 69 61 2D 
1A2DD30 	63 68 61 6E 67 65 64 8E 
1A2DD38 	EC DC A2  1 20 40 A0  1 
   DOS-LOCK  media-changed?  if  init-dir  then
1A2DD40 	64 4F A0  1 4C C5 A2  1 
1A2DD48 	DC 41 A0  1  8  0  0  0 
1A2DD50 	EC DC A2  1 
;
1A2DD54 	58 46 A0  1 

\ Directory clusters numbers are funny, because the root directory is
\ outside the normal range of clusters and its size is not necessarily a
\ multiple of the cluster size.  We use positive numbers for clusters
\ in subdirectories, 0 for the first "cluster" in the root directory,
\ and negative numbers for subsequent "clusters" in the root directory.

\ Writes the directory cache contents to disks.
: write-dir-cl  ( -- error? )
1A2DD58 	 0  0  0 77 72 69 74 65 
1A2DD60 	2D 64 69 72 2D 63 6C 8C 
1A2DD68 	3C DD A2  1 20 40 A0  1 
   dir-dev @ set-device
1A2DD70 	94 DC A2  1 5C 4C A0  1 
1A2DD78 	 4 CC A2  1 
   dir-cl @ 0>  if    \ Subdirectory cluster
1A2DD7C 	A8 DC A2  1 
1A2DD80 	5C 4C A0  1 A4 47 A0  1 
1A2DD88 	DC 41 A0  1 20  0  0  0 
      dir-cl @ 1  dir-buf  write-clusters   ( error? )
1A2DD90 	A8 DC A2  1 5C 4C A0  1 
1A2DD98 	80 6F A0  1 1C C4 A2  1 
1A2DDA0 	BC CC A2  1 
   else      \ Root directory sectors
1A2DDA4 	C8 41 A0  1 
1A2DDA8 	48  0  0  0 
      dir-cl @ cl>root-sectors              ( rel-sector# )
1A2DDAC 	A8 DC A2  1 
1A2DDB0 	5C 4C A0  1 C4 DC A2  1 
      #dir-sectors w@ over -                ( rel-sector# rem-#sectors )
1A2DDB8 	24 BC A2  1 94 4C A0  1 
1A2DDC0 	54 49 A0  1 18 45 A0  1 
      spc c@ min                            ( rel-sector# #sectors )
1A2DDC8 	58 BC A2  1 C4 4C A0  1 
1A2DDD0 	74 4A A0  1 
      swap dir-sector0 w@ + swap            ( sector# #sectors )
1A2DDD4 	68 49 A0  1 
1A2DDD8 	 8 BC A2  1 94 4C A0  1 
1A2DDE0 	 4 45 A0  1 68 49 A0  1 
      dir-buf  write-sectors      ( error? )
1A2DDE8 	1C C4 A2  1 8C BE A2  1 
   then
;
1A2DDF0 	58 46 A0  1 

\ Ensures that the cluster containing the desired directory entry is in
\ memory, reading it from disk if necessary.
: set-dirent  ( offset cl dev -- error? )
1A2DDF4 	 0 73 65 74 
1A2DDF8 	2D 64 69 72 65 6E 74 8A 
1A2DE00 	6C DD A2  1 20 40 A0  1 
   rot  dir-buf + dirent !                     ( cl dev )
1A2DE08 	7C 49 A0  1 1C C4 A2  1 
1A2DE10 	 4 45 A0  1 DC BE A2  1 
1A2DE18 	54 4D A0  1 

   over dir-cl @ =  over dir-dev @ = and  if   ( cl dev )
1A2DE1C 	54 49 A0  1 
1A2DE20 	A8 DC A2  1 5C 4C A0  1 
1A2DE28 	24 48 A0  1 54 49 A0  1 
1A2DE30 	94 DC A2  1 5C 4C A0  1 
1A2DE38 	24 48 A0  1 5C 44 A0  1 
1A2DE40 	DC 41 A0  1 10  0  0  0 
      2drop  \ Directory cluster already in memory
1A2DE48 	AC 49 A0  1 
   else                                        ( cl dev )
1A2DE4C 	C8 41 A0  1 
1A2DE50 	28  1  0  0 
      \ The desired cluster is not in the cache, so we have to read it in.

      \ Invalidate the cache in case of read failure
      init-dir                                 ( cl dev )
1A2DE54 	EC DC A2  1 

      dup set-device                           ( cl dev )
1A2DE58 	40 49 A0  1  4 CC A2  1 

      \ Subdirectory or root directory?

      over  0>  if                             ( cl dev )
1A2DE60 	54 49 A0  1 A4 47 A0  1 
1A2DE68 	DC 41 A0  1 1C  0  0  0 
         \ Subdirectory; read clusters from cluster space
         over 1 dir-buf read-clusters          ( cl dev error? )
1A2DE70 	54 49 A0  1 80 6F A0  1 
1A2DE78 	1C C4 A2  1 90 CC A2  1 
      else                                     ( cl dev )
1A2DE80 	C8 41 A0  1 44  0  0  0 
         \ Root directory; read sectors from before cluster space
         over cl>root-sectors                  ( cl dev rel-sector# )
1A2DE88 	54 49 A0  1 C4 DC A2  1 
         #dir-sectors w@ over -                ( cl dev rel-sector# rem-#sects)
1A2DE90 	24 BC A2  1 94 4C A0  1 
1A2DE98 	54 49 A0  1 18 45 A0  1 
         spc c@ min                            ( cl dev rel-sector# #sectors )
1A2DEA0 	58 BC A2  1 C4 4C A0  1 
1A2DEA8 	74 4A A0  1 
         swap dir-sector0 w@ + swap            ( cl dev sector# #sectors )
1A2DEAC 	68 49 A0  1 
1A2DEB0 	 8 BC A2  1 94 4C A0  1 
1A2DEB8 	 4 45 A0  1 68 49 A0  1 
         dir-buf read-sectors                  ( cl dev error? )
1A2DEC0 	1C C4 A2  1 4C BE A2  1 
      then                                     ( cl dev error? )

      if  "CaR ". "dir ". cr  2drop  true exit  then
1A2DEC8 	DC 41 A0  1 24  0  0  0 
1A2DED0 	B4 B3 A2  1 A8 7C A0  1 
1A2DED8 	38 B4 A2  1 A8 7C A0  1 
1A2DEE0 	80 6D A0  1 AC 49 A0  1 
1A2DEE8 	 4 70 A0  1 40 46 A0  1 
      ( cl dev )
      \ The read succeeded, so we can set the directory cache tags
      dir-dev ! dup dir-cl !   ( cl )
1A2DEF0 	94 DC A2  1 54 4D A0  1 
1A2DEF8 	40 49 A0  1 A8 DC A2  1 
1A2DF00 	54 4D A0  1 

      \ Since the directory cache is sized in clusters, not sectors,
      \ and since a cluster may be larger than the root directory,
      \ part of the directory cache may be invalid.  This can only
      \ happen for the root directory which is allocated in sectors;
      \ subdirectories are allocated in clusters.

      0<=  if          ( )
1A2DF04 	84 47 A0  1 
1A2DF08 	DC 41 A0  1 6C  0  0  0 
         \ This is the root directory.
         \ Is part of the directory buffer invalid?

         dir-cl @ 1- cl>root-sectors #dir-sectors w@ >  if
1A2DF10 	A8 DC A2  1 5C 4C A0  1 
1A2DF18 	54 4B A0  1 C4 DC A2  1 
1A2DF20 	24 BC A2  1 94 4C A0  1 
1A2DF28 	 4 48 A0  1 DC 41 A0  1 
1A2DF30 	48  0  0  0 

            \ Set the invalid portion to look like unallocated files.
            dir-cl @ 1- cl>root-sectors #dir-sectors w@ - ( #inv-sectors )
1A2DF34 	A8 DC A2  1 
1A2DF38 	5C 4C A0  1 54 4B A0  1 
1A2DF40 	C4 DC A2  1 24 BC A2  1 
1A2DF48 	94 4C A0  1 18 45 A0  1 
            dir-buf /cluster +  swap /sector * -  0 swap c!
1A2DF50 	1C C4 A2  1 18 C3 A2  1 
1A2DF58 	 4 45 A0  1 68 49 A0  1 
1A2DF60 	F8 C2 A2  1 1C 5F A0  1 
1A2DF68 	18 45 A0  1 70 6F A0  1 
1A2DF70 	68 49 A0  1 B8 4D A0  1 
         then
      then
   then
   false
1A2DF78 	18 70 A0  1 
;
1A2DF7C 	58 46 A0  1 

: +dirent  ( -- end? )
1A2DF80 	2B 64 69 72 65 6E 74 87 
1A2DF88 	 4 DE A2  1 20 40 A0  1 
   search-cl @ cl#eof =  if  true exit  then
1A2DF90 	68 D7 A2  1 5C 4C A0  1 
1A2DF98 	70 D8 A2  1 24 48 A0  1 
1A2DFA0 	DC 41 A0  1  C  0  0  0 
1A2DFA8 	 4 70 A0  1 40 46 A0  1 

   /dirent search-offset +!
1A2DFB0 	F0 C0 A2  1 84 D7 A2  1 
1A2DFB8 	 C 4C A0  1 
   /cluster  ( dir-chunk-size )  search-offset @ >  if  false exit  then
1A2DFBC 	18 C3 A2  1 
1A2DFC0 	84 D7 A2  1 5C 4C A0  1 
1A2DFC8 	 4 48 A0  1 DC 41 A0  1 
1A2DFD0 	 C  0  0  0 18 70 A0  1 
1A2DFD8 	40 46 A0  1 
   0 search-offset !
1A2DFDC 	70 6F A0  1 
1A2DFE0 	84 D7 A2  1 54 4D A0  1 

   \ Advance to the next cluster in the directory if there is one

   search-cl @
1A2DFE8 	68 D7 A2  1 5C 4C A0  1 
   dup 0>  if                                      ( current-cluster )
1A2DFF0 	40 49 A0  1 A4 47 A0  1 
1A2DFF8 	DC 41 A0  1 18  0  0  0 
      \ It's a normal subdirectory cluster
      cluster@  dup fat-end?                       ( new-cluster# end? )
1A2E000 	1C D0 A2  1 40 49 A0  1 
1A2E008 	24 CD A2  1 
   else                                            ( current-cluster )
1A2E00C 	C8 41 A0  1 
1A2E010 	1C  0  0  0 
      \ It's the root directory so the sectors are in a fixed place
      1- dup cl>root-sectors #dir-sectors w@ >=    ( pseudo-cl# end? )
1A2E014 	54 4B A0  1 
1A2E018 	40 49 A0  1 C4 DC A2  1 
1A2E020 	24 BC A2  1 94 4C A0  1 
1A2E028 	EC 48 A0  1 
   then                                            ( new-cl# end? )

   tuck  if  drop  else  search-cl !  then         ( end? )
1A2E02C 	E8 46 A0  1 
1A2E030 	DC 41 A0  1 10  0  0  0 
1A2E038 	30 49 A0  1 C8 41 A0  1 
1A2E040 	 C  0  0  0 68 D7 A2  1 
1A2E048 	54 4D A0  1 
;
1A2E04C 	58 46 A0  1 

: advance-entry  ( -- 0=deleted | -1=okay | 1=soft-end  | 2=hard-end )
1A2E050 	 0  0 61 64 76 61 6E 63 
1A2E058 	65 2D 65 6E 74 72 79 8D 
1A2E060 	8C DF A2  1 20 40 A0  1 
   +dirent  if  2 exit  then \ Go to next dirent; exit if there are no more
1A2E068 	8C DF A2  1 DC 41 A0  1 
1A2E070 	 C  0  0  0 90 6F A0  1 
1A2E078 	40 46 A0  1 

   \ Set the directory entry address; exit if set-dirent fails
   search-offset @ search-cl @ search-dev @ set-dirent if  2 exit  then
1A2E07C 	84 D7 A2  1 
1A2E080 	5C 4C A0  1 68 D7 A2  1 
1A2E088 	5C 4C A0  1 9C D7 A2  1 
1A2E090 	5C 4C A0  1  4 DE A2  1 
1A2E098 	DC 41 A0  1  C  0  0  0 
1A2E0A0 	90 6F A0  1 40 46 A0  1 

   de_attributes c@  h# f =  if  0 exit  then  \ ignore a VFAT long file name
1A2E0A8 	68 BF A2  1 C4 4C A0  1 
1A2E0B0 	58 41 A0  1  F  0  0  0 
1A2E0B8 	24 48 A0  1 DC 41 A0  1 
1A2E0C0 	 C  0  0  0 70 6F A0  1 
1A2E0C8 	40 46 A0  1 

   de_attributes c@  at_vollab and  if  0 exit  then  \ ignore a volume label
1A2E0CC 	68 BF A2  1 
1A2E0D0 	C4 4C A0  1 C8 BF A2  1 
1A2E0D8 	5C 44 A0  1 DC 41 A0  1 
1A2E0E0 	 C  0  0  0 70 6F A0  1 
1A2E0E8 	40 46 A0  1 

   de_name c@  case
1A2E0EC 	30 BF A2  1 
1A2E0F0 	C4 4C A0  1 
      0      of     1   endof \ No more valid entries
1A2E0F4 	70 6F A0  1 
1A2E0F8 	48 43 A0  1 10  0  0  0 
1A2E100 	80 6F A0  1 6C 43 A0  1 
1A2E108 	30  0  0  0 
      h# e5  of     0   endof \ Deleted file
1A2E10C 	58 41 A0  1 
1A2E110 	E5  0  0  0 48 43 A0  1 
1A2E118 	10  0  0  0 70 6F A0  1 
1A2E120 	6C 43 A0  1 14  0  0  0 
      ( default )  -1 swap \ Valid entry
1A2E128 	58 41 A0  1 FF FF FF FF 
1A2E130 	68 49 A0  1 
   endcase
1A2E134 	84 43 A0  1 
;
1A2E138 	58 46 A0  1 

: next-file  ( -- another? )
1A2E13C 	 0  0 6E 65 
1A2E140 	78 74 2D 66 69 6C 65 89 
1A2E148 	64 E0 A2  1 20 40 A0  1 
   begin  advance-entry  dup 0<=  while  0< if  true  exit  then   repeat
1A2E150 	64 E0 A2  1 40 49 A0  1 
1A2E158 	84 47 A0  1 DC 41 A0  1 
1A2E160 	20  0  0  0 64 47 A0  1 
1A2E168 	DC 41 A0  1  C  0  0  0 
1A2E170 	 4 70 A0  1 40 46 A0  1 
1A2E178 	C8 41 A0  1 D4 FF FF FF 
   drop  false
1A2E180 	30 49 A0  1 18 70 A0  1 
;
1A2E188 	58 46 A0  1 
: find-dir  ( -- another? )
1A2E18C 	 0  0  0 66 
1A2E190 	69 6E 64 2D 64 69 72 88 
1A2E198 	4C E1 A2  1 20 40 A0  1 
   begin
      advance-entry  dup 0<=
1A2E1A0 	64 E0 A2  1 40 49 A0  1 
1A2E1A8 	84 47 A0  1 
   while
1A2E1AC 	DC 41 A0  1 
1A2E1B0 	44  0  0  0 
      0<  if
1A2E1B4 	64 47 A0  1 
1A2E1B8 	DC 41 A0  1 30  0  0  0 
         de_attributes c@ at_subdir and  if
1A2E1C0 	68 BF A2  1 C4 4C A0  1 
1A2E1C8 	E0 BF A2  1 5C 44 A0  1 
1A2E1D0 	DC 41 A0  1 18  0  0  0 
            names-match?  if  true  exit  then
1A2E1D8 	14 D9 A2  1 DC 41 A0  1 
1A2E1E0 	 C  0  0  0  4 70 A0  1 
1A2E1E8 	40 46 A0  1 
         then
      then
   repeat
1A2E1EC 	C8 41 A0  1 
1A2E1F0 	B0 FF FF FF 
   drop  false
1A2E1F4 	30 49 A0  1 
1A2E1F8 	18 70 A0  1 
;
1A2E1FC 	58 46 A0  1 

: attributes-match?  ( -- flag? )
1A2E200 	 0  0 61 74 74 72 69 62 
1A2E208 	75 74 65 73 2D 6D 61 74 
1A2E210 	63 68 3F 91 9C E1 A2  1 
1A2E218 	20 40 A0  1 
   de_attributes c@ at_archiv invert and  ( masked-attributes )
1A2E21C 	68 BF A2  1 
1A2E220 	C4 4C A0  1 F8 BF A2  1 
1A2E228 	30 45 A0  1 5C 44 A0  1 
   search-attrib c@ invert and  0=
1A2E230 	40 D8 A2  1 C4 4C A0  1 
1A2E238 	30 45 A0  1 5C 44 A0  1 
1A2E240 	24 47 A0  1 
;
1A2E244 	58 46 A0  1 
\ : attributes-match?  ( -- flag? )
\    de_attributes c@  at_archiv invert and  at_rdonly invert and
\    ?dup  0=  if  at_normal  then
\    search-attrib c@ and  0<>
\ ;
: reset-search  ( cl# -- )
1A2E248 	 0  0  0 72 65 73 65 74 
1A2E250 	2D 73 65 61 72 63 68 8C 
1A2E258 	18 E2 A2  1 20 40 A0  1 
   dup search-dir-cl ! search-cl !  /dirent negate search-offset !
1A2E260 	40 49 A0  1 8C D8 A2  1 
1A2E268 	54 4D A0  1 68 D7 A2  1 
1A2E270 	54 4D A0  1 F0 C0 A2  1 
1A2E278 	48 45 A0  1 84 D7 A2  1 
1A2E280 	54 4D A0  1 
;
1A2E284 	58 46 A0  1 

[ifndef] /string
\ Remove n characters (if there are that many) from the string adr,len
: /string  ( adr len n -- adr' len' )  over min  tuck -  -rot + swap  ;
[then]

: set-search  ( adr len file-types -- )
1A2E288 	 0 73 65 74 2D 73 65 61 
1A2E290 	72 63 68 8A 5C E2 A2  1 
1A2E298 	20 40 A0  1 

   search-attrib c!
1A2E29C 	40 D8 A2  1 
1A2E2A0 	B8 4D A0  1 

   \ Set the search drive, either from the path if it contains e.g. A: , or
   \ from the current device

   drive#  dup search-dev !  set-device    ( adr' len' )
1A2E2A4 	50 DB A2  1 
1A2E2A8 	40 49 A0  1 9C D7 A2  1 
1A2E2B0 	54 4D A0  1  4 CC A2  1 

   \ The path starts at the root directory if the first character is "\";
   \ otherwise it starts at the current directory
   dup 1 >=  if
1A2E2B8 	40 49 A0  1 80 6F A0  1 
1A2E2C0 	EC 48 A0  1 DC 41 A0  1 
1A2E2C8 	48  0  0  0 
      over c@  ascii \  =  if
1A2E2CC 	54 49 A0  1 
1A2E2D0 	C4 4C A0  1 58 41 A0  1 
1A2E2D8 	5C  0  0  0 24 48 A0  1 
1A2E2E0 	DC 41 A0  1 1C  0  0  0 
         1 /string
1A2E2E8 	80 6F A0  1 3C 85 A0  1 
         rdirclus l@
1A2E2F0 	40 BB A2  1 6C 4C A0  1 
      else
1A2E2F8 	C8 41 A0  1  C  0  0  0 
         dv_cwd-cl l@
1A2E300 	84 BB A2  1 6C 4C A0  1 
      then
   else
1A2E308 	C8 41 A0  1  C  0  0  0 
      dv_cwd-cl l@
1A2E310 	84 BB A2  1 6C 4C A0  1 
   then                                    ( adr' len' cl# )

   reset-search                            ( adr' len' )
1A2E318 	5C E2 A2  1 

   \ If a search path is present, find the indicated subdirectory

   begin                                   ( adr' len' )

      \ Split the remaining string at the first backslash, if there is one
      ascii \ split-before                 ( adr' len' dir-adr dir-len )
1A2E31C 	58 41 A0  1 
1A2E320 	5C  0  0  0 20 19 A1  1 

   2 pick  while                           ( adr' len' dir-adr dir-len )
1A2E328 	90 6F A0  1  C 4A A0  1 
1A2E330 	DC 41 A0  1 54  0  0  0 
      set-filename                         ( adr' len' )
1A2E338 	B0 DB A2  1 
      find-dir if  file-cluster@
1A2E33C 	9C E1 A2  1 
1A2E340 	DC 41 A0  1 10  0  0  0 
1A2E348 	A0 C2 A2  1 
      else  cl#eof then                    ( adr' len' cl# )
1A2E34C 	C8 41 A0  1 
1A2E350 	 8  0  0  0 70 D8 A2  1 
      dup reset-search                     ( adr' len' cl# )
1A2E358 	40 49 A0  1 5C E2 A2  1 

      \ Bail out if the requested directory wasn't found
      cl#eof =  if  2drop exit  then       ( adr' len' )
1A2E360 	70 D8 A2  1 24 48 A0  1 
1A2E368 	DC 41 A0  1  C  0  0  0 
1A2E370 	AC 49 A0  1 40 46 A0  1 
      1 /string				   ( adr' len' )  \ Remove the '\'
1A2E378 	80 6F A0  1 3C 85 A0  1 
   repeat                                  ( adr 0 filename-adr filename-len )
1A2E380 	C8 41 A0  1 98 FF FF FF 

   set-filename
1A2E388 	B0 DB A2  1 
   2drop
1A2E38C 	AC 49 A0  1 
;
1A2E390 	58 46 A0  1 

: init-search  ( adr len file-types -- )
1A2E394 	69 6E 69 74 
1A2E398 	2D 73 65 61 72 63 68 8B 
1A2E3A0 	98 E2 A2  1 20 40 A0  1 
   file-search-state search-state ! ( adr len file-types )  set-search
1A2E3A8 	AC D8 A2  1 10 D7 A2  1 
1A2E3B0 	54 4D A0  1 98 E2 A2  1 
;
1A2E3B8 	58 46 A0  1 

\ mmo internal

: find-next  ( -- flag )
1A2E3BC 	 0  0 66 69 
1A2E3C0 	6E 64 2D 6E 65 78 74 89 
1A2E3C8 	A4 E3 A2  1 20 40 A0  1 
   begin  next-file  while
1A2E3D0 	4C E1 A2  1 DC 41 A0  1 
1A2E3D8 	28  0  0  0 
      attributes-match? names-match?  and  if  true exit  then
1A2E3DC 	18 E2 A2  1 
1A2E3E0 	14 D9 A2  1 5C 44 A0  1 
1A2E3E8 	DC 41 A0  1  C  0  0  0 
1A2E3F0 	 4 70 A0  1 40 46 A0  1 
   repeat
1A2E3F8 	C8 41 A0  1 D4 FF FF FF 
   false
1A2E400 	18 70 A0  1 
;
1A2E404 	58 46 A0  1 
: find-first  ( adr len file-types -- flag )  init-search find-next  ;
1A2E408 	 0 66 69 6E 64 2D 66 69 
1A2E410 	72 73 74 8A CC E3 A2  1 
1A2E418 	20 40 A0  1 A4 E3 A2  1 
1A2E420 	CC E3 A2  1 58 46 A0  1 

\ mmo private

: extend-dir  ( -- error? )
1A2E428 	 0 65 78 74 65 6E 64 2D 
1A2E430 	64 69 72 8A 18 E4 A2  1 
1A2E438 	20 40 A0  1 
   search-cl @ 0<=  if  true exit  then
1A2E43C 	68 D7 A2  1 
1A2E440 	5C 4C A0  1 84 47 A0  1 
1A2E448 	DC 41 A0  1  C  0  0  0 
1A2E450 	 4 70 A0  1 40 46 A0  1 
   search-cl @ allocate-cluster           ( cluster# true  |  false )
1A2E458 	68 D7 A2  1 5C 4C A0  1 
1A2E460 	10 D5 A2  1 
   if                                     ( cluster# )
1A2E464 	DC 41 A0  1 
1A2E468 	70  0  0  0 
      dup search-cl @ cluster!            ( cluster# )
1A2E46C 	40 49 A0  1 
1A2E470 	68 D7 A2  1 5C 4C A0  1 
1A2E478 	14 D1 A2  1 
      dup search-cl !  0 search-offset !  ( cluster# )
1A2E47C 	40 49 A0  1 
1A2E480 	68 D7 A2  1 54 4D A0  1 
1A2E488 	70 6F A0  1 84 D7 A2  1 
1A2E490 	54 4D A0  1 
      0 swap search-dev @ set-dirent ?dup  if  exit  then
1A2E494 	70 6F A0  1 
1A2E498 	68 49 A0  1 9C D7 A2  1 
1A2E4A0 	5C 4C A0  1  4 DE A2  1 
1A2E4A8 	B4 70 A0  1 DC 41 A0  1 
1A2E4B0 	 8  0  0  0 40 46 A0  1 
      dirent @  /cluster  0  fill    \ Clear it.
1A2E4B8 	DC BE A2  1 5C 4C A0  1 
1A2E4C0 	18 C3 A2  1 70 6F A0  1 
1A2E4C8 	8C 4E A0  1 
      write-dir-cl   ( error? )
1A2E4CC 	6C DD A2  1 
   else                                 ( )
1A2E4D0 	C8 41 A0  1  8  0  0  0 
      true
1A2E4D8 	 4 70 A0  1 
   then
;
1A2E4DC 	58 46 A0  1 

\ This is only called after "find-first" has just been executed, so the
\ directory and drive context is already set properly.
: find-free-dirent  ( -- error? )
1A2E4E0 	 0  0  0 66 69 6E 64 2D 
1A2E4E8 	66 72 65 65 2D 64 69 72 
1A2E4F0 	65 6E 74 90 38 E4 A2  1 
1A2E4F8 	20 40 A0  1 
   \ Go back to the starting cluster of the directory that was most recently
   \ searched.
   search-dir-cl @ reset-search
1A2E4FC 	8C D8 A2  1 
1A2E500 	5C 4C A0  1 5C E2 A2  1 

   ( advance-entry returns:  -1=file | 0=deleted  | 1=soft-end  | 2=hard-end )
   begin  advance-entry  dup 0 1 between 0=  while
1A2E508 	64 E0 A2  1 40 49 A0  1 
1A2E510 	70 6F A0  1 80 6F A0  1 
1A2E518 	D8 70 A0  1 24 47 A0  1 
1A2E520 	DC 41 A0  1 24  0  0  0 
      2 =  if  extend-dir exit  then
1A2E528 	90 6F A0  1 24 48 A0  1 
1A2E530 	DC 41 A0  1  C  0  0  0 
1A2E538 	38 E4 A2  1 40 46 A0  1 
   repeat
1A2E540 	C8 41 A0  1 C4 FF FF FF 

   \ Found a slot for the new file
   drop  false
1A2E548 	30 49 A0  1 18 70 A0  1 
;
1A2E550 	58 46 A0  1 

OpenFirmware/ofw/fs/fatfs/lookup.fth_AL	3692 1A2E554 \ DOS file handle.  There is one of these for each open file.

\ Logical cluster numbers are relative to the start of the file.
\ Physical cluster numbers are relative to the start of the partition.

hex

\ mmo private

instance variable  fh
1A2E554 	 0 66 68 82 
1A2E558 	F8 E4 A2  1 40  1 A2  1 
1A2E560 	28  0  0  0 

: hfield  (s handle-offset size -- handle-offset+size )
1A2E564 	 0 68 66 69 
1A2E568 	65 6C 64 86 5C E5 A2  1 
1A2E570 	20 40 A0  1 
   create over , + does> @ fh @ +
1A2E574 	A8 A2 A0  1 
1A2E578 	54 49 A0  1 98 55 A0  1 
1A2E580 	 4 45 A0  1 50 A3 A0  1 
1A2E588 	90 90 90 E8 EC 5A FD FF 
1A2E590 	5C 4C A0  1 5C E5 A2  1 
1A2E598 	5C 4C A0  1  4 45 A0  1 
;
1A2E5A0 	58 46 A0  1 

struct \ fh
  /n hfield fh_dev        \ Device # where file lives
1A2E5A4 	 0 66 68 5F 
1A2E5A8 	64 65 76 86 70 E5 A2  1 
1A2E5B0 	88 E5 A2  1  0  0  0  0 
  /n hfield fh_dircl      \ Cluster # of directory entry
1A2E5B8 	 0  0  0 66 68 5F 64 69 
1A2E5C0 	72 63 6C 88 B0 E5 A2  1 
1A2E5C8 	88 E5 A2  1  4  0  0  0 
                          \ Must be long because we must encode both
                          \ negative root directory sector number and
                          \ unsigned 16-bit cluster numbers
  /l hfield fh_first      \ First cluster number of file
1A2E5D0 	 0  0  0 66 68 5F 66 69 
1A2E5D8 	72 73 74 88 C8 E5 A2  1 
1A2E5E0 	88 E5 A2  1  8  0  0  0 
  /l hfield fh_length     \ #bytes in file
1A2E5E8 	 0  0 66 68 5F 6C 65 6E 
1A2E5F0 	67 74 68 89 E0 E5 A2  1 
1A2E5F8 	88 E5 A2  1  C  0  0  0 
  /l hfield fh_logicalcl  \ Current position - logical cluster#
1A2E600 	 0  0  0 66 68 5F 6C 6F 
1A2E608 	67 69 63 61 6C 63 6C 8C 
1A2E610 	F8 E5 A2  1 88 E5 A2  1 
1A2E618 	10  0  0  0 
  /l hfield fh_physicalcl \ Current position - physical cluster#
1A2E61C 	 0  0 66 68 
1A2E620 	5F 70 68 79 73 69 63 61 
1A2E628 	6C 63 6C 8D 14 E6 A2  1 
1A2E630 	88 E5 A2  1 14  0  0  0 
  /l hfield fh_prevphyscl \ Predecessor of current physical cluster#
1A2E638 	 0  0 66 68 5F 70 72 65 
1A2E640 	76 70 68 79 73 63 6C 8D 
1A2E648 	30 E6 A2  1 88 E5 A2  1 
1A2E650 	18  0  0  0 
   2 hfield fh_diroff     \ Offset of directory entry within its cluster
1A2E654 	 0  0 66 68 
1A2E658 	5F 64 69 72 6F 66 66 89 
1A2E660 	4C E6 A2  1 88 E5 A2  1 
1A2E668 	1C  0  0  0 
   2 hfield fh_clshift    \ Shift count to convert from position to cl#
1A2E66C 	 0 66 68 5F 
1A2E670 	63 6C 73 68 69 66 74 8A 
1A2E678 	64 E6 A2  1 88 E5 A2  1 
1A2E680 	1E  0  0  0 
   2 hfield fh_flags
1A2E684 	 0  0  0 66 
1A2E688 	68 5F 66 6C 61 67 73 88 
1A2E690 	7C E6 A2  1 88 E5 A2  1 
1A2E698 	20  0  0  0 

       0001 constant fh_isopen
1A2E69C 	 0  0 66 68 
1A2E6A0 	5F 69 73 6F 70 65 6E 89 
1A2E6A8 	94 E6 A2  1 68 40 A0  1 
1A2E6B0 	 1  0  0  0 
       0002 constant fh_writeable
1A2E6B4 	 0  0  0 66 
1A2E6B8 	68 5F 77 72 69 74 65 61 
1A2E6C0 	62 6C 65 8C AC E6 A2  1 
1A2E6C8 	68 40 A0  1  2  0  0  0 
       0004 constant fh_dirty
1A2E6D0 	 0  0  0 66 68 5F 64 69 
1A2E6D8 	72 74 79 88 C8 E6 A2  1 
1A2E6E0 	68 40 A0  1  4  0  0  0 

   /l round-up
constant /fh
1A2E6E8 	2F 66 68 83 E0 E6 A2  1 
1A2E6F0 	68 40 A0  1 24  0  0  0 

\ Releases the current file handle
: clear-fh  ( -- )  fh @ /fh free-mem  ;
1A2E6F8 	 0  0  0 63 6C 65 61 72 
1A2E700 	2D 66 68 88 F0 E6 A2  1 
1A2E708 	20 40 A0  1 5C E5 A2  1 
1A2E710 	5C 4C A0  1 F0 E6 A2  1 
1A2E718 	 8 6D A0  1 58 46 A0  1 

\ Allocates a free file handle if possible
: allocate-fh  ( -- fh true  |  false )
1A2E720 	61 6C 6C 6F 63 61 74 65 
1A2E728 	2D 66 68 8B  8 E7 A2  1 
1A2E730 	20 40 A0  1 
   /fh alloc-mem fh !  fh @  if  fh @ true  else  false  then
1A2E734 	F0 E6 A2  1 
1A2E738 	F0 6C A0  1 5C E5 A2  1 
1A2E740 	54 4D A0  1 5C E5 A2  1 
1A2E748 	5C 4C A0  1 DC 41 A0  1 
1A2E750 	18  0  0  0 5C E5 A2  1 
1A2E758 	5C 4C A0  1  4 70 A0  1 
1A2E760 	C8 41 A0  1  8  0  0  0 
1A2E768 	18 70 A0  1 
;
1A2E76C 	58 46 A0  1 

OpenFirmware/ofw/fs/fatfs/fh.fth_AL	21C 1A2E770 \ opening, seeking and reading the contents of an existing file.
\ 10/2/90 cpt: revised for reading continuous clusters in 1 shot.

\ mmo private
: to-first-cluster  ( -- )
1A2E770 	 0  0  0 74 6F 2D 66 69 
1A2E778 	72 73 74 2D 63 6C 75 73 
1A2E780 	74 65 72 90 30 E7 A2  1 
1A2E788 	20 40 A0  1 
   0 fh_logicalcl l!
1A2E78C 	70 6F A0  1 
1A2E790 	14 E6 A2  1 7C 4D A0  1 
   fh_first l@ fh_physicalcl l!
1A2E798 	E0 E5 A2  1 6C 4C A0  1 
1A2E7A0 	30 E6 A2  1 7C 4D A0  1 
   0 fh_prevphyscl l!
1A2E7A8 	70 6F A0  1 4C E6 A2  1 
1A2E7B0 	7C 4D A0  1 
;
1A2E7B4 	58 46 A0  1 

: last-cluster?  ( -- flag )
1A2E7B8 	 0  0 6C 61 73 74 2D 63 
1A2E7C0 	6C 75 73 74 65 72 3F 8D 
1A2E7C8 	88 E7 A2  1 20 40 A0  1 
   fh_physicalcl l@ fat-end?  fh_physicalcl l@ 0=  or ;
1A2E7D0 	30 E6 A2  1 6C 4C A0  1 
1A2E7D8 	24 CD A2  1 30 E6 A2  1 
1A2E7E0 	6C 4C A0  1 24 47 A0  1 
1A2E7E8 	70 44 A0  1 58 46 A0  1 

: to-next-cluster  ( -- )
1A2E7F0 	74 6F 2D 6E 65 78 74 2D 
1A2E7F8 	63 6C 75 73 74 65 72 8F 
1A2E800 	CC E7 A2  1 20 40 A0  1 
   fh_physicalcl l@  dup fh_prevphyscl l!  ( previous-physical-cluster# )
1A2E808 	30 E6 A2  1 6C 4C A0  1 
1A2E810 	40 49 A0  1 4C E6 A2  1 
1A2E818 	7C 4D A0  1 
   cluster@ fh_physicalcl l!
1A2E81C 	1C D0 A2  1 
1A2E820 	30 E6 A2  1 7C 4D A0  1 
   fh_logicalcl l@ 1+ fh_logicalcl l!
1A2E828 	14 E6 A2  1 6C 4C A0  1 
1A2E830 	30 4B A0  1 14 E6 A2  1 
1A2E838 	7C 4D A0  1 
;
1A2E83C 	58 46 A0  1 

: to-last-cluster  ( -- )
1A2E840 	74 6F 2D 6C 61 73 74 2D 
1A2E848 	63 6C 75 73 74 65 72 8F 
1A2E850 	 4 E8 A2  1 20 40 A0  1 
   begin  last-cluster?  0=  while  to-next-cluster  repeat
1A2E858 	CC E7 A2  1 24 47 A0  1 
1A2E860 	DC 41 A0  1 10  0  0  0 
1A2E868 	 4 E8 A2  1 C8 41 A0  1 
1A2E870 	E8 FF FF FF 
;
1A2E874 	58 46 A0  1 

: dos-seek  ( byte# fh -- error? )
1A2E878 	 0  0  0 64 6F 73 2D 73 
1A2E880 	65 65 6B 88 54 E8 A2  1 
1A2E888 	20 40 A0  1 
   fh !   ( byte# )
1A2E88C 	5C E5 A2  1 
1A2E890 	54 4D A0  1 
   fh_dev @ set-device
1A2E894 	B0 E5 A2  1 
1A2E898 	5C 4C A0  1  4 CC A2  1 

   fh_clshift w@ >>   ( target-cl )
1A2E8A0 	7C E6 A2  1 94 4C A0  1 
1A2E8A8 	DC 44 A0  1 

   \ Bail out early if we're already on the right cluster
   dup fh_logicalcl l@ = if  drop false  exit  then
1A2E8AC 	40 49 A0  1 
1A2E8B0 	14 E6 A2  1 6C 4C A0  1 
1A2E8B8 	24 48 A0  1 DC 41 A0  1 
1A2E8C0 	10  0  0  0 30 49 A0  1 
1A2E8C8 	18 70 A0  1 40 46 A0  1 

   \ If we are seeking forward, start at the current position.  Otherwise
   \ start at the beginning of the file.

   dup fh_logicalcl l@ <= if  to-first-cluster  then
1A2E8D0 	40 49 A0  1 14 E6 A2  1 
1A2E8D8 	6C 4C A0  1  C 49 A0  1 
1A2E8E0 	DC 41 A0  1  8  0  0  0 
1A2E8E8 	88 E7 A2  1 

   \ Advance to the desired cluster, if it exists.
   begin  dup fh_logicalcl l@ <> while           ( target-cluster# )
1A2E8EC 	40 49 A0  1 
1A2E8F0 	14 E6 A2  1 6C 4C A0  1 
1A2E8F8 	44 48 A0  1 DC 41 A0  1 
1A2E900 	28  0  0  0 

      last-cluster?  if  drop true  exit   then   \ End of file?
1A2E904 	CC E7 A2  1 
1A2E908 	DC 41 A0  1 10  0  0  0 
1A2E910 	30 49 A0  1  4 70 A0  1 
1A2E918 	40 46 A0  1 
      to-next-cluster
1A2E91C 	 4 E8 A2  1 
   repeat                                       ( target-cluster# )
1A2E920 	C8 41 A0  1 C8 FF FF FF 

   drop false
1A2E928 	30 49 A0  1 18 70 A0  1 
;
1A2E930 	58 46 A0  1 

: log2  ( n -- log2-of-n )
1A2E934 	 0  0  0 6C 
1A2E938 	6F 67 32 84 88 E8 A2  1 
1A2E940 	20 40 A0  1 
   -1 swap  bits/cell 0  do
1A2E944 	58 41 A0  1 
1A2E948 	FF FF FF FF 68 49 A0  1 
1A2E950 	94 65 A0  1 70 6F A0  1 
1A2E958 	88 42 A0  1 34  0  0  0 
       1 >>  dup 0=  if  nip i swap leave  then
1A2E960 	80 6F A0  1 DC 44 A0  1 
1A2E968 	40 49 A0  1 24 47 A0  1 
1A2E970 	DC 41 A0  1 14  0  0  0 
1A2E978 	FC 46 A0  1 B4 42 A0  1 
1A2E980 	68 49 A0  1 18 43 A0  1 
   loop  ( log n' )
1A2E988 	F8 41 A0  1 D4 FF FF FF 
   drop
1A2E990 	30 49 A0  1 
;
1A2E994 	58 46 A0  1 
: fh-open  ( 'dirent -- fh false | true )
1A2E998 	66 68 2D 6F 70 65 6E 87 
1A2E9A0 	40 E9 A2  1 20 40 A0  1 
   dirent !
1A2E9A8 	DC BE A2  1 54 4D A0  1 
   allocate-fh  if  fh !  else  true exit  then
1A2E9B0 	30 E7 A2  1 DC 41 A0  1 
1A2E9B8 	14  0  0  0 5C E5 A2  1 
1A2E9C0 	54 4D A0  1 C8 41 A0  1 
1A2E9C8 	 C  0  0  0  4 70 A0  1 
1A2E9D0 	40 46 A0  1 

   fh_isopen
1A2E9D4 	AC E6 A2  1 
   de_attributes c@ at_rdonly and  0=  if  fh_writeable or  then
1A2E9D8 	68 BF A2  1 C4 4C A0  1 
1A2E9E0 	80 BF A2  1 5C 44 A0  1 
1A2E9E8 	24 47 A0  1 DC 41 A0  1 
1A2E9F0 	 C  0  0  0 C8 E6 A2  1 
1A2E9F8 	70 44 A0  1 
   fh_flags w!
1A2E9FC 	94 E6 A2  1 
1A2EA00 	A4 4D A0  1 

   current-device @  fh_dev !
1A2EA04 	A8 BA A2  1 
1A2EA08 	5C 4C A0  1 B0 E5 A2  1 
1A2EA10 	54 4D A0  1 
   dir-cl @  fh_dircl !  \ Cluster containing the directory entry
1A2EA14 	A8 DC A2  1 
1A2EA18 	5C 4C A0  1 C8 E5 A2  1 
1A2EA20 	54 4D A0  1 
   dirent @ dir-buf - fh_diroff w! \ Location of directory entry in its cluster
1A2EA24 	DC BE A2  1 
1A2EA28 	5C 4C A0  1 1C C4 A2  1 
1A2EA30 	18 45 A0  1 64 E6 A2  1 
1A2EA38 	A4 4D A0  1 
   ( fh_dircl ?  ) ( fh_diroff ? )
   file-cluster@  fh_first  l!
1A2EA3C 	A0 C2 A2  1 
1A2EA40 	E0 E5 A2  1 7C 4D A0  1 
   de_length lel@ fh_length l!
1A2EA48 	DC C0 A2  1 DC B4 A2  1 
1A2EA50 	F8 E5 A2  1 7C 4D A0  1 
   to-first-cluster
1A2EA58 	88 E7 A2  1 
   /cluster  log2  fh_clshift w!
1A2EA5C 	18 C3 A2  1 
1A2EA60 	40 E9 A2  1 7C E6 A2  1 
1A2EA68 	A4 4D A0  1 
   fh @ false
1A2EA6C 	5C E5 A2  1 
1A2EA70 	5C 4C A0  1 18 70 A0  1 
;
1A2EA78 	58 46 A0  1 

: name-open  ( adr len mode -- fh false  | true )
1A2EA7C 	 0  0 6E 61 
1A2EA80 	6D 65 2D 6F 70 65 6E 89 
1A2EA88 	A4 E9 A2  1 20 40 A0  1 
   \ If the mode specifies writing, look for writeable normal files
   \ If mode is "read" (0), also find read-only files and subdirectories

   1 >=  if  0  else  at_rdonly  then
1A2EA90 	80 6F A0  1 EC 48 A0  1 
1A2EA98 	DC 41 A0  1 10  0  0  0 
1A2EAA0 	70 6F A0  1 C8 41 A0  1 
1A2EAA8 	 8  0  0  0 80 BF A2  1 
   at_system or  at_hidden or              ( adr len file-types )
1A2EAB0 	B0 BF A2  1 70 44 A0  1 
1A2EAB8 	98 BF A2  1 70 44 A0  1 

   find-first  if  dirent @ fh-open  else  -1  then
1A2EAC0 	18 E4 A2  1 DC 41 A0  1 
1A2EAC8 	18  0  0  0 DC BE A2  1 
1A2EAD0 	5C 4C A0  1 A4 E9 A2  1 
1A2EAD8 	C8 41 A0  1  C  0  0  0 
1A2EAE0 	58 41 A0  1 FF FF FF FF 
;
1A2EAE8 	58 46 A0  1 

variable remaining \ bytes
1A2EAEC 	 0  0 72 65 
1A2EAF0 	6D 61 69 6E 69 6E 67 89 
1A2EAF8 	8C EA A2  1 48 40 A0  1 
1A2EB00 	3C  9  0  0 
variable requested \ bytes
1A2EB04 	 0  0 72 65 
1A2EB08 	71 75 65 73 74 65 64 89 
1A2EB10 	FC EA A2  1 48 40 A0  1 
1A2EB18 	40  9  0  0 
variable bufadr
1A2EB1C 	 0 62 75 66 
1A2EB20 	61 64 72 86 14 EB A2  1 
1A2EB28 	48 40 A0  1 44  9  0  0 
VARIABLE 1st-cl#   \ marks 1st of an allocated cotinuous cluster range
1A2EB30 	31 73 74 2D 63 6C 23 87 
1A2EB38 	28 EB A2  1 48 40 A0  1 
1A2EB40 	48  9  0  0 
VARIABLE #cont-cls \ marks # of clusters in the  ----  "  --------
1A2EB44 	 0  0 23 63 
1A2EB48 	6F 6E 74 2D 63 6C 73 89 
1A2EB50 	3C EB A2  1 48 40 A0  1 
1A2EB58 	4C  9  0  0 
VARIABLE next-cl#  \ marks next 1st cluster of non-continuous cluster range
1A2EB5C 	 0  0  0 6E 
1A2EB60 	65 78 74 2D 63 6C 23 88 
1A2EB68 	54 EB A2  1 48 40 A0  1 
1A2EB70 	50  9  0  0 
                   \ (for read its used as a flag only)

: current-position  ( -- n )  fh_logicalcl l@ fh_clshift w@ <<  ;
1A2EB74 	 0  0  0 63 
1A2EB78 	75 72 72 65 6E 74 2D 70 
1A2EB80 	6F 73 69 74 69 6F 6E 90 
1A2EB88 	6C EB A2  1 20 40 A0  1 
1A2EB90 	14 E6 A2  1 6C 4C A0  1 
1A2EB98 	7C E6 A2  1 94 4C A0  1 
1A2EBA0 	C8 44 A0  1 58 46 A0  1 

: cl#-valid?  ( cl# -- flag )  2  max-cl# l@  between  ;
1A2EBA8 	 0 63 6C 23 2D 76 61 6C 
1A2EBB0 	69 64 3F 8A 8C EB A2  1 
1A2EBB8 	20 40 A0  1 90 6F A0  1 
1A2EBC0 	54 BB A2  1 6C 4C A0  1 
1A2EBC8 	D8 70 A0  1 58 46 A0  1 

: dos-read  ( adr count 'fh -- #read false  |  true )
1A2EBD0 	 0  0  0 64 6F 73 2D 72 
1A2EBD8 	65 61 64 88 B8 EB A2  1 
1A2EBE0 	20 40 A0  1 
   fh !   fh_dev @ set-device                        ( adr count )
1A2EBE4 	5C E5 A2  1 
1A2EBE8 	54 4D A0  1 B0 E5 A2  1 
1A2EBF0 	5C 4C A0  1  4 CC A2  1 

   dup remaining !  dup requested ! swap bufadr !     ( count )
1A2EBF8 	40 49 A0  1 FC EA A2  1 
1A2EC00 	54 4D A0  1 40 49 A0  1 
1A2EC08 	14 EB A2  1 54 4D A0  1 
1A2EC10 	68 49 A0  1 28 EB A2  1 
1A2EC18 	54 4D A0  1 
   bytes>clusters                                     ( #cls-to-read )
1A2EC1C 	44 C3 A2  1 
   fh_physicalcl l@  dup 1st-cl# !  1 #cont-cls !     ( #cls phys-cl# )
1A2EC20 	30 E6 A2  1 6C 4C A0  1 
1A2EC28 	40 49 A0  1 3C EB A2  1 
1A2EC30 	54 4D A0  1 80 6F A0  1 
1A2EC38 	54 EB A2  1 54 4D A0  1 
   cl#-valid?  0=  next-cl# !              \ set if not in valid range!
1A2EC40 	B8 EB A2  1 24 47 A0  1 
1A2EC48 	6C EB A2  1 54 4D A0  1 
                                                      ( #cls-to-read )
   begin
      dup 0>
1A2EC50 	40 49 A0  1 A4 47 A0  1 
      remaining @ 0>  and
1A2EC58 	FC EA A2  1 5C 4C A0  1 
1A2EC60 	A4 47 A0  1 5C 44 A0  1 
      current-position fh_length l@ u<  and
1A2EC68 	8C EB A2  1 F8 E5 A2  1 
1A2EC70 	6C 4C A0  1 A8 48 A0  1 
1A2EC78 	5C 44 A0  1 
      last-cluster? 0=  and
1A2EC7C 	CC E7 A2  1 
1A2EC80 	24 47 A0  1 5C 44 A0  1 
   while                                              ( #cls-remaining )
1A2EC88 	DC 41 A0  1 FC  0  0  0 
      to-next-cluster 
1A2EC90 	 4 E8 A2  1 
      1st-cl# @  #cont-cls @  +  fh_physicalcl l@  =  if
1A2EC94 	3C EB A2  1 
1A2EC98 	5C 4C A0  1 54 EB A2  1 
1A2ECA0 	5C 4C A0  1  4 45 A0  1 
1A2ECA8 	30 E6 A2  1 6C 4C A0  1 
1A2ECB0 	24 48 A0  1 DC 41 A0  1 
1A2ECB8 	34  0  0  0 
         \ increment counter only if not first loop
         next-cl# @  if  next-cl# off  else  #cont-cls 1+!  then
1A2ECBC 	6C EB A2  1 
1A2ECC0 	5C 4C A0  1 DC 41 A0  1 
1A2ECC8 	14  0  0  0 6C EB A2  1 
1A2ECD0 	F8 4B A0  1 C8 41 A0  1 
1A2ECD8 	 C  0  0  0 54 EB A2  1 
1A2ECE0 	54 B3 A2  1 
      else 
1A2ECE4 	C8 41 A0  1 
1A2ECE8 	94  0  0  0 
         next-cl# @ 0= if
1A2ECEC 	6C EB A2  1 
1A2ECF0 	5C 4C A0  1 24 47 A0  1 
1A2ECF8 	DC 41 A0  1 5C  0  0  0 
            1st-cl# @  #cont-cls @  bufadr @  read-clusters  if  
1A2ED00 	3C EB A2  1 5C 4C A0  1 
1A2ED08 	54 EB A2  1 5C 4C A0  1 
1A2ED10 	28 EB A2  1 5C 4C A0  1 
1A2ED18 	90 CC A2  1 DC 41 A0  1 
1A2ED20 	10  0  0  0 
               drop true  exit
1A2ED24 	30 49 A0  1 
1A2ED28 	 4 70 A0  1 40 46 A0  1 
            then
            #cont-cls @  /cluster *  dup bufadr +!  negate remaining +!
1A2ED30 	54 EB A2  1 5C 4C A0  1 
1A2ED38 	18 C3 A2  1 1C 5F A0  1 
1A2ED40 	40 49 A0  1 28 EB A2  1 
1A2ED48 	 C 4C A0  1 48 45 A0  1 
1A2ED50 	FC EA A2  1  C 4C A0  1 
         then
         fh_physicalcl l@ 1st-cl# !  1 #cont-cls !  next-cl# off
1A2ED58 	30 E6 A2  1 6C 4C A0  1 
1A2ED60 	3C EB A2  1 54 4D A0  1 
1A2ED68 	80 6F A0  1 54 EB A2  1 
1A2ED70 	54 4D A0  1 6C EB A2  1 
1A2ED78 	F8 4B A0  1 
      then
      1-  ( #cls-to-read-1 )
1A2ED7C 	54 4B A0  1 
   repeat  drop
1A2ED80 	C8 41 A0  1 CC FE FF FF 
1A2ED88 	30 49 A0  1 
   
   remaining @ 0>  next-cl# @ 0=  and  1st-cl# @ cl#-valid?  and  if
1A2ED8C 	FC EA A2  1 
1A2ED90 	5C 4C A0  1 A4 47 A0  1 
1A2ED98 	6C EB A2  1 5C 4C A0  1 
1A2EDA0 	24 47 A0  1 5C 44 A0  1 
1A2EDA8 	3C EB A2  1 5C 4C A0  1 
1A2EDB0 	B8 EB A2  1 5C 44 A0  1 
1A2EDB8 	DC 41 A0  1 50  0  0  0 
      \ We did loop & there is real data
      remaining @  bytes>clusters          ( #clusters-left )
1A2EDC0 	FC EA A2  1 5C 4C A0  1 
1A2EDC8 	44 C3 A2  1 
      1st-cl# @ over bufadr @ read-clusters  if  drop true exit  then
1A2EDCC 	3C EB A2  1 
1A2EDD0 	5C 4C A0  1 54 49 A0  1 
1A2EDD8 	28 EB A2  1 5C 4C A0  1 
1A2EDE0 	90 CC A2  1 DC 41 A0  1 
1A2EDE8 	10  0  0  0 30 49 A0  1 
1A2EDF0 	 4 70 A0  1 40 46 A0  1 
      /cluster *  negate  remaining +!
1A2EDF8 	18 C3 A2  1 1C 5F A0  1 
1A2EE00 	48 45 A0  1 FC EA A2  1 
1A2EE08 	 C 4C A0  1 
   then

   requested @  remaining @ -              ( bytes-tranferred )
1A2EE0C 	14 EB A2  1 
1A2EE10 	5C 4C A0  1 FC EA A2  1 
1A2EE18 	5C 4C A0  1 18 45 A0  1 

   \ If the last cluster of the file has been read, account for the
   \ true length of the file
   current-position fh_length l@ u>  if    ( bytes-tranferred )
1A2EE20 	8C EB A2  1 F8 E5 A2  1 
1A2EE28 	6C 4C A0  1 64 48 A0  1 
1A2EE30 	DC 41 A0  1 18  0  0  0 
      current-position fh_length l@ -  -   ( bytes-valid )
1A2EE38 	8C EB A2  1 F8 E5 A2  1 
1A2EE40 	6C 4C A0  1 18 45 A0  1 
1A2EE48 	18 45 A0  1 
   then                                    ( bytes-valid )

   false
1A2EE4C 	18 70 A0  1 
;
1A2EE50 	58 46 A0  1 

OpenFirmware/ofw/fs/fatfs/read.fth_AL	6E4 1A2EE54 \ Extend a file by allocating more clusters and writing out cluster data.
\ 10/2/90 cpt : revised for 1 shot i/o on consecutive clusters

\ mmo private

: (get-modtime)  ( -- s m h d m y )  de_time lew@ >hms  de_date lew@ >dmy  ;
1A2EE54 	 0  0 28 67 
1A2EE58 	65 74 2D 6D 6F 64 74 69 
1A2EE60 	6D 65 29 8D E0 EB A2  1 
1A2EE68 	20 40 A0  1 98 C0 A2  1 
1A2EE70 	7C B4 A2  1 B8 B5 A2  1 
1A2EE78 	AC C0 A2  1 7C B4 A2  1 
1A2EE80 	78 B6 A2  1 58 46 A0  1 
: (set-modtime)  ( s m h d m y -- )  dmy> de_date lew!  hms> de_time lew!  ;
1A2EE88 	 0  0 28 73 65 74 2D 6D 
1A2EE90 	6F 64 74 69 6D 65 29 8D 
1A2EE98 	68 EE A2  1 20 40 A0  1 
1A2EEA0 	E0 B6 A2  1 AC C0 A2  1 
1A2EEA8 	A8 B4 A2  1 18 B6 A2  1 
1A2EEB0 	98 C0 A2  1 A8 B4 A2  1 
1A2EEB8 	58 46 A0  1 
: (set-createtime)  ( s m h d m y -- )
1A2EEBC 	 0  0  0 28 
1A2EEC0 	73 65 74 2D 63 72 65 61 
1A2EEC8 	74 65 74 69 6D 65 29 90 
1A2EED0 	9C EE A2  1 20 40 A0  1 
   fat-type c@  fat32 =  if
1A2EED8 	84 BC A2  1 C4 4C A0  1 
1A2EEE0 	F0 BC A2  1 24 48 A0  1 
1A2EEE8 	DC 41 A0  1 24  0  0  0 
      dmy> de_cdate lew! hms> de_ctime lew!  
1A2EEF0 	E0 B6 A2  1 54 C0 A2  1 
1A2EEF8 	A8 B4 A2  1 18 B6 A2  1 
1A2EF00 	3C C0 A2  1 A8 B4 A2  1 
   else
1A2EF08 	C8 41 A0  1  C  0  0  0 
      3drop 3drop
1A2EF10 	90 52 A0  1 90 52 A0  1 
   then
;
1A2EF18 	58 46 A0  1 
: (set-accessdate)  ( d m y -- )
1A2EF1C 	 0  0  0 28 
1A2EF20 	73 65 74 2D 61 63 63 65 
1A2EF28 	73 73 64 61 74 65 29 90 
1A2EF30 	D4 EE A2  1 20 40 A0  1 
   fat-type c@  fat32 =  if
1A2EF38 	84 BC A2  1 C4 4C A0  1 
1A2EF40 	F0 BC A2  1 24 48 A0  1 
1A2EF48 	DC 41 A0  1 18  0  0  0 
      dmy> de_adate lew!  
1A2EF50 	E0 B6 A2  1 6C C0 A2  1 
1A2EF58 	A8 B4 A2  1 
   else
1A2EF5C 	C8 41 A0  1 
1A2EF60 	 8  0  0  0 
      3drop
1A2EF64 	90 52 A0  1 
   then
;
1A2EF68 	58 46 A0  1 

: update-dirent ( -- error? )
1A2EF6C 	 0  0 75 70 
1A2EF70 	64 61 74 65 2D 64 69 72 
1A2EF78 	65 6E 74 8D 34 EF A2  1 
1A2EF80 	20 40 A0  1 
   fh_flags w@ fh_dirty and  if  \ Update directory entry if file has changed
1A2EF84 	94 E6 A2  1 
1A2EF88 	94 4C A0  1 E0 E6 A2  1 
1A2EF90 	5C 44 A0  1 DC 41 A0  1 
1A2EF98 	A0  0  0  0 
      fh_diroff w@ fh_dircl @ fh_dev @ set-dirent ?dup if  exit  then
1A2EF9C 	64 E6 A2  1 
1A2EFA0 	94 4C A0  1 C8 E5 A2  1 
1A2EFA8 	5C 4C A0  1 B0 E5 A2  1 
1A2EFB0 	5C 4C A0  1  4 DE A2  1 
1A2EFB8 	B4 70 A0  1 DC 41 A0  1 
1A2EFC0 	 8  0  0  0 40 46 A0  1 
      fh_length l@ de_length lel!
1A2EFC8 	F8 E5 A2  1 6C 4C A0  1 
1A2EFD0 	DC C0 A2  1  8 B5 A2  1 
      fh_first l@ file-cluster!
1A2EFD8 	E0 E5 A2  1 6C 4C A0  1 
1A2EFE0 	70 C2 A2  1 
      now today  (set-modtime)
1A2EFE4 	 4 ED A0  1 
1A2EFE8 	20 ED A0  1 9C EE A2  1 
      de_attributes c@ at_archiv or  de_attributes c!
1A2EFF0 	68 BF A2  1 C4 4C A0  1 
1A2EFF8 	F8 BF A2  1 70 44 A0  1 
1A2F000 	68 BF A2  1 B8 4D A0  1 
      write-dir-cl   ( error? )  ?dup  if  exit  then
1A2F008 	6C DD A2  1 B4 70 A0  1 
1A2F010 	DC 41 A0  1  8  0  0  0 
1A2F018 	40 46 A0  1 
      fh_flags w@ fh_dirty invert and  fh_flags w!
1A2F01C 	94 E6 A2  1 
1A2F020 	94 4C A0  1 E0 E6 A2  1 
1A2F028 	30 45 A0  1 5C 44 A0  1 
1A2F030 	94 E6 A2  1 A4 4D A0  1 
   then
   false
1A2F038 	18 70 A0  1 
;
1A2F03C 	58 46 A0  1 
\ When a file is first created, it's "de_first" field is set to 0.

: extend-file  ( #needed-clusters -- #needed-clusters' error? )
1A2F040 	65 78 74 65 6E 64 2D 66 
1A2F048 	69 6C 65 8B 80 EF A2  1 
1A2F050 	20 40 A0  1 
\ Assumes that fh_physicalcl is the cluster# of the last valid cluster
\ in the file, or 0 if the file is empty

   0  begin  drop                                ( #cls' )
1A2F054 	70 6F A0  1 
1A2F058 	30 49 A0  1 
      to-last-cluster
1A2F05C 	54 E8 A2  1 
      fh_prevphyscl l@ allocate-cluster if       ( #cls' cluster# )
1A2F060 	4C E6 A2  1 6C 4C A0  1 
1A2F068 	10 D5 A2  1 DC 41 A0  1 
1A2F070 	F0  0  0  0 
         fh_prevphyscl l@ if                     ( #cls' cluster# )
1A2F074 	4C E6 A2  1 
1A2F078 	6C 4C A0  1 DC 41 A0  1 
1A2F080 	1C  0  0  0 
            dup fh_prevphyscl l@ cluster!        ( #cls' cluster# )
1A2F084 	40 49 A0  1 
1A2F088 	4C E6 A2  1 6C 4C A0  1 
1A2F090 	14 D1 A2  1 
         else
1A2F094 	C8 41 A0  1 
1A2F098 	28  0  0  0 
            dup fh_first l!                      ( #cls' cluster# )
1A2F09C 	40 49 A0  1 
1A2F0A0 	E0 E5 A2  1 7C 4D A0  1 
            update-dirent if  drop true exit  then \ to remember got clusters
1A2F0A8 	80 EF A2  1 DC 41 A0  1 
1A2F0B0 	10  0  0  0 30 49 A0  1 
1A2F0B8 	 4 70 A0  1 40 46 A0  1 
         then                                    ( #cls' cluster# )
         dup fh_physicalcl l!                    ( #cls' cluster# )
1A2F0C0 	40 49 A0  1 30 E6 A2  1 
1A2F0C8 	7C 4D A0  1 
         1st-cl# @ #cont-cls @ + over = IF   
1A2F0CC 	3C EB A2  1 
1A2F0D0 	5C 4C A0  1 54 EB A2  1 
1A2F0D8 	5C 4C A0  1  4 45 A0  1 
1A2F0E0 	54 49 A0  1 24 48 A0  1 
1A2F0E8 	DC 41 A0  1 18  0  0  0 
             drop #cont-cls 1+!          \ continuation case
1A2F0F0 	30 49 A0  1 54 EB A2  1 
1A2F0F8 	54 B3 A2  1 
         else 1st-cl# @ 0= IF 
1A2F0FC 	C8 41 A0  1 
1A2F100 	3C  0  0  0 3C EB A2  1 
1A2F108 	5C 4C A0  1 24 47 A0  1 
1A2F110 	DC 41 A0  1 20  0  0  0 
                1st-cl# !  1 #cont-cls ! \ first cluster
1A2F118 	3C EB A2  1 54 4D A0  1 
1A2F120 	80 6F A0  1 54 EB A2  1 
1A2F128 	54 4D A0  1 
             else  next-cl# !  then      \ next range's 1st
1A2F12C 	C8 41 A0  1 
1A2F130 	 C  0  0  0 6C EB A2  1 
1A2F138 	54 4D A0  1 
         then
         1-                                       ( #cls'-1 )         
1A2F13C 	54 4B A0  1 
         current-position /cluster + fh_length l! ( #cls'-1 )
1A2F140 	8C EB A2  1 18 C3 A2  1 
1A2F148 	 4 45 A0  1 F8 E5 A2  1 
1A2F150 	7C 4D A0  1 
         false                                    ( #cls'-1 false )
1A2F154 	18 70 A0  1 
      else                                          
1A2F158 	C8 41 A0  1  8  0  0  0 
         3                                        ( #cls no-more-space-error )
1A2F160 	A0 6F A0  1 
      then
   over 0= over 0<> or next-cl# @ 0<> or until 
1A2F164 	54 49 A0  1 
1A2F168 	24 47 A0  1 54 49 A0  1 
1A2F170 	44 47 A0  1 70 44 A0  1 
1A2F178 	6C EB A2  1 5C 4C A0  1 
1A2F180 	44 47 A0  1 70 44 A0  1 
1A2F188 	DC 41 A0  1 CC FE FF FF 
;
1A2F190 	58 46 A0  1 

variable extended?
1A2F194 	 0  0 65 78 
1A2F198 	74 65 6E 64 65 64 3F 89 
1A2F1A0 	50 F0 A2  1 48 40 A0  1 
1A2F1A8 	54  9  0  0 

: dos-write  ( adr count 'fh -- #written false  |  true )
1A2F1AC 	 0  0 64 6F 
1A2F1B0 	73 2D 77 72 69 74 65 89 
1A2F1B8 	A4 F1 A2  1 20 40 A0  1 
   fh !  fh_dev @ set-device               ( adr count )
1A2F1C0 	5C E5 A2  1 54 4D A0  1 
1A2F1C8 	B0 E5 A2  1 5C 4C A0  1 
1A2F1D0 	 4 CC A2  1 
   fh_flags w@ fh_dirty or fh_flags w!
1A2F1D4 	94 E6 A2  1 
1A2F1D8 	94 4C A0  1 E0 E6 A2  1 
1A2F1E0 	70 44 A0  1 94 E6 A2  1 
1A2F1E8 	A4 4D A0  1 

   dup remaining !  dup requested !  swap bufadr !     ( #bytes )
1A2F1EC 	40 49 A0  1 
1A2F1F0 	FC EA A2  1 54 4D A0  1 
1A2F1F8 	40 49 A0  1 14 EB A2  1 
1A2F200 	54 4D A0  1 68 49 A0  1 
1A2F208 	28 EB A2  1 54 4D A0  1 
   bytes>clusters                                      ( #needed-clusters )   
1A2F210 	44 C3 A2  1 
   1st-cl# off  #cont-cls off  next-cl# off
1A2F214 	3C EB A2  1 
1A2F218 	F8 4B A0  1 54 EB A2  1 
1A2F220 	F8 4B A0  1 6C EB A2  1 
1A2F228 	F8 4B A0  1 
   extended? off
1A2F22C 	A4 F1 A2  1 
1A2F230 	F8 4B A0  1 
   
   begin   remaining @ 0>  while     ( #needed-clusters' )
1A2F234 	FC EA A2  1 
1A2F238 	5C 4C A0  1 A4 47 A0  1 
1A2F240 	DC 41 A0  1 74  1  0  0 

      \ If we need more cluster(s) and
      \ we're at or beyond the end of the file, add new cluster(s)
      dup 0>
1A2F248 	40 49 A0  1 A4 47 A0  1 
      current-position fh_length l@ >  last-cluster? or   and  if
1A2F250 	8C EB A2  1 F8 E5 A2  1 
1A2F258 	6C 4C A0  1  4 48 A0  1 
1A2F260 	CC E7 A2  1 70 44 A0  1 
1A2F268 	5C 44 A0  1 DC 41 A0  1 
1A2F270 	30  0  0  0 
         extend-file ?dup if  ?flush-fat-cache  nip  exit  then
1A2F274 	50 F0 A2  1 
1A2F278 	B4 70 A0  1 DC 41 A0  1 
1A2F280 	10  0  0  0 98 CE A2  1 
1A2F288 	FC 46 A0  1 40 46 A0  1 
         extended? on
1A2F290 	A4 F1 A2  1 E0 4B A0  1 
      else \ same cluster?
1A2F298 	C8 41 A0  1 34  0  0  0 
          1st-cl# @ 0= if  
1A2F2A0 	3C EB A2  1 5C 4C A0  1 
1A2F2A8 	24 47 A0  1 DC 41 A0  1 
1A2F2B0 	20  0  0  0 
             fh_physicalcl l@ 1st-cl# !  1 #cont-cls !
1A2F2B4 	30 E6 A2  1 
1A2F2B8 	6C 4C A0  1 3C EB A2  1 
1A2F2C0 	54 4D A0  1 80 6F A0  1 
1A2F2C8 	54 EB A2  1 54 4D A0  1 
          then
      then                           ( #needed-clusters' )
      
      \ Write the data
      1st-cl# @ #cont-cls @ bufadr @ write-clusters if
1A2F2D0 	3C EB A2  1 5C 4C A0  1 
1A2F2D8 	54 EB A2  1 5C 4C A0  1 
1A2F2E0 	28 EB A2  1 5C 4C A0  1 
1A2F2E8 	BC CC A2  1 DC 41 A0  1 
1A2F2F0 	10  0  0  0 
         ?flush-fat-cache  true exit
1A2F2F4 	98 CE A2  1 
1A2F2F8 	 4 70 A0  1 40 46 A0  1 
      then

      \ Adjust the length field unless extend-file already did it
      extended? @ 0=  if
1A2F300 	A4 F1 A2  1 5C 4C A0  1 
1A2F308 	24 47 A0  1 DC 41 A0  1 
1A2F310 	1C  0  0  0 
         current-position remaining @ + fh_length l!
1A2F314 	8C EB A2  1 
1A2F318 	FC EA A2  1 5C 4C A0  1 
1A2F320 	 4 45 A0  1 F8 E5 A2  1 
1A2F328 	7C 4D A0  1 
      then

      \ Continue with the rest of the transfer
      #cont-cls @ /cluster * dup bufadr +!  negate remaining +!
1A2F32C 	54 EB A2  1 
1A2F330 	5C 4C A0  1 18 C3 A2  1 
1A2F338 	1C 5F A0  1 40 49 A0  1 
1A2F340 	28 EB A2  1  C 4C A0  1 
1A2F348 	48 45 A0  1 FC EA A2  1 
1A2F350 	 C 4C A0  1 

      next-cl# @ ?dup if
1A2F354 	6C EB A2  1 
1A2F358 	5C 4C A0  1 B4 70 A0  1 
1A2F360 	DC 41 A0  1 28  0  0  0 
         1st-cl# !  1 #cont-cls !  next-cl# off
1A2F368 	3C EB A2  1 54 4D A0  1 
1A2F370 	80 6F A0  1 54 EB A2  1 
1A2F378 	54 4D A0  1 6C EB A2  1 
1A2F380 	F8 4B A0  1 
      else
1A2F384 	C8 41 A0  1 
1A2F388 	14  0  0  0 
         1st-cl# off  #cont-cls off
1A2F38C 	3C EB A2  1 
1A2F390 	F8 4B A0  1 54 EB A2  1 
1A2F398 	F8 4B A0  1 
      then

      last-cluster? 0= if  to-next-cluster  then 
1A2F39C 	CC E7 A2  1 
1A2F3A0 	24 47 A0  1 DC 41 A0  1 
1A2F3A8 	 8  0  0  0  4 E8 A2  1 
   repeat  drop ( )
1A2F3B0 	C8 41 A0  1 80 FE FF FF 
1A2F3B8 	30 49 A0  1 

   extended? @ if
1A2F3BC 	A4 F1 A2  1 
1A2F3C0 	5C 4C A0  1 DC 41 A0  1 
1A2F3C8 	20  0  0  0 
      \ extended partial cluster length adjustment
      remaining @ fh_length l@  +  fh_length l!
1A2F3CC 	FC EA A2  1 
1A2F3D0 	5C 4C A0  1 F8 E5 A2  1 
1A2F3D8 	6C 4C A0  1  4 45 A0  1 
1A2F3E0 	F8 E5 A2  1 7C 4D A0  1 
   then
   fh_flags w@ fh_dirty or  fh_flags w! \ force dirent & FAT update in close
1A2F3E8 	94 E6 A2  1 94 4C A0  1 
1A2F3F0 	E0 E6 A2  1 70 44 A0  1 
1A2F3F8 	94 E6 A2  1 A4 4D A0  1 

\ Flushing the FAT here causes excessive seeking.
\   ?flush-fat-cache

   requested @ remaining @ 0 max - ( bytes-tranferred )
1A2F400 	14 EB A2  1 5C 4C A0  1 
1A2F408 	FC EA A2  1 5C 4C A0  1 
1A2F410 	70 6F A0  1 9C 4A A0  1 
1A2F418 	18 45 A0  1 
   false
1A2F41C 	18 70 A0  1 
;
1A2F420 	58 46 A0  1 

: dos-close  ( 'fh -- error? )
1A2F424 	 0  0 64 6F 
1A2F428 	73 2D 63 6C 6F 73 65 89 
1A2F430 	BC F1 A2  1 20 40 A0  1 
   fh !
1A2F438 	5C E5 A2  1 54 4D A0  1 
   update-dirent ( error? )
1A2F440 	80 EF A2  1 
   dup 0=  if  clear-fh  ?flush-fat-cache  then
1A2F444 	40 49 A0  1 
1A2F448 	24 47 A0  1 DC 41 A0  1 
1A2F450 	 C  0  0  0  8 E7 A2  1 
1A2F458 	98 CE A2  1 
;
1A2F45C 	58 46 A0  1 

OpenFirmware/ofw/fs/fatfs/write.fth_AL	60C 1A2F460 \ Directory operations:
\ file and subdirectory creation, renaming, changing directory
\
\ TODO:
\   Allow renames across directory boundaries.
\   Media change handling (hard to actually implement due to crummy OMTI
\       floppy controller, but the hooks should be put in)

\ mmo private

: set-file-name  ( ext-adr ext-len name-adr name-len -- )
1A2F460 	 0  0 73 65 74 2D 66 69 
1A2F468 	6C 65 2D 6E 61 6D 65 8D 
1A2F470 	34 F4 A2  1 20 40 A0  1 
   de_name d# 11 blank ( ext-adr ext-len name-adr name-len )
1A2F478 	30 BF A2  1 58 41 A0  1 
1A2F480 	 B  0  0  0  C 73 A0  1 
   de_name swap 8 min cmove  de_extension swap 3 min cmove ( )
1A2F488 	30 BF A2  1 68 49 A0  1 
1A2F490 	F0 6F A0  1 74 4A A0  1 
1A2F498 	10 44 A0  1 4C BF A2  1 
1A2F4A0 	68 49 A0  1 A0 6F A0  1 
1A2F4A8 	74 4A A0  1 10 44 A0  1 
;
1A2F4B0 	58 46 A0  1 

: set-stamps  ( attributes -- )
1A2F4B4 	 0 73 65 74 
1A2F4B8 	2D 73 74 61 6D 70 73 8A 
1A2F4C0 	74 F4 A2  1 20 40 A0  1 
   de_attributes c!
1A2F4C8 	68 BF A2  1 B8 4D A0  1 
   0 de_length lel!
1A2F4D0 	70 6F A0  1 DC C0 A2  1 
1A2F4D8 	 8 B5 A2  1 
   now today (set-modtime)
1A2F4DC 	 4 ED A0  1 
1A2F4E0 	20 ED A0  1 9C EE A2  1 
   now today (set-createtime)
1A2F4E8 	 4 ED A0  1 20 ED A0  1 
1A2F4F0 	D4 EE A2  1 
   today (set-accessdate)
1A2F4F4 	20 ED A0  1 
1A2F4F8 	34 EF A2  1 
;
1A2F4FC 	58 46 A0  1 

\ mmo public
: dos-create  ( adr len protection -- error? )
1A2F500 	 0 64 6F 73 2D 63 72 65 
1A2F508 	61 74 65 8A C4 F4 A2  1 
1A2F510 	20 40 A0  1 
\ error? =  0 is success,
\          -1 means: couldn't create (no free entry or already exists),
\          0> means: error writing directory cluster.
   -rot        ( protection adr len )
1A2F514 	94 49 A0  1 

   \ Error if the file already exists
   at_rdonly at_system or at_subdir or at_hidden or     ( protection )
1A2F518 	80 BF A2  1 B0 BF A2  1 
1A2F520 	70 44 A0  1 E0 BF A2  1 
1A2F528 	70 44 A0  1 98 BF A2  1 
1A2F530 	70 44 A0  1 
   find-first if  drop true  exit  then                 ( protection )
1A2F534 	18 E4 A2  1 
1A2F538 	DC 41 A0  1 10  0  0  0 
1A2F540 	30 49 A0  1  4 70 A0  1 
1A2F548 	40 46 A0  1 

   \ Create the file but don't open it
   find-free-dirent  if  drop true  exit  then          ( protection )
1A2F54C 	F8 E4 A2  1 
1A2F550 	DC 41 A0  1 10  0  0  0 
1A2F558 	30 49 A0  1  4 70 A0  1 
1A2F560 	40 46 A0  1 

   base-ext be-len c@ base-name bn-len c@ set-file-name ( protection )
1A2F564 	FC D7 A2  1 
1A2F568 	24 D8 A2  1 C4 4C A0  1 
1A2F570 	E4 D7 A2  1 10 D8 A2  1 
1A2F578 	C4 4C A0  1 74 F4 A2  1 
   set-stamps
1A2F580 	C4 F4 A2  1 
   0 file-cluster!
1A2F584 	70 6F A0  1 
1A2F588 	70 C2 A2  1 

   write-dir-cl    ( error? )  \ Flush directory cluster image to disk
1A2F58C 	6C DD A2  1 
;
1A2F590 	58 46 A0  1 

\ mmo private
: (dos-delete)  ( -- error? )   
1A2F594 	 0  0  0 28 
1A2F598 	64 6F 73 2D 64 65 6C 65 
1A2F5A0 	74 65 29 8C 10 F5 A2  1 
1A2F5A8 	20 40 A0  1 
\ dirent points to the file to be deleted !
   file-cluster@  ( 1st-cl# )         \ remember first cluster  
1A2F5AC 	A0 C2 A2  1 
   0 file-cluster!  h# e5 de_name c!
1A2F5B0 	70 6F A0  1 70 C2 A2  1 
1A2F5B8 	58 41 A0  1 E5  0  0  0 
1A2F5C0 	30 BF A2  1 B8 4D A0  1 
   write-dir-cl   ( 1st-cl#  error? ) \ delete entry in directory cluster first
1A2F5C8 	6C DD A2  1 
   swap  ?dup  if                     \ & from cluster table second (10/28/91)
1A2F5CC 	68 49 A0  1 
1A2F5D0 	B4 70 A0  1 DC 41 A0  1 
1A2F5D8 	 8  0  0  0 
      deallocate-clusters  then 
1A2F5DC 	B8 D5 A2  1 
   ( error? )
;
1A2F5E0 	58 46 A0  1 

\ mmo public

\ This version will delete any file, even read-only, hidden, and system files
: $delete!  ( adr len -- error? )
1A2F5E4 	 0  0  0 24 
1A2F5E8 	64 65 6C 65 74 65 21 88 
1A2F5F0 	A8 F5 A2  1 20 40 A0  1 
   at_rdonly at_system or at_hidden or
1A2F5F8 	80 BF A2  1 B0 BF A2  1 
1A2F600 	70 44 A0  1 98 BF A2  1 
1A2F608 	70 44 A0  1 
   find-first  0=  if  true  exit  then    ( adr len )
1A2F60C 	18 E4 A2  1 
1A2F610 	24 47 A0  1 DC 41 A0  1 
1A2F618 	 C  0  0  0  4 70 A0  1 
1A2F620 	40 46 A0  1 
   (dos-delete)  ( error? )
1A2F624 	A8 F5 A2  1 
;
1A2F628 	58 46 A0  1 
: $delete  ( adr len -- error? )
1A2F62C 	24 64 65 6C 
1A2F630 	65 74 65 87 F4 F5 A2  1 
1A2F638 	20 40 A0  1 
   0  find-first  0=  if  true  exit  then    ( adr len )
1A2F63C 	70 6F A0  1 
1A2F640 	18 E4 A2  1 24 47 A0  1 
1A2F648 	DC 41 A0  1  C  0  0  0 
1A2F650 	 4 70 A0  1 40 46 A0  1 
   (dos-delete)  ( error? )
1A2F658 	A8 F5 A2  1 
;
1A2F65C 	58 46 A0  1 

\ mmo private

\ Creates one of the "special" entries "." and ".."
: make-dotent  ( cluster# adr len -- )
1A2F660 	6D 61 6B 65 2D 64 6F 74 
1A2F668 	65 6E 74 8B 38 F6 A2  1 
1A2F670 	20 40 A0  1 
   " " 2swap  set-file-name   ( cluster# )
1A2F674 	9C 53 A0  1 
1A2F678 	 0  0  0  0 F4 49 A0  1 
1A2F680 	74 F4 A2  1 
   file-cluster!              ( )
1A2F684 	70 C2 A2  1 
   at_subdir set-stamps
1A2F688 	E0 BF A2  1 C4 F4 A2  1 
;
1A2F690 	58 46 A0  1 
: prime-directory  ( parent-cluster# my-cluster# my-dev -- error? )
1A2F694 	70 72 69 6D 
1A2F698 	65 2D 64 69 72 65 63 74 
1A2F6A0 	6F 72 79 8F 70 F6 A2  1 
1A2F6A8 	20 40 A0  1 
   over swap 0 -rot  set-dirent             ( parent-cl# my-cl# error? )
1A2F6AC 	54 49 A0  1 
1A2F6B0 	68 49 A0  1 70 6F A0  1 
1A2F6B8 	94 49 A0  1  4 DE A2  1 
   if  2drop true exit  then                ( parent-cl# my-cl# )
1A2F6C0 	DC 41 A0  1 10  0  0  0 
1A2F6C8 	AC 49 A0  1  4 70 A0  1 
1A2F6D0 	40 46 A0  1 

   \ Clear the first cluster.
   dirent @  /cluster  0 fill               ( parent-cl# my-cl# )
1A2F6D4 	DC BE A2  1 
1A2F6D8 	5C 4C A0  1 18 C3 A2  1 
1A2F6E0 	70 6F A0  1 8C 4E A0  1 

   \ Make the "." entry.
   " ."  make-dotent                        ( parent-cl# )
1A2F6E8 	9C 53 A0  1  1 2E  0  0 
1A2F6F0 	70 F6 A2  1 

   \ Make the ".." entry.
   /dirent dirent +!                        ( parent-cl# )
1A2F6F4 	F0 C0 A2  1 
1A2F6F8 	DC BE A2  1  C 4C A0  1 
   " .." make-dotent                        ( )
1A2F700 	9C 53 A0  1  2 2E 2E  0 
1A2F708 	70 F6 A2  1 

   write-dir-cl  ( error? )
1A2F70C 	6C DD A2  1 
;
1A2F710 	58 46 A0  1 

\ mmo public

: $mkdir  ( adr len -- error? )
1A2F714 	 0 24 6D 6B 
1A2F718 	64 69 72 86 A8 F6 A2  1 
1A2F720 	20 40 A0  1 
   at_subdir dos-create  ?dup  if  exit  then
1A2F724 	E0 BF A2  1 
1A2F728 	10 F5 A2  1 B4 70 A0  1 
1A2F730 	DC 41 A0  1  8  0  0  0 
1A2F738 	40 46 A0  1 

   \ Allocate a cluster for the directory entries.
   \ We don't want to just fault it in as though the directory were
   \ being extended, because we don't have an appropriate value for
   \ the de_first field to indicate this condition.  We could use
   \ fat-eof, but we would still have the problem that extend-dir
   \ would need to hook the new cluster to the head node instead of
   \ to a cluster link.  We might as well just do it here.

   \ Allocate the new cluster near the directory containing it
   search-cl @ allocate-cluster  ( cl# true | false )  if  ( cl# )
1A2F73C 	68 D7 A2  1 
1A2F740 	5C 4C A0  1 10 D5 A2  1 
1A2F748 	DC 41 A0  1 2C  0  0  0 
      ?flush-fat-cache             \ cpt - force to update FAT on device first
1A2F750 	98 CE A2  1 
      dup file-cluster!
1A2F754 	40 49 A0  1 
1A2F758 	70 C2 A2  1 
      \ ??? what should be done with the de_length field of a subdirectory?
      write-dir-cl ?dup if  exit  then
1A2F75C 	6C DD A2  1 
1A2F760 	B4 70 A0  1 DC 41 A0  1 
1A2F768 	 8  0  0  0 40 46 A0  1 
   else
1A2F770 	C8 41 A0  1  C  0  0  0 
      true exit
1A2F778 	 4 70 A0  1 40 46 A0  1 
   then                         ( cl# )

   search-dir-cl @              ( subdir-cl# parent-dir-cl# )
1A2F780 	8C D8 A2  1 5C 4C A0  1 

   \ chdir to the new subdirectory
   dv_cwd-cl l@ -rot  ( old-curdir subdir-cl# parent-dir-cl# )
1A2F788 	84 BB A2  1 6C 4C A0  1 
1A2F790 	94 49 A0  1 
   over dv_cwd-cl l!  ( old-curdir subdir-cl# parent-dir-cl# )
1A2F794 	54 49 A0  1 
1A2F798 	84 BB A2  1 7C 4D A0  1 

   \ Clear the new directory and create the "." and ".." entries
   swap search-dev @ prime-directory    ( old-curdir error? )
1A2F7A0 	68 49 A0  1 9C D7 A2  1 
1A2F7A8 	5C 4C A0  1 A8 F6 A2  1 

   swap dv_cwd-cl l!            ( error? )
1A2F7B0 	68 49 A0  1 84 BB A2  1 
1A2F7B8 	7C 4D A0  1 
;
1A2F7BC 	58 46 A0  1 

\ mmo private

\ Returns true if current directory is empty.
: directory-empty?  ( -- flag )
1A2F7C0 	 0  0  0 64 69 72 65 63 
1A2F7C8 	74 6F 72 79 2D 65 6D 70 
1A2F7D0 	74 79 3F 90 20 F7 A2  1 
1A2F7D8 	20 40 A0  1 
   " *.*" 0 init-search  \ Attrib.s don't matter; next-file ignores them
1A2F7DC 	9C 53 A0  1 
1A2F7E0 	 3 2A 2E 2A  0  0  0  0 
1A2F7E8 	70 6F A0  1 A4 E3 A2  1 
   begin  next-file  while
1A2F7F0 	4C E1 A2  1 DC 41 A0  1 
1A2F7F8 	48  0  0  0 
      file-name  dup 2 >  if   2drop false  exit  then   ( adr len )
1A2F7FC 	7C C1 A2  1 
1A2F800 	40 49 A0  1 90 6F A0  1 
1A2F808 	 4 48 A0  1 DC 41 A0  1 
1A2F810 	10  0  0  0 AC 49 A0  1 
1A2F818 	18 70 A0  1 40 46 A0  1 
      dot-name? 0=  if  false  exit  then 
1A2F820 	70 DB A2  1 24 47 A0  1 
1A2F828 	DC 41 A0  1  C  0  0  0 
1A2F830 	18 70 A0  1 40 46 A0  1 
   repeat
1A2F838 	C8 41 A0  1 B4 FF FF FF 
   true
1A2F840 	 4 70 A0  1 
;
1A2F844 	58 46 A0  1 

\ mmo public

: $rmdir  ( addr len -- error? )
1A2F848 	 0 24 72 6D 64 69 72 86 
1A2F850 	D8 F7 A2  1 20 40 A0  1 
   at_subdir init-search
1A2F858 	E0 BF A2  1 A4 E3 A2  1 
   begin  find-next  while
1A2F860 	CC E3 A2  1 DC 41 A0  1 
1A2F868 	90  0  0  0 
      de_attributes c@ at_subdir and  if   \ Found it
1A2F86C 	68 BF A2  1 
1A2F870 	C4 4C A0  1 E0 BF A2  1 
1A2F878 	5C 44 A0  1 DC 41 A0  1 
1A2F880 	70  0  0  0 

         \ Remember the current directory location
         dv_cwd-cl l@ dirent @ dir-buf -  dir-cl @ dir-dev @ ( cwd offs cl dev)
1A2F884 	84 BB A2  1 
1A2F888 	6C 4C A0  1 DC BE A2  1 
1A2F890 	5C 4C A0  1 1C C4 A2  1 
1A2F898 	18 45 A0  1 A8 DC A2  1 
1A2F8A0 	5C 4C A0  1 94 DC A2  1 
1A2F8A8 	5C 4C A0  1 

         \ Change to the directory to be deleted and see if it's empty
         file-cluster@ dv_cwd-cl l!  directory-empty?  >r    ( cwd offs cl dev)
1A2F8AC 	A0 C2 A2  1 
1A2F8B0 	84 BB A2  1 7C 4D A0  1 
1A2F8B8 	D8 F7 A2  1 BC 45 A0  1 

         \ Go back to where we were
         set-dirent drop  ( cwd )   dv_cwd-cl l!
1A2F8C0 	 4 DE A2  1 30 49 A0  1 
1A2F8C8 	84 BB A2  1 7C 4D A0  1 
         r>  if  (dos-delete)  else  true  then  exit
1A2F8D0 	D0 45 A0  1 DC 41 A0  1 
1A2F8D8 	10  0  0  0 A8 F5 A2  1 
1A2F8E0 	C8 41 A0  1  8  0  0  0 
1A2F8E8 	 4 70 A0  1 40 46 A0  1 
      then
   repeat
1A2F8F0 	C8 41 A0  1 6C FF FF FF 
   true
1A2F8F8 	 4 70 A0  1 
;
1A2F8FC 	58 46 A0  1 

\ mmo private

variable new-device  variable new-directory
1A2F900 	 0 6E 65 77 2D 64 65 76 
1A2F908 	69 63 65 8A 54 F8 A2  1 
1A2F910 	48 40 A0  1 58  9  0  0 
1A2F918 	 0  0 6E 65 77 2D 64 69 
1A2F920 	72 65 63 74 6F 72 79 8D 
1A2F928 	10 F9 A2  1 48 40 A0  1 
1A2F930 	5C  9  0  0 
8 buffer: new-name  3 buffer: new-ext
1A2F934 	 0  0  0 6E 
1A2F938 	65 77 2D 6E 61 6D 65 88 
1A2F940 	2C F9 A2  1 B4 A9 A0  1 
1A2F948 	60  9  0  0  8  0  0  0 
1A2F950 	 C C1 A2  1 6E 65 77 2D 
1A2F958 	65 78 74 87 44 F9 A2  1 
1A2F960 	B4 A9 A0  1 64  9  0  0 
1A2F968 	 3  0  0  0 44 F9 A2  1 

\ mmo public

: $rename  ( old-adr old-len  new-adr new-len -- error? )
1A2F970 	24 72 65 6E 61 6D 65 87 
1A2F978 	60 F9 A2  1 20 40 A0  1 
\ Complications:
\ We need to find the device and directory containing both the old file
\ and the new file.  The following cases are interesting (in order):
\  a) If the new file already exists, error.
\  b) If the files are on different devices, error.
\  c) If the files are in different directories, create a new directory
\     entry, copy the old dirent to the new place, delete old entry.
\  d) If the files are in the same directory, overwrite the file name field
\ A file may be identified by (device, dirent == (cluster,offset)), which is
\ the set of parameters used by set-dirent.  If the file doesn't exist,
\ the enclosing directory needs to be known; a directory is specified by
\ (device, starting-cluster)

   \ Error if the "new" file name already exists
   at_subdir  find-first  if  2drop true exit  then  ( old-adr,len )
1A2F980 	E0 BF A2  1 18 E4 A2  1 
1A2F988 	DC 41 A0  1 10  0  0  0 
1A2F990 	AC 49 A0  1  4 70 A0  1 
1A2F998 	40 46 A0  1 

   \ The "new" file doesn't already exist, but as a side effect of looking
   \ for it, we have processed the directory portion of the pathname.
   \ Save that directory and the final file name.
   search-dev @ new-device !  search-dir-cl @ new-directory ! ( old-adr,len )
1A2F99C 	9C D7 A2  1 
1A2F9A0 	5C 4C A0  1 10 F9 A2  1 
1A2F9A8 	54 4D A0  1 8C D8 A2  1 
1A2F9B0 	5C 4C A0  1 2C F9 A2  1 
1A2F9B8 	54 4D A0  1 
   new-name 8 blank  new-ext 3 blank
1A2F9BC 	44 F9 A2  1 
1A2F9C0 	F0 6F A0  1  C 73 A0  1 
1A2F9C8 	60 F9 A2  1 A0 6F A0  1 
1A2F9D0 	 C 73 A0  1 
   base-name new-name bn-len c@ cmove                ( old-adr,len )
1A2F9D4 	E4 D7 A2  1 
1A2F9D8 	44 F9 A2  1 10 D8 A2  1 
1A2F9E0 	C4 4C A0  1 10 44 A0  1 
   base-ext  new-ext  be-len c@ cmove                ( old-adr,len )
1A2F9E8 	FC D7 A2  1 60 F9 A2  1 
1A2F9F0 	24 D8 A2  1 C4 4C A0  1 
1A2F9F8 	10 44 A0  1 

   at_subdir  find-first  if                         ( )
1A2F9FC 	E0 BF A2  1 
1A2FA00 	18 E4 A2  1 DC 41 A0  1 
1A2FA08 	64  0  0  0 

      \ If the new file and the old file are in the same directory, then
      \ all we have to do is to change the name.  Otherwise, we have to
      \ move the directory entry.

      search-dev @ new-device @ =  search-dir-cl @ new-directory @ = and  if
1A2FA0C 	9C D7 A2  1 
1A2FA10 	5C 4C A0  1 10 F9 A2  1 
1A2FA18 	5C 4C A0  1 24 48 A0  1 
1A2FA20 	8C D8 A2  1 5C 4C A0  1 
1A2FA28 	2C F9 A2  1 5C 4C A0  1 
1A2FA30 	24 48 A0  1 5C 44 A0  1 
1A2FA38 	DC 41 A0  1 24  0  0  0 
         new-ext 3  new-name 8  set-file-name
1A2FA40 	60 F9 A2  1 A0 6F A0  1 
1A2FA48 	44 F9 A2  1 F0 6F A0  1 
1A2FA50 	74 F4 A2  1 
         write-dir-cl                                      ( error? )
1A2FA54 	6C DD A2  1 
      else
1A2FA58 	C8 41 A0  1  8  0  0  0 
         \ We don't handle this case yet.  Here's what would be required:
         \ Make a temporary copy of the "old" dirent.  Remember the
         \ (device,cluster,offset) for the "old" dirent.  Select the
         \ "new" directory.  Allocate a new directory entry with
         \ "find-free-dirent".  Copy the temporary copy of the "old"
         \ dirent to the newly allocated dirent.  write out that cluster.
         \ Switch back to the old dirent and mark it free.
         true
1A2FA60 	 4 70 A0  1 
      then
   else
1A2FA64 	C8 41 A0  1 
1A2FA68 	 8  0  0  0 
      true
1A2FA6C 	 4 70 A0  1 
   then
;
1A2FA70 	58 46 A0  1 

external

: $chdir  ( adr len -- error? )
1A2FA74 	 0 24 63 68 
1A2FA78 	64 69 72 86 7C F9 A2  1 
1A2FA80 	20 40 A0  1 
   dup 0=  if   2drop false  exit   then  \ Bail out early if null argument
1A2FA84 	40 49 A0  1 
1A2FA88 	24 47 A0  1 DC 41 A0  1 
1A2FA90 	10  0  0  0 AC 49 A0  1 
1A2FA98 	18 70 A0  1 40 46 A0  1 

   2dup at_subdir init-search   ( adr len )
1A2FAA0 	C0 49 A0  1 E0 BF A2  1 
1A2FAA8 	A4 E3 A2  1 

   \ If the pathname search failed, we give up immediately
   search-dir-cl @ cl#eof = if  2drop true  exit  then
1A2FAAC 	8C D8 A2  1 
1A2FAB0 	5C 4C A0  1 70 D8 A2  1 
1A2FAB8 	24 48 A0  1 DC 41 A0  1 
1A2FAC0 	10  0  0  0 AC 49 A0  1 
1A2FAC8 	 4 70 A0  1 40 46 A0  1 

   \ If the pathname ends with a backslash or colon character, we won't
   \ actually perform the search; instead we'll just use the directory that
   \ was found as part of the search initialization

   1- + c@  dup ascii \ =  swap ascii : = or  if
1A2FAD0 	54 4B A0  1  4 45 A0  1 
1A2FAD8 	C4 4C A0  1 40 49 A0  1 
1A2FAE0 	58 41 A0  1 5C  0  0  0 
1A2FAE8 	24 48 A0  1 68 49 A0  1 
1A2FAF0 	58 41 A0  1 3A  0  0  0 
1A2FAF8 	24 48 A0  1 70 44 A0  1 
1A2FB00 	DC 41 A0  1 34  0  0  0 
      search-dev @ dup drive ! set-device
1A2FB08 	9C D7 A2  1 5C 4C A0  1 
1A2FB10 	40 49 A0  1 F4 D6 A2  1 
1A2FB18 	54 4D A0  1  4 CC A2  1 
      search-dir-cl @ dv_cwd-cl l!  false  exit
1A2FB20 	8C D8 A2  1 5C 4C A0  1 
1A2FB28 	84 BB A2  1 7C 4D A0  1 
1A2FB30 	18 70 A0  1 40 46 A0  1 
   then

   find-dir  if
1A2FB38 	9C E1 A2  1 DC 41 A0  1 
1A2FB40 	34  0  0  0 
      search-dev @ dup drive ! set-device
1A2FB44 	9C D7 A2  1 
1A2FB48 	5C 4C A0  1 40 49 A0  1 
1A2FB50 	F4 D6 A2  1 54 4D A0  1 
1A2FB58 	 4 CC A2  1 
      file-cluster@ dv_cwd-cl l!  false
1A2FB5C 	A0 C2 A2  1 
1A2FB60 	84 BB A2  1 7C 4D A0  1 
1A2FB68 	18 70 A0  1 
   else
1A2FB6C 	C8 41 A0  1 
1A2FB70 	 8  0  0  0 
      true
1A2FB74 	 4 70 A0  1 
   then
;
1A2FB78 	58 46 A0  1 

OpenFirmware/ofw/fs/fatfs/create.fth_AL	71C 1A2FB7C \ Initializes a disk, creating an empty MS-DOS file system.

\ mmo private

create ibm-jmp  h# eb c,  h# 34 c,  h# 90 c,  0 c,
1A2FB7C 	69 62 6D 2D 
1A2FB80 	6A 6D 70 87 80 FA A2  1 
1A2FB88 	30 40 A0  1 EB 34 90  0 

create fat32-jmp  h# eb c,  h# 58 c,  h# 90 c,  0 c,
1A2FB90 	 0  0 66 61 74 33 32 2D 
1A2FB98 	6A 6D 70 89 88 FB A2  1 
1A2FBA0 	30 40 A0  1 EB 58 90  0 

: set-params16
1A2FBA8 	 0  0  0 73 65 74 2D 70 
1A2FBB0 	61 72 61 6D 73 31 36 8C 
1A2FBB8 	A0 FB A2  1 20 40 A0  1 
( #hidden-sectors #sides sec/trk sec/fat media-desc #sectors #dirents spc bps 
  -- )
   ibm-jmp     bp_branch 3 cmove  \  0  branch-to-boot instruction
1A2FBC0 	88 FB A2  1 9C B7 A2  1 
1A2FBC8 	A0 6F A0  1 10 44 A0  1 
   " Forthmax" bp_name swap cmove \  3  system name string
1A2FBD0 	9C 53 A0  1  8 46 6F 72 
1A2FBD8 	74 68 6D 61 78  0  0  0 
1A2FBE0 	B0 B7 A2  1 68 49 A0  1 
1A2FBE8 	10 44 A0  1 
               bp_bps lew!        \  b  bytes/sector
1A2FBEC 	C4 B7 A2  1 
1A2FBF0 	A8 B4 A2  1 
               bp_spc c!          \  d  sectors/cluster
1A2FBF4 	D8 B7 A2  1 
1A2FBF8 	B8 4D A0  1 
   1           bp_res lew!        \  e  #reserved-sectors
1A2FBFC 	80 6F A0  1 
1A2FC00 	EC B7 A2  1 A8 B4 A2  1 
   2           bp_nfats c!        \ 10  #FATs
1A2FC08 	90 6F A0  1  4 B8 A2  1 
1A2FC10 	B8 4D A0  1 
               bp_ndirs lew!      \ 11  #directory-entries
1A2FC14 	1C B8 A2  1 
1A2FC18 	A8 B4 A2  1 
   dup h# 10000 <  if
1A2FC1C 	40 49 A0  1 
1A2FC20 	58 41 A0  1  0  0  1  0 
1A2FC28 	E4 47 A0  1 DC 41 A0  1 
1A2FC30 	14  0  0  0 
               bp_nsects lew!     \ 13  total-#sectors (including reserved ones)
1A2FC34 	34 B8 A2  1 
1A2FC38 	A8 B4 A2  1 
   else
1A2FC3C 	C8 41 A0  1 
1A2FC40 	 C  0  0  0 
               bp_xnsects lel!    \ 20  total #sectors (4 bytes)
1A2FC44 	B8 B8 A2  1 
1A2FC48 	 8 B5 A2  1 
   then
               bp_media c!        \ 15  media descriptor ("magic" number)
1A2FC4C 	4C B8 A2  1 
1A2FC50 	B8 4D A0  1 
               bp_spf lew!        \ 16  sectors/FAT
1A2FC54 	60 B8 A2  1 
1A2FC58 	A8 B4 A2  1 
               bp_spt lew!        \ 18  sectors/track
1A2FC5C 	74 B8 A2  1 
1A2FC60 	A8 B4 A2  1 
               bp_nsides lew!     \ 1a  #sides (#heads)
1A2FC64 	8C B8 A2  1 
1A2FC68 	A8 B4 A2  1 
               bp_nhid lel!       \ 1c  #hidden-sectors
1A2FC6C 	A0 B8 A2  1 
1A2FC70 	 8 B5 A2  1 
;
1A2FC74 	58 46 A0  1 
: set-params32
1A2FC78 	 0  0  0 73 65 74 2D 70 
1A2FC80 	61 72 61 6D 73 33 32 8C 
1A2FC88 	BC FB A2  1 20 40 A0  1 
( #hidden-sectors #sides sec/trk sec/fat media-desc #sectors #dirents spc bps 
  -- )
   fat32-jmp   bp_branch 3 cmove  \  0  branch-to-boot instruction
1A2FC90 	A0 FB A2  1 9C B7 A2  1 
1A2FC98 	A0 6F A0  1 10 44 A0  1 
   " Forthmax" bp_name swap cmove \  3  system name string
1A2FCA0 	9C 53 A0  1  8 46 6F 72 
1A2FCA8 	74 68 6D 61 78  0  0  0 
1A2FCB0 	B0 B7 A2  1 68 49 A0  1 
1A2FCB8 	10 44 A0  1 
               bp_bps lew!        \  b  bytes/sector
1A2FCBC 	C4 B7 A2  1 
1A2FCC0 	A8 B4 A2  1 
               bp_spc c!          \  d  sectors/cluster
1A2FCC4 	D8 B7 A2  1 
1A2FCC8 	B8 4D A0  1 
   ( #dirents ) drop
1A2FCCC 	30 49 A0  1 
   20          bp_res lew!        \  e  #reserved-sectors
1A2FCD0 	58 41 A0  1 20  0  0  0 
1A2FCD8 	EC B7 A2  1 A8 B4 A2  1 
   2           bp_nfats c!        \ 10  #FATs
1A2FCE0 	90 6F A0  1  4 B8 A2  1 
1A2FCE8 	B8 4D A0  1 
               bp_xnsects lel!    \ 20  total #sectors (4 bytes)
1A2FCEC 	B8 B8 A2  1 
1A2FCF0 	 8 B5 A2  1 
               bp_media c!        \ 15  media descriptor ("magic" number)
1A2FCF4 	4C B8 A2  1 
1A2FCF8 	B8 4D A0  1 
	       bp_bspf lel!	  \ 24  big sectors/FAT
1A2FCFC 	CC B8 A2  1 
1A2FD00 	 8 B5 A2  1 
               bp_spt lew!        \ 18  sectors/track
1A2FD04 	74 B8 A2  1 
1A2FD08 	A8 B4 A2  1 
               bp_nsides lew!     \ 1a  #sides (#heads)
1A2FD0C 	8C B8 A2  1 
1A2FD10 	A8 B4 A2  1 
               bp_nhid lel!       \ 1c  #hidden-sectors
1A2FD14 	A0 B8 A2  1 
1A2FD18 	 8 B5 A2  1 
   2	       bp_rdirclus lel!	  \ 2c  root directory starting cluster
1A2FD1C 	90 6F A0  1 
1A2FD20 	14 B9 A2  1  8 B5 A2  1 
   1	       bp_fsinfos lew!	  \ 30  file system info sector
1A2FD28 	80 6F A0  1 2C B9 A2  1 
1A2FD30 	A8 B4 A2  1 
;
1A2FD34 	58 46 A0  1 
: fill-sectors  ( sector# #sectors byte -- )
1A2FD38 	 0  0  0 66 69 6C 6C 2D 
1A2FD40 	73 65 63 74 6F 72 73 8C 
1A2FD48 	8C FC A2  1 20 40 A0  1 
   /sector alloc-mem                 ( sector# #sectors byte adr )
1A2FD50 	F8 C2 A2  1 F0 6C A0  1 
   tuck /sector  rot fill            ( sector# #sectors adr )
1A2FD58 	E8 46 A0  1 F8 C2 A2  1 
1A2FD60 	7C 49 A0  1 8C 4E A0  1 
   -rot bounds  ?do                  ( adr )
1A2FD68 	94 49 A0  1 F0 6D A0  1 
1A2FD70 	50 42 A0  1 48  0  0  0 
      i 1 2 pick write-sectors if  /sector free-mem
1A2FD78 	B4 42 A0  1 80 6F A0  1 
1A2FD80 	90 6F A0  1  C 4A A0  1 
1A2FD88 	8C BE A2  1 DC 41 A0  1 
1A2FD90 	24  0  0  0 F8 C2 A2  1 
1A2FD98 	 8 6D A0  1 


         "CaW ". ." sector"  abort  then  ( adr )
1A2FD9C 	D4 B3 A2  1 
1A2FDA0 	A8 7C A0  1 20 7C A0  1 
1A2FDA8 	 6 73 65 63 74 6F 72  0 
1A2FDB0 	28 91 A0  1 
   loop                              ( adr )
1A2FDB4 	F8 41 A0  1 
1A2FDB8 	C0 FF FF FF 
   /sector free-mem
1A2FDBC 	F8 C2 A2  1 
1A2FDC0 	 8 6D A0  1 
;
1A2FDC4 	58 46 A0  1 
\ mmo public	\ Called with $call-self
: (init-disk)
1A2FDC8 	28 69 6E 69 74 2D 64 69 
1A2FDD0 	73 6B 29 8B 4C FD A2  1 
1A2FDD8 	20 40 A0  1 
   ( #hid-sectors #sides sec/trk sec/fat media-desc #sectors #dirents
     spc bps fat32? -- )

   over >r >r
1A2FDDC 	54 49 A0  1 
1A2FDE0 	BC 45 A0  1 BC 45 A0  1 
   dos-lock
1A2FDE8 	64 4F A0  1 

   uncache-device   \ force BPB refresh for the next time
1A2FDEC 	78 C3 A2  1 
   0 dv_cwd-cl l!   \ Go to root directory on this device
1A2FDF0 	70 6F A0  1 84 BB A2  1 
1A2FDF8 	7C 4D A0  1 

   dup alloc-mem dup bpb ! over erase
1A2FDFC 	40 49 A0  1 
1A2FE00 	F0 6C A0  1 40 49 A0  1 
1A2FE08 	44 B7 A2  1 54 4D A0  1 
1A2FE10 	54 49 A0  1 F0 72 A0  1 
  
   r@  if  set-params32  else  set-params16  then
1A2FE18 	E4 45 A0  1 DC 41 A0  1 
1A2FE20 	10  0  0  0 8C FC A2  1 
1A2FE28 	C8 41 A0  1  8  0  0  0 
1A2FE30 	BC FB A2  1 
   bpb>device
1A2FE34 	10 C9 A2  1 
   r> r>			( fat32? bps )
1A2FE38 	D0 45 A0  1 D0 45 A0  1 

   bpb @ over 1- + h# aa over c! 1- h# 55 swap c!
1A2FE40 	44 B7 A2  1 5C 4C A0  1 
1A2FE48 	54 49 A0  1 54 4B A0  1 
1A2FE50 	 4 45 A0  1 58 41 A0  1 
1A2FE58 	AA  0  0  0 54 49 A0  1 
1A2FE60 	B8 4D A0  1 54 4B A0  1 
1A2FE68 	58 41 A0  1 55  0  0  0 
1A2FE70 	68 49 A0  1 B8 4D A0  1 
   0 1 bpb @ write-sectors	( fat32? bps error? )
1A2FE78 	70 6F A0  1 80 6F A0  1 
1A2FE80 	44 B7 A2  1 5C 4C A0  1 
1A2FE88 	8C BE A2  1 
   rot  if	\ Write file system info sector
1A2FE8C 	7C 49 A0  1 
1A2FE90 	DC 41 A0  1 10  1  0  0 
      alloc-fssector
1A2FE98 	E0 C6 A2  1 
      fssector @ 2 pick erase
1A2FE9C 	BC B9 A2  1 
1A2FEA0 	5C 4C A0  1 90 6F A0  1 
1A2FEA8 	 C 4A A0  1 F0 72 A0  1 
      over /fsinfo - /n - fssector @ + fsinfo !
1A2FEB0 	54 49 A0  1 8C BA A2  1 
1A2FEB8 	18 45 A0  1 40 51 A0  1 
1A2FEC0 	18 45 A0  1 BC B9 A2  1 
1A2FEC8 	5C 4C A0  1  4 45 A0  1 
1A2FED0 	D0 B9 A2  1 54 4D A0  1 
      fssignature0 fssector @ 4 cmove
1A2FED8 	8C B9 A2  1 BC B9 A2  1 
1A2FEE0 	5C 4C A0  1 B0 6F A0  1 
1A2FEE8 	10 44 A0  1 
      fssignature  fs_sig 4 cmove
1A2FEEC 	A4 B9 A2  1 
1A2FEF0 	24 BA A2  1 B0 6F A0  1 
1A2FEF8 	10 44 A0  1 
      bp_nsects lew@ ?dup 0=  if  bp_xnsects lel@ then
1A2FEFC 	34 B8 A2  1 
1A2FF00 	7C B4 A2  1 B4 70 A0  1 
1A2FF08 	24 47 A0  1 DC 41 A0  1 
1A2FF10 	 C  0  0  0 B8 B8 A2  1 
1A2FF18 	DC B4 A2  1 
      bp_res lew@ -  bp_spc c@ / 2-  fs_#freeclusters lel!
1A2FF1C 	EC B7 A2  1 
1A2FF20 	7C B4 A2  1 18 45 A0  1 
1A2FF28 	D8 B7 A2  1 C4 4C A0  1 
1A2FF30 	98 5F A0  1 64 4B A0  1 
1A2FF38 	44 BA A2  1  8 B5 A2  1 
      3 fs_freecluster# lel!
1A2FF40 	A0 6F A0  1 60 BA A2  1 
1A2FF48 	 8 B5 A2  1 
      fssector @ 2 pick 1- + h# aa over c! 1- h# 55 swap c!
1A2FF4C 	BC B9 A2  1 
1A2FF50 	5C 4C A0  1 90 6F A0  1 
1A2FF58 	 C 4A A0  1 54 4B A0  1 
1A2FF60 	 4 45 A0  1 58 41 A0  1 
1A2FF68 	AA  0  0  0 54 49 A0  1 
1A2FF70 	B8 4D A0  1 54 4B A0  1 
1A2FF78 	58 41 A0  1 55  0  0  0 
1A2FF80 	68 49 A0  1 B8 4D A0  1 
      1 1 fssector @ write-sectors or	( bps error? )
1A2FF88 	80 6F A0  1 80 6F A0  1 
1A2FF90 	BC B9 A2  1 5C 4C A0  1 
1A2FF98 	8C BE A2  1 70 44 A0  1 
      free-fssector
1A2FFA0 	20 C7 A2  1 
   then

   bpb @ rot free-mem
1A2FFA4 	44 B7 A2  1 
1A2FFA8 	5C 4C A0  1 7C 49 A0  1 
1A2FFB0 	 8 6D A0  1 
   if  "CaW ". ." sector 0"  abort  then
1A2FFB4 	DC 41 A0  1 
1A2FFB8 	20  0  0  0 D4 B3 A2  1 
1A2FFC0 	A8 7C A0  1 20 7C A0  1 
1A2FFC8 	 8 73 65 63 74 6F 72 20 
1A2FFD0 	30  0  0  0 28 91 A0  1 

   0 bps w!    \ Force reread
1A2FFD8 	70 6F A0  1 34 BC A2  1 
1A2FFE0 	A4 4D A0  1 
   ?read-bpb   \ Now read back the BIOS parameter block
1A2FFE4 	58 CB A2  1 

   \ Clear the FATs. (0 means "free cluster")
   fat-sector0 w@  spf l@ 2*  ( assume 2 FATs )  0  fill-sectors
1A2FFE8 	F0 BB A2  1 94 4C A0  1 
1A2FFF0 	28 BB A2  1 6C 4C A0  1 
1A2FFF8 	A0 4B A0  1 70 6F A0  1 
1A30000 	4C FD A2  1 

   media c@ h# 0fffff00 or  0 cluster!
1A30004 	6C BC A2  1 
1A30008 	C4 4C A0  1 58 41 A0  1 
1A30010 	 0 FF FF  F 70 44 A0  1 
1A30018 	70 6F A0  1 14 D1 A2  1 
   fat-eof  1 cluster!
1A30020 	F8 CC A2  1 80 6F A0  1 
1A30028 	14 D1 A2  1 
   fat-type c@ fat32 =  if  fat-eof 2 cluster!  then
1A3002C 	84 BC A2  1 
1A30030 	C4 4C A0  1 F0 BC A2  1 
1A30038 	24 48 A0  1 DC 41 A0  1 
1A30040 	10  0  0  0 F8 CC A2  1 
1A30048 	90 6F A0  1 14 D1 A2  1 
   ?flush-fat-cache
1A30050 	98 CE A2  1 

   \ Clear the root directory.
   init-dir   \ Invalidate the directory cache
1A30054 	EC DC A2  1 
   rdirclus l@  ?dup  if
1A30058 	40 BB A2  1 6C 4C A0  1 
1A30060 	B4 70 A0  1 DC 41 A0  1 
1A30068 	1C  0  0  0 
      1 cl>sector 0 fill-sectors
1A3006C 	80 6F A0  1 
1A30070 	5C CC A2  1 70 6F A0  1 
1A30078 	4C FD A2  1 
   else
1A3007C 	C8 41 A0  1 
1A30080 	1C  0  0  0 
      dir-sector0 w@ #dir-sectors w@ 0  fill-sectors
1A30084 	 8 BC A2  1 
1A30088 	94 4C A0  1 24 BC A2  1 
1A30090 	94 4C A0  1 70 6F A0  1 
1A30098 	4C FD A2  1 
   then
   
   \ XXX We should put a label in the root directory.

   dos-unlock
1A3009C 	64 4F A0  1 
;
1A300A0 	58 46 A0  1 

[ifdef] format-floppies

public

\ Extra high density floppy; 2.88MB total space (3-1/2")
\ 512-byte sectors, 8.5K x 2 FATs, 7K root directory, 2 sectors/cluster
: 3ed-fl-init  ( -- )
   2ed-den
   0  2  d# 36  d# 9  h# f0  d# 5760  d# 224  2  d# 512  0  false  (init-disk)
;

\ PC/AT style high density floppy; 1.44MB total space (3-1/2")
\ 512-byte sectors, 4.5K x 2 FATs, 7K root directory, 1 sectors/cluster
: 3hd-fl-init  ( -- )
   2hd-den
   0  2  d# 18  9  h# f0  d# 2880  d# 224  1  d# 512  0  false  (init-disk)
;
[then]

[ifdef] format-hard-disks

public

variable  c-kbytes d# 5120 c-kbytes ! \ ** 1/17/91 cpt 

\ Hard disk, using 5 Mbytes of the disk for DOS file system space
\ 1K sectors, 6K x 2 FATs (enough to map <3 Mbytes of disk space),
\ 256 root directory entries (8K), ?M total space, 1 sector/cluster
: hd-init  ( -- )  \ 10 sects/FAT               
   0  7  9  c-kbytes @ 2* d# 1024 /mod swap  if  1+  then
                   h# f8  c-kbytes @  d# 256  1  d# 1024  false  (init-disk)
;
[then]

[ifdef] format-floppies

public

: format-1.44  ( -- )  3hd-format 3hd-fl-init  ;
: format-2.88  ( -- )  3ed-format 3ed-fl-init  ;
[then]

OpenFirmware/ofw/fs/fatfs/makefs.fth_AL	528 1A300A4 \ DOS file interface

hex

\ mmo private

\ Protection to be assigned to newly-created files
\ Defaults to unprotected

\ variable file-protection

\ Interfaces between the buffering code and the lower level operating
\ system code.  This is the stuff that has to be reimplemented to port
\ to a different operating system.

\ Rounds down to a block boundary.  This causes all file accesses to the
\ underlying operating system to occur on disk block boundaries.  Some
\ systems (e.g. CP/M) require this; others which don't require it (e.g. GEM)
\ usually run faster with alignment than without.  It is required for
\ the Forth DOS file system, which only handle cluster-sized chunks
\ at the low level, depending on the higher level buffering to handle
\ the fragments.

: dosdfalign  ( d.byte# 'fh -- d.aligned )
1A300A4 	 0 64 6F 73 
1A300A8 	64 66 61 6C 69 67 6E 8A 
1A300B0 	D8 FD A2  1 20 40 A0  1 
   drop swap /cluster 1- invert and  swap
1A300B8 	30 49 A0  1 68 49 A0  1 
1A300C0 	18 C3 A2  1 54 4B A0  1 
1A300C8 	30 45 A0  1 5C 44 A0  1 
1A300D0 	68 49 A0  1 
;
1A300D4 	58 46 A0  1 

: dosdflen   ( 'fhandle -- d.size )  fh !  fh_length l@  0  ;
1A300D8 	 0  0  0 64 6F 73 64 66 
1A300E0 	6C 65 6E 88 B4  0 A3  1 
1A300E8 	20 40 A0  1 5C E5 A2  1 
1A300F0 	54 4D A0  1 F8 E5 A2  1 
1A300F8 	6C 4C A0  1 70 6F A0  1 
1A30100 	58 46 A0  1 

: dosdfseek  ( d.byte# 'fh -- )  nip dos-seek  abort" dosdfseek failed"  ;
1A30104 	 0  0 64 6F 
1A30108 	73 64 66 73 65 65 6B 89 
1A30110 	E8  0 A3  1 20 40 A0  1 
1A30118 	FC 46 A0  1 88 E8 A2  1 
1A30120 	 8 81 A0  1 10 64 6F 73 
1A30128 	64 66 73 65 65 6B 20 66 
1A30130 	61 69 6C 65 64  0  0  0 
1A30138 	58 46 A0  1 

: dosfread   ( addr count 'fh -- #read )  dos-read  abort" dosfread failed"  ;
1A3013C 	 0  0  0 64 
1A30140 	6F 73 66 72 65 61 64 88 
1A30148 	14  1 A3  1 20 40 A0  1 
1A30150 	E0 EB A2  1  8 81 A0  1 
1A30158 	 F 64 6F 73 66 72 65 61 
1A30160 	64 20 66 61 69 6C 65 64 
1A30168 	 0  0  0  0 58 46 A0  1 

: dosfwrite  ( addr count 'fh -- #written )  dos-write  if  0  then  ;
1A30170 	 0  0 64 6F 73 66 77 72 
1A30178 	69 74 65 89 4C  1 A3  1 
1A30180 	20 40 A0  1 BC F1 A2  1 
1A30188 	DC 41 A0  1  8  0  0  0 
1A30190 	70 6F A0  1 58 46 A0  1 

: dosfclose  ( 'fh -- )
1A30198 	 0  0 64 6F 73 66 63 6C 
1A301A0 	6F 73 65 89 80  1 A3  1 
1A301A8 	20 40 A0  1 
   dos-close abort" dosfclose failed"
1A301AC 	34 F4 A2  1 
1A301B0 	 8 81 A0  1 10 64 6F 73 
1A301B8 	66 63 6C 6F 73 65 20 66 
1A301C0 	61 69 6C 65 64  0  0  0 
   bfbase @  /cluster free-mem
1A301C8 	98 AB A0  1 5C 4C A0  1 
1A301D0 	18 C3 A2  1  8 6D A0  1 
;
1A301D8 	58 46 A0  1 

: $dosopen  ( adr len mode -- ... )
1A301DC 	 0  0  0 24 
1A301E0 	64 6F 73 6F 70 65 6E 88 
1A301E8 	A8  1 A3  1 20 40 A0  1 
   dup >r  name-open  ( error? )  if
1A301F0 	40 49 A0  1 BC 45 A0  1 
1A301F8 	8C EA A2  1 DC 41 A0  1 
1A30200 	10  0  0  0 
      false
1A30204 	18 70 A0  1 
   else
1A30208 	C8 41 A0  1 94  0  0  0 
[ifndef] dos-fd
\ In the context of the file system reading support package, a buffer
\ hasn't been previously allocated.
      bfbase @ /fbuf free-mem
[then]
      /cluster alloc-mem /cluster initbuf
1A30210 	18 C3 A2  1 F0 6C A0  1 
1A30218 	18 C3 A2  1 F4 CA A0  1 
      r@  ['] dosdflen  ['] dosdfalign  ['] dosfclose  ['] dosdfseek
1A30220 	E4 45 A0  1 60 53 A0  1 
1A30228 	E8  0 A3  1 60 53 A0  1 
1A30230 	B4  0 A3  1 60 53 A0  1 
1A30238 	A8  1 A3  1 60 53 A0  1 
1A30240 	14  1 A3  1 
      r@ read  =  if  ['] nullwrite  else  ['] dosfwrite  then
1A30244 	E4 45 A0  1 
1A30248 	E8 C9 A0  1 24 48 A0  1 
1A30250 	DC 41 A0  1 14  0  0  0 
1A30258 	60 53 A0  1 40 CA A0  1 
1A30260 	C8 41 A0  1  C  0  0  0 
1A30268 	60 53 A0  1 80  1 A3  1 
      r@ write =  if  ['] nullread   else  ['] dosfread   then
1A30270 	E4 45 A0  1 FC C9 A0  1 
1A30278 	24 48 A0  1 DC 41 A0  1 
1A30280 	14  0  0  0 60 53 A0  1 
1A30288 	9C CA A0  1 C8 41 A0  1 
1A30290 	 C  0  0  0 60 53 A0  1 
1A30298 	4C  1 A3  1 
      true
1A3029C 	 4 70 A0  1 
   then
   r> drop
1A302A0 	D0 45 A0  1 30 49 A0  1 
;
1A302A8 	58 46 A0  1 
[ifdef] dos-ui
: dosopen  ( name mode -- ...)
   ( ... -- fid sizeop alignop closeop seekop writeop readop true  | false )
   >r  count  r> $dosopen
;

\ Creates an empty file with name "name".  The file still must be
\ opened if it is to be accessed. true = success, false = failure.
: dosmake  ( name -- flag )  
   count
   2dup file-protection @  dos-create  ?dup if  ( adr len [-2|-1|0>] )
      -1 = if  \ file exists, delete it first and try again ***
         2dup  $delete  if  ( adr len )
            2drop false
         else
            file-protection @  dos-create  0=   then
      else  2drop  false  then  \ i/o error or no space  *** 10/28/91
   else 
      2drop true
   then
;

\ Installs DOS filing in basic file I/O.
: install-dos-files  ( -- )
   0 is file-protection  \ no special protection
   ['] dosopen  to do-fopen
   ['] dosmake  to make
;
[then]

[ifdef] notdef
\ Removes DOS filing from basic file I/O.
: unload-dos-files  ( -- )
   o# 664 is file-protection \ rw-rw-r--
   ['] sys_fopen  to do-fopen
   ['] sys_make   to make
;
[then]

[ifdef] dos-ui
public

warning @ warning off
: stand-init  ( -- )  stand-init  install-dos-files  ;
warning !
[then]

[ifdef] notdef
public
\ ** cpt 10/30/90: added fast dos I/O words. RESTRICTION: they are  
\ good only for ONE SHOT (whole) I/O after the file is opened/created.
\ Fclose must be called after this calls.
\ file handle pointing is based on current Kernel 'fd' field offset (32) !

: fread   ( addr count 'fd -- #read )  d# 32 + @ dosfread  ;

: fwrite  ( addr count 'fd -- )        d# 32 + @ dosfwrite drop  ;
[then]

OpenFirmware/ofw/fs/fatfs/sysdos.fth_AL	208 1A302AC purpose: Enumerate directory entries

\ mmo private

\ Convert DOS file attributes to the firmware encoding
\ see showdir.fth for a description of the firmware encoding
: >canonical-attrs  ( dos-attrs -- canon-attrs )
1A302AC 	 0  0  0 3E 
1A302B0 	63 61 6E 6F 6E 69 63 61 
1A302B8 	6C 2D 61 74 74 72 73 90 
1A302C0 	EC  1 A3  1 20 40 A0  1 
   >r
1A302C8 	BC 45 A0  1 
   \ Access permissions
   r@     1 and  if  o# 666  else  o# 777  then \ rwxrwxrwx
1A302CC 	E4 45 A0  1 
1A302D0 	80 6F A0  1 5C 44 A0  1 
1A302D8 	DC 41 A0  1 14  0  0  0 
1A302E0 	58 41 A0  1 B6  1  0  0 
1A302E8 	C8 41 A0  1  C  0  0  0 
1A302F0 	58 41 A0  1 FF  1  0  0 

   \ Bits that are independent of one another
   r@     2 and  if  h# 10000 or  then		\ hidden
1A302F8 	E4 45 A0  1 90 6F A0  1 
1A30300 	5C 44 A0  1 DC 41 A0  1 
1A30308 	10  0  0  0 58 41 A0  1 
1A30310 	 0  0  1  0 70 44 A0  1 
   r@     4 and  if  h# 20000 or  then		\ system
1A30318 	E4 45 A0  1 B0 6F A0  1 
1A30320 	5C 44 A0  1 DC 41 A0  1 
1A30328 	10  0  0  0 58 41 A0  1 
1A30330 	 0  0  2  0 70 44 A0  1 
   r@ h# 20 and  if  h# 40000 or  then		\ archive
1A30338 	E4 45 A0  1 58 41 A0  1 
1A30340 	20  0  0  0 5C 44 A0  1 
1A30348 	DC 41 A0  1 10  0  0  0 
1A30350 	58 41 A0  1  0  0  4  0 
1A30358 	70 44 A0  1 

   \ Mutually-exclusive file types
   r@     8 and  if  h#  3000 or  then		\ Volume label
1A3035C 	E4 45 A0  1 
1A30360 	F0 6F A0  1 5C 44 A0  1 
1A30368 	DC 41 A0  1 10  0  0  0 
1A30370 	58 41 A0  1  0 30  0  0 
1A30378 	70 44 A0  1 
   r> h# 10 and  if  h#  4000 or  then		\ Subdirectory
1A3037C 	D0 45 A0  1 
1A30380 	58 41 A0  1 10  0  0  0 
1A30388 	5C 44 A0  1 DC 41 A0  1 
1A30390 	10  0  0  0 58 41 A0  1 
1A30398 	 0 40  0  0 70 44 A0  1 
   dup h# f000 and  0=  if  h# 8000 or  then	\ Ordinary file	
1A303A0 	40 49 A0  1 58 41 A0  1 
1A303A8 	 0 F0  0  0 5C 44 A0  1 
1A303B0 	24 47 A0  1 DC 41 A0  1 
1A303B8 	10  0  0  0 58 41 A0  1 
1A303C0 	 0 80  0  0 70 44 A0  1 
;
1A303C8 	58 46 A0  1 

\ mmo public
: file-info  ( -- s m h d m y len attributes name$ )
1A303CC 	 0  0 66 69 
1A303D0 	6C 65 2D 69 6E 66 6F 89 
1A303D8 	C4  2 A3  1 20 40 A0  1 
   file-time  file-date  file-size  file-attributes >canonical-attrs
1A303E0 	24 C2 A2  1  0 C2 A2  1 
1A303E8 	E0 C1 A2  1 4C C2 A2  1 
1A303F0 	C4  2 A3  1 
   file-name
1A303F4 	7C C1 A2  1 
;
1A303F8 	58 46 A0  1 

: next-file-info  ( id -- false | id' s m h d m y len attributes name$ true )
1A303FC 	 0 6E 65 78 
1A30400 	74 2D 66 69 6C 65 2D 69 
1A30408 	6E 66 6F 8E DC  3 A3  1 
1A30410 	20 40 A0  1 
   dup 0=  if  0 0 0 set-search  then  ( id )
1A30414 	40 49 A0  1 
1A30418 	24 47 A0  1 DC 41 A0  1 
1A30420 	14  0  0  0 70 6F A0  1 
1A30428 	70 6F A0  1 70 6F A0  1 
1A30430 	98 E2 A2  1 
   next-file  if                       ( id )
1A30434 	4C E1 A2  1 
1A30438 	DC 41 A0  1 18  0  0  0 
      1+  file-info  true
1A30440 	30 4B A0  1 DC  3 A3  1 
1A30448 	 4 70 A0  1 
   else
1A3044C 	C8 41 A0  1 
1A30450 	 C  0  0  0 
      drop false
1A30454 	30 49 A0  1 
1A30458 	18 70 A0  1 
   then
;
1A3045C 	58 46 A0  1 
: $create  ( adr len -- error? )  h# 20 dos-create  ;  \ Set archive bit
1A30460 	24 63 72 65 61 74 65 87 
1A30468 	10  4 A3  1 20 40 A0  1 
1A30470 	58 41 A0  1 20  0  0  0 
1A30478 	10 F5 A2  1 58 46 A0  1 

OpenFirmware/ofw/fs/fatfs/enumdir.fth_AL	1D4 1A30480 purpose: Interface methods for FAT file system package

\ mmo private
false instance value file-open?
1A30480 	 0 66 69 6C 65 2D 6F 70 
1A30488 	65 6E 3F 8A 6C  4 A3  1 
1A30490 	C0 FE A1  1 2C  0  0  0 
: free-device  ( -- )  current-device @ /device free-mem  ;
1A30498 	66 72 65 65 2D 64 65 76 
1A304A0 	69 63 65 8B 90  4 A3  1 
1A304A8 	20 40 A0  1 A8 BA A2  1 
1A304B0 	5C 4C A0  1 B4 BC A2  1 
1A304B8 	 8 6D A0  1 58 46 A0  1 

: open  ( -- okay? )
1A304C0 	 0  0  0 6F 70 65 6E 84 
1A304C8 	A8  4 A3  1 20 40 A0  1 
   /device alloc-mem  (set-device)
1A304D0 	B4 BC A2  1 F0 6C A0  1 
1A304D8 	28 C5 A2  1 
   current-device @ /device erase
1A304DC 	A8 BA A2  1 
1A304E0 	5C 4C A0  1 B4 BC A2  1 
1A304E8 	F0 72 A0  1 

   current-device @  drive !
1A304EC 	A8 BA A2  1 
1A304F0 	5C 4C A0  1 F4 D6 A2  1 
1A304F8 	54 4D A0  1 

   init-dir
1A304FC 	EC DC A2  1 

   my-args " <NoFile>"  $=  if  true exit  then
1A30500 	10  7 A2  1 9C 53 A0  1 
1A30508 	 8 3C 4E 6F 46 69 6C 65 
1A30510 	3E  0  0  0 88 8D A0  1 
1A30518 	DC 41 A0  1  C  0  0  0 
1A30520 	 4 70 A0  1 40 46 A0  1 

   ['] ?read-bpb catch  if  free-device  false  exit  then
1A30528 	60 53 A0  1 58 CB A2  1 
1A30530 	14 7F A0  1 DC 41 A0  1 
1A30538 	10  0  0  0 A8  4 A3  1 
1A30540 	18 70 A0  1 40 46 A0  1 

   my-args  ascii \ split-after                 ( file$ path$ )
1A30548 	10  7 A2  1 58 41 A0  1 
1A30550 	5C  0  0  0 BC 19 A1  1 
   $chdir  if  free-device false  exit  then    ( file$ )
1A30558 	80 FA A2  1 DC 41 A0  1 
1A30560 	10  0  0  0 A8  4 A3  1 
1A30568 	18 70 A0  1 40 46 A0  1 

   \ Filename ends in "\"; select the directory and exit with success
   dup  0=  if  2drop  true exit  then          ( file$ )
1A30570 	40 49 A0  1 24 47 A0  1 
1A30578 	DC 41 A0  1 10  0  0  0 
1A30580 	AC 49 A0  1  4 70 A0  1 
1A30588 	40 46 A0  1 

   file @ >r  dos-fd file !                     ( file$ )
1A3058C 	84 AB A0  1 
1A30590 	5C 4C A0  1 BC 45 A0  1 
1A30598 	44 B3 A2  1 84 AB A0  1 
1A305A0 	54 4D A0  1 

   2dup r/w $dosopen 0=  if                     ( file$ )
1A305A4 	C0 49 A0  1 
1A305A8 	3C D6 A0  1 EC  1 A3  1 
1A305B0 	24 47 A0  1 DC 41 A0  1 
1A305B8 	58  0  0  0 
      2dup r/o $dosopen 0=  if                  ( file$ )
1A305BC 	C0 49 A0  1 
1A305C0 	1C D6 A0  1 EC  1 A3  1 
1A305C8 	24 47 A0  1 DC 41 A0  1 
1A305D0 	40  0  0  0 
         r> file !                              ( file$ )
1A305D4 	D0 45 A0  1 
1A305D8 	84 AB A0  1 54 4D A0  1 
         $chdir  0=  if  true  exit  then       ( )
1A305E0 	80 FA A2  1 24 47 A0  1 
1A305E8 	DC 41 A0  1  C  0  0  0 
1A305F0 	 4 70 A0  1 40 46 A0  1 
         ?free-fat-cache  free-bpb  free-fssector  free-device  false    exit
1A305F8 	C8 C4 A2  1 68 C5 A2  1 
1A30600 	20 C7 A2  1 A8  4 A3  1 
1A30608 	18 70 A0  1 40 46 A0  1 
      then
   then            ( file$ file-ops ... )
   setupfd
1A30610 	64 C9 A0  1 
   2drop
1A30614 	AC 49 A0  1 
   true to file-open?
1A30618 	 4 70 A0  1 48 B8 A1  1 
1A30620 	90  4 A3  1 
   true
1A30624 	 4 70 A0  1 
   r> file !
1A30628 	D0 45 A0  1 84 AB A0  1 
1A30630 	54 4D A0  1 
;
1A30634 	58 46 A0  1 

: close  ( -- )
1A30638 	 0  0 63 6C 6F 73 65 85 
1A30640 	CC  4 A3  1 20 40 A0  1 
   file-open?  if
1A30648 	90  4 A3  1 DC 41 A0  1 
1A30650 	28  0  0  0 
      dos-fd ['] fclose catch  ?dup  if  .error drop  then
1A30654 	44 B3 A2  1 
1A30658 	60 53 A0  1 5C CC A0  1 
1A30660 	14 7F A0  1 B4 70 A0  1 
1A30668 	DC 41 A0  1  C  0  0  0 
1A30670 	70 CF A0  1 30 49 A0  1 
   then
   ?free-fat-cache
1A30678 	C8 C4 A2  1 
   free-bpb
1A3067C 	68 C5 A2  1 
   free-fssector
1A30680 	20 C7 A2  1 
   free-device
1A30684 	A8  4 A3  1 
;
1A30688 	58 46 A0  1 
: read  ( adr len -- actual )
1A3068C 	 0  0  0 72 
1A30690 	65 61 64 84 44  6 A3  1 
1A30698 	20 40 A0  1 
   dos-fd  ['] fgets catch  if  3drop 0  then
1A3069C 	44 B3 A2  1 
1A306A0 	60 53 A0  1 1C D4 A0  1 
1A306A8 	14 7F A0  1 DC 41 A0  1 
1A306B0 	 C  0  0  0 90 52 A0  1 
1A306B8 	70 6F A0  1 
;
1A306BC 	58 46 A0  1 
: write  ( adr len -- actual )
1A306C0 	 0  0 77 72 69 74 65 85 
1A306C8 	98  6 A3  1 20 40 A0  1 
   tuck  dos-fd  ['] fputs catch  if  2drop 2drop -1  then
1A306D0 	E8 46 A0  1 44 B3 A2  1 
1A306D8 	60 53 A0  1  8 B3 A0  1 
1A306E0 	14 7F A0  1 DC 41 A0  1 
1A306E8 	14  0  0  0 AC 49 A0  1 
1A306F0 	AC 49 A0  1 58 41 A0  1 
1A306F8 	FF FF FF FF 
;
1A306FC 	58 46 A0  1 
: seek   ( offset.low offset.high -- error? )
1A30700 	 0  0  0 73 65 65 6B 84 
1A30708 	CC  6 A3  1 20 40 A0  1 
   dos-fd  ['] dfseek catch  if  2drop true  else  false  then
1A30710 	44 B3 A2  1 60 53 A0  1 
1A30718 	F8 D1 A0  1 14 7F A0  1 
1A30720 	DC 41 A0  1 14  0  0  0 
1A30728 	AC 49 A0  1  4 70 A0  1 
1A30730 	C8 41 A0  1  8  0  0  0 
1A30738 	18 70 A0  1 
;
1A3073C 	58 46 A0  1 
: size  ( -- d )  fh_length l@  0  ;
1A30740 	 0  0  0 73 69 7A 65 84 
1A30748 	 C  7 A3  1 20 40 A0  1 
1A30750 	F8 E5 A2  1 6C 4C A0  1 
1A30758 	70 6F A0  1 58 46 A0  1 
: load  ( adr -- size )  size drop read  ;
1A30760 	 0  0  0 6C 6F 61 64 84 
1A30768 	4C  7 A3  1 20 40 A0  1 
1A30770 	4C  7 A3  1 30 49 A0  1 
1A30778 	98  6 A3  1 58 46 A0  1 

[ifdef] notdef
\ XXX we need to figure out what environment this runs in! open or not open
\ Creates an empty file with name "name".  The file still must be
\ opened if it is to be accessed. true = success, false = failure.
: $create  ( name$ mode -- flag )  
   3dup  dos-create  ?dup if  ( adr len mode [-2|-1|0>] )
      -1 = if  \ file exists, delete it first and try again
         2 pick 2 pick  $delete  if  ( adr len mode )
            3drop false
         else
            dos-create  0=   then
      else  3drop  false  then  \ i/o error or no space
   else 
      3drop true
   then
;
[then]

OpenFirmware/ofw/fs/fatfs/methods.fth_AL	300 1A30780 
99CF4F4   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99CF504   00 00 00 00  00 00 00 00  FF FF FF FF  00 00 00 00 ............
99CF514   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................32\ : le-x@  ( adr -- x )  dup le-l@  swap la1+ le-l@  ;
1A307B0 	 0  0 6C 65 2D 78 40 85 
1A307B8 	C8 B2 A2  1 20 40 A0  1 
1A307C0 	40 49 A0  1 4C 4C A0  1 
1A307C8 	68 49 A0  1 B4 50 A0  1 
1A307D0 	4C 4C A0  1 58 46 A0  1 
0 value #gpt-partitions
1A307D8 	23 67 70 74 2D 70 61 72 
1A307E0 	74 69 74 69 6F 6E 73 8F 
1A307E8 	BC  7 A3  1 50 40 A0  1 
1A307F0 	68  9  0  0 
0 value /gpt-entry
1A307F4 	 0 2F 67 70 
1A307F8 	74 2D 65 6E 74 72 79 8A 
1A30800 	EC  7 A3  1 50 40 A0  1 
1A30808 	6C  9  0  0 
32\ 0. 2value partition-lba0
1A3080C 	 0 70 61 72 
1A30810 	74 69 74 69 6F 6E 2D 6C 
1A30818 	62 61 30 8E  4  8 A3  1 
1A30820 	24 BA A1  1 70  9  0  0 
32\ alias x>u drop
1A30828 	78 3E 75 A3 20  8 A3  1 
1A30830 	30 49 A0  1 
32\ alias u>x u>d
1A30834 	75 3E 78 A3 
1A30838 	30  8 A3  1 B4 68 A0  1 
32\ alias x+ d+
1A30840 	 0 78 2B A2 3C  8 A3  1 
1A30848 	E0 5D A0  1 
32\ alias x- d-
1A3084C 	 0 78 2D A2 
1A30850 	48  8 A3  1 F8 5D A0  1 
32\ alias xswap 2swap
1A30858 	 0  0 78 73 77 61 70 A5 
1A30860 	54  8 A3  1 F4 49 A0  1 
32\ : onex 1. ;
1A30868 	 0  0  0 6F 6E 65 78 84 
1A30870 	64  8 A3  1 20 40 A0  1 
1A30878 	80 41 A0  1  1  0  0  0 
1A30880 	 0  0  0  0 58 46 A0  1 
32\ : xu*d  ( x u -- d )  du*  ;
1A30888 	 0  0  0 78 75 2A 64 84 
1A30890 	74  8 A3  1 20 40 A0  1 
1A30898 	54 6B A0  1 58 46 A0  1 
64\ alias xu*d um*

: gpt-magic  ( -- adr len )  " EFI PART"  ;
1A308A0 	 0  0 67 70 74 2D 6D 61 
1A308A8 	67 69 63 89 94  8 A3  1 
1A308B0 	20 40 A0  1 9C 53 A0  1 
1A308B8 	 8 45 46 49 20 50 41 52 
1A308C0 	54  0  0  0 58 46 A0  1 
: gpt-blk0   ( adr -- d.blk0 )  d# 32 + le-x@  ;
1A308C8 	 0  0  0 67 70 74 2D 62 
1A308D0 	6C 6B 30 88 B0  8 A3  1 
1A308D8 	20 40 A0  1 58 41 A0  1 
1A308E0 	20  0  0  0  4 45 A0  1 
1A308E8 	BC  7 A3  1 58 46 A0  1 
: gpt-#blks  ( adr -- d.blks )  dup d# 40 + le-x@  rot gpt-blk0 x-  onex d+  ;
1A308F0 	 0  0 67 70 74 2D 23 62 
1A308F8 	6C 6B 73 89 D8  8 A3  1 
1A30900 	20 40 A0  1 40 49 A0  1 
1A30908 	58 41 A0  1 28  0  0  0 
1A30910 	 4 45 A0  1 BC  7 A3  1 
1A30918 	7C 49 A0  1 D8  8 A3  1 
1A30920 	F8 5D A0  1 74  8 A3  1 
1A30928 	E0 5D A0  1 58 46 A0  1 

OpenFirmware/ofw/disklabel/gpttools.fth_AL	180 1A30930 
propset=1A30944 B442136 1A009B8 
vocset=B442136 1A009B8 1A30944 
new-node=B44214A 1A00998 
vocset=B44214A 1A00998 1A30944 1A30958 purpose: Data that is common to all format recognizers

-1 instance value size-low
1A30964 	 0  0  0 73 
1A30968 	69 7A 65 2D 6C 6F 77 88 
1A30970 	 0  0 A0  1 C0 FE A1  1 
1A30978 	18  0  0  0 
-1 instance value size-high
1A3097C 	 0  0 73 69 
1A30980 	7A 65 2D 68 69 67 68 89 
1A30988 	74  9 A3  1 C0 FE A1  1 
1A30990 	1C  0  0  0 
0 instance value partition-type
1A30994 	 0 70 61 72 
1A30998 	74 69 74 69 6F 6E 2D 74 
1A309A0 	79 70 65 8E 8C  9 A3  1 
1A309A8 	C0 FE A1  1 20  0  0  0 
h# 81 constant minix-type
1A309B0 	 0 6D 69 6E 69 78 2D 74 
1A309B8 	79 70 65 8A A8  9 A3  1 
1A309C0 	68 40 A0  1 81  0  0  0 
h# 83 constant ext2fs-type
1A309C8 	65 78 74 32 66 73 2D 74 
1A309D0 	79 70 65 8B C0  9 A3  1 
1A309D8 	68 40 A0  1 83  0  0  0 
h# a5 constant ufs-type
1A309E0 	 0  0  0 75 66 73 2D 74 
1A309E8 	79 70 65 88 D8  9 A3  1 
1A309F0 	68 40 A0  1 A5  0  0  0 
h# 96 constant iso-type
1A309F8 	 0  0  0 69 73 6F 2D 74 
1A30A00 	79 70 65 88 F0  9 A3  1 
1A30A08 	68 40 A0  1 96  0  0  0 
h# ee constant gpt-type
1A30A10 	 0  0  0 67 70 74 2D 74 
1A30A18 	79 70 65 88  8  A A3  1 
1A30A20 	68 40 A0  1 EE  0  0  0 

0 value ufs-partition
1A30A28 	 0  0 75 66 73 2D 70 61 
1A30A30 	72 74 69 74 69 6F 6E 8D 
1A30A38 	20  A A3  1 50 40 A0  1 
1A30A40 	9C  9  0  0 
0 0 instance 2value partition-name$
1A30A44 	70 61 72 74 
1A30A48 	69 74 69 6F 6E 2D 6E 61 
1A30A50 	6D 65 24 8F 3C  A A3  1 
1A30A58 	B8 FF A1  1 24  0  0  0 
0 instance value #part
1A30A60 	 0  0 23 70 61 72 74 85 
1A30A68 	58  A A3  1 C0 FE A1  1 
1A30A70 	2C  0  0  0 

0 instance value /sector  \ Set in open by calling parent's block-size method
1A30A74 	2F 73 65 63 
1A30A78 	74 6F 72 87 6C  A A3  1 
1A30A80 	C0 FE A1  1 30  0  0  0 
0 instance value sector-buf
1A30A88 	 0 73 65 63 74 6F 72 2D 
1A30A90 	62 75 66 8A 80  A A3  1 
1A30A98 	C0 FE A1  1 34  0  0  0 

0 instance value sector-offset
1A30AA0 	 0  0 73 65 63 74 6F 72 
1A30AA8 	2D 6F 66 66 73 65 74 8D 
1A30AB0 	98  A A3  1 C0 FE A1  1 
1A30AB8 	38  0  0  0 

: sector-alloc  ( -- )  /sector alloc-mem to sector-buf  ;
1A30ABC 	 0  0  0 73 
1A30AC0 	65 63 74 6F 72 2D 61 6C 
1A30AC8 	6C 6F 63 8C B4  A A3  1 
1A30AD0 	20 40 A0  1 80  A A3  1 
1A30AD8 	F0 6C A0  1 48 B8 A1  1 
1A30AE0 	98  A A3  1 58 46 A0  1 
: sector-free  ( -- )  sector-buf /sector free-mem  ;
1A30AE8 	73 65 63 74 6F 72 2D 66 
1A30AF0 	72 65 65 8B D0  A A3  1 
1A30AF8 	20 40 A0  1 98  A A3  1 
1A30B00 	80  A A3  1  8 6D A0  1 
1A30B08 	58 46 A0  1 

\ For ISO-9660 CD-ROMs, ISO-9660 flash or hard drives, and GPT
: read-hw-sector  ( sector# -- )
1A30B0C 	 0 72 65 61 
1A30B10 	64 2D 68 77 2D 73 65 63 
1A30B18 	74 6F 72 8E F8  A A3  1 
1A30B20 	20 40 A0  1 
   sector-offset +  /sector um*  " seek" $call-parent  abort" Seek failed"
1A30B24 	B4  A A3  1 
1A30B28 	 4 45 A0  1 80  A A3  1 
1A30B30 	50 5D A0  1 9C 53 A0  1 
1A30B38 	 4 73 65 65 6B  0  0  0 
1A30B40 	DC 31 A2  1  8 81 A0  1 
1A30B48 	 B 53 65 65 6B 20 66 61 
1A30B50 	69 6C 65 64  0  0  0  0 
   sector-buf /sector  " read" $call-parent  /sector <> abort" Read failed"
1A30B58 	98  A A3  1 80  A A3  1 
1A30B60 	9C 53 A0  1  4 72 65 61 
1A30B68 	64  0  0  0 DC 31 A2  1 
1A30B70 	80  A A3  1 44 48 A0  1 
1A30B78 	 8 81 A0  1  B 52 65 61 
1A30B80 	64 20 66 61 69 6C 65 64 
1A30B88 	 0  0  0  0 
;
1A30B8C 	58 46 A0  1 
\ For everything else
: read-sector  ( sector# -- )
1A30B90 	72 65 61 64 2D 73 65 63 
1A30B98 	74 6F 72 8B 20  B A3  1 
1A30BA0 	20 40 A0  1 
   sector-offset +  h# 200 um*  " seek" $call-parent  abort" Seek failed"
1A30BA4 	B4  A A3  1 
1A30BA8 	 4 45 A0  1 58 41 A0  1 
1A30BB0 	 0  2  0  0 50 5D A0  1 
1A30BB8 	9C 53 A0  1  4 73 65 65 
1A30BC0 	6B  0  0  0 DC 31 A2  1 
1A30BC8 	 8 81 A0  1  B 53 65 65 
1A30BD0 	6B 20 66 61 69 6C 65 64 
1A30BD8 	 0  0  0  0 
   sector-buf h# 200  " read" $call-parent  h# 200 <> abort" Read failed"
1A30BDC 	98  A A3  1 
1A30BE0 	58 41 A0  1  0  2  0  0 
1A30BE8 	9C 53 A0  1  4 72 65 61 
1A30BF0 	64  0  0  0 DC 31 A2  1 
1A30BF8 	58 41 A0  1  0  2  0  0 
1A30C00 	44 48 A0  1  8 81 A0  1 
1A30C08 	 B 52 65 61 64 20 66 61 
1A30C10 	69 6C 65 64  0  0  0  0 
;
1A30C18 	58 46 A0  1 

OpenFirmware/ofw/disklabel/common.fth_AL	2B8 1A30C1C purpose: FDisk partition map decoder

\ Returns true if the sector buffer appears to contain a BIOS Parameter Block,
\ which signifies the beginning of a DOS "FAT" file system.
: fat?  ( -- flag )
1A30C1C 	 0  0  0 66 
1A30C20 	61 74 3F 84 A0  B A3  1 
1A30C28 	20 40 A0  1 
   sector-buf d# 11 +  le-w@              ( bps )
1A30C2C 	98  A A3  1 
1A30C30 	58 41 A0  1  B  0  0  0 
1A30C38 	 4 45 A0  1 80 4C A0  1 
   dup  dup 1- and 0=                  ( bps power-of-2? )
1A30C40 	40 49 A0  1 40 49 A0  1 
1A30C48 	54 4B A0  1 5C 44 A0  1 
1A30C50 	24 47 A0  1 
   swap  d# 256  d# 4096 between  and  ( bps-ok? )
1A30C54 	68 49 A0  1 
1A30C58 	58 41 A0  1  0  1  0  0 
1A30C60 	58 41 A0  1  0 10  0  0 
1A30C68 	D8 70 A0  1 5C 44 A0  1 
   sector-buf d# 16 + c@ 1 2 between and  ( flag )  \ #FATS ok?
1A30C70 	98  A A3  1 58 41 A0  1 
1A30C78 	10  0  0  0  4 45 A0  1 
1A30C80 	C4 4C A0  1 80 6F A0  1 
1A30C88 	90 6F A0  1 D8 70 A0  1 
1A30C90 	5C 44 A0  1 
;
1A30C94 	58 46 A0  1 

\ This is a lame check to see if there might be a partition map entry.
\ It is for the case where the disk has a valid BPB in sector 0, but
\ also has a partition that doesn't start at 0.  Thit is a bogus layout,
\ but we need to handle it anyway, because people often screw up when
\ using fdisk and mkdosfs under Linux.  It is too easy to run mkdosfs on
\ the overall disk (not the partition).
: unpartitioned?  ( -- flag )
1A30C98 	 0 75 6E 70 61 72 74 69 
1A30CA0 	74 69 6F 6E 65 64 3F 8E 
1A30CA8 	28  C A3  1 20 40 A0  1 
   \ In partition maps, the status byte is 0 (not bootable) or 80 (bootable)
   sector-buf h# 1be + c@  h# 7f and  0<>     ( unpartitioned? )
1A30CB0 	98  A A3  1 58 41 A0  1 
1A30CB8 	BE  1  0  0  4 45 A0  1 
1A30CC0 	C4 4C A0  1 58 41 A0  1 
1A30CC8 	7F  0  0  0 5C 44 A0  1 
1A30CD0 	44 47 A0  1 
   \ and the end of the sector contains a signature
   sector-buf h# 1fe + le-w@ h# aa55 <>  or   ( unpartitioned?' )
1A30CD4 	98  A A3  1 
1A30CD8 	58 41 A0  1 FE  1  0  0 
1A30CE0 	 4 45 A0  1 80 4C A0  1 
1A30CE8 	58 41 A0  1 55 AA  0  0 
1A30CF0 	44 48 A0  1 70 44 A0  1 
   \ and the first partition entry has a non0 starting sector number
   sector-buf h# 1c6 + le-l@ 0=  or           ( unpartitioned?' )
1A30CF8 	98  A A3  1 58 41 A0  1 
1A30D00 	C6  1  0  0  4 45 A0  1 
1A30D08 	4C 4C A0  1 24 47 A0  1 
1A30D10 	70 44 A0  1 
;
1A30D14 	58 46 A0  1 

: ptable-bounds  ( -- end start )  sector-buf  h# 1be +  h# 40  bounds  ;
1A30D18 	 0  0 70 74 61 62 6C 65 
1A30D20 	2D 62 6F 75 6E 64 73 8D 
1A30D28 	AC  C A3  1 20 40 A0  1 
1A30D30 	98  A A3  1 58 41 A0  1 
1A30D38 	BE  1  0  0  4 45 A0  1 
1A30D40 	58 41 A0  1 40  0  0  0 
1A30D48 	F0 6D A0  1 58 46 A0  1 
: ptable-sum  ( -- n )   0  ptable-bounds  do  i c@ +  loop  ;
1A30D50 	 0 70 74 61 62 6C 65 2D 
1A30D58 	73 75 6D 8A 2C  D A3  1 
1A30D60 	20 40 A0  1 70 6F A0  1 
1A30D68 	2C  D A3  1 88 42 A0  1 
1A30D70 	18  0  0  0 B4 42 A0  1 
1A30D78 	C4 4C A0  1  4 45 A0  1 
1A30D80 	F8 41 A0  1 F0 FF FF FF 
1A30D88 	58 46 A0  1 
: fdisk?  ( -- flag )
1A30D8C 	 0 66 64 69 
1A30D90 	73 6B 3F 86 60  D A3  1 
1A30D98 	20 40 A0  1 
   sector-buf h# 1fe + le-w@  h# aa55  <>  if  false exit  then
1A30D9C 	98  A A3  1 
1A30DA0 	58 41 A0  1 FE  1  0  0 
1A30DA8 	 4 45 A0  1 80 4C A0  1 
1A30DB0 	58 41 A0  1 55 AA  0  0 
1A30DB8 	44 48 A0  1 DC 41 A0  1 
1A30DC0 	 C  0  0  0 18 70 A0  1 
1A30DC8 	40 46 A0  1 

   \ If the partition table area is all zero, then it's not a partition table
   ptable-sum     ( sum )
1A30DCC 	60  D A3  1 
   0=  if  false exit  then
1A30DD0 	24 47 A0  1 DC 41 A0  1 
1A30DD8 	 C  0  0  0 18 70 A0  1 
1A30DE0 	40 46 A0  1 

   \ Look for at least one recognizable partition type code
   ptable-bounds  do
1A30DE4 	2C  D A3  1 
1A30DE8 	88 42 A0  1 14  1  0  0 
      i 4 + c@                                        ( type )
1A30DF0 	B4 42 A0  1 B0 6F A0  1 
1A30DF8 	 4 45 A0  1 C4 4C A0  1 
      dup 1 =                   \ FAT12
1A30E00 	40 49 A0  1 80 6F A0  1 
1A30E08 	24 48 A0  1 
      over 4 7 between or       \ 4: FAT16<32M  5: Extended 6: FAT16>32M 7: NTFS
1A30E0C 	54 49 A0  1 
1A30E10 	B0 6F A0  1 E0 6F A0  1 
1A30E18 	D8 70 A0  1 70 44 A0  1 
      over h#  b =     or	\ FAT-32
1A30E20 	54 49 A0  1 58 41 A0  1 
1A30E28 	 B  0  0  0 24 48 A0  1 
1A30E30 	70 44 A0  1 
      over h#  c =     or	\ FAT-32
1A30E34 	54 49 A0  1 
1A30E38 	58 41 A0  1  C  0  0  0 
1A30E40 	24 48 A0  1 70 44 A0  1 
      over h#  e =     or	\ FAT-16 LBA
1A30E48 	54 49 A0  1 58 41 A0  1 
1A30E50 	 E  0  0  0 24 48 A0  1 
1A30E58 	70 44 A0  1 
      over h#  f =     or	\ Extended LBA
1A30E5C 	54 49 A0  1 
1A30E60 	58 41 A0  1  F  0  0  0 
1A30E68 	24 48 A0  1 70 44 A0  1 
      over h# 41 =     or       \ PowerPC PreP
1A30E70 	54 49 A0  1 58 41 A0  1 
1A30E78 	41  0  0  0 24 48 A0  1 
1A30E80 	70 44 A0  1 
      over iso-type =  or       \ ISO9660
1A30E84 	54 49 A0  1 
1A30E88 	 8  A A3  1 24 48 A0  1 
1A30E90 	70 44 A0  1 
      over minix-type =  or     \ Minix
1A30E94 	54 49 A0  1 
1A30E98 	C0  9 A3  1 24 48 A0  1 
1A30EA0 	70 44 A0  1 
      over ufs-type =  or       \ Unix file system
1A30EA4 	54 49 A0  1 
1A30EA8 	F0  9 A3  1 24 48 A0  1 
1A30EB0 	70 44 A0  1 
      swap ext2fs-type =  or    \ Linux ext2/3, reiser, etc  ( recognized? )
1A30EB4 	68 49 A0  1 
1A30EB8 	D8  9 A3  1 24 48 A0  1 
1A30EC0 	70 44 A0  1 
      if  i 4 + c@ to partition-type true unloop exit  then
1A30EC4 	DC 41 A0  1 
1A30EC8 	28  0  0  0 B4 42 A0  1 
1A30ED0 	B0 6F A0  1  4 45 A0  1 
1A30ED8 	C4 4C A0  1 48 B8 A1  1 
1A30EE0 	A8  9 A3  1  4 70 A0  1 
1A30EE8 	3C 42 A0  1 40 46 A0  1 
   h# 10 +loop
1A30EF0 	58 41 A0  1 10  0  0  0 
1A30EF8 	1C 42 A0  1 F4 FE FF FF 
   false
1A30F00 	18 70 A0  1 
;
1A30F04 	58 46 A0  1 
\ ??? n,s,b,t means #sectors start-sector boot-indicator type
\ type: 0 empty, 1 12-bit FAT, 4 16-bit FAT, 5 extended, 6 over 32M
\            ... b FAT 32, c FAT 32 LBA, e FAT-16 LBA, f extended LBA
\ boot-indicator: 80 bootable

: process-ptable  ( -- true | n,s,b,t4 n,s,b,t3 n,s,b,t2 n,s,b,t1 false )
1A30F08 	 0 70 72 6F 63 65 73 73 
1A30F10 	2D 70 74 61 62 6C 65 8E 
1A30F18 	98  D A3  1 20 40 A0  1 
   sector-buf h# 1fe + le-w@  h# aa55  <>  if  true exit  then
1A30F20 	98  A A3  1 58 41 A0  1 
1A30F28 	FE  1  0  0  4 45 A0  1 
1A30F30 	80 4C A0  1 58 41 A0  1 
1A30F38 	55 AA  0  0 44 48 A0  1 
1A30F40 	DC 41 A0  1  C  0  0  0 
1A30F48 	 4 70 A0  1 40 46 A0  1 

   \ Process a real partition table
   sector-buf h# 1ee +  h# -30  bounds  do
1A30F50 	98  A A3  1 58 41 A0  1 
1A30F58 	EE  1  0  0  4 45 A0  1 
1A30F60 	58 41 A0  1 D0 FF FF FF 
1A30F68 	F0 6D A0  1 88 42 A0  1 
1A30F70 	50  0  0  0 
      i d# 12 + le-l@  i 8 + le-l@  i c@  i 4 + c@
1A30F74 	B4 42 A0  1 
1A30F78 	58 41 A0  1  C  0  0  0 
1A30F80 	 4 45 A0  1 4C 4C A0  1 
1A30F88 	B4 42 A0  1 F0 6F A0  1 
1A30F90 	 4 45 A0  1 4C 4C A0  1 
1A30F98 	B4 42 A0  1 C4 4C A0  1 
1A30FA0 	B4 42 A0  1 B0 6F A0  1 
1A30FA8 	 4 45 A0  1 C4 4C A0  1 
   h# -10 +loop
1A30FB0 	58 41 A0  1 F0 FF FF FF 
1A30FB8 	1C 42 A0  1 B8 FF FF FF 
   false
1A30FC0 	18 70 A0  1 
;
1A30FC4 	58 46 A0  1 

\ (find-partition) scans ordinary and extended partitions looking for one that
\ matches a given criterion.

0 instance value extended-offset
1A30FC8 	65 78 74 65 6E 64 65 64 
1A30FD0 	2D 6F 66 66 73 65 74 8F 
1A30FD8 	1C  F A3  1 C0 FE A1  1 
1A30FE0 	3C  0  0  0 
false value found?
1A30FE4 	 0 66 6F 75 
1A30FE8 	6E 64 3F 86 DC  F A3  1 
1A30FF0 	50 40 A0  1 A0  9  0  0 
defer suitable?  ( b t -- b t flag )
1A30FF8 	 0  0 73 75 69 74 61 62 
1A31000 	6C 65 3F 89 F0  F A3  1 
1A31008 	5C 40 A0  1 A4  9  0  0 

: (find-partition  ( sector-offset -- not-found? )
1A31010 	28 66 69 6E 64 2D 70 61 
1A31018 	72 74 69 74 69 6F 6E 8F 
1A31020 	 8 10 A3  1 20 40 A0  1 
   >r process-ptable  if  r> drop false exit  then  r>  ( n,s,b,t*4 sector-offset )
1A31028 	BC 45 A0  1 1C  F A3  1 
1A31030 	DC 41 A0  1 14  0  0  0 
1A31038 	D0 45 A0  1 30 49 A0  1 
1A31040 	18 70 A0  1 40 46 A0  1 
1A31048 	D0 45 A0  1 

   4 0 do			( n,s,b,tN ... n,s,b,t1 sector-offset )
1A3104C 	B0 6F A0  1 
1A31050 	70 6F A0  1 88 42 A0  1 
1A31058 	2C  1  0  0 
      >r						( ... n,s,b,t )
1A3105C 	BC 45 A0  1 
      found?  if		\ partition was found	( ... n,s,b,t )
1A31060 	F0  F A3  1 DC 41 A0  1 
1A31068 	14  0  0  0 
         2drop 2drop					( ... )
1A3106C 	AC 49 A0  1 
1A31070 	AC 49 A0  1 
      else						( ... n,s,b,t )
1A31074 	C8 41 A0  1 
1A31078 	 0  1  0  0 
         ?dup 0=  if					( ... n,s,b )
1A3107C 	B4 70 A0  1 
1A31080 	24 47 A0  1 DC 41 A0  1 
1A31088 	10  0  0  0 
	    \ empty, skip it.
	    3drop					( ... )
1A3108C 	90 52 A0  1 
         else						( ... n,s,b,t )
1A31090 	C8 41 A0  1 E4  0  0  0 
            dup 5 = over h# f = or  if   \ extended partition          ( ... n,s,b,t )
1A31098 	40 49 A0  1 C0 6F A0  1 
1A310A0 	24 48 A0  1 54 49 A0  1 
1A310A8 	58 41 A0  1  F  0  0  0 
1A310B0 	24 48 A0  1 70 44 A0  1 
1A310B8 	DC 41 A0  1 64  0  0  0 
               2drop nip                                ( ... s )
1A310C0 	AC 49 A0  1 FC 46 A0  1 
               extended-offset dup 0=  if  over to extended-offset  then
1A310C8 	DC  F A3  1 40 49 A0  1 
1A310D0 	24 47 A0  1 DC 41 A0  1 
1A310D8 	10  0  0  0 54 49 A0  1 
1A310E0 	48 B8 A1  1 DC  F A3  1 
               + dup                                    ( ... es )
1A310E8 	 4 45 A0  1 40 49 A0  1 
               sector-buf >r sector-alloc               ( ... es )
1A310F0 	98  A A3  1 BC 45 A0  1 
1A310F8 	D0  A A3  1 
               read-sector recurse drop                 ( ... )
1A310FC 	A0  B A3  1 
1A31100 	24 10 A3  1 30 49 A0  1 
               sector-free r> to sector-buf             ( ... )
1A31108 	F8  A A3  1 D0 45 A0  1 
1A31110 	48 B8 A1  1 98  A A3  1 
            else		\ Ordinary partition	( ... n,s,b,t )
1A31118 	C8 41 A0  1 5C  0  0  0 
               suitable?  if                		( ... n,s,b,t )
1A31120 	 8 10 A3  1 DC 41 A0  1 
1A31128 	4C  0  0  0 
                  to partition-type drop		( ... n,s )
1A3112C 	48 B8 A1  1 
1A31130 	A8  9 A3  1 30 49 A0  1 
                  r@ + to sector-offset			( ... n )
1A31138 	E4 45 A0  1  4 45 A0  1 
1A31140 	48 B8 A1  1 B4  A A3  1 
                  /sector um* to size-high to size-low	( ... )
1A31148 	80  A A3  1 50 5D A0  1 
1A31150 	48 B8 A1  1 8C  9 A3  1 
1A31158 	48 B8 A1  1 74  9 A3  1 
                  true to found?			( ... )
1A31160 	 4 70 A0  1 B8 40 A0  1 
1A31168 	F0  F A3  1 
               else					( ... n,s,b,t )
1A3116C 	C8 41 A0  1 
1A31170 	 8  0  0  0 
                  4drop					( ... )
1A31174 	38 53 A0  1 
               then					( ... )
            then					( ... )
         then						( ... )
      then						( ... )
      r>						( ... sector-offset )
1A31178 	D0 45 A0  1 
   loop
1A3117C 	F8 41 A0  1 
1A31180 	DC FE FF FF 
   drop found? 0=
1A31184 	30 49 A0  1 
1A31188 	F0  F A3  1 24 47 A0  1 
;
1A31190 	58 46 A0  1 
: (find-partition)  ( sector-offset criterion-xt -- not-found? )
1A31194 	 0  0  0 28 
1A31198 	66 69 6E 64 2D 70 61 72 
1A311A0 	74 69 74 69 6F 6E 29 90 
1A311A8 	24 10 A3  1 20 40 A0  1 
   to suitable?  false to found?  (find-partition
1A311B0 	98 40 A0  1  8 10 A3  1 
1A311B8 	18 70 A0  1 B8 40 A0  1 
1A311C0 	F0  F A3  1 24 10 A3  1 
;
1A311C8 	58 46 A0  1 

\ These are some criteria used for finding specific partitions

\ Matches UFS partitions
: is-ufs?  ( type -- type flag )  dup ufs-type =  ;
1A311CC 	69 73 2D 75 
1A311D0 	66 73 3F 87 AC 11 A3  1 
1A311D8 	20 40 A0  1 40 49 A0  1 
1A311E0 	F0  9 A3  1 24 48 A0  1 
1A311E8 	58 46 A0  1 

\ Matches partitions with the bootable flag set
: bootable?  ( boot? type -- boot? type flag )  over h# 80 =  ;
1A311EC 	 0  0 62 6F 
1A311F0 	6F 74 61 62 6C 65 3F 89 
1A311F8 	D8 11 A3  1 20 40 A0  1 
1A31200 	54 49 A0  1 58 41 A0  1 
1A31208 	80  0  0  0 24 48 A0  1 
1A31210 	58 46 A0  1 

\ Kludge for Linux: bootable flag is not always set, accept ext2fs-type
\ : bootable?  ( boot? type -- boot? type flag )
\    over h# 80 =  over h# 83 = or
\ ;

\ Matches the Nth partition, where N is initially stored in the value #part
: nth?  ( -- flag )  #part 1- dup to #part  0=  ;
1A31214 	 0  0  0 6E 
1A31218 	74 68 3F 84 FC 11 A3  1 
1A31220 	20 40 A0  1 6C  A A3  1 
1A31228 	54 4B A0  1 40 49 A0  1 
1A31230 	48 B8 A1  1 6C  A A3  1 
1A31238 	24 47 A0  1 58 46 A0  1 

: find-partition  ( sector-offset -- )
1A31240 	 0 66 69 6E 64 2D 70 61 
1A31248 	72 74 69 74 69 6F 6E 8E 
1A31250 	20 12 A3  1 20 40 A0  1 
   0  ['] nth? (find-partition) abort" No such partition"
1A31258 	70 6F A0  1 60 53 A0  1 
1A31260 	20 12 A3  1 AC 11 A3  1 
1A31268 	 8 81 A0  1 11 4E 6F 20 
1A31270 	73 75 63 68 20 70 61 72 
1A31278 	74 69 74 69 6F 6E  0  0 
;
1A31280 	58 46 A0  1 

OpenFirmware/ofw/fs/fatfs/partition.fth_AL	668 1A31284 : gpt?  ( -- flag )
1A3129C 	 0  0  0 67 
1A312A0 	70 74 3F 84 90 12 A3  1 
1A312A8 	20 40 A0  1 
   sector-buf h# 1fe + le-w@  h# aa55  <>  if  false exit  then
1A312AC 	98  A A3  1 
1A312B0 	58 41 A0  1 FE  1  0  0 
1A312B8 	 4 45 A0  1 80 4C A0  1 
1A312C0 	58 41 A0  1 55 AA  0  0 
1A312C8 	44 48 A0  1 DC 41 A0  1 
1A312D0 	 C  0  0  0 18 70 A0  1 
1A312D8 	40 46 A0  1 
   sector-buf h# 1c2 + c@ gpt-type =
1A312DC 	98  A A3  1 
1A312E0 	58 41 A0  1 C2  1  0  0 
1A312E8 	 4 45 A0  1 C4 4C A0  1 
1A312F0 	20  A A3  1 24 48 A0  1 
;
1A312F8 	58 46 A0  1 

\ Tasks:
\ Choose a partition based on part# and partition-name$
\ Set sector-offset, size-low, size-high, and partition-type

-1 value the-sector
1A312FC 	 0 74 68 65 
1A31300 	2D 73 65 63 74 6F 72 8A 
1A31308 	A8 12 A3  1 50 40 A0  1 
1A31310 	A8  9  0  0 
: get-gpt-info  ( -- error? )
1A31314 	 0  0  0 67 
1A31318 	65 74 2D 67 70 74 2D 69 
1A31320 	6E 66 6F 8C  C 13 A3  1 
1A31328 	20 40 A0  1 
   1 read-hw-sector            ( )
1A3132C 	80 6F A0  1 
1A31330 	20  B A3  1 
   sector-buf gpt-magic comp  if  true exit  then
1A31334 	98  A A3  1 
1A31338 	B0  8 A3  1 38 52 A0  1 
1A31340 	DC 41 A0  1  C  0  0  0 
1A31348 	 4 70 A0  1 40 46 A0  1 
   \ XXX should verify CRC
   sector-buf d# 72 + le-x@ to partition-lba0
1A31350 	98  A A3  1 58 41 A0  1 
1A31358 	48  0  0  0  4 45 A0  1 
1A31360 	BC  7 A3  1 48 B8 A1  1 
1A31368 	20  8 A3  1 
   sector-buf d# 80 + le-l@ to #gpt-partitions
1A3136C 	98  A A3  1 
1A31370 	58 41 A0  1 50  0  0  0 
1A31378 	 4 45 A0  1 4C 4C A0  1 
1A31380 	B8 40 A0  1 EC  7 A3  1 
   sector-buf d# 84 + le-l@ to /gpt-entry
1A31388 	98  A A3  1 58 41 A0  1 
1A31390 	54  0  0  0  4 45 A0  1 
1A31398 	4C 4C A0  1 B8 40 A0  1 
1A313A0 	 4  8 A3  1 
   -1 to the-sector
1A313A4 	58 41 A0  1 
1A313A8 	FF FF FF FF B8 40 A0  1 
1A313B0 	 C 13 A3  1 
   false
1A313B4 	18 70 A0  1 
;
1A313B8 	58 46 A0  1 
: read-gpt-sector  ( sector# -- )
1A313BC 	72 65 61 64 
1A313C0 	2D 67 70 74 2D 73 65 63 
1A313C8 	74 6F 72 8F 28 13 A3  1 
1A313D0 	20 40 A0  1 
   dup the-sector =  if  drop exit  then      ( sector# )
1A313D4 	40 49 A0  1 
1A313D8 	 C 13 A3  1 24 48 A0  1 
1A313E0 	DC 41 A0  1  C  0  0  0 
1A313E8 	30 49 A0  1 40 46 A0  1 
   dup to the-sector                          ( sector# )
1A313F0 	40 49 A0  1 B8 40 A0  1 
1A313F8 	 C 13 A3  1 
   read-hw-sector
1A313FC 	20  B A3  1 
;
1A31400 	58 46 A0  1 

: select-gpt-partition  ( adr -- )
1A31404 	 0  0  0 73 
1A31408 	65 6C 65 63 74 2D 67 70 
1A31410 	74 2D 70 61 72 74 69 74 
1A31418 	69 6F 6E 94 D0 13 A3  1 
1A31420 	20 40 A0  1 
   dup gpt-blk0 x>u to sector-offset                 ( adr )
1A31424 	40 49 A0  1 
1A31428 	D8  8 A3  1 30 49 A0  1 
1A31430 	48 B8 A1  1 B4  A A3  1 
   gpt-#blks /sector xu*d to size-high  to size-low  ( )
1A31438 	 0  9 A3  1 80  A A3  1 
1A31440 	94  8 A3  1 48 B8 A1  1 
1A31448 	8C  9 A3  1 48 B8 A1  1 
1A31450 	74  9 A3  1 
;
1A31454 	58 46 A0  1 

: partition-name=  ( adr -- flag )
1A31458 	70 61 72 74 69 74 69 6F 
1A31460 	6E 2D 6E 61 6D 65 3D 8F 
1A31468 	20 14 A3  1 20 40 A0  1 
   d# 56 +                        ( utf16-name-adr )
1A31470 	58 41 A0  1 38  0  0  0 
1A31478 	 4 45 A0  1 
   partition-name$  bounds  ?do   ( utf16-name-adr )
1A3147C 	58  A A3  1 
1A31480 	F0 6D A0  1 50 42 A0  1 
1A31488 	3C  0  0  0 
      dup w@  i c@  <>  if        ( utf16-name-adr )
1A3148C 	40 49 A0  1 
1A31490 	94 4C A0  1 B4 42 A0  1 
1A31498 	C4 4C A0  1 44 48 A0  1 
1A314A0 	DC 41 A0  1 14  0  0  0 
         drop false unloop exit   ( -- false )
1A314A8 	30 49 A0  1 18 70 A0  1 
1A314B0 	3C 42 A0  1 40 46 A0  1 
      then                        ( utf16-name-adr )
      wa1+                        ( utf16-name-adr' )
1A314B8 	A0 50 A0  1 
   loop                           ( utf16-name-adr )
1A314BC 	F8 41 A0  1 
1A314C0 	CC FF FF FF 
   w@ 0=                          ( flag )
1A314C4 	94 4C A0  1 
1A314C8 	24 47 A0  1 
;
1A314CC 	58 46 A0  1 

: >gpt-entry  ( n -- adr )
1A314D0 	 0 3E 67 70 74 2D 65 6E 
1A314D8 	74 72 79 8A 6C 14 A3  1 
1A314E0 	20 40 A0  1 
   /gpt-entry *             ( offset )
1A314E4 	 4  8 A3  1 
1A314E8 	1C 5F A0  1 
   /sector /mod             ( rem quot )
1A314EC 	80  A A3  1 
1A314F0 	50 5F A0  1 
   partition-lba0 x>u +     ( rem sector# )
1A314F4 	20  8 A3  1 
1A314F8 	30 49 A0  1  4 45 A0  1 
   read-gpt-sector          ( rem )
1A31500 	D0 13 A3  1 
   sector-buf +             ( adr )
1A31504 	98  A A3  1 
1A31508 	 4 45 A0  1 
;
1A3150C 	58 46 A0  1 
: nth-gpt-partition  ( n -- )
1A31510 	 0  0 6E 74 68 2D 67 70 
1A31518 	74 2D 70 61 72 74 69 74 
1A31520 	69 6F 6E 91 E0 14 A3  1 
1A31528 	20 40 A0  1 
   1- >gpt-entry select-gpt-partition     ( )
1A3152C 	54 4B A0  1 
1A31530 	E0 14 A3  1 20 14 A3  1 
;
1A31538 	58 46 A0  1 
: gpt-active?  ( adr -- flag )  d# 16 0 bskip  0<>  ;
1A3153C 	67 70 74 2D 
1A31540 	61 63 74 69 76 65 3F 8B 
1A31548 	28 15 A3  1 20 40 A0  1 
1A31550 	58 41 A0  1 10  0  0  0 
1A31558 	70 6F A0  1 F4 4E A0  1 
1A31560 	44 47 A0  1 58 46 A0  1 

: named-gpt-partition  ( -- )
1A31568 	6E 61 6D 65 64 2D 67 70 
1A31570 	74 2D 70 61 72 74 69 74 
1A31578 	69 6F 6E 93 4C 15 A3  1 
1A31580 	20 40 A0  1 
   #gpt-partitions 0  ?do
1A31584 	EC  7 A3  1 
1A31588 	70 6F A0  1 50 42 A0  1 
1A31590 	40  0  0  0 
      i >gpt-entry                ( adr )
1A31594 	B4 42 A0  1 
1A31598 	E0 14 A3  1 
      dup gpt-active?  if         ( adr )
1A3159C 	40 49 A0  1 
1A315A0 	4C 15 A3  1 DC 41 A0  1 
1A315A8 	1C  0  0  0 
         dup partition-name=  if  ( adr )
1A315AC 	40 49 A0  1 
1A315B0 	6C 14 A3  1 DC 41 A0  1 
1A315B8 	 C  0  0  0 
            select-gpt-partition  ( )
1A315BC 	20 14 A3  1 
	    leave                 ( )
1A315C0 	18 43 A0  1 
         then                     ( adr )
      then                        ( adr )
      drop                        ( )
1A315C4 	30 49 A0  1 
   loop                           ( )
1A315C8 	F8 41 A0  1 C8 FF FF FF 
;
1A315D0 	58 46 A0  1 
: gpt-map  ( -- )
1A315D4 	67 70 74 2D 
1A315D8 	6D 61 70 87 80 15 A3  1 
1A315E0 	20 40 A0  1 
   get-gpt-info  abort" Invalid GUID Partition Table"
1A315E4 	28 13 A3  1 
1A315E8 	 8 81 A0  1 1C 49 6E 76 
1A315F0 	61 6C 69 64 20 47 55 49 
1A315F8 	44 20 50 61 72 74 69 74 
1A31600 	69 6F 6E 20 54 61 62 6C 
1A31608 	65  0  0  0 
   #part 1 >=  if
1A3160C 	6C  A A3  1 
1A31610 	80 6F A0  1 EC 48 A0  1 
1A31618 	DC 41 A0  1 14  0  0  0 
      #part nth-gpt-partition
1A31620 	6C  A A3  1 28 15 A3  1 
   else
1A31628 	C8 41 A0  1  8  0  0  0 
      named-gpt-partition
1A31630 	80 15 A3  1 
   then
;
1A31634 	58 46 A0  1 

OpenFirmware/ofw/disklabel/gpt.fth_AL	39C 1A31638 purpose: disk-label package

headers

: offset  ( d1 -- d2 )  sector-offset /sector um*  d+  ;
1A31638 	 0 6F 66 66 73 65 74 86 
1A31640 	E0 15 A3  1 20 40 A0  1 
1A31648 	B4  A A3  1 80  A A3  1 
1A31650 	50 5D A0  1 E0 5D A0  1 
1A31658 	58 46 A0  1 

headerless

\ Recognizers for various filesystem types

: dropin?  ( -- flag )  sector-buf  " OBMD" comp 0=  ;
1A3165C 	64 72 6F 70 
1A31660 	69 6E 3F 87 44 16 A3  1 
1A31668 	20 40 A0  1 98  A A3  1 
1A31670 	9C 53 A0  1  4 4F 42 4D 
1A31678 	44  0  0  0 38 52 A0  1 
1A31680 	24 47 A0  1 58 46 A0  1 
: zip?  ( -- flag )  sector-buf  " PK" comp 0=  ;
1A31688 	 0  0  0 7A 69 70 3F 84 
1A31690 	68 16 A3  1 20 40 A0  1 
1A31698 	98  A A3  1 9C 53 A0  1 
1A316A0 	 2 50 4B  0 38 52 A0  1 
1A316A8 	24 47 A0  1 58 46 A0  1 


0 0 2value filename
1A316B0 	 0  0  0 66 69 6C 65 6E 
1A316B8 	61 6D 65 88 94 16 A3  1 
1A316C0 	24 BA A1  1 AC  9  0  0 

\ Sets size-high and size-low to the total size of the disk in bytes,
\ as determined by the parent's "#blocks" and "block-size" methods.
: get-disk-size  ( -- )
1A316C8 	 0  0 67 65 74 2D 64 69 
1A316D0 	73 6B 2D 73 69 7A 65 8D 
1A316D8 	C0 16 A3  1 20 40 A0  1 
   " #blocks" ['] $call-parent catch  if
1A316E0 	9C 53 A0  1  7 23 62 6C 
1A316E8 	6F 63 6B 73  0  0  0  0 
1A316F0 	60 53 A0  1 DC 31 A2  1 
1A316F8 	14 7F A0  1 DC 41 A0  1 
1A31700 	10  0  0  0 
      2drop
1A31704 	AC 49 A0  1 
   else   ( #blocks )
1A31708 	C8 41 A0  1 2C  0  0  0 
      " block-size" $call-parent  um*
1A31710 	9C 53 A0  1  A 62 6C 6F 
1A31718 	63 6B 2D 73 69 7A 65  0 
1A31720 	DC 31 A2  1 50 5D A0  1 
      to size-high  to size-low
1A31728 	48 B8 A1  1 8C  9 A3  1 
1A31730 	48 B8 A1  1 74  9 A3  1 
   then
;
1A31738 	58 46 A0  1 

\ It would be nice if this word could be in partition.fth, but it can't
\ because of interactions between FDISK and UFS partition maps.
: fdisk-map  ( -- )
1A3173C 	 0  0 66 64 
1A31740 	69 73 6B 2D 6D 61 70 89 
1A31748 	DC 16 A3  1 20 40 A0  1 
   0 to extended-offset
1A31750 	70 6F A0  1 48 B8 A1  1 
1A31758 	DC  F A3  1 
   #part 0>  if
1A3175C 	6C  A A3  1 
1A31760 	A4 47 A0  1 DC 41 A0  1 
1A31768 	10  0  0  0 
      \ An explicit partition number was specified.  Select that partition.
      find-partition
1A3176C 	54 12 A3  1 
   else		\ Use default FDISK partition
1A31770 	C8 41 A0  1 68  0  0  0 

      \ If the arguments specified a partition letter (a..h), try to find
      \ an FDISK partition that contains a UFS partition map, then select
      \ the specified sub-partition.
      ufs-partition  if
1A31778 	3C  A A3  1 DC 41 A0  1 
1A31780 	34  0  0  0 
         0 ['] is-ufs?  (find-partition) abort" No UFS partition"
1A31784 	70 6F A0  1 
1A31788 	60 53 A0  1 D8 11 A3  1 
1A31790 	AC 11 A3  1  8 81 A0  1 
1A31798 	10 4E 6F 20 55 46 53 20 
1A317A0 	70 61 72 74 69 74 69 6F 
1A317A8 	6E  0  0  0 
      else
1A317AC 	C8 41 A0  1 
1A317B0 	2C  0  0  0 
         0 ['] bootable?  (find-partition)  if
1A317B4 	70 6F A0  1 
1A317B8 	60 53 A0  1 FC 11 A3  1 
1A317C0 	AC 11 A3  1 DC 41 A0  1 
1A317C8 	14  0  0  0 
            \ If no bootable partition was found, use the first one
            1 to #part  find-partition
1A317CC 	80 6F A0  1 
1A317D0 	48 B8 A1  1 6C  A A3  1 
1A317D8 	54 12 A3  1 
         then
      then
   then

[ifdef] ufs-support
   \ If the partition type is UFS and a filename is specified, select
   \ one of the UFS sub-partitions.  Otherwise use the raw partition.
   partition-type ufs-type =  if
      filename nip  if  ufs-map  then
   then
[then]
;
1A317DC 	58 46 A0  1 

: select-partition  ( -- )
1A317E0 	 0  0  0 73 65 6C 65 63 
1A317E8 	74 2D 70 61 72 74 69 74 
1A317F0 	69 6F 6E 90 4C 17 A3  1 
1A317F8 	20 40 A0  1 
   \ If parse-partition set #part to -2, it already mapped the partition
   #part -2 =  if  exit  then
1A317FC 	6C  A A3  1 
1A31800 	58 41 A0  1 FE FF FF FF 
1A31808 	24 48 A0  1 DC 41 A0  1 
1A31810 	 8  0  0  0 40 46 A0  1 

   \ Partition 0 is the raw disk, in which case we leave sector-offset at 0
   \ and avoid reading the disk.  Otherwise, we try to determine what sort
   \ of partition map the disk has, if any, and from that determine the
   \ offset to the beginning of the specified partition.
   #part 0=  if  get-disk-size exit  then
1A31818 	6C  A A3  1 24 47 A0  1 
1A31820 	DC 41 A0  1  C  0  0  0 
1A31828 	DC 16 A3  1 40 46 A0  1 
   
   \ Get the first sector into the buffer so we can examine it
   0 read-sector
1A31830 	70 6F A0  1 A0  B A3  1 

   \ If we find certain things in the first sector, we need not bother
   \ with partitions, and we ignore the partition specification
   fat? unpartitioned?  and  if  get-disk-size exit  then
1A31838 	28  C A3  1 AC  C A3  1 
1A31840 	5C 44 A0  1 DC 41 A0  1 
1A31848 	 C  0  0  0 DC 16 A3  1 
1A31850 	40 46 A0  1 
   dropin?  if  get-disk-size exit  then
1A31854 	68 16 A3  1 
1A31858 	DC 41 A0  1  C  0  0  0 
1A31860 	DC 16 A3  1 40 46 A0  1 
   zip?     if  get-disk-size exit  then
1A31868 	94 16 A3  1 DC 41 A0  1 
1A31870 	 C  0  0  0 DC 16 A3  1 
1A31878 	40 46 A0  1 

[ifdef] hfs-support
   mac-disk?  if  mac-map exit  then
[then]

   gpt?  if  gpt-map exit  then
1A3187C 	A8 12 A3  1 
1A31880 	DC 41 A0  1  C  0  0  0 
1A31888 	E0 15 A3  1 40 46 A0  1 

   fdisk?  if  fdisk-map exit  then
1A31890 	98  D A3  1 DC 41 A0  1 
1A31898 	 C  0  0  0 4C 17 A3  1 
1A318A0 	40 46 A0  1 

   \ Nothing we tried worked.
   abort
1A318A4 	28 91 A0  1 
;
1A318A8 	58 46 A0  1 

: choose-file-system  ( -- package-name$ )
1A318AC 	 0 63 68 6F 
1A318B0 	6F 73 65 2D 66 69 6C 65 
1A318B8 	2D 73 79 73 74 65 6D 92 
1A318C0 	F8 17 A3  1 20 40 A0  1 
   \ Execute found-iso-9660? (an instance value) before changing my-self !
   partition-type iso-type =  if  " iso9660-file-system" exit  then
1A318C8 	A8  9 A3  1  8  A A3  1 
1A318D0 	24 48 A0  1 DC 41 A0  1 
1A318D8 	24  0  0  0 9C 53 A0  1 
1A318E0 	13 69 73 6F 39 36 36 30 
1A318E8 	2D 66 69 6C 65 2D 73 79 
1A318F0 	73 74 65 6D  0  0  0  0 
1A318F8 	40 46 A0  1 

[ifdef] hfs-support
   hfs-partition?  if  " hfs-file-system" exit  then
   \ XXX handle boot portion of HFS partition, one of these days
   \ ( filename$ ) 2dup " %BOOT" $=  if
   \    ( change sector-offset and size.low,high ) ...
[then]

   2 read-sector
1A318FC 	90 6F A0  1 
1A31900 	A0  B A3  1 
   ext2?  if  
1A31904 	90 12 A3  1 
1A31908 	DC 41 A0  1 98  0  0  0 
      partition-type ext2fs-type <>  if
1A31910 	A8  9 A3  1 D8  9 A3  1 
1A31918 	44 48 A0  1 DC 41 A0  1 
1A31920 	68  0  0  0 
         ." Warning: Filesystem is ext2/3, but partition type is 0x"  
1A31924 	20 7C A0  1 
1A31928 	37 57 61 72 6E 69 6E 67 
1A31930 	3A 20 46 69 6C 65 73 79 
1A31938 	73 74 65 6D 20 69 73 20 
1A31940 	65 78 74 32 2F 33 2C 20 
1A31948 	62 75 74 20 70 61 72 74 
1A31950 	69 74 69 6F 6E 20 74 79 
1A31958 	70 65 20 69 73 20 30 78 
1A31960 	 0  0  0  0 
         partition-type .x ." (should be 0x83)."  cr
1A31964 	A8  9 A3  1 
1A31968 	2C  E A1  1 20 7C A0  1 
1A31970 	11 28 73 68 6F 75 6C 64 
1A31978 	20 62 65 20 30 78 38 33 
1A31980 	29 2E  0  0 80 6D A0  1 
      then
      " ext2-file-system" exit
1A31988 	9C 53 A0  1 10 65 78 74 
1A31990 	32 2D 66 69 6C 65 2D 73 
1A31998 	79 73 74 65 6D  0  0  0 
1A319A0 	40 46 A0  1 
   then

[ifdef] ufs-support
   partition-type ufs-type    =  if  " ufs-file-system"    exit  then
[then]
   partition-type minix-type  =  if  " minix-file-system"  exit  then
1A319A4 	A8  9 A3  1 
1A319A8 	C0  9 A3  1 24 48 A0  1 
1A319B0 	DC 41 A0  1 20  0  0  0 
1A319B8 	9C 53 A0  1 11 6D 69 6E 
1A319C0 	69 78 2D 66 69 6C 65 2D 
1A319C8 	73 79 73 74 65 6D  0  0 
1A319D0 	40 46 A0  1 

   0 read-sector   \ Get the first sector of the selected partition
1A319D4 	70 6F A0  1 
1A319D8 	A0  B A3  1 
   dropin?  if  " dropin-file-system" exit  then
1A319DC 	68 16 A3  1 
1A319E0 	DC 41 A0  1 20  0  0  0 
1A319E8 	9C 53 A0  1 12 64 72 6F 
1A319F0 	70 69 6E 2D 66 69 6C 65 
1A319F8 	2D 73 79 73 74 65 6D  0 
1A31A00 	40 46 A0  1 
   zip?     if  " zip-file-system"    exit  then
1A31A04 	94 16 A3  1 
1A31A08 	DC 41 A0  1 20  0  0  0 
1A31A10 	9C 53 A0  1  F 7A 69 70 
1A31A18 	2D 66 69 6C 65 2D 73 79 
1A31A20 	73 74 65 6D  0  0  0  0 
1A31A28 	40 46 A0  1 
   fat?     if
1A31A2C 	28  C A3  1 
1A31A30 	DC 41 A0  1 80  0  0  0 
      partition-type ext2fs-type =  if
1A31A38 	A8  9 A3  1 D8  9 A3  1 
1A31A40 	24 48 A0  1 DC 41 A0  1 
1A31A48 	50  0  0  0 
         ." Warning: Filesystem is FAT, but partition type is 0x83 (ext2/3)." cr
1A31A4C 	20 7C A0  1 
1A31A50 	40 57 61 72 6E 69 6E 67 
1A31A58 	3A 20 46 69 6C 65 73 79 
1A31A60 	73 74 65 6D 20 69 73 20 
1A31A68 	46 41 54 2C 20 62 75 74 
1A31A70 	20 70 61 72 74 69 74 69 
1A31A78 	6F 6E 20 74 79 70 65 20 
1A31A80 	69 73 20 30 78 38 33 20 
1A31A88 	28 65 78 74 32 2F 33 29 
1A31A90 	2E  0  0  0 80 6D A0  1 
      then
      " fat-file-system"    exit
1A31A98 	9C 53 A0  1  F 66 61 74 
1A31AA0 	2D 66 69 6C 65 2D 73 79 
1A31AA8 	73 74 65 6D  0  0  0  0 
1A31AB0 	40 46 A0  1 
   then
\ mmo   ntfs?    if  " nt-file-system"     exit  then

   ." Error: Unknown file system" cr
1A31AB4 	20 7C A0  1 
1A31AB8 	1A 45 72 72 6F 72 3A 20 
1A31AC0 	55 6E 6B 6E 6F 77 6E 20 
1A31AC8 	66 69 6C 65 20 73 79 73 
1A31AD0 	74 65 6D  0 80 6D A0  1 

   abort
1A31AD8 	28 91 A0  1 
;
1A31ADC 	58 46 A0  1 

\ If the arguments include a filename, we determine the type of filesystem
\ that the disk or partition contains and interpose a handler for that
\ type, passing it the filename.
: select-file  ( -- )
1A31AE0 	73 65 6C 65 63 74 2D 66 
1A31AE8 	69 6C 65 8B C4 18 A3  1 
1A31AF0 	20 40 A0  1 
   filename nip 0=  if  exit  then
1A31AF4 	C0 16 A3  1 
1A31AF8 	FC 46 A0  1 24 47 A0  1 
1A31B00 	DC 41 A0  1  8  0  0  0 
1A31B08 	40 46 A0  1 

   choose-file-system  find-package  0=  if  abort  then  ( phandle )
1A31B0C 	C4 18 A3  1 
1A31B10 	E0 39 A2  1 24 47 A0  1 
1A31B18 	DC 41 A0  1  8  0  0  0 
1A31B20 	28 91 A0  1 
   filename rot  interpose
1A31B24 	C0 16 A3  1 
1A31B28 	7C 49 A0  1 34 35 A2  1 
;
1A31B30 	58 46 A0  1 

\ partition$ syntax:
\ null:     use default partition
\ <digit>:  FDISK partition number
\ <letter>: UFS partition letter (a..h)
\ <digit><letter>: UFS partition embedded within FDISK partition
\ -<decimal-digits>: The last N blocks of the disk

\ partition# is one of:
\ -1, meaning the default partition, i.e. no partition was specified
\  0, meaning the raw disk
\ >0, meaning an explicit partition

\ In addition, ufs-partition is set to the UFS partition letter (a..h)
\ if the string appears to contain a letter.

: decode-partition  ( adr len -- rem$ )
1A31B34 	 0  0  0 64 
1A31B38 	65 63 6F 64 65 2D 70 61 
1A31B40 	72 74 69 74 69 6F 6E 90 
1A31B48 	F0 1A A3  1 20 40 A0  1 
\ CR ." decode-partition=<" 2DUP TYPE ." >"
   \ If the string parses as a decimal number, it's a partition# if
   \ positive or the last N blocks if negative
   2dup push-decimal $number pop-base 0= ( DUP .)  if   ( adr len n )
1A31B50 	C0 49 A0  1 48 F4 A0  1 
1A31B58 	40 FE A0  1 9C F4 A0  1 
1A31B60 	24 47 A0  1 DC 41 A0  1 
1A31B68 	80  0  0  0 
      dup 0<  if                               ( adr len n )
1A31B6C 	40 49 A0  1 
1A31B70 	64 47 A0  1 DC 41 A0  1 
1A31B78 	5C  0  0  0 
         /sector um*                           ( adr len d.partition-size )
1A31B7C 	80  A A3  1 
1A31B80 	50 5D A0  1 
         get-disk-size  size-low size-high     ( adr len d.partition-size d.disk-size )
1A31B84 	DC 16 A3  1 
1A31B88 	74  9 A3  1 8C  9 A3  1 
         2over d-  /sector um/mod nip          ( adr len d.partition-size partition-sector )
1A31B90 	D8 49 A0  1 F8 5D A0  1 
1A31B98 	80  A A3  1 7C 5D A0  1 
1A31BA0 	FC 46 A0  1 
         to sector-offset                      ( adr len d.partition-size )
1A31BA4 	48 B8 A1  1 
1A31BA8 	B4  A A3  1 
         to size-high to size-low              ( adr len )
1A31BAC 	48 B8 A1  1 
1A31BB0 	8C  9 A3  1 48 B8 A1  1 
1A31BB8 	74  9 A3  1 
         -2 to #part                           ( adr len )   \ Tell select-partition
1A31BBC 	58 41 A0  1 
1A31BC0 	FE FF FF FF 48 B8 A1  1 
1A31BC8 	6C  A A3  1 
      else                                     ( adr len n )
1A31BCC 	C8 41 A0  1 
1A31BD0 	 C  0  0  0 
         to #part                              ( adr len )
1A31BD4 	48 B8 A1  1 
1A31BD8 	6C  A A3  1 
      then                                     ( adr len )
      drop 0                                   ( adr 0 )
1A31BDC 	30 49 A0  1 
1A31BE0 	70 6F A0  1 
      exit                                     ( rem$ -- )
1A31BE4 	40 46 A0  1 
   then                                      ( adr len )

   \ If the first character of the string is a decimal number, it's a partition #,
   \ possibly followed by UFS partition letter
   over c@  ascii 0 ascii 9 between  if      ( adr len )
1A31BE8 	54 49 A0  1 C4 4C A0  1 
1A31BF0 	58 41 A0  1 30  0  0  0 
1A31BF8 	58 41 A0  1 39  0  0  0 
1A31C00 	D8 70 A0  1 DC 41 A0  1 
1A31C08 	3C  0  0  0 
      over c@  ascii 0 -  to #part           ( adr len )
1A31C0C 	54 49 A0  1 
1A31C10 	C4 4C A0  1 58 41 A0  1 
1A31C18 	30  0  0  0 18 45 A0  1 
1A31C20 	48 B8 A1  1 6C  A A3  1 
      1 /string                              ( adr' len' )
1A31C28 	80 6F A0  1 3C 85 A0  1 
      dup  0=  if  exit  then                ( adr len )
1A31C30 	40 49 A0  1 24 47 A0  1 
1A31C38 	DC 41 A0  1  8  0  0  0 
1A31C40 	40 46 A0  1 
   then

[ifdef] ufs-support
   \ If the first character is "a".."h", it's a UFS partition letter
   over c@ lcc  ascii a ascii h between  if  ( adr len )
      over c@  to ufs-partition              ( adr len )
      1 /string                              ( adr' len' )
      dup  0=  if  exit  then                ( adr len )
   then					     ( adr len )
[then]
;
1A31C44 	58 46 A0  1 
: parse-partition  ( -- )
1A31C48 	70 61 72 73 65 2D 70 61 
1A31C50 	72 74 69 74 69 6F 6E 8F 
1A31C58 	4C 1B A3  1 20 40 A0  1 
   null$ to filename  null$ to partition-name$  -1 to #part  0 to ufs-partition
1A31C60 	7C E1 A1  1 48 B8 A1  1 
1A31C68 	C0 16 A3  1 7C E1 A1  1 
1A31C70 	48 B8 A1  1 58  A A3  1 
1A31C78 	58 41 A0  1 FF FF FF FF 
1A31C80 	48 B8 A1  1 6C  A A3  1 
1A31C88 	70 6F A0  1 B8 40 A0  1 
1A31C90 	3C  A A3  1 

   my-args				     ( adr len )
1A31C94 	10  7 A2  1 

   \ An empty arg string is treated as a null partition and a null filename
   dup  0=  if  2drop exit  then	     ( adr len )
1A31C98 	40 49 A0  1 24 47 A0  1 
1A31CA0 	DC 41 A0  1  C  0  0  0 
1A31CA8 	AC 49 A0  1 40 46 A0  1 

   \ If the string contains a comma, the first half is the partition name
   " ," lex  if                              ( tail$ head$ delim )
1A31CB0 	9C 53 A0  1  1 2C  0  0 
1A31CB8 	B0 74 A1  1 DC 41 A0  1 
1A31CC0 	28  0  0  0 
      drop  2dup to partition-name$          ( tail$ head$ )
1A31CC4 	30 49 A0  1 
1A31CC8 	C0 49 A0  1 48 B8 A1  1 
1A31CD0 	58  A A3  1 
      decode-partition  2drop                ( tail$ )
1A31CD4 	4C 1B A3  1 
1A31CD8 	AC 49 A0  1 
      to filename                            ( )
1A31CDC 	48 B8 A1  1 
1A31CE0 	C0 16 A3  1 
      exit                                   ( -- )
1A31CE4 	40 46 A0  1 
   then                                      ( adr len )

   decode-partition                          ( rem$ )
1A31CE8 	4C 1B A3  1 

   \ The remainder of the string, if any, is the filename
   to filename
1A31CEC 	48 B8 A1  1 
1A31CF0 	C0 16 A3  1 
;
1A31CF4 	58 46 A0  1 

: try-open  ( -- )
1A31CF8 	 0  0  0 74 72 79 2D 6F 
1A31D00 	70 65 6E 88 5C 1C A3  1 
1A31D08 	20 40 A0  1 
   " block-size" $call-parent to /sector
1A31D0C 	9C 53 A0  1 
1A31D10 	 A 62 6C 6F 63 6B 2D 73 
1A31D18 	69 7A 65  0 DC 31 A2  1 
1A31D20 	48 B8 A1  1 80  A A3  1 
   sector-alloc
1A31D28 	D0  A A3  1 
   parse-partition	( )
1A31D2C 	5C 1C A3  1 
   select-partition     ( )
1A31D30 	F8 17 A3  1 

   \ Establish initial position at beginning of partition
   0 0 offset  " seek" $call-parent drop        ( )
1A31D34 	70 6F A0  1 
1A31D38 	70 6F A0  1 44 16 A3  1 
1A31D40 	9C 53 A0  1  4 73 65 65 
1A31D48 	6B  0  0  0 DC 31 A2  1 
1A31D50 	30 49 A0  1 

   select-file          ( )
1A31D54 	F0 1A A3  1 
;
1A31D58 	58 46 A0  1 

headers
\ In order to simplify the error handling logic, instead of passing
\ flags around, we just abort when a fatal error occurs.  The "catch"
\ intercepts the abort and returns the appropriate flag value.
: open  ( -- okay? )  ['] try-open  catch  0=  ;
1A31D5C 	 0  0  0 6F 
1A31D60 	70 65 6E 84  8 1D A3  1 
1A31D68 	20 40 A0  1 60 53 A0  1 
1A31D70 	 8 1D A3  1 14 7F A0  1 
1A31D78 	24 47 A0  1 58 46 A0  1 

OpenFirmware/ofw/disklabel/methods.fth_AL	748 1A31D80 
99D0184   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99D0194   00 00 00 00  00 00 00 00  FF FF FF FF  FF FF FF FF ........
99D01A4   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99D01B4   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................purpose: Filename pattern matching

headerless
\ Pattern matching with wildcards as in Unix filenames.

\ * matches anything, ? matches any individual character

: third   ( n5 n4 n3 n2 n1 -- n5 n4 n3 n2 n1 n3 )  2 pick  ;
1A31DC0 	 0  0 74 68 69 72 64 85 
1A31DC8 	 0  9 A3  1 20 40 A0  1 
1A31DD0 	90 6F A0  1  C 4A A0  1 
1A31DD8 	58 46 A0  1 
: fourth  ( n5 n4 n3 n2 n1 -- n5 n4 n3 n2 n1 n4 )  3 pick  ;
1A31DDC 	 0 66 6F 75 
1A31DE0 	72 74 68 86 CC 1D A3  1 
1A31DE8 	20 40 A0  1 A0 6F A0  1 
1A31DF0 	 C 4A A0  1 58 46 A0  1 
: fifth   ( n5 n4 n3 n2 n1 -- n5 n4 n3 n2 n1 n4 )  4 pick  ;
1A31DF8 	 0  0 66 69 66 74 68 85 
1A31E00 	E8 1D A3  1 20 40 A0  1 
1A31E08 	B0 6F A0  1  C 4A A0  1 
1A31E10 	58 46 A0  1 
\needs 5drop  : 5drop   ( n5 n4 n3 n2 n1 -- )  2drop 3drop  ;
\needs /string  : /string  ( adr len cnt -- adr' len' )  tuck - -rot + swap  ;

: -initial-match  ( case-insensitive? pat-str test-str -- ... )
1A31E14 	 0 2D 69 6E 
1A31E18 	69 74 69 61 6C 2D 6D 61 
1A31E20 	74 63 68 8E  4 1E A3  1 
1A31E28 	20 40 A0  1 
                  ( ... -- case-insensitive? pat-str' test-str' )
   begin                                ( case pat-str test-str )
      third 0<>  over 0<>  and          ( case pat-str test-str flag )
1A31E2C 	CC 1D A3  1 
1A31E30 	44 47 A0  1 54 49 A0  1 
1A31E38 	44 47 A0  1 5C 44 A0  1 
   while                                ( case pat-str test-str )
1A31E40 	DC 41 A0  1 8C  0  0  0 
      fourth c@  ascii ?  <>  if        ( case pat-str test-str )
1A31E48 	E8 1D A3  1 C4 4C A0  1 
1A31E50 	58 41 A0  1 3F  0  0  0 
1A31E58 	44 48 A0  1 DC 41 A0  1 
1A31E60 	50  0  0  0 
         fifth  if
1A31E64 	 4 1E A3  1 
1A31E68 	DC 41 A0  1 24  0  0  0 
            fourth c@ upc  third c@ upc ( case pat-str test-str char1 char2 )
1A31E70 	E8 1D A3  1 C4 4C A0  1 
1A31E78 	D0 51 A0  1 CC 1D A3  1 
1A31E80 	C4 4C A0  1 D0 51 A0  1 
         else
1A31E88 	C8 41 A0  1 14  0  0  0 
            fourth c@  third c@         ( case pat-str test-str char1 char2 )
1A31E90 	E8 1D A3  1 C4 4C A0  1 
1A31E98 	CC 1D A3  1 C4 4C A0  1 
         then
         <>  if  exit  then             ( case pat-str test-str )
1A31EA0 	44 48 A0  1 DC 41 A0  1 
1A31EA8 	 8  0  0  0 40 46 A0  1 
      then                              ( case pat-str test-str )
      2swap 1 /string  2swap 1 /string  ( case pat-str' test-str' )
1A31EB0 	F4 49 A0  1 80 6F A0  1 
1A31EB8 	3C 85 A0  1 F4 49 A0  1 
1A31EC0 	80 6F A0  1 3C 85 A0  1 
   repeat                               ( case pat-str test-str )
1A31EC8 	C8 41 A0  1 60 FF FF FF 
;
1A31ED0 	58 46 A0  1 

headers
: pattern-match?  ( case-insensitive? pat-str test-str -- flag )  recursive
1A31ED4 	 0 70 61 74 
1A31ED8 	74 65 72 6E 2D 6D 61 74 
1A31EE0 	63 68 3F 8E 28 1E A3  1 
1A31EE8 	20 40 A0  1 
   -initial-match                       ( case pat-str' test-str' )
1A31EEC 	28 1E A3  1 

   \ If the pattern string is empty, we can decide the question right now;
   \ it's a match iff the test string is also empty.
   third 0=  if                         ( case pat-str test-str )
1A31EF0 	CC 1D A3  1 24 47 A0  1 
1A31EF8 	DC 41 A0  1 1C  0  0  0 
      nip nip nip nip 0=  exit
1A31F00 	FC 46 A0  1 FC 46 A0  1 
1A31F08 	FC 46 A0  1 FC 46 A0  1 
1A31F10 	24 47 A0  1 40 46 A0  1 
   then                                 ( case pat-str test-str )

   \ If the first remaining character in the pattern string is not a '*',
   \ then the strings don't match.

   fourth c@  ascii *  <>  if           ( case pat-str test-str )
1A31F18 	E8 1D A3  1 C4 4C A0  1 
1A31F20 	58 41 A0  1 2A  0  0  0 
1A31F28 	44 48 A0  1 DC 41 A0  1 
1A31F30 	10  0  0  0 
      5drop false  exit                 \ Lose
1A31F34 	4C 53 A0  1 
1A31F38 	18 70 A0  1 40 46 A0  1 
   then                                 ( case pat-str test-str )

   \ The pattern string begins with an *; remove it and try to
   \ match the remaining pattern with all possible trailing substrings
   \ of the test pattern.

   2swap 1 /string 2swap                ( case pat-str test-str )
1A31F40 	F4 49 A0  1 80 6F A0  1 
1A31F48 	3C 85 A0  1 F4 49 A0  1 

   \ If the pattern is now empty, we win, because a trailing "*" matches
   \ any possible remaining string.
   third 0=  if  5drop true  exit  then ( case pat-str test-str )
1A31F50 	CC 1D A3  1 24 47 A0  1 
1A31F58 	DC 41 A0  1 10  0  0  0 
1A31F60 	4C 53 A0  1  4 70 A0  1 
1A31F68 	40 46 A0  1 

   begin  dup  while                    ( case pat-str test-str )
1A31F6C 	40 49 A0  1 
1A31F70 	DC 41 A0  1 40  0  0  0 
      fifth fifth fifth fifth fifth     ( case pat-str test-str case .. test$ )
1A31F78 	 4 1E A3  1  4 1E A3  1 
1A31F80 	 4 1E A3  1  4 1E A3  1 
1A31F88 	 4 1E A3  1 
      pattern-match?  if                ( case pat-str test-str )
1A31F8C 	E8 1E A3  1 
1A31F90 	DC 41 A0  1 10  0  0  0 
         5drop true  exit               \ We have a winner!
1A31F98 	4C 53 A0  1  4 70 A0  1 
1A31FA0 	40 46 A0  1 
      then                              ( case pat-str test-str )
      1 /string                         ( case pat-str test-str' )
1A31FA4 	80 6F A0  1 
1A31FA8 	3C 85 A0  1 
   repeat                               ( case pat-str test-str )
1A31FAC 	C8 41 A0  1 
1A31FB0 	BC FF FF FF 

   \ Having exhausted all possible matches for the '*', we admit defeat.

   5drop false
1A31FB4 	4C 53 A0  1 
1A31FB8 	18 70 A0  1 
;
1A31FBC 	58 46 A0  1 

OpenFirmware/forth/lib/pattern.fth_AL	200 1A31FC0 purpose: User interface commands for file manipulation

\needs 2nip  : 2nip  ( $1 $2 -- $2 )  2swap 2drop  ;

\needs internal alias internal headerless
1A31FC0 	 0  0  0 69 6E 74 65 72 
1A31FC8 	6E 61 6C A8 E8 1E A3  1 
1A31FD0 	4C F0 A0  1 
\needs public   alias public   headers
1A31FD4 	 0 70 75 62 
1A31FD8 	6C 69 63 A6 D0 1F A3  1 
1A31FE0 	60 F0 A0  1 
\needs private  alias private  headerless
1A31FE4 	70 72 69 76 
1A31FE8 	61 74 65 A7 E0 1F A3  1 
1A31FF0 	4C F0 A0  1 

internal

: dev&path  ( path$ -- dev$ file-path$ )  [char] \ split-string  ;
1A31FF4 	 0  0  0 64 
1A31FF8 	65 76 26 70 61 74 68 88 
1A32000 	F0 1F A3  1 20 40 A0  1 
1A32008 	58 41 A0  1 5C  0  0  0 
1A32010 	3C 64 A0  1 58 46 A0  1 

: $volatile?  ( $ -- $ flag )  over in-dictionary? 0=  over 0<>  and  ;
1A32018 	 0 24 76 6F 6C 61 74 69 
1A32020 	6C 65 3F 8A  4 20 A3  1 
1A32028 	20 40 A0  1 54 49 A0  1 
1A32030 	24 CF A0  1 24 47 A0  1 
1A32038 	54 49 A0  1 44 47 A0  1 
1A32040 	5C 44 A0  1 58 46 A0  1 
: ?save-string  ( $1 -- $2 )
1A32048 	 0  0  0 3F 73 61 76 65 
1A32050 	2D 73 74 72 69 6E 67 8C 
1A32058 	28 20 A3  1 20 40 A0  1 
   $volatile?  if               ( $1 )
1A32060 	28 20 A3  1 DC 41 A0  1 
1A32068 	20  0  0  0 
      dup alloc-mem swap        ( adr1 adr2 len )
1A3206C 	40 49 A0  1 
1A32070 	F0 6C A0  1 68 49 A0  1 
      2dup 2>r move 2r>         ( $2 )
1A32078 	C0 49 A0  1 F8 45 A0  1 
1A32080 	F4 4A A0  1 10 46 A0  1 
   then
;
1A32088 	58 46 A0  1 
: ?release-string  ( $ -- )  $volatile?  if  free-mem  else  2drop  then  ;
1A3208C 	3F 72 65 6C 
1A32090 	65 61 73 65 2D 73 74 72 
1A32098 	69 6E 67 8F 5C 20 A3  1 
1A320A0 	20 40 A0  1 28 20 A3  1 
1A320A8 	DC 41 A0  1 10  0  0  0 
1A320B0 	 8 6D A0  1 C8 41 A0  1 
1A320B8 	 8  0  0  0 AC 49 A0  1 
1A320C0 	58 46 A0  1 

variable current-volume
1A320C4 	 0 63 75 72 
1A320C8 	72 65 6E 74 2D 76 6F 6C 
1A320D0 	75 6D 65 8E A0 20 A3  1 
1A320D8 	48 40 A0  1 B4  9  0  0 

: >directory  ( xt -- adr )  >body >user  ;
1A320E0 	 0 3E 64 69 72 65 63 74 
1A320E8 	6F 72 79 8A D8 20 A3  1 
1A320F0 	20 40 A0  1 E4 59 A0  1 
1A320F8 	C8 74 A0  1 58 46 A0  1 

public

3 actions
1A32100 	50 21 A3  1 24 21 A3  1 
1A32108 	 3  0  0  0 
action:  body> current-volume token!  ;
1A3210C 	90 90 90 E8 
1A32110 	68 1F FD FF C8 59 A0  1 
1A32118 	D8 20 A3  1 20 54 A0  1 
1A32120 	58 46 A0  1 
action:  body> >directory >r  r@ 2@ ?release-string  ?save-string r> 2!  ;
1A32124 	20 40 A0  1 
1A32128 	C8 59 A0  1 F0 20 A3  1 
1A32130 	BC 45 A0  1 E4 45 A0  1 
1A32138 	CC 4D A0  1 A0 20 A3  1 
1A32140 	5C 20 A3  1 D0 45 A0  1 
1A32148 	E4 4D A0  1 58 46 A0  1 
action:  body> >directory 2@  ;
1A32150 	20 40 A0  1 C8 59 A0  1 
1A32158 	F0 20 A3  1 CC 4D A0  1 
1A32160 	58 46 A0  1 
: volume:  ( "name" -- )  create  0 0  2 /n* user#,  2!  use-actions  ;
1A32164 	76 6F 6C 75 
1A32168 	6D 65 3A 87 F0 20 A3  1 
1A32170 	20 40 A0  1 A8 A2 A0  1 
1A32178 	70 6F A0  1 70 6F A0  1 
1A32180 	90 6F A0  1 98 51 A0  1 
1A32188 	84 9A A0  1 E4 4D A0  1 
1A32190 	60 53 A0  1  C 21 A3  1 
1A32198 	E0 57 A0  1 58 46 A0  1 

: current-volume-name  ( -- adr len )
1A321A0 	63 75 72 72 65 6E 74 2D 
1A321A8 	76 6F 6C 75 6D 65 2D 6E 
1A321B0 	61 6D 65 93 70 21 A3  1 
1A321B8 	20 40 A0  1 
   current-volume token@ 0= abort" There is no current volume"
1A321BC 	D8 20 A3  1 
1A321C0 	 C 54 A0  1 24 47 A0  1 
1A321C8 	 8 81 A0  1 1A 54 68 65 
1A321D0 	72 65 20 69 73 20 6E 6F 
1A321D8 	20 63 75 72 72 65 6E 74 
1A321E0 	20 76 6F 6C 75 6D 65  0 
   current-volume token@ >name name>string
1A321E8 	D8 20 A3  1  C 54 A0  1 
1A321F0 	24 74 A0  1 58 74 A0  1 
;
1A321F8 	58 46 A0  1 
: pcwd  ( -- name$ )
1A321FC 	 0  0  0 70 
1A32200 	63 77 64 84 B8 21 A3  1 
1A32208 	20 40 A0  1 
   current-volume-name type
1A3220C 	B8 21 A3  1 
1A32210 	 4 6C A0  1 
   current-volume token@ >directory 2@  dup  if  type  else  2drop  ." \"  then
1A32214 	D8 20 A3  1 
1A32218 	 C 54 A0  1 F0 20 A3  1 
1A32220 	CC 4D A0  1 40 49 A0  1 
1A32228 	DC 41 A0  1 10  0  0  0 
1A32230 	 4 6C A0  1 C8 41 A0  1 
1A32238 	10  0  0  0 AC 49 A0  1 
1A32240 	20 7C A0  1  1 5C  0  0 
   cr
1A32248 	80 6D A0  1 
;
1A3224C 	58 46 A0  1 

volume: A:
1A32250 	 0 61 3A 82  8 22 A3  1 
1A32258 	 C 21 A3  1 B8  9  0  0 
volume: B:
1A32260 	 0 62 3A 82 58 22 A3  1 
1A32268 	 C 21 A3  1 C0  9  0  0 
volume: C:
1A32270 	 0 63 3A 82 68 22 A3  1 
1A32278 	 C 21 A3  1 C8  9  0  0 
volume: D:
1A32280 	 0 64 3A 82 78 22 A3  1 
1A32288 	 C 21 A3  1 D0  9  0  0 
volume: E:
1A32290 	 0 65 3A 82 88 22 A3  1 
1A32298 	 C 21 A3  1 D8  9  0  0 
volume: F:
1A322A0 	 0 66 3A 82 98 22 A3  1 
1A322A8 	 C 21 A3  1 E0  9  0  0 

volume:  /pci/isa@1/ide@i1f0/disk@1:
1A322B0 	2F 70 63 69 2F 69 73 61 
1A322B8 	40 31 2F 69 64 65 40 69 
1A322C0 	31 66 30 2F 64 69 73 6B 
1A322C8 	40 31 3A 9B A8 22 A3  1 
1A322D0 	 C 21 A3  1 E8  9  0  0 

C:
\eof
internal

d# 256 buffer: file-path-buf
d# 32  buffer: drive-name
: +path  ( adr len -- )  file-path-buf $cat  ;
: +\  ( -- )  " \" +path  ;

: file&dir  ( path$ -- basename$ dirname$ )  [char] \ right-split-string  ;
: parse-volume  ( $1 -- path$ volume$ )
   " :" lex  if  drop  else  current-volume-name 1-  then  ( path$ volume$: )
;
: drive-volume  ( -- adr len false | xt true )
   drive-name count  dup  if    ( adr len )
      + 1- c@ [char] : <>  if   ( )
         " :" drive-name $cat   ( )
      then                      ( )
      drive-name count          ( adr len )
   then
   $find
;
: insert-directory  ( -- )
   drive-volume  if
      2 perform-action  dup  if  +path  else  2drop  +\  then
   else
      2drop  +\
   then
;
\ Removes the first character from tail$ and puts it at the end of head$
: copy\  ( head$ tail$ -- head$' tail$' )
   dup  if  over c@ >r  2over +  r> swap c!  rot 1+ -rot  1 /string  then
;
: remove..  ( $1 -- $2 )
   dev&path copy\                             ( head$ tail$ )
   begin  dup  while                          ( head$ tail$ )
      dev&path                                ( head$ next$ tail$' )
      2over " .."  $=  if                     ( head$ next$ tail$' )
         \ ".." found - remove the previous directory component and
         \ any backslash at the beginning of the tail string
         2>r                                  ( head$ next$ )
         2drop                                ( head$ )
         1-     \ Remove trailing \           ( head$' )
         [char] \ right-split-string          ( right$ left$ )
         dup  if  2nip  else  2drop 1+  then  ( head$' )
         2r>  dup  if  1 /string  then        ( head$' tail$' )
      else                                    ( head$ next$ tail$' )
         \ ".." not found - append the current name component 
         \ to the end of the head string
         2>r   >r >r                          ( head$ r: tail$ next-len,adr)
         2dup +  r> swap r@ move              ( head$ r: tail$ next-len)
         r> +                                 ( head$' r: tail$' )
         2r>  copy\                           ( head$' tail$' )
      then                                    ( head$' tail$' )
   repeat                                     ( $2 null$ )
   2drop
;

: ?+:  ( adr len -- adr len' )
   \ If the last character is already a colon or a comma, just exit
   file-path-buf count  + 1- c@                          ( last-char )
   dup [char] : =  swap [char] , =  or  if  exit  then   ( )

   \ Otherwise, append a colon if the last pathname component of the string
   \ doesn't already contain one or a comma if it does.
   file-path-buf count  [char] / right-split-string      ( tail$ head$ )
   2drop  [char] :  split-string                         ( head$ tail$ )
   if  " ,"  else  " :"  then  +path  3drop              ( )
;
: canonical-path  ( $1 -- $2 )
   \ In the following code, file-path-buf is used to store the output
   \ string as it is being constructed.  drive-name is an intermediate.
   0 file-path-buf c!                                    ( $1 )
   parse-volume                                          ( path$ volume$ )
   drive-name place                                      ( path$ )

   \ If the name could be an alias, convert it to lower case, so that,
   \ for example, "C:" will work
   drive-name count nip 0<>  if                          ( path$ )
      drive-name count drop c@  [char] / <>  if          ( path$ )
         drive-name count lower                          ( path$ )
      then                                               ( path$ )
   then                                                  ( path$ )

   \ If the drive name matches a user-created configuration variable,
   \ replace it with that variable's value
   drive-name count  2dup $getenv  if                    ( path$ drive$ )
      2dup not-alias?  0=  if  2swap 2drop  then         ( path$ drive$' )
   else                                                  ( path$ drive$ exp$ )
      2swap 2drop                                        ( path$ drive$' )
   then                                                  ( path$ drive$' )
                                                         ( path$ drive$ )
   +path                                                 ( path$ )

   \ XXX we probably should insert a ":" or a "," after the expanded name
   ?+:

   \ Insert working directory if the path name is relative
   dup  if                                               ( path$ )
      [char] ,  split-string                             ( head$ tail$ )

      dup  if                                            ( head$ ,tail$ )
         \ If tail$ is not empty, there was a , in the path
         \ so we copy the head$ to the path buffer verbatim
         2swap +path  " ," +path                         ( tail$ )
         1 /string                                       ( tail$' )
      else                                               ( head$ null$ )
         2drop                                           ( head$ )
      then                                               ( path$ )

      \ Insert directory if path string doesn't start with '\'
      over c@ [char] \ <>  if  insert-directory  then    ( path$ )
   else                                                  ( path$ )
      \ Insert directory if path string is empty
      insert-directory                                   ( path$ )
   then                                                  ( path$ )

   +path                                                 ( )

   file-path-buf count                                   ( $2 )

   \ Edit the output string to eliminate any "dir/.." sequences
   remove..                                              ( $2' )
;

: case-insensitive?  ( ihandle -- flag )
   \ If the "case-sensitive" property does not exist,
   \ then we use case-insensitive pattern matching
   " case-sensitive"  rot ihandle>phandle get-package-property  if  ( )
      \ Property does not exist; use case-insensitive matching
      true
   else                                                        ( adr len )
      \ Property exists; use case-sensitive matching
      2drop false
   then
;

0 value search-ih
0 value search-index
0 value search-case
d# 64 buffer: search-pattern
: $open-canonical-file  ( canonical-path$ -- ih )
   open-dev dup 0= abort" Can't open file"
;
: $open-file  ( path$ -- ih )
   canonical-path $open-canonical-file
;
: $open-dir   ( path$ -- ih )  open-dev dup 0= abort" Can't open directory"  ;
: open-directory  ( path$ -- file$ ih )  canonical-path file&dir  $open-dir  ;
: begin-search  ( pattern$ -- )
   open-directory      ( base-pattern$ ihandle )
   to search-ih  search-pattern place
   0 to search-index
   search-ih case-insensitive? to search-case
;
: close-search  ( -- )  search-ih close-dev  ;
: drop-attributes  ( s m h m d y attr len -- )  2drop 3drop 3drop  ;
: another-match?  ( -- false | 8*attributes name$ true )
   begin  search-index " next-file-info"  search-ih  $call-method  while
      ( index s m h d m y len attr name$ )
      2>r  8 roll to search-index      ( 8*n r: name$ )
      search-case  search-pattern count  2r@  pattern-match?  if
         2r> true exit
      else
         2r> 2drop drop-attributes
      then
   repeat
   close-search  false
;
: first-match  ( pattern$ -- false | 8attributes name$ true )
   begin-search  another-match?  dup  if  close-search  then
;

: dir-attr?  ( attribute -- flag )  h# f000 and  h# 4000 =  ;
: dir?  ( 8attributes -- flag )  >r drop 3drop 3drop r> dir-attr? ;

\ Standard file type encoding; this is a melange of Unix and DOS file
\ type semantics.  We map the DOS types into the Unix encoding where
\ that will work, and then add on some extra bits for the DOS-specific
\ things.  Portable client programs should not depend upon any of the
\ OS-specific bits or file types.

\ Permissions:
\    Low 9 bits are Owner RWX, Group RWX, World RWX using the well-known
\    Unix encoding.  For DOS, the only two possibilities are r-xr-xr-x
\    and rwxrwxrwx.  (Portable programs should pay attention to only the
\    h# 00002 bit, i.e. the "world writeable" bit).
\ File Types:
\    The h# f000 nibble is the file type.  The encoding are the same as
\    the Unix types (see stat.h), with some DOS-specific types inserted
\    in otherwise-unused slots.  These file types are mutually exclusive.
\    h#  1000   FIFO (Unix-specific)
\    h#  2000   Character special (Unix-specific)
\    h#  3000	Volume Label (DOS-specific)
\    h#  4000	Subdirectory
\    h#  6000   Block special (Unix-specific)
\    h#  8000	Ordinary File
\    h#  a000	Symbolic link (Unix-specific)
\    h#  c000   Socket (Unix-specific)
\ Other attributes: (DOS-specific)
\    DOS-specific attributes other then file type are mutually independent
\    h# 10000	Hidden
\    h# 20000	System
\    h# 40000	Archive
\ Other attributes: (Unix-specific)
\    h# 00200   Sticky
\    h# 00400   Set GID
\    h# 00800   Set UID

: ?.c  ( n mask char -- )  -rot  and  if  emit  else  drop  ." -"  then  ;
: .rwx  ( n -- )  dup 4  ascii r ?.c  dup 2  ascii w  ?.c  1 ascii x ?.c  ;
: .attrs  ( attributes -- )
   dup h# 20000  ascii S  ?.c
   dup h# 10000  ascii H  ?.c
   dup h# 40000  ascii A  ?.c
   dup h#  f000  and  case
       h#  4000  of  ." d"  endof
       h#  3000  of  ." v"  endof
       h#  8000  of  ." -"  endof
       h#  a000  of  ." l"  endof
                     ." ?"	\ Don't bother decoding specials and sockets
   endcase
   dup 6 >> .rwx  dup 3 >> .rwx  .rwx
   space
;

: .file  ( s m h d m y len atr name$ -- )
   2>r >r r@ .attrs  base @ >r decimal 9 u.r r> base !
   2 spaces  .date space .time 2 spaces  r> 2r> 2dup type  ( atr name$ )

   \ display the referent of links
   rot  h# f000 and h# a000 =  if                          ( name$ )
      " $readlink" search-ih  ['] $call-method  catch  if  ( x x x x x )
         5drop                                             ( )
      else                                                 ( t | name$' f )
         0=  if  ."  -> " type  then                       ( )
      then                                                 ( )
   else                                                    ( name$ )
      2drop                                                ( )
   then                                                    ( )
;

public

: $delete1  ( path$ -- )
   open-directory ?dup 0= abort" Can't open directory"      ( name$ dir-ih )
   >r  " $delete!" r@ $call-method  ( error?  r: dir-ih ) 
   r> close-dev                     ( error? )
   abort" Can't delete file"  
;
' $delete1 to _ofdelete

: $delete-all  ( pattern-adr pattern-len -- )
   begin-search  begin  another-match?  while           ( 8*attributes name$ )
      \ Check attributes to see if this is a directory
      2 pick dir-attr? if
	 \ Filter out '.' and '..' from printing
	 2dup " ." $= >r 2dup " .." $= r> or if           ( 8*attributes name$ )
	    2drop                                         ( 8*attributes )
	 else						  ( 8*attributes name$ )
	    ." Not deleting directory: " type cr          ( 8*attributes )
	 then						  ( 8*attributes )
     else						  ( 8*attributes name$ )
	2dup " $delete"  search-ih  $call-method          ( 8*n name$ err? )
	if  ." Can't delete " type cr  else  2drop  then  ( 8*n )
     then                                                 ( 8*attributes )
     drop-attributes					  ( )
   repeat                                                 ( )
;

internal

: last-char  ( adr len -- adr len char )  2dup + 1- c@  ;

: separator?  ( adr len -- adr len flag )
   last-char  dup [char] : =  swap [char] \ =  or
;
: is-pattern?  ( adr len -- flag )
   false -rot  bounds ?do
      i c@  dup [char] * =  swap [char] ? =  or  if  0= leave  then
   loop
;

\ If the pathname contains no pattern matching characters, and it
\ refers to a directory, append a "\" so that later code will append
\ a "*", thus causing all the files to be listed.
: add\  ( pstr -- )  " \" rot $cat  ;
: ?add\  ( adr len -- adr' len' )
   2dup is-pattern?  0=  if                     ( adr len )
      separator?  if  exit  then                ( adr len )
      2dup  first-match  if                     ( adr len 8*attrs name$ )
         2drop  dir?  if                        ( adr len )
            string2 pack  add\  string2 count   ( adr' len' )
         then                                   ( adr len )
      then                                      ( adr len )
   then                                         ( adr len )
;

: .fs-name  ( -- )
   " name"  search-ih ihandle>phandle get-package-property  0=  if
      get-encoded-string type cr
   then
;

public

: $dir  ( pattern$ -- )
   \ If the pattern$ is null or has no name component, add a "*" to the end
   dup  if   ?add\  separator?  else  true  then        ( pattern$ no-name? )

   if  string2 pack  " *" rot $cat  string2 count  then

   begin-search
   .fs-name
   begin  another-match?  while           ( 8*attributes name$ )
      .file cr
      exit?  if  close-search exit  then
   repeat
;
: dir  ( "pattern" -- )  parse-word  $dir  ;
: dir" ( "pattern"" -- )  [char] " parse  $dir  ;

defer handle-dirent  ( 8*attributes $name )

d# 256 buffer: ls-r-name
0 value ls-r-len

: ls-r-name$  ( -- adr len )  ls-r-name ls-r-len  ;

variable indent-level

: .totsize  ( d.size name$ -- )
   indent-level @ spaces  type ."  Total: "  push-decimal ud. pop-base cr
;
: ($ls-r)  ( name$ -- d.totsize )

   search-ih >r  ls-r-len >r

   \ Extend the path with the new name component and start new search
   tuck                               ( len name$ )
   ls-r-name$ +  swap move            ( len )
   dup  ls-r-name$ + +  [char] \ swap c!  ( len )
   ls-r-len + 1+  to ls-r-len         ( )

   ls-r-name$ $open-dir to search-ih  ( )

   1 indent-level +!                  ( )

   0. 0                               ( d.totsize index )
   begin  " next-file-info"  search-ih  $call-method  while    ( index 8*attributes name$ )
      handle-dirent                   ( d.totsize index d.size )
      rot >r  d+  r>                  ( d.totsize index' )
   exit? until   \ Resolves "begin"   ( d.totsize index )
      \ This block executes only if the loop terminates via "until"
      drop                            ( d.totsize )
   then          \ Resolves "while"   ( d.totsize )
   close-search                       ( d.totsize )

   -1 indent-level +!                 ( d.totsize )

   2dup  ls-r-name$ .totsize          ( d.totsize )

   \ Restore the path (removing the new name) and the search parameters
   r> to ls-r-len  r> to search-ih    ( d.totsize )
;

: recursive-.file  ( 8*attributes $name -- d.size )
   2dup " ." $= >r   2dup " .." $=  r> or  if   ( 8*attributes $name )
      2drop 4drop 4drop  0.  exit
   then

   3 pick >r  2dup 2>r 2 pick >r    ( 8*attributes $name r: len $name attr )
   indent-level @ spaces  .file cr  ( r: len $name attr )
   r> dir-attr?  if                 ( r: len $name )
      2r>  r> drop   ($ls-r)        ( d.size )
   else                             ( r: len $name )
      2r> 2drop  r> 0               ( d.size )
   then
;
' recursive-.file to handle-dirent

: $ls-r  ( pattern$ -- )
   \ If the pattern$ is null or has no name component, add a "*" to the end
   dup  if                     ( pattern$ )
      ?add\                    ( pattern$' )
      2dup file&dir 2nip       ( pattern$ dir$ )
      dup to ls-r-len          ( pattern$ dir$ )
      ls-r-name swap move      ( pattern$ )
      separator?               ( pattern$ no-name? )
   else  true  then            ( pattern$ no-name? )

   if  string2 pack  " *" rot $cat  string2 count  then  ( pattern$ )

   0 indent-level !                       ( pattern$ )
   2dup 2>r                               ( pattern$ r: pattern$ )
   begin-search    0.                     ( d.totsize )
   begin  another-match?  while           ( d.totsize 8*attributes name$ )
      handle-dirent  d+                   ( d.totsize' )
      exit?  if  close-search 2drop 2r> 2drop  exit  then
   repeat                                 ( d.totsize r: pattern$ )
   2r>  .totsize                          ( )
;
: ls-r  ( "pattern" -- )  parse-word  $ls-r  ;
: ls-r"  ( "pattern"" -- )  [char] " parse  $ls-r  ;

internal

: do-fileop  ( ... path$ op$ -- )
   2>r  open-directory         ( ... file$ ih )
   2r>  rot dup >r  $call-method  ( )
   r> close-dev
;


public

: $delete  ( path$ -- )  " $delete!" do-fileop abort" Can't delete file"  ;
: $rmdir   ( path$ -- )  " $rmdir"  do-fileop abort" Can't delete directory"  ;
: $mkdir   ( path$ -- )  " $mkdir"  do-fileop abort" Can't create directory"  ;
: $disk-free  ( path$ -- d.bytes )   " free-bytes" do-fileop 2nip  ;
: $disk-size  ( path$ -- d.bytes )   " total-size" do-fileop 2nip  ;

: $chdir  ( name$ -- )
   2dup is-pattern? abort" Can't use wildcards in directory name"
   canonical-path
   last-char  [char] \  <>  if  2dup + [char] \ swap c! 1+  then
   2dup $open-dir  close-dev                                      ( path$ )
   drive-volume  0= abort" Unassigned volume"                     ( path$ xt )
   -rot  dev&path 2nip  rot                                       ( tail$ xt )
   1 perform-action
;

internal

: safe-parse"  ( "name"" -- adr len )
   [char] " parse  dup 0=  abort" Missing command line argument"
;

public

: chdir  ( "name" -- )   safe-parse-word $chdir  ;
: chdir" ( "name"" -- )  safe-parse"     $chdir  ;

: delete  ( "pattern" -- )   safe-parse-word  $delete-all  ;
: delete" ( "pattern"" -- )  safe-parse"      $delete-all  ;
alias del  delete
alias del" delete"
alias rm   delete
alias rm"  delete"


internal

h# 8000 constant /copybuf
: (fcopy)  ( in-ih out-ih -- )
   /copybuf alloc-mem >r
   " size" 3 pick $call-method drop    ( in-ih out-ih input-file-size )
   begin  ?dup  while                  ( in-ih out-ih #remaining )
      r@  /copybuf " read" 6 pick $call-method  ( i o #remaining #read )
      tuck -  r@ rot                   ( i o #remaining' adr #read )
      " write" 5 pick $call-method     ( i o #remaining' #written )
      drop                             ( i o #remaining' )
   repeat                              ( i o )
   close-dev  close-dev  \ order is important for date/time keeping
   r> /copybuf free-mem
;

public

: $create-file  ( path$ -- ih )
   2dup open-directory                                     ( path$2 file$2 ih )
   >r " $create" r@ $call-method abort" Can't create file" ( path$2 ) ( r: ih )
   r> close-dev                                            ( path$2 )
   $open-file
;
' $create-file to _ofcreate

dev /client-services
: firmworks,create  ( cstr -- ihandle )
   cscount                   ( path$ )

   \ If the file already exists, delete it so it can be
   \ recreated with 0 initial length.
   2dup ['] $open-file catch  if  ( path$ x x )
      2drop                       ( path$ )
   else                           ( path$ ih )
      close-dev                   ( path$ )
      2dup ['] $delete catch  if  2drop  then  ( path$ )
   then                           ( path$ )

   ['] $create-file  catch  if  2drop 0  then
;
device-end

internal

: ?delete-file  ( path$ -- continue? )
   2dup  canonical-path open-dev  ?dup  if  ( path$2 ihandle )
      close-dev                             ( path$2 )
      confirmed? if                         ( path$2 )
	 $delete true                       ( continue? )
      else                                  ( path$2 )
	 2drop false                        ( continue? )
      then                                  ( continue? )
   else                                     ( path$2 )
      2drop true                            ( continue? )
   then                                     ( continue? )
;
: same-device?  ( path$1 path$2 -- flag )
   canonical-path dev&path 2drop  string2 $save      ( path$1 dev$2 )
   2swap canonical-path dev&path 2drop    $=         ( flag )
;

: $copy1  ( path$1 path$2 -- )
   2swap $open-canonical-file -rot          ( ih path$2 )
   2dup ?delete-file if                     ( ih path$2 )
      $create-file                          ( ih out-ih )
      (fcopy)
   then
;
d# 128 buffer: source$
d# 128 buffer: destination$
: $copy-to-dir  ( file-name$ dir-path$ -- )
   last-char [char] \ = >r destination$ pack r> if
      drop                                   ( file-name$ )
   else
      add\                                   ( file-name$ )
   then
   2dup  file&dir 2drop  destination$ $cat   ( file-name$ )
   destination$ count  $copy1
;

: is-dir?  ( name$ -- flag )
   \ Special case to detect the root directory which does not appear inside
   \ any other directory.
   2dup canonical-path [char] \ split-string 2nip nip 1 = if
      2drop true exit
   then
   first-match  if  2drop dir?  else  false  then
;   
d# 128 buffer: search-dir
: $copy-all  ( pattern$ dir$ -- )
   2>r                                                 ( pattern$ r: dir$ )
   2r@ is-dir?  0= abort" The destination for pattern copies must be a directory"
   2dup canonical-path                                 ( pattern$ canonical$ r: dir$ )
   file&dir 2nip search-dir place  \ note source dir   ( pattern$ r: dir$ )
   begin-search  begin  another-match?  while          ( 8attributes name$ r: dir$ )
      2>r dir?  if                                     ( r: dir$ name$ )
         ." Not copying the directory: " 2r> type cr   ( r: dir$ )
      else                                             ( r: dir$ name$ )
         search-dir count source$ place                ( r: dir$ name$ )
         2r> source$ $cat                              ( r: dir$ )
         source$ count  2r@  $copy-to-dir              ( r: dir$ )
      then                                             ( r: dir$ )
   repeat                                              ( r: dir$ )
   2r> 2drop                                           ( )
;

: $copy2  ( path$1 path$2 -- )
   2dup is-dir? >r 2swap canonical-path 2swap r> if
      $copy-to-dir
   else
      $copy1
   then
;

public

: $copy  ( path$1 path$2 -- )
   2dup is-pattern? abort" Can't use wildcards in destination filename"
   2over is-pattern?  if
      $copy-all
   else
      \ Check whether the source and destination file are identical.
      2over canonical-path tuck source$ swap move source$ swap
      2over canonical-path $=
      abort" Can't copy file to itself"
      $copy2 
   then
;

: copy  ( "name1" "name2" -- )  safe-parse-word  safe-parse-word  $copy  ;

: $rename  ( path$1 path$2 -- )
   2over 2over is-pattern? -rot is-pattern? or
   abort" Can't use wildcards with rename"
   2over 2over same-device?  if           ( path$1 path$2 )
      2swap canonical-path dev&path 2nip  ( path$2 file-path$1 )
      string2 $save  2swap                ( file-path$1 path$2 )
      " $rename"  do-fileop  abort" Can't rename file"  ( )
   else   
      2>r  2dup  2r>  $copy2  $delete
   then
;
: rename  ( "name1" "name2" -- )
   safe-parse-word safe-parse-word $rename
;
alias ren rename
alias mv rename

: rmdir  ( "name" -- )   safe-parse-word $rmdir  ;
: rmdir" ( "name"" -- )  safe-parse"     $rmdir  ;

: mkdir  ( "name" -- )   safe-parse-word $mkdir  ;
: mkdir" ( "name"" -- )  safe-parse"     $mkdir  ;

public

: disk-free  ( "name" -- )
   parse-word $disk-free           ( d.size )
   dup  if    \ Larger than 4G, so display size in GB
      d# 1000000000 um/mod nip  ( gbytes )
      .d ." GB" cr                 ( )
      exit
   then                            ( d.size )
   2dup  h# 40.0000.  d<  if       ( d.size )
      d# 1024 um/mod nip           ( kbytes )
      .d ." KB" cr                 ( )
      exit
   then                            ( d.size )
   d# 1000000 um/mod nip         ( mbytes )
   .d ." MB" cr                    ( )
;

: more  ( "devspec" -- )
   safe-parse-word
   open-dev  dup 0=  abort" Can't open it"   ( ih )
   >r                                        ( r: ih )
   load-base " load" r@ $call-method         ( len r: ih )
   r> close-dev                              ( len )
   load-base swap list
;

\ Read entire file into allocated memory
: $read-file  ( filename$ -- true | data$ false )
   open-dev  ?dup  0=  if  true exit  then  >r  ( r: ih )
   " size" r@ $call-method  drop   ( len r: ih )
   dup alloc-mem  swap             ( adr len r: ih )
   2dup " read" r@ $call-method    ( adr len actual r: ih )
   r> close-dev                    ( adr len actual )
   over <>  if                     ( adr len )
      free-mem  true exit
   then                            ( adr len )
   false
;


OpenFirmware/ofw/core/filecmds.fth_AL	318 1A322D8 purpose: Establish configuration definitions

\ --- The environment that "boots" OFW ---
\ - Image Format - Example Media - previous stage bootloader

\ - ELF format w/ Multiboot signature - various media - GRUB
create grub-loaded
1A322D8 	67 72 75 62 2D 6C 6F 61 
1A322E0 	64 65 64 8B D0 22 A3  1 
1A322E8 	30 40 A0  1 

create debug-startup
1A322EC 	 0  0 64 65 
1A322F0 	62 75 67 2D 73 74 61 72 
1A322F8 	74 75 70 8D E8 22 A3  1 
1A32300 	30 40 A0  1 
\ create serial-console
create resident-packages
1A32304 	 0  0 72 65 
1A32308 	73 69 64 65 6E 74 2D 70 
1A32310 	61 63 6B 61 67 65 73 91 
1A32318 	 0 23 A3  1 30 40 A0  1 
create addresses-assigned  \ Don't reassign PCI addresses
1A32320 	 0 61 64 64 72 65 73 73 
1A32328 	65 73 2D 61 73 73 69 67 
1A32330 	6E 65 64 92 1C 23 A3  1 
1A32338 	30 40 A0  1 
\ create virtual-mode
\ create use-root-isa
create use-timestamp-counter
1A3233C 	 0  0 75 73 
1A32340 	65 2D 74 69 6D 65 73 74 
1A32348 	61 6D 70 2D 63 6F 75 6E 
1A32350 	74 65 72 95 38 23 A3  1 
1A32358 	30 40 A0  1 
create use-pci-isa
1A3235C 	75 73 65 2D 
1A32360 	70 63 69 2D 69 73 61 8B 
1A32368 	58 23 A3  1 30 40 A0  1 
create use-isa-ide
1A32370 	75 73 65 2D 69 73 61 2D 
1A32378 	69 64 65 8B 6C 23 A3  1 
1A32380 	30 40 A0  1 
create use-ega
1A32384 	75 73 65 2D 
1A32388 	65 67 61 87 80 23 A3  1 
1A32390 	30 40 A0  1 
create use-elf
1A32394 	75 73 65 2D 
1A32398 	65 6C 66 87 90 23 A3  1 
1A323A0 	30 40 A0  1 
\ create use-ne2000
create use-watch-all
1A323A4 	 0  0 75 73 
1A323A8 	65 2D 77 61 74 63 68 2D 
1A323B0 	61 6C 6C 8D A0 23 A3  1 
1A323B8 	30 40 A0  1 
create use-null-nvram
1A323BC 	 0 75 73 65 
1A323C0 	2D 6E 75 6C 6C 2D 6E 76 
1A323C8 	72 61 6D 8E B8 23 A3  1 
1A323D0 	30 40 A0  1 
\ create no-floppy-node


OpenFirmware/cpu/x86/pc/biosload/config.fth_AL	FC 1A323D4 purpose: Establish address and I/O configuration definitions

\ Dropin-base is where the set of dropin modules, the verbatim
\ image of what is stored in ROM or on disk, ends up in memory.
\ If OFW is in FLASH, dropin-base can just be the FLASH address.
\ If OFW is pulled in from disk, dropin-base is where the very
\ early startup code - the first few instructions in the image -
\ copies it to get it out of the way of things like OS load areas.

[ifdef] coreboot-loaded
  [ifdef] coreboot-qemu
    \ when running in qemu OFW is not in ROM but loaded to RAM by elfboot
    h# 198.0080 constant dropin-base  \ Location of payload in RAM
    dropin-base h# 20 +  constant ResetBase	\ Location of "reset" dropin in RAM
  [else]
    h# fff8.0000 constant dropin-base  \ Location of payload in FLASH
    dropin-base h# 80 + h# 20 +  constant ResetBase	\ Location of "reset" dropin in ROM
  [then]
  h#   08.0000 constant dropin-size
[then]

[ifdef] virtualbox-loaded
  h#   f0.0000 constant dropin-base  \ Location of payload in RAM
  h#   08.0000 constant dropin-size
  h#    1.0000 constant dma-base  \ DMA heap
  h#    8.0000 constant dma-size

[then]

[ifdef] preof-loaded
h# 2000.0000 constant ramsize
h# fff8.0020 constant dropin-base  \ Location of payload in ROM
h#   08.0000 constant dropin-size
[then]

[ifdef] via-demo
\ Don't assume a lot of memory (256M for most versions, 128M for a few)
\needs fw-pa      h#  e00.0000 constant fw-pa     \ OFW dictionary location
\needs /fw-ram    h#   20.0000 constant /fw-ram

\needs heap-base  h#  e20.0000 constant heap-base \ Dynamic allocation heap
\needs heap-size  h#   20.0000 constant heap-size

\needs dma-base   h#  e40.0000 constant dma-base  \ DMA heap
\needs dma-size   h#   20.0000 constant dma-size

                  h#  e60.0000 constant dropin-base  \ Location of payload in RAM
                  h#   08.0000 constant dropin-size
[then]

\needs dropin-base  h# 198.0000 constant dropin-base
1A323D4 	64 72 6F 70 
1A323D8 	69 6E 2D 62 61 73 65 8B 
1A323E0 	D0 23 A3  1 68 40 A0  1 
1A323E8 	 0  0 98  1 
\needs dropin-size  h#   8.0000 constant dropin-size
1A323EC 	64 72 6F 70 
1A323F0 	69 6E 2D 73 69 7A 65 8B 
1A323F8 	E4 23 A3  1 68 40 A0  1 
1A32400 	 0  0  8  0 
\needs ResetBase    dropin-base h# 20 +  constant ResetBase	\ Location of "reset" dropin in ROM
1A32404 	 0  0 72 65 
1A32408 	73 65 74 62 61 73 65 89 
1A32410 	FC 23 A3  1 68 40 A0  1 
1A32418 	20  0 98  1 

[ifdef] syslinux-loaded
\ This fits nicely with my VIA board that has "only" 256 MiB of memory
\needs fw-pa      h# 1d80.0000 constant fw-pa     \ OFW dictionary location
\needs /fw-ram    h#   20.0000 constant /fw-ram

\needs heap-base  h# 1da0.0000 constant heap-base \ Dynamic allocation heap
\needs heap-size  h#   20.0000 constant heap-size

\needs dma-base   h# 1dc0.0000 constant dma-base  \ DMA heap
\needs dma-size   h#   20.0000 constant dma-size
[then]

[ifndef] fw-pa
\ This is considerably more memory than Open Firmware needs
\ on platforms where you have a well bounded set of I/O devices.

\needs fw-pa      h# 1a0.0000 constant fw-pa     \ OFW dictionary location
1A3241C 	 0  0 66 77 
1A32420 	2D 70 61 85 14 24 A3  1 
1A32428 	68 40 A0  1  0  0 A0  1 
\needs /fw-ram    h#  20.0000 constant /fw-ram
1A32430 	2F 66 77 2D 72 61 6D 87 
1A32438 	28 24 A3  1 68 40 A0  1 
1A32440 	 0  0 20  0 

\needs heap-base  h# 1c0.0000 constant heap-base \ Dynamic allocation heap
1A32444 	 0  0 68 65 
1A32448 	61 70 2D 62 61 73 65 89 
1A32450 	3C 24 A3  1 68 40 A0  1 
1A32458 	 0  0 C0  1 
\needs heap-size  h#  20.0000 constant heap-size
1A3245C 	 0  0 68 65 
1A32460 	61 70 2D 73 69 7A 65 89 
1A32468 	54 24 A3  1 68 40 A0  1 
1A32470 	 0  0 20  0 

\needs dma-base   h# 1e0.0000 constant dma-base  \ DMA heap
1A32474 	 0  0  0 64 
1A32478 	6D 61 2D 62 61 73 65 88 
1A32480 	6C 24 A3  1 68 40 A0  1 
1A32488 	 0  0 E0  1 
\needs dma-size   h#  20.0000 constant dma-size
1A3248C 	 0  0  0 64 
1A32490 	6D 61 2D 73 69 7A 65 88 
1A32498 	84 24 A3  1 68 40 A0  1 
1A324A0 	 0  0 20  0 
[then]

\ Where OFW initially loads an OS that is is going to boot

h# 100.0000 constant def-load-base      \ Convenient for initrd
1A324A4 	 0  0 64 65 
1A324A8 	66 2D 6C 6F 61 64 2D 62 
1A324B0 	61 73 65 8D 9C 24 A3  1 
1A324B8 	68 40 A0  1  0  0  0  1 


OpenFirmware/cpu/x86/pc/biosload/addrs.fth_AL	EC 1A324C0 purpose: Defines Open Firmware virtual address space

\ Low RAM
h#     580 constant gdt-pa   \ Above the BDA, below the MBR area at 600
1A324C0 	 0 67 64 74 2D 70 61 86 
1A324C8 	B8 24 A3  1 68 40 A0  1 
1A324D0 	80  5  0  0 
h#      80 constant gdt-size
1A324D4 	 0  0  0 67 
1A324D8 	64 74 2D 73 69 7A 65 88 
1A324E0 	CC 24 A3  1 68 40 A0  1 
1A324E8 	80  0  0  0 

h#    1000 constant mem-info-pa
1A324EC 	6D 65 6D 2D 
1A324F0 	69 6E 66 6F 2D 70 61 8B 
1A324F8 	E4 24 A3  1 68 40 A0  1 
1A32500 	 0 10  0  0 
h#  9.fc00 constant 'ebda    \ Extended BIOS Data Area, which we co-opt for our
1A32504 	 0  0 27 65 
1A32508 	62 64 61 85 FC 24 A3  1 
1A32510 	68 40 A0  1  0 FC  9  0 

[ifdef] virtual-mode
h#    2000 constant pdir-pa
h#    3000 constant pt-pa
h# ff80.0000 value fw-virt-base
h# 0040.0000 value fw-virt-size
[else]
fw-pa value fw-virt-base
1A32518 	 0  0  0 66 77 2D 76 69 
1A32520 	72 74 2D 62 61 73 65 8C 
1A32528 	10 25 A3  1 50 40 A0  1 
1A32530 	F0  9  0  0 
0 value fw-virt-size
1A32534 	 0  0  0 66 
1A32538 	77 2D 76 69 72 74 2D 73 
1A32540 	69 7A 65 8C 2C 25 A3  1 
1A32548 	50 40 A0  1 F4  9  0  0 
[then]

OpenFirmware/cpu/x86/pc/virtaddr.fth_AL	90 1A32550 1A32670 1A32690 1A326B0 id: @(#)memlist.fth 2.9 05/04/08
purpose: Common routines for memory list manipulation

headers
listnode
   /n field >adr
1A326BC 	 0  0  0 3E 
1A326C0 	61 64 72 84 50 26 A3  1 
1A326C8 	50 EE A0  1  4  0  0  0 
   /n field >size
1A326D0 	 0  0 3E 73 69 7A 65 85 
1A326D8 	C8 26 A3  1 50 EE A0  1 
1A326E0 	 8  0  0  0 
nodetype: memrange
1A326E4 	 0  0  0 6D 
1A326E8 	65 6D 72 61 6E 67 65 88 
1A326F0 	DC 26 A3  1 AC 71 A1  1 
1A326F8 	 0  A  0  0 

headerless
\ local variable for use by memory list code
0 value prev-node	\ The node preceding (above) the insertion point
1A326FC 	 0  0 70 72 
1A32700 	65 76 2D 6E 6F 64 65 89 
1A32708 	F4 26 A3  1 50 40 A0  1 
1A32710 	 8  A  0  0 
0 value next-node	\ The node following (below) the insertion point
1A32714 	 0  0 6E 65 
1A32718 	78 74 2D 6E 6F 64 65 89 
1A32720 	 C 27 A3  1 50 40 A0  1 
1A32728 	 C  A  0  0 
0 value memlist		\ The memory list we're working on
1A3272C 	6D 65 6D 6C 
1A32730 	69 73 74 87 24 27 A3  1 
1A32738 	50 40 A0  1 10  A  0  0 
defer ?splice	( adr node -- )  \ Routine to free spanning resources
1A32740 	3F 73 70 6C 69 63 65 87 
1A32748 	38 27 A3  1 5C 40 A0  1 
1A32750 	14  A  0  0 

headers
: node-range  ( node -- adr size )  dup >adr @  swap >size @  ;
1A32754 	 0 6E 6F 64 
1A32758 	65 2D 72 61 6E 67 65 8A 
1A32760 	4C 27 A3  1 20 40 A0  1 
1A32768 	40 49 A0  1 C8 26 A3  1 
1A32770 	5C 4C A0  1 68 49 A0  1 
1A32778 	DC 26 A3  1 5C 4C A0  1 
1A32780 	58 46 A0  1 
headerless
\ Convenience functions

: prev-start  ( -- adr )  prev-node >adr @  ;
1A32784 	 0 70 72 65 
1A32788 	76 2D 73 74 61 72 74 8A 
1A32790 	64 27 A3  1 20 40 A0  1 
1A32798 	 C 27 A3  1 C8 26 A3  1 
1A327A0 	5C 4C A0  1 58 46 A0  1 
: next-end  ( -- adr )  next-node node-range +  ;
1A327A8 	 0  0  0 6E 65 78 74 2D 
1A327B0 	65 6E 64 88 94 27 A3  1 
1A327B8 	20 40 A0  1 24 27 A3  1 
1A327C0 	64 27 A3  1  4 45 A0  1 
1A327C8 	58 46 A0  1 

\ Allocates and initializes a new memory node
headers
: set-node  ( adr size -- node )
1A327CC 	 0  0  0 73 
1A327D0 	65 74 2D 6E 6F 64 65 88 
1A327D8 	B8 27 A3  1 20 40 A0  1 
   memrange allocate-node                 ( adr' size' node )
1A327E0 	F4 26 A3  1 34 74 A1  1 
   tuck >size !  tuck >adr !              ( node )
1A327E8 	E8 46 A0  1 DC 26 A3  1 
1A327F0 	54 4D A0  1 E8 46 A0  1 
1A327F8 	C8 26 A3  1 54 4D A0  1 
;
1A32800 	58 46 A0  1 
headerless
\ Expands the address range adr,len out to page boundaries in both directions.

: >page-boundaries  ( adr len -- page-aligned-adr page-multiple-len )
1A32804 	 0  0  0 3E 
1A32808 	70 61 67 65 2D 62 6F 75 
1A32810 	6E 64 61 72 69 65 73 90 
1A32818 	DC 27 A3  1 20 40 A0  1 
   bounds                                        ( top-adr bottom-adr )
1A32820 	F0 6D A0  1 
   pagesize round-down  swap pagesize round-up   ( bottom-adr' top-adr' )
1A32824 	50 7F A2  1 
1A32828 	80 91 A0  1 68 49 A0  1 
1A32830 	50 7F A2  1 A4 91 A0  1 
   over -                                        ( adr' len' )
1A32838 	54 49 A0  1 18 45 A0  1 
;
1A32840 	58 46 A0  1 


\ Used with "find-node" to locate the pair of nodes around "adr"

: lower?  ( adr node -- adr flag )  >adr @  over u<=  ;
1A32844 	 0 6C 6F 77 
1A32848 	65 72 3F 86 1C 28 A3  1 
1A32850 	20 40 A0  1 C8 26 A3  1 
1A32858 	5C 4C A0  1 54 49 A0  1 
1A32860 	88 48 A0  1 58 46 A0  1 


\ Used with "find-node" to locate a memory node at least as big as "size"

: big-enough?  ( size node-adr -- size flag )  >size @  over u>=  ;
1A32868 	62 69 67 2D 65 6E 6F 75 
1A32870 	67 68 3F 8B 50 28 A3  1 
1A32878 	20 40 A0  1 DC 26 A3  1 
1A32880 	5C 4C A0  1 54 49 A0  1 
1A32888 	CC 48 A0  1 58 46 A0  1 


\ Handle possible singularity at 0
: handle-0  ( end-adr start-adr -- end-adr' start-adr' )
1A32890 	 0  0  0 68 61 6E 64 6C 
1A32898 	65 2D 30 88 78 28 A3  1 
1A328A0 	20 40 A0  1 
   2dup =  if  exit  then               \ Don't do it for 0-length ranges
1A328A4 	C0 49 A0  1 
1A328A8 	24 48 A0  1 DC 41 A0  1 
1A328B0 	 8  0  0  0 40 46 A0  1 
   over  0=  if  nip -1 swap  then
1A328B8 	54 49 A0  1 24 47 A0  1 
1A328C0 	DC 41 A0  1 14  0  0  0 
1A328C8 	FC 46 A0  1 58 41 A0  1 
1A328D0 	FF FF FF FF 68 49 A0  1 
;
1A328D8 	58 46 A0  1 

\ Used with "find-node" to locate a memory node containing the range adr,len

: (contained?)  ( adr1 len1 adr2 len2 -- adr1 len1 flag )
1A328DC 	 0  0  0 28 
1A328E0 	63 6F 6E 74 61 69 6E 65 
1A328E8 	64 3F 29 8C A0 28 A3  1 
1A328F0 	20 40 A0  1 
   bounds handle-0              ( adr len  node-end node-start )
1A328F4 	F0 6D A0  1 
1A328F8 	A0 28 A3  1 
   2over bounds handle-0        ( adr len  node-end,start end,start )
1A328FC 	D8 49 A0  1 
1A32900 	F0 6D A0  1 A0 28 A3  1 
   rot u>= -rot  u>=  and       ( adr len flag )
1A32908 	7C 49 A0  1 CC 48 A0  1 
1A32910 	94 49 A0  1 CC 48 A0  1 
1A32918 	5C 44 A0  1 
;
1A3291C 	58 46 A0  1 
: contained?  ( adr len node-adr -- adr len flag )  node-range  (contained?)  ;
1A32920 	 0 63 6F 6E 74 61 69 6E 
1A32928 	65 64 3F 8A F0 28 A3  1 
1A32930 	20 40 A0  1 64 27 A3  1 
1A32938 	F0 28 A3  1 58 46 A0  1 

\ Frees the range of memory "adr size", adding it to the free list "list".
\ Every attempt is made to add the memory range to an existing node, and
\ to join adjacent nodes into one larger node.  When memory is added to an
\ existing node, or when nodes are joined, the defer word "?splice" is
\ called with the join address as an argument, allowing for spanning
\ resources (e.g. PMEGS) to be freed if possible.
: free-memrange  ( adr size list -- )
1A32940 	 0  0 66 72 65 65 2D 6D 
1A32948 	65 6D 72 61 6E 67 65 8D 
1A32950 	30 29 A3  1 20 40 A0  1 
   over 0=  if  3drop exit  then
1A32958 	54 49 A0  1 24 47 A0  1 
1A32960 	DC 41 A0  1  C  0  0  0 
1A32968 	90 52 A0  1 40 46 A0  1 
   is memlist                             ( adr size )
1A32970 	B8 40 A0  1 38 27 A3  1 

   swap memlist  ['] lower?  find-node    ( size adr prev-node this-node|0 )
1A32978 	68 49 A0  1 38 27 A3  1 
1A32980 	60 53 A0  1 50 28 A3  1 
1A32988 	88 72 A1  1 
   is next-node  is prev-node             ( size adr )
1A3298C 	B8 40 A0  1 
1A32990 	24 27 A3  1 B8 40 A0  1 
1A32998 	 C 27 A3  1 

   \ Error check to catch attempts to free already-free memory.

   next-node  if                          ( size adr )
1A3299C 	24 27 A3  1 
1A329A0 	DC 41 A0  1 48  0  0  0 
      dup  next-node >adr @  next-end  within
1A329A8 	40 49 A0  1 24 27 A3  1 
1A329B0 	C8 26 A3  1 5C 4C A0  1 
1A329B8 	B8 27 A3  1  8 71 A0  1 
      abort" Freeing memory that is already free"
1A329C0 	 8 81 A0  1 23 46 72 65 
1A329C8 	65 69 6E 67 20 6D 65 6D 
1A329D0 	6F 72 79 20 74 68 61 74 
1A329D8 	20 69 73 20 61 6C 72 65 
1A329E0 	61 64 79 20 66 72 65 65 
1A329E8 	 0  0  0  0 
   then                                   ( size adr )

   \ Try to add this node to the end of the lower piece in the available list

   next-node  if                          ( size adr )
1A329EC 	24 27 A3  1 
1A329F0 	DC 41 A0  1 A8  0  0  0 
      dup next-end =  if                  ( size adr )
1A329F8 	40 49 A0  1 B8 27 A3  1 
1A32A00 	24 48 A0  1 DC 41 A0  1 
1A32A08 	94  0  0  0 

         \ This piece can be added to the end of the lower piece

         swap  next-node >size +!         ( adr )
1A32A0C 	68 49 A0  1 
1A32A10 	24 27 A3  1 DC 26 A3  1 
1A32A18 	 C 4C A0  1 
	 next-node ?splice                ( )  \ Perhaps free PMEG
1A32A1C 	24 27 A3  1 
1A32A20 	4C 27 A3  1 

	 \ Now try to collapse 2 adjacent nodes
	 prev-node memlist <>  if                             ( )
1A32A24 	 C 27 A3  1 
1A32A28 	38 27 A3  1 44 48 A0  1 
1A32A30 	DC 41 A0  1 64  0  0  0 
	    next-end prev-start =  if                         ( )
1A32A38 	B8 27 A3  1 94 27 A3  1 
1A32A40 	24 48 A0  1 DC 41 A0  1 
1A32A48 	50  0  0  0 
               next-end                                       ( splice-adr )
1A32A4C 	B8 27 A3  1 
               next-node >size @  prev-node >size +!          ( splice-adr )
1A32A50 	24 27 A3  1 DC 26 A3  1 
1A32A58 	5C 4C A0  1  C 27 A3  1 
1A32A60 	DC 26 A3  1  C 4C A0  1 
               next-node >adr  @  prev-node >adr   !          ( splice-adr )
1A32A68 	24 27 A3  1 C8 26 A3  1 
1A32A70 	5C 4C A0  1  C 27 A3  1 
1A32A78 	C8 26 A3  1 54 4D A0  1 
	       prev-node delete-after  memrange free-node     ( splice-adr )
1A32A80 	 C 27 A3  1 58 72 A1  1 
1A32A88 	F4 26 A3  1 88 74 A1  1 
               prev-node ?splice          ( )  \ Perhaps free PMEG
1A32A90 	 C 27 A3  1 4C 27 A3  1 
	    then
         then

         exit
1A32A98 	40 46 A0  1 
      then
   then

   \ Try to add this node to the start of the upper piece in the available list
   prev-node memlist <>  if               ( size adr )
1A32A9C 	 C 27 A3  1 
1A32AA0 	38 27 A3  1 44 48 A0  1 
1A32AA8 	DC 41 A0  1 48  0  0  0 
      2dup +  prev-start =  if            ( size adr )
1A32AB0 	C0 49 A0  1  4 45 A0  1 
1A32AB8 	94 27 A3  1 24 48 A0  1 
1A32AC0 	DC 41 A0  1 30  0  0  0 
         2dup prev-node >adr !            ( size adr size )
1A32AC8 	C0 49 A0  1  C 27 A3  1 
1A32AD0 	C8 26 A3  1 54 4D A0  1 
         prev-node >size +!               ( size adr )
1A32AD8 	 C 27 A3  1 DC 26 A3  1 
1A32AE0 	 C 4C A0  1 
         +  prev-node ?splice             ( )  \ Perhaps free PMEG
1A32AE4 	 4 45 A0  1 
1A32AE8 	 C 27 A3  1 4C 27 A3  1 
	 exit
1A32AF0 	40 46 A0  1 
      then
   then                                   ( size adr )

   \ Oh bother!  We have to create another node
   swap set-node prev-node insert-after
1A32AF4 	68 49 A0  1 
1A32AF8 	DC 27 A3  1  C 27 A3  1 
1A32B00 	28 72 A1  1 
;
1A32B04 	58 46 A0  1 

: suitable?  ( alignment size node-adr -- alignment size flag )
1A32B08 	 0  0 73 75 69 74 61 62 
1A32B10 	6C 65 3F 89 54 29 A3  1 
1A32B18 	20 40 A0  1 
   >r r@ >adr @  2 pick round-up          ( alignment size aligned-adr )
1A32B1C 	BC 45 A0  1 
1A32B20 	E4 45 A0  1 C8 26 A3  1 
1A32B28 	5C 4C A0  1 90 6F A0  1 
1A32B30 	 C 4A A0  1 A4 91 A0  1 
   r> node-range -rot -                   ( alignment size node-size waste )
1A32B38 	D0 45 A0  1 64 27 A3  1 
1A32B40 	94 49 A0  1 18 45 A0  1 
   2dup u<=  if  2drop false  exit  then  ( alignment size node-size waste )
1A32B48 	C0 49 A0  1 88 48 A0  1 
1A32B50 	DC 41 A0  1 10  0  0  0 
1A32B58 	AC 49 A0  1 18 70 A0  1 
1A32B60 	40 46 A0  1 
   -                                      ( alignment size aln-node-size )
1A32B64 	18 45 A0  1 
   over u>=                               ( alignment size flag )
1A32B68 	54 49 A0  1 CC 48 A0  1 
;   
1A32B70 	58 46 A0  1 
: end-piece-aligned?  ( aln size -- flag )
1A32B74 	 0 65 6E 64 
1A32B78 	2D 70 69 65 63 65 2D 61 
1A32B80 	6C 69 67 6E 65 64 3F 92 
1A32B88 	18 2B A3  1 20 40 A0  1 
   next-end           ( aln size end-adr )
1A32B90 	B8 27 A3  1 
   swap - dup rot     ( adr adr aln )
1A32B94 	68 49 A0  1 
1A32B98 	18 45 A0  1 40 49 A0  1 
1A32BA0 	7C 49 A0  1 
   round-up =         ( flag )
1A32BA4 	A4 91 A0  1 
1A32BA8 	24 48 A0  1 
;
1A32BAC 	58 46 A0  1 

: allocate-memrange  ( alignment size list -- phys-adr false | true )
1A32BB0 	 0  0 61 6C 6C 6F 63 61 
1A32BB8 	74 65 2D 6D 65 6D 72 61 
1A32BC0 	6E 67 65 91 8C 2B A3  1 
1A32BC8 	20 40 A0  1 

   ['] suitable?  find-node is next-node  is prev-node ( aln+ size+ )
1A32BCC 	60 53 A0  1 
1A32BD0 	18 2B A3  1 88 72 A1  1 
1A32BD8 	B8 40 A0  1 24 27 A3  1 
1A32BE0 	B8 40 A0  1  C 27 A3  1 

   next-node 0=  if  2drop true  exit  then               ( aln+ size+ )
1A32BE8 	24 27 A3  1 24 47 A0  1 
1A32BF0 	DC 41 A0  1 10  0  0  0 
1A32BF8 	AC 49 A0  1  4 70 A0  1 
1A32C00 	40 46 A0  1 

   2dup  end-piece-aligned?  if                           ( aln+ size+ )
1A32C04 	C0 49 A0  1 
1A32C08 	8C 2B A3  1 DC 41 A0  1 
1A32C10 	64  0  0  0 
      dup  next-node >size @ =  if                        ( aln+ size+ )
1A32C14 	40 49 A0  1 
1A32C18 	24 27 A3  1 DC 26 A3  1 
1A32C20 	5C 4C A0  1 24 48 A0  1 
1A32C28 	DC 41 A0  1 28  0  0  0 
         \ Node is exactly the right size; return the
         \ address and remove the node from the list
         next-node >adr @                                 ( aln+ size+ adr )
1A32C30 	24 27 A3  1 C8 26 A3  1 
1A32C38 	5C 4C A0  1 
         prev-node delete-after  memrange free-node       ( aln+ size+ adr )
1A32C3C 	 C 27 A3  1 
1A32C40 	58 72 A1  1 F4 26 A3  1 
1A32C48 	88 74 A1  1 
      else                                                ( aln+ size+ )
1A32C4C 	C8 41 A0  1 
1A32C50 	1C  0  0  0 
         \ Node is bigger than requested size.  Decrease the size of the
         \ node's region and return the last part of its address range.
         dup negate next-node >size +!                    ( aln+ size+ )
1A32C54 	40 49 A0  1 
1A32C58 	48 45 A0  1 24 27 A3  1 
1A32C60 	DC 26 A3  1  C 4C A0  1 
         next-end                                         ( aln+ size+ adr )
1A32C68 	B8 27 A3  1 
      then
   else         \ The piece was not already aligned       ( aln+ size+ )
1A32C6C 	C8 41 A0  1 
1A32C70 	8C  0  0  0 

      \ Change the size of the current node to reflect only the
      \ fragment after the allocated piece.

      next-end  over - 2 pick round-down                  ( aln+ size+ adr )
1A32C74 	B8 27 A3  1 
1A32C78 	54 49 A0  1 18 45 A0  1 
1A32C80 	90 6F A0  1  C 4A A0  1 
1A32C88 	80 91 A0  1 
      2dup +  dup  next-end swap -      ( aln+ size+ adr frag-adr frag-len )
1A32C8C 	C0 49 A0  1 
1A32C90 	 4 45 A0  1 40 49 A0  1 
1A32C98 	B8 27 A3  1 68 49 A0  1 
1A32CA0 	18 45 A0  1 
      next-node >adr @ >r                                 \ Save for later
1A32CA4 	24 27 A3  1 
1A32CA8 	C8 26 A3  1 5C 4C A0  1 
1A32CB0 	BC 45 A0  1 
      next-node >size !  next-node >adr !                 ( aln+ size+ adr )
1A32CB4 	24 27 A3  1 
1A32CB8 	DC 26 A3  1 54 4D A0  1 
1A32CC0 	24 27 A3  1 C8 26 A3  1 
1A32CC8 	54 4D A0  1 

      r> 2dup -                         ( aln+ size+ adr frag-adr frag-len )
1A32CCC 	D0 45 A0  1 
1A32CD0 	C0 49 A0  1 18 45 A0  1 
      dup if                            ( aln+ size+ adr frag-adr frag-len )
1A32CD8 	40 49 A0  1 DC 41 A0  1 
1A32CE0 	18  0  0  0 
         \ Create a new node for the fragment before the allocated range.
         \ We don't have to worry about splicing it to adjacent nodes,
         \ because we know that it came from the beginning of an existing
         \ separate node.
         set-node next-node insert-after                  ( aln+ size+ adr )
1A32CE4 	DC 27 A3  1 
1A32CE8 	24 27 A3  1 28 72 A1  1 
      else                              ( aln+ size+ adr frag-adr frag-len )
1A32CF0 	C8 41 A0  1  8  0  0  0 
         \ There is no fragment before the allocated range.
         2drop                                            ( aln+ size+ adr )
1A32CF8 	AC 49 A0  1 
      then                                                ( aln+ size+ adr )
   then                                                   ( aln+ size+ adr )
   nip nip  false                                         ( adr false )
1A32CFC 	FC 46 A0  1 
1A32D00 	FC 46 A0  1 18 70 A0  1 
;
1A32D08 	58 46 A0  1 
headers

OpenFirmware/ofw/core/memlist.fth_AL	650 1A32D0C 
propset=1A32D54 B4423A7 1A00A60 
vocset=B4423A7 1A00A60 1A32D54 
new-node=B4423BB 1A00A40 
vocset=B4423BB 1A00A40 1A32D54 
memory
1A32D64 
99D1324   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99D1334   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................purpose: Allocator for physical memory - 1-cell version

\ Methods:

\ claim  ( [ phys ] size alignment -- base )
\       If "alignment" is non-zero, allocates at least "size" bytes of
\	physical memory aligned on the indicated boundary, returning
\	its address "base".  This implementation rounds
\	"alignment" up to a multiple of the page size.
\
\	If "alignment" is zero, removes the range of physical memory
\	denoted by phys and size from the list of available
\	physical memory, returning "base" equal to "phys"
\
\ release  ( phys size -- )
\	Frees the physical memory range denoted by phys and size.

\ clear-mem is a deferred word so that a system-dependent implementation,
\ perhaps using bzero hardware, can be installed in the system-dependent
\ part of the load sequence.

headerless
defer clear-mem  ( phys size -- )  ' 2drop is clear-mem
1A32D0C 	 0  0 63 6C 
1A32D10 	65 61 72 2D 6D 65 6D 89 
1A32D18 	C8 2B A3  1 5C 40 A0  1 
1A32D20 	18  A  0  0 
defer initial-memory  ( -- adr len )  ' no-memory to initial-memory
1A32D24 	 0 69 6E 69 
1A32D28 	74 69 61 6C 2D 6D 65 6D 
1A32D30 	6F 72 79 8E 1C 2D A3  1 
1A32D38 	5C 40 A0  1 1C  A  0  0 

headers
root-device
new-device  current-device-t to memory-device \ mmo
1A32D40 	E0 B6 A0  1 20  A  0  0 
1A32D48 	B8 10 A2  1 E0 B6 A0  1 
1A32D50 	40  A  0  0 

" memory" device-name
1A32D54 	6D 65 6D 6F 
1A32D58 	72 79  0 6E 61 6D 65 84 
1A32D60 	 0  0 A0  1 BC 13 A2  1 
1A32D68 	14  0  0  0  7  0  0  0 

list: physavail   0 physavail !
1A32D70 	 0  0 70 68 79 73 61 76 
1A32D78 	61 69 6C 89  0  0 A0  1 
1A32D80 	48 40 A0  1 44  A  0  0 

headers
: first-phys-avail  ( -- phys size )
1A32D88 	 0  0  0 66 69 72 73 74 
1A32D90 	2D 70 68 79 73 2D 61 76 
1A32D98 	61 69 6C 90 80 2D A3  1 
1A32DA0 	20 40 A0  1 
   physavail last-node node-range  ( phys size )
1A32DA4 	80 2D A3  1 
1A32DA8 	6C 73 A1  1 64 27 A3  1 
;
1A32DB0 	58 46 A0  1 
headerless

: accum-size  ( total node -- total' false )  >size @ +  false  ;
1A32DB4 	 0 61 63 63 
1A32DB8 	75 6D 2D 73 69 7A 65 8A 
1A32DC0 	A0 2D A3  1 20 40 A0  1 
1A32DC8 	DC 26 A3  1 5C 4C A0  1 
1A32DD0 	 4 45 A0  1 18 70 A0  1 
1A32DD8 	58 46 A0  1 
: total-size  ( list -- size )
1A32DDC 	 0 74 6F 74 
1A32DE0 	61 6C 2D 73 69 7A 65 8A 
1A32DE8 	C4 2D A3  1 20 40 A0  1 
   0 swap ['] accum-size find-node  2drop
1A32DF0 	70 6F A0  1 68 49 A0  1 
1A32DF8 	60 53 A0  1 C4 2D A3  1 
1A32E00 	88 72 A1  1 AC 49 A0  1 
;
1A32E08 	58 46 A0  1 

: (claim-phys-callback)
1A32E0C 	 0  0 28 63 
1A32E10 	6C 61 69 6D 2D 70 68 79 
1A32E18 	73 2D 63 61 6C 6C 62 61 
1A32E20 	63 6B 29 95 EC 2D A3  1 
1A32E28 	20 40 A0  1 
   ( aln|adr size  aln size max min -- aln|adr size false | phys true )
   4 " claim-phys"  ($callback)  if                 ( adr size )
1A32E2C 	B0 6F A0  1 
1A32E30 	9C 53 A0  1  A 63 6C 61 
1A32E38 	69 6D 2D 70 68 79 73  0 
1A32E40 	9C A4 A2  1 DC 41 A0  1 
1A32E48 	10  0  0  0 
      \ There was no "claim-phys" callback, so we return false to
      \ indicate that the firmware should proceed.
      false                                       ( adr size false )
1A32E4C 	18 70 A0  1 
   else                                           ( adr size  [ phys ] err? n )
1A32E50 	C8 41 A0  1 18  0  0  0 
      \ There was a "claim-phys" callback.  If it succeeded, we return
      \ the result under true to indicate that the operation has
      \ been performed.  If it failed, we throw the error because we
      \ are no longer in charge of allocation services.
      drop throw                                  ( aln size phys )
1A32E58 	30 49 A0  1 74 7F A0  1 
      nip nip true
1A32E60 	FC 46 A0  1 FC 46 A0  1 
1A32E68 	 4 70 A0  1 
   then      
;
1A32E6C 	58 46 A0  1 
: alloc-phys-callback?  ( aln size -- aln size false | phys true )
1A32E70 	 0  0  0 61 6C 6C 6F 63 
1A32E78 	2D 70 68 79 73 2D 63 61 
1A32E80 	6C 6C 62 61 63 6B 3F 94 
1A32E88 	28 2E A3  1 20 40 A0  1 
   2dup  -1 0  (claim-phys-callback)
1A32E90 	C0 49 A0  1 58 41 A0  1 
1A32E98 	FF FF FF FF 70 6F A0  1 
1A32EA0 	28 2E A3  1 
;
1A32EA4 	58 46 A0  1 
: claim-phys-callback?  ( adr size -- adr size false | phys true )
1A32EA8 	 0  0  0 63 6C 61 69 6D 
1A32EB0 	2D 70 68 79 73 2D 63 61 
1A32EB8 	6C 6C 62 61 63 6B 3F 94 
1A32EC0 	8C 2E A3  1 20 40 A0  1 
   2dup  pagesize -rot swap dup  (claim-phys-callback)
1A32EC8 	C0 49 A0  1 50 7F A2  1 
1A32ED0 	94 49 A0  1 68 49 A0  1 
1A32ED8 	40 49 A0  1 28 2E A3  1 
;
1A32EE0 	58 46 A0  1 
: release-phys-callback?  ( adr size -- true | adr size false )
1A32EE4 	 0 72 65 6C 
1A32EE8 	65 61 73 65 2D 70 68 79 
1A32EF0 	73 2D 63 61 6C 6C 62 61 
1A32EF8 	63 6B 3F 96 C4 2E A3  1 
1A32F00 	20 40 A0  1 
   2dup 2  " release-phys"  ($callback)  if       ( adr size )
1A32F04 	C0 49 A0  1 
1A32F08 	90 6F A0  1 9C 53 A0  1 
1A32F10 	 C 72 65 6C 65 61 73 65 
1A32F18 	2D 70 68 79 73  0  0  0 
1A32F20 	9C A4 A2  1 DC 41 A0  1 
1A32F28 	10  0  0  0 
      \ There was no "release-phys" callback, so we return false to
      \ indicate that the firmware should proceed.
      false                                       ( adr size false )
1A32F2C 	18 70 A0  1 
   else                                           ( adr size  err? n )
1A32F30 	C8 41 A0  1 10  0  0  0 
      \ There was a "release-phys" callback.  If it failed, oh well.
      \ Discard the arguments and return true to indicate that the
      \ operation has been done.
      2drop 2drop true
1A32F38 	AC 49 A0  1 AC 49 A0  1 
1A32F40 	 4 70 A0  1 
   then      
;
1A32F44 	58 46 A0  1 

: allocate-aligned-physical  ( alignment size -- phys )
1A32F48 	 0  0 61 6C 6C 6F 63 61 
1A32F50 	74 65 2D 61 6C 69 67 6E 
1A32F58 	65 64 2D 70 68 79 73 69 
1A32F60 	63 61 6C 99  0 2F A3  1 
1A32F68 	20 40 A0  1 
   \ Minumum granularity of memory chunks is 1 page
   swap pagesize round-up
1A32F6C 	68 49 A0  1 
1A32F70 	50 7F A2  1 A4 91 A0  1 
   swap pagesize round-up			( aln+ size+ )
1A32F78 	68 49 A0  1 50 7F A2  1 
1A32F80 	A4 91 A0  1 

   alloc-phys-callback?  if  exit  then         ( aln+ size+ )
1A32F84 	8C 2E A3  1 
1A32F88 	DC 41 A0  1  8  0  0  0 
1A32F90 	40 46 A0  1 

   tuck physavail				( size alignment size list )
1A32F94 	E8 46 A0  1 
1A32F98 	80 2D A3  1 
   allocate-memrange				( size [ adr ] error? )
1A32F9C 	C8 2B A3  1 
   abort" Insufficient physical memory"		( size adr )
1A32FA0 	 8 81 A0  1 1C 49 6E 73 
1A32FA8 	75 66 66 69 63 69 65 6E 
1A32FB0 	74 20 70 68 79 73 69 63 
1A32FB8 	61 6C 20 6D 65 6D 6F 72 
1A32FC0 	79  0  0  0 
   dup rot clear-mem				( phys )
1A32FC4 	40 49 A0  1 
1A32FC8 	7C 49 A0  1 1C 2D A3  1 
;
1A32FD0 	58 46 A0  1 

variable allow-reclaim  true allow-reclaim !
1A32FD4 	 0  0 61 6C 
1A32FD8 	6C 6F 77 2D 72 65 63 6C 
1A32FE0 	61 69 6D 8D 68 2F A3  1 
1A32FE8 	48 40 A0  1 48  A  0  0 
: claim-physical  ( adr len -- )
1A32FF0 	 0 63 6C 61 69 6D 2D 70 
1A32FF8 	68 79 73 69 63 61 6C 8E 
1A33000 	E8 2F A3  1 20 40 A0  1 
   >page-boundaries                               ( adr' len' )
1A33008 	1C 28 A3  1 

   claim-phys-callback?  if  drop exit  then      ( adr' len' )
1A3300C 	C4 2E A3  1 
1A33010 	DC 41 A0  1  C  0  0  0 
1A33018 	30 49 A0  1 40 46 A0  1 

   \ Look first in the monitor's piece list
   physavail  ['] contained?  find-node           ( adr len prev next|0 )
1A33020 	80 2D A3  1 60 53 A0  1 
1A33028 	30 29 A3  1 88 72 A1  1 
   is next-node  is prev-node                     ( adr len )
1A33030 	B8 40 A0  1 24 27 A3  1 
1A33038 	B8 40 A0  1  C 27 A3  1 

   next-node 0=  if
1A33040 	24 27 A3  1 24 47 A0  1 
1A33048 	DC 41 A0  1 3C  0  0  0 
      allow-reclaim @  0=
1A33050 	E8 2F A3  1 5C 4C A0  1 
1A33058 	24 47 A0  1 
      abort" physical address already used"       ( adr len )
1A3305C 	 8 81 A0  1 
1A33060 	1D 70 68 79 73 69 63 61 
1A33068 	6C 20 61 64 64 72 65 73 
1A33070 	73 20 61 6C 72 65 61 64 
1A33078 	79 20 75 73 65 64  0  0 
      2drop  exit
1A33080 	AC 49 A0  1 40 46 A0  1 
   then

   \ There are 4 cases to consider in removing the requested physical
   \ address range from the list:
   \ (1) The requested range exactly matches the list node range
   \ (2) The requested range is at the beginning of the list node range
   \ (3) The requested range is at the end of the list node range
   \ (4) The requested range is in the middle of the list node range

   \ Remember the range of the node to be deleted
   next-node node-range                            ( adr len node-a,l )
1A33088 	24 27 A3  1 64 27 A3  1 

   \ Remove the node from the list
   prev-node delete-after  memrange free-node      ( adr len node-a,l )
1A33090 	 C 27 A3  1 58 72 A1  1 
1A33098 	F4 26 A3  1 88 74 A1  1 

   \ Give back any left-over portion at the beginning
   over 4 pick over -  dup  if            ( adr len node-a,l begin-a,l )
1A330A0 	54 49 A0  1 B0 6F A0  1 
1A330A8 	 C 4A A0  1 54 49 A0  1 
1A330B0 	18 45 A0  1 40 49 A0  1 
1A330B8 	DC 41 A0  1 14  0  0  0 
      physavail free-memrange
1A330C0 	80 2D A3  1 54 29 A3  1 
   else
1A330C8 	C8 41 A0  1  8  0  0  0 
      2drop
1A330D0 	AC 49 A0  1 
   then                                            ( adr len node-a,l )

   \ Give back any left-over portion at the end
   2swap +  -rot  +   over -                            ( end-a,l )
1A330D4 	F4 49 A0  1 
1A330D8 	 4 45 A0  1 94 49 A0  1 
1A330E0 	 4 45 A0  1 54 49 A0  1 
1A330E8 	18 45 A0  1 
   ?dup  if  physavail free-memrange  else  drop  then  (  )
1A330EC 	B4 70 A0  1 
1A330F0 	DC 41 A0  1 14  0  0  0 
1A330F8 	80 2D A3  1 54 29 A3  1 
1A33100 	C8 41 A0  1  8  0  0  0 
1A33108 	30 49 A0  1 
;
1A3310C 	58 46 A0  1 
headers
: claim ( [ phys ] size align -- base )
1A33110 	 0  0 63 6C 61 69 6D 85 
1A33118 	 4 30 A3  1 20 40 A0  1 
   ?dup  if                          ( size align )
1A33120 	B4 70 A0  1 DC 41 A0  1 
1A33128 	14  0  0  0 
      \ Alignment should be next power of two
      swap allocate-aligned-physical ( base )
1A3312C 	68 49 A0  1 
1A33130 	68 2F A3  1 
   else                              ( phys size )
1A33134 	C8 41 A0  1 
1A33138 	14  0  0  0 
      >r dup r> claim-physical       ( base )
1A3313C 	BC 45 A0  1 
1A33140 	40 49 A0  1 D0 45 A0  1 
1A33148 	 4 30 A3  1 
   then                              ( base )
;
1A3314C 	58 46 A0  1 
: release  ( phys size -- )
1A33150 	72 65 6C 65 61 73 65 87 
1A33158 	1C 31 A3  1 20 40 A0  1 
   >page-boundaries                         ( adr' size' )
1A33160 	1C 28 A3  1 
   release-phys-callback?  if  exit  then   ( adr' size' )
1A33164 	 0 2F A3  1 
1A33168 	DC 41 A0  1  8  0  0  0 
1A33170 	40 46 A0  1 
   ['] 2drop  is ?splice                    ( adr' size' )
1A33174 	60 53 A0  1 
1A33178 	AC 49 A0  1 98 40 A0  1 
1A33180 	4C 27 A3  1 
   physavail free-memrange
1A33184 	80 2D A3  1 
1A33188 	54 29 A3  1 
;
1A3318C 	58 46 A0  1 
: close  ( -- )  ;
1A33190 	 0  0 63 6C 6F 73 65 85 
1A33198 	5C 31 A3  1 20 40 A0  1 
1A331A0 	58 46 A0  1 
: open  ( -- ok? )
1A331A4 	 0  0  0 6F 
1A331A8 	70 65 6E 84 9C 31 A3  1 
1A331B0 	20 40 A0  1 
   physavail @  if  true exit  then
1A331B4 	80 2D A3  1 
1A331B8 	5C 4C A0  1 DC 41 A0  1 
1A331C0 	 C  0  0  0  4 70 A0  1 
1A331C8 	40 46 A0  1 
   initial-memory  dup  if   ( phys size )
1A331CC 	38 2D A3  1 
1A331D0 	40 49 A0  1 DC 41 A0  1 
1A331D8 	10  0  0  0 
      release
1A331DC 	5C 31 A3  1 
   else
1A331E0 	C8 41 A0  1  8  0  0  0 
      2drop
1A331E8 	AC 49 A0  1 
   then
   true
1A331EC 	 4 70 A0  1 
;
1A331F0 	58 46 A0  1 

-2 constant mode
1A331F4 	 0  0  0 6D 
1A331F8 	6F 64 65 84 B0 31 A3  1 
1A33200 	68 40 A0  1 FE FF FF FF 

finish-device
1A33208 	 0  0  0  0  0  0  0  0 
1A33210 	 0  0  0  0  0  0  0  0 
1A33218 	 0  0  0  0  0  0  0  0 
device-end

headers
stand-init: memory node
1A33220 	 0 73 74 61 6E 64 2D 69 
1A33228 	6E 69 74 8A 38 2D A3  1 
1A33230 	20 40 A0  1 2C 7E A2  1 
1A33238 	9C 53 A0  1  B 6D 65 6D 
1A33240 	6F 72 79 20 6E 6F 64 65 
1A33248 	 0  0  0  0 80 6D A0  1 
1A33250 	 4 6C A0  1 
   " /memory" open-dev  memory-node !
1A33254 	9C 53 A0  1 
1A33258 	 7 2F 6D 65 6D 6F 72 79 
1A33260 	 0  0  0  0 FC 3E A2  1 
1A33268 	58 7E A2  1 54 4D A0  1 
;
1A33270 	58 46 A0  1 

OpenFirmware/ofw/core/allocph1.fth_AL	568 1A33274 1A332CC 
99D23C4   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99D23D4   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................purpose: Root node methods for generic PC, beyond the generic 1-cell ones

: root-map-in  ( phys len -- virt )
1A33274 	72 6F 6F 74 
1A33278 	2D 6D 61 70 2D 69 6E 8B 
1A33280 	30 32 A3  1 20 40 A0  1 
[ifdef] virtual-mode
   " /" " map-in" execute-device-method drop
[else]
   drop
1A33288 	30 49 A0  1 
[then]
;
1A3328C 	58 46 A0  1 
: root-map-out  ( virt len -- )
1A33290 	 0  0  0 72 6F 6F 74 2D 
1A33298 	6D 61 70 2D 6F 75 74 8C 
1A332A0 	84 32 A3  1 20 40 A0  1 
[ifdef] virtual-mode
   " /" " map-out" execute-device-method drop
[else]
   2drop
1A332A8 	AC 49 A0  1 
[then]
;
1A332AC 	58 46 A0  1 

dev /
extend-package

" Generic PC" encode-string  " banner-name" property
1A332B0 	47 65 6E 65 72 69 63 20 
1A332B8 	50 43  0  0 62 61 6E 6E 
1A332C0 	65 72 2D 6E 61 6D 65 8B 
1A332C8 	B0 26 A3  1 BC 13 A2  1 
1A332D0 	20  0  0  0  B  0  0  0 

hex

\ Static methods
: decode-unit  ( adr len -- phys )  push-hex  $number  if  0  then  pop-base  ;
1A332D8 	64 65 63 6F 64 65 2D 75 
1A332E0 	6E 69 74 8B  0  0 A0  1 
1A332E8 	20 40 A0  1 5C F4 A0  1 
1A332F0 	40 FE A0  1 DC 41 A0  1 
1A332F8 	 8  0  0  0 70 6F A0  1 
1A33300 	9C F4 A0  1 58 46 A0  1 
: encode-unit  ( phys -- adr len )  push-hex  (u.)  pop-base  ;
1A33308 	65 6E 63 6F 64 65 2D 75 
1A33310 	6E 69 74 8B E8 32 A3  1 
1A33318 	20 40 A0  1 5C F4 A0  1 
1A33320 	AC 77 A0  1 9C F4 A0  1 
1A33328 	58 46 A0  1 

\ Not-necessarily-static methods
: open  ( -- true )  true  ;
1A3332C 	 0  0  0 6F 
1A33330 	70 65 6E 84 18 33 A3  1 
1A33338 	20 40 A0  1  4 70 A0  1 
1A33340 	58 46 A0  1 
: close  ( -- )  ;
1A33344 	 0  0 63 6C 
1A33348 	6F 73 65 85 38 33 A3  1 
1A33350 	20 40 A0  1 58 46 A0  1 

: map-in   ( phys size -- virt )
1A33358 	 0 6D 61 70 2D 69 6E 86 
1A33360 	50 33 A3  1 20 40 A0  1 
[ifdef] virtual-mode
   over  mmu-lowbits +  pagesize round-up >r   ( phys        r: size' )
   r@ pagesize mmu-claim                       ( phys virt   r: size' )
   >r  dup mmu-highbits                        ( phys phys'  r: size' virt )
   r> r>  over >r                 ( phys  phys' virt size    r: virt )
   -1 mmu-map                                  ( phys        r: virt )
   mmu-lowbits r> +                            ( virtual )
[else]
   drop
1A33368 	30 49 A0  1 
[then]
;
1A3336C 	58 46 A0  1 
: map-out  ( virtual size -- )
1A33370 	6D 61 70 2D 6F 75 74 87 
1A33378 	64 33 A3  1 20 40 A0  1 
[ifdef] virtual-mode
   2dup mmu-unmap  mmu-release
[else]
   2drop
1A33380 	AC 49 A0  1 
[then]
;
1A33384 	58 46 A0  1 

: dma-range  ( -- start end )  dma-base   dup dma-size +  ;
1A33388 	 0  0 64 6D 61 2D 72 61 
1A33390 	6E 67 65 89 7C 33 A3  1 
1A33398 	20 40 A0  1 84 24 A3  1 
1A333A0 	40 49 A0  1 9C 24 A3  1 
1A333A8 	 4 45 A0  1 58 46 A0  1 

0 [if]  \ This is fairly useless since the DMA ranges can be dynamic
\ We hereby establish the convention that the implied "#address-cells"
\ for the (nonexistent) parent of the root node is 0, so the parent
\ address portion of the ranges property is empty.
0 0 encode-bytes
   dma-base encode-int encode+  dma-size encode-int encode+
" dma-ranges" property
[then]

\ x86 caches are coherent
h# 3 constant dma-map-mode		\ Cacheable
1A333B0 	 0  0  0 64 6D 61 2D 6D 
1A333B8 	61 70 2D 6D 6F 64 65 8C 
1A333C0 	98 33 A3  1 68 40 A0  1 
1A333C8 	 3  0  0  0 

\ Used with "find-node" to locate a physical memory node containing
\ enough memory in the DMA range.
\ We first compute the intersection between the memory piece and the
\ range reachable by DMA.  If the regions are disjoint, then ok-high
\ will be (unsigned) less than ok-low.  We then subtract ok-low from
\ ok-high to give the (possibly negative) size of the intersection.
: in-range?  ( size mem-low mem-high range-low range-high -- flag )
1A333CC 	 0  0 69 6E 
1A333D0 	2D 72 61 6E 67 65 3F 89 
1A333D8 	C4 33 A3  1 20 40 A0  1 
   rot umin -rot              ( size min-high mem-low mem-high )
1A333E0 	7C 49 A0  1 4C 4A A0  1 
1A333E8 	94 49 A0  1 
   umax                       ( size min-high max-low )
1A333EC 	C8 4A A0  1 
   - <=                       ( flag )
1A333F0 	18 45 A0  1  C 49 A0  1 
;
1A333F8 	58 46 A0  1 

: dma-ok?  ( size node-adr -- size flag )
1A333FC 	64 6D 61 2D 
1A33400 	6F 6B 3F 87 DC 33 A3  1 
1A33408 	20 40 A0  1 
   node-range				 ( size mem-adr mem-len )
1A3340C 	64 27 A3  1 
   over +                                ( size mem-adr mem-end )
1A33410 	54 49 A0  1  4 45 A0  1 

   3dup dma-range in-range?  if          ( size mem-adr mem-end )
1A33418 	A4 52 A0  1 98 33 A3  1 
1A33420 	DC 33 A3  1 DC 41 A0  1 
1A33428 	10  0  0  0 
      2drop true exit                    ( size true )
1A3342C 	AC 49 A0  1 
1A33430 	 4 70 A0  1 40 46 A0  1 
   then                                  ( size mem-adr mem-end )

   2drop false                           ( size false )
1A33438 	AC 49 A0  1 18 70 A0  1 
;
1A33440 	58 46 A0  1 

\ Find an available physical address range suitable for DMA.  This word
\ doesn't actually claim the memory (that is done later), but simply locates
\ a suitable range that can be successfully claimed.
: find-dma-address  ( size -- true | adr false )
1A33444 	 0  0  0 66 
1A33448 	69 6E 64 2D 64 6D 61 2D 
1A33450 	61 64 64 72 65 73 73 90 
1A33458 	 8 34 A3  1 20 40 A0  1 
   " physavail" memory-node @ $call-method  	( list )
1A33460 	9C 53 A0  1  9 70 68 79 
1A33468 	73 61 76 61 69 6C  0  0 
1A33470 	58 7E A2  1 5C 4C A0  1 
1A33478 	B4 31 A2  1 
   ['] dma-ok?  find-node is next-node  drop	( size' )
1A3347C 	60 53 A0  1 
1A33480 	 8 34 A3  1 88 72 A1  1 
1A33488 	B8 40 A0  1 24 27 A3  1 
1A33490 	30 49 A0  1 
   next-node 0=  if  drop true exit  then	( size' )
1A33494 	24 27 A3  1 
1A33498 	24 47 A0  1 DC 41 A0  1 
1A334A0 	10  0  0  0 30 49 A0  1 
1A334A8 	 4 70 A0  1 40 46 A0  1 
   next-end                                     ( size mem-end )
1A334B0 	B8 27 A3  1 
   dma-range                                    ( size mem-end range-l,h )
1A334B4 	98 33 A3  1 
   nip umin  swap -   false		        ( adr false )
1A334B8 	FC 46 A0  1 4C 4A A0  1 
1A334C0 	68 49 A0  1 18 45 A0  1 
1A334C8 	18 70 A0  1 
;
1A334CC 	58 46 A0  1 

headers
: dma-alloc  ( size -- virt )
1A334D0 	 0  0 64 6D 61 2D 61 6C 
1A334D8 	6C 6F 63 89 5C 34 A3  1 
1A334E0 	20 40 A0  1 
   pagesize round-up
1A334E4 	50 7F A2  1 
1A334E8 	A4 91 A0  1 

   \ Locate a suitable physical range
   dup  find-dma-address  throw			( size' phys )
1A334EC 	40 49 A0  1 
1A334F0 	5C 34 A3  1 74 7F A0  1 

   \ Claim it
   over 0  mem-claim				( size' phys )
1A334F8 	54 49 A0  1 70 6F A0  1 
1A33500 	B0 7E A2  1 

[ifdef] virtual-mode
   \ Get a virtual range
   over pagesize  mmu-claim			( size' phys virt )

   \ Map the physical and virtual ranges
   dup >r					( size' phys virt )
   rot dma-map-mode				( phys virt size' mode )
   mmu-map					( )
   r>						( virt )
[else]
   nip
1A33504 	FC 46 A0  1 
[then]
;
1A33508 	58 46 A0  1 
warning off
: dma-free  ( virt size -- )
1A3350C 	 0  0  0 64 
1A33510 	6D 61 2D 66 72 65 65 88 
1A33518 	E0 34 A3  1 20 40 A0  1 
   pagesize round-up				( virt size' )
1A33520 	50 7F A2  1 A4 91 A0  1 
[ifdef] virtual-mode
   over mmu-translate 0= abort" Freeing unmapped dma memory"  drop
						( virt size phys )
   -rot tuck                                    ( phys size  virt size )
   2dup mmu-unmap  mmu-release			( phys size )
[then]
   mem-release					( )
1A33528 	D8 7E A2  1 
;
1A3352C 	58 46 A0  1 

\ We don't need to flush the cache because we map DMA memory non-cached.
: dma-map-in  ( virt size cache? -- phys )
1A33530 	 0 64 6D 61 2D 6D 61 70 
1A33538 	2D 69 6E 8A 1C 35 A3  1 
1A33540 	20 40 A0  1 
   2drop    \ We mapped it non-cacheable above	( virt )
1A33544 	AC 49 A0  1 
[ifdef] virtual-mode
   mmu-translate 0= abort" Invalid DMA address"	( phys mode )
   drop
[then]
;
1A33548 	58 46 A0  1 
: dma-map-out  ( virt phys size -- )  3drop  ;
1A3354C 	64 6D 61 2D 
1A33550 	6D 61 70 2D 6F 75 74 8B 
1A33558 	40 35 A3  1 20 40 A0  1 
1A33560 	90 52 A0  1 58 46 A0  1 
: dma-sync     ( virt phys size -- )  3drop  ;
1A33568 	 0  0  0 64 6D 61 2D 73 
1A33570 	79 6E 63 88 5C 35 A3  1 
1A33578 	20 40 A0  1 90 52 A0  1 
1A33580 	58 46 A0  1 
: dma-push     ( virt phys size -- )  3drop  ;
1A33584 	 0  0  0 64 
1A33588 	6D 61 2D 70 75 73 68 88 
1A33590 	78 35 A3  1 20 40 A0  1 
1A33598 	90 52 A0  1 58 46 A0  1 
: dma-pull     ( virt phys size -- )  3drop  ;
1A335A0 	 0  0  0 64 6D 61 2D 70 
1A335A8 	75 6C 6C 88 94 35 A3  1 
1A335B0 	20 40 A0  1 90 52 A0  1 
1A335B8 	58 46 A0  1 
warning on
finish-device
1A335BC 	 0  0  0  0 
1A335C0 	 0  0  0  0  0  0  0  0 
1A335C8 	 0  0  0  0  0  0  0  0 
1A335D0 	 0  0  0  0 

device-end

OpenFirmware/cpu/x86/pc/rootnode.fth_AL	360 1A335D4 purpose: Create memory node properties and lists

dev /memory

: cmos@   ( offset -- byte )  h# 70 pc!  h# 71 pc@  ;
1A335D4 	 0  0 63 6D 
1A335D8 	6F 73 40 85  0 32 A3  1 
1A335E0 	20 40 A0  1 58 41 A0  1 
1A335E8 	70  0  0  0 E8 81 A2  1 
1A335F0 	58 41 A0  1 71  0  0  0 
1A335F8 	AC 81 A2  1 58 46 A0  1 
: /ram  ( -- #bytes )
1A33600 	 0  0  0 2F 72 61 6D 84 
1A33608 	E0 35 A3  1 20 40 A0  1 
   mem-info-pa la1+ l@ 
1A33610 	FC 24 A3  1 B4 50 A0  1 
1A33618 	6C 4C A0  1 

\   \ The BIOS puts the number of kilobytes of extended memory in CMOS memory
\   \ locations 30,31. The total memory is that plus the low meg.
\   h# 30 cmos@  h# 31 cmos@  bwjoin    ( #kbytes-extended )
\   d# 1024 +                           ( #kbytes-total )
\   d# 1024 *                           ( #bytes )
;
1A3361C 	58 46 A0  1 

: release-range  ( start-adr end-adr -- )  over - release  ;
1A33620 	 0  0 72 65 6C 65 61 73 
1A33628 	65 2D 72 61 6E 67 65 8D 
1A33630 	 C 36 A3  1 20 40 A0  1 
1A33638 	54 49 A0  1 18 45 A0  1 
1A33640 	5C 31 A3  1 58 46 A0  1 

: probe  ( -- )
1A33648 	 0  0 70 72 6F 62 65 85 
1A33650 	34 36 A3  1 20 40 A0  1 
   0 /ram  reg   \ Report extant memory
1A33658 	70 6F A0  1  C 36 A3  1 
1A33660 	C8 B2 A2  1 

   \ Put h# 10.0000-1f.ffff and 28.0000-memsize in pool,
   \ reserving 0..10.0000 for the firmware
   \ and 20.0000-27.ffff for the "flash"

\   h#  0.0000  h# 02.0000  release   \ A little bit of DMA space, we hope
\   h# 10.0000  h# 0f.ffff  release
\   h# 28.0000  h# 80.0000 h# 28.0000 -  release

\ Release some of the first meg, between the page tables and the DOS hole,
\ for use as DMA memory.
   mem-info-pa 2 la+ l@   h# a.0000  release-range  \ Below DOS hole
1A33664 	FC 24 A3  1 
1A33668 	90 6F A0  1 30 50 A0  1 
1A33670 	6C 4C A0  1 58 41 A0  1 
1A33678 	 0  0  A  0 34 36 A3  1 

[ifdef] virtual-mode
   h# 10.0000  dropin-base over -  release
   dropin-base dropin-size +  mem-info-pa la1+ l@  over -  release

[else]
   fw-pa h# 10.0000 u>  if
1A33680 	28 24 A3  1 58 41 A0  1 
1A33688 	 0  0 10  0 64 48 A0  1 
1A33690 	DC 41 A0  1 40  0  0  0 
      h# 10.0000   fw-pa over -  release
1A33698 	58 41 A0  1  0  0 10  0 
1A336A0 	28 24 A3  1 54 49 A0  1 
1A336A8 	18 45 A0  1 5C 31 A3  1 
      fw-pa /fw-ram +  heap-base heap-size +  umax  /ram  release
1A336B0 	28 24 A3  1 3C 24 A3  1 
1A336B8 	 4 45 A0  1 54 24 A3  1 
1A336C0 	6C 24 A3  1  4 45 A0  1 
1A336C8 	C8 4A A0  1  C 36 A3  1 
1A336D0 	5C 31 A3  1 
   then

\   dropin-base /ram u<  if
\      dropin-base dropin-size +  /ram over -  release
\   then
[then]
;
1A336D4 	58 46 A0  1 

device-end

also forth definitions
stand-init: Probing memory
1A336D8 	 0 73 74 61 6E 64 2D 69 
1A336E0 	6E 69 74 8A A4 32 A3  1 
1A336E8 	20 40 A0  1 30 32 A3  1 
1A336F0 	9C 53 A0  1  E 50 72 6F 
1A336F8 	62 69 6E 67 20 6D 65 6D 
1A33700 	6F 72 79  0 80 6D A0  1 
1A33708 	 4 6C A0  1 
   " probe" memory-node @ $call-method  
1A3370C 	9C 53 A0  1 
1A33710 	 5 70 72 6F 62 65  0  0 
1A33718 	58 7E A2  1 5C 4C A0  1 
1A33720 	B4 31 A2  1 
;
1A33724 	58 46 A0  1 
previous definitions

OpenFirmware/cpu/x86/pc/biosload/probemem.fth_AL	154 1A33728 1A3379C purpose: Real-mode access to ISA IO space

h# ffff.0000 value io-base	\ "mapped" base address of ISA I/O space
1A337A8 	69 6F 2D 62 61 73 65 87 
1A337B0 	74 37 A3  1 50 40 A0  1 
1A337B8 	4C  A  0  0 

OpenFirmware/cpu/x86/pc/isaio.fth_AL	14 1A337BC purpose: Configuration space access using "configuration mechanism 1"

\ Ostensibly this applies to the PCI bus and thus should be in the PCI node.
\ However, many of the host bridge registers are accessed via this mechanism,
\ so it is convenient to make the configuration access words globally-visible.
\ This mechanism works for several different PCI host bridges.

headerless

defer config-map
1A337BC 	 0 63 6F 6E 
1A337C0 	66 69 67 2D 6D 61 70 8A 
1A337C8 	B4 37 A3  1 5C 40 A0  1 
1A337D0 	50  A  0  0 
: config-map-m1  ( config-adr -- port )
1A337D4 	 0  0 63 6F 
1A337D8 	6E 66 69 67 2D 6D 61 70 
1A337E0 	2D 6D 31 8D CC 37 A3  1 
1A337E8 	20 40 A0  1 
   dup  3 invert and  h# 8000.0000 or  h# cf8 pl!  ( config-adr )
1A337EC 	40 49 A0  1 
1A337F0 	A0 6F A0  1 30 45 A0  1 
1A337F8 	5C 44 A0  1 58 41 A0  1 
1A33800 	 0  0  0 80 70 44 A0  1 
1A33808 	58 41 A0  1 F8  C  0  0 
1A33810 	10 82 A2  1 
   3 and  h# cfc or  io-base +
1A33814 	A0 6F A0  1 
1A33818 	5C 44 A0  1 58 41 A0  1 
1A33820 	FC  C  0  0 70 44 A0  1 
1A33828 	B4 37 A3  1  4 45 A0  1 
;
1A33830 	58 46 A0  1 
' config-map-m1 to config-map

headers

: config-l@  ( config-addr -- l )  config-map rl@  ;
1A33834 	 0  0 63 6F 
1A33838 	6E 66 69 67 2D 6C 40 89 
1A33840 	E8 37 A3  1 20 40 A0  1 
1A33848 	CC 37 A3  1 F8 B1 A2  1 
1A33850 	58 46 A0  1 
: config-l!  ( l config-addr -- )  config-map rl!  ;
1A33854 	 0  0 63 6F 
1A33858 	6E 66 69 67 2D 6C 21 89 
1A33860 	44 38 A3  1 20 40 A0  1 
1A33868 	CC 37 A3  1 68 B2 A2  1 
1A33870 	58 46 A0  1 
: config-w@  ( config-addr -- w )  config-map rw@  ;
1A33874 	 0  0 63 6F 
1A33878 	6E 66 69 67 2D 77 40 89 
1A33880 	64 38 A3  1 20 40 A0  1 
1A33888 	CC 37 A3  1 D0 B1 A2  1 
1A33890 	58 46 A0  1 
: config-w!  ( w config-addr -- )  config-map rw!  ;
1A33894 	 0  0 63 6F 
1A33898 	6E 66 69 67 2D 77 21 89 
1A338A0 	84 38 A3  1 20 40 A0  1 
1A338A8 	CC 37 A3  1 40 B2 A2  1 
1A338B0 	58 46 A0  1 
: config-b@  ( config-addr -- c )  config-map rb@  ;
1A338B4 	 0  0 63 6F 
1A338B8 	6E 66 69 67 2D 62 40 89 
1A338C0 	A4 38 A3  1 20 40 A0  1 
1A338C8 	CC 37 A3  1 A8 B1 A2  1 
1A338D0 	58 46 A0  1 
: config-b!  ( c config-addr -- )  config-map rb!  ;
1A338D4 	 0  0 63 6F 
1A338D8 	6E 66 69 67 2D 62 21 89 
1A338E0 	C4 38 A3  1 20 40 A0  1 
1A338E8 	CC 37 A3  1 1C B2 A2  1 
1A338F0 	58 46 A0  1 

OpenFirmware/dev/pci/configm1.fth_AL	138 1A338F4 
vocset=5D89D8 1A00A74 1A338F4 
vocset=5D89F8 1A00A78 1A33914 
vocset=5D8A18 1A00A7C 1A33934 
vocset=5D8A38 1A00A80 1A33954 
select-dev=</>
propset=1A339E8 B44241C 1A00AB4 
vocset=B44241C 1A00AB4 1A339E8 
new-node=B442430 1A00A94 
vocset=B442430 1A00A94 1A339E8 
set-args0=0 5D8F85 0 0 purpose: PCI physical address mapping to root node

headerless

\ map-pci-phys creates a virtual mapping for the PCI physical address range
\ "paddr io? size", returning its virtual address "vaddr".  It does so by
\ first translating the PCI physical base address "paddr io?" to the
\ corresponding physical address in the parent node's address space (which
\ in this case is the primary system bus address space), and then calling
\ the parent's "map-in" method.  We have a bit of a problem here in that
\ the root node is bogus - it doesn't recognize I/O space - so we do that
\ explicitly here.
\ "io?" is false for PCI memory space, true for PCI I/O space.

\ We use the top 64K of address space to mean I/O space.
\ The "rX@/!" words understand that and use I/O cycles for such addresses

: map-pci-phys  ( paddr io? phys.hi size -- vaddr )
1A339E8 	 0  0  0 6D 61 70 2D 70 
1A339F0 	63 69 2D 70 68 79 73 8C 
1A339F8 	 0  0 A0  1 20 40 A0  1 
   nip swap  if                      ( paddr size )
1A33A00 	FC 46 A0  1 68 49 A0  1 
1A33A08 	DC 41 A0  1 1C  0  0  0 
      \ We use the top 64K of address space to mean I/O space.
      \ The "rX@/!" words understand that and use I/O cycles
      \ for such addresses
      drop  h# ffff.0000 or          ( io-vaddr )
1A33A10 	30 49 A0  1 58 41 A0  1 
1A33A18 	 0  0 FF FF 70 44 A0  1 
   else                              ( paddr size )
1A33A20 	C8 41 A0  1 14  0  0  0 
      " map-in" $call-parent         ( mem-vaddr )
1A33A28 	9C 53 A0  1  6 6D 61 70 
1A33A30 	2D 69 6E  0 DC 31 A2  1 
   then                              ( vaddr )
;      
1A33A38 	58 46 A0  1 

\ >pci-devaddr translates the DMA address "parent-devaddr", which is in the
\ parent node's physical address space, to the corresponding DMA address
\ "pci-devaddr" in the PCI physical address space (in PCI memory space; DMA
\ to PCI I/O space is not possible).

: >pci-devaddr  ( parent-devaddr -- pci-devaddr )  h# 0  +  ;
1A33A3C 	 0  0  0 3E 
1A33A40 	70 63 69 2D 64 65 76 61 
1A33A48 	64 64 72 8C FC 39 A3  1 
1A33A50 	20 40 A0  1 58 41 A0  1 
1A33A58 	 0  0  0  0  4 45 A0  1 
1A33A60 	58 46 A0  1 

\ pci-devaddr> translates the DMA address "pci-devaddr", which is in the
\ PCI physical address space (in PCI memory space; DMA to PCI I/O space is
\ not possible), to the corresponding DMA address "parent-devaddr" in the
\ parent node's physical address space.

: pci-devaddr>  ( pci-devaddr -- parent-devaddr )  h# 0  -  ;
1A33A64 	 0  0  0 70 
1A33A68 	63 69 2D 64 65 76 61 64 
1A33A70 	64 72 3E 8C 50 3A A3  1 
1A33A78 	20 40 A0  1 58 41 A0  1 
1A33A80 	 0  0  0  0 18 45 A0  1 
1A33A88 	58 46 A0  1 
headers

OpenFirmware/cpu/x86/pc/mappci.fth_AL	A4 1A33A8C 
1A33B3C 

1A33B58 

1A33B70 

1A33B8C 
1A33C10 1A33C30 1A33C54 1A33C74 
vocset=5D8978 1A00AF4 1A36B58 1A37CA8 purpose: PCI bus package

hex
headerless

defer prsnt@
1A33A8C 	 0 70 72 73 
1A33A90 	6E 74 40 86 78 3A A3  1 
1A33A98 	5C 40 A0  1 98  A  0  0 

\ Many systems have no way to read the PRSNT bits, so the default 
\ implementation returns the worst-case information.
: (prsnt@)  ( phys.hi -- false | prsnt-bits true )  drop 2 true  ;
1A33AA0 	 0  0  0 28 70 72 73 6E 
1A33AA8 	74 40 29 88 98 3A A3  1 
1A33AB0 	20 40 A0  1 30 49 A0  1 
1A33AB8 	90 6F A0  1  4 70 A0  1 
1A33AC0 	58 46 A0  1 
' (prsnt@) to prsnt@

defer setup-fcodes   ( -- )  ' noop to setup-fcodes
1A33AC4 	 0  0  0 73 
1A33AC8 	65 74 75 70 2D 66 63 6F 
1A33AD0 	64 65 73 8C B0 3A A3  1 
1A33AD8 	5C 40 A0  1 9C  A  0  0 
defer restore-fcodes ( -- )  ' noop to restore-fcodes
1A33AE0 	 0 72 65 73 74 6F 72 65 
1A33AE8 	2D 66 63 6F 64 65 73 8E 
1A33AF0 	D8 3A A3  1 5C 40 A0  1 
1A33AF8 	A0  A  0  0 

false value pcimsg?	\ Optional Debug Msgs
1A33AFC 	70 63 69 6D 
1A33B00 	73 67 3F 87 F4 3A A3  1 
1A33B08 	50 40 A0  1 A4  A  0  0 
-1 value probemsg?	\ Optional Probing Msgs
1A33B10 	 0  0 70 72 6F 62 65 6D 
1A33B18 	73 67 3F 89  8 3B A3  1 
1A33B20 	50 40 A0  1 A8  A  0  0 

\ The default value for first-io skips the area where built-in ISA
\ devices normally live, but stays below 64K, in order to work with
\ 16-bit PCI-PCI bridges like the DEC 21050
\ XXX we should maintain a separate I/O space allocation pointer
\ for I/O devices with "large" region sizes (e.g. some versions of
\ IBM's MPIC chip), so they do not eat up all the available space
\ below 64K.
headers		\ These headers are for debugging convenience
h# 00001000 package value first-io       \ Avoid on-board ISA I/O devices
1A33B28 	 0  0  0 66 69 72 73 74 
1A33B30 	2D 69 6F 88 20 3B A3  1 
1A33B38 	74  5 A2  1 18  0  0  0 
h# 00010000 package value io-space-top   \ Stay below 64K for 16-bit bridges
1A33B40 	 0  0  0 69 6F 2D 73 70 
1A33B48 	61 63 65 2D 74 6F 70 8C 
1A33B50 	38 3B A3  1 74  5 A2  1 
1A33B58 	1C  0  0  0 

h# 01000000 package value first-mem      \ Default: reserve 16M for ISA memory
1A33B5C 	 0  0 66 69 
1A33B60 	72 73 74 2D 6D 65 6D 89 
1A33B68 	54 3B A3  1 74  5 A2  1 
1A33B70 	20  0  0  0 
h# 3f000000 package value mem-space-top
1A33B74 	 0  0 6D 65 
1A33B78 	6D 2D 73 70 61 63 65 2D 
1A33B80 	74 6F 70 8D 6C 3B A3  1 
1A33B88 	74  5 A2  1 24  0  0  0 
headerless

h# 40 buffer: string1
1A33B90 	73 74 72 69 6E 67 31 87 
1A33B98 	88 3B A3  1 B4 A9 A0  1 
1A33BA0 	AC  A  0  0 40  0  0  0 
1A33BA8 	60 F9 A2  1 
h# 40 buffer: string2
1A33BAC 	73 74 72 69 
1A33BB0 	6E 67 32 87 9C 3B A3  1 
1A33BB8 	B4 A9 A0  1 B0  A  0  0 
1A33BC0 	40  0  0  0 9C 3B A3  1 
h# 40 buffer: string3
1A33BC8 	73 74 72 69 6E 67 33 87 
1A33BD0 	B8 3B A3  1 B4 A9 A0  1 
1A33BD8 	B4  A  0  0 40  0  0  0 
1A33BE0 	B8 3B A3  1 
h# 40 buffer: string4
1A33BE4 	73 74 72 69 
1A33BE8 	6E 67 34 87 D4 3B A3  1 
1A33BF0 	B4 A9 A0  1 B8  A  0  0 
1A33BF8 	40  0  0  0 D4 3B A3  1 

headers
" pci"  encode-string  " name"  property
1A33C00 	70 63 69  0  0  0  0 6E 
1A33C08 	61 6D 65 84  0  0 A0  1 
1A33C10 	BC 13 A2  1 14  0  0  0 
1A33C18 	 4  0  0  0 

\ There are no visible PCI registers
\ my-address encode-int  /pci-regs encode-int encode+  " reg" property

" pci" encode-string  " device_type"  property
1A33C1C 	70 63 69  0 
1A33C20 	64 65 76 69 63 65 5F 74 
1A33C28 	79 70 65 8B 10 3C A3  1 
1A33C30 	BC 13 A2  1 18  0  0  0 
1A33C38 	 4  0  0  0 

3 encode-int  " #address-cells" property
1A33C3C 	 0  0  0  3 
1A33C40 	 0 23 61 64 64 72 65 73 
1A33C48 	73 2D 63 65 6C 6C 73 8E 
1A33C50 	30 3C A3  1 BC 13 A2  1 
1A33C58 	1C  0  0  0  4  0  0  0 
2 encode-int  " #size-cells"    property
1A33C60 	 0  0  0  2 23 73 69 7A 
1A33C68 	65 2D 63 65 6C 6C 73 8B 
1A33C70 	54 3C A3  1 BC 13 A2  1 
1A33C78 	18  0  0  0  4  0  0  0 

headerless
false instance value apple-hack?
1A33C80 	61 70 70 6C 65 2D 68 61 
1A33C88 	63 6B 3F 8B F0 3B A3  1 
1A33C90 	C0 FE A1  1 28  0  0  0 
false value probe-state?
1A33C98 	 0  0  0 70 72 6F 62 65 
1A33CA0 	2D 73 74 61 74 65 3F 8C 
1A33CA8 	90 3C A3  1 50 40 A0  1 
1A33CB0 	BC  A  0  0 

headers		\ These headers are for debugging convenience
0 value current-bus#
1A33CB4 	 0  0  0 63 
1A33CB8 	75 72 72 65 6E 74 2D 62 
1A33CC0 	75 73 23 8C AC 3C A3  1 
1A33CC8 	50 40 A0  1 C0  A  0  0 

: have-property?  ( propname$ -- flag )
1A33CD0 	 0 68 61 76 65 2D 70 72 
1A33CD8 	6F 70 65 72 74 79 3F 8E 
1A33CE0 	C8 3C A3  1 20 40 A0  1 
   get-my-property  if  false  else  2drop true  then
1A33CE8 	1C 34 A2  1 DC 41 A0  1 
1A33CF0 	10  0  0  0 18 70 A0  1 
1A33CF8 	C8 41 A0  1  C  0  0  0 
1A33D00 	AC 49 A0  1  4 70 A0  1 
;
1A33D08 	58 46 A0  1 
: assign-addresses?  ( -- flag )  " addresses-preassigned" have-property? 0=  ;
1A33D0C 	 0  0 61 73 
1A33D10 	73 69 67 6E 2D 61 64 64 
1A33D18 	72 65 73 73 65 73 3F 91 
1A33D20 	E4 3C A3  1 20 40 A0  1 
1A33D28 	9C 53 A0  1 15 61 64 64 
1A33D30 	72 65 73 73 65 73 2D 70 
1A33D38 	72 65 61 73 73 69 67 6E 
1A33D40 	65 64  0  0 E4 3C A3  1 
1A33D48 	24 47 A0  1 58 46 A0  1 
: parent-assign-addresses?  ( -- flag )
1A33D50 	 0  0  0 70 61 72 65 6E 
1A33D58 	74 2D 61 73 73 69 67 6E 
1A33D60 	2D 61 64 64 72 65 73 73 
1A33D68 	65 73 3F 98 24 3D A3  1 
1A33D70 	20 40 A0  1 
   " addresses-preassigned" get-inherited-property  if  ( )
1A33D74 	9C 53 A0  1 
1A33D78 	15 61 64 64 72 65 73 73 
1A33D80 	65 73 2D 70 72 65 61 73 
1A33D88 	73 69 67 6E 65 64  0  0 
1A33D90 	20 36 A2  1 DC 41 A0  1 
1A33D98 	10  0  0  0 
      true
1A33D9C 	 4 70 A0  1 
   else                     ( propval$ )
1A33DA0 	C8 41 A0  1  C  0  0  0 
      2drop false
1A33DA8 	AC 49 A0  1 18 70 A0  1 
   then
;
1A33DB0 	58 46 A0  1 

\ These cannot be package values because some words that use them are called
\ directly from different contexts - both from the root of the PCI domain
\ and also from child nodes and subordinate PCI-PCI bridge nodes.  They need
\ not be package values because they contain no long-term information;
\ between invocations of master-probe, the allocation pointers are stored
\ in first-io and first-mem.
first-io  value next-io
1A33DB4 	6E 65 78 74 
1A33DB8 	2D 69 6F 87 70 3D A3  1 
1A33DC0 	50 40 A0  1 C4  A  0  0 
first-mem value next-mem
1A33DC8 	 0  0  0 6E 65 78 74 2D 
1A33DD0 	6D 65 6D 88 C0 3D A3  1 
1A33DD8 	50 40 A0  1 C8  A  0  0 
headerless

: set-next-io   ( adr -- )  to next-io   ;
1A33DE0 	73 65 74 2D 6E 65 78 74 
1A33DE8 	2D 69 6F 8B D8 3D A3  1 
1A33DF0 	20 40 A0  1 B8 40 A0  1 
1A33DF8 	C0 3D A3  1 58 46 A0  1 
: set-next-mem  ( adr -- )  to next-mem  ;
1A33E00 	 0  0  0 73 65 74 2D 6E 
1A33E08 	65 78 74 2D 6D 65 6D 8C 
1A33E10 	F0 3D A3  1 20 40 A0  1 
1A33E18 	B8 40 A0  1 D8 3D A3  1 
1A33E20 	58 46 A0  1 

h# 00000fff constant pci-pagemask
1A33E24 	 0  0  0 70 
1A33E28 	63 69 2D 70 61 67 65 6D 
1A33E30 	61 73 6B 8C 14 3E A3  1 
1A33E38 	68 40 A0  1 FF  F  0  0 

\ XXX we need a sophisticated IO space allocator that accounts for
\ hardwired devices

: self-b@  ( phys.hi -- l )  h# ffffff and  " config-b@" $call-self  ;
1A33E40 	73 65 6C 66 2D 62 40 87 
1A33E48 	38 3E A3  1 20 40 A0  1 
1A33E50 	58 41 A0  1 FF FF FF  0 
1A33E58 	5C 44 A0  1 9C 53 A0  1 
1A33E60 	 9 63 6F 6E 66 69 67 2D 
1A33E68 	62 40  0  0 B4 30 A2  1 
1A33E70 	58 46 A0  1 
: self-l@  ( phys.hi -- l )  h# ffffff and  " config-l@" $call-self  ;
1A33E74 	73 65 6C 66 
1A33E78 	2D 6C 40 87 4C 3E A3  1 
1A33E80 	20 40 A0  1 58 41 A0  1 
1A33E88 	FF FF FF  0 5C 44 A0  1 
1A33E90 	9C 53 A0  1  9 63 6F 6E 
1A33E98 	66 69 67 2D 6C 40  0  0 
1A33EA0 	B4 30 A2  1 58 46 A0  1 
: self-l!  ( l phys.hi -- )  h# ffffff and  " config-l!" $call-self  ;
1A33EA8 	73 65 6C 66 2D 6C 21 87 
1A33EB0 	80 3E A3  1 20 40 A0  1 
1A33EB8 	58 41 A0  1 FF FF FF  0 
1A33EC0 	5C 44 A0  1 9C 53 A0  1 
1A33EC8 	 9 63 6F 6E 66 69 67 2D 
1A33ED0 	6C 21  0  0 B4 30 A2  1 
1A33ED8 	58 46 A0  1 
: 64mem?  ( phys.hi -- flag ) self-l@  7 and 4 = ;
1A33EDC 	 0 36 34 6D 
1A33EE0 	65 6D 3F 86 B4 3E A3  1 
1A33EE8 	20 40 A0  1 80 3E A3  1 
1A33EF0 	E0 6F A0  1 5C 44 A0  1 
1A33EF8 	B0 6F A0  1 24 48 A0  1 
1A33F00 	58 46 A0  1 
: io?  ( phys.hi -- flag )
1A33F04 	69 6F 3F 83 
1A33F08 	E8 3E A3  1 20 40 A0  1 
   \ For expansion ROM base address registers, the LSB is an enable bit,
   \ not an I/O space indicator.  Expansion ROM base address registers
   \ are at 30 or 38; the register number portion of our phys.hi argument
   \ will always be in the range 10-24 (inclusive), 30, or 38.
   dup h# 30 and  h# 30 =  if  drop false  else  self-l@  1 and  0<>  then
1A33F10 	40 49 A0  1 58 41 A0  1 
1A33F18 	30  0  0  0 5C 44 A0  1 
1A33F20 	58 41 A0  1 30  0  0  0 
1A33F28 	24 48 A0  1 DC 41 A0  1 
1A33F30 	14  0  0  0 30 49 A0  1 
1A33F38 	18 70 A0  1 C8 41 A0  1 
1A33F40 	14  0  0  0 80 3E A3  1 
1A33F48 	80 6F A0  1 5C 44 A0  1 
1A33F50 	44 47 A0  1 
;
1A33F54 	58 46 A0  1 
: probe-base-reg  ( phys.hi -- value )
1A33F58 	 0 70 72 6F 62 65 2D 62 
1A33F60 	61 73 65 2D 72 65 67 8E 
1A33F68 	 C 3F A3  1 20 40 A0  1 
   dup self-l@ over                   ( phys.hi old-value phys.hi )
1A33F70 	40 49 A0  1 80 3E A3  1 
1A33F78 	54 49 A0  1 
   h# ffffffff over self-l! self-l@  ( phys.hi old-value new-value )
1A33F7C 	58 41 A0  1 
1A33F80 	FF FF FF FF 54 49 A0  1 
1A33F88 	B4 3E A3  1 80 3E A3  1 
   -rot swap self-l!
1A33F90 	94 49 A0  1 68 49 A0  1 
1A33F98 	B4 3E A3  1 
;
1A33F9C 	58 46 A0  1 
: mask-low-bits  ( phys.hi regval -- regval' )
1A33FA0 	 0  0 6D 61 73 6B 2D 6C 
1A33FA8 	6F 77 2D 62 69 74 73 8D 
1A33FB0 	6C 3F A3  1 20 40 A0  1 
   swap io?  if  3  else  h# f  then  invert and   ( regval' )
1A33FB8 	68 49 A0  1  C 3F A3  1 
1A33FC0 	DC 41 A0  1 10  0  0  0 
1A33FC8 	A0 6F A0  1 C8 41 A0  1 
1A33FD0 	 C  0  0  0 58 41 A0  1 
1A33FD8 	 F  0  0  0 30 45 A0  1 
1A33FE0 	5C 44 A0  1 
;
1A33FE4 	58 46 A0  1 
\ Some devices neglect to implement the upper 16 bits of the IO base
\ address register!
: fix-io16  ( high-mask -- high-mask' )
1A33FE8 	 0  0  0 66 69 78 2D 69 
1A33FF0 	6F 31 36 88 B4 3F A3  1 
1A33FF8 	20 40 A0  1 
   dup h# 18000 and  h# 08000 =  if  h# ffff0000 or  then
1A33FFC 	40 49 A0  1 
1A34000 	58 41 A0  1  0 80  1  0 
1A34008 	5C 44 A0  1 58 41 A0  1 
1A34010 	 0 80  0  0 24 48 A0  1 
1A34018 	DC 41 A0  1 10  0  0  0 
1A34020 	58 41 A0  1  0  0 FF FF 
1A34028 	70 44 A0  1 
;
1A3402C 	58 46 A0  1 
: find-boundary  ( phys.hi -- low-mask )
1A34030 	 0  0 66 69 6E 64 2D 62 
1A34038 	6F 75 6E 64 61 72 79 8D 
1A34040 	F8 3F A3  1 20 40 A0  1 
   dup dup probe-base-reg			( phys.hi phys-hi regval )
1A34048 	40 49 A0  1 40 49 A0  1 
1A34050 	6C 3F A3  1 
   mask-low-bits  fix-io16  invert		( phys.hi low-mask )
1A34054 	B4 3F A3  1 
1A34058 	F8 3F A3  1 30 45 A0  1 
   swap 64mem?  0=  if  n->l  then              ( low-mask )
1A34060 	68 49 A0  1 E8 3E A3  1 
1A34068 	24 47 A0  1 DC 41 A0  1 
1A34070 	 8  0  0  0 74 4F A0  1 
;
1A34078 	58 46 A0  1 
: mask-up  ( n mask -- n' )  tuck + swap invert and  ;
1A3407C 	6D 61 73 6B 
1A34080 	2D 75 70 87 44 40 A3  1 
1A34088 	20 40 A0  1 E8 46 A0  1 
1A34090 	 4 45 A0  1 68 49 A0  1 
1A34098 	30 45 A0  1 5C 44 A0  1 
1A340A0 	58 46 A0  1 

: ?p  ( adr len phys -- adr' len' phys' )
1A340A4 	 0 3F 70 82 
1A340A8 	88 40 A3  1 20 40 A0  1 
   over 1 >=  if                            ( adr len phys )
1A340B0 	54 49 A0  1 80 6F A0  1 
1A340B8 	EC 48 A0  1 DC 41 A0  1 
1A340C0 	44  0  0  0 
      2 pick c@  upc  ascii P =  if         ( adr len phys )
1A340C4 	90 6F A0  1 
1A340C8 	 C 4A A0  1 C4 4C A0  1 
1A340D0 	D0 51 A0  1 58 41 A0  1 
1A340D8 	50  0  0  0 24 48 A0  1 
1A340E0 	DC 41 A0  1 20  0  0  0 
         h# 40000000 +  >r  1 /string  r>  ( adr' len' phys' )
1A340E8 	58 41 A0  1  0  0  0 40 
1A340F0 	 4 45 A0  1 BC 45 A0  1 
1A340F8 	80 6F A0  1 3C 85 A0  1 
1A34100 	D0 45 A0  1 
      then
   then
;
1A34104 	58 46 A0  1 
: ?t  ( adr len phys -- adr' len' phys' )
1A34108 	 0 3F 74 82 AC 40 A3  1 
1A34110 	20 40 A0  1 
   over 1 >=  if                            ( adr len phys )
1A34114 	54 49 A0  1 
1A34118 	80 6F A0  1 EC 48 A0  1 
1A34120 	DC 41 A0  1 44  0  0  0 
      2 pick c@  upc  ascii T =  if         ( adr len phys )
1A34128 	90 6F A0  1  C 4A A0  1 
1A34130 	C4 4C A0  1 D0 51 A0  1 
1A34138 	58 41 A0  1 54  0  0  0 
1A34140 	24 48 A0  1 DC 41 A0  1 
1A34148 	20  0  0  0 
         h# 20000000 +  >r  1 /string  r>  ( adr' len' phys' )
1A3414C 	58 41 A0  1 
1A34150 	 0  0  0 20  4 45 A0  1 
1A34158 	BC 45 A0  1 80 6F A0  1 
1A34160 	3C 85 A0  1 D0 45 A0  1 
      then
   then
;
1A34168 	58 46 A0  1 

: $hnumber  ( adr len -- true | n false )  push-hex  $number  pop-base  ;
1A3416C 	 0  0  0 24 
1A34170 	68 6E 75 6D 62 65 72 88 
1A34178 	10 41 A3  1 20 40 A0  1 
1A34180 	5C F4 A0  1 40 FE A0  1 
1A34188 	9C F4 A0  1 58 46 A0  1 
: $hdnumber?  ( adr len -- true | d false )
1A34190 	 0 24 68 64 6E 75 6D 62 
1A34198 	65 72 3F 8A 7C 41 A3  1 
1A341A0 	20 40 A0  1 
   push-hex  $dnumber?  pop-base
1A341A4 	5C F4 A0  1 
1A341A8 	9C 9C A0  1 9C F4 A0  1 
;
1A341B0 	58 46 A0  1 

headers

: decode-unit  ( adr len -- phys.lo phys.mid phys.hi )
1A341B4 	64 65 63 6F 
1A341B8 	64 65 2D 75 6E 69 74 8B 
1A341C0 	A0 41 A3  1 20 40 A0  1 
   dup 0=  if  2drop 0 0 0  exit  then        ( adr len )
1A341C8 	40 49 A0  1 24 47 A0  1 
1A341D0 	DC 41 A0  1 18  0  0  0 
1A341D8 	AC 49 A0  1 70 6F A0  1 
1A341E0 	70 6F A0  1 70 6F A0  1 
1A341E8 	40 46 A0  1 
   0 >r
1A341EC 	70 6F A0  1 
1A341F0 	BC 45 A0  1 
   over c@  upc  ascii N =  if  r> h# 80000000 + >r  1 /string  then  ( adr len )
1A341F4 	54 49 A0  1 
1A341F8 	C4 4C A0  1 D0 51 A0  1 
1A34200 	58 41 A0  1 4E  0  0  0 
1A34208 	24 48 A0  1 DC 41 A0  1 
1A34210 	20  0  0  0 D0 45 A0  1 
1A34218 	58 41 A0  1  0  0  0 80 
1A34220 	 4 45 A0  1 BC 45 A0  1 
1A34228 	80 6F A0  1 3C 85 A0  1 
   over c@  upc  case
1A34230 	54 49 A0  1 C4 4C A0  1 
1A34238 	D0 51 A0  1 
      ascii I  of  r> h# 01000000 + >r  1 /string  r> ?t    >r  endof
1A3423C 	58 41 A0  1 
1A34240 	49  0  0  0 48 43 A0  1 
1A34248 	34  0  0  0 D0 45 A0  1 
1A34250 	58 41 A0  1  0  0  0  1 
1A34258 	 4 45 A0  1 BC 45 A0  1 
1A34260 	80 6F A0  1 3C 85 A0  1 
1A34268 	D0 45 A0  1 10 41 A3  1 
1A34270 	BC 45 A0  1 6C 43 A0  1 
1A34278 	8C  0  0  0 
      ascii M  of  r> h# 02000000 + >r  1 /string  r> ?t ?p >r  endof
1A3427C 	58 41 A0  1 
1A34280 	4D  0  0  0 48 43 A0  1 
1A34288 	38  0  0  0 D0 45 A0  1 
1A34290 	58 41 A0  1  0  0  0  2 
1A34298 	 4 45 A0  1 BC 45 A0  1 
1A342A0 	80 6F A0  1 3C 85 A0  1 
1A342A8 	D0 45 A0  1 10 41 A3  1 
1A342B0 	AC 40 A3  1 BC 45 A0  1 
1A342B8 	6C 43 A0  1 48  0  0  0 
      ascii X  of  r> h# 03000000 + >r  1 /string  r>    ?p >r  endof
1A342C0 	58 41 A0  1 58  0  0  0 
1A342C8 	48 43 A0  1 34  0  0  0 
1A342D0 	D0 45 A0  1 58 41 A0  1 
1A342D8 	 0  0  0  3  4 45 A0  1 
1A342E0 	BC 45 A0  1 80 6F A0  1 
1A342E8 	3C 85 A0  1 D0 45 A0  1 
1A342F0 	AC 40 A3  1 BC 45 A0  1 
1A342F8 	6C 43 A0  1  8  0  0  0 
      ( default )
   endcase
1A34300 	84 43 A0  1 

   \ XX do range checks

   ascii , left-parse-string                            ( rem$ DD$ )
1A34304 	58 41 A0  1 
1A34308 	2C  0  0  0 44 D7 A0  1 
   $hnumber  if  0  then  h# 1f and d# 11 <<  r> + >r   ( rem$ )
1A34310 	7C 41 A3  1 DC 41 A0  1 
1A34318 	 8  0  0  0 70 6F A0  1 
1A34320 	58 41 A0  1 1F  0  0  0 
1A34328 	5C 44 A0  1 58 41 A0  1 
1A34330 	 B  0  0  0 C8 44 A0  1 
1A34338 	D0 45 A0  1  4 45 A0  1 
1A34340 	BC 45 A0  1 
   dup 0=  if  2drop  0 0 r>  exit  then                ( rem$ )
1A34344 	40 49 A0  1 
1A34348 	24 47 A0  1 DC 41 A0  1 
1A34350 	18  0  0  0 AC 49 A0  1 
1A34358 	70 6F A0  1 70 6F A0  1 
1A34360 	D0 45 A0  1 40 46 A0  1 

   ascii , left-parse-string                            ( rem$ F$ )
1A34368 	58 41 A0  1 2C  0  0  0 
1A34370 	44 D7 A0  1 
   $hnumber  if  0  then  h#  f and d#  8 <<  r> + >r   ( rem$ )
1A34374 	7C 41 A3  1 
1A34378 	DC 41 A0  1  8  0  0  0 
1A34380 	70 6F A0  1 58 41 A0  1 
1A34388 	 F  0  0  0 5C 44 A0  1 
1A34390 	58 41 A0  1  8  0  0  0 
1A34398 	C8 44 A0  1 D0 45 A0  1 
1A343A0 	 4 45 A0  1 BC 45 A0  1 
   dup 0=  if  2drop  0 0 r>  exit  then                ( rem$ )
1A343A8 	40 49 A0  1 24 47 A0  1 
1A343B0 	DC 41 A0  1 18  0  0  0 
1A343B8 	AC 49 A0  1 70 6F A0  1 
1A343C0 	70 6F A0  1 D0 45 A0  1 
1A343C8 	40 46 A0  1 

   ascii , left-parse-string                            ( rem$ RR$ )
1A343CC 	58 41 A0  1 
1A343D0 	2C  0  0  0 44 D7 A0  1 
   $hnumber  if  0  then  h# ff and           r> + >r   ( rem$ )
1A343D8 	7C 41 A3  1 DC 41 A0  1 
1A343E0 	 8  0  0  0 70 6F A0  1 
1A343E8 	58 41 A0  1 FF  0  0  0 
1A343F0 	5C 44 A0  1 D0 45 A0  1 
1A343F8 	 4 45 A0  1 BC 45 A0  1 
   dup 0=  if  2drop  0 0 r>  exit  then                ( rem$ )
1A34400 	40 49 A0  1 24 47 A0  1 
1A34408 	DC 41 A0  1 18  0  0  0 
1A34410 	AC 49 A0  1 70 6F A0  1 
1A34418 	70 6F A0  1 D0 45 A0  1 
1A34420 	40 46 A0  1 

   \ Parse the remaining digits as a number, forcing the result to
   \ be a double number by pushing zeroes as needed
   $hdnumber?  ( 0 | n 1 | d 2 )  2 swap  ?do  0  loop  r>
1A34424 	A0 41 A3  1 
1A34428 	90 6F A0  1 68 49 A0  1 
1A34430 	50 42 A0  1 10  0  0  0 
1A34438 	70 6F A0  1 F8 41 A0  1 
1A34440 	F8 FF FF FF D0 45 A0  1 
;
1A34448 	58 46 A0  1 
headerless
: convert-device  ( phys.hi -- phys.hi )
1A3444C 	 0 63 6F 6E 
1A34450 	76 65 72 74 2D 64 65 76 
1A34458 	69 63 65 8E C4 41 A3  1 
1A34460 	20 40 A0  1 
   dup d# 11 >>  h# 1f and  u#s  drop
1A34464 	40 49 A0  1 
1A34468 	58 41 A0  1  B  0  0  0 
1A34470 	DC 44 A0  1 58 41 A0  1 
1A34478 	1F  0  0  0 5C 44 A0  1 
1A34480 	BC 76 A0  1 30 49 A0  1 
;
1A34488 	58 46 A0  1 
: convert-function  ( phys.hi -- phys.hi )
1A3448C 	 0  0  0 63 
1A34490 	6F 6E 76 65 72 74 2D 66 
1A34498 	75 6E 63 74 69 6F 6E 90 
1A344A0 	60 44 A3  1 20 40 A0  1 
   dup 8 >>  7 and  u#  ascii , hold  drop
1A344A8 	40 49 A0  1 F0 6F A0  1 
1A344B0 	DC 44 A0  1 E0 6F A0  1 
1A344B8 	5C 44 A0  1 94 76 A0  1 
1A344C0 	58 41 A0  1 2C  0  0  0 
1A344C8 	DC 75 A0  1 30 49 A0  1 
;
1A344D0 	58 46 A0  1 
: convert-high  ( phys.hi -- phys.hi )
1A344D4 	 0  0  0 63 
1A344D8 	6F 6E 76 65 72 74 2D 68 
1A344E0 	69 67 68 8C A4 44 A3  1 
1A344E8 	20 40 A0  1 
   dup h# 700 and  if  convert-function  then
1A344EC 	40 49 A0  1 
1A344F0 	58 41 A0  1  0  7  0  0 
1A344F8 	5C 44 A0  1 DC 41 A0  1 
1A34500 	 8  0  0  0 A4 44 A3  1 
   convert-device
1A34508 	60 44 A3  1 
;
1A3450C 	58 46 A0  1 
: convert-rr  ( phys.hi -- phys.hi )
1A34510 	 0 63 6F 6E 76 65 72 74 
1A34518 	2D 72 72 8A E8 44 A3  1 
1A34520 	20 40 A0  1 
   ascii , hold
1A34524 	58 41 A0  1 
1A34528 	2C  0  0  0 DC 75 A0  1 
   dup h# ff and  u# u#s  drop   ( phys.hi )  \ RR field
1A34530 	40 49 A0  1 58 41 A0  1 
1A34538 	FF  0  0  0 5C 44 A0  1 
1A34540 	94 76 A0  1 BC 76 A0  1 
1A34548 	30 49 A0  1 
   ascii , hold
1A3454C 	58 41 A0  1 
1A34550 	2C  0  0  0 DC 75 A0  1 
   convert-function convert-device
1A34558 	A4 44 A3  1 60 44 A3  1 
;
1A34560 	58 46 A0  1 
: ?tpn  ( phys.hi char -- 0 )
1A34564 	 0  0  0 3F 
1A34568 	74 70 6E 84 20 45 A3  1 
1A34570 	20 40 A0  1 
   over  h# 20000000 and  if  ascii t hold  then
1A34574 	54 49 A0  1 
1A34578 	58 41 A0  1  0  0  0 20 
1A34580 	5C 44 A0  1 DC 41 A0  1 
1A34588 	10  0  0  0 58 41 A0  1 
1A34590 	74  0  0  0 DC 75 A0  1 
   over  h# 40000000 and  if  ascii p hold  then
1A34598 	54 49 A0  1 58 41 A0  1 
1A345A0 	 0  0  0 40 5C 44 A0  1 
1A345A8 	DC 41 A0  1 10  0  0  0 
1A345B0 	58 41 A0  1 70  0  0  0 
1A345B8 	DC 75 A0  1 
   hold
1A345BC 	DC 75 A0  1 
   h# 80000000 and  if  ascii n hold  then
1A345C0 	58 41 A0  1  0  0  0 80 
1A345C8 	5C 44 A0  1 DC 41 A0  1 
1A345D0 	10  0  0  0 58 41 A0  1 
1A345D8 	6E  0  0  0 DC 75 A0  1 
;
1A345E0 	58 46 A0  1 

headers
: encode-unit  ( phys.lo phys.mid phys.hi -- adr len )
1A345E4 	65 6E 63 6F 
1A345E8 	64 65 2D 75 6E 69 74 8B 
1A345F0 	70 45 A3  1 20 40 A0  1 
   push-hex
1A345F8 	5C F4 A0  1 
   <#
1A345FC 	 8 76 A0  1 
   dup  d# 24 >>  3 and  case                   ( phys.low phys.mid phys.hi )
1A34600 	40 49 A0  1 58 41 A0  1 
1A34608 	18  0  0  0 DC 44 A0  1 
1A34610 	A0 6F A0  1 5C 44 A0  1 
      0  of  nip nip  convert-high  drop  endof  \ Configuration space
1A34618 	70 6F A0  1 48 43 A0  1 
1A34620 	1C  0  0  0 FC 46 A0  1 
1A34628 	FC 46 A0  1 E8 44 A3  1 
1A34630 	30 49 A0  1 6C 43 A0  1 
1A34638 	AC  0  0  0 
      1  of                                      \ I/O space
1A3463C 	80 6F A0  1 
1A34640 	48 43 A0  1 30  0  0  0 
             nip swap            ( phys.hi phys.low )
1A34648 	FC 46 A0  1 68 49 A0  1 
	     u# u#s  drop        ( phys.hi )
1A34650 	94 76 A0  1 BC 76 A0  1 
1A34658 	30 49 A0  1 
             convert-rr          ( phys.hi )
1A3465C 	20 45 A3  1 
             ascii i  ?tpn       ( )
1A34660 	58 41 A0  1 69  0  0  0 
1A34668 	70 45 A3  1 
      endof
1A3466C 	6C 43 A0  1 
1A34670 	74  0  0  0 
      2  of					 \ Memory-32 space
1A34674 	90 6F A0  1 
1A34678 	48 43 A0  1 30  0  0  0 
             nip swap            ( phys.hi phys.low )
1A34680 	FC 46 A0  1 68 49 A0  1 
	     u# u#s  drop        ( phys.hi )
1A34688 	94 76 A0  1 BC 76 A0  1 
1A34690 	30 49 A0  1 
             convert-rr          ( phys.hi )
1A34694 	20 45 A3  1 
             ascii m  ?tpn       ( )
1A34698 	58 41 A0  1 6D  0  0  0 
1A346A0 	70 45 A3  1 
      endof
1A346A4 	6C 43 A0  1 
1A346A8 	3C  0  0  0 
      3  of					 \ Memory-64 space
1A346AC 	A0 6F A0  1 
1A346B0 	48 43 A0  1 2C  0  0  0 
             -rot                ( phys.hi phys.low phys.mid )
1A346B8 	94 49 A0  1 
	     # #s  2drop         ( phys.hi )
1A346BC 	40 77 A0  1 
1A346C0 	68 77 A0  1 AC 49 A0  1 
             convert-rr          ( phys.hi )
1A346C8 	20 45 A3  1 
	     ascii x  ?tpn       ( )
1A346CC 	58 41 A0  1 
1A346D0 	78  0  0  0 70 45 A3  1 
      endof
1A346D8 	6C 43 A0  1  8  0  0  0 
   endcase
1A346E0 	84 43 A0  1 
   0 u#> string1 $save
1A346E4 	70 6F A0  1 
1A346E8 	E0 76 A0  1 9C 3B A3  1 
1A346F0 	68 7E A0  1 
   pop-base
1A346F4 	9C F4 A0  1 
;
1A346F8 	58 46 A0  1 
headerless

\ Configuration space

\ [ifdef] example-ranges-property
\ : +i  ( adr len n -- adr' len' )  encode-int encode+  ;
\ : 0+i  ( adr len -- adr' len' )  0 +i  ;
\ 
\ \  ---PCI Address---     ---Host Address----    --- size ---
\ \ phys.hi    .mid .low   phys.hi   .lo          .hi    .lo
\ 0000.0000 encode-int
\               0+i  0+i    1 +i  0000.0800 +i    0+i   800 +i  \ Slot 0
\ 0000.0800 +i  0+i  0+i    1 +i  0000.1000 +i    0+i   800 +i  \ Slot 1
\ 0000.1000 +i  0+i  0+i    1 +i  0000.2000 +i    0+i   800 +i  \ Slot 2
\ 0000.1800 +i  0+i  0+i    1 +i  0000.4000 +i    0+i   800 +i  \ Slot 3
\ 0100.0000 +i  0+i  0+i    2 +i  0000.0000 +i   1 +i      0+i  \ I/O
\ 0200.0000 +i  0+i  0+i    3 +i  0000.0000 +i   1 +i      0+i  \ Mem
\ 
\    " ranges" property
\ 
\ : map-pci-phys  ( paddr size io? -- vaddr )
\    if  2  else  3  then              ( paddr size parent-space )
\    swap " map-in" $call-parent       ( vaddr )
\ ;
\ 
\ [then]

\ : mapped?  ( phys.hi -- flag )
\ \ [ifdef] clear-to-f
\ \    dup config-l@ swap             ( old phys.hi )
\ \    h# ffffffff over config-l!    ( old phys.hi )
\ \    \ Ignore the low-order bits because the low bit of the expansion ROM
\ \    \ base address register is writeable
\ \    2dup config-l@                 ( old phys.hi old unmapped-value )
\ \    swap 3 invert and  swap 3 invert and  <>  ( old phys.hi flag )
\ \    -rot config-l!                 ( flag )
\ \ [else]
\    config-l@ 3 invert and  0<>      ( old phys.hi )
\ \ [then]
\ ;

: +i  ( adr len n -- adr' len' )  encode-int encode+  ;
1A346FC 	 0 2B 69 82 
1A34700 	F4 45 A3  1 20 40 A0  1 
1A34708 	40 F7 A1  1 F0 F5 A1  1 
1A34710 	58 46 A0  1 
: 0+i  ( adr len -- adr' len' )  0 +i  ;
1A34714 	30 2B 69 83 
1A34718 	 4 47 A3  1 20 40 A0  1 
1A34720 	70 6F A0  1  4 47 A3  1 
1A34728 	58 46 A0  1 

: special-!  ( data bus# -- )
1A3472C 	 0  0 73 70 
1A34730 	65 63 69 61 6C 2D 21 89 
1A34738 	1C 47 A3  1 20 40 A0  1 
   h# ff and		\ isolate bus number
1A34740 	58 41 A0  1 FF  0  0  0 
1A34748 	5C 44 A0  1 
   d# 16 lshift		\ shift into Bus Number Field
1A3474C 	58 41 A0  1 
1A34750 	10  0  0  0 9C 44 A0  1 
   h# 0000ff00 or	\ set Device/Function Bits to 1.  Register Bits = 0
1A34758 	58 41 A0  1  0 FF  0  0 
1A34760 	70 44 A0  1 
   self-l!
1A34764 	B4 3E A3  1 
;
1A34768 	58 46 A0  1 

: get-address  ( phys.low phys.mid phys.hi -- phys.hi paddr )
1A3476C 	67 65 74 2D 
1A34770 	61 64 64 72 65 73 73 8B 
1A34778 	3C 47 A3  1 20 40 A0  1 
   apple-hack?  if  2 pick  if  nip swap exit  then  then
1A34780 	90 3C A3  1 DC 41 A0  1 
1A34788 	20  0  0  0 90 6F A0  1 
1A34790 	 C 4A A0  1 DC 41 A0  1 
1A34798 	10  0  0  0 FC 46 A0  1 
1A347A0 	68 49 A0  1 40 46 A0  1 
   dup dup self-l@                    ( low mid hi hi base+type )
1A347A8 	40 49 A0  1 40 49 A0  1 
1A347B0 	80 3E A3  1 
   mask-low-bits                      ( low mid hi base )
1A347B4 	B4 3F A3  1 
   2swap drop +                       ( phys.hi paddr )
1A347B8 	F4 49 A0  1 30 49 A0  1 
1A347C0 	 4 45 A0  1 
;
1A347C4 	58 46 A0  1 
: not-relocatable?  ( phys.hi -- flag )  h# 80000000 and  0<>  ;
1A347C8 	 0  0  0 6E 6F 74 2D 72 
1A347D0 	65 6C 6F 63 61 74 61 62 
1A347D8 	6C 65 3F 90 7C 47 A3  1 
1A347E0 	20 40 A0  1 58 41 A0  1 
1A347E8 	 0  0  0 80 5C 44 A0  1 
1A347F0 	44 47 A0  1 58 46 A0  1 

\ As described in the PCI binding document, we must avoid I/O addresses
\ with a "1" in either the h# 100 bit or the h# 200 bit.  Such addresses
\ have special meaning in ISA systems.  When an I/O address allocation
\ attempt generates such an address, we bump the address past the bad range.

: avoid-hard-decode  ( base -- base' )
1A347F8 	 0  0 61 76 6F 69 64 2D 
1A34800 	68 61 72 64 2D 64 65 63 
1A34808 	6F 64 65 91 E0 47 A3  1 
1A34810 	20 40 A0  1 
   dup h# 300 and  if  h# 3ff invert and  h# 400 +  then
1A34814 	40 49 A0  1 
1A34818 	58 41 A0  1  0  3  0  0 
1A34820 	5C 44 A0  1 DC 41 A0  1 
1A34828 	20  0  0  0 58 41 A0  1 
1A34830 	FF  3  0  0 30 45 A0  1 
1A34838 	5C 44 A0  1 58 41 A0  1 
1A34840 	 0  4  0  0  4 45 A0  1 
;
1A34848 	58 46 A0  1 

: power-of-2?  ( n -- flag )  dup 1- and 0=  ;
1A3484C 	70 6F 77 65 
1A34850 	72 2D 6F 66 2D 32 3F 8B 
1A34858 	10 48 A3  1 20 40 A0  1 
1A34860 	40 49 A0  1 54 4B A0  1 
1A34868 	5C 44 A0  1 24 47 A0  1 
1A34870 	58 46 A0  1 

: >sizemask  ( n -- mask )
1A34874 	 0  0 3E 73 
1A34878 	69 7A 65 6D 61 73 6B 89 
1A34880 	5C 48 A3  1 20 40 A0  1 
   \ Mask is one less than the smallest power of two >= n.
   ?dup  if                                 ( n )
1A34888 	B4 70 A0  1 DC 41 A0  1 
1A34890 	7C  0  0  0 
      dup power-of-2?  if                   ( n )
1A34894 	40 49 A0  1 
1A34898 	5C 48 A3  1 DC 41 A0  1 
1A348A0 	10  0  0  0 
         1-                                 ( mask )
1A348A4 	54 4B A0  1 
      else                                  ( n )
1A348A8 	C8 41 A0  1 58  0  0  0 
         0                                  ( n #bits )
1A348B0 	70 6F A0  1 
         \ Shift left until the leftmost 1
         \ bit is in the msb of the cell
         begin  swap 2* dup 0>=  while      ( #bits n' )
1A348B4 	68 49 A0  1 
1A348B8 	A0 4B A0  1 40 49 A0  1 
1A348C0 	C4 47 A0  1 DC 41 A0  1 
1A348C8 	14  0  0  0 
            swap 1+                         ( n' #bits' )
1A348CC 	68 49 A0  1 
1A348D0 	30 4B A0  1 
         repeat                             ( #bits x )
1A348D4 	C8 41 A0  1 
1A348D8 	DC FF FF FF 

         \ Starting with all ones, shift
         \ right the same number of times
         drop  -1 swap 0  do  u2/  loop     ( mask )
1A348DC 	30 49 A0  1 
1A348E0 	58 41 A0  1 FF FF FF FF 
1A348E8 	68 49 A0  1 70 6F A0  1 
1A348F0 	88 42 A0  1 10  0  0  0 
1A348F8 	8C 4B A0  1 F8 41 A0  1 
1A34900 	F8 FF FF FF 
      then                                  ( mask )
   else                                    
1A34904 	C8 41 A0  1 
1A34908 	 8  0  0  0 
      1                                     ( mask )
1A3490C 	80 6F A0  1 
   then                                     ( mask )
;
1A34910 	58 46 A0  1 

headers
external

: assign-pci-addr  ( phys.lo phys.mid phys.hi len | -1 -- phys.hi paddr size )
1A34914 	61 73 73 69 
1A34918 	67 6E 2D 70 63 69 2D 61 
1A34920 	64 64 72 8F 84 48 A3  1 
1A34928 	20 40 A0  1 
   \ If len is -1, reset any temporary allocations
   dup -1 =  if  first-io set-next-io  first-mem set-next-mem  drop exit  then
1A3492C 	40 49 A0  1 
1A34930 	58 41 A0  1 FF FF FF FF 
1A34938 	24 48 A0  1 DC 41 A0  1 
1A34940 	1C  0  0  0 38 3B A3  1 
1A34948 	F0 3D A3  1 6C 3B A3  1 
1A34950 	14 3E A3  1 30 49 A0  1 
1A34958 	40 46 A0  1 

   probemsg?  if  ??cr ." Assigning PCI Space of length " dup 8 u.r  cr  then
1A3495C 	20 3B A3  1 
1A34960 	DC 41 A0  1 3C  0  0  0 
1A34968 	 0 A1 A0  1 20 7C A0  1 
1A34970 	1E 41 73 73 69 67 6E 69 
1A34978 	6E 67 20 50 43 49 20 53 
1A34980 	70 61 63 65 20 6F 66 20 
1A34988 	6C 65 6E 67 74 68 20  0 
1A34990 	40 49 A0  1 F0 6F A0  1 
1A34998 	E4 77 A0  1 80 6D A0  1 

   >r nip                                           ( phys.lo phys.hi )
1A349A0 	BC 45 A0  1 FC 46 A0  1 
   dup find-boundary                                ( phys.lo phys.hi mask )
1A349A8 	40 49 A0  1 44 40 A3  1 
   over io?  if                                     ( phys.lo phys.hi mask )
1A349B0 	54 49 A0  1  C 3F A3  1 
1A349B8 	DC 41 A0  1 7C  0  0  0 
      probemsg?  if  ." I/O Space..." cr  then
1A349C0 	20 3B A3  1 DC 41 A0  1 
1A349C8 	1C  0  0  0 20 7C A0  1 
1A349D0 	 C 49 2F 4F 20 53 70 61 
1A349D8 	63 65 2E 2E 2E  0  0  0 
1A349E0 	80 6D A0  1 
      \ Use the maximum of the requested size and the
      \ size implied by the register.
      2 pick r> +  >sizemask or   dup 1+ >r         ( phys.lo phys.hi mask'' )
1A349E4 	90 6F A0  1 
1A349E8 	 C 4A A0  1 D0 45 A0  1 
1A349F0 	 4 45 A0  1 84 48 A3  1 
1A349F8 	70 44 A0  1 40 49 A0  1 
1A34A00 	30 4B A0  1 BC 45 A0  1 

      next-io  swap mask-up  avoid-hard-decode      ( phys.lo phys.hi base )
1A34A08 	C0 3D A3  1 68 49 A0  1 
1A34A10 	88 40 A3  1 10 48 A3  1 
      dup r> +  set-next-io                         ( phys.lo phys.hi base )
1A34A18 	40 49 A0  1 D0 45 A0  1 
1A34A20 	 4 45 A0  1 F0 3D A3  1 
      next-io >r                                    ( ... r: next-io )
1A34A28 	C0 3D A3  1 BC 45 A0  1 
   else	                                            ( phys.lo phys.hi mask )
1A34A30 	C8 41 A0  1 7C  0  0  0 
      probemsg?  if  ." Memory Space..." cr  then
1A34A38 	20 3B A3  1 DC 41 A0  1 
1A34A40 	20  0  0  0 20 7C A0  1 
1A34A48 	 F 4D 65 6D 6F 72 79 20 
1A34A50 	53 70 61 63 65 2E 2E 2E 
1A34A58 	 0  0  0  0 80 6D A0  1 
      \ Force memory space resources to page granularity
      pci-pagemask or				    ( phys.lo phys.hi mask' )
1A34A60 	38 3E A3  1 70 44 A0  1 

      \ Some PCI devices (e.g. S3 928) lie about
      \ the mapping granularity by having writeable
      \ base address register bits that are not in
      \ fact decoded, so we use the maximum of the
      \ sizes implied by the base address register
      \ and the reg property entry.
      2 pick r> +  >sizemask or   dup 1+ >r         ( phys.lo phys.hi mask'' )
1A34A68 	90 6F A0  1  C 4A A0  1 
1A34A70 	D0 45 A0  1  4 45 A0  1 
1A34A78 	84 48 A3  1 70 44 A0  1 
1A34A80 	40 49 A0  1 30 4B A0  1 
1A34A88 	BC 45 A0  1 

      next-mem swap mask-up  dup r> + set-next-mem  ( phys.lo phys.hi base )
1A34A8C 	D8 3D A3  1 
1A34A90 	68 49 A0  1 88 40 A3  1 
1A34A98 	40 49 A0  1 D0 45 A0  1 
1A34AA0 	 4 45 A0  1 14 3E A3  1 
      next-mem >r                                   ( ... r: next-mem )
1A34AA8 	D8 3D A3  1 BC 45 A0  1 
   then                                             ( phys.lo phys.hi base )
   probemsg?  if  2dup swap ."   Base Reg: " . ."  = " . cr  then
1A34AB0 	20 3B A3  1 DC 41 A0  1 
1A34AB8 	38  0  0  0 C0 49 A0  1 
1A34AC0 	68 49 A0  1 20 7C A0  1 
1A34AC8 	 C 20 20 42 61 73 65 20 
1A34AD0 	52 65 67 3A 20  0  0  0 
1A34AD8 	94 7A A0  1 20 7C A0  1 
1A34AE0 	 3 20 3D 20  0  0  0  0 
1A34AE8 	94 7A A0  1 80 6D A0  1 
   2dup swap self-l!                                ( phys.lo phys.hi base )
1A34AF0 	C0 49 A0  1 68 49 A0  1 
1A34AF8 	B4 3E A3  1 
\ M
   over 64mem?  if  over 4 + 0 swap self-l!  then
1A34AFC 	54 49 A0  1 
1A34B00 	E8 3E A3  1 DC 41 A0  1 
1A34B08 	1C  0  0  0 54 49 A0  1 
1A34B10 	B0 6F A0  1  4 45 A0  1 
1A34B18 	70 6F A0  1 68 49 A0  1 
1A34B20 	B4 3E A3  1 
\ M
   rot +                                            ( phys.hi paddr )
1A34B24 	7C 49 A0  1 
1A34B28 	 4 45 A0  1 
   r> over -                                        ( phys.hi paddr size )
1A34B2C 	D0 45 A0  1 
1A34B30 	54 49 A0  1 18 45 A0  1 
;
1A34B38 	58 46 A0  1 

\ XXX What if a stateful bridge needs to have its registers mapped
\ in order to probe its children, thus it has a probe-state mapping,
\ then during the probe long-term addresses get assigned, then the
\ subordinate probe finishes and the bridge registers are unmapped,
\ ostensibly in probe state.
\ XXX we should stipulate that, after mapping out, devices must set
\ their command registers to disable memory and I/O response.

: enable-apple-hack  ( -- )  true to apple-hack?   ;
1A34B3C 	 0  0 65 6E 
1A34B40 	61 62 6C 65 2D 61 70 70 
1A34B48 	6C 65 2D 68 61 63 6B 91 
1A34B50 	28 49 A3  1 20 40 A0  1 
1A34B58 	 4 70 A0  1 48 B8 A1  1 
1A34B60 	90 3C A3  1 58 46 A0  1 

: ?map-in-msg  ( phys.lo..hi -- phys.lo..hi )
1A34B68 	3F 6D 61 70 2D 69 6E 2D 
1A34B70 	6D 73 67 8B 54 4B A3  1 
1A34B78 	20 40 A0  1 
   pcimsg?  if
1A34B7C 	 8 3B A3  1 
1A34B80 	DC 41 A0  1 EC  0  0  0 
      ??cr ." PCI-MAP-IN: Bus: " dup d# 16 rshift  h# ff and   . ." , "
1A34B88 	 0 A1 A0  1 20 7C A0  1 
1A34B90 	11 50 43 49 2D 4D 41 50 
1A34B98 	2D 49 4E 3A 20 42 75 73 
1A34BA0 	3A 20  0  0 40 49 A0  1 
1A34BA8 	58 41 A0  1 10  0  0  0 
1A34BB0 	B4 44 A0  1 58 41 A0  1 
1A34BB8 	FF  0  0  0 5C 44 A0  1 
1A34BC0 	94 7A A0  1 20 7C A0  1 
1A34BC8 	 2 2C 20  0 
      dup h# 3000000 and
1A34BCC 	40 49 A0  1 
1A34BD0 	58 41 A0  1  0  0  0  3 
1A34BD8 	5C 44 A0  1 
      case
         h# 00000000  of  ." CONFIG, "  endof	( phys.lo..hi )
1A34BDC 	58 41 A0  1 
1A34BE0 	 0  0  0  0 48 43 A0  1 
1A34BE8 	1C  0  0  0 20 7C A0  1 
1A34BF0 	 8 43 4F 4E 46 49 47 2C 
1A34BF8 	20  0  0  0 6C 43 A0  1 
1A34C00 	38  0  0  0 
         h# 01000000  of  ." I/O, "     endof	( phys.lo..hi )
1A34C04 	58 41 A0  1 
1A34C08 	 0  0  0  1 48 43 A0  1 
1A34C10 	18  0  0  0 20 7C A0  1 
1A34C18 	 5 49 2F 4F 2C 20  0  0 
1A34C20 	6C 43 A0  1 14  0  0  0 
         ( default )	   ." MEM, "
1A34C28 	20 7C A0  1  5 4D 45 4D 
1A34C30 	2C 20  0  0 
      endcase
1A34C34 	84 43 A0  1 
      ." PCI PHYS.HI..LO = " 3dup .x space .x space .x  4 spaces
1A34C38 	20 7C A0  1 12 50 43 49 
1A34C40 	20 50 48 59 53 2E 48 49 
1A34C48 	2E 2E 4C 4F 20 3D 20  0 
1A34C50 	A4 52 A0  1 2C  E A1  1 
1A34C58 	CC 71 A0  1 2C  E A1  1 
1A34C60 	CC 71 A0  1 2C  E A1  1 
1A34C68 	B0 6F A0  1 E8 71 A0  1 
   then
;
1A34C70 	58 46 A0  1 
: map-in  ( phys.low phys.mid phys.hi len -- vaddr )
1A34C74 	 0 6D 61 70 
1A34C78 	2D 69 6E 86 78 4B A3  1 
1A34C80 	20 40 A0  1 
   >r                                               ( phys.lo..hi )
1A34C84 	BC 45 A0  1 
   ?map-in-msg                                      ( phys.lo..hi )
1A34C88 	78 4B A3  1 
\ XXX handle "t" bit
   \ In most systems, map-in won't be called for config space addresses,
   \ but some systems require it, so we check this case, letting
   \ map-pci-phys do most of the work.
   dup h# 3000000 and  0=  if	\ Config Space      ( phys.lo..hi )
1A34C8C 	40 49 A0  1 
1A34C90 	58 41 A0  1  0  0  0  3 
1A34C98 	5C 44 A0  1 24 47 A0  1 
1A34CA0 	DC 41 A0  1 18  0  0  0 
      nip tuck false                                ( phys.hi phys.lo io? )
1A34CA8 	FC 46 A0  1 E8 46 A0  1 
1A34CB0 	18 70 A0  1 
   else  dup not-relocatable?  if                   ( phys.lo..hi )
1A34CB4 	C8 41 A0  1 
1A34CB8 	68  0  0  0 40 49 A0  1 
1A34CC0 	E0 47 A3  1 DC 41 A0  1 
1A34CC8 	2C  0  0  0 
      nip tuck  h# 3000000 and h# 1000000 =       ( phys.hi phys.lo io? )
1A34CCC 	FC 46 A0  1 
1A34CD0 	E8 46 A0  1 58 41 A0  1 
1A34CD8 	 0  0  0  3 5C 44 A0  1 
1A34CE0 	58 41 A0  1  0  0  0  1 
1A34CE8 	24 48 A0  1 
   else                                             ( phys.lo..hi )
1A34CEC 	C8 41 A0  1 
1A34CF0 	30  0  0  0 
      probe-state?  if                              ( phys.lo..hi )
1A34CF4 	AC 3C A3  1 
1A34CF8 	DC 41 A0  1 18  0  0  0 
         r@ assign-pci-addr drop                    ( phys.hi paddr )
1A34D00 	E4 45 A0  1 28 49 A3  1 
1A34D08 	30 49 A0  1 
      else                                          ( phys.lo..hi)
1A34D0C 	C8 41 A0  1 
1A34D10 	 8  0  0  0 
         get-address                                ( phys.hi paddr )
1A34D14 	7C 47 A3  1 
      then                                          ( phys.hi paddr )
      over io?                                      ( phys.hi paddr io? )
1A34D18 	54 49 A0  1  C 3F A3  1 
   then then                                        ( phys.hi paddr io? )
   \ The PCI bus physical base address has been assigned.
   \ Now determine the virtual address.
   rot r> map-pci-phys                              ( vaddr )
1A34D20 	7C 49 A0  1 D0 45 A0  1 
1A34D28 	FC 39 A3  1 
;
1A34D2C 	58 46 A0  1 

: open  ( -- )  true  ;
1A34D30 	 0  0  0 6F 70 65 6E 84 
1A34D38 	80 4C A3  1 20 40 A0  1 
1A34D40 	 4 70 A0  1 58 46 A0  1 
: close  ;
1A34D48 	 0  0 63 6C 6F 73 65 85 
1A34D50 	3C 4D A3  1 20 40 A0  1 
1A34D58 	58 46 A0  1 

headerless

\ The my-X@ words are executed in the child instance
: my-b@  ( offset -- b )  my-space +  " config-b@" $call-parent  ;
1A34D5C 	 0  0 6D 79 
1A34D60 	2D 62 40 85 54 4D A3  1 
1A34D68 	20 40 A0  1 AC  3 A2  1 
1A34D70 	 4 45 A0  1 9C 53 A0  1 
1A34D78 	 9 63 6F 6E 66 69 67 2D 
1A34D80 	62 40  0  0 DC 31 A2  1 
1A34D88 	58 46 A0  1 
: my-b!  ( b offset -- )  my-space +  " config-b!" $call-parent  ;
1A34D8C 	 0  0 6D 79 
1A34D90 	2D 62 21 85 68 4D A3  1 
1A34D98 	20 40 A0  1 AC  3 A2  1 
1A34DA0 	 4 45 A0  1 9C 53 A0  1 
1A34DA8 	 9 63 6F 6E 66 69 67 2D 
1A34DB0 	62 21  0  0 DC 31 A2  1 
1A34DB8 	58 46 A0  1 
: my-w@  ( offset -- w )  my-space +  " config-w@" $call-parent  ;
1A34DBC 	 0  0 6D 79 
1A34DC0 	2D 77 40 85 98 4D A3  1 
1A34DC8 	20 40 A0  1 AC  3 A2  1 
1A34DD0 	 4 45 A0  1 9C 53 A0  1 
1A34DD8 	 9 63 6F 6E 66 69 67 2D 
1A34DE0 	77 40  0  0 DC 31 A2  1 
1A34DE8 	58 46 A0  1 
: my-w!  ( w offset -- )  my-space +  " config-w!" $call-parent  ;
1A34DEC 	 0  0 6D 79 
1A34DF0 	2D 77 21 85 C8 4D A3  1 
1A34DF8 	20 40 A0  1 AC  3 A2  1 
1A34E00 	 4 45 A0  1 9C 53 A0  1 
1A34E08 	 9 63 6F 6E 66 69 67 2D 
1A34E10 	77 21  0  0 DC 31 A2  1 
1A34E18 	58 46 A0  1 
: my-l@  ( offset -- l )  my-space +  " config-l@" $call-parent  ;
1A34E1C 	 0  0 6D 79 
1A34E20 	2D 6C 40 85 F8 4D A3  1 
1A34E28 	20 40 A0  1 AC  3 A2  1 
1A34E30 	 4 45 A0  1 9C 53 A0  1 
1A34E38 	 9 63 6F 6E 66 69 67 2D 
1A34E40 	6C 40  0  0 DC 31 A2  1 
1A34E48 	58 46 A0  1 
: my-l!  ( l offset -- )  my-space +  " config-l!" $call-parent  ;
1A34E4C 	 0  0 6D 79 
1A34E50 	2D 6C 21 85 28 4E A3  1 
1A34E58 	20 40 A0  1 AC  3 A2  1 
1A34E60 	 4 45 A0  1 9C 53 A0  1 
1A34E68 	 9 63 6F 6E 66 69 67 2D 
1A34E70 	6C 21  0  0 DC 31 A2  1 
1A34E78 	58 46 A0  1 

\ Create an integer-valued property with name "name$" and value "n".

: int-property  ( n name$ -- )  rot encode-int  2swap property  ;
1A34E7C 	 0  0  0 69 
1A34E80 	6E 74 2D 70 72 6F 70 65 
1A34E88 	72 74 79 8C 58 4E A3  1 
1A34E90 	20 40 A0  1 7C 49 A0  1 
1A34E98 	40 F7 A1  1 F4 49 A0  1 
1A34EA0 	BC 14 A2  1 58 46 A0  1 

\ Create an integer-valued property named "name$" from a 16-bit
\ configuration space register.

: int16-property  ( offset name$ -- )
1A34EA8 	 0 69 6E 74 31 36 2D 70 
1A34EB0 	72 6F 70 65 72 74 79 8E 
1A34EB8 	90 4E A3  1 20 40 A0  1 
   >r >r  my-w@  encode-int  r> r> property
1A34EC0 	BC 45 A0  1 BC 45 A0  1 
1A34EC8 	C8 4D A3  1 40 F7 A1  1 
1A34ED0 	D0 45 A0  1 D0 45 A0  1 
1A34ED8 	BC 14 A2  1 
;
1A34EDC 	58 46 A0  1 

\ Create an integer-valued property named "name$" from an 8-bit
\ configuration space register.

: int8-property  ( offset name$ -- )
1A34EE0 	 0  0 69 6E 74 38 2D 70 
1A34EE8 	72 6F 70 65 72 74 79 8D 
1A34EF0 	BC 4E A3  1 20 40 A0  1 
   >r >r  my-b@  encode-int  r> r> property
1A34EF8 	BC 45 A0  1 BC 45 A0  1 
1A34F00 	68 4D A3  1 40 F7 A1  1 
1A34F08 	D0 45 A0  1 D0 45 A0  1 
1A34F10 	BC 14 A2  1 
;
1A34F14 	58 46 A0  1 

\ True if the header type indicates that the function is a PCI-PCI bridge
: bridge?  ( -- flag )  h# 0e my-b@  h# 7f and  1 =   ;
1A34F18 	62 72 69 64 67 65 3F 87 
1A34F20 	F4 4E A3  1 20 40 A0  1 
1A34F28 	58 41 A0  1  E  0  0  0 
1A34F30 	68 4D A3  1 58 41 A0  1 
1A34F38 	7F  0  0  0 5C 44 A0  1 
1A34F40 	80 6F A0  1 24 48 A0  1 
1A34F48 	58 46 A0  1 

\ True if the header type indicates that the funtion is a PCI-Cardbus
: card-bus? ( -- flag ) h# 0e my-b@  h# 7f and h# 2 =  ;
1A34F4C 	 0  0 63 61 
1A34F50 	72 64 2D 62 75 73 3F 89 
1A34F58 	24 4F A3  1 20 40 A0  1 
1A34F60 	58 41 A0  1  E  0  0  0 
1A34F68 	68 4D A3  1 58 41 A0  1 
1A34F70 	7F  0  0  0 5C 44 A0  1 
1A34F78 	58 41 A0  1  2  0  0  0 
1A34F80 	24 48 A0  1 58 46 A0  1 

\ Create properties reflecting standard configuration header information

: class-code  ( -- n )  8 my-l@ 8 rshift  ;
1A34F88 	 0 63 6C 61 73 73 2D 63 
1A34F90 	6F 64 65 8A 5C 4F A3  1 
1A34F98 	20 40 A0  1 F0 6F A0  1 
1A34FA0 	28 4E A3  1 F0 6F A0  1 
1A34FA8 	B4 44 A0  1 58 46 A0  1 
: make-child-properties  ( -- )
1A34FB0 	 0  0 6D 61 6B 65 2D 63 
1A34FB8 	68 69 6C 64 2D 70 72 6F 
1A34FC0 	70 65 72 74 69 65 73 95 
1A34FC8 	98 4F A3  1 20 40 A0  1 
   h# 00     " vendor-id"   int16-property
1A34FD0 	58 41 A0  1  0  0  0  0 
1A34FD8 	9C 53 A0  1  9 76 65 6E 
1A34FE0 	64 6F 72 2D 69 64  0  0 
1A34FE8 	BC 4E A3  1 
   h# 02     " device-id"   int16-property
1A34FEC 	58 41 A0  1 
1A34FF0 	 2  0  0  0 9C 53 A0  1 
1A34FF8 	 9 64 65 76 69 63 65 2D 
1A35000 	69 64  0  0 BC 4E A3  1 
   h# 08     " revision-id" int8-property
1A35008 	58 41 A0  1  8  0  0  0 
1A35010 	9C 53 A0  1  B 72 65 76 
1A35018 	69 73 69 6F 6E 2D 69 64 
1A35020 	 0  0  0  0 F4 4E A3  1 
 cr ." make-child-properties11 " here .h
1A35028 	80 6D A0  1 20 7C A0  1 
1A35030 	18 6D 61 6B 65 2D 63 68 
1A35038 	69 6C 64 2D 70 72 6F 70 
1A35040 	65 72 74 69 65 73 31 31 
1A35048 	20  0  0  0 70 54 A0  1 
1A35050 	10  E A1  1 
   bridge?  card-bus? or 0=  dup .h if
1A35054 	24 4F A3  1 
1A35058 	5C 4F A3  1 70 44 A0  1 
1A35060 	24 47 A0  1 40 49 A0  1 
1A35068 	10  E A1  1 DC 41 A0  1 
1A35070 	40  0  0  0 
      h# 3e  " min-grant"   int8-property
1A35074 	58 41 A0  1 
1A35078 	3E  0  0  0 9C 53 A0  1 
1A35080 	 9 6D 69 6E 2D 67 72 61 
1A35088 	6E 74  0  0 F4 4E A3  1 
      h# 3f  " max-latency" int8-property
1A35090 	58 41 A0  1 3F  0  0  0 
1A35098 	9C 53 A0  1  B 6D 61 78 
1A350A0 	2D 6C 61 74 65 6E 63 79 
1A350A8 	 0  0  0  0 F4 4E A3  1 
   then
 cr ." make-child-properties22 " here .h
1A350B0 	80 6D A0  1 20 7C A0  1 
1A350B8 	18 6D 61 6B 65 2D 63 68 
1A350C0 	69 6C 64 2D 70 72 6F 70 
1A350C8 	65 72 74 69 65 73 32 32 
1A350D0 	20  0  0  0 70 54 A0  1 
1A350D8 	10  E A1  1 
\ mmo   h# 3d my-b@  ?dup dup .  if                       ( int )
\ mmo      dup encode-int " interrupts" property    ( int )
\ mmo      my-space swap  " assign-int-line" $call-parent  if  h# 3c my-b!  then
\ mmo   then                                        ( )

   h# 2e  " subsystem-id"         int16-property
1A350DC 	58 41 A0  1 
1A350E0 	2E  0  0  0 9C 53 A0  1 
1A350E8 	 C 73 75 62 73 79 73 74 
1A350F0 	65 6D 2D 69 64  0  0  0 
1A350F8 	BC 4E A3  1 
   h# 2c  " subsystem-vendor-id"  int16-property
1A350FC 	58 41 A0  1 
1A35100 	2C  0  0  0 9C 53 A0  1 
1A35108 	13 73 75 62 73 79 73 74 
1A35110 	65 6D 2D 76 65 6E 64 6F 
1A35118 	72 2D 69 64  0  0  0  0 
1A35120 	BC 4E A3  1 

   class-code  encode-int  " class-code"  property
1A35124 	98 4F A3  1 
1A35128 	40 F7 A1  1 9C 53 A0  1 
1A35130 	 A 63 6C 61 73 73 2D 63 
1A35138 	6F 64 65  0 BC 14 A2  1 
   6 my-w@
1A35140 	D0 6F A0  1 C8 4D A3  1 
      dup 9 rshift 3 and  " devsel-speed"       int-property
1A35148 	40 49 A0  1 58 41 A0  1 
1A35150 	 9  0  0  0 B4 44 A0  1 
1A35158 	A0 6F A0  1 5C 44 A0  1 
1A35160 	9C 53 A0  1  C 64 65 76 
1A35168 	73 65 6C 2D 73 70 65 65 
1A35170 	64  0  0  0 90 4E A3  1 
 cr ." make-child-properties44 " here .h
1A35178 	80 6D A0  1 20 7C A0  1 
1A35180 	18 6D 61 6B 65 2D 63 68 
1A35188 	69 6C 64 2D 70 72 6F 70 
1A35190 	65 72 74 69 65 73 34 34 
1A35198 	20  0  0  0 70 54 A0  1 
1A351A0 	10  E A1  1 
\ MMO      dup 7 rshift 1 and dup .  if  0 0  " fast-back-to-back"  property  then
      dup 6 rshift 1 and dup .  if  0 0  " udf-supported"      property  then
1A351A4 	40 49 A0  1 
1A351A8 	D0 6F A0  1 B4 44 A0  1 
1A351B0 	80 6F A0  1 5C 44 A0  1 
1A351B8 	40 49 A0  1 94 7A A0  1 
1A351C0 	DC 41 A0  1 24  0  0  0 
1A351C8 	70 6F A0  1 70 6F A0  1 
1A351D0 	9C 53 A0  1  D 75 64 66 
1A351D8 	2D 73 75 70 70 6F 72 74 
1A351E0 	65 64  0  0 BC 14 A2  1 
          5 rshift 1 and dup .  if  0 0  " 66mhz-capable"      property  then
1A351E8 	C0 6F A0  1 B4 44 A0  1 
1A351F0 	80 6F A0  1 5C 44 A0  1 
1A351F8 	40 49 A0  1 94 7A A0  1 
1A35200 	DC 41 A0  1 24  0  0  0 
1A35208 	70 6F A0  1 70 6F A0  1 
1A35210 	9C 53 A0  1  D 36 36 6D 
1A35218 	68 7A 2D 63 61 70 61 62 
1A35220 	6C 65  0  0 BC 14 A2  1 

   \ Find the cache line size, and put it (divided by 4) into the
   \ cache-line-size register at offset 0x0c
 cr ." make-child-properties55 " here .h
1A35228 	80 6D A0  1 20 7C A0  1 
1A35230 	18 6D 61 6B 65 2D 63 68 
1A35238 	69 6C 64 2D 70 72 6F 70 
1A35240 	65 72 74 69 65 73 35 35 
1A35248 	20  0  0  0 70 54 A0  1 
1A35250 	10  E A1  1 

   cpu-node @ dup .  if
1A35254 	FC E4 A1  1 
1A35258 	5C 4C A0  1 40 49 A0  1 
1A35260 	94 7A A0  1 DC 41 A0  1 
1A35268 	60  0  0  0 
      " d-cache-block-size" cpu-node @	( adr len ihandle )
1A3526C 	9C 53 A0  1 
1A35270 	12 64 2D 63 61 63 68 65 
1A35278 	2D 62 6C 6F 63 6B 2D 73 
1A35280 	69 7A 65  0 FC E4 A1  1 
1A35288 	5C 4C A0  1 
      ihandle>phandle			( adr len phandle )
1A3528C 	 0 32 A2  1 
      get-package-property		( adr len false | true )
1A35290 	98 33 A2  1 
      0= dup .  if				( adr len )
1A35294 	24 47 A0  1 
1A35298 	40 49 A0  1 94 7A A0  1 
1A352A0 	DC 41 A0  1 24  0  0  0 
         decode-int nip nip		( line-size )
1A352A8 	68 F7 A1  1 FC 46 A0  1 
1A352B0 	FC 46 A0  1 
         4 / h# 0c			( size adr )
1A352B4 	B0 6F A0  1 
1A352B8 	98 5F A0  1 58 41 A0  1 
1A352C0 	 C  0  0  0 
         my-b!				(  )
1A352C4 	98 4D A3  1 
      then				(  )
   then

   \ Set the latency-timer to a default of 32
   h# 20 h# 0d my-b!			( )
1A352C8 	58 41 A0  1 20  0  0  0 
1A352D0 	58 41 A0  1  D  0  0  0 
1A352D8 	98 4D A3  1 
;
1A352DC 	58 46 A0  1 
: make-function-properties  ( child-ihandle -- )
1A352E0 	 0  0  0 6D 61 6B 65 2D 
1A352E8 	66 75 6E 63 74 69 6F 6E 
1A352F0 	2D 70 72 6F 70 65 72 74 
1A352F8 	69 65 73 98 CC 4F A3  1 
1A35300 	20 40 A0  1 
   to my-self	\ Get back into child node
1A35304 	B8 40 A0  1 
1A35308 	EC 7E A0  1 
   make-child-properties
1A3530C 	CC 4F A3  1 
;
1A35310 	58 46 A0  1 

\ Create a "name" property of the form "pciVVVV,DDDD", where VVVV and
\ DDDD are the hexadecimal representations of the vendor ID and device
\ ID, respectively.

: $hold  ( adr len -- )
1A35314 	 0  0 24 68 
1A35318 	6F 6C 64 85  0 53 A3  1 
1A35320 	20 40 A0  1 
   dup  if  bounds swap 1-  ?do  i c@ hold  -1 +loop  else  2drop  then
1A35324 	40 49 A0  1 
1A35328 	DC 41 A0  1 3C  0  0  0 
1A35330 	F0 6D A0  1 68 49 A0  1 
1A35338 	54 4B A0  1 50 42 A0  1 
1A35340 	20  0  0  0 B4 42 A0  1 
1A35348 	C4 4C A0  1 DC 75 A0  1 
1A35350 	58 41 A0  1 FF FF FF FF 
1A35358 	1C 42 A0  1 E8 FF FF FF 
1A35360 	C8 41 A0  1  8  0  0  0 
1A35368 	AC 49 A0  1 
;
1A3536C 	58 46 A0  1 
: ascii-vendor-id  ( device/vendor-id -- adr len )
1A35370 	61 73 63 69 69 2D 76 65 
1A35378 	6E 64 6F 72 2D 69 64 8F 
1A35380 	20 53 A3  1 20 40 A0  1 
   lwsplit
1A35388 	A0 4F A0  1 
   push-hex
1A3538C 	5C F4 A0  1 
   <# u#s drop ascii , hold u#s  " pci" $hold  u#> string2 $save
1A35390 	 8 76 A0  1 BC 76 A0  1 
1A35398 	30 49 A0  1 58 41 A0  1 
1A353A0 	2C  0  0  0 DC 75 A0  1 
1A353A8 	BC 76 A0  1 9C 53 A0  1 
1A353B0 	 3 70 63 69  0  0  0  0 
1A353B8 	20 53 A3  1 E0 76 A0  1 
1A353C0 	B8 3B A3  1 68 7E A0  1 
   pop-base
1A353C8 	9C F4 A0  1 
;
1A353CC 	58 46 A0  1 
: name-property-value  ( -- adr len )  0 my-l@ ascii-vendor-id  ;
1A353D0 	6E 61 6D 65 2D 70 72 6F 
1A353D8 	70 65 72 74 79 2D 76 61 
1A353E0 	6C 75 65 93 84 53 A3  1 
1A353E8 	20 40 A0  1 70 6F A0  1 
1A353F0 	28 4E A3  1 84 53 A3  1 
1A353F8 	58 46 A0  1 

: class-name: ( code "name" --- )  ,  parse-word ",  align  ;
1A353FC 	63 6C 61 73 
1A35400 	73 2D 6E 61 6D 65 3A 8B 
1A35408 	E8 53 A3  1 20 40 A0  1 
1A35410 	98 55 A0  1 34 93 A0  1 
1A35418 	24 89 A0  1 34 62 A0  1 
1A35420 	58 46 A0  1 

hex
create class-names
1A35424 	63 6C 61 73 
1A35428 	73 2D 6E 61 6D 65 73 8B 
1A35430 	 C 54 A3  1 30 40 A0  1 

ffffff ,  \ Mask
1A35438 	FF FF FF  0 
000100 class-name: display
1A3543C 	 0  1  0  0 
1A35440 	 7 64 69 73 70 6C 61 79 
1A35448 	 0  0  0  0 
0 , 	  \ No more entries for this mask
1A3544C 	 0  0  0  0 

ff0000 ,  \ Mask
1A35450 	 0  0 FF  0 
030000 class-name: display
1A35454 	 0  0  3  0 
1A35458 	 7 64 69 73 70 6C 61 79 
1A35460 	 0  0  0  0 
0a0000 class-name: dock
1A35464 	 0  0  A  0 
1A35468 	 4 64 6F 63 6B  0  0  0 
0b0000 class-name: cpu
1A35470 	 0  0  B  0  3 63 70 75 
1A35478 	 0  0  0  0 
0 , 	  \ No more entries for this mask
1A3547C 	 0  0  0  0 

ffff00 ,  \ Mask
1A35480 	 0 FF FF  0 
010000 class-name: scsi
1A35484 	 0  0  1  0 
1A35488 	 4 73 63 73 69  0  0  0 
010100 class-name: ide
1A35490 	 0  1  1  0  3 69 64 65 
1A35498 	 0  0  0  0 
010200 class-name: fdc
1A3549C 	 0  2  1  0 
1A354A0 	 3 66 64 63  0  0  0  0 
010300 class-name: ipi
1A354A8 	 0  3  1  0  3 69 70 69 
1A354B0 	 0  0  0  0 
010400 class-name: raid
1A354B4 	 0  4  1  0 
1A354B8 	 4 72 61 69 64  0  0  0 
020000 class-name: ethernet
1A354C0 	 0  0  2  0  8 65 74 68 
1A354C8 	65 72 6E 65 74  0  0  0 
020100 class-name: token
1A354D0 	 0  1  2  0  5 74 6F 6B 
1A354D8 	65 6E  0  0 
020200 class-name: fddi
1A354DC 	 0  2  2  0 
1A354E0 	 4 66 64 64 69  0  0  0 
020300 class-name: atm
1A354E8 	 0  3  2  0  3 61 74 6D 
1A354F0 	 0  0  0  0 
040000 class-name: video
1A354F4 	 0  0  4  0 
1A354F8 	 5 76 69 64 65 6F  0  0 
040100 class-name: sound
1A35500 	 0  1  4  0  5 73 6F 75 
1A35508 	6E 64  0  0 
050000 class-name: memory
1A3550C 	 0  0  5  0 
1A35510 	 6 6D 65 6D 6F 72 79  0 
050100 class-name: flash
1A35518 	 0  1  5  0  5 66 6C 61 
1A35520 	73 68  0  0 
060000 class-name: host
1A35524 	 0  0  6  0 
1A35528 	 4 68 6F 73 74  0  0  0 
060100 class-name: isa
1A35530 	 0  1  6  0  3 69 73 61 
1A35538 	 0  0  0  0 
060200 class-name: eisa
1A3553C 	 0  2  6  0 
1A35540 	 4 65 69 73 61  0  0  0 
060300 class-name: mca
1A35548 	 0  3  6  0  3 6D 63 61 
1A35550 	 0  0  0  0 
060400 class-name: pci
1A35554 	 0  4  6  0 
1A35558 	 3 70 63 69  0  0  0  0 
060500 class-name: pcmcia
1A35560 	 0  5  6  0  6 70 63 6D 
1A35568 	63 69 61  0 
060600 class-name: nubus
1A3556C 	 0  6  6  0 
1A35570 	 5 6E 75 62 75 73  0  0 
060700 class-name: cardbus
1A35578 	 0  7  6  0  7 63 61 72 
1A35580 	64 62 75 73  0  0  0  0 
070000 class-name: serial
1A35588 	 0  0  7  0  6 73 65 72 
1A35590 	69 61 6C  0 
070100 class-name: parallel
1A35594 	 0  1  7  0 
1A35598 	 8 70 61 72 61 6C 6C 65 
1A355A0 	6C  0  0  0 
080000 class-name: interrupt
1A355A4 	 0  0  8  0 
1A355A8 	 9 69 6E 74 65 72 72 75 
1A355B0 	70 74  0  0 
080100 class-name: dma
1A355B4 	 0  1  8  0 
1A355B8 	 3 64 6D 61  0  0  0  0 
080200 class-name: timer
1A355C0 	 0  2  8  0  5 74 69 6D 
1A355C8 	65 72  0  0 
080300 class-name: rtc
1A355CC 	 0  3  8  0 
1A355D0 	 3 72 74 63  0  0  0  0 
090000 class-name: keyboard
1A355D8 	 0  0  9  0  8 6B 65 79 
1A355E0 	62 6F 61 72 64  0  0  0 
090100 class-name: pen
1A355E8 	 0  1  9  0  3 70 65 6E 
1A355F0 	 0  0  0  0 
090200 class-name: mouse
1A355F4 	 0  2  9  0 
1A355F8 	 5 6D 6F 75 73 65  0  0 
0c0000 class-name: firewire
1A35600 	 0  0  C  0  8 66 69 72 
1A35608 	65 77 69 72 65  0  0  0 
0c0100 class-name: access
1A35610 	 0  1  C  0  6 61 63 63 
1A35618 	65 73 73  0 
0c0200 class-name: ssa
1A3561C 	 0  2  C  0 
1A35620 	 3 73 73 61  0  0  0  0 
0c0300 class-name: usb
1A35628 	 0  3  C  0  3 75 73 62 
1A35630 	 0  0  0  0 
0c0300 class-name: fibre
1A35634 	 0  3  C  0 
1A35638 	 5 66 69 62 72 65  0  0 
0 ,       \ No more entries for this mask
1A35640 	 0  0  0  0 
0 ,       \ End of table
1A35644 	 0  0  0  0 

: @+  ( adr -- adr' n )  dup na1+ swap @  ;
1A35648 	 0 40 2B 82 34 54 A3  1 
1A35650 	20 40 A0  1 40 49 A0  1 
1A35658 	CC 50 A0  1 68 49 A0  1 
1A35660 	5C 4C A0  1 58 46 A0  1 

: unknown-class?  ( class-code -- true | class-name$ false )
1A35668 	 0 75 6E 6B 6E 6F 77 6E 
1A35670 	2D 63 6C 61 73 73 3F 8E 
1A35678 	50 56 A3  1 20 40 A0  1 
   \ The outer loop executes once for each distinct mask value
   class-names  begin  @+  dup  while        ( code adr mask )
1A35680 	34 54 A3  1 50 56 A3  1 
1A35688 	40 49 A0  1 DC 41 A0  1 
1A35690 	74  0  0  0 
      2 pick and >r                          ( code adr r: masked-code )
1A35694 	90 6F A0  1 
1A35698 	 C 4A A0  1 5C 44 A0  1 
1A356A0 	BC 45 A0  1 

      \ The inner loop searches all entries with that mask value
      begin  @+  dup  while                  ( code adr match )
1A356A4 	50 56 A3  1 
1A356A8 	40 49 A0  1 DC 41 A0  1 
1A356B0 	44  0  0  0 

         r@ =  if                            ( code adr )
1A356B4 	E4 45 A0  1 
1A356B8 	24 48 A0  1 DC 41 A0  1 
1A356C0 	1C  0  0  0 
            \ A match under the mask was found; return the string
            r> drop nip  count false  exit   ( class-name$ false )
1A356C4 	D0 45 A0  1 
1A356C8 	30 49 A0  1 FC 46 A0  1 
1A356D0 	BC 53 A0  1 18 70 A0  1 
1A356D8 	40 46 A0  1 
         then                                ( code adr )

         \ Skip the string and proceed to the next entry
         count + 1+ aligned
1A356DC 	BC 53 A0  1 
1A356E0 	 4 45 A0  1 30 4B A0  1 
1A356E8 	EC 5C A0  1 
      repeat                                 ( code adr 0 )
1A356EC 	C8 41 A0  1 
1A356F0 	B4 FF FF FF 

      \ Proceed to the next mask value
      r> 2drop                               ( code adr )
1A356F4 	D0 45 A0  1 
1A356F8 	AC 49 A0  1 
   repeat                                    ( code adr 0 )
1A356FC 	C8 41 A0  1 
1A35700 	84 FF FF FF 

   \ No match was found
   3drop true                                ( true )
1A35704 	90 52 A0  1 
1A35708 	 4 70 A0  1 
;
1A3570C 	58 46 A0  1 
: make-name-property  ( -- )
1A35710 	 0 6D 61 6B 65 2D 6E 61 
1A35718 	6D 65 2D 70 72 6F 70 65 
1A35720 	72 74 79 92 7C 56 A3  1 
1A35728 	20 40 A0  1 
   class-code unknown-class?  if  name-property-value  then
1A3572C 	98 4F A3  1 
1A35730 	7C 56 A3  1 DC 41 A0  1 
1A35738 	 8  0  0  0 E8 53 A3  1 
   encode-string  " name" property
1A35740 	A0 F6 A1  1 9C 53 A0  1 
1A35748 	 4 6E 61 6D 65  0  0  0 
1A35750 	BC 14 A2  1 
;
1A35754 	58 46 A0  1 
: +string  ( prop-adr,len string-adr,len -- prop-adr,len' )
1A35758 	2B 73 74 72 69 6E 67 87 
1A35760 	28 57 A3  1 20 40 A0  1 
   encode-string  encode+
1A35768 	A0 F6 A1  1 F0 F5 A1  1 
;
1A35770 	58 46 A0  1 

: <#class  ( -- arguments-to-u#> )
1A35774 	3C 23 63 6C 
1A35778 	61 73 73 87 64 57 A3  1 
1A35780 	20 40 A0  1 
   class-code  push-hex <# u# u# u# u# u# u#  pop-base
1A35784 	98 4F A3  1 
1A35788 	5C F4 A0  1  8 76 A0  1 
1A35790 	94 76 A0  1 94 76 A0  1 
1A35798 	94 76 A0  1 94 76 A0  1 
1A357A0 	94 76 A0  1 94 76 A0  1 
1A357A8 	9C F4 A0  1 
;
1A357AC 	58 46 A0  1 
: class-property-value  ( -- adr len )
1A357B0 	 0  0  0 63 6C 61 73 73 
1A357B8 	2D 70 72 6F 70 65 72 74 
1A357C0 	79 2D 76 61 6C 75 65 94 
1A357C8 	80 57 A3  1 20 40 A0  1 
   <#class " class" $hold u#> string3 $save
1A357D0 	80 57 A3  1 9C 53 A0  1 
1A357D8 	 5 63 6C 61 73 73  0  0 
1A357E0 	20 53 A3  1 E0 76 A0  1 
1A357E8 	D4 3B A3  1 68 7E A0  1 
;
1A357F0 	58 46 A0  1 
headers
: make-compatible-property  ( -- )
1A357F4 	 0  0  0 6D 
1A357F8 	61 6B 65 2D 63 6F 6D 70 
1A35800 	61 74 69 62 6C 65 2D 70 
1A35808 	72 6F 70 65 72 74 79 98 
1A35810 	CC 57 A3  1 20 40 A0  1 
   0 0 encode-bytes
1A35818 	70 6F A0  1 70 6F A0  1 
1A35820 	14 F6 A1  1 
 cr ." make-compatible-property11 " here .h
1A35824 	80 6D A0  1 
1A35828 	20 7C A0  1 1B 6D 61 6B 
1A35830 	65 2D 63 6F 6D 70 61 74 
1A35838 	69 62 6C 65 2D 70 72 6F 
1A35840 	70 65 72 74 79 31 31 20 
1A35848 	 0  0  0  0 70 54 A0  1 
1A35850 	10  E A1  1 
\ mmo   h# 2c my-l@  ?dup dup .  if  ascii-vendor-id +string  then
   name-property-value +string
1A35854 	E8 53 A3  1 
1A35858 	64 57 A3  1 
   <#class " pciclass," $hold u#>  +string
1A3585C 	80 57 A3  1 
1A35860 	9C 53 A0  1  9 70 63 69 
1A35868 	63 6C 61 73 73 2C  0  0 
1A35870 	20 53 A3  1 E0 76 A0  1 
1A35878 	64 57 A3  1 
 cr ." make-compatible-property22 " here .h 2dup type
1A3587C 	80 6D A0  1 
1A35880 	20 7C A0  1 1B 6D 61 6B 
1A35888 	65 2D 63 6F 6D 70 61 74 
1A35890 	69 62 6C 65 2D 70 72 6F 
1A35898 	70 65 72 74 79 32 32 20 
1A358A0 	 0  0  0  0 70 54 A0  1 
1A358A8 	10  E A1  1 C0 49 A0  1 
1A358B0 	 4 6C A0  1 
   " compatible" property
1A358B4 	9C 53 A0  1 
1A358B8 	 A 63 6F 6D 70 61 74 69 
1A358C0 	62 6C 65  0 BC 14 A2  1 
 cr ." make-compatible-property33 " here .h
1A358C8 	80 6D A0  1 20 7C A0  1 
1A358D0 	1B 6D 61 6B 65 2D 63 6F 
1A358D8 	6D 70 61 74 69 62 6C 65 
1A358E0 	2D 70 72 6F 70 65 72 74 
1A358E8 	79 33 33 20  0  0  0  0 
1A358F0 	70 54 A0  1 10  E A1  1 
;
1A358F8 	58 46 A0  1 
headerless

\ If the expansion ROM mapped at "virt" contains an FCode program,
\ copy it into RAM and return its address

: get-int-property  ( adr len -- n )
1A358FC 	 0  0  0 67 
1A35900 	65 74 2D 69 6E 74 2D 70 
1A35908 	72 6F 70 65 72 74 79 90 
1A35910 	14 58 A3  1 20 40 A0  1 
   get-my-property  if  -1  else  decode-int nip nip  then
1A35918 	1C 34 A2  1 DC 41 A0  1 
1A35920 	14  0  0  0 58 41 A0  1 
1A35928 	FF FF FF FF C8 41 A0  1 
1A35930 	10  0  0  0 68 F7 A1  1 
1A35938 	FC 46 A0  1 FC 46 A0  1 
;
1A35940 	58 46 A0  1 
: fcode-image?  ( PCI-struct-adr -- flag )
1A35944 	 0  0  0 66 
1A35948 	63 6F 64 65 2D 69 6D 61 
1A35950 	67 65 3F 8C 14 59 A3  1 
1A35958 	20 40 A0  1 
   dup " PCIR" comp  if  drop false exit  then
1A3595C 	40 49 A0  1 
1A35960 	9C 53 A0  1  4 50 43 49 
1A35968 	52  0  0  0 38 52 A0  1 
1A35970 	DC 41 A0  1 10  0  0  0 
1A35978 	30 49 A0  1 18 70 A0  1 
1A35980 	40 46 A0  1 

   probemsg?  if
1A35984 	20 3B A3  1 
1A35988 	DC 41 A0  1 6C  0  0  0 
      ??cr
1A35990 	 0 A1 A0  1 
      ."   Function:" " vendor-id" get-int-property 4 u.r
1A35994 	20 7C A0  1 
1A35998 	 B 20 20 46 75 6E 63 74 
1A359A0 	69 6F 6E 3A  0  0  0  0 
1A359A8 	9C 53 A0  1  9 76 65 6E 
1A359B0 	64 6F 72 2D 69 64  0  0 
1A359B8 	14 59 A3  1 B0 6F A0  1 
1A359C0 	E4 77 A0  1 
      ."   Function:" " device-id" get-int-property 4 u.r
1A359C4 	20 7C A0  1 
1A359C8 	 B 20 20 46 75 6E 63 74 
1A359D0 	69 6F 6E 3A  0  0  0  0 
1A359D8 	9C 53 A0  1  9 64 65 76 
1A359E0 	69 63 65 2D 69 64  0  0 
1A359E8 	14 59 A3  1 B0 6F A0  1 
1A359F0 	E4 77 A0  1 
      ??cr
1A359F4 	 0 A1 A0  1 
   then

   \ always accept ROMs with vendor-id and device-id = ffff
   dup h# 04 + le-w@  dup h# ffff <>  if             ( adr id )
1A359F8 	40 49 A0  1 58 41 A0  1 
1A35A00 	 4  0  0  0  4 45 A0  1 
1A35A08 	80 4C A0  1 40 49 A0  1 
1A35A10 	58 41 A0  1 FF FF  0  0 
1A35A18 	44 48 A0  1 DC 41 A0  1 
1A35A20 	D0  0  0  0 
      " vendor-id" get-int-property  <>  if          ( adr )
1A35A24 	9C 53 A0  1 
1A35A28 	 9 76 65 6E 64 6F 72 2D 
1A35A30 	69 64  0  0 14 59 A3  1 
1A35A38 	44 48 A0  1 DC 41 A0  1 
1A35A40 	A8  0  0  0 
         probemsg?  if                               ( adr )
1A35A44 	20 3B A3  1 
1A35A48 	DC 41 A0  1 90  0  0  0 
            ??cr
1A35A50 	 0 A1 A0  1 
            ."   Vendor IDs do not match ->  "
1A35A54 	20 7C A0  1 
1A35A58 	1E 20 20 56 65 6E 64 6F 
1A35A60 	72 20 49 44 73 20 64 6F 
1A35A68 	20 6E 6F 74 20 6D 61 74 
1A35A70 	63 68 20 2D 3E 20 20  0 
            ."   Function:" " vendor-id" get-int-property 4 u.r
1A35A78 	20 7C A0  1  B 20 20 46 
1A35A80 	75 6E 63 74 69 6F 6E 3A 
1A35A88 	 0  0  0  0 9C 53 A0  1 
1A35A90 	 9 76 65 6E 64 6F 72 2D 
1A35A98 	69 64  0  0 14 59 A3  1 
1A35AA0 	B0 6F A0  1 E4 77 A0  1 
            ." /ROM Image:" dup h# 04 + le-w@ 4 u.r  cr
1A35AA8 	20 7C A0  1  B 2F 52 4F 
1A35AB0 	4D 20 49 6D 61 67 65 3A 
1A35AB8 	 0  0  0  0 40 49 A0  1 
1A35AC0 	58 41 A0  1  4  0  0  0 
1A35AC8 	 4 45 A0  1 80 4C A0  1 
1A35AD0 	B0 6F A0  1 E4 77 A0  1 
1A35AD8 	80 6D A0  1 
         then                                        ( adr )
	 drop false exit                             ( false )
1A35ADC 	30 49 A0  1 
1A35AE0 	18 70 A0  1 40 46 A0  1 
      then                                           ( adr )
   else                                              ( adr id )
1A35AE8 	C8 41 A0  1  8  0  0  0 
      drop                                           ( adr )
1A35AF0 	30 49 A0  1 
   then                                              ( adr )

   dup h# 06 + le-w@  dup h# ffff <>  if             ( adr id )
1A35AF4 	40 49 A0  1 
1A35AF8 	58 41 A0  1  6  0  0  0 
1A35B00 	 4 45 A0  1 80 4C A0  1 
1A35B08 	40 49 A0  1 58 41 A0  1 
1A35B10 	FF FF  0  0 44 48 A0  1 
1A35B18 	DC 41 A0  1 C0  0  0  0 
      " device-id" get-int-property  <>  if          ( adr )
1A35B20 	9C 53 A0  1  9 64 65 76 
1A35B28 	69 63 65 2D 69 64  0  0 
1A35B30 	14 59 A3  1 44 48 A0  1 
1A35B38 	DC 41 A0  1 98  0  0  0 
         probemsg?  if                               ( adr )
1A35B40 	20 3B A3  1 DC 41 A0  1 
1A35B48 	80  0  0  0 
            ??cr ."   Function:" " device-id" get-int-property 4 u.r
1A35B4C 	 0 A1 A0  1 
1A35B50 	20 7C A0  1  B 20 20 46 
1A35B58 	75 6E 63 74 69 6F 6E 3A 
1A35B60 	 0  0  0  0 9C 53 A0  1 
1A35B68 	 9 64 65 76 69 63 65 2D 
1A35B70 	69 64  0  0 14 59 A3  1 
1A35B78 	B0 6F A0  1 E4 77 A0  1 
            ."   /ROM Image:" le-w@ 4 u.r  ."  Device IDs do not match... " cr
1A35B80 	20 7C A0  1  D 20 20 2F 
1A35B88 	52 4F 4D 20 49 6D 61 67 
1A35B90 	65 3A  0  0 80 4C A0  1 
1A35B98 	B0 6F A0  1 E4 77 A0  1 
1A35BA0 	20 7C A0  1 1C 20 44 65 
1A35BA8 	76 69 63 65 20 49 44 73 
1A35BB0 	20 64 6F 20 6E 6F 74 20 
1A35BB8 	6D 61 74 63 68 2E 2E 2E 
1A35BC0 	20  0  0  0 80 6D A0  1 
         then                                        ( adr )
	 drop false exit                             ( false )
1A35BC8 	30 49 A0  1 18 70 A0  1 
1A35BD0 	40 46 A0  1 
      then                                           ( adr )
   else                                              ( adr id )
1A35BD4 	C8 41 A0  1 
1A35BD8 	 8  0  0  0 
      drop                                           ( adr )
1A35BDC 	30 49 A0  1 
   then                                              ( adr )

   h# 14 + c@  1 =                                   ( flag )
1A35BE0 	58 41 A0  1 14  0  0  0 
1A35BE8 	 4 45 A0  1 C4 4C A0  1 
1A35BF0 	80 6F A0  1 24 48 A0  1 
;
1A35BF8 	58 46 A0  1 

0 value rom-base
1A35BFC 	 0  0  0 72 
1A35C00 	6F 6D 2D 62 61 73 65 88 
1A35C08 	58 59 A3  1 50 40 A0  1 
1A35C10 	CC  A  0  0 
: locate-fcode  ( rom-image-adr -- false | adr len true )
1A35C14 	 0  0  0 6C 
1A35C18 	6F 63 61 74 65 2D 66 63 
1A35C20 	6F 64 65 8C  C 5C A3  1 
1A35C28 	20 40 A0  1 
   dup to rom-base
1A35C2C 	40 49 A0  1 
1A35C30 	B8 40 A0  1  C 5C A3  1 
   begin
      dup  le-w@  h# aa55 <>  if
1A35C38 	40 49 A0  1 80 4C A0  1 
1A35C40 	58 41 A0  1 55 AA  0  0 
1A35C48 	44 48 A0  1 DC 41 A0  1 
1A35C50 	54  0  0  0 
         probemsg?  if
1A35C54 	20 3B A3  1 
1A35C58 	DC 41 A0  1 3C  0  0  0 
            ??cr ."   Invalid ROM Header Format: " dup le-w@ . cr
1A35C60 	 0 A1 A0  1 20 7C A0  1 
1A35C68 	1D 20 20 49 6E 76 61 6C 
1A35C70 	69 64 20 52 4F 4D 20 48 
1A35C78 	65 61 64 65 72 20 46 6F 
1A35C80 	72 6D 61 74 3A 20  0  0 
1A35C88 	40 49 A0  1 80 4C A0  1 
1A35C90 	94 7A A0  1 80 6D A0  1 
         then
         drop false exit
1A35C98 	30 49 A0  1 18 70 A0  1 
1A35CA0 	40 46 A0  1 
      then                          ( rom-image-adr )

      dup  h# 18 +  le-w@  over +   ( rom-image-adr PCI-struct-adr )
1A35CA4 	40 49 A0  1 
1A35CA8 	58 41 A0  1 18  0  0  0 
1A35CB0 	 4 45 A0  1 80 4C A0  1 
1A35CB8 	54 49 A0  1  4 45 A0  1 
      dup fcode-image?  if          ( rom-image-adr PCI-struct-adr )
1A35CC0 	40 49 A0  1 58 59 A3  1 
1A35CC8 	DC 41 A0  1 BC  0  0  0 
         probemsg?  if  ??cr ."   FCode ROM Image Found... " cr  then
1A35CD0 	20 3B A3  1 DC 41 A0  1 
1A35CD8 	30  0  0  0  0 A1 A0  1 
1A35CE0 	20 7C A0  1 1B 20 20 46 
1A35CE8 	43 6F 64 65 20 52 4F 4D 
1A35CF0 	20 49 6D 61 67 65 20 46 
1A35CF8 	6F 75 6E 64 2E 2E 2E 20 
1A35D00 	 0  0  0  0 80 6D A0  1 
         drop dup rom-base -        ( rom-image-adr offset )
1A35D08 	30 49 A0  1 40 49 A0  1 
1A35D10 	 C 5C A3  1 18 45 A0  1 
         encode-int  " fcode-rom-offset" property
1A35D18 	40 F7 A1  1 9C 53 A0  1 
1A35D20 	10 66 63 6F 64 65 2D 72 
1A35D28 	6F 6D 2D 6F 66 66 73 65 
1A35D30 	74  0  0  0 BC 14 A2  1 
         dup h# 02 + le-w@ +        ( FCode-image-adr )
1A35D38 	40 49 A0  1 58 41 A0  1 
1A35D40 	 2  0  0  0  4 45 A0  1 
1A35D48 	80 4C A0  1  4 45 A0  1 
	 dup >r  4 + be-l@          ( FCode-len )
1A35D50 	40 49 A0  1 BC 45 A0  1 
1A35D58 	B0 6F A0  1  4 45 A0  1 
1A35D60 	30 FC A0  1 
	 dup alloc-mem              ( FCode-len adr )
1A35D64 	40 49 A0  1 
1A35D68 	F0 6C A0  1 
         swap 2dup r> -rot cmove    ( adr len )
1A35D6C 	68 49 A0  1 
1A35D70 	C0 49 A0  1 D0 45 A0  1 
1A35D78 	94 49 A0  1 10 44 A0  1 
         true exit
1A35D80 	 4 70 A0  1 40 46 A0  1 
      then
      probemsg?  if  ??cr ."   Non FCode Format ROM Image. " cr  then
1A35D88 	20 3B A3  1 DC 41 A0  1 
1A35D90 	30  0  0  0  0 A1 A0  1 
1A35D98 	20 7C A0  1 1E 20 20 4E 
1A35DA0 	6F 6E 20 46 43 6F 64 65 
1A35DA8 	20 46 6F 72 6D 61 74 20 
1A35DB0 	52 4F 4D 20 49 6D 61 67 
1A35DB8 	65 2E 20  0 80 6D A0  1 
      dup h# 15 + c@  h# 80 and 0=  ( rom-image-adr PCI-struct-adr )
1A35DC0 	40 49 A0  1 58 41 A0  1 
1A35DC8 	15  0  0  0  4 45 A0  1 
1A35DD0 	C4 4C A0  1 58 41 A0  1 
1A35DD8 	80  0  0  0 5C 44 A0  1 
1A35DE0 	24 47 A0  1 
   while    \ More images           ( rom-image-adr PCI-struct-adr )
1A35DE4 	DC 41 A0  1 
1A35DE8 	2C  0  0  0 
      h# 10 +  le-w@  9 <<  +       ( rom-image-adr' )
1A35DEC 	58 41 A0  1 
1A35DF0 	10  0  0  0  4 45 A0  1 
1A35DF8 	80 4C A0  1 58 41 A0  1 
1A35E00 	 9  0  0  0 C8 44 A0  1 
1A35E08 	 4 45 A0  1 
   repeat                           ( rom-image-adr' )
1A35E0C 	C8 41 A0  1 
1A35E10 	28 FE FF FF 
   2drop false
1A35E14 	AC 49 A0  1 
1A35E18 	18 70 A0  1 
;
1A35E1C 	58 46 A0  1 

\ READ orig base reg value.  write -1 and get new value. reset to orig value.
: probe-own-base-reg  ( offset -- value )
1A35E20 	 0 70 72 6F 62 65 2D 6F 
1A35E28 	77 6E 2D 62 61 73 65 2D 
1A35E30 	72 65 67 92 28 5C A3  1 
1A35E38 	20 40 A0  1 
   dup my-l@  over                   ( offset old-value offset )
1A35E3C 	40 49 A0  1 
1A35E40 	28 4E A3  1 54 49 A0  1 
   h# ffffffff over my-l!  my-l@    ( offset old-value new-value )
1A35E48 	58 41 A0  1 FF FF FF FF 
1A35E50 	54 49 A0  1 58 4E A3  1 
1A35E58 	28 4E A3  1 
   -rot swap my-l!                   ( new-value )
1A35E5C 	94 49 A0  1 
1A35E60 	68 49 A0  1 58 4E A3  1 
   l->n
1A35E68 	88 61 A0  1 
;
1A35E6C 	58 46 A0  1 

: own-64mem?  ( phys.hi -- flag )  my-l@  7 and 4 =  ;
1A35E70 	 0 6F 77 6E 2D 36 34 6D 
1A35E78 	65 6D 3F 8A 38 5E A3  1 
1A35E80 	20 40 A0  1 28 4E A3  1 
1A35E88 	E0 6F A0  1 5C 44 A0  1 
1A35E90 	B0 6F A0  1 24 48 A0  1 
1A35E98 	58 46 A0  1 
: own-io?  ( phys.hi -- flag )
1A35E9C 	6F 77 6E 2D 
1A35EA0 	69 6F 3F 87 80 5E A3  1 
1A35EA8 	20 40 A0  1 
   \ For expansion ROM base address registers, the LSB is an enable bit,
   \ not an I/O space indicator.  Expansion ROM base address registers
   \ are at 30 or 38; the register number portion of our phys.hi argument
   \ will always be in the range 10-24 (inclusive), 30, or 38.
   dup h# 30 and  h# 30 =  if  drop false  else  my-l@  1 and  0<>  then
1A35EAC 	40 49 A0  1 
1A35EB0 	58 41 A0  1 30  0  0  0 
1A35EB8 	5C 44 A0  1 58 41 A0  1 
1A35EC0 	30  0  0  0 24 48 A0  1 
1A35EC8 	DC 41 A0  1 14  0  0  0 
1A35ED0 	30 49 A0  1 18 70 A0  1 
1A35ED8 	C8 41 A0  1 14  0  0  0 
1A35EE0 	28 4E A3  1 80 6F A0  1 
1A35EE8 	5C 44 A0  1 44 47 A0  1 
;
1A35EF0 	58 46 A0  1 
: mask-own-low-bits  ( phys.hi regval -- regval' )
1A35EF4 	 0  0 6D 61 
1A35EF8 	73 6B 2D 6F 77 6E 2D 6C 
1A35F00 	6F 77 2D 62 69 74 73 91 
1A35F08 	A8 5E A3  1 20 40 A0  1 
   swap own-io?  if  3  else  7  then  invert and   ( regval' )
1A35F10 	68 49 A0  1 A8 5E A3  1 
1A35F18 	DC 41 A0  1 10  0  0  0 
1A35F20 	A0 6F A0  1 C8 41 A0  1 
1A35F28 	 8  0  0  0 E0 6F A0  1 
1A35F30 	30 45 A0  1 5C 44 A0  1 
;
1A35F38 	58 46 A0  1 
: own-size-mask  ( offset -- high-mask )
1A35F3C 	 0  0 6F 77 
1A35F40 	6E 2D 73 69 7A 65 2D 6D 
1A35F48 	61 73 6B 8D  C 5F A3  1 
1A35F50 	20 40 A0  1 
   dup probe-own-base-reg        ( offset regval )
1A35F54 	40 49 A0  1 
1A35F58 	38 5E A3  1 
   mask-own-low-bits             ( regval' )
1A35F5C 	 C 5F A3  1 
   fix-io16
1A35F60 	F8 3F A3  1 
;
1A35F64 	58 46 A0  1 
: find-own-size  ( offset -- size )
1A35F68 	 0  0 66 69 6E 64 2D 6F 
1A35F70 	77 6E 2D 73 69 7A 65 8D 
1A35F78 	50 5F A3  1 20 40 A0  1 
   dup own-size-mask invert  swap own-64mem?  0=  if  n->l  then  1+
1A35F80 	40 49 A0  1 50 5F A3  1 
1A35F88 	30 45 A0  1 68 49 A0  1 
1A35F90 	80 5E A3  1 24 47 A0  1 
1A35F98 	DC 41 A0  1  8  0  0  0 
1A35FA0 	74 4F A0  1 30 4B A0  1 
;
1A35FA8 	58 46 A0  1 

: expansion-rom  ( -- offset )
1A35FAC 	 0  0 65 78 
1A35FB0 	70 61 6E 73 69 6F 6E 2D 
1A35FB8 	72 6F 6D 8D 7C 5F A3  1 
1A35FC0 	20 40 A0  1 
   bridge?  if  h# 38  else  h# 30   then
1A35FC4 	24 4F A3  1 
1A35FC8 	DC 41 A0  1 14  0  0  0 
1A35FD0 	58 41 A0  1 38  0  0  0 
1A35FD8 	C8 41 A0  1  C  0  0  0 
1A35FE0 	58 41 A0  1 30  0  0  0 
;
1A35FE8 	58 46 A0  1 

: base-register-bounds  ( -- high low )
1A35FEC 	 0  0  0 62 
1A35FF0 	61 73 65 2D 72 65 67 69 
1A35FF8 	73 74 65 72 2D 62 6F 75 
1A36000 	6E 64 73 94 C0 5F A3  1 
1A36008 	20 40 A0  1 
   bridge?  if  h# 18  else  card-bus?	if  h# 14  else  h# 28  then  then
1A3600C 	24 4F A3  1 
1A36010 	DC 41 A0  1 14  0  0  0 
1A36018 	58 41 A0  1 18  0  0  0 
1A36020 	C8 41 A0  1 28  0  0  0 
1A36028 	5C 4F A3  1 DC 41 A0  1 
1A36030 	14  0  0  0 58 41 A0  1 
1A36038 	14  0  0  0 C8 41 A0  1 
1A36040 	 C  0  0  0 58 41 A0  1 
1A36048 	28  0  0  0 
   h# 10
1A3604C 	58 41 A0  1 
1A36050 	10  0  0  0 
;
1A36054 	58 46 A0  1 

\ Temporarily assign addresses for all the base address registers so they
\ don't conflict with the expansion ROM address register.  Some boards do
\ not disable the response of relocatable memory regions when the expansion
\ ROM is turned on.

: temp-assign-addresses  ( -- )
1A36058 	 0  0 74 65 6D 70 2D 61 
1A36060 	73 73 69 67 6E 2D 61 64 
1A36068 	64 72 65 73 73 65 73 95 
1A36070 	 8 60 A3  1 20 40 A0  1 
   base-register-bounds  do
1A36078 	 8 60 A3  1 88 42 A0  1 
1A36080 	CC  0  0  0 
      i probe-own-base-reg                               ( regval )
1A36084 	B4 42 A0  1 
1A36088 	38 5E A3  1 

      dup 7 and 4 =  if      \ Skip mem64 regions        ( regval )
1A3608C 	40 49 A0  1 
1A36090 	E0 6F A0  1 5C 44 A0  1 
1A36098 	B0 6F A0  1 24 48 A0  1 
1A360A0 	DC 41 A0  1 14  0  0  0 
         drop 8                                          ( increment )
1A360A8 	30 49 A0  1 F0 6F A0  1 
      else                                               ( regval )
1A360B0 	C8 41 A0  1 90  0  0  0 
         dup 1 and  over 0= or  if  \ Skip IO regions    ( regval )
1A360B8 	40 49 A0  1 80 6F A0  1 
1A360C0 	5C 44 A0  1 54 49 A0  1 
1A360C8 	24 47 A0  1 70 44 A0  1 
1A360D0 	DC 41 A0  1 14  0  0  0 
            drop 4                                       ( increment )
1A360D8 	30 49 A0  1 B0 6F A0  1 
         else  			                         ( regval )
1A360E0 	C8 41 A0  1 60  0  0  0 
            7 invert and  invert                         ( low-mask )
1A360E8 	E0 6F A0  1 30 45 A0  1 
1A360F0 	5C 44 A0  1 30 45 A0  1 
            i own-64mem?  0=  if  n->l  then             ( low-mask )
1A360F8 	B4 42 A0  1 80 5E A3  1 
1A36100 	24 47 A0  1 DC 41 A0  1 
1A36108 	 8  0  0  0 74 4F A0  1 
            pci-pagemask or                              ( low-mask )
1A36110 	38 3E A3  1 70 44 A0  1 
            next-mem over mask-up                        ( low-mask base )
1A36118 	D8 3D A3  1 54 49 A0  1 
1A36120 	88 40 A3  1 
            tuck swap 1+ + set-next-mem                  ( base )
1A36124 	E8 46 A0  1 
1A36128 	68 49 A0  1 30 4B A0  1 
1A36130 	 4 45 A0  1 14 3E A3  1 
            i my-l!                                      ( )
1A36138 	B4 42 A0  1 58 4E A3  1 
            4                                            ( increment )
1A36140 	B0 6F A0  1 
         then                                            ( increment )
      then                                               ( increment )
   +loop                                                 ( )
1A36144 	1C 42 A0  1 
1A36148 	3C FF FF FF 
;
1A3614C 	58 46 A0  1 

\ If the function at configuration space address "phys.hi.func" has an
\ FCode program in its expansion ROM, evaluate that program and return
\ true, otherwise return false.

0 value save-mem
1A36150 	 0  0  0 73 61 76 65 2D 
1A36158 	6D 65 6D 88 74 60 A3  1 
1A36160 	50 40 A0  1 D0  A  0  0 
headers		\ find-fcode? doesn't have to be headered; it's just convenient
: find-fcode?  ( -- false | adr len true )
1A36168 	66 69 6E 64 2D 66 63 6F 
1A36170 	64 65 3F 8B 60 61 A3  1 
1A36178 	20 40 A0  1 

   next-mem to save-mem
1A3617C 	D8 3D A3  1 
1A36180 	B8 40 A0  1 60 61 A3  1 
   parent-assign-addresses?  if  temp-assign-addresses  then
1A36188 	70 3D A3  1 DC 41 A0  1 
1A36190 	 8  0  0  0 74 60 A3  1 
   expansion-rom                                             ( offset )
1A36198 	C0 5F A3  1 

\   \ Map the expansion ROM at a high physical address that does not
\   \ conflict with the base addresses that were zeroed above.
\   mem-space-top 10.0000 - 1 or  over my-l!                  ( offset )

   \ Some PCI cards (e.g. a SciTex bridge device) implement a writeable
   \ enable bit for the expansion ROM base address register, but no other
   \ writeable bits, so comparing to zero doesn't work.
   dup probe-own-base-reg 2 u<  if  drop false  exit  then    ( offset )
1A3619C 	40 49 A0  1 
1A361A0 	38 5E A3  1 90 6F A0  1 
1A361A8 	A8 48 A0  1 DC 41 A0  1 
1A361B0 	10  0  0  0 30 49 A0  1 
1A361B8 	18 70 A0  1 40 46 A0  1 

\ Let map-in perform the address assignment, as we are in probe-state

   0 0 2 pick  dup find-own-size    ( offset p.rom.lo,med offset size )
1A361C0 	70 6F A0  1 70 6F A0  1 
1A361C8 	90 6F A0  1  C 4A A0  1 
1A361D0 	40 49 A0  1 7C 5F A3  1 

   \ The following line is a bug workaround for a Sun device named
   \  "Multi-Grain", whose expansion ROM decoder responds to a 16 Mbyte region.
   dup h# 40000 >  if  drop h# 40000  then	\ Limit ROM size to 256K
1A361D8 	40 49 A0  1 58 41 A0  1 
1A361E0 	 0  0  4  0  4 48 A0  1 
1A361E8 	DC 41 A0  1 10  0  0  0 
1A361F0 	30 49 A0  1 58 41 A0  1 
1A361F8 	 0  0  4  0 

   >r  h# 2000000 or my-space +  r@ " map-in" $call-parent  ( offset virt )
1A361FC 	BC 45 A0  1 
1A36200 	58 41 A0  1  0  0  0  2 
1A36208 	70 44 A0  1 AC  3 A2  1 
1A36210 	 4 45 A0  1 E4 45 A0  1 
1A36218 	9C 53 A0  1  6 6D 61 70 
1A36220 	2D 69 6E  0 DC 31 A2  1 
   tuck >r >r                       ( r: size virt offset )  ( virt )
1A36228 	E8 46 A0  1 BC 45 A0  1 
1A36230 	BC 45 A0  1 

   \ Turn on address decode enable in Expansion ROM Base Address Register
   r@ my-l@  1 or  r@ my-l!         ( r: size virt offset )  ( virt )
1A36234 	E4 45 A0  1 
1A36238 	28 4E A3  1 80 6F A0  1 
1A36240 	70 44 A0  1 E4 45 A0  1 
1A36248 	58 4E A3  1 

   4 my-w@  2 or  4 my-w!	\ Turn on memory enable      ( virt )
1A3624C 	B0 6F A0  1 
1A36250 	C8 4D A3  1 90 6F A0  1 
1A36258 	70 44 A0  1 B0 6F A0  1 
1A36260 	F8 4D A3  1 

   locate-fcode                ( r: size virt offset ) ( false | adr len true )
1A36264 	28 5C A3  1 

   \ Turn off memory enable
   parent-assign-addresses?  if      ( r: size virt offset ) ( false | adr len true )
1A36268 	70 3D A3  1 DC 41 A0  1 
1A36270 	20  0  0  0 
      4 my-w@  2 invert and   4 my-w!
1A36274 	B0 6F A0  1 
1A36278 	C8 4D A3  1 90 6F A0  1 
1A36280 	30 45 A0  1 5C 44 A0  1 
1A36288 	B0 6F A0  1 F8 4D A3  1 
   then                       ( r: size virt offset ) ( false | adr len true )

   \ Turn off address decode enable in Expansion ROM Base Address Register
   r@ my-l@  1 invert and  r> my-l!  ( r: size virt ) ( false | adr len true )
1A36290 	E4 45 A0  1 28 4E A3  1 
1A36298 	80 6F A0  1 30 45 A0  1 
1A362A0 	5C 44 A0  1 D0 45 A0  1 
1A362A8 	58 4E A3  1 
   save-mem set-next-mem
1A362AC 	60 61 A3  1 
1A362B0 	14 3E A3  1 

   r> r>  " map-out" $call-parent                     ( false | adr len true )
1A362B4 	D0 45 A0  1 
1A362B8 	D0 45 A0  1 9C 53 A0  1 
1A362C0 	 7 6D 61 70 2D 6F 75 74 
1A362C8 	 0  0  0  0 DC 31 A2  1 
;
1A362D0 	58 46 A0  1 

\ Set all base address registers to the highest possible address,
\ thus (hopefully) avoiding contention with explicitly-assigned addresses.
: clear-addresses  ( -- )
1A362D4 	63 6C 65 61 
1A362D8 	72 2D 61 64 64 72 65 73 
1A362E0 	73 65 73 8F 78 61 A3  1 
1A362E8 	20 40 A0  1 
   base-register-bounds  do  -1 i my-l!  /l +loop
1A362EC 	 8 60 A3  1 
1A362F0 	88 42 A0  1 20  0  0  0 
1A362F8 	58 41 A0  1 FF FF FF FF 
1A36300 	B4 42 A0  1 58 4E A3  1 
1A36308 	30 51 A0  1 1C 42 A0  1 
1A36310 	E8 FF FF FF 
;
1A36314 	58 46 A0  1 

\ Add the property encoding of the address range "phys.lo..hi size.lo..hi"
\ to the property-encoded array "adr,len"

: +reg-entry  ( adr len phys.lo..hi size.lo..hi -- adr' len' )
1A36318 	 0 2B 72 65 67 2D 65 6E 
1A36320 	74 72 79 8A E8 62 A3  1 
1A36328 	20 40 A0  1 
   swap >r >r  swap rot >r >r     ( adr len p.hi ) ( r: s.lo,hi p.lo,mid )
1A3632C 	68 49 A0  1 
1A36330 	BC 45 A0  1 BC 45 A0  1 
1A36338 	68 49 A0  1 7C 49 A0  1 
1A36340 	BC 45 A0  1 BC 45 A0  1 
   +i r> +i r> +i r> +i r> +i
1A36348 	 4 47 A3  1 D0 45 A0  1 
1A36350 	 4 47 A3  1 D0 45 A0  1 
1A36358 	 4 47 A3  1 D0 45 A0  1 
1A36360 	 4 47 A3  1 D0 45 A0  1 
1A36368 	 4 47 A3  1 
;
1A3636C 	58 46 A0  1 

: get-prefetch-mask  ( reg-val -- mask )  8 and h# 1b lshift  ;
1A36370 	 0  0 67 65 74 2D 70 72 
1A36378 	65 66 65 74 63 68 2D 6D 
1A36380 	61 73 6B 91 28 63 A3  1 
1A36388 	20 40 A0  1 F0 6F A0  1 
1A36390 	5C 44 A0  1 58 41 A0  1 
1A36398 	1B  0  0  0 9C 44 A0  1 
1A363A0 	58 46 A0  1 

: t-bit-mask  ( reg-val -- mask )  2 and h# 1c lshift  ;
1A363A4 	 0 74 2D 62 
1A363A8 	69 74 2D 6D 61 73 6B 8A 
1A363B0 	88 63 A3  1 20 40 A0  1 
1A363B8 	90 6F A0  1 5C 44 A0  1 
1A363C0 	58 41 A0  1 1C  0  0  0 
1A363C8 	9C 44 A0  1 58 46 A0  1 

\ Determine "phys.lo..hi", the numeric representation of the base address
\ register at configuration space address "base-reg-adr", and "increment",
\ the offset to the next base address register (8 for 64-bit memory space,
\ 4 otherwise).  If the base address register isn't implemented, return false.

\ In the code below, "mask" is a bitmask containing ones in the high bits
\ that can be programmed to set the device's address, and zeros in the
\ low bits that cannot be programmed.  The phrase "invert 1+" converts such
\ a mask into the size of the region.

: decode-base-reg  ( base-reg-offset -- ... )
1A363D0 	64 65 63 6F 64 65 2D 62 
1A363D8 	61 73 65 2D 72 65 67 8F 
1A363E0 	B4 63 A3  1 20 40 A0  1 
   ( false increment | phys.lo..hi size true increment )

   dup probe-own-base-reg  h# f invert and  0=  if
1A363E8 	40 49 A0  1 38 5E A3  1 
1A363F0 	58 41 A0  1  F  0  0  0 
1A363F8 	30 45 A0  1 5C 44 A0  1 
1A36400 	24 47 A0  1 DC 41 A0  1 
1A36408 	14  0  0  0 
      \ No valid address set, but the space decode, i/o or prefetchable
      \ bits are ignored.
      drop false 4 exit
1A3640C 	30 49 A0  1 
1A36410 	18 70 A0  1 B0 6F A0  1 
1A36418 	40 46 A0  1 
   then						  ( base )

   \ XXX TODO what about non-relocatable devices?  How do we detect them?

   0 0 rot   dup own-size-mask swap               ( 0 0 mask base )
1A3641C 	70 6F A0  1 
1A36420 	70 6F A0  1 7C 49 A0  1 
1A36428 	40 49 A0  1 50 5F A3  1 
1A36430 	68 49 A0  1 

   dup my-l@  dup >r 7 and  4 =  if               ( 0 0 mask base )
1A36434 	40 49 A0  1 
1A36438 	28 4E A3  1 40 49 A0  1 
1A36440 	BC 45 A0  1 E0 6F A0  1 
1A36448 	5C 44 A0  1 B0 6F A0  1 
1A36450 	24 48 A0  1 DC 41 A0  1 
1A36458 	64  0  0  0 
      \ 64-bit memory space - look at the next base register too
      dup 4 +  probe-own-base-reg                 ( 0 0 mask base hi-mask )
1A3645C 	40 49 A0  1 
1A36460 	B0 6F A0  1  4 45 A0  1 
1A36468 	38 5E A3  1 
      swap h# 3000000 or r> get-prefetch-mask or ( 0 0 mask hi-mask' )
1A3646C 	68 49 A0  1 
1A36470 	58 41 A0  1  0  0  0  3 
1A36478 	70 44 A0  1 D0 45 A0  1 
1A36480 	88 63 A3  1 70 44 A0  1 
      my-space +  -rot                            ( 0 0 phys mask hi-mask )
1A36488 	AC  3 A2  1  4 45 A0  1 
1A36490 	94 49 A0  1 
      swap invert swap invert  1 0 d+  8          ( 0 0 phys size.lo..hi inc )
1A36494 	68 49 A0  1 
1A36498 	30 45 A0  1 68 49 A0  1 
1A364A0 	30 45 A0  1 80 6F A0  1 
1A364A8 	70 6F A0  1 E0 5D A0  1 
1A364B0 	F0 6F A0  1 
   else				                  ( 0 0 mask base )
1A364B4 	C8 41 A0  1 
1A364B8 	74  0  0  0 
      \ 32-bit ..
      \ Memory space or I/O space
      \ XXX what about "below 1 Meg" memory?
      r> dup 1 and  if                           ( 0 0 mask base reg )
1A364BC 	D0 45 A0  1 
1A364C0 	40 49 A0  1 80 6F A0  1 
1A364C8 	5C 44 A0  1 DC 41 A0  1 
1A364D0 	18  0  0  0 
         drop h# 1000000                        ( 0 0 mask base hi-mask )
1A364D4 	30 49 A0  1 
1A364D8 	58 41 A0  1  0  0  0  1 
      else                                       ( 0 0 mask base reg )
1A364E0 	C8 41 A0  1 28  0  0  0 
         dup get-prefetch-mask >r                ( 0 0 mask base reg )
1A364E8 	40 49 A0  1 88 63 A3  1 
1A364F0 	BC 45 A0  1 
         t-bit-mask r> or h# 2000000 or         ( 0 0 mask base hi-mask )
1A364F4 	B4 63 A3  1 
1A364F8 	D0 45 A0  1 70 44 A0  1 
1A36500 	58 41 A0  1  0  0  0  2 
1A36508 	70 44 A0  1 
      then                                       ( 0 0 mask base type' )
      or  my-space +  swap invert 1+  0  4       ( 0 0 base' size.lo..hi inc )
1A3650C 	70 44 A0  1 
1A36510 	AC  3 A2  1  4 45 A0  1 
1A36518 	68 49 A0  1 30 45 A0  1 
1A36520 	30 4B A0  1 70 6F A0  1 
1A36528 	B0 6F A0  1 
   then
   true  swap
1A3652C 	 4 70 A0  1 
1A36530 	68 49 A0  1 
;
1A36534 	58 46 A0  1 

\ If the base address register at "offset" is implemented, add its
\ description to the property-encoded array "adr,len", returning
\ "inc" = 8 if the base address register is for 64-bit memory space,
\ "inc" = 4 otherwise.

: add-reg-entry  ( adr len offset -- adr' len' inc )
1A36538 	 0  0 61 64 64 2D 72 65 
1A36540 	67 2D 65 6E 74 72 79 8D 
1A36548 	E4 63 A3  1 20 40 A0  1 
   decode-base-reg  >r  if  +reg-entry  then  r>
1A36550 	E4 63 A3  1 BC 45 A0  1 
1A36558 	DC 41 A0  1  8  0  0  0 
1A36560 	28 63 A3  1 D0 45 A0  1 
;
1A36568 	58 46 A0  1 

\ Create a "reg" property describing the base address registers

: make-reg-property  ( -- )
1A3656C 	 0  0 6D 61 
1A36570 	6B 65 2D 72 65 67 2D 70 
1A36578 	72 6F 70 65 72 74 79 91 
1A36580 	4C 65 A3  1 20 40 A0  1 
   my-space encode-int  0+i  0+i  0+i  0+i   ( adr len )
1A36588 	AC  3 A2  1 40 F7 A1  1 
1A36590 	1C 47 A3  1 1C 47 A3  1 
1A36598 	1C 47 A3  1 1C 47 A3  1 
   cr ." base-register-bounds " here .h
1A365A0 	80 6D A0  1 20 7C A0  1 
1A365A8 	15 62 61 73 65 2D 72 65 
1A365B0 	67 69 73 74 65 72 2D 62 
1A365B8 	6F 75 6E 64 73 20  0  0 
1A365C0 	70 54 A0  1 10  E A1  1 
   base-register-bounds 2dup . . do  i add-reg-entry  ( inc ) +loop  ( adr len )
1A365C8 	 8 60 A3  1 C0 49 A0  1 
1A365D0 	94 7A A0  1 94 7A A0  1 
1A365D8 	88 42 A0  1 14  0  0  0 
1A365E0 	B4 42 A0  1 4C 65 A3  1 
1A365E8 	1C 42 A0  1 F4 FF FF FF 
   " reg" property
1A365F0 	9C 53 A0  1  3 72 65 67 
1A365F8 	 0  0  0  0 BC 14 A2  1 
  cr ." make-reg-property "  here .h
1A36600 	80 6D A0  1 20 7C A0  1 
1A36608 	12 6D 61 6B 65 2D 72 65 
1A36610 	67 2D 70 72 6F 70 65 72 
1A36618 	74 79 20  0 70 54 A0  1 
1A36620 	10  E A1  1 
;
1A36624 	58 46 A0  1 

: set-power-property  ( prsnt-bits -- )
1A36628 	 0 73 65 74 2D 70 6F 77 
1A36630 	65 72 2D 70 72 6F 70 65 
1A36638 	72 74 79 92 84 65 A3  1 
1A36640 	20 40 A0  1 
   \ XXX I hope we decide to switch the order of "standby" and "full-on"
   \ so we can omit the "standby" entry here.
   0 encode-int
1A36644 	70 6F A0  1 
1A36648 	40 F7 A1  1 
   rot case
1A3664C 	7C 49 A0  1 
     0 of  d#  7.500.000  endof	\ 7.5W  (the property value is in microwatts)
1A36650 	70 6F A0  1 48 43 A0  1 
1A36658 	14  0  0  0 58 41 A0  1 
1A36660 	E0 70 72  0 6C 43 A0  1 
1A36668 	4C  0  0  0 
     1 of  d# 15.000.000  endof	\ 15W
1A3666C 	80 6F A0  1 
1A36670 	48 43 A0  1 14  0  0  0 
1A36678 	58 41 A0  1 C0 E1 E4  0 
1A36680 	6C 43 A0  1 30  0  0  0 
     2 of  d# 25.000.000  endof	\ 25W
1A36688 	90 6F A0  1 48 43 A0  1 
1A36690 	14  0  0  0 58 41 A0  1 
1A36698 	40 78 7D  1 6C 43 A0  1 
1A366A0 	14  0  0  0 
     \ We know there is something in the slot because we only
     \ execute this word after finding something, but in case
     \ the PRSNT bits lie (or the hardware doesn't give them to us,
     \ we assume the worst case
     ( default )  d# 25.000.000 swap
1A366A4 	58 41 A0  1 
1A366A8 	40 78 7D  1 68 49 A0  1 
   endcase
1A366B0 	84 43 A0  1 
   +i  " power-consumption" property
1A366B4 	 4 47 A3  1 
1A366B8 	9C 53 A0  1 11 70 6F 77 
1A366C0 	65 72 2D 63 6F 6E 73 75 
1A366C8 	6D 70 74 69 6F 6E  0  0 
1A366D0 	BC 14 A2  1 
;
1A366D4 	58 46 A0  1 

\ Read the power sense pins in a system-dependent manner
: make-power-property  ( -- )
1A366D8 	6D 61 6B 65 2D 70 6F 77 
1A366E0 	65 72 2D 70 72 6F 70 65 
1A366E8 	72 74 79 93 40 66 A3  1 
1A366F0 	20 40 A0  1 
   \ Don't create the property for non-zero function numbers
   my-space 8 rshift 7 and  if  exit  then
1A366F4 	AC  3 A2  1 
1A366F8 	F0 6F A0  1 B4 44 A0  1 
1A36700 	E0 6F A0  1 5C 44 A0  1 
1A36708 	DC 41 A0  1  8  0  0  0 
1A36710 	40 46 A0  1 

   my-space prsnt@  if  set-power-property  then
1A36714 	AC  3 A2  1 
1A36718 	98 3A A3  1 DC 41 A0  1 
1A36720 	 8  0  0  0 40 66 A3  1 
;
1A36728 	58 46 A0  1 

: usbalias
1A3672C 	 0  0  0 75 
1A36730 	73 62 61 6C 69 61 73 88 
1A36738 	F0 66 A3  1 20 40 A0  1 
	s" alias dma-alloc dma-alloc" eval
1A36740 	9C 53 A0  1 19 61 6C 69 
1A36748 	61 73 20 64 6D 61 2D 61 
1A36750 	6C 6C 6F 63 20 64 6D 61 
1A36758 	2D 61 6C 6C 6F 63  0  0 
1A36760 	D8 E5 A0  1 
	s" alias dma-free dma-free" eval
1A36764 	9C 53 A0  1 
1A36768 	17 61 6C 69 61 73 20 64 
1A36770 	6D 61 2D 66 72 65 65 20 
1A36778 	64 6D 61 2D 66 72 65 65 
1A36780 	 0  0  0  0 D8 E5 A0  1 


	s" alias decode-unit decode-unit-m" eval
1A36788 	9C 53 A0  1 1F 61 6C 69 
1A36790 	61 73 20 64 65 63 6F 64 
1A36798 	65 2D 75 6E 69 74 20 64 
1A367A0 	65 63 6F 64 65 2D 75 6E 
1A367A8 	69 74 2D 6D  0  0  0  0 
1A367B0 	D8 E5 A0  1 
	s" alias encode-unit encode-unit-m" eval
1A367B4 	9C 53 A0  1 
1A367B8 	1F 61 6C 69 61 73 20 65 
1A367C0 	6E 63 6F 64 65 2D 75 6E 
1A367C8 	69 74 20 65 6E 63 6F 64 
1A367D0 	65 2D 75 6E 69 74 2D 6D 
1A367D8 	 0  0  0  0 D8 E5 A0  1 

	s" defer unstall-pipe ' drop to unstall-pipe" eval
1A367E0 	9C 53 A0  1 29 64 65 66 
1A367E8 	65 72 20 75 6E 73 74 61 
1A367F0 	6C 6C 2D 70 69 70 65 20 
1A367F8 	27 20 64 72 6F 70 20 74 
1A36800 	6F 20 75 6E 73 74 61 6C 
1A36808 	6C 2D 70 69 70 65  0  0 
1A36810 	D8 E5 A0  1 

	s" 0 instance value target" eval
1A36814 	9C 53 A0  1 
1A36818 	17 30 20 69 6E 73 74 61 
1A36820 	6E 63 65 20 76 61 6C 75 
1A36828 	65 20 74 61 72 67 65 74 
1A36830 	 0  0  0  0 D8 E5 A0  1 
	s" false instance value noprobe?" eval
1A36838 	9C 53 A0  1 1D 66 61 6C 
1A36840 	73 65 20 69 6E 73 74 61 
1A36848 	6E 63 65 20 76 61 6C 75 
1A36850 	65 20 6E 6F 70 72 6F 62 
1A36858 	65 3F  0  0 D8 E5 A0  1 


	s" : set-target  ( target -- )  to target  ;" eval
1A36860 	9C 53 A0  1 29 3A 20 73 
1A36868 	65 74 2D 74 61 72 67 65 
1A36870 	74 20 20 28 20 74 61 72 
1A36878 	67 65 74 20 2D 2D 20 29 
1A36880 	20 20 74 6F 20 74 61 72 
1A36888 	67 65 74 20 20 3B  0  0 
1A36890 	D8 E5 A0  1 

\ A usb device node defines an address space of the form
\ "port,interface".  port and interface are both integers.
\ parse-2int converts a text string (e.g. "3,1") into a pair of
\ binary integers.

	s" false instance value fisheye?" eval
1A36894 	9C 53 A0  1 
1A36898 	1D 66 61 6C 73 65 20 69 
1A368A0 	6E 73 74 61 6E 63 65 20 
1A368A8 	76 61 6C 75 65 20 66 69 
1A368B0 	73 68 65 79 65 3F  0  0 
1A368B8 	D8 E5 A0  1 
	s" : parse-my-args ;" eval
1A368BC 	9C 53 A0  1 
1A368C0 	11 3A 20 70 61 72 73 65 
1A368C8 	2D 6D 79 2D 61 72 67 73 
1A368D0 	20 3B  0  0 D8 E5 A0  1 


         " usb"             device-name
1A368D8 	9C 53 A0  1  3 75 73 62 
1A368E0 	 0  0  0  0 20 49 A2  1 
 2       " #address-cells"  int-property
1A368E8 	90 6F A0  1 9C 53 A0  1 
1A368F0 	 E 23 61 64 64 72 65 73 
1A368F8 	73 2D 63 65 6C 6C 73  0 
1A36900 	90 4E A3  1 
 0       " #size-cells"     int-property
1A36904 	70 6F A0  1 
1A36908 	9C 53 A0  1  B 23 73 69 
1A36910 	7A 65 2D 63 65 6C 6C 73 
1A36918 	 0  0  0  0 90 4E A3  1 

;
1A36920 	58 46 A0  1 

: usbaliaso
1A36924 	 0  0 75 73 
1A36928 	62 61 6C 69 61 73 6F 89 
1A36930 	3C 67 A3  1 20 40 A0  1 
" ohci" encode-string " device_type" property
1A36938 	9C 53 A0  1  4 6F 68 63 
1A36940 	69  0  0  0 A0 F6 A1  1 
1A36948 	9C 53 A0  1  B 64 65 76 
1A36950 	69 63 65 5F 74 79 70 65 
1A36958 	 0  0  0  0 BC 14 A2  1 
\ Configuration space registers
my-address my-space encode-phys
1A36960 	20 10 A2  1 AC  3 A2  1 
1A36968 	E0 47 A2  1 
0 encode-int encode+  0 encode-int encode+
1A3696C 	70 6F A0  1 
1A36970 	40 F7 A1  1 F0 F5 A1  1 
1A36978 	70 6F A0  1 40 F7 A1  1 
1A36980 	F0 F5 A1  1 
\ OHCI operational registers
0 0    my-space  02000010 + encode-phys encode+
1A36984 	70 6F A0  1 
1A36988 	70 6F A0  1 AC  3 A2  1 
1A36990 	58 41 A0  1 10  0  0  2 
1A36998 	 4 45 A0  1 E0 47 A2  1 
1A369A0 	F0 F5 A1  1 
0 encode-int encode+  h# 1000 encode-int encode+
1A369A4 	70 6F A0  1 
1A369A8 	40 F7 A1  1 F0 F5 A1  1 
1A369B0 	58 41 A0  1  0 10  0  0 
1A369B8 	40 F7 A1  1 F0 F5 A1  1 
" reg" property
1A369C0 	9C 53 A0  1  3 72 65 67 
1A369C8 	 0  0  0  0 BC 14 A2  1 


s" : set-normal-dev target dup to my-dev to my-real-dev ;" eval
1A369D0 	9C 53 A0  1 36 3A 20 73 
1A369D8 	65 74 2D 6E 6F 72 6D 61 
1A369E0 	6C 2D 64 65 76 20 74 61 
1A369E8 	72 67 65 74 20 64 75 70 
1A369F0 	20 74 6F 20 6D 79 2D 64 
1A369F8 	65 76 20 74 6F 20 6D 79 
1A36A00 	2D 72 65 61 6C 2D 64 65 
1A36A08 	76 20 3B  0 D8 E5 A0  1 
s" ' set-normal-dev to set-my-dev" eval
1A36A10 	9C 53 A0  1 1E 27 20 73 
1A36A18 	65 74 2D 6E 6F 72 6D 61 
1A36A20 	6C 2D 64 65 76 20 74 6F 
1A36A28 	20 73 65 74 2D 6D 79 2D 
1A36A30 	64 65 76  0 D8 E5 A0  1 


;
1A36A38 	58 46 A0  1 

: usbaliasu
1A36A3C 	 0  0 75 73 
1A36A40 	62 61 6C 69 61 73 75 89 
1A36A48 	34 69 A3  1 20 40 A0  1 

" uhci" encode-string " device_type" property
1A36A50 	9C 53 A0  1  4 75 68 63 
1A36A58 	69  0  0  0 A0 F6 A1  1 
1A36A60 	9C 53 A0  1  B 64 65 76 
1A36A68 	69 63 65 5F 74 79 70 65 
1A36A70 	 0  0  0  0 BC 14 A2  1 

\ Configuration space registers
my-address my-space          encode-phys
1A36A78 	20 10 A2  1 AC  3 A2  1 
1A36A80 	E0 47 A2  1 
                           0 encode-int  encode+  0     encode-int encode+
1A36A84 	70 6F A0  1 
1A36A88 	40 F7 A1  1 F0 F5 A1  1 
1A36A90 	70 6F A0  1 40 F7 A1  1 
1A36A98 	F0 F5 A1  1 
\ UHCI operational registers
0 0    my-space  01000020 + encode-phys encode+
1A36A9C 	70 6F A0  1 
1A36AA0 	70 6F A0  1 AC  3 A2  1 
1A36AA8 	58 41 A0  1 20  0  0  1 
1A36AB0 	 4 45 A0  1 E0 47 A2  1 
1A36AB8 	F0 F5 A1  1 
                           0 encode-int  encode+  h# 400 encode-int encode+
1A36ABC 	70 6F A0  1 
1A36AC0 	40 F7 A1  1 F0 F5 A1  1 
1A36AC8 	58 41 A0  1  0  4  0  0 
1A36AD0 	40 F7 A1  1 F0 F5 A1  1 

" reg" property
1A36AD8 	9C 53 A0  1  3 72 65 67 
1A36AE0 	 0  0  0  0 BC 14 A2  1 


s" : set-normal-dev  target dup to my-dev to my-real-dev ;" eval
1A36AE8 	9C 53 A0  1 37 3A 20 73 
1A36AF0 	65 74 2D 6E 6F 72 6D 61 
1A36AF8 	6C 2D 64 65 76 20 20 74 
1A36B00 	61 72 67 65 74 20 64 75 
1A36B08 	70 20 74 6F 20 6D 79 2D 
1A36B10 	64 65 76 20 74 6F 20 6D 
1A36B18 	79 2D 72 65 61 6C 2D 64 
1A36B20 	65 76 20 3B  0  0  0  0 
1A36B28 	D8 E5 A0  1 
s" ' set-normal-dev to set-my-dev" eval
1A36B2C 	9C 53 A0  1 
1A36B30 	1E 27 20 73 65 74 2D 6E 
1A36B38 	6F 72 6D 61 6C 2D 64 65 
1A36B40 	76 20 74 6F 20 73 65 74 
1A36B48 	2D 6D 79 2D 64 65 76  0 
1A36B50 	D8 E5 A0  1 


;
1A36B54 	58 46 A0  1 


\ After a function has been located and a device node has been created
\ for it, fill in the device node with properties and methods.
headers
vocabulary builtin-drivers
1A36B58 	62 75 69 6C 74 69 6E 2D 
1A36B60 	64 72 69 76 65 72 73 8F 
1A36B68 	4C 6A A3  1 E0 B6 A0  1 
1A36B70 	D4  A  0  0 64 39 A3  1 
1A36B78 	 0  0  0  0 
headerless
: no-builtin-fcode?  ( -- flag )
1A36B7C 	 0  0 6E 6F 
1A36B80 	2D 62 75 69 6C 74 69 6E 
1A36B88 	2D 66 63 6F 64 65 3F 91 
1A36B90 	6C 6B A3  1 20 40 A0  1 
\	debug-me
   probemsg?  if  
1A36B98 	20 3B A3  1 DC 41 A0  1 
1A36BA0 	B8  0  0  0 
      ??cr ."   Checking for built-in FCode match for "
1A36BA4 	 0 A1 A0  1 
1A36BA8 	20 7C A0  1 28 20 20 43 
1A36BB0 	68 65 63 6B 69 6E 67 20 
1A36BB8 	66 6F 72 20 62 75 69 6C 
1A36BC0 	74 2D 69 6E 20 46 43 6F 
1A36BC8 	64 65 20 6D 61 74 63 68 
1A36BD0 	20 66 6F 72 20  0  0  0 
      ??cr
1A36BD8 	 0 A1 A0  1 
      ."   Vendor:" " vendor-id" get-int-property 4 u.r
1A36BDC 	20 7C A0  1 
1A36BE0 	 9 20 20 56 65 6E 64 6F 
1A36BE8 	72 3A  0  0 9C 53 A0  1 
1A36BF0 	 9 76 65 6E 64 6F 72 2D 
1A36BF8 	69 64  0  0 14 59 A3  1 
1A36C00 	B0 6F A0  1 E4 77 A0  1 
      ."   Device:" " device-id" get-int-property 4 u.r
1A36C08 	20 7C A0  1  9 20 20 44 
1A36C10 	65 76 69 63 65 3A  0  0 
1A36C18 	9C 53 A0  1  9 64 65 76 
1A36C20 	69 63 65 2D 69 64  0  0 
1A36C28 	14 59 A3  1 B0 6F A0  1 
1A36C30 	E4 77 A0  1 
      ."   class-code:"  class-code u. HERE .H
1A36C34 	20 7C A0  1 
1A36C38 	 D 20 20 63 6C 61 73 73 
1A36C40 	2D 63 6F 64 65 3A  0  0 
1A36C48 	98 4F A3  1 C8 77 A0  1 
1A36C50 	70 54 A0  1 10  E A1  1 
   then
      ??cr pwd cr
1A36C58 	 0 A1 A0  1 D0 2B A2  1 
1A36C60 	80 6D A0  1 
  class-code h# 0c0300 = if
1A36C64 	98 4F A3  1 
1A36C68 	58 41 A0  1  0  3  C  0 
1A36C70 	24 48 A0  1 DC 41 A0  1 
1A36C78 	44  0  0  0 
	usb_lib_u also current @ context !
1A36C7C 	44 39 A3  1 
1A36C80 	C8 C1 A0  1 F0 A3 A0  1 
1A36C88 	5C 4C A0  1 DC A3 A0  1 
1A36C90 	54 4D A0  1 
        usbalias
1A36C94 	3C 67 A3  1 
        usbaliasu
1A36C98 	4C 6A A3  1 
\    s" d:include\dev\usbm\hcd\uhci\uhci.bth" included
        usbaevalu
1A36C9C 	9C 39 A3  1 
        previous  current @ context !
1A36CA0 	E4 C3 A0  1 F0 A3 A0  1 
1A36CA8 	5C 4C A0  1 DC A3 A0  1 
1A36CB0 	54 4D A0  1 
  false exit
1A36CB4 	18 70 A0  1 
1A36CB8 	40 46 A0  1 
   then

  class-code h# 0c0310 = if
1A36CBC 	98 4F A3  1 
1A36CC0 	58 41 A0  1 10  3  C  0 
1A36CC8 	24 48 A0  1 DC 41 A0  1 
1A36CD0 	74  0  0  0 
	usb_lib_o also current @ context !
1A36CD4 	 4 39 A3  1 
1A36CD8 	C8 C1 A0  1 F0 A3 A0  1 
1A36CE0 	5C 4C A0  1 DC A3 A0  1 
1A36CE8 	54 4D A0  1 
	usbalias
1A36CEC 	3C 67 A3  1 
	usbaliaso
1A36CF0 	34 69 A3  1 

    s" d:include\dev\usbm\hcd\ohci\ohci.bth" included
1A36CF4 	9C 53 A0  1 
1A36CF8 	24 64 3A 69 6E 63 6C 75 
1A36D00 	64 65 5C 64 65 76 5C 75 
1A36D08 	73 62 6D 5C 68 63 64 5C 
1A36D10 	6F 68 63 69 5C 6F 68 63 
1A36D18 	69 2E 62 74 68  0  0  0 
1A36D20 	C8 E8 A0  1 
        usbaevalo
1A36D24 	CC 39 A3  1 
\	cr ." usb_lib_o=" order key drop
        previous  current @ context !
1A36D28 	E4 C3 A0  1 F0 A3 A0  1 
1A36D30 	5C 4C A0  1 DC A3 A0  1 
1A36D38 	54 4D A0  1 
  false exit
1A36D3C 	18 70 A0  1 
1A36D40 	40 46 A0  1 
   then

  class-code h# 0c0320 = if
1A36D44 	98 4F A3  1 
1A36D48 	58 41 A0  1 20  3  C  0 
1A36D50 	24 48 A0  1 DC 41 A0  1 
1A36D58 	44  0  0  0 
	usb_lib_e also current @ context !
1A36D5C 	24 39 A3  1 
1A36D60 	C8 C1 A0  1 F0 A3 A0  1 
1A36D68 	5C 4C A0  1 DC A3 A0  1 
1A36D70 	54 4D A0  1 

	usbalias
1A36D74 	3C 67 A3  1 
        usbaliase
1A36D78 	84 39 A3  1 
\    s" d:include\dev\usbm\hcd\ehci\ehci.bth" included
        usbaevale
1A36D7C 	B4 39 A3  1 
\	cr ." usb_lib_e=" order key drop
        previous  current @ context !
1A36D80 	E4 C3 A0  1 F0 A3 A0  1 
1A36D88 	5C 4C A0  1 DC A3 A0  1 
1A36D90 	54 4D A0  1 
  false exit
1A36D94 	18 70 A0  1 
1A36D98 	40 46 A0  1 
   then

   true
1A36D9C 	 4 70 A0  1 
;
1A36DA0 	58 46 A0  1 

: make-common-properties ( -- )
1A36DA4 	 0 6D 61 6B 
1A36DA8 	65 2D 63 6F 6D 6D 6F 6E 
1A36DB0 	2D 70 72 6F 70 65 72 74 
1A36DB8 	69 65 73 96 94 6B A3  1 
1A36DC0 	20 40 A0  1 
   make-name-property
1A36DC4 	28 57 A3  1 
 cr ." make-compatible-property " here .h
1A36DC8 	80 6D A0  1 20 7C A0  1 
1A36DD0 	19 6D 61 6B 65 2D 63 6F 
1A36DD8 	6D 70 61 74 69 62 6C 65 
1A36DE0 	2D 70 72 6F 70 65 72 74 
1A36DE8 	79 20  0  0 70 54 A0  1 
1A36DF0 	10  E A1  1 
   make-compatible-property
1A36DF4 	14 58 A3  1 
 cr ." make-reg-property " here .h
1A36DF8 	80 6D A0  1 20 7C A0  1 
1A36E00 	12 6D 61 6B 65 2D 72 65 
1A36E08 	67 2D 70 72 6F 70 65 72 
1A36E10 	74 79 20  0 70 54 A0  1 
1A36E18 	10  E A1  1 
   make-reg-property
1A36E1C 	84 65 A3  1 
 cr ." make-power-property " here .h
1A36E20 	80 6D A0  1 20 7C A0  1 
1A36E28 	14 6D 61 6B 65 2D 70 6F 
1A36E30 	77 65 72 2D 70 72 6F 70 
1A36E38 	65 72 74 79 20  0  0  0 
1A36E40 	70 54 A0  1 10  E A1  1 
   make-power-property
1A36E48 	F0 66 A3  1 
;
1A36E4C 	58 46 A0  1 
: populate-device-node  ( -- )
1A36E50 	 0  0  0 70 6F 70 75 6C 
1A36E58 	61 74 65 2D 64 65 76 69 
1A36E60 	63 65 2D 6E 6F 64 65 94 
1A36E68 	C0 6D A3  1 20 40 A0  1 
 cr ." populate-device-node " here .h
1A36E70 	80 6D A0  1 20 7C A0  1 
1A36E78 	15 70 6F 70 75 6C 61 74 
1A36E80 	65 2D 64 65 76 69 63 65 
1A36E88 	2D 6E 6F 64 65 20  0  0 
1A36E90 	70 54 A0  1 10  E A1  1 
\ cr ."  exit" exit
   setup-fcodes              ( )		
1A36E98 	D8 3A A3  1 
 cr ." populate-device-node1 " here .h
1A36E9C 	80 6D A0  1 
1A36EA0 	20 7C A0  1 16 70 6F 70 
1A36EA8 	75 6C 61 74 65 2D 64 65 
1A36EB0 	76 69 63 65 2D 6E 6F 64 
1A36EB8 	65 31 20  0 70 54 A0  1 
1A36EC0 	10  E A1  1 
   make-child-properties     ( )
1A36EC4 	CC 4F A3  1 
 cr ." populate-device-node5 " here .h
1A36EC8 	80 6D A0  1 20 7C A0  1 
1A36ED0 	16 70 6F 70 75 6C 61 74 
1A36ED8 	65 2D 64 65 76 69 63 65 
1A36EE0 	2D 6E 6F 64 65 35 20  0 
1A36EE8 	70 54 A0  1 10  E A1  1 
   card-bus? dup .  if  make-common-properties  exit  then  ( )
1A36EF0 	5C 4F A3  1 40 49 A0  1 
1A36EF8 	94 7A A0  1 DC 41 A0  1 
1A36F00 	 C  0  0  0 C0 6D A3  1 
1A36F08 	40 46 A0  1 
 cr ." populate-device-node11 " here .h
1A36F0C 	80 6D A0  1 
1A36F10 	20 7C A0  1 17 70 6F 70 
1A36F18 	75 6C 61 74 65 2D 64 65 
1A36F20 	76 69 63 65 2D 6E 6F 64 
1A36F28 	65 31 31 20  0  0  0  0 
1A36F30 	70 54 A0  1 10  E A1  1 
   parent-assign-addresses? dup .  if  clear-addresses  then        ( )
1A36F38 	70 3D A3  1 40 49 A0  1 
1A36F40 	94 7A A0  1 DC 41 A0  1 
1A36F48 	 8  0  0  0 E8 62 A3  1 

 cr ." populate-device-node22 " here .h
1A36F50 	80 6D A0  1 20 7C A0  1 
1A36F58 	17 70 6F 70 75 6C 61 74 
1A36F60 	65 2D 64 65 76 69 63 65 
1A36F68 	2D 6E 6F 64 65 32 32 20 
1A36F70 	 0  0  0  0 70 54 A0  1 
1A36F78 	10  E A1  1 

   \ Interpret FCode if present; if not, invent "name" and "reg" properties
      no-builtin-fcode?   if  make-common-properties  then
1A36F7C 	94 6B A3  1 
1A36F80 	DC 41 A0  1  8  0  0  0 
1A36F88 	C0 6D A3  1 

 cr ." populate-device-node33 " here .h
1A36F8C 	80 6D A0  1 
1A36F90 	20 7C A0  1 17 70 6F 70 
1A36F98 	75 6C 61 74 65 2D 64 65 
1A36FA0 	76 69 63 65 2D 6E 6F 64 
1A36FA8 	65 33 33 20  0  0  0  0 
1A36FB0 	70 54 A0  1 10  E A1  1 

   bridge? 0= dup .  if
1A36FB8 	24 4F A3  1 24 47 A0  1 
1A36FC0 	40 49 A0  1 94 7A A0  1 
1A36FC8 	DC 41 A0  1 3C  0  0  0 
      parent-assign-addresses?  if
1A36FD0 	70 3D A3  1 DC 41 A0  1 
1A36FD8 	30  0  0  0 
	 clear-addresses          ( )
1A36FDC 	E8 62 A3  1 
	 b my-b@ 6 <>  if
1A36FE0 	58 41 A0  1  B  0  0  0 
1A36FE8 	68 4D A3  1 D0 6F A0  1 
1A36FF0 	44 48 A0  1 DC 41 A0  1 
1A36FF8 	10  0  0  0 
	    0 4 my-w!		\ Disables all card response
1A36FFC 	70 6F A0  1 
1A37000 	B0 6F A0  1 F8 4D A3  1 
	 then
      then
   then
 cr ." populate-device-node44 " here .h
1A37008 	80 6D A0  1 20 7C A0  1 
1A37010 	17 70 6F 70 75 6C 61 74 
1A37018 	65 2D 64 65 76 69 63 65 
1A37020 	2D 6E 6F 64 65 34 34 20 
1A37028 	 0  0  0  0 70 54 A0  1 
1A37030 	10  E A1  1 
   restore-fcodes
1A37034 	F4 3A A3  1 
 cr ." populate-device-node55 " here .h
1A37038 	80 6D A0  1 20 7C A0  1 
1A37040 	17 70 6F 70 75 6C 61 74 
1A37048 	65 2D 64 65 76 69 63 65 
1A37050 	2D 6E 6F 64 65 35 35 20 
1A37058 	 0  0  0  0 70 54 A0  1 
1A37060 	10  E A1  1 
;
1A37064 	58 46 A0  1 
\ Searches the direct children of the PCI node for an existing
\ whose unit address matches reg$ .  The name property is ignored,
\ because during probing, there's no target name for which to search.
: find-existing  ( reg$ -- reg$ )
1A37068 	 0  0 66 69 6E 64 2D 65 
1A37070 	78 69 73 74 69 6E 67 8D 
1A37078 	6C 6E A3  1 20 40 A0  1 
   2dup decode-unit  unit# 3 /n* bounds  ?do  i !  /n +loop  ( reg$ )
1A37080 	C0 49 A0  1 C4 41 A3  1 
1A37088 	1C 18 A2  1 A0 6F A0  1 
1A37090 	98 51 A0  1 F0 6D A0  1 
1A37098 	50 42 A0  1 18  0  0  0 
1A370A0 	B4 42 A0  1 54 4D A0  1 
1A370A8 	40 51 A0  1 1C 42 A0  1 
1A370B0 	F0 FF FF FF 
   ['] unit-match?  search-level  drop                       ( reg$ )
1A370B4 	60 53 A0  1 
1A370B8 	18 19 A2  1 E0 17 A2  1 
1A370C0 	30 49 A0  1 
;
1A370C4 	58 46 A0  1 

\ Create a new node or activate an existing one
: make-function-node  ( arg$ reg$ -- )
1A370C8 	 0 6D 61 6B 65 2D 66 75 
1A370D0 	6E 63 74 69 6F 6E 2D 6E 
1A370D8 	6F 64 65 92 7C 70 A3  1 
1A370E0 	20 40 A0  1 
 CR ." make-function-node=" .s here .h
1A370E4 	80 6D A0  1 
1A370E8 	20 7C A0  1 13 6D 61 6B 
1A370F0 	65 2D 66 75 6E 63 74 69 
1A370F8 	6F 6E 2D 6E 6F 64 65 3D 
1A37100 	 0  0  0  0 38 7C A0  1 
1A37108 	70 54 A0  1 10  E A1  1 
   ['] find-existing catch  if  ( arg$ reg$ )   \ Make new node
1A37110 	60 53 A0  1 7C 70 A3  1 
1A37118 	14 7F A0  1 DC 41 A0  1 
1A37120 	18  0  0  0 
      new-device  set-args      ( )
1A37124 	74  F A2  1 
1A37128 	 4 33 A2  1 
\ CR ." make-function-node11=" .s here .h
      populate-device-node      ( )
1A3712C 	6C 6E A3  1 
   else                         ( arg$ reg$ )	\ Active the existing node
1A37130 	C8 41 A0  1 60  0  0  0 
      extend-package set-args   ( )
1A37138 	C0  9 A2  1  4 33 A2  1 
      make-child-properties     ( )
1A37140 	CC 4F A3  1 
 CR ." make-function-node15=" .s here .h
1A37144 	80 6D A0  1 
1A37148 	20 7C A0  1 15 6D 61 6B 
1A37150 	65 2D 66 75 6E 63 74 69 
1A37158 	6F 6E 2D 6E 6F 64 65 31 
1A37160 	35 3D  0  0 38 7C A0  1 
1A37168 	70 54 A0  1 10  E A1  1 
      " init" my-self		( adr len ihandle )
1A37170 	9C 53 A0  1  4 69 6E 69 
1A37178 	74  0  0  0 EC 7E A0  1 
      ihandle>phandle		( adr len phandle )
1A37180 	 0 32 A2  1 
      find-method  if		( xt )
1A37184 	A0 2F A2  1 
1A37188 	DC 41 A0  1  8  0  0  0 
         execute		( )
1A37190 	98 41 A0  1 
      then			( )
   then pwd
1A37194 	D0 2B A2  1 
 CR ." make-function-node22=" .s here .h
1A37198 	80 6D A0  1 20 7C A0  1 
1A371A0 	15 6D 61 6B 65 2D 66 75 
1A371A8 	6E 63 74 69 6F 6E 2D 6E 
1A371B0 	6F 64 65 32 32 3D  0  0 
1A371B8 	38 7C A0  1 70 54 A0  1 
1A371C0 	10  E A1  1 
   finish-device                ( )
1A371C4 	74 11 A2  1 
 CR ." make-function-node33=" .s here .h
1A371C8 	80 6D A0  1 20 7C A0  1 
1A371D0 	15 6D 61 6B 65 2D 66 75 
1A371D8 	6E 63 74 69 6F 6E 2D 6E 
1A371E0 	6F 64 65 33 33 3D  0  0 
1A371E8 	38 7C A0  1 70 54 A0  1 
1A371F0 	10  E A1  1 
;
1A371F4 	58 46 A0  1 

: amend-reg$  ( reg$ func# -- reg$' )
1A371F8 	 0 61 6D 65 6E 64 2D 72 
1A37200 	65 67 24 8A E0 70 A3  1 
1A37208 	20 40 A0  1 
   push-hex
1A3720C 	5C F4 A0  1 
   >r  ascii , left-parse-string         ( rem$ head$ )
1A37210 	BC 45 A0  1 58 41 A0  1 
1A37218 	2C  0  0  0 44 D7 A0  1 
   2swap 2drop $number  if  0  then  r>  ( dev# func# )
1A37220 	F4 49 A0  1 AC 49 A0  1 
1A37228 	40 FE A0  1 DC 41 A0  1 
1A37230 	 8  0  0  0 70 6F A0  1 
1A37238 	D0 45 A0  1 
   <# u# drop  ascii , hold  u#s u#> string4 $save
1A3723C 	 8 76 A0  1 
1A37240 	94 76 A0  1 30 49 A0  1 
1A37248 	58 41 A0  1 2C  0  0  0 
1A37250 	DC 75 A0  1 BC 76 A0  1 
1A37258 	E0 76 A0  1 F0 3B A3  1 
1A37260 	68 7E A0  1 
   pop-base
1A37264 	9C F4 A0  1 
;
1A37268 	58 46 A0  1 

\ Returns true if the card implements a function at the indicated
\ configuration address.

\ We defer this because some systems require more careful checking, perhaps
\ using "wpeek" (which in turn may require a mapping operation).
defer function-present?  ( phys.hi.func -- flag )
1A3726C 	 0  0 66 75 
1A37270 	6E 63 74 69 6F 6E 2D 70 
1A37278 	72 65 73 65 6E 74 3F 91 
1A37280 	 8 72 A3  1 5C 40 A0  1 
1A37288 	D8  A  0  0 
: (function-present?)  ( phys.hi.func -- flag )
1A3728C 	28 66 75 6E 
1A37290 	63 74 69 6F 6E 2D 70 72 
1A37298 	65 73 65 6E 74 3F 29 93 
1A372A0 	84 72 A3  1 20 40 A0  1 
   " config-w@" $call-self  h# ffff <>
1A372A8 	9C 53 A0  1  9 63 6F 6E 
1A372B0 	66 69 67 2D 77 40  0  0 
1A372B8 	B4 30 A2  1 58 41 A0  1 
1A372C0 	FF FF  0  0 44 48 A0  1 
;
1A372C8 	58 46 A0  1 
' (function-present?) to function-present?

\ Create a string of the form  "D,F" where D is the device number portion
\ of the string "reg$" and F is the hexadecimal representation of "func#"
\ Probe the card function func#
: probe-function  ( args$ reg$ phys.hi.dev func# -- args$ reg$ phys.hi.dev )
1A372CC 	 0 70 72 6F 
1A372D0 	62 65 2D 66 75 6E 63 74 
1A372D8 	69 6F 6E 8E A4 72 A3  1 
1A372E0 	20 40 A0  1 

   2dup  8 lshift +  function-present?  if  ( args$ reg$ phys.hi.dev func# )
1A372E4 	C0 49 A0  1 
1A372E8 	F0 6F A0  1 9C 44 A0  1 
1A372F0 	 4 45 A0  1 84 72 A3  1 
1A372F8 	DC 41 A0  1 20  0  0  0 

      \ Now we know that the function is present, so we can go ahead and
      \ create a device node for it

      2>r  2over 2over                      ( args$ reg$ args$ reg$ r: p f# )
1A37300 	F8 45 A0  1 D8 49 A0  1 
1A37308 	D8 49 A0  1 
      r@ amend-reg$  make-function-node     ( args$ reg$ r: p f# )
1A3730C 	E4 45 A0  1 
1A37310 	 8 72 A3  1 E0 70 A3  1 
      2r>                                   ( args$ reg$ phys.hi.dev func# )
1A37318 	10 46 A0  1 
   then                                     ( args$ reg$ phys.hi.dev func# )
   drop                                     ( args$ reg$ phys.hi.dev )
1A3731C 	30 49 A0  1 
;
1A37320 	58 46 A0  1 

\ Returns 0 if the card isn't present, 8 for a multifunction card, 1 otherwise
: max#functions  ( phys.hi -- phys.hi n )
1A37324 	 0  0 6D 61 
1A37328 	78 23 66 75 6E 63 74 69 
1A37330 	6F 6E 73 8D E0 72 A3  1 
1A37338 	20 40 A0  1 
   dup function-present?  if               ( phys.hi )
1A3733C 	40 49 A0  1 
1A37340 	84 72 A3  1 DC 41 A0  1 
1A37348 	54  0  0  0 
      dup h# e +  " config-b@" $call-self  ( phys.hi field )
1A3734C 	40 49 A0  1 
1A37350 	58 41 A0  1  E  0  0  0 
1A37358 	 4 45 A0  1 9C 53 A0  1 
1A37360 	 9 63 6F 6E 66 69 67 2D 
1A37368 	62 40  0  0 B4 30 A2  1 
      h# 80  and  if  8  else  1  then     ( phys.hi n )
1A37370 	58 41 A0  1 80  0  0  0 
1A37378 	5C 44 A0  1 DC 41 A0  1 
1A37380 	10  0  0  0 F0 6F A0  1 
1A37388 	C8 41 A0  1  8  0  0  0 
1A37390 	80 6F A0  1 
   else                                    ( phys.hi )
1A37394 	C8 41 A0  1 
1A37398 	 8  0  0  0 
      0                                    ( phys.hi n )
1A3739C 	70 6F A0  1 
   then
;
1A373A0 	58 46 A0  1 

0 value aa-adr
1A373A4 	 0 61 61 2D 
1A373A8 	61 64 72 86 38 73 A3  1 
1A373B0 	50 40 A0  1 DC  A  0  0 
0 value aa-len
1A373B8 	 0 61 61 2D 6C 65 6E 86 
1A373C0 	B0 73 A3  1 50 40 A0  1 
1A373C8 	E0  A  0  0 
: init-aa-property  ( -- )  0 0 encode-bytes  to aa-len  to aa-adr  ;
1A373CC 	 0  0  0 69 
1A373D0 	6E 69 74 2D 61 61 2D 70 
1A373D8 	72 6F 70 65 72 74 79 90 
1A373E0 	C4 73 A3  1 20 40 A0  1 
1A373E8 	70 6F A0  1 70 6F A0  1 
1A373F0 	14 F6 A1  1 B8 40 A0  1 
1A373F8 	C4 73 A3  1 B8 40 A0  1 
1A37400 	B0 73 A3  1 58 46 A0  1 
: finish-aa-property  ( phandle -- )
1A37408 	 0 66 69 6E 69 73 68 2D 
1A37410 	61 61 2D 70 72 6F 70 65 
1A37418 	72 74 79 92 E4 73 A3  1 
1A37420 	20 40 A0  1 
   aa-len  if
1A37424 	C4 73 A3  1 
1A37428 	DC 41 A0  1 38  0  0  0 
      >r  aa-adr aa-len  " assigned-addresses"  r> set-package-property
1A37430 	BC 45 A0  1 B0 73 A3  1 
1A37438 	C4 73 A3  1 9C 53 A0  1 
1A37440 	12 61 73 73 69 67 6E 65 
1A37448 	64 2D 61 64 64 72 65 73 
1A37450 	73 65 73  0 D0 45 A0  1 
1A37458 	C8 33 A2  1 
   else
1A3745C 	C8 41 A0  1 
1A37460 	 8  0  0  0 
      drop
1A37464 	30 49 A0  1 
   then
;
1A37468 	58 46 A0  1 
\ "encode-phys" cannot be used to implement this, because it executes in
\ the instance context of the bus node, whereas encode-phys expects to
\ execute in the child instance context.
: +assigned-address  ( phys.hi paddr len -- )
1A3746C 	 0  0 2B 61 
1A37470 	73 73 69 67 6E 65 64 2D 
1A37478 	61 64 64 72 65 73 73 91 
1A37480 	20 74 A3  1 20 40 A0  1 
   >r                                ( phys.hi paddr )  ( r: len )
1A37488 	BC 45 A0  1 
   swap h# 80000000 or              ( paddr phys.hi' )
1A3748C 	68 49 A0  1 
1A37490 	58 41 A0  1  0  0  0 80 
1A37498 	70 44 A0  1 
   aa-adr aa-len rot +i              ( paddr adr' len' )
1A3749C 	B0 73 A3  1 
1A374A0 	C4 73 A3  1 7C 49 A0  1 
1A374A8 	 4 47 A3  1 
   0+i  rot +i                       ( adr len )
1A374AC 	1C 47 A3  1 
1A374B0 	7C 49 A0  1  4 47 A3  1 
   0+i  r> +i  to aa-len  to aa-adr  ( )
1A374B8 	1C 47 A3  1 D0 45 A0  1 
1A374C0 	 4 47 A3  1 B8 40 A0  1 
1A374C8 	C4 73 A3  1 B8 40 A0  1 
1A374D0 	B0 73 A3  1 
;
1A374D4 	58 46 A0  1 

d# 16 buffer: already-assigned
1A374D8 	 0  0  0 61 6C 72 65 61 
1A374E0 	64 79 2D 61 73 73 69 67 
1A374E8 	6E 65 64 90 84 74 A3  1 
1A374F0 	B4 A9 A0  1 E4  A  0  0 
1A374F8 	10  0  0  0 F0 3B A3  1 
: >assigned  ( phys.hi -- adr )
1A37500 	 0  0 3E 61 73 73 69 67 
1A37508 	6E 65 64 89 F0 74 A3  1 
1A37510 	20 40 A0  1 
   h# 3c and  2 >>  already-assigned +
1A37514 	58 41 A0  1 
1A37518 	3C  0  0  0 5C 44 A0  1 
1A37520 	90 6F A0  1 DC 44 A0  1 
1A37528 	F0 74 A3  1  4 45 A0  1 
;
1A37530 	58 46 A0  1 

: (assign-address)  ( phys.lo,mid,hi size.lo,hi -- )
1A37534 	 0  0  0 28 
1A37538 	61 73 73 69 67 6E 2D 61 
1A37540 	64 64 72 65 73 73 29 90 
1A37548 	10 75 A3  1 20 40 A0  1 
   \ Don't assign addresses for reg entries that refer to a base address
   \ register that has already been assigned by an earlier entry.
   2 pick  >assigned c@  if
1A37550 	90 6F A0  1  C 4A A0  1 
1A37558 	10 75 A3  1 C4 4C A0  1 
1A37560 	DC 41 A0  1  C  0  0  0 
      5drop  exit
1A37568 	4C 53 A0  1 40 46 A0  1 
   then                           ( phys.lo,mid,hi size.lo,hi )

   if                             ( phys.lo,mid,hi size.lo )
1A37570 	DC 41 A0  1 48  0  0  0 
      ." Can't assign address ranges larger than 32-bits" cr
1A37578 	20 7C A0  1 2F 43 61 6E 
1A37580 	27 74 20 61 73 73 69 67 
1A37588 	6E 20 61 64 64 72 65 73 
1A37590 	73 20 72 61 6E 67 65 73 
1A37598 	20 6C 61 72 67 65 72 20 
1A375A0 	74 68 61 6E 20 33 32 2D 
1A375A8 	62 69 74 73  0  0  0  0 
1A375B0 	80 6D A0  1 
      4drop   exit
1A375B4 	38 53 A0  1 
1A375B8 	40 46 A0  1 
   then                           ( phys.lo,mid,hi size.lo )

   over io?  if                   ( phys.lo,mid,hi size.lo )
1A375BC 	54 49 A0  1 
1A375C0 	 C 3F A3  1 DC 41 A0  1 
1A375C8 	A8  0  0  0 
      dup h# 4000 u>=  if         ( phys.lo,mid,hi size.lo )
1A375CC 	40 49 A0  1 
1A375D0 	58 41 A0  1  0 40  0  0 
1A375D8 	CC 48 A0  1 DC 41 A0  1 
1A375E0 	90  0  0  0 
         ." Can't assign more than 16K of I/O space" cr
1A375E4 	20 7C A0  1 
1A375E8 	27 43 61 6E 27 74 20 61 
1A375F0 	73 73 69 67 6E 20 6D 6F 
1A375F8 	72 65 20 74 68 61 6E 20 
1A37600 	31 36 4B 20 6F 66 20 49 
1A37608 	2F 4F 20 73 70 61 63 65 
1A37610 	 0  0  0  0 80 6D A0  1 
         ." Probably a non-writable BAR at PCI config address " drop h# ff.ffff and u. cr
1A37618 	20 7C A0  1 32 50 72 6F 
1A37620 	62 61 62 6C 79 20 61 20 
1A37628 	6E 6F 6E 2D 77 72 69 74 
1A37630 	61 62 6C 65 20 42 41 52 
1A37638 	20 61 74 20 50 43 49 20 
1A37640 	63 6F 6E 66 69 67 20 61 
1A37648 	64 64 72 65 73 73 20  0 
1A37650 	30 49 A0  1 58 41 A0  1 
1A37658 	FF FF FF  0 5C 44 A0  1 
1A37660 	C8 77 A0  1 80 6D A0  1 
         2drop exit
1A37668 	AC 49 A0  1 40 46 A0  1 
      then
   then

   \ Mark as already assigned
   1  2 pick  >assigned dup 1+ >r c!  ( phys.lo,mid,hi size.lo ) ( r: adr)
1A37670 	80 6F A0  1 90 6F A0  1 
1A37678 	 C 4A A0  1 10 75 A3  1 
1A37680 	40 49 A0  1 30 4B A0  1 
1A37688 	BC 45 A0  1 B8 4D A0  1 
   r> 2 pick 64mem?  if  1 swap c!  else  drop  then
1A37690 	D0 45 A0  1 90 6F A0  1 
1A37698 	 C 4A A0  1 E8 3E A3  1 
1A376A0 	DC 41 A0  1 18  0  0  0 
1A376A8 	80 6F A0  1 68 49 A0  1 
1A376B0 	B8 4D A0  1 C8 41 A0  1 
1A376B8 	 8  0  0  0 30 49 A0  1 
   

   \ assign-pci-addr must be called with $call-self because the ultimate
   \ address assignment must occur in the context of the top-level PCI
   \ node within the PCI domain.  If prober is called from a PCI-PCI
   \ bridge node, the context must be changed to the top-level node
   \ so that the package values next-io and next-mem can be accessed.
   \ PCI-PCI bridges have assign-pci-addr methods that call up the tree.
   " assign-pci-addr" $call-self  ( phys.hi paddr actual-size )
1A376C0 	9C 53 A0  1  F 61 73 73 
1A376C8 	69 67 6E 2D 70 63 69 2D 
1A376D0 	61 64 64 72  0  0  0  0 
1A376D8 	B4 30 A2  1 

   +assigned-address              ( )
1A376DC 	84 74 A3  1 
;
1A376E0 	58 46 A0  1 

\ Returns true if the given address should not be assigned.
defer avoid?  ( phys.hi -- flag )
1A376E4 	 0 61 76 6F 
1A376E8 	69 64 3F 86 4C 75 A3  1 
1A376F0 	5C 40 A0  1 E8  A  0  0 

\ Normally, we don't assign configuration space or non-relocatable addresses
\ In some systems, we may need to avoid additional devices or addresses;
\ in those system, avoid? can be extended as needed.
: (avoid?)  ( phys.hi -- flag )
1A376F8 	 0  0  0 28 61 76 6F 69 
1A37700 	64 3F 29 88 F0 76 A3  1 
1A37708 	20 40 A0  1 
   dup h# 3000000 and  0=  swap h# 80000000 and 0<>  or
1A3770C 	40 49 A0  1 
1A37710 	58 41 A0  1  0  0  0  3 
1A37718 	5C 44 A0  1 24 47 A0  1 
1A37720 	68 49 A0  1 58 41 A0  1 
1A37728 	 0  0  0 80 5C 44 A0  1 
1A37730 	44 47 A0  1 70 44 A0  1 
;
1A37738 	58 46 A0  1 
' (avoid?) to avoid?

: assign-address  ( phys.lo,mid,hi size.lo,hi -- )
1A3773C 	 0 61 73 73 
1A37740 	69 67 6E 2D 61 64 64 72 
1A37748 	65 73 73 8E  8 77 A3  1 
1A37750 	20 40 A0  1 
   2 pick  avoid?  if                    ( phys.lo,mid,hi size.lo,hi )
1A37754 	90 6F A0  1 
1A37758 	 C 4A A0  1 F0 76 A3  1 
1A37760 	DC 41 A0  1 20  0  0  0 
      \ Mark it as assigned so the code that handles base address
      \ registers that don't appear in "reg" properties won't blast it.
      2drop  1 swap >assigned c!  2drop  exit   ( )
1A37768 	AC 49 A0  1 80 6F A0  1 
1A37770 	68 49 A0  1 10 75 A3  1 
1A37778 	B8 4D A0  1 AC 49 A0  1 
1A37780 	40 46 A0  1 
   then                                  ( phys.lo,mid,hi size.lo,hi )
   (assign-address)
1A37784 	4C 75 A3  1 
;
1A37788 	58 46 A0  1 

: decode-reg-entry  ( adr len -- adr' len' phys.lo,mid,hi size.lo,hi )
1A3778C 	 0  0  0 64 
1A37790 	65 63 6F 64 65 2D 72 65 
1A37798 	67 2D 65 6E 74 72 79 90 
1A377A0 	50 77 A3  1 20 40 A0  1 
   decode-int >r  decode-int >r        ( $' ) ( r: phys.hi phys.mid )
1A377A8 	68 F7 A1  1 BC 45 A0  1 
1A377B0 	68 F7 A1  1 BC 45 A0  1 
   decode-int r>  2swap r> -rot        ( phys.lo,mid,hi adr' len' )
1A377B8 	68 F7 A1  1 D0 45 A0  1 
1A377C0 	F4 49 A0  1 D0 45 A0  1 
1A377C8 	94 49 A0  1 
   decode-int >r  decode-int >r        ( phys.lo,mid,hi adr'' len'' )
1A377CC 	68 F7 A1  1 
1A377D0 	BC 45 A0  1 68 F7 A1  1 
1A377D8 	BC 45 A0  1 
   rot >r 2swap r> r> r>               ( adr' len' phys.lo,mid,hi size.lo,hi )
1A377DC 	7C 49 A0  1 
1A377E0 	BC 45 A0  1 F4 49 A0  1 
1A377E8 	D0 45 A0  1 D0 45 A0  1 
1A377F0 	D0 45 A0  1 
;
1A377F4 	58 46 A0  1 

\ Assign addresses for a child device
: assign-package-addresses  ( phandle -- )
1A377F8 	 0  0  0 61 73 73 69 67 
1A37800 	6E 2D 70 61 63 6B 61 67 
1A37808 	65 2D 61 64 64 72 65 73 
1A37810 	73 65 73 98 A4 77 A3  1 
1A37818 	20 40 A0  1 
   \ If there is already an assigned-addresses property, don't reassign.
   \ This handles the case where an on-board device has a preassigned address.
   " assigned-addresses" 2 pick get-package-property  0=  if  3drop exit  then
1A3781C 	9C 53 A0  1 
1A37820 	12 61 73 73 69 67 6E 65 
1A37828 	64 2D 61 64 64 72 65 73 
1A37830 	73 65 73  0 90 6F A0  1 
1A37838 	 C 4A A0  1 98 33 A2  1 
1A37840 	24 47 A0  1 DC 41 A0  1 
1A37848 	 C  0  0  0 90 52 A0  1 
1A37850 	40 46 A0  1 

   already-assigned d# 16 erase		\ No base registers have been assigned
1A37854 	F0 74 A3  1 
1A37858 	58 41 A0  1 10  0  0  0 
1A37860 	F0 72 A0  1 
   init-aa-property
1A37864 	E4 73 A3  1 
   >r
1A37868 	BC 45 A0  1 
   " reg" r@ get-package-property  0=  if    ( adr len r: phandle )
1A3786C 	9C 53 A0  1 
1A37870 	 3 72 65 67  0  0  0  0 
1A37878 	E4 45 A0  1 98 33 A2  1 
1A37880 	24 47 A0  1 DC 41 A0  1 
1A37888 	70  1  0  0 
      \ Get the configuration space address for later
      decode-reg-entry 2drop >r 2drop        ( adr' len' r: phandle phys.hi )
1A3788C 	A4 77 A3  1 
1A37890 	AC 49 A0  1 BC 45 A0  1 
1A37898 	AC 49 A0  1 

      begin  dup 0>  while                   ( adr len r: phandle phys.hi )
1A3789C 	40 49 A0  1 
1A378A0 	A4 47 A0  1 DC 41 A0  1 
1A378A8 	14  0  0  0 
         decode-reg-entry assign-address     ( adr' len' r: phandle phys.hi )
1A378AC 	A4 77 A3  1 
1A378B0 	50 77 A3  1 
      repeat                                 ( adr' len' r: phandle phys.hi )
1A378B4 	C8 41 A0  1 
1A378B8 	E4 FF FF FF 
      2drop                                  ( r: phandle phys.hi )
1A378BC 	AC 49 A0  1 

      \ Ensure that all the base registers have been assigned, even those
      \ that have no "reg" entry.

      \ Determine the last base address register according to whether or
      \ not this device is a PCI-PCI bridge.  We can't use "bridge?" because
      \ it requires that we be in an instance of the child node, but we
      \ are currently in the parent node and there is no longer a child
      \ instance.
      r@ h# 0e + self-b@  h# 7f and  1 =  if  h# 18  else  h# 28  then
1A378C0 	E4 45 A0  1 58 41 A0  1 
1A378C8 	 E  0  0  0  4 45 A0  1 
1A378D0 	4C 3E A3  1 58 41 A0  1 
1A378D8 	7F  0  0  0 5C 44 A0  1 
1A378E0 	80 6F A0  1 24 48 A0  1 
1A378E8 	DC 41 A0  1 14  0  0  0 
1A378F0 	58 41 A0  1 18  0  0  0 
1A378F8 	C8 41 A0  1  C  0  0  0 
1A37900 	58 41 A0  1 28  0  0  0 
                                             ( base-reg-end r: phandle phys.hi)
      \ Loop over the possible base address registers
      r@ +  r> h# 10 +  do                   ( r: phandle )
1A37908 	E4 45 A0  1  4 45 A0  1 
1A37910 	D0 45 A0  1 58 41 A0  1 
1A37918 	10  0  0  0  4 45 A0  1 
1A37920 	88 42 A0  1 D4  0  0  0 
         i probe-base-reg  7 and 4 =  if   \ Skip mem64     ( )
1A37928 	B4 42 A0  1 6C 3F A3  1 
1A37930 	E0 6F A0  1 5C 44 A0  1 
1A37938 	B0 6F A0  1 24 48 A0  1 
1A37940 	DC 41 A0  1 48  0  0  0 
            i find-boundary 1+  if                          ( )
1A37948 	B4 42 A0  1 44 40 A3  1 
1A37950 	30 4B A0  1 DC 41 A0  1 
1A37958 	28  0  0  0 
               0 0
1A3795C 	70 6F A0  1 
1A37960 	70 6F A0  1 
               h# 3000000
1A37964 	58 41 A0  1 
1A37968 	 0  0  0  3 
               i or  0 0  (assign-address)                  ( )
1A3796C 	B4 42 A0  1 
1A37970 	70 44 A0  1 70 6F A0  1 
1A37978 	70 6F A0  1 4C 75 A3  1 
            then                                            ( )
            8                                               ( increment )
1A37980 	F0 6F A0  1 
         else   \ mem32 or I/O                              ( )
1A37984 	C8 41 A0  1 
1A37988 	68  0  0  0 
            i find-boundary 1+  if                          ( )
1A3798C 	B4 42 A0  1 
1A37990 	44 40 A3  1 30 4B A0  1 
1A37998 	DC 41 A0  1 50  0  0  0 
               0 0
1A379A0 	70 6F A0  1 70 6F A0  1 
               i probe-base-reg 1 and  if  h# 1000000  else  h# 2000000  then
1A379A8 	B4 42 A0  1 6C 3F A3  1 
1A379B0 	80 6F A0  1 5C 44 A0  1 
1A379B8 	DC 41 A0  1 14  0  0  0 
1A379C0 	58 41 A0  1  0  0  0  1 
1A379C8 	C8 41 A0  1  C  0  0  0 
1A379D0 	58 41 A0  1  0  0  0  2 
               i or  0 0  (assign-address)                  ( )
1A379D8 	B4 42 A0  1 70 44 A0  1 
1A379E0 	70 6F A0  1 70 6F A0  1 
1A379E8 	4C 75 A3  1 
            then                                            ( )
            4                                               ( increment )
1A379EC 	B0 6F A0  1 
         then                                               ( increment )
      +loop
1A379F0 	1C 42 A0  1 34 FF FF FF 

   then
   r> finish-aa-property
1A379F8 	D0 45 A0  1 20 74 A3  1 
;
1A37A00 	58 46 A0  1 

\ Assign addresses for all children
: assign-all-addresses  ( -- )
1A37A04 	 0  0  0 61 
1A37A08 	73 73 69 67 6E 2D 61 6C 
1A37A10 	6C 2D 61 64 64 72 65 73 
1A37A18 	73 65 73 94 18 78 A3  1 
1A37A20 	20 40 A0  1 
   my-self ihandle>phandle  child
1A37A24 	EC 7E A0  1 
1A37A28 	 0 32 A2  1 58 74 A2  1 
   begin  ?dup  while
1A37A30 	B4 70 A0  1 DC 41 A0  1 
1A37A38 	18  0  0  0 
      dup assign-package-addresses
1A37A3C 	40 49 A0  1 
1A37A40 	18 78 A3  1 
      peer
1A37A44 	B4 74 A2  1 
   repeat
1A37A48 	C8 41 A0  1 E4 FF FF FF 
;
1A37A50 	58 46 A0  1 

headers
: fix-adr  ( pci-devaddr size -- root-devaddr size )  swap pci-devaddr> swap  ;
1A37A54 	66 69 78 2D 
1A37A58 	61 64 72 87 20 7A A3  1 
1A37A60 	20 40 A0  1 68 49 A0  1 
1A37A68 	78 3A A3  1 68 49 A0  1 
1A37A70 	58 46 A0  1 

[ifndef] get-property-patch
also forth definitions
headerless
: get-property-patch  ( adr len -- adr len voc )
1A37A74 	 0 67 65 74 
1A37A78 	2D 70 72 6F 70 65 72 74 
1A37A80 	79 2D 70 61 74 63 68 92 
1A37A88 	CC 39 A3  1 20 40 A0  1 
   2dup " assigned-addresses"  $=  if
1A37A90 	C0 49 A0  1 9C 53 A0  1 
1A37A98 	12 61 73 73 69 67 6E 65 
1A37AA0 	64 2D 61 64 64 72 65 73 
1A37AA8 	73 65 73  0 88 8D A0  1 
1A37AB0 	DC 41 A0  1 34  0  0  0 
      " enable-apple-hack" ['] $call-parent catch  if  2drop  then
1A37AB8 	9C 53 A0  1 11 65 6E 61 
1A37AC0 	62 6C 65 2D 61 70 70 6C 
1A37AC8 	65 2D 68 61 63 6B  0  0 
1A37AD0 	60 53 A0  1 DC 31 A2  1 
1A37AD8 	14 7F A0  1 DC 41 A0  1 
1A37AE0 	 8  0  0  0 AC 49 A0  1 
   then
   current-properties
1A37AE8 	98  C A2  1 
;
1A37AEC 	58 46 A0  1 
patch get-property-patch current-properties get-property
headers
previous definitions
[then]

also forth definitions
: make-properties  ( -- )
1A37AF0 	6D 61 6B 65 2D 70 72 6F 
1A37AF8 	70 65 72 74 69 65 73 8F 
1A37B00 	8C 7A A3  1 20 40 A0  1 
   my-self  " make-function-properties" $call-parent
1A37B08 	EC 7E A0  1 9C 53 A0  1 
1A37B10 	18 6D 61 6B 65 2D 66 75 
1A37B18 	6E 63 74 69 6F 6E 2D 70 
1A37B20 	72 6F 70 65 72 74 69 65 
1A37B28 	73  0  0  0 DC 31 A2  1 
;
1A37B30 	58 46 A0  1 
: assign-addresses  ( -- )
1A37B34 	 0  0  0 61 
1A37B38 	73 73 69 67 6E 2D 61 64 
1A37B40 	64 72 65 73 73 65 73 90 
1A37B48 	 4 7B A3  1 20 40 A0  1 
   my-self ihandle>phandle  " assign-package-addresses"  $call-parent
1A37B50 	EC 7E A0  1  0 32 A2  1 
1A37B58 	9C 53 A0  1 18 61 73 73 
1A37B60 	69 67 6E 2D 70 61 63 6B 
1A37B68 	61 67 65 2D 61 64 64 72 
1A37B70 	65 73 73 65 73  0  0  0 
1A37B78 	DC 31 A2  1 
;
1A37B7C 	58 46 A0  1 
previous definitions

\ Probe the card at the address given by fcode$, setting my-address,my-space
\ in the resulting device node to the address given by reg$.
\
\ probe-self is meant to handle one PCI device (= 1 physical slot)
\ at a time.  Up to 8 functions are checked per device.  Each can have
\ a separate piece of FCode controlling it.

[ifdef] probe-exclusion
\ Check to see if pci node devices are excluded from probing
: (no-probe?)  ( dev-id no-probe-adr no-probe-len -- flag ) 3drop false ;
defer no-probe?    ' (no-probe?)  is  no-probe?
[then]

: probe-self  ( args$ reg$ fcode$ -- )
1A37B80 	 0 70 72 6F 62 65 2D 73 
1A37B88 	65 6C 66 8A 60 7A A3  1 
1A37B90 	20 40 A0  1 
 cr ." probe-self="
1A37B94 	80 6D A0  1 
1A37B98 	20 7C A0  1  B 70 72 6F 
1A37BA0 	62 65 2D 73 65 6C 66 3D 
1A37BA8 	 0  0  0  0 
   " decode-unit" $call-self  nip nip              ( args$ reg$ phys.hi.dev )
1A37BAC 	9C 53 A0  1 
1A37BB0 	 B 64 65 63 6F 64 65 2D 
1A37BB8 	75 6E 69 74  0  0  0  0 
1A37BC0 	B4 30 A2  1 FC 46 A0  1 
1A37BC8 	FC 46 A0  1 
\   probemsg?  if  ." PCI PROBE-SELF:  Phys.hi = " dup . cr  then
                  .s
1A37BCC 	38 7C A0  1 
   max#functions dup . ?dup  if
1A37BD0 	38 73 A3  1 40 49 A0  1 
1A37BD8 	94 7A A0  1 B4 70 A0  1 
1A37BE0 	DC 41 A0  1 2C  0  0  0 
      0  ?do  i probe-function  loop   ( args$ reg$ phys.hi.dev )
1A37BE8 	70 6F A0  1 50 42 A0  1 
1A37BF0 	14  0  0  0 B4 42 A0  1 
1A37BF8 	E0 72 A3  1 F8 41 A0  1 
1A37C00 	F4 FF FF FF 
      diag-cr
1A37C04 	18 E7 A1  1 
   else
1A37C08 	C8 41 A0  1 1C  0  0  0 
      " Nothing there" diag-type-cr
1A37C10 	9C 53 A0  1  D 4E 6F 74 
1A37C18 	68 69 6E 67 20 74 68 65 
1A37C20 	72 65  0  0 74 E7 A1  1 
\      probemsg?  if  ." Nothing there" cr  then
   then
   5drop
1A37C28 	4C 53 A0  1 
;
1A37C2C 	58 46 A0  1 

\ XXX TODO need to handle bus numbers somehow

also forth definitions
defer .prober-location
1A37C30 	 0  0  0 2E 70 72 6F 62 
1A37C38 	65 72 2D 6C 6F 63 61 74 
1A37C40 	69 6F 6E 90 4C 7B A3  1 
1A37C48 	5C 40 A0  1 EC  A  0  0 
' noop is .prober-location
previous definitions

headerless
\ Restore temporary allocation pointers to permanent values
: update-pointers  ( -- )  -1 " assign-pci-addr" $call-self  ;
1A37C50 	75 70 64 61 74 65 2D 70 
1A37C58 	6F 69 6E 74 65 72 73 8F 
1A37C60 	90 7B A3  1 20 40 A0  1 
1A37C68 	58 41 A0  1 FF FF FF FF 
1A37C70 	9C 53 A0  1  F 61 73 73 
1A37C78 	69 67 6E 2D 70 63 69 2D 
1A37C80 	61 64 64 72  0  0  0  0 
1A37C88 	B4 30 A2  1 58 46 A0  1 

headers
[ifndef] my-bus#
0 encode-int  0+i  " bus-range" property
1A37C90 	 0  0  0  0  0  0  0  0 
1A37C98 	 0  0 62 75 73 2D 72 61 
1A37CA0 	6E 67 65 89 74 3C A3  1 
1A37CA8 	BC 13 A2  1 1C  0  0  0 
1A37CB0 	 8  0  0  0 
[then]

: prober  ( adr len -- )
1A37CB4 	 0 70 72 6F 
1A37CB8 	62 65 72 86 64 7C A3  1 
1A37CC0 	20 40 A0  1 
   update-pointers		\ Init the temporary allocation pointers
1A37CC4 	64 7C A3  1 
   begin  dup  while                              ( adr len )
1A37CC8 	40 49 A0  1 DC 41 A0  1 
1A37CD0 	48  0  0  0 
\ CR ."  prober="
      ascii , left-parse-string                   ( rem$ dev#$ )
1A37CD4 	58 41 A0  1 
1A37CD8 	2C  0  0  0 44 D7 A0  1 
\ .s cr
      dup  if                                     ( rem$ dev#$ )
1A37CE0 	40 49 A0  1 DC 41 A0  1 
1A37CE8 	24  0  0  0 
         .prober-location                         ( rem$ dev#$ )
1A37CEC 	48 7C A3  1 
         " "  2swap 2dup  probe-self              ( rem$ )
1A37CF0 	9C 53 A0  1  0  0  0  0 
1A37CF8 	F4 49 A0  1 C0 49 A0  1 
1A37D00 	90 7B A3  1 
      else                                        ( rem$ dev#$ )
1A37D04 	C8 41 A0  1 
1A37D08 	 8  0  0  0 
         2drop                                    ( rem$ )
1A37D0C 	AC 49 A0  1 
      then                                        ( rem$ )
   repeat                                         ( null$ )
1A37D10 	C8 41 A0  1 B4 FF FF FF 
   2drop
1A37D18 	AC 49 A0  1 
   update-pointers		\ Re-init the temporary allocation pointers,
1A37D1C 	64 7C A3  1 
				\ thus erasing any probe-state mappings

   assign-addresses?  if  assign-all-addresses  then
1A37D20 	24 3D A3  1 DC 41 A0  1 
1A37D28 	 8  0  0  0 20 7A A3  1 
   \ XXX TODO set-latency-timers  set-fast-back-to-backs
;
1A37D30 	58 46 A0  1 
: master-probe  ( adr len -- )
1A37D34 	 0  0  0 6D 
1A37D38 	61 73 74 65 72 2D 70 72 
1A37D40 	6F 62 65 8C C0 7C A3  1 
1A37D48 	20 40 A0  1 
   assign-addresses?  to probe-state?
1A37D4C 	24 3D A3  1 
1A37D50 	B8 40 A0  1 AC 3C A3  1 
   prober
1A37D58 	C0 7C A3  1 

   \ Make permanent any address assignments that occurred during the
   \ execution of prober.
   next-mem to first-mem      next-io to first-io
1A37D5C 	D8 3D A3  1 
1A37D60 	48 B8 A1  1 6C 3B A3  1 
1A37D68 	C0 3D A3  1 48 B8 A1  1 
1A37D70 	38 3B A3  1 

   false to probe-state?
1A37D74 	18 70 A0  1 
1A37D78 	B8 40 A0  1 AC 3C A3  1 
[ifdef] my-bus#
   my-bus# current-bus# max  to current-bus#
   my-bus#
[else]
   0
1A37D80 	70 6F A0  1 
[then]
   encode-int  current-bus# +i  " bus-range" property
1A37D84 	40 F7 A1  1 
1A37D88 	C8 3C A3  1  4 47 A3  1 
1A37D90 	9C 53 A0  1  9 62 75 73 
1A37D98 	2D 72 61 6E 67 65  0  0 
1A37DA0 	BC 14 A2  1 
;
1A37DA4 	58 46 A0  1 
: prober-xt  ( -- adr )  ['] prober  ;
1A37DA8 	 0  0 70 72 6F 62 65 72 
1A37DB0 	2D 78 74 89 48 7D A3  1 
1A37DB8 	20 40 A0  1 60 53 A0  1 
1A37DC0 	C0 7C A3  1 58 46 A0  1 

[ifdef] notdef   \ Sun uses a different approach; here is their version
\ Note that this version requires that a "prober" method exist in every
\ subordinate bus node
: master-probe  ( -- )
   \ If previously probed, we need to update current-bus#
   " bus-range"  get-my-property  0= if
      2 decode-ints drop nip nip is current-bus#
   else
      " my-pci-bus" $call-self  is current-bus#
   then

   true to probe-state?
   " prober"  $call-self
   false to probe-state?
   " my-pci-bus" $call-self  encode-int  current-bus# +i  " bus-range" property
;
[then]

\ This is called twice for each PCI-PCI bridge,
\ It is called with n=1 at the beginning of the bridge probing sequence,
\ in order to allocate a new bus number and establish base address values.
\ It is called with n=0 at the end of the bridge probing sequence,
\ in order to determine the "high water marks" of the bus numbers and
\ address ranges that were assigned during the (possibly recursive)
\ bridge probing process.

: allocate-bus#  ( n -- bus# first-mem first-io )
1A37DC8 	 0  0 61 6C 6C 6F 63 61 
1A37DD0 	74 65 2D 62 75 73 23 8D 
1A37DD8 	B8 7D A3  1 20 40 A0  1 
   current-bus# over +  dup to current-bus#			( n bus# )
1A37DE0 	C8 3C A3  1 54 49 A0  1 
1A37DE8 	 4 45 A0  1 40 49 A0  1 
1A37DF0 	B8 40 A0  1 C8 3C A3  1 

   \ When beginning a new bridge (n=1), we use the permanent pointers
   \ (first-xx) in order to "erase" any temporary (probe-state) address
   \ assignments that resulted from probing ordinary devices.

   \ When finishing a bridge (n=0), we use the temporary pointers
   \ (next-xx) in order to capture the result of address
   \ assignments that resulted from "assign-addresses".

   swap  if  first-mem first-io  else  next-mem next-io  then	( bus# mem io )
1A37DF8 	68 49 A0  1 DC 41 A0  1 
1A37E00 	14  0  0  0 6C 3B A3  1 
1A37E08 	38 3B A3  1 C8 41 A0  1 
1A37E10 	 C  0  0  0 D8 3D A3  1 
1A37E18 	C0 3D A3  1 

   h#   1000 round-up dup to first-io   set-next-io		( bus# mem )
1A37E1C 	58 41 A0  1 
1A37E20 	 0 10  0  0 A4 91 A0  1 
1A37E28 	40 49 A0  1 48 B8 A1  1 
1A37E30 	38 3B A3  1 F0 3D A3  1 
   h# 100000 round-up dup to first-mem  set-next-mem		( bus# )
1A37E38 	58 41 A0  1  0  0 10  0 
1A37E40 	A4 91 A0  1 40 49 A0  1 
1A37E48 	48 B8 A1  1 6C 3B A3  1 
1A37E50 	14 3E A3  1 

   update-pointers						( bus# )
1A37E54 	64 7C A3  1 
   first-mem first-io						( bus# mem' io' )
1A37E58 	6C 3B A3  1 38 3B A3  1 
;
1A37E60 	58 46 A0  1 

: map-out      ( vaddr size -- )                 " map-out"     $call-parent  ;
1A37E64 	6D 61 70 2D 
1A37E68 	6F 75 74 87 DC 7D A3  1 
1A37E70 	20 40 A0  1 9C 53 A0  1 
1A37E78 	 7 6D 61 70 2D 6F 75 74 
1A37E80 	 0  0  0  0 DC 31 A2  1 
1A37E88 	58 46 A0  1 

: dma-map-in   ( vaddr size cache? -- devaddr )
1A37E8C 	 0 64 6D 61 
1A37E90 	2D 6D 61 70 2D 69 6E 8A 
1A37E98 	70 7E A3  1 20 40 A0  1 
   " dma-map-in"  $call-parent  >pci-devaddr
1A37EA0 	9C 53 A0  1  A 64 6D 61 
1A37EA8 	2D 6D 61 70 2D 69 6E  0 
1A37EB0 	DC 31 A2  1 50 3A A3  1 
;
1A37EB8 	58 46 A0  1 

: dma-alloc    ( size -- vaddr )                 " dma-alloc"   $call-parent  ;
1A37EBC 	 0  0 64 6D 
1A37EC0 	61 2D 61 6C 6C 6F 63 89 
1A37EC8 	9C 7E A3  1 20 40 A0  1 
1A37ED0 	9C 53 A0  1  9 64 6D 61 
1A37ED8 	2D 61 6C 6C 6F 63  0  0 
1A37EE0 	DC 31 A2  1 58 46 A0  1 
: dma-free     ( vaddr size -- )                 " dma-free"    $call-parent  ;
1A37EE8 	 0  0  0 64 6D 61 2D 66 
1A37EF0 	72 65 65 88 CC 7E A3  1 
1A37EF8 	20 40 A0  1 9C 53 A0  1 
1A37F00 	 8 64 6D 61 2D 66 72 65 
1A37F08 	65  0  0  0 DC 31 A2  1 
1A37F10 	58 46 A0  1 
: dma-map-out  ( vaddr devaddr size -- ) fix-adr " dma-map-out" $call-parent  ;
1A37F14 	64 6D 61 2D 
1A37F18 	6D 61 70 2D 6F 75 74 8B 
1A37F20 	F8 7E A3  1 20 40 A0  1 
1A37F28 	60 7A A3  1 9C 53 A0  1 
1A37F30 	 B 64 6D 61 2D 6D 61 70 
1A37F38 	2D 6F 75 74  0  0  0  0 
1A37F40 	DC 31 A2  1 58 46 A0  1 
: dma-sync     ( vaddr devaddr size -- ) fix-adr " dma-sync"    $call-parent  ;
1A37F48 	 0  0  0 64 6D 61 2D 73 
1A37F50 	79 6E 63 88 24 7F A3  1 
1A37F58 	20 40 A0  1 60 7A A3  1 
1A37F60 	9C 53 A0  1  8 64 6D 61 
1A37F68 	2D 73 79 6E 63  0  0  0 
1A37F70 	DC 31 A2  1 58 46 A0  1 
: dma-push     ( vaddr devaddr size -- ) fix-adr " dma-push"    $call-parent  ;
1A37F78 	 0  0  0 64 6D 61 2D 70 
1A37F80 	75 73 68 88 58 7F A3  1 
1A37F88 	20 40 A0  1 60 7A A3  1 
1A37F90 	9C 53 A0  1  8 64 6D 61 
1A37F98 	2D 70 75 73 68  0  0  0 
1A37FA0 	DC 31 A2  1 58 46 A0  1 
: dma-pull     ( vaddr devaddr size -- ) fix-adr " dma-pull"    $call-parent  ;
1A37FA8 	 0  0  0 64 6D 61 2D 70 
1A37FB0 	75 6C 6C 88 88 7F A3  1 
1A37FB8 	20 40 A0  1 60 7A A3  1 
1A37FC0 	9C 53 A0  1  8 64 6D 61 
1A37FC8 	2D 70 75 6C 6C  0  0  0 
1A37FD0 	DC 31 A2  1 58 46 A0  1 

\ Define the display format for some PCI-specific properties
also known-int-properties definitions
[ifndef] alternate-reg
: alternate-reg       ( -- n )  reg  ;
1A37FD8 	 0  0 61 6C 74 65 72 6E 
1A37FE0 	61 74 65 2D 72 65 67 8D 
1A37FE8 	B8 27 A2  1 20 40 A0  1 
1A37FF0 	C0 26 A2  1 58 46 A0  1 
: assigned-addresses  ( -- n )  reg  ;
1A37FF8 	 0 61 73 73 69 67 6E 65 
1A38000 	64 2D 61 64 64 72 65 73 
1A38008 	73 65 73 92 EC 7F A3  1 
1A38010 	20 40 A0  1 C0 26 A2  1 
1A38018 	58 46 A0  1 
[then]
previous definitions

[ifdef] notdef   \ Some code from Sun, untested in our environment
: lookup-ranges ( -- size phys.lo )
   decode-int drop decode-int drop decode-phys lxjoin >r
     decode-int >r decode-int r> lxjoin r> over 1- and
;

: set-avail-prop ( -- )
  select-dev
     my-self ihandle>phandle dup >r
     " available" 2dup r> get-package-property 0= if
        2drop 2dup delete-property
     then 2>r >r
     " ranges" r> get-package-property 0= if
        begin dup 0> while
           decode-int dup h# 01000000 = if
                 drop lookup-ranges next-io + swap next-io - >r >r
                      h# 81000000 " my-pci-bus" $call-self  h# 10 lshift or >r
                 else
                      h# 02000000 = if
                      lookup-ranges next-mem + swap next-mem - >r >r
                      h# 82000000 " my-pci-bus" $call-self  h# 10 lshift or >r
                 else
                      lookup-ranges 2drop
                 then then
        repeat
        2drop then
        0 0 encode-bytes
        r> +i 0+i r> +i r> xlsplit swap >r +i r> +i
        r> +i 0+i r> +i r> xlsplit swap >r +i r> +i
        2r> property
   unselect-dev
;
headerless
[then]


OpenFirmware/dev/pcibus.fth_AL	4590 1A3801C 1A38038 1A38058 1A3808C purpose: PCI bus package

\ For the PVI-486AP4 board with the i82425/5 chipset
\ wrong for most hardware...
\ what should this be for a generic system?
\ h# 1800 encode-int  " slave-only" property
\ h# 1e00 encode-int			\ Mask of implemented add-in slots
\ " PCI-1"           encode-string encode+
\ " PCI-2"           encode-string encode+ 
\ " PCI-3"           encode-string encode+
\ " PCI-4"           encode-string encode+

\ For the PicoPower 550/560/570 motherboard
\ wrong for most hardware...
\ what should this be for a generic system?  No such thing
h# 1000 encode-int  " slave-only" property
1A38044 	 0  0 10  0 
1A38048 	 0 73 6C 61 76 65 2D 6F 
1A38050 	6E 6C 79 8A 38 80 A3  1 
1A38058 	BC 13 A2  1 18  0  0  0 
1A38060 	 4  0  0  0 
h# 1800 encode-int			\ Mask of implemented add-in slots
1A38064 	 0  0 18  0 
" PCI-1"           encode-string encode+
1A38068 	50 43 49 2D 31  0 
" PCI-2"           encode-string encode+
1A3806E 	50 43 
1A38070 	49 2D 32  0 
" PCI-3"           encode-string encode+
1A38074 	50 43 49 2D 
1A38078 	33  0 

" slot-names" property
1A3807A 	 0  0  0 73 6C 6F 
1A38080 	74 2D 6E 61 6D 65 73 8A 
1A38088 	58 80 A3  1 BC 13 A2  1 
1A38090 	2C  0  0  0 16  0  0  0 

also forth definitions


\ unknown hardware, so probe all low slots
\ note: could hang some systems
\ note: some systems might have devices 0..1f

previous definitions

h# 1000.0000 to first-mem		\ Avoid RAM at low addresses
h# 2000.0000 to mem-space-top
h# 0000.8000 to first-io		\ Avoid mappings established by BIOS

defer config-setup
1A38098 	 0  0  0 63 6F 6E 66 69 
1A380A0 	67 2D 73 65 74 75 70 8C 
1A380A8 	B8 7F A3  1 5C 40 A0  1 
1A380B0 	F0  A  0  0 
defer config-done
1A380B4 	63 6F 6E 66 
1A380B8 	69 67 2D 64 6F 6E 65 8B 
1A380C0 	AC 80 A3  1 5C 40 A0  1 
1A380C8 	F4  A  0  0 

\ Configuration mechanism #1 as defined in the PCI spec.
: config-setup1  ( config-adr -- vaddr )
1A380CC 	 0  0 63 6F 
1A380D0 	6E 66 69 67 2D 73 65 74 
1A380D8 	75 70 31 8D C4 80 A3  1 
1A380E0 	20 40 A0  1 
   \ Bit 31 ("enable") must be 1, bits 30:24 ("reserved") must be 0,
   \ bits 1:0 must be 0.
   dup h# ff.fffc and  h# 8000.0000 or  h# cf8 pl!  ( config-adr )
1A380E4 	40 49 A0  1 
1A380E8 	58 41 A0  1 FC FF FF  0 
1A380F0 	5C 44 A0  1 58 41 A0  1 
1A380F8 	 0  0  0 80 70 44 A0  1 
1A38100 	58 41 A0  1 F8  C  0  0 
1A38108 	10 82 A2  1 

   3 and  h# cfc +  \ Merge in the byte selector bits
1A3810C 	A0 6F A0  1 
1A38110 	5C 44 A0  1 58 41 A0  1 
1A38118 	FC  C  0  0  4 45 A0  1 
;
1A38120 	58 46 A0  1 

\ These versions of config-x@/! are for "configuration mechanism #2"
\ as described in the PCI design guide.  That mechanism is not the
\ recommended one, but several PC PCI chipsets use it.

: config-setup2  ( bus#|dev#|function|reg# -- port-adr )
1A38124 	 0  0 63 6F 
1A38128 	6E 66 69 67 2D 73 65 74 
1A38130 	75 70 32 8D E0 80 A3  1 
1A38138 	20 40 A0  1 
   \ XXX For now, we ignore the bus number
   \ Write function number and "access config space" key to the config
   \ space enable register
   dup 7 >> h# e and  h# 10 or  h# cf8 pc!  ( bus#|dev#|function#|reg#)
1A3813C 	40 49 A0  1 
1A38140 	E0 6F A0  1 DC 44 A0  1 
1A38148 	58 41 A0  1  E  0  0  0 
1A38150 	5C 44 A0  1 58 41 A0  1 
1A38158 	10  0  0  0 70 44 A0  1 
1A38160 	58 41 A0  1 F8  C  0  0 
1A38168 	E8 81 A2  1 
   dup h# ff and  swap d# 11 >> h# f and 8 <<  or  h# c000 or
1A3816C 	40 49 A0  1 
1A38170 	58 41 A0  1 FF  0  0  0 
1A38178 	5C 44 A0  1 68 49 A0  1 
1A38180 	58 41 A0  1  B  0  0  0 
1A38188 	DC 44 A0  1 58 41 A0  1 
1A38190 	 F  0  0  0 5C 44 A0  1 
1A38198 	F0 6F A0  1 C8 44 A0  1 
1A381A0 	70 44 A0  1 58 41 A0  1 
1A381A8 	 0 C0  0  0 70 44 A0  1 
;
1A381B0 	58 46 A0  1 
: config-done2  ( -- )  0 h# cf8 pc!  ; 
1A381B4 	 0  0  0 63 
1A381B8 	6F 6E 66 69 67 2D 64 6F 
1A381C0 	6E 65 32 8C 38 81 A3  1 
1A381C8 	20 40 A0  1 70 6F A0  1 
1A381D0 	58 41 A0  1 F8  C  0  0 
1A381D8 	E8 81 A2  1 58 46 A0  1 

: config-b@  ( config-adr -- b )  config-setup pc@ config-done  ;
1A381E0 	 0  0 63 6F 6E 66 69 67 
1A381E8 	2D 62 40 89 C8 81 A3  1 
1A381F0 	20 40 A0  1 AC 80 A3  1 
1A381F8 	AC 81 A2  1 C4 80 A3  1 
1A38200 	58 46 A0  1 
: config-w@  ( config-adr -- w )  config-setup pw@ config-done  ;
1A38204 	 0  0 63 6F 
1A38208 	6E 66 69 67 2D 77 40 89 
1A38210 	F0 81 A3  1 20 40 A0  1 
1A38218 	AC 80 A3  1 C0 81 A2  1 
1A38220 	C4 80 A3  1 58 46 A0  1 
: config-l@  ( config-adr -- l )  config-setup pl@ config-done  ;
1A38228 	 0  0 63 6F 6E 66 69 67 
1A38230 	2D 6C 40 89 14 82 A3  1 
1A38238 	20 40 A0  1 AC 80 A3  1 
1A38240 	D4 81 A2  1 C4 80 A3  1 
1A38248 	58 46 A0  1 
: config-b!  ( b config-adr -- )  config-setup pc! config-done  ;
1A3824C 	 0  0 63 6F 
1A38250 	6E 66 69 67 2D 62 21 89 
1A38258 	38 82 A3  1 20 40 A0  1 
1A38260 	AC 80 A3  1 E8 81 A2  1 
1A38268 	C4 80 A3  1 58 46 A0  1 
: config-w!  ( w config-adr -- )  config-setup pw! config-done  ;
1A38270 	 0  0 63 6F 6E 66 69 67 
1A38278 	2D 77 21 89 5C 82 A3  1 
1A38280 	20 40 A0  1 AC 80 A3  1 
1A38288 	FC 81 A2  1 C4 80 A3  1 
1A38290 	58 46 A0  1 
: config-l!  ( l config-adr -- )  config-setup pl! config-done  ;
1A38294 	 0  0 63 6F 
1A38298 	6E 66 69 67 2D 6C 21 89 
1A382A0 	80 82 A3  1 20 40 A0  1 
1A382A8 	AC 80 A3  1 10 82 A2  1 
1A382B0 	C4 80 A3  1 58 46 A0  1 

: mechanism1   ( -- )
1A382B8 	 0 6D 65 63 68 61 6E 69 
1A382C0 	73 6D 31 8A A4 82 A3  1 
1A382C8 	20 40 A0  1 
   ['] config-setup1 to config-setup
1A382CC 	60 53 A0  1 
1A382D0 	E0 80 A3  1 98 40 A0  1 
1A382D8 	AC 80 A3  1 
   ['] noop          to config-done
1A382DC 	60 53 A0  1 
1A382E0 	64 4F A0  1 98 40 A0  1 
1A382E8 	C4 80 A3  1 
;
1A382EC 	58 46 A0  1 
mechanism1
: mechanism2   ( -- )
1A382F0 	 0 6D 65 63 68 61 6E 69 
1A382F8 	73 6D 32 8A C8 82 A3  1 
1A38300 	20 40 A0  1 
   ['] config-setup2 to config-setup
1A38304 	60 53 A0  1 
1A38308 	38 81 A3  1 98 40 A0  1 
1A38310 	AC 80 A3  1 
   ['] config-done2  to config-done
1A38314 	60 53 A0  1 
1A38318 	C8 81 A3  1 98 40 A0  1 
1A38320 	C4 80 A3  1 
;
1A38324 	58 46 A0  1 

\ !!! assumes a device in either slot 0 or slot 1 !!!
\ and that failed reads return -1.
: init  ( -- )
1A38328 	 0  0  0 69 6E 69 74 84 
1A38330 	 0 83 A3  1 20 40 A0  1 
   mechanism1
1A38338 	C8 82 A3  1 
   0 config-l@  -1 =  h# 800 config-l@  -1 =  and  if
1A3833C 	70 6F A0  1 
1A38340 	38 82 A3  1 58 41 A0  1 
1A38348 	FF FF FF FF 24 48 A0  1 
1A38350 	58 41 A0  1  0  8  0  0 
1A38358 	38 82 A3  1 58 41 A0  1 
1A38360 	FF FF FF FF 24 48 A0  1 
1A38368 	5C 44 A0  1 DC 41 A0  1 
1A38370 	 8  0  0  0 
      mechanism2
1A38374 	 0 83 A3  1 
\      h# 0000.5000  to first-io    \ Avoid on-board SCSI chip's BIOS mapping 
\      " 3,4,5" to pci-probe-list
   then
;
1A38378 	58 46 A0  1 

\ Determine the parent interrupt information (the "interrupt line" in PCI
\ parlance) from the child's "interrupt pin" and the child's address,
\ returning "int-line true" if the child's interrupt line register should
\ be set or "false" otherwise.
: assign-int-line  ( phys.hi.func INTx -- irq true )
1A3837C 	61 73 73 69 
1A38380 	67 6E 2D 69 6E 74 2D 6C 
1A38388 	69 6E 65 8F 34 83 A3  1 
1A38390 	20 40 A0  1 
   \ Reiterate the value that is already in the int line register,
   \ which was presumably placed there by the BIOS
   drop  h# 3c +  config-b@  true
1A38394 	30 49 A0  1 
1A38398 	58 41 A0  1 3C  0  0  0 
1A383A0 	 4 45 A0  1 F0 81 A3  1 
1A383A8 	 4 70 A0  1 
;
1A383AC 	58 46 A0  1 

\ XXX we should keep a table of already-mapped addresses so that
\ successive map/unmaps of the same address will succeed.


\ The io-base handling really ought to be in the root node, but
\ that would require more changes than I'm willing to do at present.
warning @ warning off
: map-out  ( vaddr size -- )
1A383B0 	6D 61 70 2D 6F 75 74 87 
1A383B8 	90 83 A3  1 20 40 A0  1 
   over io-base u>=  if  2drop exit  then  ( vaddr size )
1A383C0 	54 49 A0  1 B4 37 A3  1 
1A383C8 	CC 48 A0  1 DC 41 A0  1 
1A383D0 	 C  0  0  0 AC 49 A0  1 
1A383D8 	40 46 A0  1 
   map-out                                 ( )
1A383DC 	70 7E A3  1 
;   
1A383E0 	58 46 A0  1 
warning !

OpenFirmware/cpu/x86/pc/biosload/pcinode.fth_AL	3A0 1A383E4 
99D3054   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99D3064   00 00 00 00  00 00 00 00  00 80 00 00  00 00 01 00 ...............
99D3074   00 00 00 10  00 00 00 20  00 00 00 00  00 00 00 00 ....... ........purpose: PCI probing user interface commands

: probe-pci  ( -- )
1A3846C 	 0  0 70 72 
1A38470 	6F 62 65 2D 70 63 69 89 
1A38478 	20 84 A3  1 20 40 A0  1 
   " /pci" open-dev  ?dup  if   ( ihandle )
1A38480 	9C 53 A0  1  4 2F 70 63 
1A38488 	69  0  0  0 FC 3E A2  1 
1A38490 	B4 70 A0  1 DC 41 A0  1 
1A38498 	A4  0  0  0 
      iselect
1A3849C 	3C 40 A2  1 
\      " pci-probe-list" eval
" 0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,10,11,12,13,14,15,16,17,18,19,1a,1b,1c,1d,1e,1f"
1A384A0 	9C 53 A0  1 4F 30 2C 31 
1A384A8 	2C 32 2C 33 2C 34 2C 35 
1A384B0 	2C 36 2C 37 2C 38 2C 39 
1A384B8 	2C 61 2C 62 2C 63 2C 64 
1A384C0 	2C 65 2C 66 2C 31 30 2C 
1A384C8 	31 31 2C 31 32 2C 31 33 
1A384D0 	2C 31 34 2C 31 35 2C 31 
1A384D8 	36 2C 31 37 2C 31 38 2C 
1A384E0 	31 39 2C 31 61 2C 31 62 
1A384E8 	2C 31 63 2C 31 64 2C 31 
1A384F0 	65 2C 31 66  0  0  0  0 
 CR  ."  master-probe eval=" HERE .H
1A384F8 	80 6D A0  1 20 7C A0  1 
1A38500 	13 20 6D 61 73 74 65 72 
1A38508 	2D 70 72 6F 62 65 20 65 
1A38510 	76 61 6C 3D  0  0  0  0 
1A38518 	70 54 A0  1 10  E A1  1 
  " master-probe" eval
1A38520 	9C 53 A0  1  C 6D 61 73 
1A38528 	74 65 72 2D 70 72 6F 62 
1A38530 	65  0  0  0 D8 E5 A0  1 
      unselect-dev
1A38538 	50 41 A2  1 

   then
;
1A3853C 	58 46 A0  1 

OpenFirmware/dev/pciprobe.fth_AL	D4 1A38540 purpose: Timing functions using model-specific time-stamp-counter register

\ One way to read the time-stamp counter is to use the
\ "read model-specific register" instruction with the value 0x10 in CX, e.g.:
\  h# 10 # cx mov		\ Timestamp counter code
\  h# f c,  h# 32 c,		\ Read Model-Specific Register
\ RDMSR works only in supervisor state

code tsc@  ( -- low high )
1A38540 	 0  0  0 74 73 63 40 84 
1A38548 	7C 84 A3  1 50 85 A3  1 
   \ This version of the instruction can also be used from User state
   \ if bit 2 in the CR4 register is 0.
   h# f c,  h# 31 c,		\ Read Time-Stamp Counter
1A38550 	 F 31 
   ax push   dx push
1A38552 	50 52 
c;
1A38554 	FF E7 
code spins  ( count -- )
1A38556 	73 70 
1A38558 	69 6E 73 85 4C 85 A3  1 
1A38560 	64 85 A3  1 
   bx pop
1A38564 	5B 
   h# f c,  h# 31 c,		\ Read Time-Stamp Counter   
1A38565 	 F 31 
   ax bx add			\ bx: target time
1A38567 	 1 
1A38568 	C3 
   begin
      h# f c,  h# 31 c,		\ Read Time-Stamp Counter into dx,ax
1A38569 	 F 31 
      bx ax sub
1A3856B 	29 D8 
   0>= until
1A3856D 	78 FA 
c;
1A3856F 	FF 
1A38570 	E7 

d# 10 to ms/tick
d# 262000 value ms-factor
1A38571 	 0 6D 73 2D 66 61 63 
1A38578 	74 6F 72 89 60 85 A3  1 
1A38580 	50 40 A0  1 F8  A  0  0 
d# 262 value us-factor
1A38588 	 0  0 75 73 2D 66 61 63 
1A38590 	74 6F 72 89 80 85 A3  1 
1A38598 	50 40 A0  1 FC  A  0  0 

0 value tick-msecs	\ To make isatick.fth happy
1A385A0 	 0 74 69 63 6B 2D 6D 73 
1A385A8 	65 63 73 8A 98 85 A3  1 
1A385B0 	50 40 A0  1  0  B  0  0 

: (get-msecs)  ( -- )  tsc@ ms-factor um/mod  nip  ;
1A385B8 	28 67 65 74 2D 6D 73 65 
1A385C0 	63 73 29 8B B0 85 A3  1 
1A385C8 	20 40 A0  1 4C 85 A3  1 
1A385D0 	80 85 A3  1 7C 5D A0  1 
1A385D8 	FC 46 A0  1 58 46 A0  1 
' (get-msecs) to get-msecs

: 1ms  ( -- )  ms-factor spins  ;
1A385E0 	31 6D 73 83 C8 85 A3  1 
1A385E8 	20 40 A0  1 80 85 A3  1 
1A385F0 	60 85 A3  1 58 46 A0  1 
: (us)  ( #microseconds -- )  us-factor * spins  ;
1A385F8 	 0  0  0 28 75 73 29 84 
1A38600 	E8 85 A3  1 20 40 A0  1 
1A38608 	98 85 A3  1 1C 5F A0  1 
1A38610 	60 85 A3  1 58 46 A0  1 
' (us) to us

[ifdef] use-timestamp-counter
: (ms)  ( #ms -- )  0  ?do  1ms  loop  ;
1A38618 	 0  0  0 28 6D 73 29 84 
1A38620 	 4 86 A3  1 20 40 A0  1 
1A38628 	70 6F A0  1 50 42 A0  1 
1A38630 	10  0  0  0 E8 85 A3  1 
1A38638 	F8 41 A0  1 F8 FF FF FF 
1A38640 	58 46 A0  1 
' (ms) to ms
[then]

[ifdef] use-tsc-timing   \ These are precise but inaccurate, as the TSC varies with clock throttling
\ Timing tools
2variable timestamp
: t-update ;
: t(  ( -- )  tsc@ timestamp 2! ;
: ))t  ( -- d.ticks )  tsc@  timestamp 2@  d-  ;
: ))t-usecs  ( -- usecs )  ))t us-factor um/mod nip  ;
: )t  ( -- )
   ))t-usecs  ( microseconds )
   push-decimal
   <#  u# u# u#  [char] , hold  u# u#s u#>  type  ."  uS "
   pop-base
;
: t-sec(  ( -- )  t(  ;
: )t-sec  ( -- )
   ))t  us-factor d# 1,000,000 *  um/mod nip  ( seconds )
   push-decimal
   <# u# u#s u#>  type  ." S "
   pop-base
;
: .hms  ( seconds -- )
   d# 60 /mod   d# 60 /mod    ( sec min hrs )
   push-decimal
   <# u# u#s u#> type ." :" <# u# u# u#> type ." :" <# u# u# u#>  type
   pop-base
;
: t-hms(  ( -- )  t(  ;
: )t-hms
   ))t  us-factor d# 1,000,000 *  um/mod nip  ( seconds )
   .hms
;
[then]


OpenFirmware/cpu/x86/tsc.fth_AL	104 1A38644 
begin-package
select-dev=</>0 0 5D9288 0 

propset=1A38658 B44259A 1A00B44 
vocset=B44259A 1A00B44 1A38658 
new-node=B4425AE 1A00B24 
vocset=B4425AE 1A00B24 1A38658 0 0 5D9288 0 

set-args0=0 5D9288 0 0 
begin-package;
ega-text
1A3866C 1A38690 1A386B4 purpose: Display driver for EGA/VGA in text mode

\ 0 0  " "  " /"  begin-package

hex
headers

" ega-text" device-name
1A38658 	65 67 61 2D 74 65 78 74 
1A38660 	 0  0  0 6E 61 6D 65 84 
1A38668 	 0  0 A0  1 BC 13 A2  1 
1A38670 	18  0  0  0  9  0  0  0 
" display"                      device-type
1A38678 	64 69 73 70 6C 61 79  0 
1A38680 	64 65 76 69 63 65 5F 74 
1A38688 	79 70 65 8B 6C 86 A3  1 
1A38690 	BC 13 A2  1 1C  0  0  0 
1A38698 	 8  0  0  0 
0 0  encode-bytes  " iso6429-1983-colors"  property
1A3869C 	69 73 6F 36 
1A386A0 	34 32 39 2D 31 39 38 33 
1A386A8 	2D 63 6F 6C 6F 72 73 93 
1A386B0 	90 86 A3  1 BC 13 A2  1 
1A386B8 	1C  0  0  0  0  0  0  0 

d# 80 constant #ega-columns
1A386C0 	 0  0  0 23 65 67 61 2D 
1A386C8 	63 6F 6C 75 6D 6E 73 8C 
1A386D0 	 0  0 A0  1 68 40 A0  1 
1A386D8 	50  0  0  0 
d# 25 constant #ega-lines
1A386DC 	 0 23 65 67 
1A386E0 	61 2D 6C 69 6E 65 73 8A 
1A386E8 	D4 86 A3  1 68 40 A0  1 
1A386F0 	19  0  0  0 
#ega-lines #ega-columns * constant #chars
1A386F4 	 0 23 63 68 
1A386F8 	61 72 73 86 EC 86 A3  1 
1A38700 	68 40 A0  1 D0  7  0  0 
#chars 2* constant /ega
1A38708 	 0  0  0 2F 65 67 61 84 
1A38710 	 0 87 A3  1 68 40 A0  1 
1A38718 	A0  F  0  0 
7 value attributes
1A3871C 	 0 61 74 74 
1A38720 	72 69 62 75 74 65 73 8A 
1A38728 	14 87 A3  1 50 40 A0  1 
1A38730 	28  B  0  0 

: background  ( -- n )
1A38734 	 0 62 61 63 
1A38738 	6B 67 72 6F 75 6E 64 8A 
1A38740 	2C 87 A3  1 20 40 A0  1 
   inverse?  if  foreground-color  else  background-color  then
1A38748 	2C 89 A2  1 DC 41 A0  1 
1A38750 	10  0  0  0 DC 89 A2  1 
1A38758 	C8 41 A0  1  8  0  0  0 
1A38760 	FC 89 A2  1 
;
1A38764 	58 46 A0  1 
: foreground  ( -- n )
1A38768 	 0 66 6F 72 65 67 72 6F 
1A38770 	75 6E 64 8A 44 87 A3  1 
1A38778 	20 40 A0  1 
   inverse?  if  background-color  else  foreground-color  then
1A3877C 	2C 89 A2  1 
1A38780 	DC 41 A0  1 10  0  0  0 
1A38788 	FC 89 A2  1 C8 41 A0  1 
1A38790 	 8  0  0  0 DC 89 A2  1 
;
1A38798 	58 46 A0  1 
: set-attributes  ( -- )
1A3879C 	 0 73 65 74 
1A387A0 	2D 61 74 74 72 69 62 75 
1A387A8 	74 65 73 8E 78 87 A3  1 
1A387B0 	20 40 A0  1 
   background 7 and  4 lshift  foreground or  to attributes
1A387B4 	44 87 A3  1 
1A387B8 	E0 6F A0  1 5C 44 A0  1 
1A387C0 	B0 6F A0  1 9C 44 A0  1 
1A387C8 	78 87 A3  1 70 44 A0  1 
1A387D0 	B8 40 A0  1 2C 87 A3  1 
;
1A387D8 	58 46 A0  1 

0 value ega
1A387DC 	65 67 61 83 
1A387E0 	B0 87 A3  1 50 40 A0  1 
1A387E8 	2C  B  0  0 
: fill-text  ( len value -- )
1A387EC 	 0  0 66 69 
1A387F0 	6C 6C 2D 74 65 78 74 89 
1A387F8 	E4 87 A3  1 20 40 A0  1 
   ega rot 2*  bounds  do  dup i c!  2 +loop  drop
1A38800 	E4 87 A3  1 7C 49 A0  1 
1A38808 	A0 4B A0  1 F0 6D A0  1 
1A38810 	88 42 A0  1 1C  0  0  0 
1A38818 	40 49 A0  1 B4 42 A0  1 
1A38820 	B8 4D A0  1 90 6F A0  1 
1A38828 	1C 42 A0  1 EC FF FF FF 
1A38830 	30 49 A0  1 
;
1A38834 	58 46 A0  1 
: fill-attrs  ( len value -- )
1A38838 	 0 66 69 6C 6C 2D 61 74 
1A38840 	74 72 73 8A FC 87 A3  1 
1A38848 	20 40 A0  1 
   ega rot 2*  bounds  do  dup i 1+ c!  2 +loop  drop
1A3884C 	E4 87 A3  1 
1A38850 	7C 49 A0  1 A0 4B A0  1 
1A38858 	F0 6D A0  1 88 42 A0  1 
1A38860 	20  0  0  0 40 49 A0  1 
1A38868 	B4 42 A0  1 30 4B A0  1 
1A38870 	B8 4D A0  1 90 6F A0  1 
1A38878 	1C 42 A0  1 E8 FF FF FF 
1A38880 	30 49 A0  1 
;
1A38884 	58 46 A0  1 

\ On many chipsets, to access the CRT registers you have to do things
\ like turning on the I/O enable in the PCI command register for the
\ display controller.  And on some chipsets the screen blanks if you
\ try to touch the CRT registers.
\ : crt-setup  ( index -- data-adr )  h# 03d4 pc!  h# 03d5  ;
\ : crt!  ( b index -- )  crt-setup pc!  ;
\ : crt@  ( index -- b )  crt-setup pc@  ;

: ega-screen-adr  ( column# line# -- adr )  #columns *  + 2*  ega +  ;
1A38888 	 0 65 67 61 2D 73 63 72 
1A38890 	65 65 6E 2D 61 64 72 8E 
1A38898 	48 88 A3  1 20 40 A0  1 
1A388A0 	1C 87 A2  1 1C 5F A0  1 
1A388A8 	 4 45 A0  1 A0 4B A0  1 
1A388B0 	E4 87 A3  1  4 45 A0  1 
1A388B8 	58 46 A0  1 
: ega-line-adr  ( line# -- adr )  0 swap ega-screen-adr  ;
1A388BC 	 0  0  0 65 
1A388C0 	67 61 2D 6C 69 6E 65 2D 
1A388C8 	61 64 72 8C 9C 88 A3  1 
1A388D0 	20 40 A0  1 70 6F A0  1 
1A388D8 	68 49 A0  1 9C 88 A3  1 
1A388E0 	58 46 A0  1 
: ega-column-adr ( column# -- adr )  line# ega-screen-adr  ;
1A388E4 	 0 65 67 61 
1A388E8 	2D 63 6F 6C 75 6D 6E 2D 
1A388F0 	61 64 72 8E D0 88 A3  1 
1A388F8 	20 40 A0  1 54 86 A2  1 
1A38900 	9C 88 A3  1 58 46 A0  1 
: ega-cursor-adr  ( -- adr )  column# line#  ega-screen-adr  ;
1A38908 	 0 65 67 61 2D 63 75 72 
1A38910 	73 6F 72 2D 61 64 72 8E 
1A38918 	F8 88 A3  1 20 40 A0  1 
1A38920 	40 86 A2  1 54 86 A2  1 
1A38928 	9C 88 A3  1 58 46 A0  1 

: ega-draw-character  ( char -- )
1A38930 	 0 65 67 61 2D 64 72 61 
1A38938 	77 2D 63 68 61 72 61 63 
1A38940 	74 65 72 92 1C 89 A3  1 
1A38948 	20 40 A0  1 
   set-attributes  ega-cursor-adr tuck c!  attributes swap 1+ c!
1A3894C 	B0 87 A3  1 
1A38950 	1C 89 A3  1 E8 46 A0  1 
1A38958 	B8 4D A0  1 2C 87 A3  1 
1A38960 	68 49 A0  1 30 4B A0  1 
1A38968 	B8 4D A0  1 
;
1A3896C 	58 46 A0  1 
: ega-reset-screen  ( -- )  ( TBD )  ;
1A38970 	 0  0  0 65 67 61 2D 72 
1A38978 	65 73 65 74 2D 73 63 72 
1A38980 	65 65 6E 90 48 89 A3  1 
1A38988 	20 40 A0  1 58 46 A0  1 

\ Exchange foreground and background
: flop  ( attr-byte -- attr-byte' )
1A38990 	 0  0  0 66 6C 6F 70 84 
1A38998 	88 89 A3  1 20 40 A0  1 
   dup h# 88 and  over 4 lshift h# 70 and or  swap 4 rshift 7 and  or
1A389A0 	40 49 A0  1 58 41 A0  1 
1A389A8 	88  0  0  0 5C 44 A0  1 
1A389B0 	54 49 A0  1 B0 6F A0  1 
1A389B8 	9C 44 A0  1 58 41 A0  1 
1A389C0 	70  0  0  0 5C 44 A0  1 
1A389C8 	70 44 A0  1 68 49 A0  1 
1A389D0 	B0 6F A0  1 B4 44 A0  1 
1A389D8 	E0 6F A0  1 5C 44 A0  1 
1A389E0 	70 44 A0  1 
;
1A389E4 	58 46 A0  1 
: ega-toggle-cursor  ( -- )
1A389E8 	 0  0 65 67 61 2D 74 6F 
1A389F0 	67 67 6C 65 2D 63 75 72 
1A389F8 	73 6F 72 91 9C 89 A3  1 
1A38A00 	20 40 A0  1 
   set-attributes
1A38A04 	B0 87 A3  1 
   ega-cursor-adr 1+               ( attribute-adr )
1A38A08 	1C 89 A3  1 30 4B A0  1 
   dup c@  flop  swap c!           ( )
1A38A10 	40 49 A0  1 C4 4C A0  1 
1A38A18 	9C 89 A3  1 68 49 A0  1 
1A38A20 	B8 4D A0  1 

\ Code for the hardware cursor; unwise to use it because accessing
\ the CRT registers often requires external setup.
\  line# #ega-columns *  column# +  wbsplit  h# e crt!  h# f crt!
;
1A38A24 	58 46 A0  1 
: ega-erase-screen  ( -- )
1A38A28 	 0  0  0 65 67 61 2D 65 
1A38A30 	72 61 73 65 2D 73 63 72 
1A38A38 	65 65 6E 90  0 8A A3  1 
1A38A40 	20 40 A0  1 
   #chars attributes fill-attrs  #chars bl fill-text
1A38A44 	 0 87 A3  1 
1A38A48 	2C 87 A3  1 48 88 A3  1 
1A38A50 	 0 87 A3  1 28 70 A0  1 
1A38A58 	FC 87 A3  1 
;
1A38A5C 	58 46 A0  1 
: ega-invert-screen  ( -- )
1A38A60 	 0  0 65 67 61 2D 69 6E 
1A38A68 	76 65 72 74 2D 73 63 72 
1A38A70 	65 65 6E 91 40 8A A3  1 
1A38A78 	20 40 A0  1 
   ega /ega  bounds  do  i 1+  c@  flop  i 1+ c!  2 +loop
1A38A7C 	E4 87 A3  1 
1A38A80 	14 87 A3  1 F0 6D A0  1 
1A38A88 	88 42 A0  1 2C  0  0  0 
1A38A90 	B4 42 A0  1 30 4B A0  1 
1A38A98 	C4 4C A0  1 9C 89 A3  1 
1A38AA0 	B4 42 A0  1 30 4B A0  1 
1A38AA8 	B8 4D A0  1 90 6F A0  1 
1A38AB0 	1C 42 A0  1 DC FF FF FF 
;
1A38AB8 	58 46 A0  1 
: ega-blink-screen  ( -- )  ega-invert-screen  d# 100 ms  ega-invert-screen  ;
1A38ABC 	 0  0  0 65 
1A38AC0 	67 61 2D 62 6C 69 6E 6B 
1A38AC8 	2D 73 63 72 65 65 6E 90 
1A38AD0 	78 8A A3  1 20 40 A0  1 
1A38AD8 	78 8A A3  1 58 41 A0  1 
1A38AE0 	64  0  0  0 60 E0 A1  1 
1A38AE8 	78 8A A3  1 58 46 A0  1 

: ega-bytes/line  ( -- n )  #ega-columns 2*  ;
1A38AF0 	 0 65 67 61 2D 62 79 74 
1A38AF8 	65 73 2F 6C 69 6E 65 8E 
1A38B00 	D4 8A A3  1 20 40 A0  1 
1A38B08 	D4 86 A3  1 A0 4B A0  1 
1A38B10 	58 46 A0  1 
: blank-chars  ( adr #chars -- )
1A38B14 	62 6C 61 6E 
1A38B18 	6B 2D 63 68 61 72 73 8B 
1A38B20 	 4 8B A3  1 20 40 A0  1 
   2*  bounds  ?do  bl i c!  attributes i 1+ c!  2 +loop
1A38B28 	A0 4B A0  1 F0 6D A0  1 
1A38B30 	50 42 A0  1 2C  0  0  0 
1A38B38 	28 70 A0  1 B4 42 A0  1 
1A38B40 	B8 4D A0  1 2C 87 A3  1 
1A38B48 	B4 42 A0  1 30 4B A0  1 
1A38B50 	B8 4D A0  1 90 6F A0  1 
1A38B58 	1C 42 A0  1 DC FF FF FF 
;
1A38B60 	58 46 A0  1 
: ega-erase-lines  ( last-line-adr first-line-adr -- )
1A38B64 	65 67 61 2D 
1A38B68 	65 72 61 73 65 2D 6C 69 
1A38B70 	6E 65 73 8F 24 8B A3  1 
1A38B78 	20 40 A0  1 
   ?do   i  #ega-columns blank-chars  ega-bytes/line +loop
1A38B7C 	50 42 A0  1 
1A38B80 	1C  0  0  0 B4 42 A0  1 
1A38B88 	D4 86 A3  1 24 8B A3  1 
1A38B90 	 4 8B A3  1 1C 42 A0  1 
1A38B98 	EC FF FF FF 
;
1A38B9C 	58 46 A0  1 
: ega-cursor-y  ( -- line-adr )  line# ega-line-adr  ;
1A38BA0 	 0  0  0 65 67 61 2D 63 
1A38BA8 	75 72 73 6F 72 2D 79 8C 
1A38BB0 	78 8B A3  1 20 40 A0  1 
1A38BB8 	54 86 A2  1 D0 88 A3  1 
1A38BC0 	58 46 A0  1 
: ega-window-bottom  ( -- line-adr )  #lines ega-line-adr  ;
1A38BC4 	 0  0 65 67 
1A38BC8 	61 2D 77 69 6E 64 6F 77 
1A38BD0 	2D 62 6F 74 74 6F 6D 91 
1A38BD8 	B4 8B A3  1 20 40 A0  1 
1A38BE0 	 4 87 A2  1 D0 88 A3  1 
1A38BE8 	58 46 A0  1 
: ega-break-low   ( delta-#lines -- line-adr )
1A38BEC 	 0  0 65 67 
1A38BF0 	61 2D 62 72 65 61 6B 2D 
1A38BF8 	6C 6F 77 8D DC 8B A3  1 
1A38C00 	20 40 A0  1 
   line# +  #lines min  ega-line-adr
1A38C04 	54 86 A2  1 
1A38C08 	 4 45 A0  1  4 87 A2  1 
1A38C10 	74 4A A0  1 D0 88 A3  1 
;
1A38C18 	58 46 A0  1 
: ega-break-high  ( delta-#lines -- line-adr )
1A38C1C 	 0 65 67 61 
1A38C20 	2D 62 72 65 61 6B 2D 68 
1A38C28 	69 67 68 8E  0 8C A3  1 
1A38C30 	20 40 A0  1 
   #lines swap -  0 max  ega-line-adr
1A38C34 	 4 87 A2  1 
1A38C38 	68 49 A0  1 18 45 A0  1 
1A38C40 	70 6F A0  1 9C 4A A0  1 
1A38C48 	D0 88 A3  1 
;
1A38C4C 	58 46 A0  1 
: ega-delete-lines  ( delta-#lines -- )
1A38C50 	 0  0  0 65 67 61 2D 64 
1A38C58 	65 6C 65 74 65 2D 6C 69 
1A38C60 	6E 65 73 90 30 8C A3  1 
1A38C68 	20 40 A0  1 
   dup ega-break-high swap ega-break-low  ( break-high break-low )
1A38C6C 	40 49 A0  1 
1A38C70 	30 8C A3  1 68 49 A0  1 
1A38C78 	 0 8C A3  1 
   ega-cursor-y  over ega-window-bottom swap -  ( b-hi b-lo curs-y bottom-blo )
1A38C7C 	B4 8B A3  1 
1A38C80 	54 49 A0  1 DC 8B A3  1 
1A38C88 	68 49 A0  1 18 45 A0  1 
   move                                   ( break-high )
1A38C90 	F4 4A A0  1 
   ega-window-bottom swap  ega-erase-lines
1A38C94 	DC 8B A3  1 
1A38C98 	68 49 A0  1 78 8B A3  1 
;
1A38CA0 	58 46 A0  1 

: ega-insert-lines  ( delta-#lines -- )
1A38CA4 	 0  0  0 65 
1A38CA8 	67 61 2D 69 6E 73 65 72 
1A38CB0 	74 2D 6C 69 6E 65 73 90 
1A38CB8 	68 8C A3  1 20 40 A0  1 
   ega-break-high  ega-window-bottom   ( break-line-adr bottom-line-adr )
1A38CC0 	30 8C A3  1 DC 8B A3  1 
   swap ega-bytes/line -               ( bottom break-high- )
1A38CC8 	68 49 A0  1  4 8B A3  1 
1A38CD0 	18 45 A0  1 
   ega-cursor-y   swap                 ( bottom  cursor-y break-high- )
1A38CD4 	B4 8B A3  1 
1A38CD8 	68 49 A0  1 
   2dup <  if                          ( bottom  cursor-y break-high- )
1A38CDC 	C0 49 A0  1 
1A38CE0 	E4 47 A0  1 DC 41 A0  1 
1A38CE8 	40  0  0  0 
      do                                          ( bottom' )
1A38CEC 	88 42 A0  1 
1A38CF0 	30  0  0  0 
         ega-bytes/line -  i over  ega-bytes/line 2*  move   ( bottom- )
1A38CF4 	 4 8B A3  1 
1A38CF8 	18 45 A0  1 B4 42 A0  1 
1A38D00 	54 49 A0  1  4 8B A3  1 
1A38D08 	A0 4B A0  1 F4 4A A0  1 
      ega-bytes/line negate +loop      ( break-low-adr )
1A38D10 	 4 8B A3  1 48 45 A0  1 
1A38D18 	1C 42 A0  1 D8 FF FF FF 
   else                                ( bottom  cursor-y break-high- )
1A38D20 	C8 41 A0  1  8  0  0  0 
      2drop                            ( break-low-adr )
1A38D28 	AC 49 A0  1 
   then                                ( break-low-adr )
   ega-cursor-y  ega-erase-lines
1A38D2C 	B4 8B A3  1 
1A38D30 	78 8B A3  1 
;
1A38D34 	58 46 A0  1 
: ega-move-chars  ( source-col# dest-col# -- )
1A38D38 	 0 65 67 61 2D 6D 6F 76 
1A38D40 	65 2D 63 68 61 72 73 8E 
1A38D48 	BC 8C A3  1 20 40 A0  1 
   2dup max  #columns swap -                 ( src-col# dst-col# #chars )
1A38D50 	C0 49 A0  1 9C 4A A0  1 
1A38D58 	1C 87 A2  1 68 49 A0  1 
1A38D60 	18 45 A0  1 
   2* -rot                                   ( #bytes src-col# dst-col# )
1A38D64 	A0 4B A0  1 
1A38D68 	94 49 A0  1 
   swap ega-column-adr  swap ega-column-adr  ( #bytes src-adr dst-adr )
1A38D6C 	68 49 A0  1 
1A38D70 	F8 88 A3  1 68 49 A0  1 
1A38D78 	F8 88 A3  1 
   rot move
1A38D7C 	7C 49 A0  1 
1A38D80 	F4 4A A0  1 
;
1A38D84 	58 46 A0  1 
: ega-erase-chars  ( #chars start-col# -- )
1A38D88 	65 67 61 2D 65 72 61 73 
1A38D90 	65 2D 63 68 61 72 73 8F 
1A38D98 	4C 8D A3  1 20 40 A0  1 
   ega-column-adr  swap  blank-chars
1A38DA0 	F8 88 A3  1 68 49 A0  1 
1A38DA8 	24 8B A3  1 
;
1A38DAC 	58 46 A0  1 
: ega-insert-characters  ( n -- )
1A38DB0 	 0  0 65 67 61 2D 69 6E 
1A38DB8 	73 65 72 74 2D 63 68 61 
1A38DC0 	72 61 63 74 65 72 73 95 
1A38DC8 	9C 8D A3  1 20 40 A0  1 
   #columns column# - min  dup
1A38DD0 	1C 87 A2  1 40 86 A2  1 
1A38DD8 	18 45 A0  1 74 4A A0  1 
1A38DE0 	40 49 A0  1 
   column# +   column# swap     ( #chars' cursor-col# cursor+count-col# )
1A38DE4 	40 86 A2  1 
1A38DE8 	 4 45 A0  1 40 86 A2  1 
1A38DF0 	68 49 A0  1 
   ega-move-chars  ( #chars' )  column#  ega-erase-chars
1A38DF4 	4C 8D A3  1 
1A38DF8 	40 86 A2  1 9C 8D A3  1 
;
1A38E00 	58 46 A0  1 
: ega-delete-characters  ( #chars -- )
1A38E04 	 0  0 65 67 
1A38E08 	61 2D 64 65 6C 65 74 65 
1A38E10 	2D 63 68 61 72 61 63 74 
1A38E18 	65 72 73 95 CC 8D A3  1 
1A38E20 	20 40 A0  1 
   #columns column# - min  dup  ( #chars' #chars' )
1A38E24 	1C 87 A2  1 
1A38E28 	40 86 A2  1 18 45 A0  1 
1A38E30 	74 4A A0  1 40 49 A0  1 
   column# +  column#           ( #chars' cursor+count-col#  cursor-col# )
1A38E38 	40 86 A2  1  4 45 A0  1 
1A38E40 	40 86 A2  1 
   ega-move-chars  ( #chars' )  #columns over -  ega-erase-chars
1A38E44 	4C 8D A3  1 
1A38E48 	1C 87 A2  1 54 49 A0  1 
1A38E50 	18 45 A0  1 9C 8D A3  1 
;
1A38E58 	58 46 A0  1 

: ega-draw-logo  ( line# addr width height -- )  2drop 2drop  ;
1A38E5C 	 0  0 65 67 
1A38E60 	61 2D 64 72 61 77 2D 6C 
1A38E68 	6F 67 6F 8D 20 8E A3  1 
1A38E70 	20 40 A0  1 AC 49 A0  1 
1A38E78 	AC 49 A0  1 58 46 A0  1 

: ega-install  ( -- )
1A38E80 	65 67 61 2D 69 6E 73 74 
1A38E88 	61 6C 6C 8B 70 8E A3  1 
1A38E90 	20 40 A0  1 
   h# b8000 /ega  " map-in" $call-parent  to ega
1A38E94 	58 41 A0  1 
1A38E98 	 0 80  B  0 14 87 A3  1 
1A38EA0 	9C 53 A0  1  6 6D 61 70 
1A38EA8 	2D 69 6E  0 DC 31 A2  1 
1A38EB0 	B8 40 A0  1 E4 87 A3  1 

   set-attributes
1A38EB8 	B0 87 A3  1 

\ Accessing the hardware cursor is a lot of trouble.
\ There are two things that can go wrong:
\ 1) The I/O space enable can be off in the display's PCI config register
\ 2) The CRT registers can be locked
\   d# 0 h# a crt!  d# 15 h# b crt!   \ Block cursor

   #ega-columns to #columns  #ega-lines to #lines
1A38EBC 	D4 86 A3  1 
1A38EC0 	48 B8 A1  1 1C 87 A2  1 
1A38EC8 	EC 86 A3  1 48 B8 A1  1 
1A38ED0 	 4 87 A2  1 
   
   true to 16-color?
1A38ED4 	 4 70 A0  1 
1A38ED8 	48 B8 A1  1 14 8A A2  1 

   ['] ega-reset-screen   	is reset-screen
1A38EE0 	60 53 A0  1 88 89 A3  1 
1A38EE8 	48 B8 A1  1 8C 88 A2  1 
   ['] ega-toggle-cursor	is toggle-cursor
1A38EF0 	60 53 A0  1  0 8A A3  1 
1A38EF8 	48 B8 A1  1 C4 88 A2  1 
   ['] ega-erase-screen	        is erase-screen
1A38F00 	60 53 A0  1 40 8A A3  1 
1A38F08 	48 B8 A1  1 A8 88 A2  1 
   ['] ega-blink-screen	        is blink-screen
1A38F10 	60 53 A0  1 D4 8A A3  1 
1A38F18 	48 B8 A1  1 54 88 A2  1 
   ['] ega-invert-screen	is invert-screen
1A38F20 	60 53 A0  1 78 8A A3  1 
1A38F28 	48 B8 A1  1 70 88 A2  1 
   ['] ega-insert-characters	is insert-characters
1A38F30 	60 53 A0  1 CC 8D A3  1 
1A38F38 	48 B8 A1  1 E0 87 A2  1 
   ['] ega-delete-characters	is delete-characters
1A38F40 	60 53 A0  1 20 8E A3  1 
1A38F48 	48 B8 A1  1  0 88 A2  1 
   ['] ega-insert-lines	        is insert-lines
1A38F50 	60 53 A0  1 BC 8C A3  1 
1A38F58 	48 B8 A1  1 1C 88 A2  1 
   ['] ega-delete-lines         is delete-lines
1A38F60 	60 53 A0  1 68 8C A3  1 
1A38F68 	48 B8 A1  1 38 88 A2  1 
   ['] ega-draw-character	is draw-character
1A38F70 	60 53 A0  1 48 89 A3  1 
1A38F78 	48 B8 A1  1 C0 87 A2  1 
   ['] ega-draw-logo		is draw-logo
1A38F80 	60 53 A0  1 70 8E A3  1 
1A38F88 	48 B8 A1  1 DC 88 A2  1 
;
1A38F90 	58 46 A0  1 
: ega-remove  ( -- )
1A38F94 	 0 65 67 61 
1A38F98 	2D 72 65 6D 6F 76 65 8A 
1A38FA0 	90 8E A3  1 20 40 A0  1 
   ega /ega  " map-out" $call-parent
1A38FA8 	E4 87 A3  1 14 87 A3  1 
1A38FB0 	9C 53 A0  1  7 6D 61 70 
1A38FB8 	2D 6F 75 74  0  0  0  0 
1A38FC0 	DC 31 A2  1 
;
1A38FC4 	58 46 A0  1 

: ega-selftest  ( -- failed? )  false  ;
1A38FC8 	 0  0  0 65 67 61 2D 73 
1A38FD0 	65 6C 66 74 65 73 74 8C 
1A38FD8 	A4 8F A3  1 20 40 A0  1 
1A38FE0 	18 70 A0  1 58 46 A0  1 

headers

: probe  ( -- )
1A38FE8 	 0  0 70 72 6F 62 65 85 
1A38FF0 	DC 8F A3  1 20 40 A0  1 
   ['] ega-install  is-install
1A38FF8 	60 53 A0  1 90 8E A3  1 
1A39000 	AC A2 A2  1 
   ['] ega-remove   is-remove
1A39004 	60 53 A0  1 
1A39008 	A4 8F A3  1 40 A3 A2  1 
   ['] ega-selftest is-selftest
1A39010 	60 53 A0  1 DC 8F A3  1 
1A39018 	80 A3 A2  1 
;
1A3901C 	58 46 A0  1 
probe
1A39020 	69 6E 73 74 61 6C 6C A7 
1A39028 	F4 8F A3  1 90 8E A3  1 
1A39030 	 0  0  0 6F 70 65 6E A4 
1A39038 	2C 90 A3  1 8C A0 A2  1 
1A39040 	 0  0 77 72 69 74 65 A5 
1A39048 	3C 90 A3  1 38 A1 A2  1 
1A39050 	 0  0 64 72 61 77 2D 6C 
1A39058 	6F 67 6F A9 4C 90 A3  1 
1A39060 	DC 88 A2  1 72 65 73 74 
1A39068 	6F 72 65 A7 60 90 A3  1 
1A39070 	8C 88 A2  1  0 72 65 6D 
1A39078 	6F 76 65 A6 70 90 A3  1 
1A39080 	A4 8F A3  1  0  0 63 6C 
1A39088 	6F 73 65 A5 80 90 A3  1 
1A39090 	18 A0 A2  1  0  0 64 69 
1A39098 	73 70 2D 74 65 73 74 A9 
1A390A0 	90 90 A3  1 DC 8F A3  1 
1A390A8 	 0  0  0 73 65 6C 66 74 
1A390B0 	65 73 74 A8 A4 90 A3  1 
1A390B8 	B4 9F A2  1 

\ end-package
\ 
\ devalias screen /ega-text

OpenFirmware/dev/egatext.fth_AL	A64 1A390BC 
99D3CE4   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99D3CF4   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................purpose: Set the ISA node's PCI configuration address

\ Find the ISA bridge and set the isa node's reg property to the
\ PCI device number of the actual hardware
: move-isa  ( -- )
1A390F0 	 0  0  0 6D 6F 76 65 2D 
1A390F8 	69 73 61 88 24 86 A3  1 
1A39100 	20 40 A0  1 
   d# 32  0  do
1A39104 	58 41 A0  1 
1A39108 	20  0  0  0 70 6F A0  1 
1A39110 	88 42 A0  1 A0  0  0  0 
      \ Look for a PCI header with the ISA bus class code
      i h# 800 *  8 +  config-l@  8 rshift  h# 60100  =  if
1A39118 	B4 42 A0  1 58 41 A0  1 
1A39120 	 0  8  0  0 1C 5F A0  1 
1A39128 	F0 6F A0  1  4 45 A0  1 
1A39130 	44 38 A3  1 F0 6F A0  1 
1A39138 	B4 44 A0  1 58 41 A0  1 
1A39140 	 0  1  6  0 24 48 A0  1 
1A39148 	DC 41 A0  1 60  0  0  0 
         \ Patch the "reg" property in the ISA node to that config address
         " /pci/isa" find-package  if
1A39150 	9C 53 A0  1  8 2F 70 63 
1A39158 	69 2F 69 73 61  0  0  0 
1A39160 	E0 39 A2  1 DC 41 A0  1 
1A39168 	40  0  0  0 
            " reg" rot get-package-property  0=  if  ( adr len )
1A3916C 	9C 53 A0  1 
1A39170 	 3 72 65 67  0  0  0  0 
1A39178 	7C 49 A0  1 98 33 A2  1 
1A39180 	24 47 A0  1 DC 41 A0  1 
1A39188 	20  0  0  0 
               drop  i h# 800 *  swap be-l!
1A3918C 	30 49 A0  1 
1A39190 	B4 42 A0  1 58 41 A0  1 
1A39198 	 0  8  0  0 1C 5F A0  1 
1A391A0 	68 49 A0  1 8C FC A0  1 
            then
         then
         leave
1A391A8 	18 43 A0  1 
      then
   loop
1A391AC 	F8 41 A0  1 
1A391B0 	68 FF FF FF 
;
1A391B4 	58 46 A0  1 
stand-init:
1A391B8 	 0 73 74 61 6E 64 2D 69 
1A391C0 	6E 69 74 8A  0 91 A3  1 
1A391C8 	20 40 A0  1 20 84 A3  1 
   move-isa
1A391D0 	 0 91 A3  1 
;
1A391D4 	58 46 A0  1 

OpenFirmware/cpu/x86/pc/moveisa.fth_AL	E8 1A391D8 
begin-package
select-dev=</pci>0 0 5D8F85 1 

propset=1A391EC B44266E 1A00B70 
vocset=B44266E 1A00B70 1A391EC 
new-node=B442682 1A00B50 
vocset=B442682 1A00B50 1A391EC 0 0 5D8F85 1 

set-args0=1 5D8F85 0 0 
begin-package;
isa
1A391FC 1A3921C 1A39240 1A39260 1A39288 1A392AC 1A392F4 1A3931C 
0 0  " 0"  " /pci" begin-package
1A391D8 	E0 B6 A0  1 30  B  0  0 
1A391E0 	D4 39 A3  1 E0 B6 A0  1 
1A391E8 	50  B  0  0 

hex
current-device-t to isa-device
" isa" device-name
1A391EC 	69 73 61  0 
1A391F0 	 0  0  0 6E 61 6D 65 84 
1A391F8 	 0  0 A0  1 BC 13 A2  1 
1A39200 	14  0  0  0  4  0  0  0 
" isa" device-type
1A39208 	69 73 61  0 64 65 76 69 
1A39210 	63 65 5F 74 79 70 65 8B 
1A39218 	FC 91 A3  1 BC 13 A2  1 
1A39220 	18  0  0  0  4  0  0  0 

2 " #address-cells" integer-property
1A39228 	 0  0  0  2  0 23 61 64 
1A39230 	64 72 65 73 73 2D 63 65 
1A39238 	6C 6C 73 8E 1C 92 A3  1 
1A39240 	BC 13 A2  1 1C  0  0  0 
1A39248 	 4  0  0  0 
1 " #size-cells" integer-property
1A3924C 	 0  0  0  1 
1A39250 	23 73 69 7A 65 2D 63 65 
1A39258 	6C 6C 73 8B 40 92 A3  1 
1A39260 	BC 13 A2  1 18  0  0  0 
1A39268 	 4  0  0  0 
my-address my-space
 encode-phys
1A3926C 	 0  0  0  0 
1A39270 	 0  0  0  0  0  0  0  0 
  0 encode-int encode+
1A39278 	 0  0  0  0 
  h# 0 encode-int encode+
1A3927C 	 0  0  0  0 
" reg" property
1A39280 	72 65 67 83 60 92 A3  1 
1A39288 	BC 13 A2  1 20  0  0  0 
1A39290 	14  0  0  0 

d# 8300000 encode-int  " clock-frequency" property \ mmo
1A39294 	 0 7E A5 E0 
1A39298 	63 6C 6F 63 6B 2D 66 72 
1A392A0 	65 71 75 65 6E 63 79 8F 
1A392A8 	88 92 A3  1 BC 13 A2  1 
1A392B0 	1C  0  0  0  4  0  0  0 

\ 16-MByte ISA memory space
        0 encode-int         0 encode-int encode+
1A392B8 	 0  0  0  0  0  0  0  0 
02000000 encode-int encode+ 0 encode-int encode+ 0 encode-int encode+
1A392C0 	 2  0  0  0  0  0  0  0 
1A392C8 	 0  0  0  0 
 1000000 encode-int encode+
1A392CC 	 1  0  0  0 

\ 64-KByte ISA I/O space
        1 encode-int encode+ 0 encode-int encode+
1A392D0 	 0  0  0  1  0  0  0  0 
01000000 encode-int encode+ 0 encode-int encode+ 0 encode-int encode+
1A392D8 	 1  0  0  0  0  0  0  0 
1A392E0 	 0  0  0  0 
   10000 encode-int encode+
1A392E4 	 0  1  0  0 

   " ranges" property
1A392E8 	 0 72 61 6E 67 65 73 86 
1A392F0 	AC 92 A3  1 BC 13 A2  1 
1A392F8 	40  0  0  0 30  0  0  0 

2 " #interrupt-cells" integer-property
1A39300 	 0  0  0  2  0  0  0 23 
1A39308 	69 6E 74 65 72 72 75 70 
1A39310 	74 2D 63 65 6C 6C 73 90 
1A39318 	F4 92 A3  1 BC 13 A2  1 
1A39320 	20  0  0  0  4  0  0  0 

internal
h# 1000 constant /io-map
1A39328 	2F 69 6F 2D 6D 61 70 87 
1A39330 	 0  0 A0  1 68 40 A0  1 
1A39338 	 0 10  0  0 

external
\ Static methods
\ Text representation:  nnn (I/O space)  innn (I/O space)  mnnn (memory space)
\ Numeric representation:  hi cell: 0-memory 1-I/O  lo cell: offset

: decode-unit  ( adr len -- phys.lo phys.hi )
1A3933C 	64 65 63 6F 
1A39340 	64 65 2D 75 6E 69 74 8B 
1A39348 	34 93 A3  1 20 40 A0  1 
   base @ >r hex
1A39350 	B8 75 A0  1 5C 4C A0  1 
1A39358 	BC 45 A0  1 C0 8D A0  1 
   dup  if
1A39360 	40 49 A0  1 DC 41 A0  1 
1A39368 	84  0  0  0 
      over c@  upc  case
1A3936C 	54 49 A0  1 
1A39370 	C4 4C A0  1 D0 51 A0  1 
         ascii I  of  1 /string   1    endof
1A39378 	58 41 A0  1 49  0  0  0 
1A39380 	48 43 A0  1 18  0  0  0 
1A39388 	80 6F A0  1 3C 85 A0  1 
1A39390 	80 6F A0  1 6C 43 A0  1 
1A39398 	34  0  0  0 
         ascii M  of  1 /string   0    endof
1A3939C 	58 41 A0  1 
1A393A0 	4D  0  0  0 48 43 A0  1 
1A393A8 	18  0  0  0 80 6F A0  1 
1A393B0 	3C 85 A0  1 70 6F A0  1 
1A393B8 	6C 43 A0  1 10  0  0  0 
         ( default )  1 swap			\ Default to "IO"
1A393C0 	80 6F A0  1 68 49 A0  1 
      endcase                               ( adr len phys.hi )
1A393C8 	84 43 A0  1 
      -rot  $number  if  0  then   swap     ( phys.lo phys.lo )
1A393CC 	94 49 A0  1 
1A393D0 	40 FE A0  1 DC 41 A0  1 
1A393D8 	 8  0  0  0 70 6F A0  1 
1A393E0 	68 49 A0  1 
   else
1A393E4 	C8 41 A0  1 
1A393E8 	10  0  0  0 
      2drop 0 0
1A393EC 	AC 49 A0  1 
1A393F0 	70 6F A0  1 70 6F A0  1 
   then
   r> base !
1A393F8 	D0 45 A0  1 B8 75 A0  1 
1A39400 	54 4D A0  1 
;
1A39404 	58 46 A0  1 
: encode-unit  ( phys.lo phys.hi -- adr len )
1A39408 	65 6E 63 6F 64 65 2D 75 
1A39410 	6E 69 74 8B 4C 93 A3  1 
1A39418 	20 40 A0  1 
   base @ >r hex
1A3941C 	B8 75 A0  1 
1A39420 	5C 4C A0  1 BC 45 A0  1 
1A39428 	C0 8D A0  1 
   >r  <# u# u#s
1A3942C 	BC 45 A0  1 
1A39430 	 8 76 A0  1 94 76 A0  1 
1A39438 	BC 76 A0  1 
   r>  1 and  if  ascii i  else  ascii m  then  hold
1A3943C 	D0 45 A0  1 
1A39440 	80 6F A0  1 5C 44 A0  1 
1A39448 	DC 41 A0  1 14  0  0  0 
1A39450 	58 41 A0  1 69  0  0  0 
1A39458 	C8 41 A0  1  C  0  0  0 
1A39460 	58 41 A0  1 6D  0  0  0 
1A39468 	DC 75 A0  1 
   u#>
1A3946C 	E0 76 A0  1 
   r> base !
1A39470 	D0 45 A0  1 B8 75 A0  1 
1A39478 	54 4D A0  1 
;
1A3947C 	58 46 A0  1 

\ Not-necessarily-static methods
: open  ( -- true )  true  ;
1A39480 	 0  0  0 6F 70 65 6E 84 
1A39488 	18 94 A3  1 20 40 A0  1 
1A39490 	 4 70 A0  1 58 46 A0  1 
: close  ( -- )  ;
1A39498 	 0  0 63 6C 6F 73 65 85 
1A394A0 	8C 94 A3  1 20 40 A0  1 
1A394A8 	58 46 A0  1 

: map-in   ( phys.lo phys.hi size -- virt )
1A394AC 	 0 6D 61 70 
1A394B0 	2D 69 6E 86 A4 94 A3  1 
1A394B8 	20 40 A0  1 
   \ The 8000.0000 bit indicates a non-relocatable PCI address
   >r  if                           ( phys.lo )         ( r: size )
1A394BC 	BC 45 A0  1 
1A394C0 	DC 41 A0  1 48  0  0  0 
      \ If the range to be mapped is in the pre-mapped region,
      \  return an address within that region
      dup r@ +  /io-map u<  if      ( phys.lo )         ( r: size )
1A394C8 	40 49 A0  1 E4 45 A0  1 
1A394D0 	 4 45 A0  1 34 93 A3  1 
1A394D8 	A8 48 A0  1 DC 41 A0  1 
1A394E0 	18  0  0  0 
         r> drop  io-base +         ( virt )
1A394E4 	D0 45 A0  1 
1A394E8 	30 49 A0  1 B4 37 A3  1 
1A394F0 	 4 45 A0  1 
         exit
1A394F4 	40 46 A0  1 
      then                          ( phys.lo )         ( r: size )
      0 h# 8100.0000                ( phys.lo,mid,hi )  ( r: size )
1A394F8 	70 6F A0  1 58 41 A0  1 
1A39500 	 0  0  0 81 
   else                             ( phys.lo )         ( r: size )
1A39504 	C8 41 A0  1 
1A39508 	10  0  0  0 
      0 h# 8200.0000                ( phys.lo,mid,hi )  ( r: size )
1A3950C 	70 6F A0  1 
1A39510 	58 41 A0  1  0  0  0 82 
   then                             ( phys.lo,mid,hi )  ( r: size )
   r> " map-in" $call-parent
1A39518 	D0 45 A0  1 9C 53 A0  1 
1A39520 	 6 6D 61 70 2D 69 6E  0 
1A39528 	DC 31 A2  1 
;
1A3952C 	58 46 A0  1 
: map-out  ( virt size -- )
1A39530 	6D 61 70 2D 6F 75 74 87 
1A39538 	B8 94 A3  1 20 40 A0  1 
  \ Don't unmap the pre-mapped I/O region
  over  io-base u>=  if         ( virt size )
1A39540 	54 49 A0  1 B4 37 A3  1 
1A39548 	CC 48 A0  1 DC 41 A0  1 
1A39550 	20  0  0  0 
     dup /io-map u<  if
1A39554 	40 49 A0  1 
1A39558 	34 93 A3  1 A8 48 A0  1 
1A39560 	DC 41 A0  1  C  0  0  0 
        2drop exit
1A39568 	AC 49 A0  1 40 46 A0  1 
     then
  then                           ( virt size )
  " map-out" $call-parent
1A39570 	9C 53 A0  1  7 6D 61 70 
1A39578 	2D 6F 75 74  0  0  0  0 
1A39580 	DC 31 A2  1 
;
1A39584 	58 46 A0  1 

: dma-map-in  ( vaddr len cacheable -- devaddr )  " dma-map-in" $call-parent  ;
1A39588 	 0 64 6D 61 2D 6D 61 70 
1A39590 	2D 69 6E 8A 3C 95 A3  1 
1A39598 	20 40 A0  1 9C 53 A0  1 
1A395A0 	 A 64 6D 61 2D 6D 61 70 
1A395A8 	2D 69 6E  0 DC 31 A2  1 
1A395B0 	58 46 A0  1 
: dma-map-out  ( vaddr devaddr len -- )  " dma-map-out" $call-parent  ;
1A395B4 	64 6D 61 2D 
1A395B8 	6D 61 70 2D 6F 75 74 8B 
1A395C0 	98 95 A3  1 20 40 A0  1 
1A395C8 	9C 53 A0  1  B 64 6D 61 
1A395D0 	2D 6D 61 70 2D 6F 75 74 
1A395D8 	 0  0  0  0 DC 31 A2  1 
1A395E0 	58 46 A0  1 
: dma-alloc  ( size -- vadr )  " dma-alloc" $call-parent  ;
1A395E4 	 0  0 64 6D 
1A395E8 	61 2D 61 6C 6C 6F 63 89 
1A395F0 	C4 95 A3  1 20 40 A0  1 
1A395F8 	9C 53 A0  1  9 64 6D 61 
1A39600 	2D 61 6C 6C 6F 63  0  0 
1A39608 	DC 31 A2  1 58 46 A0  1 
: dma-free ( vaddr len -- )  " dma-free" $call-parent  ;
1A39610 	 0  0  0 64 6D 61 2D 66 
1A39618 	72 65 65 88 F4 95 A3  1 
1A39620 	20 40 A0  1 9C 53 A0  1 
1A39628 	 8 64 6D 61 2D 66 72 65 
1A39630 	65  0  0  0 DC 31 A2  1 
1A39638 	58 46 A0  1 

\ XXX Should we define methods for allocating ISA DMA channels?

: probe-self  ( arg$ reg$ fcode$ -- )
1A3963C 	 0 70 72 6F 
1A39640 	62 65 2D 73 65 6C 66 8A 
1A39648 	20 96 A3  1 20 40 A0  1 
   true abort" probe-self for ISA is not yet implemented"  ( XXX )
1A39650 	 4 70 A0  1  8 81 A0  1 
1A39658 	29 70 72 6F 62 65 2D 73 
1A39660 	65 6C 66 20 66 6F 72 20 
1A39668 	49 53 41 20 69 73 20 6E 
1A39670 	6F 74 20 79 65 74 20 69 
1A39678 	6D 70 6C 65 6D 65 6E 74 
1A39680 	65 64  0  0 
;
1A39684 	58 46 A0  1 

internal
false value already-done?
1A39688 	 0  0 61 6C 72 65 61 64 
1A39690 	79 2D 64 6F 6E 65 3F 8D 
1A39698 	4C 96 A3  1 50 40 A0  1 
1A396A0 	54  B  0  0 

external
\ Pre-map I/O space to avoid lots of redundant mappings
: init  ( -- )
1A396A4 	 0  0  0 69 
1A396A8 	6E 69 74 84 9C 96 A3  1 
1A396B0 	20 40 A0  1 

   \ The following flag is necesary to prevent multiple inits of device
   \ in case the init routine is called twice (as when the device containing
   \ the ISA node is in the PCI probe list).

   already-done?  if  exit  then
1A396B4 	9C 96 A3  1 
1A396B8 	DC 41 A0  1  8  0  0  0 
1A396C0 	40 46 A0  1 

   true to already-done?
1A396C4 	 4 70 A0  1 
1A396C8 	B8 40 A0  1 9C 96 A3  1 

[ifdef] unmap-temp-io
   io-base >r
   0 0 h# 8100.0000  /io-map  " map-in" $call-parent  to io-base
   r> unmap-temp-io
[then]

   h# ff  h# 21 pc!	\ Mask off all interrupts
1A396D0 	58 41 A0  1 FF  0  0  0 
1A396D8 	58 41 A0  1 21  0  0  0 
1A396E0 	E8 81 A2  1 

\ mmo   " /isa/interrupt-controller" find-package  if
\ mmo      " interrupt-parent" integer-property
\ mmo    then
;
1A396E4 	58 46 A0  1 


OpenFirmware/dev/pci/isa.fth_AL	510 1A396E8 
propset=1A396FC B4426F5 1A00B98 
vocset=B4426F5 1A00B98 1A396FC 
new-node=B442709 1A00B78 
vocset=B442709 1A00B78 1A396FC 
set-args0=2 5D9086 0 0 
dma-controller
1A39714 1A39740 1A39770 1A397E4 
99D5604   20 00 00 00  00 00 00 00  00 00 00 00  01 00 00 00  ...............
99D5614   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
new-device   0 0  " i0"  set-args   
1A396E8 	E0 B6 A0  1 58  B  0  0 
1A396F0 	D8 91 A3  1 E0 B6 A0  1 
1A396F8 	78  B  0  0 
   " dma-controller" device-name
1A396FC 	64 6D 61 2D 
1A39700 	63 6F 6E 74 72 6F 6C 6C 
1A39708 	65 72  0 6E 61 6D 65 84 
1A39710 	 0  0 A0  1 BC 13 A2  1 
1A39718 	1C  0  0  0  F  0  0  0 
   " dma-controller" device-type
1A39720 	64 6D 61 2D 63 6F 6E 74 
1A39728 	72 6F 6C 6C 65 72  0  0 
1A39730 	64 65 76 69 63 65 5F 74 
1A39738 	79 70 65 8B 14 97 A3  1 
1A39740 	BC 13 A2  1 24  0  0  0 
1A39748 	 F  0  0  0 

0 0 encode-bytes
[ifndef] basic-isa
   " chrp,dma"   encode-string encode+
1A3974C 	63 68 72 70 
1A39750 	2C 64 6D 61  0 
[then]
   " pnpPNP,200" encode-string encode+
1A39755 	70 6E 70 
1A39758 	50 4E 50 2C 32 30 30  0 
" compatible" property
1A39760 	 0 63 6F 6D 70 61 74 69 
1A39768 	62 6C 65 8A 40 97 A3  1 
1A39770 	BC 13 A2  1 28  0  0  0 
1A39778 	14  0  0  0 

     0 1 10 encode-reg
1A3977C 	 0  0  0  1 
1A39780 	 0  0  0  0  0  0  0 10 
    80 1 20 encode-reg encode+
1A39788 	 0  0  0  1  0  0  0 80 
1A39790 	 0  0  0 20 
    c0 1 20 encode-reg encode+
1A39794 	 0  0  0  1 
1A39798 	 0  0  0 C0  0  0  0 20 
[ifdef] isa-dma-only
   481 1  f encode-reg encode+          \ High page registers
[else]
[ifdef] PREP    
   40a 1  2 encode-reg encode+		\ AIX wants this
[else]
   40a 1  1 encode-reg encode+		\ MacOS wants this
1A397A0 	 0  0  0  1  0  0  4  A 
1A397A8 	 0  0  0  1 
   40b 1  1 encode-reg encode+
1A397AC 	 0  0  0  1 
1A397B0 	 0  0  4  B  0  0  0  1 
[then]   
   410 1 30 encode-reg encode+
1A397B8 	 0  0  0  1  0  0  4 10 
1A397C0 	 0  0  0 30 
   481 1  b encode-reg encode+
1A397C4 	 0  0  0  1 
1A397C8 	 0  0  4 81  0  0  0  B 
   4d6 1  1 encode-reg encode+
1A397D0 	 0  0  0  1  0  0  4 D6 
1A397D8 	 0  0  0  1 
[then]
   " reg" property
1A397DC 	72 65 67 83 
1A397E0 	70 97 A3  1 BC 13 A2  1 
1A397E8 	6C  0  0  0 60  0  0  0 

   internal
   create dma-init-table
1A397F0 	 0 64 6D 61 2D 69 6E 69 
1A397F8 	74 2D 74 61 62 6C 65 8E 
1A39800 	 0  0 A0  1 30 40 A0  1 
   \ data    register
   h# 00 c,  h# 0d c,		\ DMA1 master clear
1A39808 	 0  D 
   h# 00 c,  h# da c,		\ DMA2 master clear
1A3980A 	 0 DA 
   h# 04 c,  h# 08 c,		\ Disable 0-3 group
1A3980C 	 4  8 
   h# 04 c,  h# d0 c,		\ Disable 4-7 group
1A3980E 	 4 D0 
   h# 0f c,  h# 0f c,		\ Mask off channels 0-3
1A39810 	 F  F 
   h# 0f c,  h# de c,		\ Mask off channels 4-7
1A39812 	 F DE 
   h# c0 c,  h# d6 c,		\ Put channel 4 in cascade mode
1A39814 	C0 D6 
   h# 00 c,  h# d4 c,		\ Unmask channel 4 (cascade for chs. 0-3)
1A39816 	 0 D4 
   h# 00 c,  h# 08 c,		\ Enable 0-3 group
1A39818 	 0  8 
   h# 00 c,  h# d0 c,		\ Enable 4-7 group
1A3981A 	 0 D0 
   h# ff c,  h# ff c,		\ End of table
1A3981C 	FF FF 

   external
   : init  ( -- )
1A3981E 	 0 69 
1A39820 	6E 69 74 84  4 98 A3  1 
1A39828 	20 40 A0  1 
      dma-init-table  begin              ( adr )
1A3982C 	 4 98 A3  1 
         dup ca1+ c@ dup h# ff <>        ( adr reg flag )
1A39830 	40 49 A0  1 78 50 A0  1 
1A39838 	C4 4C A0  1 40 49 A0  1 
1A39840 	58 41 A0  1 FF  0  0  0 
1A39848 	44 48 A0  1 
      while                              ( adr reg )
1A3984C 	DC 41 A0  1 
1A39850 	20  0  0  0 
         over c@ swap pc!                ( adr )
1A39854 	54 49 A0  1 
1A39858 	C4 4C A0  1 68 49 A0  1 
1A39860 	E8 81 A2  1 
         wa1+                            ( adr' )
1A39864 	A0 50 A0  1 
      repeat                             ( adr reg )
1A39868 	C8 41 A0  1 C4 FF FF FF 
      2drop
1A39870 	AC 49 A0  1 
      4 0  do  i h# 40b pc!  loop	\ Put channels 0-3 in byte mode
1A39874 	B0 6F A0  1 
1A39878 	70 6F A0  1 88 42 A0  1 
1A39880 	1C  0  0  0 B4 42 A0  1 
1A39888 	58 41 A0  1  B  4  0  0 
1A39890 	E8 81 A2  1 F8 41 A0  1 
1A39898 	EC FF FF FF 
      8 5  do  i h# 4d6 pc!  loop	\ Put channels 5-7 in word mode
1A3989C 	F0 6F A0  1 
1A398A0 	C0 6F A0  1 88 42 A0  1 
1A398A8 	1C  0  0  0 B4 42 A0  1 
1A398B0 	58 41 A0  1 D6  4  0  0 
1A398B8 	E8 81 A2  1 F8 41 A0  1 
1A398C0 	EC FF FF FF 
      \ The preceding depends on the fact that the word-mode bit is the
      \ bit masked by 4, and the low 2 bits of the register are the channel
      \ number mod 4.  Conveniently, the numbers 5,6,7 are the correct values
      \ to put channels 5,6,7 into word mode.  Admittedly, it is a dubious
      \ coding practice to depend on such a coincidence, but the architecture
      \ of the ISA DMA controller is so cast-in-stone that this code is very
      \ unlikely ever to break.
   ;
1A398C4 	58 46 A0  1 
[ifdef] tokenizing  init  [then]

finish-device
1A398C8 	20  0  0  0  0  0  0  0 
1A398D0 	 0  0  0  0  1  0  0  0 
1A398D8 	 0  0  0  0  0  0  0  0 

\eof mmo

new-device  0 0  " i20"  set-args
   0 0 encode-bytes  " interrupt-controller" property

[ifdef] PREP
   2 encode-int  d encode-int encode+  " interrupts" property
[else]   

[ifndef] basic-isa
   \ This defines the way the ISA PIC feeds into the parent (CHRP
   \ Open PIC) interrupt controller.
   0 encode-int  0 encode-int encode+  " interrupts" property
[then]

   2  " #interrupt-cells"  integer-property
[then]

   \ "#address-cells" is used by interrupt-resolution code, which needs
   \ to know how many unit-address cells to prepend to the interrupt token.
   0 encode-int  " #address-cells" property

OpenFirmware/dev/pci/i8259.fth_AL	1F8 1A398E0 
propset=1A398F4 B44274A 1A00BBC 
vocset=B44274A 1A00BBC 1A398F4 
new-node=B44275E 1A00B9C 
vocset=B44275E 1A00B9C 1A398F4 
set-args0=3 5D8F85 0 0 
timer
1A39904 1A39928 1A39950 1A3997C 1A399A0 
new-device  0 0  " i40" set-args
1A398E0 	E0 B6 A0  1 7C  B  0  0 
1A398E8 	D8 91 A3  1 E0 B6 A0  1 
1A398F0 	9C  B  0  0 
   " timer" device-name
1A398F4 	74 69 6D 65 
1A398F8 	72  0  0 6E 61 6D 65 84 
1A39900 	 0  0 A0  1 BC 13 A2  1 
1A39908 	14  0  0  0  6  0  0  0 
   " timer" device-type
1A39910 	74 69 6D 65 72  0  0  0 
1A39918 	64 65 76 69 63 65 5F 74 
1A39920 	79 70 65 8B  4 99 A3  1 
1A39928 	BC 13 A2  1 1C  0  0  0 
1A39930 	 6  0  0  0 

   " pnpPNP,100" " compatible" string-property
1A39934 	70 6E 70 50 
1A39938 	4E 50 2C 31 30 30  0  0 
1A39940 	 0 63 6F 6D 70 61 74 69 
1A39948 	62 6C 65 8A 28 99 A3  1 
1A39950 	BC 13 A2  1 20  0  0  0 
1A39958 	 B  0  0  0 

   40 1 4 encode-reg  61 1 1 encode-reg encode+  " reg" property
1A3995C 	 0  0  0  1 
1A39960 	 0  0  0 40  0  0  0  4 
1A39968 	 0  0  0  1  0  0  0 61 
1A39970 	 0  0  0  1 72 65 67 83 
1A39978 	50 99 A3  1 BC 13 A2  1 
1A39980 	24  0  0  0 18  0  0  0 
[ifdef] PREP
   0 encode-int  " interrupts" property
[else]   
   0 encode-int  3 encode-int encode+  " interrupts"  property
1A39988 	 0  0  0  0  0  0  0  3 
1A39990 	 0 69 6E 74 65 72 72 75 
1A39998 	70 74 73 8A 7C 99 A3  1 
1A399A0 	BC 13 A2  1 1C  0  0  0 
1A399A8 	 8  0  0  0 
[then]

OpenFirmware/dev/pci/i8254.fth_AL	CC 1A399AC purpose: Driver for Intel 8254 Programmable Interval Timer chip

\ The parallel port register at (hex) 61 in PC I/O space controls the GATE
\ input on timer 2, enables/disables timer 2's output to the speaker, and
\ lets you read back the state of the timer 2 OUT bit.

internal
h# 40 constant timer0
1A399AC 	 0 74 69 6D 
1A399B0 	65 72 30 86  0  0 A0  1 
1A399B8 	68 40 A0  1 40  0  0  0 
\ h# 41 constant timer1
\ h# 42 constant timer2
h# 43 constant timer-ctl
1A399C0 	 0  0 74 69 6D 65 72 2D 
1A399C8 	63 74 6C 89 B8 99 A3  1 
1A399D0 	68 40 A0  1 43  0  0  0 

\ Values for r/w field
0 constant latch
1A399D8 	 0  0 6C 61 74 63 68 85 
1A399E0 	D0 99 A3  1 68 40 A0  1 
1A399E8 	 0  0  0  0 
1 constant lsb
1A399EC 	6C 73 62 83 
1A399F0 	E4 99 A3  1 68 40 A0  1 
1A399F8 	 1  0  0  0 
2 constant msb
1A399FC 	6D 73 62 83 
1A39A00 	F4 99 A3  1 68 40 A0  1 
1A39A08 	 2  0  0  0 
3 constant lsb,msb
1A39A0C 	6C 73 62 2C 
1A39A10 	6D 73 62 87  4 9A A3  1 
1A39A18 	68 40 A0  1  3  0  0  0 

\ Modes
\ 0 - interrupt on count = 0
\ 1 - one-shot
\ 2 - rate generator  ( OUT goes high for one clock when count=0, reload count)
\ 3 - square wave     ( period = initial count, duty cycle = .5 )
\ 4 - software triggered strobe  ( OUT pulses low when count = 0, no reload)
\ 4 - hardware triggered strobe  ( OUT pulses low when count = 0, no reload)

: timer@  ( timer# -- byte )  timer0 + pc@  ;
1A39A20 	 0 74 69 6D 65 72 40 86 
1A39A28 	18 9A A3  1 20 40 A0  1 
1A39A30 	B8 99 A3  1  4 45 A0  1 
1A39A38 	AC 81 A2  1 58 46 A0  1 
: timer!  ( byte timer# -- )  timer0 + pc!  ;
1A39A40 	 0 74 69 6D 65 72 21 86 
1A39A48 	2C 9A A3  1 20 40 A0  1 
1A39A50 	B8 99 A3  1  4 45 A0  1 
1A39A58 	E8 81 A2  1 58 46 A0  1 

: latch-counter  ( timer# -- )  3 and 6 <<  timer-ctl pc!  ;
1A39A60 	 0  0 6C 61 74 63 68 2D 
1A39A68 	63 6F 75 6E 74 65 72 8D 
1A39A70 	4C 9A A3  1 20 40 A0  1 
1A39A78 	A0 6F A0  1 5C 44 A0  1 
1A39A80 	D0 6F A0  1 C8 44 A0  1 
1A39A88 	D0 99 A3  1 E8 81 A2  1 
1A39A90 	58 46 A0  1 

\ The timer-ctl register looks like:
\ TTRR.MMMB
\ TT  is timer# (0-2)
\ RR  is the r/w field, with values as given above
\ MMM is the mode field, with values as given above
\ B   is 0 for binary, 1 for BCD

: set-mode  ( r/w mode bcd? timer# -- )
1A39A94 	 0  0  0 73 
1A39A98 	65 74 2D 6D 6F 64 65 88 
1A39AA0 	74 9A A3  1 20 40 A0  1 
   3 and 6 <<  swap 1 and or  swap 7 and 1 << or  swap 3 and 4 << or
1A39AA8 	A0 6F A0  1 5C 44 A0  1 
1A39AB0 	D0 6F A0  1 C8 44 A0  1 
1A39AB8 	68 49 A0  1 80 6F A0  1 
1A39AC0 	5C 44 A0  1 70 44 A0  1 
1A39AC8 	68 49 A0  1 E0 6F A0  1 
1A39AD0 	5C 44 A0  1 80 6F A0  1 
1A39AD8 	C8 44 A0  1 70 44 A0  1 
1A39AE0 	68 49 A0  1 A0 6F A0  1 
1A39AE8 	5C 44 A0  1 B0 6F A0  1 
1A39AF0 	C8 44 A0  1 70 44 A0  1 
   timer-ctl pc!
1A39AF8 	D0 99 A3  1 E8 81 A2  1 
;
1A39B00 	58 46 A0  1 

[ifdef] not-used
: read-back  ( count? status? timer-mask -- )
   7 and 1 <<                     ( count? status? bits )
   swap  0=  if  h# 10 or  then   ( count? bits )
   swap  0=  if  h# 20 or  then   ( bits )
   h# c0 or  timer-ctl pc!
;

: get-status  ( timer# -- r/w mode bcd out stopped? )
   >r  false true  1 r@ <<  read-back   r> timer@  ( status )
   dup  4 >> 3 and  swap           ( r/w status )
   dup  1 >> 7 and  swap           ( r/w mode status )
   dup       1 and  swap           ( r/w mode bcd status )
   dup  7 >> 1 and  swap           ( r/w mode bcd out status )
        6 >> 1 and                 ( r/w mode bcd out stopped? )
;
[then]
external
: count@  ( timer# -- count )
1A39B04 	 0 63 6F 75 
1A39B08 	6E 74 40 86 A4 9A A3  1 
1A39B10 	20 40 A0  1 
   dup latch-counter  dup timer@  swap timer@ bwjoin
1A39B14 	40 49 A0  1 
1A39B18 	74 9A A3  1 40 49 A0  1 
1A39B20 	2C 9A A3  1 68 49 A0  1 
1A39B28 	2C 9A A3  1 84 FB A0  1 
;
1A39B30 	58 46 A0  1 
: count!  ( count mode timer# -- )
1A39B34 	 0 63 6F 75 
1A39B38 	6E 74 21 86 10 9B A3  1 
1A39B40 	20 40 A0  1 
   >r  lsb,msb swap false r@ set-mode   ( count )
1A39B44 	BC 45 A0  1 
1A39B48 	18 9A A3  1 68 49 A0  1 
1A39B50 	18 70 A0  1 E4 45 A0  1 
1A39B58 	A4 9A A3  1 
   wbsplit swap r@ timer!  r> timer!
1A39B5C 	54 FB A0  1 
1A39B60 	68 49 A0  1 E4 45 A0  1 
1A39B68 	4C 9A A3  1 D0 45 A0  1 
1A39B70 	4C 9A A3  1 
;
1A39B74 	58 46 A0  1 

\ PC speaker control; the GATE bit in the register at I/O address 0x61
\ is connected to the GATE2 input of the 8254 timer.

\ 01 bit enables counting
\ 02 bit enables output to speaker
\ 20 bit reads back speaker OUT line

: speaker!  ( xxxx|EIC|ERP|SPK|T2G -- )  h# 61 pc!  ;
1A39B78 	 0  0  0 73 70 65 61 6B 
1A39B80 	65 72 21 88 40 9B A3  1 
1A39B88 	20 40 A0  1 58 41 A0  1 
1A39B90 	61  0  0  0 E8 81 A2  1 
1A39B98 	58 46 A0  1 
: speaker@  ( -- PCK|CHKIO|T2O|RFD|EIC|ERP|SPK|T2G )   h# 61 pc@  ;
1A39B9C 	 0  0  0 73 
1A39BA0 	70 65 61 6B 65 72 40 88 
1A39BA8 	88 9B A3  1 20 40 A0  1 
1A39BB0 	58 41 A0  1 61  0  0  0 
1A39BB8 	AC 81 A2  1 58 46 A0  1 

: tone  ( hz msecs -- )
1A39BC0 	 0  0  0 74 6F 6E 65 84 
1A39BC8 	AC 9B A3  1 20 40 A0  1 
   d# 1193180 rot /  3 2 count!  3 speaker!  ( msecs )
1A39BD0 	58 41 A0  1 DC 34 12  0 
1A39BD8 	7C 49 A0  1 98 5F A0  1 
1A39BE0 	A0 6F A0  1 90 6F A0  1 
1A39BE8 	40 9B A3  1 A0 6F A0  1 
1A39BF0 	88 9B A3  1 
   ms
1A39BF4 	60 E0 A1  1 
   0 speaker!
1A39BF8 	70 6F A0  1 88 9B A3  1 
;
1A39C00 	58 46 A0  1 

\ To set the tick timer
: set-tick-limit  ( #ms -- )
1A39C04 	 0 73 65 74 
1A39C08 	2D 74 69 63 6B 2D 6C 69 
1A39C10 	6D 69 74 8E CC 9B A3  1 
1A39C18 	20 40 A0  1 
   d# 10000000 * d# 8381 /  h# ffff min  2 0 count!
1A39C1C 	58 41 A0  1 
1A39C20 	80 96 98  0 1C 5F A0  1 
1A39C28 	58 41 A0  1 BD 20  0  0 
1A39C30 	98 5F A0  1 58 41 A0  1 
1A39C38 	FF FF  0  0 74 4A A0  1 
1A39C40 	90 6F A0  1 70 6F A0  1 
1A39C48 	40 9B A3  1 
;
1A39C4C 	58 46 A0  1 

\ XXX we really should map the registers
: open  ( -- flag? )  true  ;
1A39C50 	 0  0  0 6F 70 65 6E 84 
1A39C58 	18 9C A3  1 20 40 A0  1 
1A39C60 	 4 70 A0  1 58 46 A0  1 
: close  ( -- )  ;
1A39C68 	 0  0 63 6C 6F 73 65 85 
1A39C70 	5C 9C A3  1 20 40 A0  1 
1A39C78 	58 46 A0  1 

: ring-bell  ( -- )
1A39C7C 	 0  0 72 69 
1A39C80 	6E 67 2D 62 65 6C 6C 89 
1A39C88 	74 9C A3  1 20 40 A0  1 
   open  drop
1A39C90 	5C 9C A3  1 30 49 A0  1 
   d# 2000  d# 100  tone
1A39C98 	58 41 A0  1 D0  7  0  0 
1A39CA0 	58 41 A0  1 64  0  0  0 
1A39CA8 	CC 9B A3  1 
   close
1A39CAC 	74 9C A3  1 
;
1A39CB0 	58 46 A0  1 

: init  ( -- )
1A39CB4 	 0  0  0 69 
1A39CB8 	6E 69 74 84 8C 9C A3  1 
1A39CC0 	20 40 A0  1 
   0 2 0 count!		\ Enable counter0 to free-run in pulse output mode
1A39CC4 	70 6F A0  1 
1A39CC8 	90 6F A0  1 70 6F A0  1 
1A39CD0 	40 9B A3  1 
;
1A39CD4 	58 46 A0  1 
[ifdef] tokenizing  init  [then]

OpenFirmware/dev/i8254.fth_AL	32C 1A39CD8 
99D6294   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99D62A4   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................[ifndef] tokenizing
also forth definitions
warning @  warning off
: beep  ( -- )  " /isa/timer" " ring-bell" execute-device-method drop  ;
1A39CF0 	 0  0  0 62 65 65 70 84 
1A39CF8 	C8 91 A3  1 20 40 A0  1 
1A39D00 	9C 53 A0  1  A 2F 69 73 
1A39D08 	61 2F 74 69 6D 65 72  0 
1A39D10 	9C 53 A0  1  9 72 69 6E 
1A39D18 	67 2D 62 65 6C 6C  0  0 
1A39D20 	84 3F A2  1 30 49 A0  1 
1A39D28 	58 46 A0  1 
warning !

stand-init: ISA
1A39D2C 	 0 73 74 61 
1A39D30 	6E 64 2D 69 6E 69 74 8A 
1A39D38 	FC 9C A3  1 20 40 A0  1 
1A39D40 	C8 91 A3  1 9C 53 A0  1 
1A39D48 	 3 49 53 41  0  0  0  0 
1A39D50 	80 6D A0  1  4 6C A0  1 
   " /isa"                 " init"  execute-device-method drop
1A39D58 	9C 53 A0  1  4 2F 69 73 
1A39D60 	61  0  0  0 9C 53 A0  1 
1A39D68 	 4 69 6E 69 74  0  0  0 
1A39D70 	84 3F A2  1 30 49 A0  1 
\ mmo   " /isa/interrupt-controller"  " init"  execute-device-method drop
   " /isa/timer"           " init"  execute-device-method drop
1A39D78 	9C 53 A0  1  A 2F 69 73 
1A39D80 	61 2F 74 69 6D 65 72  0 
1A39D88 	9C 53 A0  1  4 69 6E 69 
1A39D90 	74  0  0  0 84 3F A2  1 
1A39D98 	30 49 A0  1 
   " /isa/dma-controller"  " init"  execute-device-method drop
1A39D9C 	9C 53 A0  1 
1A39DA0 	13 2F 69 73 61 2F 64 6D 
1A39DA8 	61 2D 63 6F 6E 74 72 6F 
1A39DB0 	6C 6C 65 72  0  0  0  0 
1A39DB8 	9C 53 A0  1  4 69 6E 69 
1A39DC0 	74  0  0  0 84 3F A2  1 
1A39DC8 	30 49 A0  1 
;
1A39DCC 	58 46 A0  1 
previous definitions
[then]

OpenFirmware/dev/pci/isamisc.fth_AL	E0 1A39DD0 purpose: Use ISA 8254 timer 0 or the RTC as the tick timer

: tick-interrupt  ( level -- )
1A39DD0 	 0 74 69 63 6B 2D 69 6E 
1A39DD8 	74 65 72 72 75 70 74 8E 
1A39DE0 	C0 9C A3  1 20 40 A0  1 
   drop
1A39DE8 	30 49 A0  1 
[ifdef] level-interrupts
   " which-interrupt"  clock-node @  $call-method  drop  \ Clear the interrupt
[then]
   tick-msecs ms/tick +  to tick-msecs
1A39DEC 	B0 85 A3  1 
1A39DF0 	38 E0 A1  1  4 45 A0  1 
1A39DF8 	B8 40 A0  1 B0 85 A3  1 
\ mmo   ?call-os
   check-alarm
1A39E00 	 8 73 A2  1 
;
1A39E04 	58 46 A0  1 

\eof mmo

\ If we are using the 8259 interrupt controller in level-triggered mode,
\ we must use the RTC instead of the ISA counter/timer to generate the tick
\ interrupt, because the interrupt output from the ISA timer is a square
\ wave with no provision for making it go away immediately after servicing it.

\ Unfortunately, the granularity of the RTC interrupt leaves something to
\ be desired.  You can set its interrupt period to power-of-two multiples
\ of 1/8192 seconds (approximately 122 usecs), resulting in periods like
\ 1.95 ms, 3.9 ms, 7.8 ms, 15.6 ms ...

[ifdef] level-interrupts
: (set-tick-limit)  ( #msecs -- )
   d# 1000 *                                      ( target-usecs/tick )
   " set-tick-usecs"  clock-node @  $call-method  ( actual-usecs/tick )
   d# 500 +  d# 1000 /  to ms/tick                ( )
   ['] tick-interrupt 8 interrupt-handler!
   8 enable-interrupt
;
\ This is a workaround for a bug in JavaOS; it apparently expects
\ the firmware to set the mode and period of ISA timer 0.
stand-init: ISA Timer
   d# 10 " /isa/timer" " set-tick-limit" execute-device-method drop
;
[else]
: (set-tick-limit)  ( #msecs -- )
   to ms/tick
   ms/tick " /isa/timer" " set-tick-limit" execute-device-method drop
   ['] tick-interrupt 0 interrupt-handler!
   0 enable-interrupt
;
[then]
\ mmo  ' (set-tick-limit) to set-tick-limit

OpenFirmware/cpu/x86/pc/isatick.fth_AL	38 1A39E08 
propset=1A39E1C B4427D5 1A00BE0 
vocset=B4427D5 1A00BE0 1A39E1C 
new-node=B4427E9 1A00BC0 
vocset=B4427E9 1A00BC0 1A39E1C 1A39E2C 
99D6F24   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99D6F34   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99D6F44   00 00 00 00  00 00 00 00  00 00 00 00  FC 25 78 55 ............n%xU
99D6F54   00 00 00 00  00 00 00 00  FF FF FF FF  00 00 00 00 ............support-package: 16550
1A39E08 	E0 B6 A0  1 A0  B  0  0 
1A39E10 	C8 50 A2  1 E0 B6 A0  1 
1A39E18 	C0  B  0  0 31 36 35 35 
1A39E20 	30  0  0 6E 61 6D 65 84 
1A39E28 	 0  0 A0  1 BC 13 A2  1 
1A39E30 	14  0  0  0  6  0  0  0 

: clock-frequency  ( -- n )
1A39E38 	63 6C 6F 63 6B 2D 66 72 
1A39E40 	65 71 75 65 6E 63 79 8F 
1A39E48 	 0  0 A0  1 20 40 A0  1 
   " clock-frequency"  my-parent ihandle>phandle  get-package-property  if
1A39E50 	9C 53 A0  1  F 63 6C 6F 
1A39E58 	63 6B 2D 66 72 65 71 75 
1A39E60 	65 6E 63 79  0  0  0  0 
1A39E68 	28  4 A2  1  0 32 A2  1 
1A39E70 	98 33 A2  1 DC 41 A0  1 
1A39E78 	14  0  0  0 
      d# 1843200
1A39E7C 	58 41 A0  1 
1A39E80 	 0 20 1C  0 
   else                ( adr len )
1A39E84 	C8 41 A0  1 
1A39E88 	 8  0  0  0 
      get-encoded-int
1A39E8C 	A0 F7 A1  1 
   then
;
1A39E90 	58 46 A0  1 

0 instance value uart-base	\ Virtual address of UART; set later
1A39E94 	 0  0 75 61 
1A39E98 	72 74 2D 62 61 73 65 89 
1A39EA0 	4C 9E A3  1 C0 FE A1  1 
1A39EA8 	18  0  0  0 

: uart-base-adr  ( -- adr )
1A39EAC 	 0  0 75 61 
1A39EB0 	72 74 2D 62 61 73 65 2D 
1A39EB8 	61 64 72 8D A4 9E A3  1 
1A39EC0 	20 40 A0  1 
   uart-base
1A39EC4 	A4 9E A3  1 
\ The following code is a PowerPC-specific hack that 
\ handles the case where memory mapping is turned off
\ (in which case the 0x30 bit in MSR is 0).  Note that
\ the PowerPC msr@ is not compatible with the x86 msr@.
\ [ifdef] msr@
\   msr@ h# 30 and 0=  if  h# fff and io-base +  then
\ [then]
;
1A39EC8 	58 46 A0  1 
: uart@  ( reg# -- byte )  uart-base-adr +  rb@  ; \ Read from a UART register
1A39ECC 	 0  0 75 61 
1A39ED0 	72 74 40 85 C0 9E A3  1 
1A39ED8 	20 40 A0  1 C0 9E A3  1 
1A39EE0 	 4 45 A0  1 A8 B1 A2  1 
1A39EE8 	58 46 A0  1 
: uart!  ( byte reg# -- )  uart-base-adr +  rb!  ; \ Write to a UART register
1A39EEC 	 0  0 75 61 
1A39EF0 	72 74 21 85 D8 9E A3  1 
1A39EF8 	20 40 A0  1 C0 9E A3  1 
1A39F00 	 4 45 A0  1 1C B2 A2  1 
1A39F08 	58 46 A0  1 

\ Integer division which rounds to nearest instead of truncating
: rounded-/  ( dividend divisor -- rounded-result )
1A39F0C 	 0  0 72 6F 
1A39F10 	75 6E 64 65 64 2D 2F 89 
1A39F18 	F8 9E A3  1 20 40 A0  1 
   swap 2*  swap /  ( result*2 )
1A39F20 	68 49 A0  1 A0 4B A0  1 
1A39F28 	68 49 A0  1 98 5F A0  1 
   dup 1 and +      \ add 1 to the result if it is odd
1A39F30 	40 49 A0  1 80 6F A0  1 
1A39F38 	5C 44 A0  1  4 45 A0  1 
   2/               ( rounded-result )
1A39F40 	78 4B A0  1 
;
1A39F44 	58 46 A0  1 
: baud-to-divisor  ( baud-rate -- divisor )
1A39F48 	62 61 75 64 2D 74 6F 2D 
1A39F50 	64 69 76 69 73 6F 72 8F 
1A39F58 	1C 9F A3  1 20 40 A0  1 
   clock-frequency d# 16 /  swap rounded-/    ( baud-rate-divisor )
1A39F60 	4C 9E A3  1 58 41 A0  1 
1A39F68 	10  0  0  0 98 5F A0  1 
1A39F70 	68 49 A0  1 1C 9F A3  1 
;
1A39F78 	58 46 A0  1 
: divisor-to-baud  ( divisor -- baud-rate )
1A39F7C 	64 69 76 69 
1A39F80 	73 6F 72 2D 74 6F 2D 62 
1A39F88 	61 75 64 8F 5C 9F A3  1 
1A39F90 	20 40 A0  1 
   clock-frequency d# 16 /  swap rounded-/    ( baud-rate-divisor )
1A39F94 	4C 9E A3  1 
1A39F98 	58 41 A0  1 10  0  0  0 
1A39FA0 	98 5F A0  1 68 49 A0  1 
1A39FA8 	1C 9F A3  1 
;
1A39FAC 	58 46 A0  1 

\ The break-detect bit in the line status register is cleared when you
\ read the line status register, not when you read the garbage character
\ that accompanies the break through the FIFO.  Consequently, we must
\ check the break detect bit every time that we read the line status
\ register, using break? to remember that we saw it.
0 instance value break?
1A39FB0 	 0 62 72 65 61 6B 3F 86 
1A39FB8 	90 9F A3  1 C0 FE A1  1 
1A39FC0 	1C  0  0  0 
: (line-stat@)  ( -- n )  5 uart@  ;
1A39FC4 	 0  0  0 28 
1A39FC8 	6C 69 6E 65 2D 73 74 61 
1A39FD0 	74 40 29 8C BC 9F A3  1 
1A39FD8 	20 40 A0  1 C0 6F A0  1 
1A39FE0 	D8 9E A3  1 58 46 A0  1 
: line-stat@  ( -- n )
1A39FE8 	 0 6C 69 6E 65 2D 73 74 
1A39FF0 	61 74 40 8A D8 9F A3  1 
1A39FF8 	20 40 A0  1 
   (line-stat@)  dup h# 10 and  if  " set-break" $call-parent  then
1A39FFC 	D8 9F A3  1 
1A3A000 	40 49 A0  1 58 41 A0  1 
1A3A008 	10  0  0  0 5C 44 A0  1 
1A3A010 	DC 41 A0  1 18  0  0  0 
1A3A018 	9C 53 A0  1  9 73 65 74 
1A3A020 	2D 62 72 65 61 6B  0  0 
1A3A028 	DC 31 A2  1 
;
1A3A02C 	58 46 A0  1 

: get-divisor  ( -- divisor )
1A3A030 	67 65 74 2D 64 69 76 69 
1A3A038 	73 6F 72 8B F8 9F A3  1 
1A3A040 	20 40 A0  1 
   3 uart@  dup >r  h# 80 or  3 uart!		\ divisor latch access bit on
1A3A044 	A0 6F A0  1 
1A3A048 	D8 9E A3  1 40 49 A0  1 
1A3A050 	BC 45 A0  1 58 41 A0  1 
1A3A058 	80  0  0  0 70 44 A0  1 
1A3A060 	A0 6F A0  1 F8 9E A3  1 
   0 uart@  1 uart@  bwjoin	( divisor )	\ Read lsb and msb
1A3A068 	70 6F A0  1 D8 9E A3  1 
1A3A070 	80 6F A0  1 D8 9E A3  1 
1A3A078 	84 FB A0  1 
   r> 3 uart!					\ Restore old state
1A3A07C 	D0 45 A0  1 
1A3A080 	A0 6F A0  1 F8 9E A3  1 
;
1A3A088 	58 46 A0  1 
: set-divisor  ( divisor -- )
1A3A08C 	73 65 74 2D 
1A3A090 	64 69 76 69 73 6F 72 8B 
1A3A098 	40 A0 A3  1 20 40 A0  1 
   \ If the divisor is 0, then this is first access after power on.  We
   \ can safely plow on with out checking the transmitter status
   get-divisor  if
1A3A0A0 	40 A0 A3  1 DC 41 A0  1 
1A3A0A8 	1C  0  0  0 
      begin  line-stat@ h# 40 and  until	\ Wait until transmit done
1A3A0AC 	F8 9F A3  1 
1A3A0B0 	58 41 A0  1 40  0  0  0 
1A3A0B8 	5C 44 A0  1 DC 41 A0  1 
1A3A0C0 	EC FF FF FF 
   then

   3 uart@  dup >r  h# 80 or  3 uart!		\ divisor latch access bit on
1A3A0C4 	A0 6F A0  1 
1A3A0C8 	D8 9E A3  1 40 49 A0  1 
1A3A0D0 	BC 45 A0  1 58 41 A0  1 
1A3A0D8 	80  0  0  0 70 44 A0  1 
1A3A0E0 	A0 6F A0  1 F8 9E A3  1 
   wbsplit swap  0 uart!  1 uart!		\ Write lsb and msb
1A3A0E8 	54 FB A0  1 68 49 A0  1 
1A3A0F0 	70 6F A0  1 F8 9E A3  1 
1A3A0F8 	80 6F A0  1 F8 9E A3  1 
   r> 3 uart!					\ Restore old state
1A3A100 	D0 45 A0  1 A0 6F A0  1 
1A3A108 	F8 9E A3  1 
;
1A3A10C 	58 46 A0  1 
: baud  ( baud-rate -- )  baud-to-divisor set-divisor  ;
1A3A110 	 0  0  0 62 61 75 64 84 
1A3A118 	9C A0 A3  1 20 40 A0  1 
1A3A120 	5C 9F A3  1 9C A0 A3  1 
1A3A128 	58 46 A0  1 

\ Parses the arguments to the serial port driver, which are in the
\ form, e.g. 9600,8,n,1 , and sets the UART parameters (baudrate,
\ # data bits, parity, #stop bits, handshake) accordingly.
\
\ Fields are (in order, left to right):
\         <baud rate>, <data bits>, <parity>, <stop bits>, <handshake>
\ Fields with empty values are not changed.
\ Values for fields are whatever the hardware will support:
\ baud rates: various,including  110, 300, 1200, 2400, 4800, 9600, 19200, 38400
\ character bits: 5,6,7,8
\
\ parity:
\         char   means
\         --------------------
\         n       none
\         e       even
\         o       odd
\         m       mark
\         s       space
\
\ stop bits:
\         char    means
\         --------------------
\         1       1 stop bit
\         .       1.5 stop bits
\         2       2 stop bits
\
\ handshake:
\         char    means
\         --------------------
\         -       none
\         h       hardware (rts/cts)	\ Not supported
\         s       software (xon/xoff)   \ Not supported
\
\ The default mode is 9600,8,n,1,-
\

hex
headerless

0 instance value divisor
1A3A12C 	64 69 76 69 
1A3A130 	73 6F 72 87 1C A1 A3  1 
1A3A138 	C0 FE A1  1 20  0  0  0 
0 instance value mode
1A3A140 	 0  0  0 6D 6F 64 65 84 
1A3A148 	38 A1 A3  1 C0 FE A1  1 
1A3A150 	24  0  0  0 

: .uart-error  ( -- )
1A3A154 	2E 75 61 72 
1A3A158 	74 2D 65 72 72 6F 72 8B 
1A3A160 	4C A1 A3  1 20 40 A0  1 
   ."  error in tty mode."  cr
1A3A168 	20 7C A0  1 13 20 65 72 
1A3A170 	72 6F 72 20 69 6E 20 74 
1A3A178 	74 79 20 6D 6F 64 65 2E 
1A3A180 	 0  0  0  0 80 6D A0  1 
   -1 throw
1A3A188 	58 41 A0  1 FF FF FF FF 
1A3A190 	74 7F A0  1 
;
1A3A194 	58 46 A0  1 

0 instance value current-baudrate
1A3A198 	 0  0  0 63 75 72 72 65 
1A3A1A0 	6E 74 2D 62 61 75 64 72 
1A3A1A8 	61 74 65 90 64 A1 A3  1 
1A3A1B0 	C0 FE A1  1 28  0  0  0 
: set-baudrate  ( adr len -- )
1A3A1B8 	 0  0  0 73 65 74 2D 62 
1A3A1C0 	61 75 64 72 61 74 65 8C 
1A3A1C8 	B0 A1 A3  1 20 40 A0  1 
   dup  if
1A3A1D0 	40 49 A0  1 DC 41 A0  1 
1A3A1D8 	48  0  0  0 
      base @ >r  decimal  $number  r> base !  if
1A3A1DC 	B8 75 A0  1 
1A3A1E0 	5C 4C A0  1 BC 45 A0  1 
1A3A1E8 	E4 8D A0  1 40 FE A0  1 
1A3A1F0 	D0 45 A0  1 B8 75 A0  1 
1A3A1F8 	54 4D A0  1 DC 41 A0  1 
1A3A200 	18  0  0  0 
         ." Baud rate" .uart-error
1A3A204 	20 7C A0  1 
1A3A208 	 9 42 61 75 64 20 72 61 
1A3A210 	74 65  0  0 64 A1 A3  1 
      then
   else
1A3A218 	C8 41 A0  1  C  0  0  0 
      2drop  current-baudrate
1A3A220 	AC 49 A0  1 B0 A1 A3  1 
   then
   baud-to-divisor to divisor
1A3A228 	5C 9F A3  1 48 B8 A1  1 
1A3A230 	38 A1 A3  1 
;
1A3A234 	58 46 A0  1 


[ifndef] c@+
: c@+  ( adr -- adr+ char )  dup 1+ swap c@  ;  \ In the kernel
[then]

: do-table  ( adr len table-adr -- )
1A3A238 	 0  0  0 64 6F 2D 74 61 
1A3A240 	62 6C 65 88 CC A1 A3  1 
1A3A248 	20 40 A0  1 
   over 0=  if  3drop exit  then          ( adr len table-adr )
1A3A24C 	54 49 A0  1 
1A3A250 	24 47 A0  1 DC 41 A0  1 
1A3A258 	 C  0  0  0 90 52 A0  1 
1A3A260 	40 46 A0  1 
   over 1 u>  if                          ( adr len table-adr )
1A3A264 	54 49 A0  1 
1A3A268 	80 6F A0  1 64 48 A0  1 
1A3A270 	DC 41 A0  1 38  0  0  0 
      drop
1A3A278 	30 49 A0  1 
      ascii " emit  type  ascii " emit
1A3A27C 	58 41 A0  1 
1A3A280 	22  0  0  0 2C 6C A0  1 
1A3A288 	 4 6C A0  1 58 41 A0  1 
1A3A290 	22  0  0  0 2C 6C A0  1 
      ." : syntax" .uart-error
1A3A298 	20 7C A0  1  8 3A 20 73 
1A3A2A0 	79 6E 74 61 78  0  0  0 
1A3A2A8 	64 A1 A3  1 
   then                                   ( adr len table-adr )
   nip                                    ( adr table-adr )
1A3A2AC 	FC 46 A0  1 
   c@+ invert                             ( adr table-adr' mask )
1A3A2B0 	 8 52 A0  1 30 45 A0  1 
   mode  and  to mode                     ( adr table-adr' )
1A3A2B8 	4C A1 A3  1 5C 44 A0  1 
1A3A2C0 	48 B8 A1  1 4C A1 A3  1 
   swap c@  swap c@+                      ( char entries-adr #entries )
1A3A2C8 	68 49 A0  1 C4 4C A0  1 
1A3A2D0 	68 49 A0  1  8 52 A0  1 
   true -rot                              ( char true entries-adr #ent )
1A3A2D8 	 4 70 A0  1 94 49 A0  1 
   2* bounds  ?do                         ( char true )
1A3A2E0 	A0 4B A0  1 F0 6D A0  1 
1A3A2E8 	50 42 A0  1 4C  0  0  0 
      over i c@ =  if                     ( char true )
1A3A2F0 	54 49 A0  1 B4 42 A0  1 
1A3A2F8 	C4 4C A0  1 24 48 A0  1 
1A3A300 	DC 41 A0  1 28  0  0  0 
         i 1+ c@  mode  or  to mode       ( char true )
1A3A308 	B4 42 A0  1 30 4B A0  1 
1A3A310 	C4 4C A0  1 4C A1 A3  1 
1A3A318 	70 44 A0  1 48 B8 A1  1 
1A3A320 	4C A1 A3  1 
         0= leave                         ( char false )
1A3A324 	24 47 A0  1 
1A3A328 	18 43 A0  1 
      then                                ( char true )
   2 +loop                                ( char not-found? )
1A3A32C 	90 6F A0  1 
1A3A330 	1C 42 A0  1 BC FF FF FF 
   if  ." '" emit ." ': "  ." syntax" .uart-error  then   ( char )
1A3A338 	DC 41 A0  1 2C  0  0  0 
1A3A340 	20 7C A0  1  1 27  0  0 
1A3A348 	2C 6C A0  1 20 7C A0  1 
1A3A350 	 3 27 3A 20  0  0  0  0 
1A3A358 	20 7C A0  1  6 73 79 6E 
1A3A360 	74 61 78  0 64 A1 A3  1 
   drop
1A3A368 	30 49 A0  1 
;
1A3A36C 	58 46 A0  1 
: table:  \ name  values c, ..  ( -- )
1A3A370 	 0 74 61 62 6C 65 3A 86 
1A3A378 	48 A2 A3  1 20 40 A0  1 
   create  does> do-table
1A3A380 	A8 A2 A0  1 50 A3 A0  1 
1A3A388 	90 90 90 E8 EC 9C FC FF 
1A3A390 	48 A2 A3  1 
;
1A3A394 	58 46 A0  1 


\  character   value     mask  #entries

table: set-handshake     00 c,   1 c,
1A3A398 	 0  0 73 65 74 2D 68 61 
1A3A3A0 	6E 64 73 68 61 6B 65 8D 
1A3A3A8 	7C A3 A3  1 88 A3 A3  1 
1A3A3B0 	 0  1 
   ascii - c,  00 c,
1A3A3B2 	2D  0 

table: set-stop-bits     04 c,   2 c,
1A3A3B4 	 0  0 73 65 
1A3A3B8 	74 2D 73 74 6F 70 2D 62 
1A3A3C0 	69 74 73 8D AC A3 A3  1 
1A3A3C8 	88 A3 A3  1  4  2 
   ascii 1 c,  00 c,
1A3A3CE 	31  0 
   ascii 2 c,  04 c,
1A3A3D0 	32  4 

table: set-parity        38 c,   5 c,
1A3A3D2 	 0  0  0 73 65 74 
1A3A3D8 	2D 70 61 72 69 74 79 8A 
1A3A3E0 	C8 A3 A3  1 88 A3 A3  1 
1A3A3E8 	38  5 
   ascii n c,  00 c,
1A3A3EA 	6E  0 
   ascii o c,  08 c,
1A3A3EC 	6F  8 
   ascii e c,  18 c,
1A3A3EE 	65 18 
   ascii m c,  28 c,
1A3A3F0 	6D 28 
   ascii s c,  38 c,
1A3A3F2 	73 38 

table: set-data-bits     03 c,   4 c,
1A3A3F4 	 0  0 73 65 
1A3A3F8 	74 2D 64 61 74 61 2D 62 
1A3A400 	69 74 73 8D E4 A3 A3  1 
1A3A408 	88 A3 A3  1  3  4 
   ascii 5 c,  00 c,
1A3A40E 	35  0 
   ascii 6 c,  01 c,
1A3A410 	36  1 
   ascii 7 c,  02 c,
1A3A412 	37  2 
   ascii 8 c,  03 c,
1A3A414 	38  3 

: get-field  ( adr len -- rem-adr,len field-adr,len )
1A3A416 	67 65 
1A3A418 	74 2D 66 69 65 6C 64 89 
1A3A420 	 8 A4 A3  1 20 40 A0  1 
   ascii , left-parse-string
1A3A428 	58 41 A0  1 2C  0  0  0 
1A3A430 	44 D7 A0  1 
;
1A3A434 	58 46 A0  1 
: (set-mode)  ( adr len -- )
1A3A438 	 0 28 73 65 74 2D 6D 6F 
1A3A440 	64 65 29 8A 24 A4 A3  1 
1A3A448 	20 40 A0  1 
   get-field set-baudrate    ( adr len )
1A3A44C 	24 A4 A3  1 
1A3A450 	CC A1 A3  1 

   3 uart@ to mode
1A3A454 	A0 6F A0  1 
1A3A458 	D8 9E A3  1 48 B8 A1  1 
1A3A460 	4C A1 A3  1 
   get-field set-data-bits   ( adr len )
1A3A464 	24 A4 A3  1 
1A3A468 	 8 A4 A3  1 
   get-field set-parity      ( adr len )
1A3A46C 	24 A4 A3  1 
1A3A470 	E4 A3 A3  1 
   get-field set-stop-bits   ( adr len )
1A3A474 	24 A4 A3  1 
1A3A478 	C8 A3 A3  1 
             set-handshake   ( )
1A3A47C 	AC A3 A3  1 

   \ Commit the changes
   divisor set-divisor       ( )
1A3A480 	38 A1 A3  1 9C A0 A3  1 
   mode 3 uart!              ( )
1A3A488 	4C A1 A3  1 A0 6F A0  1 
1A3A490 	F8 9E A3  1 
;
1A3A494 	58 46 A0  1 
headers
: set-mode  ( adr len -- )
1A3A498 	 0  0  0 73 65 74 2D 6D 
1A3A4A0 	6F 64 65 88 48 A4 A3  1 
1A3A4A8 	20 40 A0  1 
   get-divisor divisor-to-baud to current-baudrate (set-mode)
1A3A4AC 	40 A0 A3  1 
1A3A4B0 	90 9F A3  1 48 B8 A1  1 
1A3A4B8 	B0 A1 A3  1 48 A4 A3  1 
;
1A3A4C0 	58 46 A0  1 
: set-modem-control  ( mask -- )  4 uart!  ;
1A3A4C4 	 0  0 73 65 
1A3A4C8 	74 2D 6D 6F 64 65 6D 2D 
1A3A4D0 	63 6F 6E 74 72 6F 6C 91 
1A3A4D8 	A8 A4 A3  1 20 40 A0  1 
1A3A4E0 	B0 6F A0  1 F8 9E A3  1 
1A3A4E8 	58 46 A0  1 

: consume  ( -- )  0 uart@ drop  ;
1A3A4EC 	63 6F 6E 73 
1A3A4F0 	75 6D 65 87 DC A4 A3  1 
1A3A4F8 	20 40 A0  1 70 6F A0  1 
1A3A500 	D8 9E A3  1 30 49 A0  1 
1A3A508 	58 46 A0  1 
\ Test for rcv character.  While consuming (discarding) break characters.
: ukey?    ( -- flag )
1A3A50C 	 0  0 75 6B 
1A3A510 	65 79 3F 85 F8 A4 A3  1 
1A3A518 	20 40 A0  1 
   line-stat@  dup h# 10 and  if  drop consume false exit  then   ( lstat )
1A3A51C 	F8 9F A3  1 
1A3A520 	40 49 A0  1 58 41 A0  1 
1A3A528 	10  0  0  0 5C 44 A0  1 
1A3A530 	DC 41 A0  1 14  0  0  0 
1A3A538 	30 49 A0  1 F8 A4 A3  1 
1A3A540 	18 70 A0  1 40 46 A0  1 
   1 and  0<>
1A3A548 	80 6F A0  1 5C 44 A0  1 
1A3A550 	44 47 A0  1 
;
1A3A554 	58 46 A0  1 
: uemit?   ( -- flag )  line-stat@  h# 20 and  0<>  ;  \ Test for xmit ready
1A3A558 	 0 75 65 6D 69 74 3F 86 
1A3A560 	18 A5 A3  1 20 40 A0  1 
1A3A568 	F8 9F A3  1 58 41 A0  1 
1A3A570 	20  0  0  0 5C 44 A0  1 
1A3A578 	44 47 A0  1 58 46 A0  1 

: ubreak?  ( -- flag )                  \ Test for received break
1A3A580 	75 62 72 65 61 6B 3F 87 
1A3A588 	64 A5 A3  1 20 40 A0  1 
   \ Previously-detected break
   " get-break" $call-parent  if  true exit  then
1A3A590 	9C 53 A0  1  9 67 65 74 
1A3A598 	2D 62 72 65 61 6B  0  0 
1A3A5A0 	DC 31 A2  1 DC 41 A0  1 
1A3A5A8 	 C  0  0  0  4 70 A0  1 
1A3A5B0 	40 46 A0  1 

   \ Checked for a break in the FIFO
   \ If the FIFO error summary bit (h#80) indicates that there is an
   \ error (break, framing error, or parity error) somewhere in the
   \ FIFO, we unload the FIFO until we have either seen the break or
   \ have discarded the character in error.  This can cause loss of
   \ good characters that are already in the FIFO, but it is necessary
   \ in order to be able to interrupt runaway programs that are not
   \ polling the serial port.  We don't want previously-queued
   \ characters to "block" the appearance of the break.  The general
   \ solution would be to put the good characters in a software queue,
   \ but that is probably not worth the effort, especially since you
   \ usually want to flush the queue when you get a break anyway.

   begin
      (line-stat@)  dup h# 10  and  if	     ( lstat )		\ New break?
1A3A5B4 	D8 9F A3  1 
1A3A5B8 	40 49 A0  1 58 41 A0  1 
1A3A5C0 	10  0  0  0 5C 44 A0  1 
1A3A5C8 	DC 41 A0  1 14  0  0  0 
         drop                                ( )
1A3A5D0 	30 49 A0  1 
         consume			     ( )	\ Consume the break
1A3A5D4 	F8 A4 A3  1 
         true  exit                          ( true )
1A3A5D8 	 4 70 A0  1 40 46 A0  1 
      then                                   ( lstat )
      h# 80 and
1A3A5E0 	58 41 A0  1 80  0  0  0 
1A3A5E8 	5C 44 A0  1 
   while						\ Break in FIFO?
1A3A5EC 	DC 41 A0  1 
1A3A5F0 	10  0  0  0 
      consume						\ Consume a character
1A3A5F4 	F8 A4 A3  1 
   repeat
1A3A5F8 	C8 41 A0  1 B8 FF FF FF 
   false
1A3A600 	18 70 A0  1 
;
1A3A604 	58 46 A0  1 

: ukey   ( -- char )  begin  ukey?   until  0 uart@  ;  \ Receive a character
1A3A608 	 0  0  0 75 6B 65 79 84 
1A3A610 	8C A5 A3  1 20 40 A0  1 
1A3A618 	18 A5 A3  1 DC 41 A0  1 
1A3A620 	F8 FF FF FF 70 6F A0  1 
1A3A628 	D8 9E A3  1 58 46 A0  1 
: uemit  ( char -- )  begin  uemit?  until  0 uart!  ;  \ Transmit a character
1A3A630 	 0  0 75 65 6D 69 74 85 
1A3A638 	14 A6 A3  1 20 40 A0  1 
1A3A640 	64 A5 A3  1 DC 41 A0  1 
1A3A648 	F8 FF FF FF 70 6F A0  1 
1A3A650 	F8 9E A3  1 58 46 A0  1 

\ poll-tty is called periodically to see if the user has tried to
\ interrupt us by sending a "break" character.

: poll-tty  ( -- )  ubreak?  if  user-abort  then  ;
1A3A658 	 0  0  0 70 6F 6C 6C 2D 
1A3A660 	74 74 79 88 3C A6 A3  1 
1A3A668 	20 40 A0  1 8C A5 A3  1 
1A3A670 	DC 41 A0  1  8  0  0  0 
1A3A678 	 C E3 A1  1 58 46 A0  1 

external	\ The following routines are visible as package methods
d# 9600 value default-baudrate
1A3A680 	 0  0  0 64 65 66 61 75 
1A3A688 	6C 74 2D 62 61 75 64 72 
1A3A690 	61 74 65 90 68 A6 A3  1 
1A3A698 	50 40 A0  1 C4  B  0  0 

\ Queues for collecting received bytes
d# 1024 constant /q
1A3A6A0 	 0 2F 71 82 98 A6 A3  1 
1A3A6A8 	68 40 A0  1  0  4  0  0 

struct
/n field >head
1A3A6B0 	 0  0 3E 68 65 61 64 85 
1A3A6B8 	A8 A6 A3  1 50 EE A0  1 
1A3A6C0 	 0  0  0  0 
/n field >tail
1A3A6C4 	 0  0 3E 74 
1A3A6C8 	61 69 6C 85 BC A6 A3  1 
1A3A6D0 	50 EE A0  1  4  0  0  0 
/q field >qdata
1A3A6D8 	 0 3E 71 64 61 74 61 86 
1A3A6E0 	D0 A6 A3  1 50 EE A0  1 
1A3A6E8 	 8  0  0  0 
constant /qstruct
1A3A6EC 	 0  0  0 2F 
1A3A6F0 	71 73 74 72 75 63 74 88 
1A3A6F8 	E4 A6 A3  1 68 40 A0  1 
1A3A700 	 8  4  0  0 

/qstruct instance buffer: read-q
1A3A704 	 0 72 65 61 
1A3A708 	64 2D 71 86 FC A6 A3  1 
1A3A710 	4C  0 A2  1 D8 FB FF FF 
\ /qstruct buffer: write-q

: init-q  ( q -- )  0 over >head !  0 swap >tail !   ;
1A3A718 	 0 69 6E 69 74 2D 71 86 
1A3A720 	10 A7 A3  1 20 40 A0  1 
1A3A728 	70 6F A0  1 54 49 A0  1 
1A3A730 	BC A6 A3  1 54 4D A0  1 
1A3A738 	70 6F A0  1 68 49 A0  1 
1A3A740 	D0 A6 A3  1 54 4D A0  1 
1A3A748 	58 46 A0  1 
: inc-q-ptr  ( pointer-addr -- )
1A3A74C 	 0  0 69 6E 
1A3A750 	63 2D 71 2D 70 74 72 89 
1A3A758 	24 A7 A3  1 20 40 A0  1 
   dup @  ca1+  dup /q  =  if  drop 0  then  swap !
1A3A760 	40 49 A0  1 5C 4C A0  1 
1A3A768 	78 50 A0  1 40 49 A0  1 
1A3A770 	A8 A6 A3  1 24 48 A0  1 
1A3A778 	DC 41 A0  1  C  0  0  0 
1A3A780 	30 49 A0  1 70 6F A0  1 
1A3A788 	68 49 A0  1 54 4D A0  1 
;
1A3A790 	58 46 A0  1 

: enque  ( new-entry q -- )
1A3A794 	 0  0 65 6E 
1A3A798 	71 75 65 85 5C A7 A3  1 
1A3A7A0 	20 40 A0  1 
   >r
1A3A7A4 	BC 45 A0  1 
   r@ >tail @  r@ >head @  2dup >  if  - /q  then  1-     ( entry tail head )
1A3A7A8 	E4 45 A0  1 D0 A6 A3  1 
1A3A7B0 	5C 4C A0  1 E4 45 A0  1 
1A3A7B8 	BC A6 A3  1 5C 4C A0  1 
1A3A7C0 	C0 49 A0  1  4 48 A0  1 
1A3A7C8 	DC 41 A0  1  C  0  0  0 
1A3A7D0 	18 45 A0  1 A8 A6 A3  1 
1A3A7D8 	54 4B A0  1 
   <>  if  r@ >qdata  r@ >tail @ ca+ c!  r@ >tail inc-q-ptr  else  drop  then
1A3A7DC 	44 48 A0  1 
1A3A7E0 	DC 41 A0  1 34  0  0  0 
1A3A7E8 	E4 45 A0  1 E4 A6 A3  1 
1A3A7F0 	E4 45 A0  1 D0 A6 A3  1 
1A3A7F8 	5C 4C A0  1  4 50 A0  1 
1A3A800 	B8 4D A0  1 E4 45 A0  1 
1A3A808 	D0 A6 A3  1 5C A7 A3  1 
1A3A810 	C8 41 A0  1  8  0  0  0 
1A3A818 	30 49 A0  1 
   r> drop
1A3A81C 	D0 45 A0  1 
1A3A820 	30 49 A0  1 
;
1A3A824 	58 46 A0  1 

\ This is only called for the queue for "port"
: deque?  ( q -- false | entry true )
1A3A828 	 0 64 65 71 75 65 3F 86 
1A3A830 	A0 A7 A3  1 20 40 A0  1 
   >r
1A3A838 	BC 45 A0  1 
   r@ >head @  r@ >tail @  <>  if
1A3A83C 	E4 45 A0  1 
1A3A840 	BC A6 A3  1 5C 4C A0  1 
1A3A848 	E4 45 A0  1 D0 A6 A3  1 
1A3A850 	5C 4C A0  1 44 48 A0  1 
1A3A858 	DC 41 A0  1 38  0  0  0 
      r@ >qdata  r@ >head @  ca+ c@  r@ >head inc-q-ptr  true
1A3A860 	E4 45 A0  1 E4 A6 A3  1 
1A3A868 	E4 45 A0  1 BC A6 A3  1 
1A3A870 	5C 4C A0  1  4 50 A0  1 
1A3A878 	C4 4C A0  1 E4 45 A0  1 
1A3A880 	BC A6 A3  1 5C A7 A3  1 
1A3A888 	 4 70 A0  1 
   else
1A3A88C 	C8 41 A0  1 
1A3A890 	 8  0  0  0 
      false
1A3A894 	18 70 A0  1 
   then
   r> drop
1A3A898 	D0 45 A0  1 30 49 A0  1 
;
1A3A8A0 	58 46 A0  1 

\ false instance value q-lock
: read-all  ( -- )
1A3A8A4 	 0  0  0 72 
1A3A8A8 	65 61 64 2D 61 6C 6C 88 
1A3A8B0 	34 A8 A3  1 20 40 A0  1 
   \ Upon entry, we believe that there is at least one character to read
   \ I have seen conditions where a UART will report, via an interrupt,
   \ that a character is available, but the line status register won't
   \ report it.
   begin  0 uart@ read-q enque  ukey? 0=  until
1A3A8B8 	70 6F A0  1 D8 9E A3  1 
1A3A8C0 	10 A7 A3  1 A0 A7 A3  1 
1A3A8C8 	18 A5 A3  1 24 47 A0  1 
1A3A8D0 	DC 41 A0  1 E4 FF FF FF 
;
1A3A8D8 	58 46 A0  1 
: try-read  ( -- )  ukey?  if  read-all  then  ;
1A3A8DC 	 0  0  0 74 
1A3A8E0 	72 79 2D 72 65 61 64 88 
1A3A8E8 	B4 A8 A3  1 20 40 A0  1 
1A3A8F0 	18 A5 A3  1 DC 41 A0  1 
1A3A8F8 	 8  0  0  0 B4 A8 A3  1 
1A3A900 	58 46 A0  1 

\ : (wpoll)  ( -- )  true to q-lock  try-read false to q-lock  ;
: (rpoll)  ( -- )  ( q-lock 0=  if )  try-read  ( then )  ;
1A3A904 	28 72 70 6F 
1A3A908 	6C 6C 29 87 EC A8 A3  1 
1A3A910 	20 40 A0  1 EC A8 A3  1 
1A3A918 	58 46 A0  1 

instance defer rpoll  ' (rpoll) to rpoll
1A3A91C 	 0  0 72 70 
1A3A920 	6F 6C 6C 85 10 A9 A3  1 
1A3A928 	F0  1 A2  1 2C  0  0  0 
\ instance defer wpoll  ' (wpoll) to wpoll

0 instance value rx-error
1A3A930 	 0  0  0 72 78 2D 65 72 
1A3A938 	72 6F 72 88 28 A9 A3  1 
1A3A940 	C0 FE A1  1 30  0  0  0 
false instance value lost-carrier?
1A3A948 	 0  0 6C 6F 73 74 2D 63 
1A3A950 	61 72 72 69 65 72 3F 8D 
1A3A958 	40 A9 A3  1 C0 FE A1  1 
1A3A960 	34  0  0  0 
\ : rx-irq  ( -- )  ( q-lock 0=  if )  read-all  ( then )  ;
: rx-status-irq  ( -- )  5 uart@  h# 1f and  to rx-error  ;
1A3A964 	 0  0 72 78 
1A3A968 	2D 73 74 61 74 75 73 2D 
1A3A970 	69 72 71 8D 5C A9 A3  1 
1A3A978 	20 40 A0  1 C0 6F A0  1 
1A3A980 	D8 9E A3  1 58 41 A0  1 
1A3A988 	1F  0  0  0 5C 44 A0  1 
1A3A990 	48 B8 A1  1 40 A9 A3  1 
1A3A998 	58 46 A0  1 
: modem-status-irq  ( -- )
1A3A99C 	 0  0  0 6D 
1A3A9A0 	6F 64 65 6D 2D 73 74 61 
1A3A9A8 	74 75 73 2D 69 72 71 90 
1A3A9B0 	78 A9 A3  1 20 40 A0  1 
   6 uart@  dup  8 and  if
1A3A9B8 	D0 6F A0  1 D8 9E A3  1 
1A3A9C0 	40 49 A0  1 F0 6F A0  1 
1A3A9C8 	5C 44 A0  1 DC 41 A0  1 
1A3A9D0 	20  0  0  0 
      dup h# 80 and 0=  to lost-carrier?
1A3A9D4 	40 49 A0  1 
1A3A9D8 	58 41 A0  1 80  0  0  0 
1A3A9E0 	5C 44 A0  1 24 47 A0  1 
1A3A9E8 	48 B8 A1  1 5C A9 A3  1 
   then
   drop
1A3A9F0 	30 49 A0  1 
;
1A3A9F4 	58 46 A0  1 

: decode-irq  ( -- )
1A3A9F8 	 0 64 65 63 6F 64 65 2D 
1A3AA00 	69 72 71 8A B4 A9 A3  1 
1A3AA08 	20 40 A0  1 
   2 uart@        ( iir )
1A3AA0C 	90 6F A0  1 
1A3AA10 	D8 9E A3  1 
   dup 1 and  if  ( ." Spurious UART IRQ" cr )  drop exit  then
1A3AA14 	40 49 A0  1 
1A3AA18 	80 6F A0  1 5C 44 A0  1 
1A3AA20 	DC 41 A0  1  C  0  0  0 
1A3AA28 	30 49 A0  1 40 46 A0  1 
\ XXX we could probably make use of this bit to help with PPP framing
\  dup 8 and  if  ( ." UART FIFO timeout" cr )  drop exit  then
   1 rshift 3 and  case
1A3AA30 	80 6F A0  1 B4 44 A0  1 
1A3AA38 	A0 6F A0  1 5C 44 A0  1 
      0 of  modem-status-irq       endof
1A3AA40 	70 6F A0  1 48 43 A0  1 
1A3AA48 	10  0  0  0 B4 A9 A3  1 
1A3AA50 	6C 43 A0  1 64  0  0  0 
      1 of  ." UART Tx IRQ" cr     endof
1A3AA58 	80 6F A0  1 48 43 A0  1 
1A3AA60 	24  0  0  0 20 7C A0  1 
1A3AA68 	 B 55 41 52 54 20 54 78 
1A3AA70 	20 49 52 51  0  0  0  0 
1A3AA78 	80 6D A0  1 6C 43 A0  1 
1A3AA80 	38  0  0  0 
      2 of  ( rx-irq ) read-all    endof
1A3AA84 	90 6F A0  1 
1A3AA88 	48 43 A0  1 10  0  0  0 
1A3AA90 	B4 A8 A3  1 6C 43 A0  1 
1A3AA98 	20  0  0  0 
      3 of  rx-status-irq          endof
1A3AA9C 	A0 6F A0  1 
1A3AAA0 	48 43 A0  1 10  0  0  0 
1A3AAA8 	78 A9 A3  1 6C 43 A0  1 
1A3AAB0 	 8  0  0  0 
   endcase
1A3AAB4 	84 43 A0  1 
;
1A3AAB8 	58 46 A0  1 

-1 instance value irq#
1A3AABC 	 0  0  0 69 
1A3AAC0 	72 71 23 84  8 AA A3  1 
1A3AAC8 	C0 FE A1  1 38  0  0  0 
0 instance value saved-handler
1A3AAD0 	 0  0 73 61 76 65 64 2D 
1A3AAD8 	68 61 6E 64 6C 65 72 8D 
1A3AAE0 	C8 AA A3  1 C0 FE A1  1 
1A3AAE8 	3C  0  0  0 
: use-polling  ( -- )
1A3AAEC 	75 73 65 2D 
1A3AAF0 	70 6F 6C 6C 69 6E 67 8B 
1A3AAF8 	E4 AA A3  1 20 40 A0  1 
   ['] (rpoll) to rpoll
1A3AB00 	60 53 A0  1 10 A9 A3  1 
1A3AB08 	48 B8 A1  1 28 A9 A3  1 
;
1A3AB10 	58 46 A0  1 

: install-abort  ( -- )  ['] poll-tty d# 100 alarm  ;	\ Check for break
1A3AB14 	 0  0 69 6E 
1A3AB18 	73 74 61 6C 6C 2D 61 62 
1A3AB20 	6F 72 74 8D FC AA A3  1 
1A3AB28 	20 40 A0  1 60 53 A0  1 
1A3AB30 	68 A6 A3  1 58 41 A0  1 
1A3AB38 	64  0  0  0 48 73 A2  1 
1A3AB40 	58 46 A0  1 
: remove-abort  ( -- )  ['] poll-tty 0 alarm  ;
1A3AB44 	 0  0  0 72 
1A3AB48 	65 6D 6F 76 65 2D 61 62 
1A3AB50 	6F 72 74 8C 28 AB A3  1 
1A3AB58 	20 40 A0  1 60 53 A0  1 
1A3AB60 	68 A6 A3  1 70 6F A0  1 
1A3AB68 	48 73 A2  1 58 46 A0  1 

\ Read at most "len" characters into the buffer at adr, stopping when
\ no more characters are immediately available.
: read  ( adr len -- #read )   \ -2 for none available right now
1A3AB70 	 0  0  0 72 65 61 64 84 
1A3AB78 	58 AB A3  1 20 40 A0  1 
   rpoll
1A3AB80 	28 A9 A3  1 
   dup  0=  if  nip exit  then                   ( adr len )
1A3AB84 	40 49 A0  1 
1A3AB88 	24 47 A0  1 DC 41 A0  1 
1A3AB90 	 C  0  0  0 FC 46 A0  1 
1A3AB98 	40 46 A0  1 
   read-q deque?  0=  if                         ( adr len )
1A3AB9C 	10 A7 A3  1 
1A3ABA0 	34 A8 A3  1 24 47 A0  1 
1A3ABA8 	DC 41 A0  1 3C  0  0  0 
      2drop                                      ( )
1A3ABB0 	AC 49 A0  1 
      lost-carrier?  if  -1  false to lost-carrier?  else  -2  then
1A3ABB4 	5C A9 A3  1 
1A3ABB8 	DC 41 A0  1 20  0  0  0 
1A3ABC0 	58 41 A0  1 FF FF FF FF 
1A3ABC8 	18 70 A0  1 48 B8 A1  1 
1A3ABD0 	5C A9 A3  1 C8 41 A0  1 
1A3ABD8 	 C  0  0  0 58 41 A0  1 
1A3ABE0 	FE FF FF FF 
                                                 ( -2:none | -1:down )
      exit
1A3ABE4 	40 46 A0  1 
   then                                          ( adr len char )
   over >r                                       ( adr len char r: len )
1A3ABE8 	54 49 A0  1 BC 45 A0  1 
   begin                                         ( adr len char r: len )
      2 pick c!                                  ( adr len r: len )
1A3ABF0 	90 6F A0  1  C 4A A0  1 
1A3ABF8 	B8 4D A0  1 
      1 /string                                  ( adr' len' )
1A3ABFC 	80 6F A0  1 
1A3AC00 	3C 85 A0  1 
      dup 0=  if  2drop r> exit  then            ( adr' len' )
1A3AC04 	40 49 A0  1 
1A3AC08 	24 47 A0  1 DC 41 A0  1 
1A3AC10 	10  0  0  0 AC 49 A0  1 
1A3AC18 	D0 45 A0  1 40 46 A0  1 
   read-q deque? 0=  until                       ( adr len r: len )
1A3AC20 	10 A7 A3  1 34 A8 A3  1 
1A3AC28 	24 47 A0  1 DC 41 A0  1 
1A3AC30 	C0 FF FF FF 
   nip r> swap -                                 ( actual )
1A3AC34 	FC 46 A0  1 
1A3AC38 	D0 45 A0  1 68 49 A0  1 
1A3AC40 	18 45 A0  1 
;
1A3AC44 	58 46 A0  1 

: write  ( adr len -- #written )
1A3AC48 	 0  0 77 72 69 74 65 85 
1A3AC50 	7C AB A3  1 20 40 A0  1 
   tuck  bounds ?do
1A3AC58 	E8 46 A0  1 F0 6D A0  1 
1A3AC60 	50 42 A0  1 38  0  0  0 
\      wpoll
      uemit?  if  i c@ 0 uart!  1  else  0  then
1A3AC68 	64 A5 A3  1 DC 41 A0  1 
1A3AC70 	20  0  0  0 B4 42 A0  1 
1A3AC78 	C4 4C A0  1 70 6F A0  1 
1A3AC80 	F8 9E A3  1 80 6F A0  1 
1A3AC88 	C8 41 A0  1  8  0  0  0 
1A3AC90 	70 6F A0  1 
   +loop
1A3AC94 	1C 42 A0  1 
1A3AC98 	D0 FF FF FF 
;
1A3AC9C 	58 46 A0  1 

: rts-dtr-on   ( -- )  4 uart@  3 or          4 uart!  ;
1A3ACA0 	 0 72 74 73 2D 64 74 72 
1A3ACA8 	2D 6F 6E 8A 54 AC A3  1 
1A3ACB0 	20 40 A0  1 B0 6F A0  1 
1A3ACB8 	D8 9E A3  1 A0 6F A0  1 
1A3ACC0 	70 44 A0  1 B0 6F A0  1 
1A3ACC8 	F8 9E A3  1 58 46 A0  1 
: rts-dtr-off  ( -- )  4 uart@  3 invert and  4 uart!  ;
1A3ACD0 	72 74 73 2D 64 74 72 2D 
1A3ACD8 	6F 66 66 8B B0 AC A3  1 
1A3ACE0 	20 40 A0  1 B0 6F A0  1 
1A3ACE8 	D8 9E A3  1 A0 6F A0  1 
1A3ACF0 	30 45 A0  1 5C 44 A0  1 
1A3ACF8 	B0 6F A0  1 F8 9E A3  1 
1A3AD00 	58 46 A0  1 

: inituart  ( -- )
1A3AD04 	 0  0  0 69 
1A3AD08 	6E 69 74 75 61 72 74 88 
1A3AD10 	E0 AC A3  1 20 40 A0  1 
   3 3 uart!  		\ 8 bits, no parity
1A3AD18 	A0 6F A0  1 A0 6F A0  1 
1A3AD20 	F8 9E A3  1 
   7 2 uart!		\ Clear and enable FIFOs
1A3AD24 	E0 6F A0  1 
1A3AD28 	90 6F A0  1 F8 9E A3  1 
   d# 9600 baud
1A3AD30 	58 41 A0  1 80 25  0  0 
1A3AD38 	1C A1 A3  1 
;
1A3AD3C 	58 46 A0  1 

: open  ( -- okay? )
1A3AD40 	 0  0  0 6F 70 65 6E 84 
1A3AD48 	14 AD A3  1 20 40 A0  1 
   " base-adr" $call-parent  to uart-base
1A3AD50 	9C 53 A0  1  8 62 61 73 
1A3AD58 	65 2D 61 64 72  0  0  0 
1A3AD60 	DC 31 A2  1 48 B8 A1  1 
1A3AD68 	A4 9E A3  1 
   use-polling
1A3AD6C 	FC AA A3  1 
   inituart
1A3AD70 	14 AD A3  1 
   default-baudrate to current-baudrate
1A3AD74 	98 A6 A3  1 
1A3AD78 	48 B8 A1  1 B0 A1 A3  1 
   read-q init-q
1A3AD80 	10 A7 A3  1 24 A7 A3  1 

   my-args  ['] (set-mode)  catch  if  2drop false exit  then
1A3AD88 	10  7 A2  1 60 53 A0  1 
1A3AD90 	48 A4 A3  1 14 7F A0  1 
1A3AD98 	DC 41 A0  1 10  0  0  0 
1A3ADA0 	AC 49 A0  1 18 70 A0  1 
1A3ADA8 	40 46 A0  1 

   rts-dtr-on
1A3ADAC 	B0 AC A3  1 
   true
1A3ADB0 	 4 70 A0  1 
;
1A3ADB4 	58 46 A0  1 

: close  ( -- )  use-polling  rts-dtr-off  ;
1A3ADB8 	 0  0 63 6C 6F 73 65 85 
1A3ADC0 	4C AD A3  1 20 40 A0  1 
1A3ADC8 	FC AA A3  1 E0 AC A3  1 
1A3ADD0 	58 46 A0  1 

: selftest  ( -- )  h# 7f  bl  ?do  i uemit  loop  ;
1A3ADD4 	 0  0  0 73 
1A3ADD8 	65 6C 66 74 65 73 74 88 
1A3ADE0 	C4 AD A3  1 20 40 A0  1 
1A3ADE8 	58 41 A0  1 7F  0  0  0 
1A3ADF0 	28 70 A0  1 50 42 A0  1 
1A3ADF8 	14  0  0  0 B4 42 A0  1 
1A3AE00 	3C A6 A3  1 F8 41 A0  1 
1A3AE08 	F4 FF FF FF 58 46 A0  1 

end-support-package
1A3AE10 	 0  0  0  0  0  0  0  0 
1A3AE18 	 0  0  0  0  0  0  0  0 
1A3AE20 	 0  0  0  0  0  0  0  0 
1A3AE28 	 0  0  0  0  0  0  0  0 
1A3AE30 	 0  0  0  0  0  0  0  0 
1A3AE38 	 0  0  0  0 FC 25 78 55 
1A3AE40 	 0  0  0  0  0  0  0  0 
1A3AE48 	FF FF FF FF  0  0  0  0 

OpenFirmware/dev/16550pkg/16550.fth_AL	1048 1A3AE50 
begin-package
select-dev=</isa>0 0 5D9187 4 

propset=1A3AE64 B4428A4 1A00C08 
vocset=B4428A4 1A00C08 1A3AE64 
new-node=B4428B8 1A00BE8 
vocset=B4428B8 1A00BE8 1A3AE64 0 0 5D9187 4 

set-args0=4 5D9187 0 0 
begin-package;1A3AE7C 1A3AEA0 purpose: Create COM port nodes

[ifndef] no-com1-node
0 0  " i3f8"  " /isa"  begin-package
1A3AE50 	E0 B6 A0  1 C8  B  0  0 
1A3AE58 	D8 91 A3  1 E0 B6 A0  1 
1A3AE60 	E8  B  0  0 
[ifdef] PREP
   4 encode-int                          " interrupts" property
[else]
   4 encode-int  3 encode-int encode+    " interrupts" property
1A3AE64 	 0  0  0  4 
1A3AE68 	 0  0  0  3  0 69 6E 74 
1A3AE70 	65 72 72 75 70 74 73 8A 
1A3AE78 	 0  0 A0  1 BC 13 A2  1 
1A3AE80 	1C  0  0  0  8  0  0  0 
[then]

   \ XXX The SuperIO data sheet implies that the clock rate is 24MHz/13, which
   \ is 1,846,153, while the ARC config data says 1,843,200.  The difference
   \ accounts for the 0.2% (actually .16%) error mentioned in the data sheet.
   \ Until we can determine whether or not NT can handle the truth, we will
   \ fudge the data and say it's 1,843,200
   \ d# 1846153 encode-int " clock-frequency" property
   d# 1843200 encode-int " clock-frequency" property
1A3AE88 	 0 1C 20  0 63 6C 6F 63 
1A3AE90 	6B 2D 66 72 65 71 75 65 
1A3AE98 	6E 63 79 8F 7C AE A3  1 
1A3AEA0 	BC 13 A2  1 1C  0  0  0 
1A3AEA8 	 4  0  0  0 
\eof
\   fload ${BP}/dev/ns16550a.fth
S" OpenFirmware/dev/16550pkg/ns16550p.fth"  INCLUDED
S" OpenFirmware/dev/16550pkg/isa-int.fth"  INCLUDED
end-package

: com1  ( -- adr len )  " com1"  ;  ' com1 to fallback-device

: use-com1  ( -- )
   " com1" " input-device" $setenv
   " com1" " output-device" $setenv
;
[then]

[ifndef] no-com2-node
0 0  " i2f8"  " /isa"  begin-packagez
[ifdef] PREP
   3 encode-int                          " interrupts" property
[else]
   3 encode-int  3 encode-int encode+    " interrupts" property
[then]

   d# 1843200 encode-int " clock-frequency" property
\   fload ${BP}/dev/ns16550a.fth

S" OpenFirmware/dev/16550pkg/ns16550p.fth"  INCLUDED
S" OpenFirmware/dev/16550pkg/isa-int.fth"  INCLUDED

end-package

: com2  ( -- adr len )  " com2"  ;
[then]

OpenFirmware/dev/pci/isacom.fth_AL	5C 1A3AEAC 
serial
1A3AEBC 1A3AEE0 1A3AF08 1A3AF2C purpose: Driver for NS16550A UART chip which relies on 16550 package support

\ Please Note:  This driver is NOT suitable for a stand-alone FCode ROM.
\ The code relies on a 16550 package and has a selftest method.

hex
headers

" serial" name			\ Name of device for identification
1A3AEAC 	73 65 72 69 
1A3AEB0 	61 6C  0 6E 61 6D 65 84 
1A3AEB8 	A0 AE A3  1 BC 13 A2  1 
1A3AEC0 	14  0  0  0  7  0  0  0 
" serial" device-type		\ Device class
1A3AEC8 	73 65 72 69 61 6C  0  0 
1A3AED0 	64 65 76 69 63 65 5F 74 
1A3AED8 	79 70 65 8B BC AE A3  1 
1A3AEE0 	BC 13 A2  1 1C  0  0  0 
1A3AEE8 	 7  0  0  0 
" pnpPNP,501" " compatible" string-property
1A3AEEC 	70 6E 70 50 
1A3AEF0 	4E 50 2C 35 30 31  0  0 
1A3AEF8 	 0 63 6F 6D 70 61 74 69 
1A3AF00 	62 6C 65 8A E0 AE A3  1 
1A3AF08 	BC 13 A2  1 20  0  0  0 
1A3AF10 	 B  0  0  0 

\ This can be overridden if necessary by redefining this property value
\ after loading this file.
d# 1843200 " clock-frequency" integer-property
1A3AF14 	 0 1C 20  0 

\ The UART chip occupies 8 bytes of IO space beginning at its base address

my-address my-space  8 reg	\ Report address space used by device
1A3AF18 	 0  0  0  1  0  0  3 F8 
1A3AF20 	 0  0  0  8 72 65 67 83 
1A3AF28 	 8 AF A3  1 BC 13 A2  1 
1A3AF30 	18  0  0  0  C  0  0  0 

0 instance value support-ih	\ ihandle of 16550 supprt package
1A3AF38 	 0 73 75 70 70 6F 72 74 
1A3AF40 	2D 69 68 8A  0  0 A0  1 
1A3AF48 	C0 FE A1  1 18  0  0  0 
variable refcount  0 refcount !
1A3AF50 	 0  0  0 72 65 66 63 6F 
1A3AF58 	75 6E 74 88 48 AF A3  1 
1A3AF60 	48 40 A0  1 EC  B  0  0 

0 value break?			\ Shared between all instances
1A3AF68 	 0 62 72 65 61 6B 3F 86 
1A3AF70 	60 AF A3  1 50 40 A0  1 
1A3AF78 	F0  B  0  0 

external
: $call-support  ( ... $ -- ... )  support-ih $call-method  ;
1A3AF7C 	 0  0 24 63 
1A3AF80 	61 6C 6C 2D 73 75 70 70 
1A3AF88 	6F 72 74 8D 74 AF A3  1 
1A3AF90 	20 40 A0  1 48 AF A3  1 
1A3AF98 	B4 31 A2  1 58 46 A0  1 

0 instance value base-adr
1A3AFA0 	 0  0  0 62 61 73 65 2D 
1A3AFA8 	61 64 72 88 90 AF A3  1 
1A3AFB0 	C0 FE A1  1 1C  0  0  0 

: set-break  ( -- )  true to break?  ;
1A3AFB8 	 0  0 73 65 74 2D 62 72 
1A3AFC0 	65 61 6B 89 B0 AF A3  1 
1A3AFC8 	20 40 A0  1  4 70 A0  1 
1A3AFD0 	B8 40 A0  1 74 AF A3  1 
1A3AFD8 	58 46 A0  1 
: get-break  ( -- flag )  break?  dup  if  false to break?  then  ;
1A3AFDC 	 0  0 67 65 
1A3AFE0 	74 2D 62 72 65 61 6B 89 
1A3AFE8 	C8 AF A3  1 20 40 A0  1 
1A3AFF0 	74 AF A3  1 40 49 A0  1 
1A3AFF8 	DC 41 A0  1 10  0  0  0 
1A3B000 	18 70 A0  1 B8 40 A0  1 
1A3B008 	74 AF A3  1 58 46 A0  1 

headers
\ Map the device into virtual address space
: map-uart  ( -- )   my-unit  8  " map-in"  $call-parent to base-adr  ;
1A3B010 	 0  0  0 6D 61 70 2D 75 
1A3B018 	61 72 74 88 EC AF A3  1 
1A3B020 	20 40 A0  1 70 10 A2  1 
1A3B028 	F0 6F A0  1 9C 53 A0  1 
1A3B030 	 6 6D 61 70 2D 69 6E  0 
1A3B038 	DC 31 A2  1 48 B8 A1  1 
1A3B040 	B0 AF A3  1 58 46 A0  1 

\ Release the mapping resources used by the device.
: unmap-uart  ( -- )  base-adr 8  " map-out" $call-parent  ;
1A3B048 	 0 75 6E 6D 61 70 2D 75 
1A3B050 	61 72 74 8A 20 B0 A3  1 
1A3B058 	20 40 A0  1 B0 AF A3  1 
1A3B060 	F0 6F A0  1 9C 53 A0  1 
1A3B068 	 7 6D 61 70 2D 6F 75 74 
1A3B070 	 0  0  0  0 DC 31 A2  1 
1A3B078 	58 46 A0  1 

external

: rts-dtr-off    ( -- )  " rts-dtr-off"   $call-support  ;
1A3B07C 	72 74 73 2D 
1A3B080 	64 74 72 2D 6F 66 66 8B 
1A3B088 	58 B0 A3  1 20 40 A0  1 
1A3B090 	9C 53 A0  1  B 72 74 73 
1A3B098 	2D 64 74 72 2D 6F 66 66 
1A3B0A0 	 0  0  0  0 90 AF A3  1 
1A3B0A8 	58 46 A0  1 
: rts-dtr-on     ( -- )  " rts-dtr-on"    $call-support  ;
1A3B0AC 	 0 72 74 73 
1A3B0B0 	2D 64 74 72 2D 6F 6E 8A 
1A3B0B8 	8C B0 A3  1 20 40 A0  1 
1A3B0C0 	9C 53 A0  1  A 72 74 73 
1A3B0C8 	2D 64 74 72 2D 6F 6E  0 
1A3B0D0 	90 AF A3  1 58 46 A0  1 
: use-irqs       ( -- )  " use-irqs"      $call-support  ;
1A3B0D8 	 0  0  0 75 73 65 2D 69 
1A3B0E0 	72 71 73 88 BC B0 A3  1 
1A3B0E8 	20 40 A0  1 9C 53 A0  1 
1A3B0F0 	 8 75 73 65 2D 69 72 71 
1A3B0F8 	73  0  0  0 90 AF A3  1 
1A3B100 	58 46 A0  1 
: use-polling    ( -- )  " use-polling"   $call-support  ;
1A3B104 	75 73 65 2D 
1A3B108 	70 6F 6C 6C 69 6E 67 8B 
1A3B110 	E8 B0 A3  1 20 40 A0  1 
1A3B118 	9C 53 A0  1  B 75 73 65 
1A3B120 	2D 70 6F 6C 6C 69 6E 67 
1A3B128 	 0  0  0  0 90 AF A3  1 
1A3B130 	58 46 A0  1 
: install-abort  ( -- )  " install-abort" $call-support  ;
1A3B134 	 0  0 69 6E 
1A3B138 	73 74 61 6C 6C 2D 61 62 
1A3B140 	6F 72 74 8D 14 B1 A3  1 
1A3B148 	20 40 A0  1 9C 53 A0  1 
1A3B150 	 D 69 6E 73 74 61 6C 6C 
1A3B158 	2D 61 62 6F 72 74  0  0 
1A3B160 	90 AF A3  1 58 46 A0  1 
: remove-abort   ( -- )  " remove-abort"  $call-support  ;
1A3B168 	 0  0  0 72 65 6D 6F 76 
1A3B170 	65 2D 61 62 6F 72 74 8C 
1A3B178 	48 B1 A3  1 20 40 A0  1 
1A3B180 	9C 53 A0  1  C 72 65 6D 
1A3B188 	6F 76 65 2D 61 62 6F 72 
1A3B190 	74  0  0  0 90 AF A3  1 
1A3B198 	58 46 A0  1 

: read   ( adr len -- actual )  " read"   $call-support  ;
1A3B19C 	 0  0  0 72 
1A3B1A0 	65 61 64 84 7C B1 A3  1 
1A3B1A8 	20 40 A0  1 9C 53 A0  1 
1A3B1B0 	 4 72 65 61 64  0  0  0 
1A3B1B8 	90 AF A3  1 58 46 A0  1 
: write  ( adr len -- actual )  " write"  $call-support  ;
1A3B1C0 	 0  0 77 72 69 74 65 85 
1A3B1C8 	A8 B1 A3  1 20 40 A0  1 
1A3B1D0 	9C 53 A0  1  5 77 72 69 
1A3B1D8 	74 65  0  0 90 AF A3  1 
1A3B1E0 	58 46 A0  1 

: open  ( -- flag )
1A3B1E4 	 0  0  0 6F 
1A3B1E8 	70 65 6E 84 CC B1 A3  1 
1A3B1F0 	20 40 A0  1 
   map-uart
1A3B1F4 	20 B0 A3  1 
   my-args " 16550" $open-package  to support-ih
1A3B1F8 	10  7 A2  1 9C 53 A0  1 
1A3B200 	 5 31 36 35 35 30  0  0 
1A3B208 	80 3A A2  1 48 B8 A1  1 
1A3B210 	48 AF A3  1 
   support-ih 0=  if  unmap-uart false  exit  then
1A3B214 	48 AF A3  1 
1A3B218 	24 47 A0  1 DC 41 A0  1 
1A3B220 	10  0  0  0 58 B0 A3  1 
1A3B228 	18 70 A0  1 40 46 A0  1 
   refcount @ 1+  refcount !
1A3B230 	60 AF A3  1 5C 4C A0  1 
1A3B238 	30 4B A0  1 60 AF A3  1 
1A3B240 	54 4D A0  1 
   true
1A3B244 	 4 70 A0  1 
;
1A3B248 	58 46 A0  1 

: close  ( -- )
1A3B24C 	 0  0 63 6C 
1A3B250 	6F 73 65 85 F0 B1 A3  1 
1A3B258 	20 40 A0  1 
   support-ih close-package
1A3B25C 	48 AF A3  1 
1A3B260 	A4 36 A2  1 
   unmap-uart
1A3B264 	58 B0 A3  1 
   refcount @ 1-  0 max  refcount !
1A3B268 	60 AF A3  1 5C 4C A0  1 
1A3B270 	54 4B A0  1 70 6F A0  1 
1A3B278 	9C 4A A0  1 60 AF A3  1 
1A3B280 	54 4D A0  1 
;
1A3B284 	58 46 A0  1 

: selftest  ( -- 0 )		\ Test device by sending a bunch of characters
1A3B288 	 0  0  0 73 65 6C 66 74 
1A3B290 	65 73 74 88 58 B2 A3  1 
1A3B298 	20 40 A0  1 
   refcount @  if  ." Device in use" cr 0 exit  then
1A3B29C 	60 AF A3  1 
1A3B2A0 	5C 4C A0  1 DC 41 A0  1 
1A3B2A8 	24  0  0  0 20 7C A0  1 
1A3B2B0 	 D 44 65 76 69 63 65 20 
1A3B2B8 	69 6E 20 75 73 65  0  0 
1A3B2C0 	80 6D A0  1 70 6F A0  1 
1A3B2C8 	40 46 A0  1 
   open 0=  if  ." Device won't open" cr true exit  then
1A3B2CC 	F0 B1 A3  1 
1A3B2D0 	24 47 A0  1 DC 41 A0  1 
1A3B2D8 	28  0  0  0 20 7C A0  1 
1A3B2E0 	11 44 65 76 69 63 65 20 
1A3B2E8 	77 6F 6E 27 74 20 6F 70 
1A3B2F0 	65 6E  0  0 80 6D A0  1 
1A3B2F8 	 4 70 A0  1 40 46 A0  1 
   " selftest" $call-support  close   0
1A3B300 	9C 53 A0  1  8 73 65 6C 
1A3B308 	66 74 65 73 74  0  0  0 
1A3B310 	90 AF A3  1 58 B2 A3  1 
1A3B318 	70 6F A0  1 
;
1A3B31C 	58 46 A0  1 

headers

OpenFirmware/dev/16550pkg/ns16550p.fth_AL	474 1A3B320 
99D7BB4   F8 03 00 00  00 00 00 00  00 00 00 00  01 00 00 00 ...............
99D7BC4   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................purpose: Extract actual interrupt value from property

hex
external
: irq#  ( -- irq )
1A3B320 	 0  0  0 69 72 71 23 84 
1A3B328 	98 B2 A3  1 20 40 A0  1 
   " interrupts" get-my-property  if
1A3B330 	9C 53 A0  1  A 69 6E 74 
1A3B338 	65 72 72 75 70 74 73  0 
1A3B340 	1C 34 A2  1 DC 41 A0  1 
1A3B348 	34  0  0  0 
      ." Missing interrupts property" cr
1A3B34C 	20 7C A0  1 
1A3B350 	1B 4D 69 73 73 69 6E 67 
1A3B358 	20 69 6E 74 65 72 72 75 
1A3B360 	70 74 73 20 70 72 6F 70 
1A3B368 	65 72 74 79  0  0  0  0 
1A3B370 	80 6D A0  1 
      0 exit
1A3B374 	70 6F A0  1 
1A3B378 	40 46 A0  1 
   then                ( adr len )
   get-encoded-int     ( irq )
1A3B37C 	A0 F7 A1  1 
;
1A3B380 	58 46 A0  1 
headers
end-package
1A3B384 	F8  3  0  0 
1A3B388 	 0  0  0  0  0  0  0  0 
1A3B390 	 1  0  0  0  0  0  0  0 
1A3B398 	 0  0  0  0  0  0  0  0 
1A3B3A0 	 0  0  0  0 

OpenFirmware/dev/16550pkg/isa-int.fth_AL	84 1A3B3A4 
begin-package
select-dev=</isa>0 0 5D8F85 4 

propset=1A3B438 B442935 1A00C34 
vocset=B442935 1A00C34 1A3B438 
new-node=B442949 1A00C14 
vocset=B442949 1A00C14 1A3B438 0 0 5D8F85 4 

set-args0=4 5D8F85 0 0 
begin-package;1A3B450 1A3B474 
serial
1A3B490 1A3B4B4 1A3B4DC 1A3B500 purpose: Driver for NS16550A UART chip which relies on 16550 package support

\ Please Note:  This driver is NOT suitable for a stand-alone FCode ROM.
\ The code relies on a 16550 package and has a selftest method.

hex
headers

" serial" name			\ Name of device for identification
1A3B480 	73 65 72 69 61 6C  0 6E 
1A3B488 	61 6D 65 84 74 B4 A3  1 
1A3B490 	BC 13 A2  1 14  0  0  0 
1A3B498 	 7  0  0  0 
" serial" device-type		\ Device class
1A3B49C 	73 65 72 69 
1A3B4A0 	61 6C  0  0 64 65 76 69 
1A3B4A8 	63 65 5F 74 79 70 65 8B 
1A3B4B0 	90 B4 A3  1 BC 13 A2  1 
1A3B4B8 	1C  0  0  0  7  0  0  0 
" pnpPNP,501" " compatible" string-property
1A3B4C0 	70 6E 70 50 4E 50 2C 35 
1A3B4C8 	30 31  0  0  0 63 6F 6D 
1A3B4D0 	70 61 74 69 62 6C 65 8A 
1A3B4D8 	B4 B4 A3  1 BC 13 A2  1 
1A3B4E0 	20  0  0  0  B  0  0  0 

\ This can be overridden if necessary by redefining this property value
\ after loading this file.
d# 1843200 " clock-frequency" integer-property
1A3B4E8 	 0 1C 20  0 

\ The UART chip occupies 8 bytes of IO space beginning at its base address

my-address my-space  8 reg	\ Report address space used by device
1A3B4EC 	 0  0  0  1 
1A3B4F0 	 0  0  2 F8  0  0  0  8 
1A3B4F8 	72 65 67 83 DC B4 A3  1 
1A3B500 	BC 13 A2  1 18  0  0  0 
1A3B508 	 C  0  0  0 

0 instance value support-ih	\ ihandle of 16550 supprt package
1A3B50C 	 0 73 75 70 
1A3B510 	70 6F 72 74 2D 69 68 8A 
1A3B518 	 0  0 A0  1 C0 FE A1  1 
1A3B520 	18  0  0  0 
variable refcount  0 refcount !
1A3B524 	 0  0  0 72 
1A3B528 	65 66 63 6F 75 6E 74 88 
1A3B530 	1C B5 A3  1 48 40 A0  1 
1A3B538 	18  C  0  0 

0 value break?			\ Shared between all instances
1A3B53C 	 0 62 72 65 
1A3B540 	61 6B 3F 86 34 B5 A3  1 
1A3B548 	50 40 A0  1 1C  C  0  0 

external
: $call-support  ( ... $ -- ... )  support-ih $call-method  ;
1A3B550 	 0  0 24 63 61 6C 6C 2D 
1A3B558 	73 75 70 70 6F 72 74 8D 
1A3B560 	48 B5 A3  1 20 40 A0  1 
1A3B568 	1C B5 A3  1 B4 31 A2  1 
1A3B570 	58 46 A0  1 

0 instance value base-adr
1A3B574 	 0  0  0 62 
1A3B578 	61 73 65 2D 61 64 72 88 
1A3B580 	64 B5 A3  1 C0 FE A1  1 
1A3B588 	1C  0  0  0 

: set-break  ( -- )  true to break?  ;
1A3B58C 	 0  0 73 65 
1A3B590 	74 2D 62 72 65 61 6B 89 
1A3B598 	84 B5 A3  1 20 40 A0  1 
1A3B5A0 	 4 70 A0  1 B8 40 A0  1 
1A3B5A8 	48 B5 A3  1 58 46 A0  1 
: get-break  ( -- flag )  break?  dup  if  false to break?  then  ;
1A3B5B0 	 0  0 67 65 74 2D 62 72 
1A3B5B8 	65 61 6B 89 9C B5 A3  1 
1A3B5C0 	20 40 A0  1 48 B5 A3  1 
1A3B5C8 	40 49 A0  1 DC 41 A0  1 
1A3B5D0 	10  0  0  0 18 70 A0  1 
1A3B5D8 	B8 40 A0  1 48 B5 A3  1 
1A3B5E0 	58 46 A0  1 

headers
\ Map the device into virtual address space
: map-uart  ( -- )   my-unit  8  " map-in"  $call-parent to base-adr  ;
1A3B5E4 	 0  0  0 6D 
1A3B5E8 	61 70 2D 75 61 72 74 88 
1A3B5F0 	C0 B5 A3  1 20 40 A0  1 
1A3B5F8 	70 10 A2  1 F0 6F A0  1 
1A3B600 	9C 53 A0  1  6 6D 61 70 
1A3B608 	2D 69 6E  0 DC 31 A2  1 
1A3B610 	48 B8 A1  1 84 B5 A3  1 
1A3B618 	58 46 A0  1 

\ Release the mapping resources used by the device.
: unmap-uart  ( -- )  base-adr 8  " map-out" $call-parent  ;
1A3B61C 	 0 75 6E 6D 
1A3B620 	61 70 2D 75 61 72 74 8A 
1A3B628 	F4 B5 A3  1 20 40 A0  1 
1A3B630 	84 B5 A3  1 F0 6F A0  1 
1A3B638 	9C 53 A0  1  7 6D 61 70 
1A3B640 	2D 6F 75 74  0  0  0  0 
1A3B648 	DC 31 A2  1 58 46 A0  1 

external

: rts-dtr-off    ( -- )  " rts-dtr-off"   $call-support  ;
1A3B650 	72 74 73 2D 64 74 72 2D 
1A3B658 	6F 66 66 8B 2C B6 A3  1 
1A3B660 	20 40 A0  1 9C 53 A0  1 
1A3B668 	 B 72 74 73 2D 64 74 72 
1A3B670 	2D 6F 66 66  0  0  0  0 
1A3B678 	64 B5 A3  1 58 46 A0  1 
: rts-dtr-on     ( -- )  " rts-dtr-on"    $call-support  ;
1A3B680 	 0 72 74 73 2D 64 74 72 
1A3B688 	2D 6F 6E 8A 60 B6 A3  1 
1A3B690 	20 40 A0  1 9C 53 A0  1 
1A3B698 	 A 72 74 73 2D 64 74 72 
1A3B6A0 	2D 6F 6E  0 64 B5 A3  1 
1A3B6A8 	58 46 A0  1 
: use-irqs       ( -- )  " use-irqs"      $call-support  ;
1A3B6AC 	 0  0  0 75 
1A3B6B0 	73 65 2D 69 72 71 73 88 
1A3B6B8 	90 B6 A3  1 20 40 A0  1 
1A3B6C0 	9C 53 A0  1  8 75 73 65 
1A3B6C8 	2D 69 72 71 73  0  0  0 
1A3B6D0 	64 B5 A3  1 58 46 A0  1 
: use-polling    ( -- )  " use-polling"   $call-support  ;
1A3B6D8 	75 73 65 2D 70 6F 6C 6C 
1A3B6E0 	69 6E 67 8B BC B6 A3  1 
1A3B6E8 	20 40 A0  1 9C 53 A0  1 
1A3B6F0 	 B 75 73 65 2D 70 6F 6C 
1A3B6F8 	6C 69 6E 67  0  0  0  0 
1A3B700 	64 B5 A3  1 58 46 A0  1 
: install-abort  ( -- )  " install-abort" $call-support  ;
1A3B708 	 0  0 69 6E 73 74 61 6C 
1A3B710 	6C 2D 61 62 6F 72 74 8D 
1A3B718 	E8 B6 A3  1 20 40 A0  1 
1A3B720 	9C 53 A0  1  D 69 6E 73 
1A3B728 	74 61 6C 6C 2D 61 62 6F 
1A3B730 	72 74  0  0 64 B5 A3  1 
1A3B738 	58 46 A0  1 
: remove-abort   ( -- )  " remove-abort"  $call-support  ;
1A3B73C 	 0  0  0 72 
1A3B740 	65 6D 6F 76 65 2D 61 62 
1A3B748 	6F 72 74 8C 1C B7 A3  1 
1A3B750 	20 40 A0  1 9C 53 A0  1 
1A3B758 	 C 72 65 6D 6F 76 65 2D 
1A3B760 	61 62 6F 72 74  0  0  0 
1A3B768 	64 B5 A3  1 58 46 A0  1 

: read   ( adr len -- actual )  " read"   $call-support  ;
1A3B770 	 0  0  0 72 65 61 64 84 
1A3B778 	50 B7 A3  1 20 40 A0  1 
1A3B780 	9C 53 A0  1  4 72 65 61 
1A3B788 	64  0  0  0 64 B5 A3  1 
1A3B790 	58 46 A0  1 
: write  ( adr len -- actual )  " write"  $call-support  ;
1A3B794 	 0  0 77 72 
1A3B798 	69 74 65 85 7C B7 A3  1 
1A3B7A0 	20 40 A0  1 9C 53 A0  1 
1A3B7A8 	 5 77 72 69 74 65  0  0 
1A3B7B0 	64 B5 A3  1 58 46 A0  1 

: open  ( -- flag )
1A3B7B8 	 0  0  0 6F 70 65 6E 84 
1A3B7C0 	A0 B7 A3  1 20 40 A0  1 
   map-uart
1A3B7C8 	F4 B5 A3  1 
   my-args " 16550" $open-package  to support-ih
1A3B7CC 	10  7 A2  1 
1A3B7D0 	9C 53 A0  1  5 31 36 35 
1A3B7D8 	35 30  0  0 80 3A A2  1 
1A3B7E0 	48 B8 A1  1 1C B5 A3  1 
   support-ih 0=  if  unmap-uart false  exit  then
1A3B7E8 	1C B5 A3  1 24 47 A0  1 
1A3B7F0 	DC 41 A0  1 10  0  0  0 
1A3B7F8 	2C B6 A3  1 18 70 A0  1 
1A3B800 	40 46 A0  1 
   refcount @ 1+  refcount !
1A3B804 	34 B5 A3  1 
1A3B808 	5C 4C A0  1 30 4B A0  1 
1A3B810 	34 B5 A3  1 54 4D A0  1 
   true
1A3B818 	 4 70 A0  1 
;
1A3B81C 	58 46 A0  1 

: close  ( -- )
1A3B820 	 0  0 63 6C 6F 73 65 85 
1A3B828 	C4 B7 A3  1 20 40 A0  1 
   support-ih close-package
1A3B830 	1C B5 A3  1 A4 36 A2  1 
   unmap-uart
1A3B838 	2C B6 A3  1 
   refcount @ 1-  0 max  refcount !
1A3B83C 	34 B5 A3  1 
1A3B840 	5C 4C A0  1 54 4B A0  1 
1A3B848 	70 6F A0  1 9C 4A A0  1 
1A3B850 	34 B5 A3  1 54 4D A0  1 
;
1A3B858 	58 46 A0  1 

: selftest  ( -- 0 )		\ Test device by sending a bunch of characters
1A3B85C 	 0  0  0 73 
1A3B860 	65 6C 66 74 65 73 74 88 
1A3B868 	2C B8 A3  1 20 40 A0  1 
   refcount @  if  ." Device in use" cr 0 exit  then
1A3B870 	34 B5 A3  1 5C 4C A0  1 
1A3B878 	DC 41 A0  1 24  0  0  0 
1A3B880 	20 7C A0  1  D 44 65 76 
1A3B888 	69 63 65 20 69 6E 20 75 
1A3B890 	73 65  0  0 80 6D A0  1 
1A3B898 	70 6F A0  1 40 46 A0  1 
   open 0=  if  ." Device won't open" cr true exit  then
1A3B8A0 	C4 B7 A3  1 24 47 A0  1 
1A3B8A8 	DC 41 A0  1 28  0  0  0 
1A3B8B0 	20 7C A0  1 11 44 65 76 
1A3B8B8 	69 63 65 20 77 6F 6E 27 
1A3B8C0 	74 20 6F 70 65 6E  0  0 
1A3B8C8 	80 6D A0  1  4 70 A0  1 
1A3B8D0 	40 46 A0  1 
   " selftest" $call-support  close   0
1A3B8D4 	9C 53 A0  1 
1A3B8D8 	 8 73 65 6C 66 74 65 73 
1A3B8E0 	74  0  0  0 64 B5 A3  1 
1A3B8E8 	2C B8 A3  1 70 6F A0  1 
;
1A3B8F0 	58 46 A0  1 

headers

OpenFirmware/dev/16550pkg/ns16550p.fth_AL	474 1A3B8F4 
99D8844   F8 02 00 00  00 00 00 00  00 00 00 00  01 00 00 00 ...............
99D8854   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................purpose: Extract actual interrupt value from property

hex
external
: irq#  ( -- irq )
1A3B8F4 	 0  0  0 69 
1A3B8F8 	72 71 23 84 6C B8 A3  1 
1A3B900 	20 40 A0  1 
   " interrupts" get-my-property  if
1A3B904 	9C 53 A0  1 
1A3B908 	 A 69 6E 74 65 72 72 75 
1A3B910 	70 74 73  0 1C 34 A2  1 
1A3B918 	DC 41 A0  1 34  0  0  0 
      ." Missing interrupts property" cr
1A3B920 	20 7C A0  1 1B 4D 69 73 
1A3B928 	73 69 6E 67 20 69 6E 74 
1A3B930 	65 72 72 75 70 74 73 20 
1A3B938 	70 72 6F 70 65 72 74 79 
1A3B940 	 0  0  0  0 80 6D A0  1 
      0 exit
1A3B948 	70 6F A0  1 40 46 A0  1 
   then                ( adr len )
   get-encoded-int     ( irq )
1A3B950 	A0 F7 A1  1 
;
1A3B954 	58 46 A0  1 
headers
end-package
1A3B958 	F8  2  0  0  0  0  0  0 
1A3B960 	 0  0  0  0  1  0  0  0 
1A3B968 	 0  0  0  0  0  0  0  0 
1A3B970 	 0  0  0  0  0  0  0  0 

OpenFirmware/dev/16550pkg/isa-int.fth_AL	84 1A3B978 
begin-package
select-dev=</isa>0 0 5D9187 3 

propset=1A3B9AC B4429C6 1A00C60 
vocset=B4429C6 1A00C60 1A3B9AC 
new-node=B4429DA 1A00C40 
vocset=B4429DA 1A00C40 1A3B9AC 0 0 5D9187 3 

set-args0=3 5D9187 0 0 
begin-package;1A3B9CC 
8042
1A3B9E8 1A3BA0C 1A3BA4C 1A3BA78 1A3BA9C 1A3BABC purpose: Driver for 8042 PC keyboard/mouse controller

headerless

" INTC,80c42" model
" 8042"       device-name
1A3B9D8 	38 30 34 32  0  0  0 6E 
1A3B9E0 	61 6D 65 84 CC B9 A3  1 
1A3B9E8 	BC 13 A2  1 14  0  0  0 
1A3B9F0 	 5  0  0  0 
" 8042"       device-type
1A3B9F4 	38 30 34 32 
1A3B9F8 	 0  0  0  0 64 65 76 69 
1A3BA00 	63 65 5F 74 79 70 65 8B 
1A3BA08 	E8 B9 A3  1 BC 13 A2  1 
1A3BA10 	1C  0  0  0  5  0  0  0 

0 0 encode-bytes
   " ps2-keyboard-controller" encode-string encode+
1A3BA18 	70 73 32 2D 6B 65 79 62 
1A3BA20 	6F 61 72 64 2D 63 6F 6E 
1A3BA28 	74 72 6F 6C 6C 65 72  0 
   " INTC,80c42"              encode-string encode+
1A3BA30 	49 4E 54 43 2C 38 30 63 
1A3BA38 	34 32  0 
" compatible" property
1A3BA3B 	 0  0 63 6F 6D 
1A3BA40 	70 61 74 69 62 6C 65 8A 
1A3BA48 	 C BA A3  1 BC 13 A2  1 
1A3BA50 	38  0  0  0 23  0  0  0 

my-address      my-space  1  encode-reg
1A3BA58 	 0  0  0  1  0  0  0 60 
1A3BA60 	 0  0  0  1 
my-address 4 +  my-space  1  encode-reg  encode+
1A3BA64 	 0  0  0  1 
1A3BA68 	 0  0  0 64  0  0  0  1 
" reg" property
1A3BA70 	72 65 67 83 4C BA A3  1 
1A3BA78 	BC 13 A2  1 24  0  0  0 
1A3BA80 	18  0  0  0 

1 " #address-cells"  integer-property
1A3BA84 	 0  0  0  1 
1A3BA88 	 0 23 61 64 64 72 65 73 
1A3BA90 	73 2D 63 65 6C 6C 73 8E 
1A3BA98 	78 BA A3  1 BC 13 A2  1 
1A3BAA0 	1C  0  0  0  4  0  0  0 
0 " #size-cells"     integer-property
1A3BAA8 	 0  0  0  0 23 73 69 7A 
1A3BAB0 	65 2D 63 65 6C 6C 73 8B 
1A3BAB8 	9C BA A3  1 BC 13 A2  1 
1A3BAC0 	18  0  0  0  4  0  0  0 

0 value debug?
1A3BAC8 	 0 64 65 62 75 67 3F 86 
1A3BAD0 	 0  0 A0  1 50 40 A0  1 
1A3BAD8 	44  C  0  0 
also forth definitions
: debug-ps2    ( -- )  true  to debug?  ;
1A3BADC 	 0  0 64 65 
1A3BAE0 	62 75 67 2D 70 73 32 89 
1A3BAE8 	84 B9 A3  1 20 40 A0  1 
1A3BAF0 	 4 70 A0  1 B8 40 A0  1 
1A3BAF8 	D4 BA A3  1 58 46 A0  1 
: undebug-ps2  ( -- )  false to debug?  ;
1A3BB00 	75 6E 64 65 62 75 67 2D 
1A3BB08 	70 73 32 8B EC BA A3  1 
1A3BB10 	20 40 A0  1 18 70 A0  1 
1A3BB18 	B8 40 A0  1 D4 BA A3  1 
1A3BB20 	58 46 A0  1 
previous definitions

hex

[ifndef] $=
: $=   rot tuck <> if  3drop false exit  then  comp 0=  ; 
[then]

\ 0 means the keyboard port, 1 means the aux port
: encode-unit  ( n -- adr len )  if  " aux"  else  " kbd"  then  ;
1A3BB24 	65 6E 63 6F 
1A3BB28 	64 65 2D 75 6E 69 74 8B 
1A3BB30 	D4 BA A3  1 20 40 A0  1 
1A3BB38 	DC 41 A0  1 18  0  0  0 
1A3BB40 	9C 53 A0  1  3 61 75 78 
1A3BB48 	 0  0  0  0 C8 41 A0  1 
1A3BB50 	10  0  0  0 9C 53 A0  1 
1A3BB58 	 3 6B 62 64  0  0  0  0 
1A3BB60 	58 46 A0  1 
: decode-unit  ( adr len -- n )
1A3BB64 	64 65 63 6F 
1A3BB68 	64 65 2D 75 6E 69 74 8B 
1A3BB70 	34 BB A3  1 20 40 A0  1 
   2dup  $number  if                        ( adr len )
1A3BB78 	C0 49 A0  1 40 FE A0  1 
1A3BB80 	DC 41 A0  1 38  0  0  0 
      " aux"  $=  0=  if  0  else  1  then  ( n )
1A3BB88 	9C 53 A0  1  3 61 75 78 
1A3BB90 	 0  0  0  0 88 8D A0  1 
1A3BB98 	24 47 A0  1 DC 41 A0  1 
1A3BBA0 	10  0  0  0 70 6F A0  1 
1A3BBA8 	C8 41 A0  1  8  0  0  0 
1A3BBB0 	80 6F A0  1 
   else                                     ( adr len n )
1A3BBB4 	C8 41 A0  1 
1A3BBB8 	 C  0  0  0 
      nip nip                               ( n )
1A3BBBC 	FC 46 A0  1 
1A3BBC0 	FC 46 A0  1 
   then
;
1A3BBC4 	58 46 A0  1 

\ Queues for distributing bytes sent from the two devices
d# 100 constant /q
1A3BBC8 	 0 2F 71 82 74 BB A3  1 
1A3BBD0 	68 40 A0  1 64  0  0  0 

struct
/n field >head
1A3BBD8 	 0  0 3E 68 65 61 64 85 
1A3BBE0 	D0 BB A3  1 50 EE A0  1 
1A3BBE8 	 0  0  0  0 
/n field >tail
1A3BBEC 	 0  0 3E 74 
1A3BBF0 	61 69 6C 85 E4 BB A3  1 
1A3BBF8 	50 EE A0  1  4  0  0  0 
/q field >qdata
1A3BC00 	 0 3E 71 64 61 74 61 86 
1A3BC08 	F8 BB A3  1 50 EE A0  1 
1A3BC10 	 8  0  0  0 
constant /qstruct
1A3BC14 	 0  0  0 2F 
1A3BC18 	71 73 74 72 75 63 74 88 
1A3BC20 	 C BC A3  1 68 40 A0  1 
1A3BC28 	6C  0  0  0 

/qstruct buffer: q0
1A3BC2C 	 0 71 30 82 
1A3BC30 	24 BC A3  1 B4 A9 A0  1 
1A3BC38 	48  C  0  0 6C  0  0  0 
1A3BC40 	F0 74 A3  1 
/qstruct buffer: q1
1A3BC44 	 0 71 31 82 
1A3BC48 	34 BC A3  1 B4 A9 A0  1 
1A3BC50 	4C  C  0  0 6C  0  0  0 
1A3BC58 	34 BC A3  1 

: init-q  ( q -- )  0 over >head !  0 swap >tail !   ;
1A3BC5C 	 0 69 6E 69 
1A3BC60 	74 2D 71 86 4C BC A3  1 
1A3BC68 	20 40 A0  1 70 6F A0  1 
1A3BC70 	54 49 A0  1 E4 BB A3  1 
1A3BC78 	54 4D A0  1 70 6F A0  1 
1A3BC80 	68 49 A0  1 F8 BB A3  1 
1A3BC88 	54 4D A0  1 58 46 A0  1 
: inc-q-ptr  ( pointer-addr -- )
1A3BC90 	 0  0 69 6E 63 2D 71 2D 
1A3BC98 	70 74 72 89 68 BC A3  1 
1A3BCA0 	20 40 A0  1 
   dup @  ca1+  dup /q  =  if  drop 0  then  swap !
1A3BCA4 	40 49 A0  1 
1A3BCA8 	5C 4C A0  1 78 50 A0  1 
1A3BCB0 	40 49 A0  1 D0 BB A3  1 
1A3BCB8 	24 48 A0  1 DC 41 A0  1 
1A3BCC0 	 C  0  0  0 30 49 A0  1 
1A3BCC8 	70 6F A0  1 68 49 A0  1 
1A3BCD0 	54 4D A0  1 
;
1A3BCD4 	58 46 A0  1 

\ This is only called for the queue opposite from "port"
: enque  ( new-entry q -- )
1A3BCD8 	 0  0 65 6E 71 75 65 85 
1A3BCE0 	A0 BC A3  1 20 40 A0  1 
   >r
1A3BCE8 	BC 45 A0  1 
   r@ >tail @  r@ >head @  2dup >  if  - /q  then  1-     ( entry tail head )
1A3BCEC 	E4 45 A0  1 
1A3BCF0 	F8 BB A3  1 5C 4C A0  1 
1A3BCF8 	E4 45 A0  1 E4 BB A3  1 
1A3BD00 	5C 4C A0  1 C0 49 A0  1 
1A3BD08 	 4 48 A0  1 DC 41 A0  1 
1A3BD10 	 C  0  0  0 18 45 A0  1 
1A3BD18 	D0 BB A3  1 54 4B A0  1 
   <>  if  r@ >qdata  r@ >tail @ ca+ c!  r@ >tail inc-q-ptr  else  drop  then
1A3BD20 	44 48 A0  1 DC 41 A0  1 
1A3BD28 	34  0  0  0 E4 45 A0  1 
1A3BD30 	 C BC A3  1 E4 45 A0  1 
1A3BD38 	F8 BB A3  1 5C 4C A0  1 
1A3BD40 	 4 50 A0  1 B8 4D A0  1 
1A3BD48 	E4 45 A0  1 F8 BB A3  1 
1A3BD50 	A0 BC A3  1 C8 41 A0  1 
1A3BD58 	 8  0  0  0 30 49 A0  1 
   r> drop
1A3BD60 	D0 45 A0  1 30 49 A0  1 
;
1A3BD68 	58 46 A0  1 

\ This is only called for the queue for "port"
: deque?  ( q -- false | entry true )
1A3BD6C 	 0 64 65 71 
1A3BD70 	75 65 3F 86 E4 BC A3  1 
1A3BD78 	20 40 A0  1 
   >r
1A3BD7C 	BC 45 A0  1 
   r@ >head @  r@ >tail @  <>  if
1A3BD80 	E4 45 A0  1 E4 BB A3  1 
1A3BD88 	5C 4C A0  1 E4 45 A0  1 
1A3BD90 	F8 BB A3  1 5C 4C A0  1 
1A3BD98 	44 48 A0  1 DC 41 A0  1 
1A3BDA0 	38  0  0  0 
      r@ >qdata  r@ >head @  ca+ c@  r@ >head inc-q-ptr  true
1A3BDA4 	E4 45 A0  1 
1A3BDA8 	 C BC A3  1 E4 45 A0  1 
1A3BDB0 	E4 BB A3  1 5C 4C A0  1 
1A3BDB8 	 4 50 A0  1 C4 4C A0  1 
1A3BDC0 	E4 45 A0  1 E4 BB A3  1 
1A3BDC8 	A0 BC A3  1  4 70 A0  1 
   else
1A3BDD0 	C8 41 A0  1  8  0  0  0 
      false
1A3BDD8 	18 70 A0  1 
   then
   r> drop
1A3BDDC 	D0 45 A0  1 
1A3BDE0 	30 49 A0  1 
;
1A3BDE4 	58 46 A0  1 

0 instance value port
1A3BDE8 	 0  0  0 70 6F 72 74 84 
1A3BDF0 	78 BD A3  1 C0 FE A1  1 
1A3BDF8 	18  0  0  0 

0 value data-port
1A3BDFC 	 0  0 64 61 
1A3BE00 	74 61 2D 70 6F 72 74 89 
1A3BE08 	F4 BD A3  1 50 40 A0  1 
1A3BE10 	50  C  0  0 
0 value cmd-status-reg
1A3BE14 	 0 63 6D 64 
1A3BE18 	2D 73 74 61 74 75 73 2D 
1A3BE20 	72 65 67 8E  C BE A3  1 
1A3BE28 	50 40 A0  1 54  C  0  0 


\ Keyboard controller command constants
\  a7 constant disable-aux
\  aa constant selftest
\  ab constant intf-test
\  ad constant disable-intf
\  ae constant enable-intf
\  d0 constant read-out-port
\  d1 constant write-out-port

\ Keyboard controller status constants
   01 constant out-buf-full
1A3BE30 	 0  0  0 6F 75 74 2D 62 
1A3BE38 	75 66 2D 66 75 6C 6C 8C 
1A3BE40 	28 BE A3  1 68 40 A0  1 
1A3BE48 	 1  0  0  0 
   02 constant in-buf-full
1A3BE4C 	69 6E 2D 62 
1A3BE50 	75 66 2D 66 75 6C 6C 8B 
1A3BE58 	44 BE A3  1 68 40 A0  1 
1A3BE60 	 2  0  0  0 
  out-buf-full in-buf-full +
      constant io-bufs-full
1A3BE64 	 0  0  0 69 
1A3BE68 	6F 2D 62 75 66 73 2D 66 
1A3BE70 	75 6C 6C 8C 5C BE A3  1 
1A3BE78 	68 40 A0  1  3  0  0  0 
\  40 constant general-timeout
\  80 constant parity-error
\  55 constant passed

\ Output port constants
\  c0 constant clk-data-high
 
headers
: set-port  ( port# -- )  to port  ;
1A3BE80 	 0  0  0 73 65 74 2D 70 
1A3BE88 	6F 72 74 88 78 BE A3  1 
1A3BE90 	20 40 A0  1 48 B8 A1  1 
1A3BE98 	F4 BD A3  1 58 46 A0  1 
headerless

: stat@  ( -- byte )  cmd-status-reg rb@  ;
1A3BEA0 	 0  0 73 74 61 74 40 85 
1A3BEA8 	90 BE A3  1 20 40 A0  1 
1A3BEB0 	28 BE A3  1 A8 B1 A2  1 
1A3BEB8 	58 46 A0  1 
: data@  ( -- byte )  data-port rb@  debug?  if  ." <" dup .  then  ;
1A3BEBC 	 0  0 64 61 
1A3BEC0 	74 61 40 85 AC BE A3  1 
1A3BEC8 	20 40 A0  1  C BE A3  1 
1A3BED0 	A8 B1 A2  1 D4 BA A3  1 
1A3BED8 	DC 41 A0  1 14  0  0  0 
1A3BEE0 	20 7C A0  1  1 3C  0  0 
1A3BEE8 	40 49 A0  1 94 7A A0  1 
1A3BEF0 	58 46 A0  1 
: data!  ( byte -- )  debug?  if  ." >" dup .  then   data-port rb!  ;
1A3BEF4 	 0  0 64 61 
1A3BEF8 	74 61 21 85 C8 BE A3  1 
1A3BF00 	20 40 A0  1 D4 BA A3  1 
1A3BF08 	DC 41 A0  1 14  0  0  0 
1A3BF10 	20 7C A0  1  1 3E  0  0 
1A3BF18 	40 49 A0  1 94 7A A0  1 
1A3BF20 	 C BE A3  1 1C B2 A2  1 
1A3BF28 	58 46 A0  1 

\ *** Following delay can be reduced after testing ***

: in-wait  ( -- ) \ Wait for input buffer to empty
1A3BF2C 	69 6E 2D 77 
1A3BF30 	61 69 74 87  0 BF A3  1 
1A3BF38 	20 40 A0  1 
   d# 1000 0  do
1A3BF3C 	58 41 A0  1 
1A3BF40 	E8  3  0  0 70 6F A0  1 
1A3BF48 	88 42 A0  1 34  0  0  0 
      stat@  in-buf-full and 0=  if  unloop exit  then
1A3BF50 	AC BE A3  1 5C BE A3  1 
1A3BF58 	5C 44 A0  1 24 47 A0  1 
1A3BF60 	DC 41 A0  1  C  0  0  0 
1A3BF68 	3C 42 A0  1 40 46 A0  1 
      1 ms
1A3BF70 	80 6F A0  1 60 E0 A1  1 
   loop
1A3BF78 	F8 41 A0  1 D4 FF FF FF 
   true abort" Keyboard input buffer full timeout"
1A3BF80 	 4 70 A0  1  8 81 A0  1 
1A3BF88 	22 4B 65 79 62 6F 61 72 
1A3BF90 	64 20 69 6E 70 75 74 20 
1A3BF98 	62 75 66 66 65 72 20 66 
1A3BFA0 	75 6C 6C 20 74 69 6D 65 
1A3BFA8 	6F 75 74  0 
;
1A3BFAC 	58 46 A0  1 

: (get-data?)  ( -- false | data true )
1A3BFB0 	28 67 65 74 2D 64 61 74 
1A3BFB8 	61 3F 29 8B 38 BF A3  1 
1A3BFC0 	20 40 A0  1 
   \ Exit immediately if a byte is waiting
   port  if  q1  else  q0  then  deque?  if  true exit  then
1A3BFC4 	F4 BD A3  1 
1A3BFC8 	DC 41 A0  1 10  0  0  0 
1A3BFD0 	4C BC A3  1 C8 41 A0  1 
1A3BFD8 	 8  0  0  0 34 BC A3  1 
1A3BFE0 	78 BD A3  1 DC 41 A0  1 
1A3BFE8 	 C  0  0  0  4 70 A0  1 
1A3BFF0 	40 46 A0  1 

   begin
      stat@  dup out-buf-full and                        ( stat flag )
1A3BFF4 	AC BE A3  1 
1A3BFF8 	40 49 A0  1 44 BE A3  1 
1A3C000 	5C 44 A0  1 
   while                                                 ( stat )
1A3C004 	DC 41 A0  1 
1A3C008 	54  0  0  0 
      data@  swap                                        ( data stat )
1A3C00C 	C8 BE A3  1 
1A3C010 	68 49 A0  1 
      5 >>  port  =  if  true  exit  then
1A3C014 	C0 6F A0  1 
1A3C018 	DC 44 A0  1 F4 BD A3  1 
1A3C020 	24 48 A0  1 DC 41 A0  1 
1A3C028 	 C  0  0  0  4 70 A0  1 
1A3C030 	40 46 A0  1 
      port  if  q0  else  q1  then  enque
1A3C034 	F4 BD A3  1 
1A3C038 	DC 41 A0  1 10  0  0  0 
1A3C040 	34 BC A3  1 C8 41 A0  1 
1A3C048 	 8  0  0  0 4C BC A3  1 
1A3C050 	E4 BC A3  1 
   repeat                                                ( stat )
1A3C054 	C8 41 A0  1 
1A3C058 	9C FF FF FF 
   drop  false
1A3C05C 	30 49 A0  1 
1A3C060 	18 70 A0  1 
;
1A3C064 	58 46 A0  1 

true value data-port-available?
1A3C068 	 0  0  0 64 61 74 61 2D 
1A3C070 	70 6F 72 74 2D 61 76 61 
1A3C078 	69 6C 61 62 6C 65 3F 94 
1A3C080 	C0 BF A3  1 50 40 A0  1 
1A3C088 	58  C  0  0 
headers
: get-data?  ( -- false | data true )
1A3C08C 	 0  0 67 65 
1A3C090 	74 2D 64 61 74 61 3F 89 
1A3C098 	84 C0 A3  1 20 40 A0  1 
   data-port-available?  if			( )
1A3C0A0 	84 C0 A3  1 DC 41 A0  1 
1A3C0A8 	28  0  0  0 
      false to data-port-available?		( )
1A3C0AC 	18 70 A0  1 
1A3C0B0 	B8 40 A0  1 84 C0 A3  1 
      (get-data?)			        ( false | data true )
1A3C0B8 	C0 BF A3  1 
      true to data-port-available?		( )
1A3C0BC 	 4 70 A0  1 
1A3C0C0 	B8 40 A0  1 84 C0 A3  1 
   else						( )
1A3C0C8 	C8 41 A0  1  8  0  0  0 
      false					( false )
1A3C0D0 	18 70 A0  1 
   then						( false | data true )
;
1A3C0D4 	58 46 A0  1 

: get-data  ( -- data | -1 )  \ Wait for data from our device
1A3C0D8 	 0  0  0 67 65 74 2D 64 
1A3C0E0 	61 74 61 88 9C C0 A3  1 
1A3C0E8 	20 40 A0  1 
   d# 1000 0  do
1A3C0EC 	58 41 A0  1 
1A3C0F0 	E8  3  0  0 70 6F A0  1 
1A3C0F8 	88 42 A0  1 28  0  0  0 
      get-data?  if  unloop exit  then		( data )
1A3C100 	9C C0 A3  1 DC 41 A0  1 
1A3C108 	 C  0  0  0 3C 42 A0  1 
1A3C110 	40 46 A0  1 
      1 ms
1A3C114 	80 6F A0  1 
1A3C118 	60 E0 A1  1 
   loop
1A3C11C 	F8 41 A0  1 
1A3C120 	E0 FF FF FF 
   true \ abort" Timeout waiting for data from device" 
1A3C124 	 4 70 A0  1 
;
1A3C128 	58 46 A0  1 
headerless

: put-ctlr-cmd   ( cmd -- )
1A3C12C 	 0  0  0 70 
1A3C130 	75 74 2D 63 74 6C 72 2D 
1A3C138 	63 6D 64 8C E8 C0 A3  1 
1A3C140 	20 40 A0  1 
   in-wait  debug?  if  ." ^" dup .  then  cmd-status-reg rb!
1A3C144 	38 BF A3  1 
1A3C148 	D4 BA A3  1 DC 41 A0  1 
1A3C150 	14  0  0  0 20 7C A0  1 
1A3C158 	 1 5E  0  0 40 49 A0  1 
1A3C160 	94 7A A0  1 28 BE A3  1 
1A3C168 	1C B2 A2  1 
;
1A3C16C 	58 46 A0  1 

headers
: put-data  ( data -- )
1A3C170 	 0  0  0 70 75 74 2D 64 
1A3C178 	61 74 61 88 40 C1 A3  1 
1A3C180 	20 40 A0  1 
   port  if
1A3C184 	F4 BD A3  1 
1A3C188 	DC 41 A0  1 28  0  0  0 
      lock[ h# d4 put-ctlr-cmd  in-wait  data! ]unlock
1A3C190 	84 E0 A1  1 58 41 A0  1 
1A3C198 	D4  0  0  0 40 C1 A3  1 
1A3C1A0 	38 BF A3  1  0 BF A3  1 
1A3C1A8 	98 E0 A1  1 
   else
1A3C1AC 	C8 41 A0  1 
1A3C1B0 	 C  0  0  0 
      in-wait  data!
1A3C1B4 	38 BF A3  1 
1A3C1B8 	 0 BF A3  1 
   then
;
1A3C1BC 	58 46 A0  1 

headerless
: put-ctlr-cmd2  ( data cmd -- )  put-ctlr-cmd  put-data   ;
1A3C1C0 	 0  0 70 75 74 2D 63 74 
1A3C1C8 	6C 72 2D 63 6D 64 32 8D 
1A3C1D0 	80 C1 A3  1 20 40 A0  1 
1A3C1D8 	40 C1 A3  1 80 C1 A3  1 
1A3C1E0 	58 46 A0  1 

headers
: put-get-data  ( cmd -- data | -1 )  put-data get-data  ;
1A3C1E4 	 0  0  0 70 
1A3C1E8 	75 74 2D 67 65 74 2D 64 
1A3C1F0 	61 74 61 8C D4 C1 A3  1 
1A3C1F8 	20 40 A0  1 80 C1 A3  1 
1A3C200 	E8 C0 A3  1 58 46 A0  1 

\ Wait until the device stops sending data
: clear-out-buf  ( -- )  begin  d# 120 ms  get-data?  while  drop  repeat  ;
1A3C208 	 0  0 63 6C 65 61 72 2D 
1A3C210 	6F 75 74 2D 62 75 66 8D 
1A3C218 	F8 C1 A3  1 20 40 A0  1 
1A3C220 	58 41 A0  1 78  0  0  0 
1A3C228 	60 E0 A1  1 9C C0 A3  1 
1A3C230 	DC 41 A0  1 10  0  0  0 
1A3C238 	30 49 A0  1 C8 41 A0  1 
1A3C240 	E0 FF FF FF 58 46 A0  1 
headerless

: disable-intf  ( -- )  h# ad put-ctlr-cmd  ;
1A3C248 	 0  0  0 64 69 73 61 62 
1A3C250 	6C 65 2D 69 6E 74 66 8C 
1A3C258 	1C C2 A3  1 20 40 A0  1 
1A3C260 	58 41 A0  1 AD  0  0  0 
1A3C268 	40 C1 A3  1 58 46 A0  1 
: enable-intf   ( -- )  h# ae put-ctlr-cmd  ;
1A3C270 	65 6E 61 62 6C 65 2D 69 
1A3C278 	6E 74 66 8B 5C C2 A3  1 
1A3C280 	20 40 A0  1 58 41 A0  1 
1A3C288 	AE  0  0  0 40 C1 A3  1 
1A3C290 	58 46 A0  1 

: (ctlr-cmd)  ( cmd -- data | -1 )
1A3C294 	 0 28 63 74 
1A3C298 	6C 72 2D 63 6D 64 29 8A 
1A3C2A0 	80 C2 A3  1 20 40 A0  1 
   \ Controller commands return data as though it were from the keyboard port
   port >r  0 to port
1A3C2A8 	F4 BD A3  1 BC 45 A0  1 
1A3C2B0 	70 6F A0  1 48 B8 A1  1 
1A3C2B8 	F4 BD A3  1 
   put-ctlr-cmd get-data
1A3C2BC 	40 C1 A3  1 
1A3C2C0 	E8 C0 A3  1 
   r> to port
1A3C2C4 	D0 45 A0  1 
1A3C2C8 	48 B8 A1  1 F4 BD A3  1 
;
1A3C2D0 	58 46 A0  1 

: cmd-reg!  ( b -- )  h# 60 put-ctlr-cmd2  ;
1A3C2D4 	 0  0  0 63 
1A3C2D8 	6D 64 2D 72 65 67 21 88 
1A3C2E0 	A4 C2 A3  1 20 40 A0  1 
1A3C2E8 	58 41 A0  1 60  0  0  0 
1A3C2F0 	D4 C1 A3  1 58 46 A0  1 
: cmd-reg@  ( -- b )  h# 20 (ctlr-cmd)  ;
1A3C2F8 	 0  0  0 63 6D 64 2D 72 
1A3C300 	65 67 40 88 E4 C2 A3  1 
1A3C308 	20 40 A0  1 58 41 A0  1 
1A3C310 	20  0  0  0 A4 C2 A3  1 
1A3C318 	58 46 A0  1 

\ Enable and disable scan set translation
: translation-on   ( -- )  cmd-reg@  h# 40 or          cmd-reg!  ;
1A3C31C 	 0 74 72 61 
1A3C320 	6E 73 6C 61 74 69 6F 6E 
1A3C328 	2D 6F 6E 8E  8 C3 A3  1 
1A3C330 	20 40 A0  1  8 C3 A3  1 
1A3C338 	58 41 A0  1 40  0  0  0 
1A3C340 	70 44 A0  1 E4 C2 A3  1 
1A3C348 	58 46 A0  1 
: translation-off  ( -- )  cmd-reg@  h# 40 invert and  cmd-reg!  ;
1A3C34C 	74 72 61 6E 
1A3C350 	73 6C 61 74 69 6F 6E 2D 
1A3C358 	6F 66 66 8F 30 C3 A3  1 
1A3C360 	20 40 A0  1  8 C3 A3  1 
1A3C368 	58 41 A0  1 40  0  0  0 
1A3C370 	30 45 A0  1 5C 44 A0  1 
1A3C378 	E4 C2 A3  1 58 46 A0  1 

: ctlr-cmd1  ( cmd -- data )
1A3C380 	 0  0 63 74 6C 72 2D 63 
1A3C388 	6D 64 31 89 60 C3 A3  1 
1A3C390 	20 40 A0  1 
   \ Enable keyboard translate mode, enable aux device, enable
   \ keyboard, set system flag, disable aux and keyboard interrupts
   disable-intf  (ctlr-cmd)  h# 44 cmd-reg!  enable-intf
1A3C394 	5C C2 A3  1 
1A3C398 	A4 C2 A3  1 58 41 A0  1 
1A3C3A0 	44  0  0  0 E4 C2 A3  1 
1A3C3A8 	80 C2 A3  1 
;
1A3C3AC 	58 46 A0  1 
   
\ This takes 160 msecs on an IBM keyboard circa 1994
: ctlr-selftest  ( -- fail? )
1A3C3B0 	 0  0 63 74 6C 72 2D 73 
1A3C3B8 	65 6C 66 74 65 73 74 8D 
1A3C3C0 	90 C3 A3  1 20 40 A0  1 
   h# aa ctlr-cmd1  ( data )
1A3C3C8 	58 41 A0  1 AA  0  0  0 
1A3C3D0 	90 C3 A3  1 
   begin  h# 55 =  if  false exit  then  get-data? 0=  until
1A3C3D4 	58 41 A0  1 
1A3C3D8 	55  0  0  0 24 48 A0  1 
1A3C3E0 	DC 41 A0  1  C  0  0  0 
1A3C3E8 	18 70 A0  1 40 46 A0  1 
1A3C3F0 	9C C0 A3  1 24 47 A0  1 
1A3C3F8 	DC 41 A0  1 D8 FF FF FF 
   true exit
1A3C400 	 4 70 A0  1 40 46 A0  1 
;
1A3C408 	58 46 A0  1 

: ack-reset  ( -- )
1A3C40C 	 0  0 61 63 
1A3C410 	6B 2D 72 65 73 65 74 89 
1A3C418 	C4 C3 A3  1 20 40 A0  1 
   \ Release the clock and data lines to acknowledge the ACK.
   \ This appears to be keyboard-specific; I find no mention
   \ of such a requirement for the mouse reset sequence.
   h# c0  h# d1  put-ctlr-cmd2
1A3C420 	58 41 A0  1 C0  0  0  0 
1A3C428 	58 41 A0  1 D1  0  0  0 
1A3C430 	D4 C1 A3  1 
   clear-out-buf
1A3C434 	1C C2 A3  1 
;
1A3C438 	58 46 A0  1 

: (test-lines)  ( -- error? )
1A3C43C 	 0  0  0 28 
1A3C440 	74 65 73 74 2D 6C 69 6E 
1A3C448 	65 73 29 8C 1C C4 A3  1 
1A3C450 	20 40 A0  1 
   port  if  h# a9  else  h# ab  then      ( kbd-or-aux-interface-test-code )
1A3C454 	F4 BD A3  1 
1A3C458 	DC 41 A0  1 14  0  0  0 
1A3C460 	58 41 A0  1 A9  0  0  0 
1A3C468 	C8 41 A0  1  C  0  0  0 
1A3C470 	58 41 A0  1 AB  0  0  0 
   ctlr-cmd1
1A3C478 	90 C3 A3  1 
   d# 20 ms		\ Recovery time
1A3C47C 	58 41 A0  1 
1A3C480 	14  0  0  0 60 E0 A1  1 
;
1A3C488 	58 46 A0  1 
headers
: test-lines  ( -- error? )
1A3C48C 	 0 74 65 73 
1A3C490 	74 2D 6C 69 6E 65 73 8A 
1A3C498 	50 C4 A3  1 20 40 A0  1 
  (test-lines)  0=  if  false exit  then
1A3C4A0 	50 C4 A3  1 24 47 A0  1 
1A3C4A8 	DC 41 A0  1  C  0  0  0 
1A3C4B0 	18 70 A0  1 40 46 A0  1 
  \ Retry in case we are not in sync with the keyboard
  (test-lines) enable-intf  dup 0=  if  exit  then    ( error-code )
1A3C4B8 	50 C4 A3  1 80 C2 A3  1 
1A3C4C0 	40 49 A0  1 24 47 A0  1 
1A3C4C8 	DC 41 A0  1  8  0  0  0 
1A3C4D0 	40 46 A0  1 
   ." Failed keyboard interface test" cr
1A3C4D4 	20 7C A0  1 
1A3C4D8 	1E 46 61 69 6C 65 64 20 
1A3C4E0 	6B 65 79 62 6F 61 72 64 
1A3C4E8 	20 69 6E 74 65 72 66 61 
1A3C4F0 	63 65 20 74 65 73 74  0 
1A3C4F8 	80 6D A0  1 
   case
      1  of  " low"  " Clock"  endof
1A3C4FC 	80 6F A0  1 
1A3C500 	48 43 A0  1 24  0  0  0 
1A3C508 	9C 53 A0  1  3 6C 6F 77 
1A3C510 	 0  0  0  0 9C 53 A0  1 
1A3C518 	 5 43 6C 6F 63 6B  0  0 
1A3C520 	6C 43 A0  1 A0  0  0  0 
      2  of  " high" " Clock"  endof
1A3C528 	90 6F A0  1 48 43 A0  1 
1A3C530 	24  0  0  0 9C 53 A0  1 
1A3C538 	 4 68 69 67 68  0  0  0 
1A3C540 	9C 53 A0  1  5 43 6C 6F 
1A3C548 	63 6B  0  0 6C 43 A0  1 
1A3C550 	74  0  0  0 
      3  of  " low"  " Data"   endof
1A3C554 	A0 6F A0  1 
1A3C558 	48 43 A0  1 24  0  0  0 
1A3C560 	9C 53 A0  1  3 6C 6F 77 
1A3C568 	 0  0  0  0 9C 53 A0  1 
1A3C570 	 4 44 61 74 61  0  0  0 
1A3C578 	6C 43 A0  1 48  0  0  0 
      4  of  " high" " Data"   endof
1A3C580 	B0 6F A0  1 48 43 A0  1 
1A3C588 	24  0  0  0 9C 53 A0  1 
1A3C590 	 4 68 69 67 68  0  0  0 
1A3C598 	9C 53 A0  1  4 44 61 74 
1A3C5A0 	61  0  0  0 6C 43 A0  1 
1A3C5A8 	1C  0  0  0 
      \ This probably means that we are out-of-sync with the keyboard
      >r " ?" 2dup  r>
1A3C5AC 	BC 45 A0  1 
1A3C5B0 	9C 53 A0  1  1 3F  0  0 
1A3C5B8 	C0 49 A0  1 D0 45 A0  1 
   endcase
1A3C5C0 	84 43 A0  1 
   ." The keyboard '" type  ." ' line is stuck " type  ." ."  cr
1A3C5C4 	20 7C A0  1 
1A3C5C8 	 E 54 68 65 20 6B 65 79 
1A3C5D0 	62 6F 61 72 64 20 27  0 
1A3C5D8 	 4 6C A0  1 20 7C A0  1 
1A3C5E0 	10 27 20 6C 69 6E 65 20 
1A3C5E8 	69 73 20 73 74 75 63 6B 
1A3C5F0 	20  0  0  0  4 6C A0  1 
1A3C5F8 	20 7C A0  1  1 2E  0  0 
1A3C600 	80 6D A0  1 
   false
1A3C604 	18 70 A0  1 
;
1A3C608 	58 46 A0  1 
headerless
0 value open-count
1A3C60C 	 0 6F 70 65 
1A3C610 	6E 2D 63 6F 75 6E 74 8A 
1A3C618 	9C C4 A3  1 50 40 A0  1 
1A3C620 	5C  C  0  0 
headers
: open  ( -- flag? )
1A3C624 	 0  0  0 6F 
1A3C628 	70 65 6E 84 1C C6 A3  1 
1A3C630 	20 40 A0  1 
   open-count 1+ to open-count
1A3C634 	1C C6 A3  1 
1A3C638 	30 4B A0  1 B8 40 A0  1 
1A3C640 	1C C6 A3  1 
   data-port 0=  if
1A3C644 	 C BE A3  1 
1A3C648 	24 47 A0  1 DC 41 A0  1 
1A3C650 	9C  0  0  0 
      my-address my-space  5  " map-in" $call-parent  is data-port
1A3C654 	20 10 A2  1 
1A3C658 	AC  3 A2  1 C0 6F A0  1 
1A3C660 	9C 53 A0  1  6 6D 61 70 
1A3C668 	2D 69 6E  0 DC 31 A2  1 
1A3C670 	B8 40 A0  1  C BE A3  1 
      data-port 4 + is cmd-status-reg
1A3C678 	 C BE A3  1 B0 6F A0  1 
1A3C680 	 4 45 A0  1 B8 40 A0  1 
1A3C688 	28 BE A3  1 

      ctlr-selftest  if
1A3C68C 	C4 C3 A3  1 
1A3C690 	DC 41 A0  1 48  0  0  0 
         ctlr-selftest  if	\ Retry in case we're out of sync
1A3C698 	C4 C3 A3  1 DC 41 A0  1 
1A3C6A0 	3C  0  0  0 
            ." Failed keyboard controller self test" cr
1A3C6A4 	20 7C A0  1 
1A3C6A8 	24 46 61 69 6C 65 64 20 
1A3C6B0 	6B 65 79 62 6F 61 72 64 
1A3C6B8 	20 63 6F 6E 74 72 6F 6C 
1A3C6C0 	6C 65 72 20 73 65 6C 66 
1A3C6C8 	20 74 65 73 74  0  0  0 
1A3C6D0 	80 6D A0  1 
            false exit
1A3C6D4 	18 70 A0  1 
1A3C6D8 	40 46 A0  1 
         then
      then
      q0 init-q  q1 init-q
1A3C6DC 	34 BC A3  1 
1A3C6E0 	68 BC A3  1 4C BC A3  1 
1A3C6E8 	68 BC A3  1 
   then
   true
1A3C6EC 	 4 70 A0  1 
;
1A3C6F0 	58 46 A0  1 
: close  ( -- )
1A3C6F4 	 0  0 63 6C 
1A3C6F8 	6F 73 65 85 30 C6 A3  1 
1A3C700 	20 40 A0  1 
   open-count 1- 0 max to open-count
1A3C704 	1C C6 A3  1 
1A3C708 	54 4B A0  1 70 6F A0  1 
1A3C710 	9C 4A A0  1 B8 40 A0  1 
1A3C718 	1C C6 A3  1 
   open-count 0=  if
1A3C71C 	1C C6 A3  1 
1A3C720 	24 47 A0  1 DC 41 A0  1 
1A3C728 	38  0  0  0 
      data-port 5 " map-out" $call-parent
1A3C72C 	 C BE A3  1 
1A3C730 	C0 6F A0  1 9C 53 A0  1 
1A3C738 	 7 6D 61 70 2D 6F 75 74 
1A3C740 	 0  0  0  0 DC 31 A2  1 
      0 to data-port
1A3C748 	70 6F A0  1 B8 40 A0  1 
1A3C750 	 C BE A3  1 
      0 to cmd-status-reg
1A3C754 	70 6F A0  1 
1A3C758 	B8 40 A0  1 28 BE A3  1 
   then
;
1A3C760 	58 46 A0  1 

OpenFirmware/dev/i8042.fth_AL	D8C 1A3C764 
propset=1A3C778 B442AAE 1A00CA0 
vocset=B442AAE 1A00CA0 1A3C778 
new-node=B442AC2 1A00C80 
vocset=B442AC2 1A00C80 1A3C778 
set-args0=1 5D9187 0 5D9086 1A3C784 
keyboard
1A3C7A4 1A3C7CC 1A3C7F4 
vocset=5D8818 1A00CF0 1A3D0D4 purpose: Package methods for 80C42 keyboard controller

\ " us" d# 16 config-string pc-keyboard-type

hex
headerless

my-space " reg" integer-property
1A3C778 	 0  0  0  0 72 65 67 83 
1A3C780 	 0  0 A0  1 BC 13 A2  1 
1A3C788 	10  0  0  0  4  0  0  0 
" keyboard"  device-name
1A3C790 	6B 65 79 62 6F 61 72 64 
1A3C798 	 0  0  0 6E 61 6D 65 84 
1A3C7A0 	84 C7 A3  1 BC 13 A2  1 
1A3C7A8 	18  0  0  0  9  0  0  0 

" pnpPNP,303" " compatible" string-property
1A3C7B0 	70 6E 70 50 4E 50 2C 33 
1A3C7B8 	30 33  0  0  0 63 6F 6D 
1A3C7C0 	70 61 74 69 62 6C 65 8A 
1A3C7C8 	A4 C7 A3  1 BC 13 A2  1 
1A3C7D0 	20  0  0  0  B  0  0  0 

" keyboard" device-type
1A3C7D8 	6B 65 79 62 6F 61 72 64 
1A3C7E0 	 0  0  0  0 64 65 76 69 
1A3C7E8 	63 65 5F 74 79 70 65 8B 
1A3C7F0 	CC C7 A3  1 BC 13 A2  1 
1A3C7F8 	20  0  0  0  9  0  0  0 

: kbdtest ;
1A3C800 	6B 62 64 74 65 73 74 87 
1A3C808 	 0  0 A0  1 20 40 A0  1 
1A3C810 	58 46 A0  1 

0 value #queued
1A3C814 	23 71 75 65 
1A3C818 	75 65 64 87  C C8 A3  1 
1A3C820 	50 40 A0  1 84  C  0  0 
d# 4 buffer: ascii-queue
1A3C828 	61 73 63 69 69 2D 71 75 
1A3C830 	65 75 65 8B 20 C8 A3  1 
1A3C838 	B4 A9 A0  1 88  C  0  0 
1A3C840 	 4  0  0  0 4C BC A3  1 

\ Keyboard command constants
\  ed constant set-leds
\  ee constant echo
\  f0 constant set-scan-codes
\  f2 constant read-id
\  f4 constant enable-scan
\  f5 constant default-disable
\  f6 constant default-enable
\  ff constant reset

\ Keyboard status constants
\  fa constant ack
\  aa constant bat-pass
\  fc constant bat-fail
\  ee constant echo
\  fe constant resend

\ Various keyboard flags
false value check-abort?	\ True to abort on CTRL-BREAK
1A3C848 	 0  0  0 63 68 65 63 6B 
1A3C850 	2D 61 62 6F 72 74 3F 8C 
1A3C858 	38 C8 A3  1 50 40 A0  1 
1A3C860 	8C  C  0  0 
0 value last-scan		\ Memory for detecting up transitions
1A3C864 	 0  0 6C 61 
1A3C868 	73 74 2D 73 63 61 6E 89 
1A3C870 	5C C8 A3  1 50 40 A0  1 
1A3C878 	90  C  0  0 

false value keyboard-probed?      \ Used to identify whether keyboard methods
1A3C87C 	 0  0  0 6B 
1A3C880 	65 79 62 6F 61 72 64 2D 
1A3C888 	70 72 6F 62 65 64 3F 90 
1A3C890 	74 C8 A3  1 50 40 A0  1 
1A3C898 	94  C  0  0 
				  \ have already been installed
false value keyboard-present?     \ Nonzero if the keyboard is operational
1A3C89C 	 0  0 6B 65 
1A3C8A0 	79 62 6F 61 72 64 2D 70 
1A3C8A8 	72 65 73 65 6E 74 3F 91 
1A3C8B0 	94 C8 A3  1 50 40 A0  1 
1A3C8B8 	98  C  0  0 
false value locked?		  \ Interrupt lockout for get-scan
1A3C8BC 	6C 6F 63 6B 
1A3C8C0 	65 64 3F 87 B4 C8 A3  1 
1A3C8C8 	50 40 A0  1 9C  C  0  0 

: lock    ( -- )  true  to locked?  ;
1A3C8D0 	 0  0  0 6C 6F 63 6B 84 
1A3C8D8 	C8 C8 A3  1 20 40 A0  1 
1A3C8E0 	 4 70 A0  1 B8 40 A0  1 
1A3C8E8 	C8 C8 A3  1 58 46 A0  1 
: unlock  ( -- )  false to locked?  ;
1A3C8F0 	 0 75 6E 6C 6F 63 6B 86 
1A3C8F8 	DC C8 A3  1 20 40 A0  1 
1A3C900 	18 70 A0  1 B8 40 A0  1 
1A3C908 	C8 C8 A3  1 58 46 A0  1 

\ Scan code queue
d# 100 constant /q
1A3C910 	 0 2F 71 82 FC C8 A3  1 
1A3C918 	68 40 A0  1 64  0  0  0 

variable head  0 head !
1A3C920 	 0  0  0 68 65 61 64 84 
1A3C928 	18 C9 A3  1 48 40 A0  1 
1A3C930 	A0  C  0  0 
variable tail  0 tail !
1A3C934 	 0  0  0 74 
1A3C938 	61 69 6C 84 2C C9 A3  1 
1A3C940 	48 40 A0  1 A4  C  0  0 
/q dup buffer: q
1A3C948 	 0  0 71 81 40 C9 A3  1 
1A3C950 	B4 A9 A0  1 A8  C  0  0 
1A3C958 	64  0  0  0 38 C8 A3  1 
1-     value   q-end
1A3C960 	 0  0 71 2D 65 6E 64 85 
1A3C968 	50 C9 A3  1 50 40 A0  1 
1A3C970 	AC  C  0  0 

: init-q  ( -- )  0 head !  0 tail !  q drop  /q 1- to q-end  ;
1A3C974 	 0 69 6E 69 
1A3C978 	74 2D 71 86 6C C9 A3  1 
1A3C980 	20 40 A0  1 70 6F A0  1 
1A3C988 	2C C9 A3  1 54 4D A0  1 
1A3C990 	70 6F A0  1 40 C9 A3  1 
1A3C998 	54 4D A0  1 50 C9 A3  1 
1A3C9A0 	30 49 A0  1 18 C9 A3  1 
1A3C9A8 	54 4B A0  1 B8 40 A0  1 
1A3C9B0 	6C C9 A3  1 58 46 A0  1 
: inc-q-ptr  ( pointer-addr -- )
1A3C9B8 	 0  0 69 6E 63 2D 71 2D 
1A3C9C0 	70 74 72 89 80 C9 A3  1 
1A3C9C8 	20 40 A0  1 
   dup @ q-end >=  if  0 swap !  else  /c swap +!  then
1A3C9CC 	40 49 A0  1 
1A3C9D0 	5C 4C A0  1 6C C9 A3  1 
1A3C9D8 	EC 48 A0  1 DC 41 A0  1 
1A3C9E0 	18  0  0  0 70 6F A0  1 
1A3C9E8 	68 49 A0  1 54 4D A0  1 
1A3C9F0 	C8 41 A0  1 10  0  0  0 
1A3C9F8 	10 51 A0  1 68 49 A0  1 
1A3CA00 	 C 4C A0  1 
;
1A3CA04 	58 46 A0  1 

: enque  ( new-entry -- )
1A3CA08 	 0  0 65 6E 71 75 65 85 
1A3CA10 	C8 C9 A3  1 20 40 A0  1 
   tail @  head @  2dup >  if  - q-end  else  1-  then  ( new-entry tail head )
1A3CA18 	40 C9 A3  1 5C 4C A0  1 
1A3CA20 	2C C9 A3  1 5C 4C A0  1 
1A3CA28 	C0 49 A0  1  4 48 A0  1 
1A3CA30 	DC 41 A0  1 14  0  0  0 
1A3CA38 	18 45 A0  1 6C C9 A3  1 
1A3CA40 	C8 41 A0  1  8  0  0  0 
1A3CA48 	54 4B A0  1 
   <>  if  q tail @ ca+ c!  tail inc-q-ptr  else  drop  then
1A3CA4C 	44 48 A0  1 
1A3CA50 	DC 41 A0  1 28  0  0  0 
1A3CA58 	50 C9 A3  1 40 C9 A3  1 
1A3CA60 	5C 4C A0  1  4 50 A0  1 
1A3CA68 	B8 4D A0  1 40 C9 A3  1 
1A3CA70 	C8 C9 A3  1 C8 41 A0  1 
1A3CA78 	 8  0  0  0 30 49 A0  1 
;
1A3CA80 	58 46 A0  1 

: deque?  ( -- false | entry true )
1A3CA84 	 0 64 65 71 
1A3CA88 	75 65 3F 86 14 CA A3  1 
1A3CA90 	20 40 A0  1 
   lock
1A3CA94 	DC C8 A3  1 
   head @  tail @  <>  if
1A3CA98 	2C C9 A3  1 5C 4C A0  1 
1A3CAA0 	40 C9 A3  1 5C 4C A0  1 
1A3CAA8 	44 48 A0  1 DC 41 A0  1 
1A3CAB0 	2C  0  0  0 
      q head @ ca+ c@   head inc-q-ptr  true
1A3CAB4 	50 C9 A3  1 
1A3CAB8 	2C C9 A3  1 5C 4C A0  1 
1A3CAC0 	 4 50 A0  1 C4 4C A0  1 
1A3CAC8 	2C C9 A3  1 C8 C9 A3  1 
1A3CAD0 	 4 70 A0  1 
   else
1A3CAD4 	C8 41 A0  1 
1A3CAD8 	 8  0  0  0 
      false
1A3CADC 	18 70 A0  1 
   then
   unlock
1A3CAE0 	FC C8 A3  1 
;
1A3CAE4 	58 46 A0  1 

false value shift?		\ True if the shift key is down
1A3CAE8 	 0 73 68 69 66 74 3F 86 
1A3CAF0 	90 CA A3  1 50 40 A0  1 
1A3CAF8 	B0  C  0  0 
false value ctrl?	  	\ True if the ctrl key is down
1A3CAFC 	 0  0 63 74 
1A3CB00 	72 6C 3F 85 F4 CA A3  1 
1A3CB08 	50 40 A0  1 B4  C  0  0 
false value mfii?               \ True if MF II extended keys
1A3CB10 	 0  0 6D 66 69 69 3F 85 
1A3CB18 	 8 CB A3  1 50 40 A0  1 
1A3CB20 	B8  C  0  0 
false value alt-gr?		\ True if the AltGr key is down
1A3CB24 	61 6C 74 2D 
1A3CB28 	67 72 3F 87 1C CB A3  1 
1A3CB30 	50 40 A0  1 BC  C  0  0 
-1 value dead-accent            \ The dead accent index (0-5) or -1
1A3CB38 	64 65 61 64 2D 61 63 63 
1A3CB40 	65 6E 74 8B 30 CB A3  1 
1A3CB48 	50 40 A0  1 C0  C  0  0 

0 value led-state
1A3CB50 	 0  0 6C 65 64 2D 73 74 
1A3CB58 	61 74 65 89 48 CB A3  1 
1A3CB60 	50 40 A0  1 C4  C  0  0 
: numlk?        ( -- flag )  led-state 2 and  0<>  ;
1A3CB68 	 0 6E 75 6D 6C 6B 3F 86 
1A3CB70 	60 CB A3  1 20 40 A0  1 
1A3CB78 	60 CB A3  1 90 6F A0  1 
1A3CB80 	5C 44 A0  1 44 47 A0  1 
1A3CB88 	58 46 A0  1 
: caps-lock?    ( -- flag )  led-state 4 and  0<>  ;
1A3CB8C 	 0 63 61 70 
1A3CB90 	73 2D 6C 6F 63 6B 3F 8A 
1A3CB98 	74 CB A3  1 20 40 A0  1 
1A3CBA0 	60 CB A3  1 B0 6F A0  1 
1A3CBA8 	5C 44 A0  1 44 47 A0  1 
1A3CBB0 	58 46 A0  1 
: scroll-lock?  ( -- flag )  led-state 1 and  0<>  ;
1A3CBB4 	 0  0  0 73 
1A3CBB8 	63 72 6F 6C 6C 2D 6C 6F 
1A3CBC0 	63 6B 3F 8C 9C CB A3  1 
1A3CBC8 	20 40 A0  1 60 CB A3  1 
1A3CBD0 	80 6F A0  1 5C 44 A0  1 
1A3CBD8 	44 47 A0  1 58 46 A0  1 

: init-data  ( -- )
1A3CBE0 	 0  0 69 6E 69 74 2D 64 
1A3CBE8 	61 74 61 89 C8 CB A3  1 
1A3CBF0 	20 40 A0  1 
   false to keyboard-present?
1A3CBF4 	18 70 A0  1 
1A3CBF8 	B8 40 A0  1 B4 C8 A3  1 
   false to shift?   false to ctrl?
1A3CC00 	18 70 A0  1 B8 40 A0  1 
1A3CC08 	F4 CA A3  1 18 70 A0  1 
1A3CC10 	B8 40 A0  1  8 CB A3  1 
   0 to last-scan
1A3CC18 	70 6F A0  1 B8 40 A0  1 
1A3CC20 	74 C8 A3  1 
   init-q
1A3CC24 	80 C9 A3  1 
;   
1A3CC28 	58 46 A0  1 

\ Frequently-used interfaces to parent (8042 controller) routines

: get-data   ( -- data | -1 )  " get-data" $call-parent  ;
1A3CC2C 	 0  0  0 67 
1A3CC30 	65 74 2D 64 61 74 61 88 
1A3CC38 	F0 CB A3  1 20 40 A0  1 
1A3CC40 	9C 53 A0  1  8 67 65 74 
1A3CC48 	2D 64 61 74 61  0  0  0 
1A3CC50 	DC 31 A2  1 58 46 A0  1 
: get-data?  ( -- false | data true )  " get-data?" $call-parent  ;
1A3CC58 	 0  0 67 65 74 2D 64 61 
1A3CC60 	74 61 3F 89 3C CC A3  1 
1A3CC68 	20 40 A0  1 9C 53 A0  1 
1A3CC70 	 9 67 65 74 2D 64 61 74 
1A3CC78 	61 3F  0  0 DC 31 A2  1 
1A3CC80 	58 46 A0  1 
: put-get-data  ( cmd -- data | -1 )  " put-get-data" $call-parent  ;
1A3CC84 	 0  0  0 70 
1A3CC88 	75 74 2D 67 65 74 2D 64 
1A3CC90 	61 74 61 8C 68 CC A3  1 
1A3CC98 	20 40 A0  1 9C 53 A0  1 
1A3CCA0 	 C 70 75 74 2D 67 65 74 
1A3CCA8 	2D 64 61 74 61  0  0  0 
1A3CCB0 	DC 31 A2  1 58 46 A0  1 

: clear-out-buf  ( -- )  " clear-out-buf" $call-parent  ;
1A3CCB8 	 0  0 63 6C 65 61 72 2D 
1A3CCC0 	6F 75 74 2D 62 75 66 8D 
1A3CCC8 	98 CC A3  1 20 40 A0  1 
1A3CCD0 	9C 53 A0  1  D 63 6C 65 
1A3CCD8 	61 72 2D 6F 75 74 2D 62 
1A3CCE0 	75 66  0  0 DC 31 A2  1 
1A3CCE8 	58 46 A0  1 

: timed-read  ( #ms -- true | data false )
1A3CCEC 	 0 74 69 6D 
1A3CCF0 	65 64 2D 72 65 61 64 8A 
1A3CCF8 	CC CC A3  1 20 40 A0  1 
   0  do
1A3CD00 	70 6F A0  1 88 42 A0  1 
1A3CD08 	2C  0  0  0 
      get-data?  if  unloop false exit  then
1A3CD0C 	68 CC A3  1 
1A3CD10 	DC 41 A0  1 10  0  0  0 
1A3CD18 	3C 42 A0  1 18 70 A0  1 
1A3CD20 	40 46 A0  1 
      1 ms
1A3CD24 	80 6F A0  1 
1A3CD28 	60 E0 A1  1 
   loop
1A3CD2C 	F8 41 A0  1 
1A3CD30 	DC FF FF FF 
   true
1A3CD34 	 4 70 A0  1 
;
1A3CD38 	58 46 A0  1 

0 value kbd-debug?
1A3CD3C 	 0 6B 62 64 
1A3CD40 	2D 64 65 62 75 67 3F 8A 
1A3CD48 	FC CC A3  1 50 40 A0  1 
1A3CD50 	C8  C  0  0 

\ This is fairly complicated to handle several possibilities.
\ In the usual case, where the response is ACK (fa), we return true on the top
\ Another case is a RETRY (fe) response - then we return "false false" so the
\ caller will continue to retry as long as we keep seeing RETRY.
\ Bytes that are neither fa nor fe are silently discarded.
\ If we timeout without seeing either fa or fe, we return "true false" so the
\ caller will retry a limited number of times before giving up.

: got-ack?  ( -- true | timeout? false )
1A3CD54 	 0  0  0 67 
1A3CD58 	6F 74 2D 61 63 6B 3F 88 
1A3CD60 	4C CD A3  1 20 40 A0  1 
   begin
      \ No response - retry once
      d# 50 timed-read  if  true false exit  then  ( data )
1A3CD68 	58 41 A0  1 32  0  0  0 
1A3CD70 	FC CC A3  1 DC 41 A0  1 
1A3CD78 	10  0  0  0  4 70 A0  1 
1A3CD80 	18 70 A0  1 40 46 A0  1 
      case
         h# fa of        true  exit  endof  \ ACK - exit without retry
1A3CD88 	58 41 A0  1 FA  0  0  0 
1A3CD90 	48 43 A0  1 14  0  0  0 
1A3CD98 	 4 70 A0  1 40 46 A0  1 
1A3CDA0 	6C 43 A0  1 2C  0  0  0 
         h# fe of  false false exit  endof  \ RETRY - retry as long as we keep getting fe
1A3CDA8 	58 41 A0  1 FE  0  0  0 
1A3CDB0 	48 43 A0  1 18  0  0  0 
1A3CDB8 	18 70 A0  1 18 70 A0  1 
1A3CDC0 	40 46 A0  1 6C 43 A0  1 
1A3CDC8 	 8  0  0  0 
         \ discard other characters
      endcase
1A3CDCC 	84 43 A0  1 
   again
1A3CDD0 	C8 41 A0  1 94 FF FF FF 
;
1A3CDD8 	58 46 A0  1 

: cmd  ( cmd -- )
1A3CDDC 	63 6D 64 83 
1A3CDE0 	64 CD A3  1 20 40 A0  1 
   1  begin                                 ( cmd #retries )
1A3CDE8 	80 6F A0  1 
      over  " put-data" $call-parent        ( cmd #retries )
1A3CDEC 	54 49 A0  1 
1A3CDF0 	9C 53 A0  1  8 70 75 74 
1A3CDF8 	2D 64 61 74 61  0  0  0 
1A3CE00 	DC 31 A2  1 
      got-ack?  if  2drop exit  then        ( cmd #retries timeout? )
1A3CE04 	64 CD A3  1 
1A3CE08 	DC 41 A0  1  C  0  0  0 
1A3CE10 	AC 49 A0  1 40 46 A0  1 

      \ Decrease the retry count if got-ack? timed out
      \ Otherwise got-ack? saw a RETRY response, in which case
      \ we retry without decrementing the count
      if  1-  then                          ( cmd #retries )
1A3CE18 	DC 41 A0  1  8  0  0  0 
1A3CE20 	54 4B A0  1 

   dup 0<  until                            ( cmd #retries )
1A3CE24 	40 49 A0  1 
1A3CE28 	64 47 A0  1 DC 41 A0  1 
1A3CE30 	BC FF FF FF 

   drop                                     ( cmd )
1A3CE34 	30 49 A0  1 
   kbd-debug?  if                           ( cmd )
1A3CE38 	4C CD A3  1 DC 41 A0  1 
1A3CE40 	34  0  0  0 
      ." Keyboard cmd " . ." failed" cr     ( )
1A3CE44 	20 7C A0  1 
1A3CE48 	 D 4B 65 79 62 6F 61 72 
1A3CE50 	64 20 63 6D 64 20  0  0 
1A3CE58 	94 7A A0  1 20 7C A0  1 
1A3CE60 	 6 66 61 69 6C 65 64  0 
1A3CE68 	80 6D A0  1 
   else                                     ( cmd )
1A3CE6C 	C8 41 A0  1 
1A3CE70 	 8  0  0  0 
      drop                                  ( )
1A3CE74 	30 49 A0  1 
   then                                     ( )
;
1A3CE78 	58 46 A0  1 

headers

\ Despite the manual's claim that this command can be executed at any time,
\ experience has shown that it does not work reliably.  Executing
\ cntlr-selftest, test-intf and reset seem to prepare the system.
\ kbd-reset (at least sometimes) is not sufficient preparation.
: set-scan-set  ( scan-set -- )  f0 cmd cmd  ;
1A3CE7C 	 0  0  0 73 
1A3CE80 	65 74 2D 73 63 61 6E 2D 
1A3CE88 	73 65 74 8C E4 CD A3  1 
1A3CE90 	20 40 A0  1 58 41 A0  1 
1A3CE98 	F0  0  0  0 E4 CD A3  1 
1A3CEA0 	E4 CD A3  1 58 46 A0  1 

\ The return value is:
\   1, 2, 3	Scan set 1, 2, or 3, h#40 bit in the 8042 cmd register clear
\   43		Scan set 1           h#40 bit set
\   41		Scan set 2           h#40 bit set
\   3f		Scan set 3           h#40 bit set
\ When the h#40 bit is set, the 8042 translates scan set 2 coming from the
\ keyboard to scan set 1 (when read from the 8042).  One might suspect from
\ the above encodings that it might also translate scan set 1 from the keyboard
\ into scan set 3.

: get-scan-set  ( -- scan-set )  lock  0 set-scan-set  get-data  unlock  ;
1A3CEA8 	 0  0  0 67 65 74 2D 73 
1A3CEB0 	63 61 6E 2D 73 65 74 8C 
1A3CEB8 	90 CE A3  1 20 40 A0  1 
1A3CEC0 	DC C8 A3  1 70 6F A0  1 
1A3CEC8 	90 CE A3  1 3C CC A3  1 
1A3CED0 	FC C8 A3  1 58 46 A0  1 

\ Re-initialize the keyboard and controller with the following:
\
\ 1.    Disable keyboard interface.
\ 2.	Perform controller self-test.  Report an error on failure.
\       (Selftest re-enables keyboard interface.)
\ 3.	Perform keyboard interface test.  Report an error on failure.
\ 4.	Reset the keyboard which results in the selection of Scan Set 2.  Report
\	an error on failure.
\ 5.	Perform a keyboard echo.  Report an error on failure.
\ 6.	Flash the three LEDs.

: default-disable-kbd  ( -- )  h# f5 cmd  ;
1A3CED8 	64 65 66 61 75 6C 74 2D 
1A3CEE0 	64 69 73 61 62 6C 65 2D 
1A3CEE8 	6B 62 64 93 BC CE A3  1 
1A3CEF0 	20 40 A0  1 58 41 A0  1 
1A3CEF8 	F5  0  0  0 E4 CD A3  1 
1A3CF00 	58 46 A0  1 
: enable-scan  ( -- )  h# f4 cmd  ;
1A3CF04 	65 6E 61 62 
1A3CF08 	6C 65 2D 73 63 61 6E 8B 
1A3CF10 	F0 CE A3  1 20 40 A0  1 
1A3CF18 	58 41 A0  1 F4  0  0  0 
1A3CF20 	E4 CD A3  1 58 46 A0  1 

\ Empirically, the delays help some keyboards to pass the echo test
: echo?  ( -- failed-echo? )
1A3CF28 	 0  0 65 63 68 6F 3F 85 
1A3CF30 	14 CF A3  1 20 40 A0  1 
   d# 32 ms  h# ee put-get-data h# ee <>  d# 32 ms
1A3CF38 	58 41 A0  1 20  0  0  0 
1A3CF40 	60 E0 A1  1 58 41 A0  1 
1A3CF48 	EE  0  0  0 98 CC A3  1 
1A3CF50 	58 41 A0  1 EE  0  0  0 
1A3CF58 	44 48 A0  1 58 41 A0  1 
1A3CF60 	20  0  0  0 60 E0 A1  1 
;
1A3CF68 	58 46 A0  1 
: set-leds  ( led-mask -- )  lock  dup to led-state h# ed cmd cmd  unlock  ;
1A3CF6C 	 0  0  0 73 
1A3CF70 	65 74 2D 6C 65 64 73 88 
1A3CF78 	34 CF A3  1 20 40 A0  1 
1A3CF80 	DC C8 A3  1 40 49 A0  1 
1A3CF88 	B8 40 A0  1 60 CB A3  1 
1A3CF90 	58 41 A0  1 ED  0  0  0 
1A3CF98 	E4 CD A3  1 E4 CD A3  1 
1A3CFA0 	FC C8 A3  1 58 46 A0  1 
: toggle-leds  ( led-mask -- )  led-state xor  set-leds  ;
1A3CFA8 	74 6F 67 67 6C 65 2D 6C 
1A3CFB0 	65 64 73 8B 7C CF A3  1 
1A3CFB8 	20 40 A0  1 60 CB A3  1 
1A3CFC0 	84 44 A0  1 7C CF A3  1 
1A3CFC8 	58 46 A0  1 

: kbd-reset  ( -- failed-reset? )
1A3CFCC 	 0  0 6B 62 
1A3CFD0 	64 2D 72 65 73 65 74 89 
1A3CFD8 	B8 CF A3  1 20 40 A0  1 
   lock
1A3CFE0 	DC C8 A3  1 
   \ Send kbd reset command
   h# ff cmd
1A3CFE4 	58 41 A0  1 
1A3CFE8 	FF  0  0  0 E4 CD A3  1 
   get-data  h# aa <>
1A3CFF0 	3C CC A3  1 58 41 A0  1 
1A3CFF8 	AA  0  0  0 44 48 A0  1 
   unlock
1A3D000 	FC C8 A3  1 
;
1A3D004 	58 46 A0  1 

: do-esc  ( char -- ESC )
1A3D008 	 0 64 6F 2D 65 73 63 86 
1A3D010 	DC CF A3  1 20 40 A0  1 
\   ascii-queue c!  ascii [ ascii-queue 1+ c!  2 to #queued   h# 1b  ( ESC )
   ascii-queue c!  1 to #queued  h# 9b  ( Unicode-CSI )
1A3D018 	38 C8 A3  1 B8 4D A0  1 
1A3D020 	80 6F A0  1 B8 40 A0  1 
1A3D028 	20 C8 A3  1 58 41 A0  1 
1A3D030 	9B  0  0  0 
;
1A3D034 	58 46 A0  1 
: do-func  ( char -- ESC )
1A3D038 	64 6F 2D 66 75 6E 63 87 
1A3D040 	14 D0 A3  1 20 40 A0  1 
   ascii-queue c!  ascii O ascii-queue 1+ c!  2 to #queued  h# 9b
1A3D048 	38 C8 A3  1 B8 4D A0  1 
1A3D050 	58 41 A0  1 4F  0  0  0 
1A3D058 	38 C8 A3  1 30 4B A0  1 
1A3D060 	B8 4D A0  1 90 6F A0  1 
1A3D068 	B8 40 A0  1 20 C8 A3  1 
1A3D070 	58 41 A0  1 9B  0  0  0 
;
1A3D078 	58 46 A0  1 
\ The following keymaps map scan codes to ASCII codes.  In those cases
\ where the scan code represents a key for which there is no ASCII equivalent,
\ the table contains a 0 byte.  This use of 0 does not prevent the generation
\ ASCII NUL (whose numerical value is 0) because control characters are
\ mostly generated by masking bits off of printable entries.  (The only
\ exceptions are Tab, BackSpace, Escape, and Return, which are the only
\ control characters that are directly generated by single keys on a
\ PC keyboard.)

\ "Syntactic sugar" to make keymaps easier to read and write
: ch  ( "char" -- )  char c,  ;
1A3D07C 	 0 63 68 82 
1A3D080 	44 D0 A3  1 20 40 A0  1 
1A3D088 	58 95 A0  1 B8 55 A0  1 
1A3D090 	58 46 A0  1 
: xx  ( -- )  0 c,  ;
1A3D094 	 0 78 78 82 
1A3D098 	84 D0 A3  1 20 40 A0  1 
1A3D0A0 	70 6F A0  1 B8 55 A0  1 
1A3D0A8 	58 46 A0  1 

0 value keymap  ( -- adr )
1A3D0AC 	 0 6B 65 79 
1A3D0B0 	6D 61 70 86 9C D0 A3  1 
1A3D0B8 	50 40 A0  1 CC  C  0  0 
h# 60 3 * 1+ constant /keymap  \ The maximum size of a keymap
1A3D0C0 	2F 6B 65 79 6D 61 70 87 
1A3D0C8 	B8 D0 A3  1 68 40 A0  1 
1A3D0D0 	21  1  0  0 

vocabulary keyboards
1A3D0D4 	 0  0 6B 65 
1A3D0D8 	79 62 6F 61 72 64 73 89 
1A3D0E0 	CC D0 A3  1 E0 B6 A0  1 
1A3D0E8 	D0  C  0  0 6C 6B A3  1 
1A3D0F0 	 0  0  0  0 

also keyboards definitions
create us
1A3D0F4 	 0 75 73 82 
1A3D0F8 	 0  0 A0  1 30 40 A0  1 
   ch E  ch N  \ Language
1A3D100 	45 4E 
   2 c,  \ #submaps
1A3D102 	 2 
\ Unshifted
  (  0 )   xx     1b c,  ch 1   ch 2   ch 3   ch 4   ch 5   ch 6
1A3D103 	 0 1B 31 32 33 
1A3D108 	34 35 36 
  (  8 )   ch 7   ch 8   ch 9   ch 0   ch -   ch =    8 c,   9 c,
1A3D10B 	37 38 39 30 2D 
1A3D110 	3D  8  9 
  ( 10 )   ch q   ch w   ch e   ch r   ch t   ch y   ch u   ch i
1A3D113 	71 77 65 72 74 
1A3D118 	79 75 69 
  ( 18 )   ch o   ch p   ch [   ch ]    d c,   2 c,  ch a   ch s
1A3D11B 	6F 70 5B 5D  D 
1A3D120 	 2 61 73 
  ( 20 )   ch d   ch f   ch g   ch h   ch j   ch k   ch l   ch ;
1A3D123 	64 66 67 68 6A 
1A3D128 	6B 6C 3B 
  ( 28 )   ch '   ch `    1 c,  ch \   ch z   ch x   ch c   ch v
1A3D12B 	27 60  1 5C 7A 
1A3D130 	78 63 76 
  ( 30 )   ch b   ch n   ch m   ch ,   ch .   ch /    1 c,  ch *
1A3D133 	62 6E 6D 2C 2E 
1A3D138 	2F  1 2A 
  ( 38 )    3 c,  20 c,   4 c,  81 c,  82 c,  83 c,  84 c,  85 c,
1A3D13B 	 3 20  4 81 82 
1A3D140 	83 84 85 
  ( 40 )   86 c,  87 c,  88 c,  89 c,  8a c,   5 c,   6 c,  97 c,
1A3D143 	86 87 88 89 8A 
1A3D148 	 5  6 97 
  ( 48 )   98 c,  99 c,  ch -   94 c,  95 c,  96 c,  ch +   91 c,
1A3D14B 	98 99 2D 94 95 
1A3D150 	96 2B 91 
  ( 50 )   92 c,  93 c,  90 c,  9a c,  xx     xx     ch <   8b c,
1A3D153 	92 93 90 9A  0 
1A3D158 	 0 3C 8B 
  ( 58 )   8c c,  xx     xx     xx     xx     xx     xx     xx
1A3D15B 	8C  0  0  0  0 
1A3D160 	 0  0  0 
\ Shifted
  (  0 )   xx     1b c,  ch !   ch @   ch #   ch $   ch %   ch ^
1A3D163 	 0 1B 21 40 23 
1A3D168 	24 25 5E 
  (  8 )   ch &   ch *   ch (   ch )   ch _   ch +    8 c,   9 c,
1A3D16B 	26 2A 28 29 5F 
1A3D170 	2B  8  9 
  ( 10 )   ch Q   ch W   ch E   ch R   ch T   ch Y   ch U   ch I
1A3D173 	51 57 45 52 54 
1A3D178 	59 55 49 
  ( 18 )   ch O   ch P   ch {   ch }   xx     xx     ch A   ch S
1A3D17B 	4F 50 7B 7D  0 
1A3D180 	 0 41 53 
  ( 20 )   ch D   ch F   ch G   ch H   ch J   ch K   ch L   ch :
1A3D183 	44 46 47 48 4A 
1A3D188 	4B 4C 3A 
  ( 28 )   ch "   ch ~   xx     ch |   ch Z   ch X   ch C   ch V
1A3D18B 	22 7E  0 7C 5A 
1A3D190 	58 43 56 
  ( 30 )   ch B   ch N   ch M   ch <   ch >   ch ?   xx     xx
1A3D193 	42 4E 4D 3C 3E 
1A3D198 	3F  0  0 
  ( 38 )   xx     20 c,  xx     8b c,  8c c,  xx     xx     xx
1A3D19B 	 0 20  0 8B 8C 
1A3D1A0 	 0  0  0 
  ( 40 )   xx     xx     xx     xx     xx     xx     xx     97 c,
1A3D1A3 	 0  0  0  0  0 
1A3D1A8 	 0  0 97 
  ( 48 )   98 c,  99 c,  xx     94 c,  95 c,  96 c,  xx     91 c,
1A3D1AB 	98 99  0 94 95 
1A3D1B0 	96  0 91 
  ( 50 )   92 c,  93 c,  90 c,  9a c,  xx     xx     ch >   8b c,
1A3D1B3 	92 93 90 9A  0 
1A3D1B8 	 0 3E 8B 
  ( 58 )   8c c,  xx     xx     xx     xx     xx     xx     xx
1A3D1BB 	8C  0  0  0  0 
1A3D1C0 	 0  0  0 

previous definitions

: ?set-property  ( value$ name$ -- )
1A3D1C3 	 0  0  0 3F 73 
1A3D1C8 	65 74 2D 70 72 6F 70 65 
1A3D1D0 	72 74 79 8D E4 D0 A3  1 
1A3D1D8 	20 40 A0  1 
   2swap 2over get-my-property  0=  if   ( name$ value$ name$ adr1 len1 )
1A3D1DC 	F4 49 A0  1 
1A3D1E0 	D8 49 A0  1 1C 34 A2  1 
1A3D1E8 	24 47 A0  1 DC 41 A0  1 
1A3D1F0 	24  0  0  0 
      get-encoded-string  2over $=  if   ( name$ value$ )
1A3D1F4 	24 F7 A1  1 
1A3D1F8 	D8 49 A0  1 88 8D A0  1 
1A3D200 	DC 41 A0  1 10  0  0  0 
         2drop 2drop exit                ( )
1A3D208 	AC 49 A0  1 AC 49 A0  1 
1A3D210 	40 46 A0  1 
      then                               ( name$ value$ )
   then                                  ( name$ value$ )
   encode-string 2swap property          ( )
1A3D214 	A0 F6 A1  1 
1A3D218 	F4 49 A0  1 BC 14 A2  1 
;
1A3D220 	58 46 A0  1 
0 instance value oem-keymap
1A3D224 	 0 6F 65 6D 
1A3D228 	2D 6B 65 79 6D 61 70 8A 
1A3D230 	D8 D1 A3  1 C0 FE A1  1 
1A3D238 	18  0  0  0 
: (set-keyboard)  ( adr len xt -- )
1A3D23C 	 0 28 73 65 
1A3D240 	74 2D 6B 65 79 62 6F 61 
1A3D248 	72 64 29 8E 34 D2 A3  1 
1A3D250 	20 40 A0  1 
   -rot                                              ( xt adr len )
1A3D254 	94 49 A0  1 
   " keyboard-type" ?set-property                    ( xt )
1A3D258 	9C 53 A0  1  D 6B 65 79 
1A3D260 	62 6F 61 72 64 2D 74 79 
1A3D268 	70 65  0  0 D8 D1 A3  1 
   execute                                           ( adr )
1A3D270 	98 41 A0  1 
   dup 2 " language" ?set-property                   ( adr )
1A3D274 	40 49 A0  1 
1A3D278 	90 6F A0  1 9C 53 A0  1 
1A3D280 	 8 6C 61 6E 67 75 61 67 
1A3D288 	65  0  0  0 D8 D1 A3  1 
   2+ to keymap                                      ( )
1A3D290 	40 4B A0  1 B8 40 A0  1 
1A3D298 	B8 D0 A3  1 
;
1A3D29C 	58 46 A0  1 
: set-keyboard  ( adr len -- )
1A3D2A0 	 0  0  0 73 65 74 2D 6B 
1A3D2A8 	65 79 62 6F 61 72 64 8C 
1A3D2B0 	50 D2 A3  1 20 40 A0  1 
   2dup ['] keyboards $vfind  0=  if                       ( adr len )
1A3D2B8 	C0 49 A0  1 60 53 A0  1 
1A3D2C0 	E4 D0 A3  1 5C BB A0  1 
1A3D2C8 	24 47 A0  1 DC 41 A0  1 
1A3D2D0 	18  0  0  0 
      2drop " us" [ also keyboards ] ['] us  [ previous ]  ( adr' len' xt )
1A3D2D4 	AC 49 A0  1 
1A3D2D8 	9C 53 A0  1  2 75 73  0 
1A3D2E0 	60 53 A0  1 FC D0 A3  1 
   then                                                    ( adr len xt )
   (set-keyboard)
1A3D2E8 	50 D2 A3  1 
;
1A3D2EC 	58 46 A0  1 
: ?free-keymap  ( -- )
1A3D2F0 	 0  0  0 3F 66 72 65 65 
1A3D2F8 	2D 6B 65 79 6D 61 70 8C 
1A3D300 	B4 D2 A3  1 20 40 A0  1 
   oem-keymap  if  oem-keymap  /keymap  free-mem  then
1A3D308 	34 D2 A3  1 DC 41 A0  1 
1A3D310 	10  0  0  0 34 D2 A3  1 
1A3D318 	CC D0 A3  1  8 6D A0  1 
   0 to oem-keymap
1A3D320 	70 6F A0  1 48 B8 A1  1 
1A3D328 	34 D2 A3  1 
;
1A3D32C 	58 46 A0  1 

: choose-type  ( -- )
1A3D330 	63 68 6F 6F 73 65 2D 74 
1A3D338 	79 70 65 8B  4 D3 A3  1 
1A3D340 	20 40 A0  1 
   my-args  dup  if
1A3D344 	10  7 A2  1 
1A3D348 	40 49 A0  1 DC 41 A0  1 
1A3D350 	28  0  0  0 
      [char] , left-parse-string  2swap 2drop  ( $ )
1A3D354 	58 41 A0  1 
1A3D358 	2C  0  0  0 44 D7 A0  1 
1A3D360 	F4 49 A0  1 AC 49 A0  1 
      set-keyboard
1A3D368 	B4 D2 A3  1 
      exit
1A3D36C 	40 46 A0  1 
   else
1A3D370 	C8 41 A0  1  8  0  0  0 
      2drop
1A3D378 	AC 49 A0  1 
   then

   " pc-keymap" $getenv  0=  if    \ Property exists ( adr len )
1A3D37C 	9C 53 A0  1 
1A3D380 	 9 70 63 2D 6B 65 79 6D 
1A3D388 	61 70  0  0 48 6D A0  1 
1A3D390 	24 47 A0  1 DC 41 A0  1 
1A3D398 	7C  0  0  0 
      decode-string " keyboard-type" ?set-property   ( adr' len' )
1A3D39C 	FC F6 A1  1 
1A3D3A0 	9C 53 A0  1  D 6B 65 79 
1A3D3A8 	62 6F 61 72 64 2D 74 79 
1A3D3B0 	70 65  0  0 D8 D1 A3  1 
      2 decode-bytes " language" ?set-property       ( adr' len' )
1A3D3B8 	90 6F A0  1 68 F6 A1  1 
1A3D3C0 	9C 53 A0  1  8 6C 61 6E 
1A3D3C8 	67 75 61 67 65  0  0  0 
1A3D3D0 	D8 D1 A3  1 
      ?free-keymap
1A3D3D4 	 4 D3 A3  1 
      /keymap alloc-mem to oem-keymap                ( adr' len' )
1A3D3D8 	CC D0 A3  1 F0 6C A0  1 
1A3D3E0 	48 B8 A1  1 34 D2 A3  1 
      oem-keymap /keymap 0 fill                      ( adr' len' )
1A3D3E8 	34 D2 A3  1 CC D0 A3  1 
1A3D3F0 	70 6F A0  1 8C 4E A0  1 
      oem-keymap swap move                           ( )
1A3D3F8 	34 D2 A3  1 68 49 A0  1 
1A3D400 	F4 4A A0  1 
      oem-keymap to keymap                           ( )
1A3D404 	34 D2 A3  1 
1A3D408 	B8 40 A0  1 B8 D0 A3  1 
      exit
1A3D410 	40 46 A0  1 
   then


   " us" set-keyboard
1A3D414 	9C 53 A0  1 
1A3D418 	 2 75 73  0 B4 D2 A3  1 
\    pc-keyboard-type set-keyboard
;
1A3D420 	58 46 A0  1 

: map?  ( scancode map-adr -- scancode false | char true )
1A3D424 	 0  0  0 6D 
1A3D428 	61 70 3F 84 40 D3 A3  1 
1A3D430 	20 40 A0  1 
   >r
1A3D434 	BC 45 A0  1 
   dup  r@ c@  r@ 1+ c@  between  if      ( scancode )
1A3D438 	40 49 A0  1 E4 45 A0  1 
1A3D440 	C4 4C A0  1 E4 45 A0  1 
1A3D448 	30 4B A0  1 C4 4C A0  1 
1A3D450 	D8 70 A0  1 DC 41 A0  1 
1A3D458 	2C  0  0  0 
      r@ c@ -  r> 2+ + c@  true           ( char true )
1A3D45C 	E4 45 A0  1 
1A3D460 	C4 4C A0  1 18 45 A0  1 
1A3D468 	D0 45 A0  1 40 4B A0  1 
1A3D470 	 4 45 A0  1 C4 4C A0  1 
1A3D478 	 4 70 A0  1 
   else                                   ( scancode )
1A3D47C 	C8 41 A0  1 
1A3D480 	10  0  0  0 
      r> drop false
1A3D484 	D0 45 A0  1 
1A3D488 	30 49 A0  1 18 70 A0  1 
   then
;
1A3D490 	58 46 A0  1 
   
\ The escape sequences implied by the following two tables are as
\ defined by the Windows NT "Portable Boot Loader" (formerly known
\ as ARC firmware) spec. They were subsequently adopted in some PowerPC
\ Open Firmware bindings. 
create move-map  90 c,  9a c,
1A3D494 	 0  0  0 6D 
1A3D498 	6F 76 65 2D 6D 61 70 88 
1A3D4A0 	30 D4 A3  1 30 40 A0  1 
1A3D4A8 	90 9A 
   ch @   \ Insert
1A3D4AA 	40 
   ch K   \ End
1A3D4AB 	4B 
   ch B   \ Down
1A3D4AC 	42 
   ch /   \ Page Down
1A3D4AD 	2F 
   ch D   \ Left
1A3D4AE 	44 
   ch 5   \ bogus
1A3D4AF 	35 
   ch C   \ Right
1A3D4B0 	43 
   ch H   \ Home
1A3D4B1 	48 
   ch A   \ Up
1A3D4B2 	41 
   ch ?   \ Page Up
1A3D4B3 	3F 
   ch P   \ Delete  (use DEL, 7f)
1A3D4B4 	50 

create func-map  81 c,  8c c,
1A3D4B5 	 0  0 66 
1A3D4B8 	75 6E 63 2D 6D 61 70 88 
1A3D4C0 	A4 D4 A3  1 30 40 A0  1 
1A3D4C8 	81 8C 
   ch P   \ F1
1A3D4CA 	50 
   ch Q   \ F2
1A3D4CB 	51 
   ch W   \ F3
1A3D4CC 	57 
   ch x   \ F4
1A3D4CD 	78 
   ch t   \ F5
1A3D4CE 	74 
   ch u   \ F6
1A3D4CF 	75 
   ch q   \ F7
1A3D4D0 	71 
   ch r   \ F8
1A3D4D1 	72 
   ch p   \ F9
1A3D4D2 	70 
   ch M   \ F10
1A3D4D3 	4D 
   ch A   \ F11
1A3D4D4 	41 
   ch B   \ F12
1A3D4D5 	42 

: get-special-key  ( char -- false | ASCII-code true )
1A3D4D6 	 0  0 
1A3D4D8 	67 65 74 2D 73 70 65 63 
1A3D4E0 	69 61 6C 2D 6B 65 79 8F 
1A3D4E8 	C4 D4 A3  1 20 40 A0  1 
   func-map  map?  if  do-func true  exit  then  
1A3D4F0 	C4 D4 A3  1 30 D4 A3  1 
1A3D4F8 	DC 41 A0  1 10  0  0  0 
1A3D500 	44 D0 A3  1  4 70 A0  1 
1A3D508 	40 46 A0  1 
   move-map  map?  if  do-esc  true  exit  then
1A3D50C 	A4 D4 A3  1 
1A3D510 	30 D4 A3  1 DC 41 A0  1 
1A3D518 	10  0  0  0 14 D0 A3  1 
1A3D520 	 4 70 A0  1 40 46 A0  1 
   ?dup 0<>
1A3D528 	B4 70 A0  1 44 47 A0  1 
;
1A3D530 	58 46 A0  1 

\ Handle reports of keys already down.
\ Also, some keyboards send an unsolicited "aa" code after power is applied,
\ indicating successful completion of the keyboard's internal selftest, which
\ we ignore.

0 value ctrl-down?
1A3D534 	 0 63 74 72 
1A3D538 	6C 2D 64 6F 77 6E 3F 8A 
1A3D540 	EC D4 A3  1 50 40 A0  1 
1A3D548 	D4  C  0  0 
0 value alt-down?
1A3D54C 	 0  0 61 6C 
1A3D550 	74 2D 64 6F 77 6E 3F 89 
1A3D558 	44 D5 A3  1 50 40 A0  1 
1A3D560 	D8  C  0  0 
0 value initial-key
1A3D564 	69 6E 69 74 
1A3D568 	69 61 6C 2D 6B 65 79 8B 
1A3D570 	5C D5 A3  1 50 40 A0  1 
1A3D578 	DC  C  0  0 

\ These scancodes are from set 1.
: handle-initial-scan  ( scancode -- )
1A3D57C 	68 61 6E 64 
1A3D580 	6C 65 2D 69 6E 69 74 69 
1A3D588 	61 6C 2D 73 63 61 6E 93 
1A3D590 	74 D5 A3  1 20 40 A0  1 
   case
      h# 1d  of  true  to ctrl-down?   endof
1A3D598 	58 41 A0  1 1D  0  0  0 
1A3D5A0 	48 43 A0  1 18  0  0  0 
1A3D5A8 	 4 70 A0  1 B8 40 A0  1 
1A3D5B0 	44 D5 A3  1 6C 43 A0  1 
1A3D5B8 	A8  0  0  0 
      h# 38  of  true  to alt-down?    endof
1A3D5BC 	58 41 A0  1 
1A3D5C0 	38  0  0  0 48 43 A0  1 
1A3D5C8 	18  0  0  0  4 70 A0  1 
1A3D5D0 	B8 40 A0  1 5C D5 A3  1 
1A3D5D8 	6C 43 A0  1 84  0  0  0 
      h# 9d  of  false to ctrl-down?   endof
1A3D5E0 	58 41 A0  1 9D  0  0  0 
1A3D5E8 	48 43 A0  1 18  0  0  0 
1A3D5F0 	18 70 A0  1 B8 40 A0  1 
1A3D5F8 	44 D5 A3  1 6C 43 A0  1 
1A3D600 	60  0  0  0 
      h# b8  of  false to alt-down?    endof
1A3D604 	58 41 A0  1 
1A3D608 	B8  0  0  0 48 43 A0  1 
1A3D610 	18  0  0  0 18 70 A0  1 
1A3D618 	B8 40 A0  1 5C D5 A3  1 
1A3D620 	6C 43 A0  1 3C  0  0  0 
      ( default )
      dup  h# 60 <=  if  dup keymap 1+ + c@  to initial-key  then
1A3D628 	40 49 A0  1 58 41 A0  1 
1A3D630 	60  0  0  0  C 49 A0  1 
1A3D638 	DC 41 A0  1 20  0  0  0 
1A3D640 	40 49 A0  1 B8 D0 A3  1 
1A3D648 	30 4B A0  1  4 45 A0  1 
1A3D650 	C4 4C A0  1 B8 40 A0  1 
1A3D658 	74 D5 A3  1 
   endcase
1A3D65C 	84 43 A0  1 
;
1A3D660 	58 46 A0  1 

: clear-state  ( -- )
1A3D664 	63 6C 65 61 
1A3D668 	72 2D 73 74 61 74 65 8B 
1A3D670 	94 D5 A3  1 20 40 A0  1 
   false to ctrl-down?
1A3D678 	18 70 A0  1 B8 40 A0  1 
1A3D680 	44 D5 A3  1 
   false to alt-down?
1A3D684 	18 70 A0  1 
1A3D688 	B8 40 A0  1 5C D5 A3  1 
   ff    to initial-key
1A3D690 	58 41 A0  1 FF  0  0  0 
1A3D698 	B8 40 A0  1 74 D5 A3  1 
   " us" set-keyboard
1A3D6A0 	9C 53 A0  1  2 75 73  0 
1A3D6A8 	B4 D2 A3  1 
\   choose-type
;
1A3D6AC 	58 46 A0  1 
: consume  ( -- )   begin  5 timed-read  0=  while  drop  repeat  ;
1A3D6B0 	63 6F 6E 73 75 6D 65 87 
1A3D6B8 	74 D6 A3  1 20 40 A0  1 
1A3D6C0 	C0 6F A0  1 FC CC A3  1 
1A3D6C8 	24 47 A0  1 DC 41 A0  1 
1A3D6D0 	10  0  0  0 30 49 A0  1 
1A3D6D8 	C8 41 A0  1 E4 FF FF FF 
1A3D6E0 	58 46 A0  1 

: get-initial-state  ( -- )
1A3D6E4 	 0  0 67 65 
1A3D6E8 	74 2D 69 6E 69 74 69 61 
1A3D6F0 	6C 2D 73 74 61 74 65 91 
1A3D6F8 	BC D6 A3  1 20 40 A0  1 
   d# 200 ms      \ Give the keyboard time to respond
1A3D700 	58 41 A0  1 C8  0  0  0 
1A3D708 	60 E0 A1  1 

   \ 5 ms is less than the standard auto-repeat rate
   begin  5 timed-read  0=  while  handle-initial-scan  repeat
1A3D70C 	C0 6F A0  1 
1A3D710 	FC CC A3  1 24 47 A0  1 
1A3D718 	DC 41 A0  1 10  0  0  0 
1A3D720 	94 D5 A3  1 C8 41 A0  1 
1A3D728 	E4 FF FF FF 

   default-disable-kbd	\ Clear last typematic key, if any
1A3D72C 	F0 CE A3  1 
   consume
1A3D730 	BC D6 A3  1 
;
1A3D734 	58 46 A0  1 

: initial-key?  ( -- false | char true )
1A3D738 	 0  0  0 69 6E 69 74 69 
1A3D740 	61 6C 2D 6B 65 79 3F 8C 
1A3D748 	FC D6 A3  1 20 40 A0  1 
   initial-key ff =  if  false exit  then
1A3D750 	74 D5 A3  1 58 41 A0  1 
1A3D758 	FF  0  0  0 24 48 A0  1 
1A3D760 	DC 41 A0  1  C  0  0  0 
1A3D768 	18 70 A0  1 40 46 A0  1 

   \ 5 and 6 are the codes for BREAK and CTRL-BREAK, respectively
   \ -1 as a return value means "break"
   initial-key  5 6 between  if  -1 true exit  then
1A3D770 	74 D5 A3  1 C0 6F A0  1 
1A3D778 	D0 6F A0  1 D8 70 A0  1 
1A3D780 	DC 41 A0  1 14  0  0  0 
1A3D788 	58 41 A0  1 FF FF FF FF 
1A3D790 	 4 70 A0  1 40 46 A0  1 

   \ 81..8c are the function keys F1..F12
   initial-key  h# 81  h# 8c between  if  initial-key true  exit  then
1A3D798 	74 D5 A3  1 58 41 A0  1 
1A3D7A0 	81  0  0  0 58 41 A0  1 
1A3D7A8 	8C  0  0  0 D8 70 A0  1 
1A3D7B0 	DC 41 A0  1 10  0  0  0 
1A3D7B8 	74 D5 A3  1  4 70 A0  1 
1A3D7C0 	40 46 A0  1 

   alt-down?  if  initial-key true exit  then
1A3D7C4 	5C D5 A3  1 
1A3D7C8 	DC 41 A0  1 10  0  0  0 
1A3D7D0 	74 D5 A3  1  4 70 A0  1 
1A3D7D8 	40 46 A0  1 
   false
1A3D7DC 	18 70 A0  1 
;
1A3D7E0 	58 46 A0  1 

: reset  ( -- )
1A3D7E4 	 0  0 72 65 
1A3D7E8 	73 65 74 85 4C D7 A3  1 
1A3D7F0 	20 40 A0  1 
   init-data
1A3D7F4 	F0 CB A3  1 
   clear-state
1A3D7F8 	74 D6 A3  1 
[ifdef] ?olpc-keyboard
   ?olpc-keyboard
[else]
   get-initial-state
1A3D7FC 	FC D6 A3  1 

   \ Test the keyboard interface clock and data lines
   " test-lines" $call-parent  if  false to keyboard-present? exit  then
1A3D800 	9C 53 A0  1  A 74 65 73 
1A3D808 	74 2D 6C 69 6E 65 73  0 
1A3D810 	DC 31 A2  1 DC 41 A0  1 
1A3D818 	14  0  0  0 18 70 A0  1 
1A3D820 	B8 40 A0  1 B4 C8 A3  1 
1A3D828 	40 46 A0  1 
   consume
1A3D82C 	BC D6 A3  1 

   kbd-reset  if
1A3D830 	DC CF A3  1 DC 41 A0  1 
1A3D838 	18  0  0  0 
      false to keyboard-present?
1A3D83C 	18 70 A0  1 
1A3D840 	B8 40 A0  1 B4 C8 A3  1 
   else
1A3D848 	C8 41 A0  1 48  0  0  0 
      get-initial-state     \ Handle reports of keys already down
1A3D850 	FC D6 A3  1 

      echo?  dup 0= to keyboard-present?  if
1A3D854 	34 CF A3  1 
1A3D858 	40 49 A0  1 24 47 A0  1 
1A3D860 	B8 40 A0  1 B4 C8 A3  1 
1A3D868 	DC 41 A0  1 28  0  0  0 
         ." Failed keyboard echo test" cr
1A3D870 	20 7C A0  1 19 46 61 69 
1A3D878 	6C 65 64 20 6B 65 79 62 
1A3D880 	6F 61 72 64 20 65 63 68 
1A3D888 	6F 20 74 65 73 74  0  0 
1A3D890 	80 6D A0  1 
      then

\     7 set-leds  d# 100 ms  0 set-leds
   then

   \ Leave the keyboard in scan set 2 (its default state), but also leave
   \ the 8042 in the mode where it translates to scan set 1.

   keyboard-present?  if  enable-scan  then
1A3D894 	B4 C8 A3  1 
1A3D898 	DC 41 A0  1  8  0  0  0 
1A3D8A0 	14 CF A3  1 
[then]
   true to keyboard-probed?
1A3D8A4 	 4 70 A0  1 
1A3D8A8 	B8 40 A0  1 94 C8 A3  1 
;
1A3D8B0 	58 46 A0  1 

\ Without doing unnecessary testing, put the keyboard into a known state.
\ This routine is used after watchdog timer resets and other conditions
\ that leave the system in an unknown state.

: restore  ( -- )
1A3D8B4 	72 65 73 74 
1A3D8B8 	6F 72 65 87 F0 D7 A3  1 
1A3D8C0 	20 40 A0  1 
   init-data
1A3D8C4 	F0 CB A3  1 
   kbd-reset 0= to keyboard-present?
1A3D8C8 	DC CF A3  1 24 47 A0  1 
1A3D8D0 	B8 40 A0  1 B4 C8 A3  1 
;
1A3D8D8 	58 46 A0  1 
defer scan-handled?
1A3D8DC 	 0  0 73 63 
1A3D8E0 	61 6E 2D 68 61 6E 64 6C 
1A3D8E8 	65 64 3F 8D C0 D8 A3  1 
1A3D8F0 	5C 40 A0  1 E0  C  0  0 
' false to scan-handled?
headerless
: check-abort  ( scan-code -- flag )  \ Ctrl-break pressed?
1A3D8F8 	63 68 65 63 6B 2D 61 62 
1A3D900 	6F 72 74 8B F0 D8 A3  1 
1A3D908 	20 40 A0  1 
   check-abort?  if
1A3D90C 	5C C8 A3  1 
1A3D910 	DC 41 A0  1 40  0  0  0 
      \ Ctrl-break does not auto-repeat, so we needn't worry about
      \ multiple down transitions
      dup h# c6 =  if				\ Ctrl-break?
1A3D918 	40 49 A0  1 58 41 A0  1 
1A3D920 	C6  0  0  0 24 48 A0  1 
1A3D928 	DC 41 A0  1 1C  0  0  0 
         last-scan h# e0 =
1A3D930 	74 C8 A3  1 58 41 A0  1 
1A3D938 	E0  0  0  0 24 48 A0  1 
      else
1A3D940 	C8 41 A0  1  8  0  0  0 
         false
1A3D948 	18 70 A0  1 
      then
   else
1A3D94C 	C8 41 A0  1 
1A3D950 	 8  0  0  0 
      false
1A3D954 	18 70 A0  1 
   then
   swap to last-scan
1A3D958 	68 49 A0  1 B8 40 A0  1 
1A3D960 	74 C8 A3  1 
;
1A3D964 	58 46 A0  1 

: get-scan  ( -- )
1A3D968 	 0  0  0 67 65 74 2D 73 
1A3D970 	63 61 6E 88  8 D9 A3  1 
1A3D978 	20 40 A0  1 
   locked?  if  exit  then
1A3D97C 	C8 C8 A3  1 
1A3D980 	DC 41 A0  1  8  0  0  0 
1A3D988 	40 46 A0  1 

   lock
1A3D98C 	DC C8 A3  1 
   begin
      get-data?
1A3D990 	68 CC A3  1 
   while                                     ( scan-code )
1A3D994 	DC 41 A0  1 
1A3D998 	54  0  0  0 
      \ In the following code, we must be careful to unlock the
      \ queue before calling user-abort, because a timer interrupt
      \ can occur at any time after user-abort is executed.
      dup check-abort  if                    ( scan-code )
1A3D99C 	40 49 A0  1 
1A3D9A0 	 8 D9 A3  1 DC 41 A0  1 
1A3D9A8 	20  0  0  0 
         drop
1A3D9AC 	30 49 A0  1 
         unlock  user-abort
1A3D9B0 	FC C8 A3  1  C E3 A1  1 
         \ Wait here for long enough to ensure that an alarm timer tick
         \ will happen if it is going to happen.  This is the safest
         \ solution I have found to the following problem: If the abort
         \ sequence is detected while polling the keyboard from the
         \ application level (i.e. not from the alarm handler), then
         \ the alarm handler is likely to sense it a little later,
         \ perhaps in the middle of deque? .  Aborting in the middle of
         \ of deque? is bad, because it leaves the lock set and potentially
         \ leaves the queue pointers and/or stateful hardware in an
         \ inconsistent state.  One solution would be to avoid calling
         \ deque after calling user-abort, but that would hang the driver
         \ if the alarm tick is turned off.
         d# 20 ms
1A3D9B8 	58 41 A0  1 14  0  0  0 
1A3D9C0 	60 E0 A1  1 
         exit
1A3D9C4 	40 46 A0  1 
      then                                         ( scan-code )
      scan-handled?  if  drop  else  enque  then   ( )
1A3D9C8 	F0 D8 A3  1 DC 41 A0  1 
1A3D9D0 	10  0  0  0 30 49 A0  1 
1A3D9D8 	C8 41 A0  1  8  0  0  0 
1A3D9E0 	14 CA A3  1 
   repeat
1A3D9E4 	C8 41 A0  1 
1A3D9E8 	A8 FF FF FF 
   unlock
1A3D9EC 	FC C8 A3  1 
;
1A3D9F0 	58 46 A0  1 

: set-port  ( port# -- )  " set-port" $call-parent  ;
1A3D9F4 	 0  0  0 73 
1A3D9F8 	65 74 2D 70 6F 72 74 88 
1A3DA00 	78 D9 A3  1 20 40 A0  1 
1A3DA08 	9C 53 A0  1  8 73 65 74 
1A3DA10 	2D 70 6F 72 74  0  0  0 
1A3DA18 	DC 31 A2  1 58 46 A0  1 

variable kbd-refcount
1A3DA20 	 0  0  0 6B 62 64 2D 72 
1A3DA28 	65 66 63 6F 75 6E 74 8C 
1A3DA30 	 4 DA A3  1 48 40 A0  1 
1A3DA38 	E4  C  0  0 
: +refcnt  ( n -- )  kbd-refcount +!  ;
1A3DA3C 	2B 72 65 66 
1A3DA40 	63 6E 74 87 34 DA A3  1 
1A3DA48 	20 40 A0  1 34 DA A3  1 
1A3DA50 	 C 4C A0  1 58 46 A0  1 
0 kbd-refcount !

headers
: open  ( -- okay? )
1A3DA58 	 0  0  0 6F 70 65 6E 84 
1A3DA60 	48 DA A3  1 20 40 A0  1 
   my-space set-port
1A3DA68 	AC  3 A2  1  4 DA A3  1 
   kbd-refcount @  if  1 +refcnt  true exit  then
1A3DA70 	34 DA A3  1 5C 4C A0  1 
1A3DA78 	DC 41 A0  1 14  0  0  0 
1A3DA80 	80 6F A0  1 48 DA A3  1 
1A3DA88 	 4 70 A0  1 40 46 A0  1 
   unlock
1A3DA90 	FC C8 A3  1 
   keyboard-present?  if  clear-out-buf  else  reset  then
1A3DA94 	B4 C8 A3  1 
1A3DA98 	DC 41 A0  1 10  0  0  0 
1A3DAA0 	CC CC A3  1 C8 41 A0  1 
1A3DAA8 	 8  0  0  0 F0 D7 A3  1 
   keyboard-present?  0=  if  false exit  then
1A3DAB0 	B4 C8 A3  1 24 47 A0  1 
1A3DAB8 	DC 41 A0  1  C  0  0  0 
1A3DAC0 	18 70 A0  1 40 46 A0  1 
   choose-type
1A3DAC8 	40 D3 A3  1 
   ['] get-scan d# 10 alarm
1A3DACC 	60 53 A0  1 
1A3DAD0 	78 D9 A3  1 58 41 A0  1 
1A3DAD8 	 A  0  0  0 48 73 A2  1 
   1 +refcnt
1A3DAE0 	80 6F A0  1 48 DA A3  1 
   true
1A3DAE8 	 4 70 A0  1 
;
1A3DAEC 	58 46 A0  1 

: close  ( -- )
1A3DAF0 	 0  0 63 6C 6F 73 65 85 
1A3DAF8 	64 DA A3  1 20 40 A0  1 
   -1 +refcnt  kbd-refcount @  if  exit  then
1A3DB00 	58 41 A0  1 FF FF FF FF 
1A3DB08 	48 DA A3  1 34 DA A3  1 
1A3DB10 	5C 4C A0  1 DC 41 A0  1 
1A3DB18 	 8  0  0  0 40 46 A0  1 
   ?free-keymap
1A3DB20 	 4 D3 A3  1 
   ['] get-scan  0 alarm
1A3DB24 	60 53 A0  1 
1A3DB28 	78 D9 A3  1 70 6F A0  1 
1A3DB30 	48 73 A2  1 
;
1A3DB34 	58 46 A0  1 

: install-abort  ( -- )  true to check-abort?  ;
1A3DB38 	 0  0 69 6E 73 74 61 6C 
1A3DB40 	6C 2D 61 62 6F 72 74 8D 
1A3DB48 	FC DA A3  1 20 40 A0  1 
1A3DB50 	 4 70 A0  1 B8 40 A0  1 
1A3DB58 	5C C8 A3  1 58 46 A0  1 
: remove-abort  ( -- )  false to check-abort?  ;
1A3DB60 	 0  0  0 72 65 6D 6F 76 
1A3DB68 	65 2D 61 62 6F 72 74 8C 
1A3DB70 	4C DB A3  1 20 40 A0  1 
1A3DB78 	18 70 A0  1 B8 40 A0  1 
1A3DB80 	5C C8 A3  1 58 46 A0  1 

headerless
: >keycode  ( scan-code -- char )
1A3DB88 	 0  0  0 3E 6B 65 79 63 
1A3DB90 	6F 64 65 88 74 DB A3  1 
1A3DB98 	20 40 A0  1 
   keymap c@ 2 >  alt-gr?  and  if
1A3DB9C 	B8 D0 A3  1 
1A3DBA0 	C4 4C A0  1 90 6F A0  1 
1A3DBA8 	 4 48 A0  1 30 CB A3  1 
1A3DBB0 	5C 44 A0  1 DC 41 A0  1 
1A3DBB8 	18  0  0  0 
      h# c0 +
1A3DBBC 	58 41 A0  1 
1A3DBC0 	C0  0  0  0  4 45 A0  1 
   else
1A3DBC8 	C8 41 A0  1 1C  0  0  0 
      shift?  if  h# 60 +  then
1A3DBD0 	F4 CA A3  1 DC 41 A0  1 
1A3DBD8 	10  0  0  0 58 41 A0  1 
1A3DBE0 	60  0  0  0  4 45 A0  1 
   then
   keymap 1+ +  c@
1A3DBE8 	B8 D0 A3  1 30 4B A0  1 
1A3DBF0 	 4 45 A0  1 C4 4C A0  1 
;
1A3DBF8 	58 46 A0  1 

\ Schema for Latin-1 accents:
\ lower-case is c0+x, upper case is e0+x
\ letter   grave  acute circumflex tilde diaresis  ring  .e  slash  cedilla obl
\    A     c0     c1    c2         c3    c4        c5    c6
\    E     c8     c9    ca         cb
\    I     cc     cd    ce         cf
\    O     d2     d3    d4         d5    d6				    d8
\    U     d9     da    db               dc
\    Y            dd
\    y                                   ff
\    C                                                                 c7
\    N                             d1

\    ETH d0  eth f0
\    multiply d7  division f7
\    oslash f8
\    THORN de  thorn fe
\    ssharp df

\ grave: vowel-base + 0
\ acute: vowel-base + 1
\ circumflex: vowel-base + 2
\ tilde: vowel-base + 3       (but bogus for u)
\ diaresis: vowel-base + (3 for u, 4 for a and o)

\ Search for a match for "byte" in the "key" position of the table at
\ "table-adr". If a match is found, return the corresponding "value" byte
\ and true.  Otherwise return the argument byte and false.  The table
\ consists of pairs of bytes - the first byte of the pair is "key" and
\ the second is "value".  The end of the table is marked by a 0 byte in
\ the "key" position.
: translate-byte ( byte table-adr -- byte false | byte' true )
1A3DBFC 	 0 74 72 61 
1A3DC00 	6E 73 6C 61 74 65 2D 62 
1A3DC08 	79 74 65 8E 98 DB A3  1 
1A3DC10 	20 40 A0  1 
   begin  dup c@  while                             ( char adr )
1A3DC14 	40 49 A0  1 
1A3DC18 	C4 4C A0  1 DC 41 A0  1 
1A3DC20 	38  0  0  0 
      2dup c@ =  if  nip 1+ c@ true  exit  then     ( char adr )
1A3DC24 	C0 49 A0  1 
1A3DC28 	C4 4C A0  1 24 48 A0  1 
1A3DC30 	DC 41 A0  1 18  0  0  0 
1A3DC38 	FC 46 A0  1 30 4B A0  1 
1A3DC40 	C4 4C A0  1  4 70 A0  1 
1A3DC48 	40 46 A0  1 
      2+                                            ( char adr' )
1A3DC4C 	40 4B A0  1 
   repeat                                           ( char adr' )
1A3DC50 	C8 41 A0  1 C0 FF FF FF 
   drop false
1A3DC58 	30 49 A0  1 18 70 A0  1 
;
1A3DC60 	58 46 A0  1 

create dead-punctuation
1A3DC64 	 0  0  0 64 
1A3DC68 	65 61 64 2D 70 75 6E 63 
1A3DC70 	74 75 61 74 69 6F 6E 90 
1A3DC78 	10 DC A3  1 30 40 A0  1 
\ base  grave  acute  circumflex  tilde  diaeresis  cedilla
  ch /   xx     xx        ch |     xx      xx         xx
1A3DC80 	2F  0  0 7C  0  0  0 
  bl c,  ch `   ch '      ch ^     ch ~    a8 c,      xx     \ diaeresis
1A3DC87 	20 
1A3DC88 	60 27 5E 7E A8  0 
  ch 0   xx     xx        b0 c,    xx      xx         xx     \ degree
1A3DC8E 	30  0 
1A3DC90 	 0 B0  0  0  0 
  ch 1   xx     xx        b9 c,    xx      xx         xx     \ onesuperior
1A3DC95 	31  0  0 
1A3DC98 	B9  0  0  0 
  ch 2   xx     xx        b2 c,    xx      xx         xx     \ twosuperior
1A3DC9C 	32  0  0 B2 
1A3DCA0 	 0  0  0 
  ch 3   xx     xx        b3 c,    xx      xx         xx     \ threesuperior
1A3DCA3 	33  0  0 B3  0 
1A3DCA8 	 0  0 
  ch .   xx     xx        b7 c,    xx      xx         xx     \ periodcentered
1A3DCAA 	2E  0  0 B7  0  0 
1A3DCB0 	 0 
  ch !   xx     xx        a6 c,    xx      xx         xx     \ brokenbar
1A3DCB1 	21  0  0 A6  0  0  0 
  ch -   xx     xx        af c,    xx      xx         ac c,  \ macron, notsign
1A3DCB8 	2D  0  0 AF  0  0 AC 
  ch _   xx     xx        af c,    xx      xx         xx     \ macron
1A3DCBF 	5F 
1A3DCC0 	 0  0 AF  0  0  0 
  ch '   xx     b4 c,     xx       xx      xx         xx     \ acute
1A3DCC6 	27  0 
1A3DCC8 	B4  0  0  0  0 
  ch ,   xx     xx        xx       xx      xx         b8 c,  \ cedilla
1A3DCCD 	2C  0  0 
1A3DCD0 	 0  0  0 B8 
  ch "   xx     xx        xx       xx      a8 c,      xx     \ diaeresis
1A3DCD4 	22  0  0  0 
1A3DCD8 	 0 A8  0 
  ch C   xx     xx        xx       xx      xx         c7 c,  \ Ccedilla
1A3DCDB 	43  0  0  0  0 
1A3DCE0 	 0 C7 
  ch c   xx     xx        xx       xx      xx         e7 c,  \ ccedilla
1A3DCE2 	63  0  0  0  0  0 
1A3DCE8 	E7 
  0 c,
1A3DCE9 	 0 

\ Positions of accented vowels within the ISO-Latin-1 character encoding
create vowel-bases
1A3DCEA 	 0  0 76 6F 77 65 
1A3DCF0 	6C 2D 62 61 73 65 73 8B 
1A3DCF8 	7C DC A3  1 30 40 A0  1 
ch A  c0 c,  ch E  c8 c,  ch I  cc c,  ch O  d2 c,  ch U  d9 c,
1A3DD00 	41 C0 45 C8 49 CC 4F D2 
1A3DD08 	55 D9 
ch a  e0 c,  ch e  e8 c,  ch i  ec c,  ch o  f2 c,  ch u  f9 c,
1A3DD0A 	61 E0 65 E8 69 EC 
1A3DD10 	6F F2 75 F9 
0 c,
1A3DD14 	 0 

create dead-map  h# 10 c,  h# 15 c,
1A3DD15 	 0  0 64 
1A3DD18 	65 61 64 2D 6D 61 70 88 
1A3DD20 	FC DC A3  1 30 40 A0  1 
1A3DD28 	10 15 
   0 c,  \ 10: dead_grave      - index 0
1A3DD2A 	 0 
   1 c,  \ 11: dead_acute      - index 1
1A3DD2B 	 1 
   2 c,  \ 12: dead_circumflex - index 2
1A3DD2C 	 2 
   3 c,  \ 13: dead_tilde      - index 3
1A3DD2D 	 3 
   4 c,  \ 14: dead_diaeresis  - index 4
1A3DD2E 	 4 
   5 c,  \ 15: dead_cedilla    - index 5
1A3DD2F 	 5 

: ?dead-accent  ( char -- char' )
1A3DD30 	 0  0  0 3F 64 65 61 64 
1A3DD38 	2D 61 63 63 65 6E 74 8C 
1A3DD40 	24 DD A3  1 20 40 A0  1 
   dead-accent  -1  =  if  exit  then
1A3DD48 	48 CB A3  1 58 41 A0  1 
1A3DD50 	FF FF FF FF 24 48 A0  1 
1A3DD58 	DC 41 A0  1  8  0  0  0 
1A3DD60 	40 46 A0  1 

   \ First search the punctuation table
   dead-punctuation  begin  2dup c@  dup  while   ( char adr char char' )
1A3DD64 	7C DC A3  1 
1A3DD68 	C0 49 A0  1 C4 4C A0  1 
1A3DD70 	40 49 A0  1 DC 41 A0  1 
1A3DD78 	40  0  0  0 
      =  if                                       ( char adr )
1A3DD7C 	24 48 A0  1 
1A3DD80 	DC 41 A0  1 24  0  0  0 
         dead-accent + c@                         ( char char'|0 )
1A3DD88 	48 CB A3  1  4 45 A0  1 
1A3DD90 	C4 4C A0  1 
         ?dup  if  nip  then   exit               ( char|char' )
1A3DD94 	B4 70 A0  1 
1A3DD98 	DC 41 A0  1  8  0  0  0 
1A3DDA0 	FC 46 A0  1 40 46 A0  1 
      then                                        ( char adr )
      7 +                                         ( char adr' )
1A3DDA8 	E0 6F A0  1  4 45 A0  1 
   repeat                                         ( char adr char char' )
1A3DDB0 	C8 41 A0  1 B4 FF FF FF 
   3drop                                          ( char )
1A3DDB8 	90 52 A0  1 

   \ If it isn't in the punctuation table, try the vowel table, but
   \ not if the dead accent is cedilla (cedilla doesn't apply to vowels)
   dead-accent 5 =  if  drop exit  then           ( char )
1A3DDBC 	48 CB A3  1 
1A3DDC0 	C0 6F A0  1 24 48 A0  1 
1A3DDC8 	DC 41 A0  1  C  0  0  0 
1A3DDD0 	30 49 A0  1 40 46 A0  1 

   \ Unlike the other diaeresis vowels, u diaeresis is offset 3 instead of 4
   dup [char] u =  dead-accent 4  =  and  if      ( char )
1A3DDD8 	40 49 A0  1 58 41 A0  1 
1A3DDE0 	75  0  0  0 24 48 A0  1 
1A3DDE8 	48 CB A3  1 B0 6F A0  1 
1A3DDF0 	24 48 A0  1 5C 44 A0  1 
1A3DDF8 	DC 41 A0  1 14  0  0  0 
      dead-accent 1- to dead-accent               ( char )
1A3DE00 	48 CB A3  1 54 4B A0  1 
1A3DE08 	B8 40 A0  1 48 CB A3  1 
   then                                           ( char )
   vowel-bases translate-byte  if  dead-accent +  then    ( char' )
1A3DE10 	FC DC A3  1 10 DC A3  1 
1A3DE18 	DC 41 A0  1  C  0  0  0 
1A3DE20 	48 CB A3  1  4 45 A0  1 
;
1A3DE28 	58 46 A0  1 

create keypad-map  h# 90 c,  h# 9a c,
1A3DE2C 	 0 6B 65 79 
1A3DE30 	70 61 64 2D 6D 61 70 8A 
1A3DE38 	44 DD A3  1 30 40 A0  1 
1A3DE40 	90 9A 
   ch 0   \ 0/Insert
1A3DE42 	30 
   ch 1   \ 1/End
1A3DE43 	31 
   ch 2   \ 2/Down
1A3DE44 	32 
   ch 3   \ 3/PageDown
1A3DE45 	33 
   ch 4   \ 4/Left
1A3DE46 	34 
   ch 5   \ 5/<nothing>
1A3DE47 	35 
   ch 6   \ 6/Right
1A3DE48 	36 
   ch 7   \ 7/Home
1A3DE49 	37 
   ch 8   \ 8/Up
1A3DE4A 	38 
   ch 9   \ 9/PageUp
1A3DE4B 	39 
   ch .   \ ./Del
1A3DE4C 	2E 

\ Exchange the codes for the two symbol sets of the numeric keypad
\ if NumLock is on.
: ?numkey  ( char -- char' )
1A3DE4D 	 0  0  0 
1A3DE50 	3F 6E 75 6D 6B 65 79 87 
1A3DE58 	3C DE A3  1 20 40 A0  1 
   \ The mfii? 0= clause prevents the non-keypad Delete key from being
   \ affected by NumLock.
   numlk? mfii? 0= and  if                 ( char )
1A3DE60 	74 CB A3  1 1C CB A3  1 
1A3DE68 	24 47 A0  1 5C 44 A0  1 
1A3DE70 	DC 41 A0  1 18  0  0  0 
      keypad-map map?  if  exit  then      ( char )
1A3DE78 	3C DE A3  1 30 D4 A3  1 
1A3DE80 	DC 41 A0  1  8  0  0  0 
1A3DE88 	40 46 A0  1 
   then
;
1A3DE8C 	58 46 A0  1 

: ?caps  ( ASCII -- ASCII' )
1A3DE90 	 0  0 3F 63 61 70 73 85 
1A3DE98 	5C DE A3  1 20 40 A0  1 
   caps-lock?  if
1A3DEA0 	9C CB A3  1 DC 41 A0  1 
1A3DEA8 	74  0  0  0 
      \ Knock off the case bit so we can test fewer ranges
      dup  h# 20 invert and                  ( ASCII upc-ASCII )
1A3DEAC 	40 49 A0  1 
1A3DEB0 	58 41 A0  1 20  0  0  0 
1A3DEB8 	30 45 A0  1 5C 44 A0  1 

      \ In the ASCII range, the alphabetic character are in the range A-Z
      dup  [char] A  [char] Z  between       ( ASCII upc-ASCII flag )
1A3DEC0 	40 49 A0  1 58 41 A0  1 
1A3DEC8 	41  0  0  0 58 41 A0  1 
1A3DED0 	5A  0  0  0 D8 70 A0  1 

      \ In the ISO-Latin-1 range, the alphabetic characters are in the range
      \ 0xc0-0xde, except for d7 which is multiply; its conjugate f7 is
      \ divide.  df is sharp; its conjugate ff is ydiaeresis.
      over h# c0  h# de  between  or         ( ASCII upc-ASCII flag' )
1A3DED8 	54 49 A0  1 58 41 A0  1 
1A3DEE0 	C0  0  0  0 58 41 A0  1 
1A3DEE8 	DE  0  0  0 D8 70 A0  1 
1A3DEF0 	70 44 A0  1 
      swap  h# d7 <>  and  if                ( ASCII )
1A3DEF4 	68 49 A0  1 
1A3DEF8 	58 41 A0  1 D7  0  0  0 
1A3DF00 	44 48 A0  1 5C 44 A0  1 
1A3DF08 	DC 41 A0  1 10  0  0  0 
         h# 20 xor                           ( ASCII' )
1A3DF10 	58 41 A0  1 20  0  0  0 
1A3DF18 	84 44 A0  1 
      then                                   ( ASCII' )
   then                                      ( ASCII' )
;
1A3DF1C 	58 46 A0  1 
: ascii?  ( scancode -- flag )  h# 7f and  h# 20 h# 7f between  ;
1A3DF20 	 0 61 73 63 69 69 3F 86 
1A3DF28 	9C DE A3  1 20 40 A0  1 
1A3DF30 	58 41 A0  1 7F  0  0  0 
1A3DF38 	5C 44 A0  1 58 41 A0  1 
1A3DF40 	20  0  0  0 58 41 A0  1 
1A3DF48 	7F  0  0  0 D8 70 A0  1 
1A3DF50 	58 46 A0  1 

: ?ctrl?  ( char -- char false | char' true )
1A3DF54 	 0 3F 63 74 
1A3DF58 	72 6C 3F 86 2C DF A3  1 
1A3DF60 	20 40 A0  1 
   ctrl?  if                                ( char )
1A3DF64 	 8 CB A3  1 
1A3DF68 	DC 41 A0  1 38  0  0  0 
      dup  h# 40 h# 7f between  if  h# 1f and  true  exit  then
1A3DF70 	40 49 A0  1 58 41 A0  1 
1A3DF78 	40  0  0  0 58 41 A0  1 
1A3DF80 	7F  0  0  0 D8 70 A0  1 
1A3DF88 	DC 41 A0  1 18  0  0  0 
1A3DF90 	58 41 A0  1 1F  0  0  0 
1A3DF98 	5C 44 A0  1  4 70 A0  1 
1A3DFA0 	40 46 A0  1 
   then
   false
1A3DFA4 	18 70 A0  1 
;
1A3DFA8 	58 46 A0  1 
: clear-accent  ( -- )
1A3DFAC 	 0  0  0 63 
1A3DFB0 	6C 65 61 72 2D 61 63 63 
1A3DFB8 	65 6E 74 8C 60 DF A3  1 
1A3DFC0 	20 40 A0  1 
   \ If we just turned on the dead-accent variable (as indicated by the
   \ bias of 10), remove the bias.  Otherwise zap it.
   dead-accent  h# 10 >  if  h# 10 -  else  -1  then  to dead-accent
1A3DFC4 	48 CB A3  1 
1A3DFC8 	58 41 A0  1 10  0  0  0 
1A3DFD0 	 4 48 A0  1 DC 41 A0  1 
1A3DFD8 	18  0  0  0 58 41 A0  1 
1A3DFE0 	10  0  0  0 18 45 A0  1 
1A3DFE8 	C8 41 A0  1  C  0  0  0 
1A3DFF0 	58 41 A0  1 FF FF FF FF 
1A3DFF8 	B8 40 A0  1 48 CB A3  1 
;
1A3E000 	58 46 A0  1 
: get-ascii  ( scan-code -- false | ASCII-code true )
1A3E004 	 0  0 67 65 
1A3E008 	74 2D 61 73 63 69 69 89 
1A3E010 	C0 DF A3  1 20 40 A0  1 
   >keycode                                         ( char )
1A3E018 	98 DB A3  1 
   ?numkey                                          ( char' )
1A3E01C 	5C DE A3  1 

   dead-map map?  if                                ( index )
1A3E020 	24 DD A3  1 30 D4 A3  1 
1A3E028 	DC 41 A0  1 20  0  0  0 
      \ Set dead-accent with a bias so it won't be cleared when we exit
      h# 10 + to dead-accent false exit             ( false )
1A3E030 	58 41 A0  1 10  0  0  0 
1A3E038 	 4 45 A0  1 B8 40 A0  1 
1A3E040 	48 CB A3  1 18 70 A0  1 
1A3E048 	40 46 A0  1 
   then                                             ( char )

   dup ascii?  if                                   ( char )
1A3E04C 	40 49 A0  1 
1A3E050 	2C DF A3  1 DC 41 A0  1 
1A3E058 	2C  0  0  0 
      ?ctrl?  if  true exit  then                   ( char )
1A3E05C 	60 DF A3  1 
1A3E060 	DC 41 A0  1  C  0  0  0 
1A3E068 	 4 70 A0  1 40 46 A0  1 
      ?caps ?dead-accent  true                      ( ASCII true )
1A3E070 	9C DE A3  1 44 DD A3  1 
1A3E078 	 4 70 A0  1 
   else  \ No ASCII code equivalent	    	    ( scan char )
1A3E07C 	C8 41 A0  1 
1A3E080 	 8  0  0  0 
      get-special-key                               ( false | ASCII true )
1A3E084 	EC D4 A3  1 
   then                                             ( false | ASCII true )
;
1A3E088 	58 46 A0  1 

create mode-map  01 c,  06 c,
1A3E08C 	 0  0  0 6D 
1A3E090 	6F 64 65 2D 6D 61 70 88 
1A3E098 	14 E0 A3  1 30 40 A0  1 
1A3E0A0 	 1  6 
   00 c,  \ Shift
1A3E0A2 	 0 
   01 c,  \ Control
1A3E0A3 	 1 
   02 c,  \ Alt
1A3E0A4 	 2 
   03 c,  \ Caps_Lock
1A3E0A5 	 3 
   04 c,  \ Num_Lock
1A3E0A6 	 4 
   05 c,  \ Scroll_Lock
1A3E0A7 	 5 

: modifier?  ( down? scan -- true | down? scan false )
1A3E0A8 	 0  0 6D 6F 64 69 66 69 
1A3E0B0 	65 72 3F 89 9C E0 A3  1 
1A3E0B8 	20 40 A0  1 
   dup keymap 1+ + c@  mode-map  map?  if       ( down? scan char )
1A3E0BC 	40 49 A0  1 
1A3E0C0 	B8 D0 A3  1 30 4B A0  1 
1A3E0C8 	 4 45 A0  1 C4 4C A0  1 
1A3E0D0 	9C E0 A3  1 30 D4 A3  1 
1A3E0D8 	DC 41 A0  1 24  1  0  0 
      nip                                       ( down? char )
1A3E0E0 	FC 46 A0  1 
      case 
         0  of  mfii?  if  drop  else  to shift?  then  endof   \ Shift
1A3E0E4 	70 6F A0  1 
1A3E0E8 	48 43 A0  1 2C  0  0  0 
1A3E0F0 	1C CB A3  1 DC 41 A0  1 
1A3E0F8 	10  0  0  0 30 49 A0  1 
1A3E100 	C8 41 A0  1  C  0  0  0 
1A3E108 	B8 40 A0  1 F4 CA A3  1 
1A3E110 	6C 43 A0  1 E0  0  0  0 
         1  of  to ctrl?                                endof   \ Ctrl
1A3E118 	80 6F A0  1 48 43 A0  1 
1A3E120 	14  0  0  0 B8 40 A0  1 
1A3E128 	 8 CB A3  1 6C 43 A0  1 
1A3E130 	C4  0  0  0 
         2  of  mfii? and  to alt-gr?                   endof   \ Alt or AltGr
1A3E134 	90 6F A0  1 
1A3E138 	48 43 A0  1 1C  0  0  0 
1A3E140 	1C CB A3  1 5C 44 A0  1 
1A3E148 	B8 40 A0  1 30 CB A3  1 
1A3E150 	6C 43 A0  1 A0  0  0  0 
         3  of  scroll-lock?  if	\ If ScrollLock is on ...
1A3E158 	A0 6F A0  1 48 43 A0  1 
1A3E160 	34  0  0  0 C8 CB A3  1 
1A3E168 	DC 41 A0  1 14  0  0  0 
                   to ctrl?		\ ... treat the CapsLock key like Ctrl
1A3E170 	B8 40 A0  1  8 CB A3  1 
                else			\ Otherwise give it ...
1A3E178 	C8 41 A0  1 10  0  0  0 
                   4 and toggle-leds	\ ... the normal CapsLock function
1A3E180 	B0 6F A0  1 5C 44 A0  1 
1A3E188 	B8 CF A3  1 
                then                                    endof   \ Caps Lock
1A3E18C 	6C 43 A0  1 
1A3E190 	64  0  0  0 
         \ Pause is encoded as E1, 1D (CTRL), 45 (NUMLOCK)
         \ CTRL/Break is encoded as 1D (CTRL), E0 (MF II), 46 (ScrollLock)
         \ We filter out those modified locks to sense the real locks.
         4  of  2 and  ctrl? 0= and  toggle-leds        endof   \ Num Lock
1A3E194 	B0 6F A0  1 
1A3E198 	48 43 A0  1 24  0  0  0 
1A3E1A0 	90 6F A0  1 5C 44 A0  1 
1A3E1A8 	 8 CB A3  1 24 47 A0  1 
1A3E1B0 	5C 44 A0  1 B8 CF A3  1 
1A3E1B8 	6C 43 A0  1 38  0  0  0 
         5  of  1 and  mfii? 0= and  toggle-leds        endof   \ Scroll Lock
1A3E1C0 	C0 6F A0  1 48 43 A0  1 
1A3E1C8 	24  0  0  0 80 6F A0  1 
1A3E1D0 	5C 44 A0  1 1C CB A3  1 
1A3E1D8 	24 47 A0  1 5C 44 A0  1 
1A3E1E0 	B8 CF A3  1 6C 43 A0  1 
1A3E1E8 	 C  0  0  0 
         ( down? scan )  nip
1A3E1EC 	FC 46 A0  1 
      endcase
1A3E1F0 	84 43 A0  1 
      true
1A3E1F4 	 4 70 A0  1 
   else                                         ( down? scan char )
1A3E1F8 	C8 41 A0  1  C  0  0  0 
      drop false                                ( down? scan false )
1A3E200 	30 49 A0  1 18 70 A0  1 
   then
;
1A3E208 	58 46 A0  1 
: (scancode->char)  ( scan-code -- false | ASCII-code true )  \ Next ASCII code
1A3E20C 	 0  0  0 28 
1A3E210 	73 63 61 6E 63 6F 64 65 
1A3E218 	2D 3E 63 68 61 72 29 90 
1A3E220 	B8 E0 A3  1 20 40 A0  1 
   \ Split the scancode into the up/down indicator and the key identifier
   h# 80 /mod 0=  swap                           ( down? scan )
1A3E228 	58 41 A0  1 80  0  0  0 
1A3E230 	50 5F A0  1 24 47 A0  1 
1A3E238 	68 49 A0  1 
	
[ifdef] ?multkey  ?multkey  [then]

   \ Exit if the scancode is one that is never used for ASCII characters
   dup h# 60 >=  if  2drop  false  exit  then    ( down? scan )
1A3E23C 	40 49 A0  1 
1A3E240 	58 41 A0  1 60  0  0  0 
1A3E248 	EC 48 A0  1 DC 41 A0  1 
1A3E250 	10  0  0  0 AC 49 A0  1 
1A3E258 	18 70 A0  1 40 46 A0  1 

   \ Handle modifiers like shift, ctrl, etc.
   modifier?  if  false exit  then               ( down? scan )
1A3E260 	B8 E0 A3  1 DC 41 A0  1 
1A3E268 	 C  0  0  0 18 70 A0  1 
1A3E270 	40 46 A0  1 

   \ We have handled all the mode keys.  For the rest of the keys,
   \ we can ignore the up transition.
   swap  0= if  drop false exit  then            ( scan )
1A3E274 	68 49 A0  1 
1A3E278 	24 47 A0  1 DC 41 A0  1 
1A3E280 	10  0  0  0 30 49 A0  1 
1A3E288 	18 70 A0  1 40 46 A0  1 

   \ Try to translate the scancode into a one or more ASCII characters
   get-ascii                                     ( false | ASCII true )
1A3E290 	14 E0 A3  1 
   clear-accent                                  ( false | ASCII true )
1A3E294 	C0 DF A3  1 
;
1A3E298 	58 46 A0  1 
: scancode->char  ( scan-code -- false | ASCII-code true )  \ Next ASCII code
1A3E29C 	 0 73 63 61 
1A3E2A0 	6E 63 6F 64 65 2D 3E 63 
1A3E2A8 	68 61 72 8E 24 E2 A3  1 
1A3E2B0 	20 40 A0  1 
   \ If the scancode is the keyboard escape prefix, set the MF II flag
   \ for use in processing the next scancode.
   dup h# e0 =  if  true to mfii?  drop false exit  then
1A3E2B4 	40 49 A0  1 
1A3E2B8 	58 41 A0  1 E0  0  0  0 
1A3E2C0 	24 48 A0  1 DC 41 A0  1 
1A3E2C8 	1C  0  0  0  4 70 A0  1 
1A3E2D0 	B8 40 A0  1 1C CB A3  1 
1A3E2D8 	30 49 A0  1 18 70 A0  1 
1A3E2E0 	40 46 A0  1 

   \ Otherwise, leave the MF II flag at its previous value while
   \ decoding this scancode, then clear it before returning.

   (scancode->char)                     ( false | ASCII true )
1A3E2E4 	24 E2 A3  1 

   false to mfii?                       ( false | ASCII true )
1A3E2E8 	18 70 A0  1 B8 40 A0  1 
1A3E2F0 	1C CB A3  1 
;
1A3E2F4 	58 46 A0  1 

0 instance value time-limit
1A3E2F8 	 0 74 69 6D 65 2D 6C 69 
1A3E300 	6D 69 74 8A B0 E2 A3  1 
1A3E308 	C0 FE A1  1 1C  0  0  0 
headers
: get-scancode  ( msecs -- false | scancode true )
1A3E310 	 0  0  0 67 65 74 2D 73 
1A3E318 	63 61 6E 63 6F 64 65 8C 
1A3E320 	 8 E3 A3  1 20 40 A0  1 
   get-msecs + to time-limit
1A3E328 	50 E0 A1  1  4 45 A0  1 
1A3E330 	48 B8 A1  1  8 E3 A3  1 
   begin
      get-scan  deque?  if  true exit  then
1A3E338 	78 D9 A3  1 90 CA A3  1 
1A3E340 	DC 41 A0  1  C  0  0  0 
1A3E348 	 4 70 A0  1 40 46 A0  1 
      get-msecs time-limit - 0>=
1A3E350 	50 E0 A1  1  8 E3 A3  1 
1A3E358 	18 45 A0  1 C4 47 A0  1 
   until
1A3E360 	DC 41 A0  1 D4 FF FF FF 
   false
1A3E368 	18 70 A0  1 
;
1A3E36C 	58 46 A0  1 

headerless
: getkey  ( -- ASCII-char true | false )
1A3E370 	 0 67 65 74 6B 65 79 86 
1A3E378 	24 E3 A3  1 20 40 A0  1 
   #queued  if  #queued 1- dup to #queued  ascii-queue + c@  true exit  then
1A3E380 	20 C8 A3  1 DC 41 A0  1 
1A3E388 	2C  0  0  0 20 C8 A3  1 
1A3E390 	54 4B A0  1 40 49 A0  1 
1A3E398 	B8 40 A0  1 20 C8 A3  1 
1A3E3A0 	38 C8 A3  1  4 45 A0  1 
1A3E3A8 	C4 4C A0  1  4 70 A0  1 
1A3E3B0 	40 46 A0  1 
   begin
      get-scan  deque?  0=  if  false exit  then   ( scancode )
1A3E3B4 	78 D9 A3  1 
1A3E3B8 	90 CA A3  1 24 47 A0  1 
1A3E3C0 	DC 41 A0  1  C  0  0  0 
1A3E3C8 	18 70 A0  1 40 46 A0  1 
   scancode->char  until     ( ASCII-char )
1A3E3D0 	B0 E2 A3  1 DC 41 A0  1 
1A3E3D8 	DC FF FF FF 
   true
1A3E3DC 	 4 70 A0  1 
;
1A3E3E0 	58 46 A0  1 

[ifdef] fix-keyboard
\ keyboard-owner: 0 firmware  1 client   2 firmware,using client's scan set
0 value keyboard-owner
0 value client-scan-set
: fw-scan-set  ( -- )
   keyboard-owner 1 =  if
      get-scan-set to client-scan-set
      client-scan-set  h# f and  1  =  if
         2 to keyboard-owner		\ We can use the client's scan set
      else
         0 to keyboard-owner		\ The firmware scan set is in use
         \ The client is using a scan set other than 1, so we switch
         \ it to set 1.  If translation is off, we tell the keyboard to
         \ send set 1; otherwise we tell the keyboard to send set 2,
         \ and let the 8042 translate it to 1.  This minimizes the
         \ amount of work we must do.
         client-scan-set  3  <=  if  1  else  2  then  lock set-scan-set unlock
      then
   then
;

\ Restore the scan set to whatever the client was using
: entering-client  ( -- )
   keyboard-owner  0=  if
      client-scan-set ?dup  if
         dup  3 >  if   ( scan-set:1,2,3,43,41,3f )
            \ Translation is on, so we have to account for the translation
            \ 43 -> 1  41 -> 2  3f -> 3
            h# 45 swap - 2/
         then                            ( kbd-scan-set:1,2,3 )
         lock set-scan-set unlock
      then
   then
   1 to keyboard-owner
;

[then]


headers
\ Search the keyboards vocabulary for an entry that contains the
\ given string in its language field.
: set-language  ( adr len -- flag )
1A3E3E4 	 0  0  0 73 
1A3E3E8 	65 74 2D 6C 61 6E 67 75 
1A3E3F0 	61 67 65 8C 7C E3 A3  1 
1A3E3F8 	20 40 A0  1 
   2 <>  if  drop false  exit  then                ( adr )
1A3E3FC 	90 6F A0  1 
1A3E400 	44 48 A0  1 DC 41 A0  1 
1A3E408 	10  0  0  0 30 49 A0  1 
1A3E410 	18 70 A0  1 40 46 A0  1 
   ['] keyboards  follow  begin  another?  while   ( adr anf )
1A3E418 	60 53 A0  1 E4 D0 A3  1 
1A3E420 	38 BC A0  1 68 BC A0  1 
1A3E428 	DC 41 A0  1 4C  0  0  0 
      2dup  name> >body  2 comp  0=  if            ( adr anf )
1A3E430 	C0 49 A0  1  8 74 A0  1 
1A3E438 	E4 59 A0  1 90 6F A0  1 
1A3E440 	38 52 A0  1 24 47 A0  1 
1A3E448 	DC 41 A0  1 24  0  0  0 
         dup name>string rot name> (set-keyboard)  ( adr )
1A3E450 	40 49 A0  1 58 74 A0  1 
1A3E458 	7C 49 A0  1  8 74 A0  1 
1A3E460 	50 D2 A3  1 
         drop  true exit                           ( flag )
1A3E464 	30 49 A0  1 
1A3E468 	 4 70 A0  1 40 46 A0  1 
      then                                         ( adr anf )
   repeat                                          ( adr anf )
1A3E470 	C8 41 A0  1 B0 FF FF FF 
   2drop false                                     ( false )
1A3E478 	AC 49 A0  1 18 70 A0  1 
;
1A3E480 	58 46 A0  1 

: read   ( adr len -- #read )
1A3E484 	 0  0  0 72 
1A3E488 	65 61 64 84 F8 E3 A3  1 
1A3E490 	20 40 A0  1 
[ifdef] fw-scan-set  fw-scan-set  [then]

   \ Poll the keyboard even if len is 0, as extra insurance against overrun
   get-scan                                   ( adr len )
1A3E494 	78 D9 A3  1 
   tuck                                       ( len adr len )
1A3E498 	E8 46 A0  1 
   begin                                      ( len adr' len' )
      dup 0<>  if  getkey  else  false  then  ( len adr' len' [ char ] flag )
1A3E49C 	40 49 A0  1 
1A3E4A0 	44 47 A0  1 DC 41 A0  1 
1A3E4A8 	10  0  0  0 7C E3 A3  1 
1A3E4B0 	C8 41 A0  1  8  0  0  0 
1A3E4B8 	18 70 A0  1 
   while                                      ( len adr' len' char )
1A3E4BC 	DC 41 A0  1 
1A3E4C0 	20  0  0  0 
      2 pick c!                               ( len adr' len' )
1A3E4C4 	90 6F A0  1 
1A3E4C8 	 C 4A A0  1 B8 4D A0  1 
      1 /string                               ( len adr'' len'' )
1A3E4D0 	80 6F A0  1 3C 85 A0  1 
   repeat                                     ( len adr' len' )
1A3E4D8 	C8 41 A0  1 C0 FF FF FF 
   nip -                                      ( #read )
1A3E4E0 	FC 46 A0  1 18 45 A0  1 
   dup  0=  if  drop -2  then                 ( #read | -2 )
1A3E4E8 	40 49 A0  1 24 47 A0  1 
1A3E4F0 	DC 41 A0  1 10  0  0  0 
1A3E4F8 	30 49 A0  1 58 41 A0  1 
1A3E500 	FE FF FF FF 
;
1A3E504 	58 46 A0  1 

: ring-bell  ( -- )  " audio" " ring-bell" execute-device-method drop  ;
1A3E508 	 0  0 72 69 6E 67 2D 62 
1A3E510 	65 6C 6C 89 90 E4 A3  1 
1A3E518 	20 40 A0  1 9C 53 A0  1 
1A3E520 	 5 61 75 64 69 6F  0  0 
1A3E528 	9C 53 A0  1  9 72 69 6E 
1A3E530 	67 2D 62 65 6C 6C  0  0 
1A3E538 	84 3F A2  1 30 49 A0  1 
1A3E540 	58 46 A0  1 

: selftest  ( -- fail? )
1A3E544 	 0  0  0 73 
1A3E548 	65 6C 66 74 65 73 74 88 
1A3E550 	18 E5 A3  1 20 40 A0  1 
   kbd-refcount @ 0<>  if  
1A3E558 	34 DA A3  1 5C 4C A0  1 
1A3E560 	44 47 A0  1 DC 41 A0  1 
1A3E568 	 C  0  0  0 
      0 exit
1A3E56C 	70 6F A0  1 
1A3E570 	40 46 A0  1 
   then
   reset  keyboard-present?  if
1A3E574 	F0 D7 A3  1 
1A3E578 	B4 C8 A3  1 DC 41 A0  1 
1A3E580 	10  0  0  0 
      false
1A3E584 	18 70 A0  1 
   else
1A3E588 	C8 41 A0  1 24  0  0  0 
      ." No keyboard found" cr  true
1A3E590 	20 7C A0  1 11 4E 6F 20 
1A3E598 	6B 65 79 62 6F 61 72 64 
1A3E5A0 	20 66 6F 75 6E 64  0  0 
1A3E5A8 	80 6D A0  1  4 70 A0  1 
   then
;
1A3E5B0 	58 46 A0  1 

[ifdef] apple-chords
0 value previous-scan		\ Memory for detecting key chords.
\ These words are for detecting key-chords
\ chord-index takes two scan codes, and returns and index which
\ tells if a pair of keys is held down. The scan codes are expected to
\ be regular keys. Other code will deal with the cntl, alt etc.

\ 1 = forth prompt on scc-a  o-f
\ 2 = menu           o-m
\ 3 = set NVRAM defaults n-v
\ 4 = set Diag-mode o-d
\ 5 = forth prompt on com1
\ add others as needed.   

create chord-pairs      \ table of pairs of scan codes to watch for
\ for scancodes
h# 18 h# 21 , ,         \ o f - debug out scca
h# 18 h# 32 , ,         \ o m - force firmware menu
h# 31 h# 2f , ,         \ n v - reset nvram
h# 18 h# 20 , ,         \ o d - set true to diagnostic-mode?
h# 18 h# 2e , ,         \ o c - debug out com1
create end-pairs

\ chord-index searches for special key pairs.
: chord-index ( n1 n2 -- index ) \ index where  (n1n2 or n2n1) found. 0=none.
   end-pairs chord-pairs do
      2dup  i 2@  d=  -rot       ( flag1 n1 n2 )
      2dup swap  i 2@  d=        ( flag1 n1 n2 flag2 )
      -rot 2swap                 ( n1 n2 flag1 flag2 )
      or  if                     ( n1 n2 ) \ if match found ....
         2drop                    (  )  \ drop n1 n2
         i chord-pairs -          ( relative addr where found )
         2 cells /  1+            ( index ) \  return index showing where match found
         unloop exit              \ leave now
      then
   2 cells +loop                ( n1 n2 ) \ step through 2 cells at a time
   2drop                         (  )  \ drop n1 n2
   false                        \ if we never exit no match was found.
;

\ set-specials  searches for ctrl-alt-x-y key combinations which do 
\ special things like force the menu or debug out the com port.
: set-specials ( scancode - flag )
   false swap 
   dup h# e0 = if  drop  exit  then
   dup h# 80 and  0=  swap  h# 7f and   ( false down? scan )
   dup h# 60 >=  if  2drop  exit  then
   case					( false  down? scan )
     1d  of  to ctrl?   endof    \ CTRL-L  (CTLR-R is eO 1d)
     38  of  to alt-gr? endof    \ ALT-L   (ALT-R is e0 38)
     nip alt-gr? ctrl? and if 		( false scan )
        ." ca " 
        dup previous-scan chord-index ?dup if ( false scan index )
            rot drop swap  		( index scan )
        then 
        dup to previous-scan
     then 
   endcase				( index )
;

\ get-key-chord  polls the keyboard for approx. 2 seconds looking for a 
\ special key code sequence.  
: get-key-chord ( -- chord-index)
   reset			\ reset-kbd
   unlock
   0 to previous-scan 
   \ Loop for approximately 2 seconds on a 200 Mhz 604. 
   8000 0 do
      get-scan deque? if
         set-specials ?dup if 
	    \ make sure to unlock the keyboard when finished. 
            unloop unlock exit 
         then 
      then
   loop

   \ Only get here if no keys were pressed so return false. 
   false
;
[then]


OpenFirmware/dev/pckbd.fth_AL	1E3C 1A3E5B4 
99DA164   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99DA174   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99D94D4   60 00 00 00  00 00 00 00  00 00 00 00  01 00 00 00 `...............
99D94E4   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................purpose: Calibrate Time Stamp Counter against ISA timer - without interrupts

\ This code works only for processors that have a Time Stamp Counter register

code calibrate-loop  ( -- tscdelta )
1A3E6B0 	 0 63 61 6C 69 62 72 61 
1A3E6B8 	74 65 2D 6C 6F 6F 70 8E 
1A3E6C0 	10 BB A3  1 C8 E6 A3  1 
   \ setup timer 0 to interrupt when the count goes to 0

   \ TTRR.MMMB Timer 0, r/w=lsb,msb, mode 0, binary
   h# 30 #  al  mov   al  h# 43 #  out	\ Start setting timer
1A3E6C8 	B0 30 E6 43 

   d# 11932 wbsplit swap     ( tick-cnt-high tick-cnt-low )
   #  al  mov   al  h# 40 #  out	\ Set tick limit low  ( tick-cnt-high )
1A3E6CC 	B0 9C E6 40 
					\ The timer should now be stopped

   h# f c,  h# 31 c,	\ Get time-stamp counter value into DX,AX
1A3E6D0 	 F 31 
   ax cx mov		\ Save the low part in CX; the high part is not needed
1A3E6D2 	8B C8 

   #  al  mov   al  h# 40 #  out	\ Set tick limit high to start timer
1A3E6D4 	B0 2E E6 40 

   begin
      ax ax xor  al  h# 43 #  out	\ Latch timer
1A3E6D8 	31 C0 E6 43 
      h# 40 # al in
1A3E6DC 	E4 40 
      al ah mov
1A3E6DE 	8A E0 
      h# 40 # al in
1A3E6E0 	E4 40 
      al ah xchg
1A3E6E2 	86 E0 
      \ The number 10 below gives a sufficient window to ensure that a count
      \ value in the range from 0 to 9 is seen.  The process of latching the
      \ timer and reading the value is time-consuming because I/O port access
      \ is slow, comparable to the clock that drives the ticker.  For many
      \ systems, a value of 5 is enough, but I have seen systems that need 8.
      d# 10 #  ax  cmp
1A3E6E4 	3D  A  0  0 
1A3E6E8 	 0 
   < until
1A3E6E9 	7D ED 
   
   h# f c,  h# 31 c,	\ Get time-stamp counter value into DX,AX
1A3E6EB 	 F 31 
   cx ax sub		\ Subtract the low parts
1A3E6ED 	29 C8 
   
   ax push
1A3E6EF 	50 
c;
1A3E6F0 	FF E7 


\needs ms-factor -1 value ms-factor
\needs us-factor -1 value us-factor
: calibrate-ms  ( -- )
1A3E6F2 	 0 63 61 6C 69 62 
1A3E6F8 	72 61 74 65 2D 6D 73 8C 
1A3E700 	C4 E6 A3  1 20 40 A0  1 
\ mmo   disable-interrupts
   calibrate-loop   dup d# 10 / to ms-factor  ( count-value )
1A3E708 	C4 E6 A3  1 40 49 A0  1 
1A3E710 	58 41 A0  1  A  0  0  0 
1A3E718 	98 5F A0  1 B8 40 A0  1 
1A3E720 	80 85 A3  1 
   d# 10000 / to us-factor   \ Divide by 1000 with rounding
1A3E724 	58 41 A0  1 
1A3E728 	10 27  0  0 98 5F A0  1 
1A3E730 	B8 40 A0  1 98 85 A3  1 
;
1A3E738 	58 46 A0  1 
stand-init: Calibrating millisecond timer
1A3E73C 	 0 73 74 61 
1A3E740 	6E 64 2D 69 6E 69 74 8A 
1A3E748 	 4 E7 A3  1 20 40 A0  1 
1A3E750 	3C 9D A3  1 9C 53 A0  1 
1A3E758 	1D 43 61 6C 69 62 72 61 
1A3E760 	74 69 6E 67 20 6D 69 6C 
1A3E768 	6C 69 73 65 63 6F 6E 64 
1A3E770 	20 74 69 6D 65 72  0  0 
1A3E778 	80 6D A0  1  4 6C A0  1 
   calibrate-ms
1A3E780 	 4 E7 A3  1 
;
1A3E784 	58 46 A0  1 


OpenFirmware/cpu/x86/pc/tsccal1.fth_AL	D8 1A3E788 
begin-package
select-dev=</isa>0 0 5D9086 4 

propset=1A3E79C B442C87 1A00D28 
vocset=B442C87 1A00D28 1A3E79C 
new-node=B442C9B 1A00D08 
vocset=B442C9B 1A00D08 1A3E79C 0 0 5D9086 4 

set-args0=4 5D9086 0 0 
begin-package;
my-#adr-cells=|0x3E79C |2 

encode-bytes=1A3E8DC 0 |0x3E8DC |2 

encode-1f0=1A3E8DC 0 1A3E8DC 8 |0x3E8E4 

encode-1f0+=1A3E8DC 8 |0x3E8E4 

encode-8=1A3E8DC C |0x3E8E8 

encode-3f6=1A3E8DC 14 
1A3E914 purpose: IDE bus package implementing a "ide" device-type interface.


cr .( my-#adr-cells=) .s .( |) here origin - .h .( |)  my-#adr-cells . cr 

hex

create include-secondary-ide \ mmo
1A3E79C 	 0  0 69 6E 
1A3E7A0 	63 6C 75 64 65 2D 73 65 
1A3E7A8 	63 6F 6E 64 61 72 79 2D 
1A3E7B0 	69 64 65 95  0  0 A0  1 
1A3E7B8 	30 40 A0  1 

\ Map the device into virtual address space
: (map)  ( -- pri-chip-base pri-dor sec-chip-base sec-dor )
1A3E7BC 	 0  0 28 6D 
1A3E7C0 	61 70 29 85 B8 E7 A3  1 
1A3E7C8 	20 40 A0  1 
   my-address my-space 8 " map-in" $call-parent
1A3E7CC 	20 10 A2  1 
1A3E7D0 	AC  3 A2  1 F0 6F A0  1 
1A3E7D8 	9C 53 A0  1  6 6D 61 70 
1A3E7E0 	2D 69 6E  0 DC 31 A2  1 
   h# 3f6     my-space 1 " map-in" $call-parent
1A3E7E8 	58 41 A0  1 F6  3  0  0 
1A3E7F0 	AC  3 A2  1 80 6F A0  1 
1A3E7F8 	9C 53 A0  1  6 6D 61 70 
1A3E800 	2D 69 6E  0 DC 31 A2  1 
[ifdef] include-secondary-ide
   h# 170     my-space 8 " map-in" $call-parent
1A3E808 	58 41 A0  1 70  1  0  0 
1A3E810 	AC  3 A2  1 F0 6F A0  1 
1A3E818 	9C 53 A0  1  6 6D 61 70 
1A3E820 	2D 69 6E  0 DC 31 A2  1 
   h# 376     my-space 1 " map-in" $call-parent
1A3E828 	58 41 A0  1 76  3  0  0 
1A3E830 	AC  3 A2  1 80 6F A0  1 
1A3E838 	9C 53 A0  1  6 6D 61 70 
1A3E840 	2D 69 6E  0 DC 31 A2  1 
[else]
   0 0
[then]
;
1A3E848 	58 46 A0  1 

\ Release the mapping resources used by the device
: (unmap)  ( pri-chip-base pri-dor sec-chip-base sec-dor -- )
1A3E84C 	28 75 6E 6D 
1A3E850 	61 70 29 87 C8 E7 A3  1 
1A3E858 	20 40 A0  1 
[ifdef] include-secondary-ide
   8  " map-out" $call-parent
1A3E85C 	F0 6F A0  1 
1A3E860 	9C 53 A0  1  7 6D 61 70 
1A3E868 	2D 6F 75 74  0  0  0  0 
1A3E870 	DC 31 A2  1 
   1  " map-out" $call-parent
1A3E874 	80 6F A0  1 
1A3E878 	9C 53 A0  1  7 6D 61 70 
1A3E880 	2D 6F 75 74  0  0  0  0 
1A3E888 	DC 31 A2  1 
[else]
   2drop
[then]
   8  " map-out" $call-parent
1A3E88C 	F0 6F A0  1 
1A3E890 	9C 53 A0  1  7 6D 61 70 
1A3E898 	2D 6F 75 74  0  0  0  0 
1A3E8A0 	DC 31 A2  1 
   1  " map-out" $call-parent
1A3E8A4 	80 6F A0  1 
1A3E8A8 	9C 53 A0  1  7 6D 61 70 
1A3E8B0 	2D 6F 75 74  0  0  0  0 
1A3E8B8 	DC 31 A2  1 
;
1A3E8BC 	58 46 A0  1 

: int+  ( adr len n -- adr' len' )  encode-int encode+  ;
1A3E8C0 	 0  0  0 69 6E 74 2B 84 
1A3E8C8 	58 E8 A3  1 20 40 A0  1 
1A3E8D0 	40 F7 A1  1 F0 F5 A1  1 
1A3E8D8 	58 46 A0  1 

0 0 encode-bytes
cr .( encode-bytes=) .s .( |) here origin - .h .( |)  my-#adr-cells . cr 
h# 1f0 1  encode-phys
1A3E8DC 	 0  0  0  1 
1A3E8E0 	 0  0  1 F0 
cr .( encode-1f0=) .s .( |) here origin - .h cr 
  encode+
cr .( encode-1f0+=) .s .( |) here origin - .h cr 
  8 int+
1A3E8E4 	 0  0  0  8 
cr .( encode-8=) .s .( |) here origin - .h cr 

h# 3f6 1  encode-phys  encode+
1A3E8E8 	 0  0  0  1  0  0  3 F6 
cr .( encode-3f6=) .s cr
  2 int+
1A3E8F0 	 0  0  0  2 
[ifdef] include-secondary-ide
h# 170 1  encode-phys  encode+  8 int+
1A3E8F4 	 0  0  0  1 
1A3E8F8 	 0  0  1 70  0  0  0  8 
h# 376 1  encode-phys  encode+  2 int+
1A3E900 	 0  0  0  1  0  0  3 76 
1A3E908 	 0  0  0  2 
[then]
" reg" property
1A3E90C 	72 65 67 83 
1A3E910 	 0  0 A0  1 BC 13 A2  1 
1A3E918 	3C  0  0  0 30  0  0  0 

OpenFirmware/dev/ide/isaintf.fth_AL	184 1A3E920 1A3E934 purpose: IDE bus package implementing a "ide" device-type interface.

\ Before loading this file, first load a file that defines a "reg"
\ property and "(map)" and "(unmap)" words.

hex

headers

0 encode-int  " #size-cells" property
1A3E920 	 0  0  0  0 23 73 69 7A 
1A3E928 	65 2D 63 65 6C 6C 73 8B 
1A3E930 	14 E9 A3  1 BC 13 A2  1 
1A3E938 	18  0  0  0  4  0  0  0 

4 value max#drives
1A3E940 	 0 6D 61 78 23 64 72 69 
1A3E948 	76 65 73 8A CC E8 A3  1 
1A3E950 	50 40 A0  1  C  D  0  0 

true value first-open?
1A3E958 	66 69 72 73 74 2D 6F 70 
1A3E960 	65 6E 3F 8B 50 E9 A3  1 
1A3E968 	50 40 A0  1 10  D  0  0 
0 value open-count
1A3E970 	 0 6F 70 65 6E 2D 63 6F 
1A3E978 	75 6E 74 8A 68 E9 A3  1 
1A3E980 	50 40 A0  1 14  D  0  0 
0 value pri-chip-base
1A3E988 	 0  0 70 72 69 2D 63 68 
1A3E990 	69 70 2D 62 61 73 65 8D 
1A3E998 	80 E9 A3  1 50 40 A0  1 
1A3E9A0 	18  D  0  0 
0 value pri-dor
1A3E9A4 	70 72 69 2D 
1A3E9A8 	64 6F 72 87 9C E9 A3  1 
1A3E9B0 	50 40 A0  1 1C  D  0  0 
0 value sec-chip-base
1A3E9B8 	 0  0 73 65 63 2D 63 68 
1A3E9C0 	69 70 2D 62 61 73 65 8D 
1A3E9C8 	B0 E9 A3  1 50 40 A0  1 
1A3E9D0 	20  D  0  0 
0 value sec-dor
1A3E9D4 	73 65 63 2D 
1A3E9D8 	64 6F 72 87 CC E9 A3  1 
1A3E9E0 	50 40 A0  1 24  D  0  0 
0 value dor-magic		\ DOR register bits that must always be set
1A3E9E8 	 0  0 64 6F 72 2D 6D 61 
1A3E9F0 	67 69 63 89 E0 E9 A3  1 
1A3E9F8 	50 40 A0  1 28  D  0  0 
0 instance value chip-base
1A3EA00 	 0  0 63 68 69 70 2D 62 
1A3EA08 	61 73 65 89 F8 E9 A3  1 
1A3EA10 	C0 FE A1  1 18  0  0  0 
0 instance value dor
1A3EA18 	64 6F 72 83 10 EA A3  1 
1A3EA20 	C0 FE A1  1 1C  0  0  0 
0 instance value drive
1A3EA28 	 0  0 64 72 69 76 65 85 
1A3EA30 	20 EA A3  1 C0 FE A1  1 
1A3EA38 	20  0  0  0 
0 instance value log-drive	\ drives 0 and 1 are on primary ide,
1A3EA3C 	 0  0 6C 6F 
1A3EA40 	67 2D 64 72 69 76 65 89 
1A3EA48 	34 EA A3  1 C0 FE A1  1 
1A3EA50 	24  0  0  0 
				\ 2 and 3 are on secondary ide

\ arrays of logical drive information
create /block       0 , 0 , 0 , 0 ,	\ drives are assumed not exist
1A3EA54 	 0 2F 62 6C 
1A3EA58 	6F 63 6B 86 4C EA A3  1 
1A3EA60 	30 40 A0  1  0  0  0  0 
1A3EA68 	 0  0  0  0  0  0  0  0 
1A3EA70 	 0  0  0  0 
\ drives are assumed IDE initially
create atapi-drive? false , false , false , false ,
1A3EA74 	 0  0  0 61 
1A3EA78 	74 61 70 69 2D 64 72 69 
1A3EA80 	76 65 3F 8C 60 EA A3  1 
1A3EA88 	30 40 A0  1  0  0  0  0 
1A3EA90 	 0  0  0  0  0  0  0  0 
1A3EA98 	 0  0  0  0 
create drive-type   0 , 0 , 0 , 0 ,	\ drives are assumed to be hard drive
1A3EA9C 	 0 64 72 69 
1A3EAA0 	76 65 2D 74 79 70 65 8A 
1A3EAA8 	88 EA A3  1 30 40 A0  1 
1A3EAB0 	 0  0  0  0  0  0  0  0 
1A3EAB8 	 0  0  0  0  0  0  0  0 
create '/secs       0 , 0 , 0 , 0 ,
1A3EAC0 	 0 27 2F 73 65 63 73 86 
1A3EAC8 	AC EA A3  1 30 40 A0  1 
1A3EAD0 	 0  0  0  0  0  0  0  0 
1A3EAD8 	 0  0  0  0  0  0  0  0 
create '/heads      0 , 0 , 0 , 0 ,
1A3EAE0 	27 2F 68 65 61 64 73 87 
1A3EAE8 	CC EA A3  1 30 40 A0  1 
1A3EAF0 	 0  0  0  0  0  0  0  0 
1A3EAF8 	 0  0  0  0  0  0  0  0 
create '/cyls       0 , 0 , 0 , 0 ,
1A3EB00 	 0 27 2F 63 79 6C 73 86 
1A3EB08 	EC EA A3  1 30 40 A0  1 
1A3EB10 	 0  0  0  0  0  0  0  0 
1A3EB18 	 0  0  0  0  0  0  0  0 
create '/lba        0 , 0 , 0 , 0 ,
1A3EB20 	 0  0 27 2F 6C 62 61 85 
1A3EB28 	 C EB A3  1 30 40 A0  1 
1A3EB30 	 0  0  0  0  0  0  0  0 
1A3EB38 	 0  0  0  0  0  0  0  0 

\ words to access the arrays
: array>  ( array-base -- indexed-addr )  log-drive cells +  ;
1A3EB40 	 0 61 72 72 61 79 3E 86 
1A3EB48 	2C EB A3  1 20 40 A0  1 
1A3EB50 	4C EA A3  1 B0 51 A0  1 
1A3EB58 	 4 45 A0  1 58 46 A0  1 
: /block@  ( -- block-size )  /block array> @  ;
1A3EB60 	2F 62 6C 6F 63 6B 40 87 
1A3EB68 	4C EB A3  1 20 40 A0  1 
1A3EB70 	60 EA A3  1 4C EB A3  1 
1A3EB78 	5C 4C A0  1 58 46 A0  1 
: /block!  ( block-size -- )  /block array> !  ;
1A3EB80 	2F 62 6C 6F 63 6B 21 87 
1A3EB88 	6C EB A3  1 20 40 A0  1 
1A3EB90 	60 EA A3  1 4C EB A3  1 
1A3EB98 	54 4D A0  1 58 46 A0  1 
: drive-type@  ( -- type )  drive-type array> @  ;
1A3EBA0 	64 72 69 76 65 2D 74 79 
1A3EBA8 	70 65 40 8B 8C EB A3  1 
1A3EBB0 	20 40 A0  1 AC EA A3  1 
1A3EBB8 	4C EB A3  1 5C 4C A0  1 
1A3EBC0 	58 46 A0  1 
: drive-type!  ( type -- )  drive-type array> !  ;
1A3EBC4 	64 72 69 76 
1A3EBC8 	65 2D 74 79 70 65 21 8B 
1A3EBD0 	B0 EB A3  1 20 40 A0  1 
1A3EBD8 	AC EA A3  1 4C EB A3  1 
1A3EBE0 	54 4D A0  1 58 46 A0  1 
: atapi-drive?@  ( -- atapi? )  atapi-drive? array> @  ;
1A3EBE8 	 0  0 61 74 61 70 69 2D 
1A3EBF0 	64 72 69 76 65 3F 40 8D 
1A3EBF8 	D4 EB A3  1 20 40 A0  1 
1A3EC00 	88 EA A3  1 4C EB A3  1 
1A3EC08 	5C 4C A0  1 58 46 A0  1 
: atapi-drive?!  ( atapi? -- )  atapi-drive? array> !  ;
1A3EC10 	 0  0 61 74 61 70 69 2D 
1A3EC18 	64 72 69 76 65 3F 21 8D 
1A3EC20 	FC EB A3  1 20 40 A0  1 
1A3EC28 	88 EA A3  1 4C EB A3  1 
1A3EC30 	54 4D A0  1 58 46 A0  1 
: /secs   ( -- spt )    '/secs  array> @  ;
1A3EC38 	 0  0 2F 73 65 63 73 85 
1A3EC40 	24 EC A3  1 20 40 A0  1 
1A3EC48 	CC EA A3  1 4C EB A3  1 
1A3EC50 	5C 4C A0  1 58 46 A0  1 
: /secs!  ( spt -- )    '/secs  array> !  ;
1A3EC58 	 0 2F 73 65 63 73 21 86 
1A3EC60 	44 EC A3  1 20 40 A0  1 
1A3EC68 	CC EA A3  1 4C EB A3  1 
1A3EC70 	54 4D A0  1 58 46 A0  1 
: /cyls   ( -- cyls )   '/cyls  array> @  ;
1A3EC78 	 0  0 2F 63 79 6C 73 85 
1A3EC80 	64 EC A3  1 20 40 A0  1 
1A3EC88 	 C EB A3  1 4C EB A3  1 
1A3EC90 	5C 4C A0  1 58 46 A0  1 
: /cyls!  ( cyls -- )   '/cyls  array> !  ;
1A3EC98 	 0 2F 63 79 6C 73 21 86 
1A3ECA0 	84 EC A3  1 20 40 A0  1 
1A3ECA8 	 C EB A3  1 4C EB A3  1 
1A3ECB0 	54 4D A0  1 58 46 A0  1 
: /heads  ( -- heads )  '/heads array> @  ;
1A3ECB8 	 0 2F 68 65 61 64 73 86 
1A3ECC0 	A4 EC A3  1 20 40 A0  1 
1A3ECC8 	EC EA A3  1 4C EB A3  1 
1A3ECD0 	5C 4C A0  1 58 46 A0  1 
: /heads! ( heads -- )  '/heads array> !  ;
1A3ECD8 	2F 68 65 61 64 73 21 87 
1A3ECE0 	C4 EC A3  1 20 40 A0  1 
1A3ECE8 	EC EA A3  1 4C EB A3  1 
1A3ECF0 	54 4D A0  1 58 46 A0  1 
: /lba    ( -- #secs )  '/lba   array> @  ;
1A3ECF8 	 0  0  0 2F 6C 62 61 84 
1A3ED00 	E4 EC A3  1 20 40 A0  1 
1A3ED08 	2C EB A3  1 4C EB A3  1 
1A3ED10 	5C 4C A0  1 58 46 A0  1 
: /lba!   ( #secs -- )  '/lba   array> !  ;
1A3ED18 	 0  0 2F 6C 62 61 21 85 
1A3ED20 	 4 ED A3  1 20 40 A0  1 
1A3ED28 	2C EB A3  1 4C EB A3  1 
1A3ED30 	54 4D A0  1 58 46 A0  1 

\ Register definitions

\ 0 constant r-data
\ 1 constant r-error
\ 2 constant r-#secs
\ 3 constant r-sector
\ 4 constant r-cyl-lsb
\ 5 constant r-cyl-msb
\ 6 constant r-drive/head
\ 7 constant r-csr

\ Access methods

: reg@  ( reg#  --  data )  chip-base + rb@  ;
1A3ED38 	 0  0  0 72 65 67 40 84 
1A3ED40 	24 ED A3  1 20 40 A0  1 
1A3ED48 	10 EA A3  1  4 45 A0  1 
1A3ED50 	A8 B1 A2  1 58 46 A0  1 

: r-data@   ( -- data  )  chip-base w@  ;
1A3ED58 	72 2D 64 61 74 61 40 87 
1A3ED60 	44 ED A3  1 20 40 A0  1 
1A3ED68 	10 EA A3  1 94 4C A0  1 
1A3ED70 	58 46 A0  1 
: r-error@  ( -- error )  1 reg@  ;
1A3ED74 	 0  0  0 72 
1A3ED78 	2D 65 72 72 6F 72 40 88 
1A3ED80 	64 ED A3  1 20 40 A0  1 
1A3ED88 	80 6F A0  1 44 ED A3  1 
1A3ED90 	58 46 A0  1 
: r-#secs@  ( -- #secs )  2 reg@  ;
1A3ED94 	 0  0  0 72 
1A3ED98 	2D 23 73 65 63 73 40 88 
1A3EDA0 	84 ED A3  1 20 40 A0  1 
1A3EDA8 	90 6F A0  1 44 ED A3  1 
1A3EDB0 	58 46 A0  1 
: r-sector@ ( -- secno )  3 reg@  ;
1A3EDB4 	 0  0 72 2D 
1A3EDB8 	73 65 63 74 6F 72 40 89 
1A3EDC0 	A4 ED A3  1 20 40 A0  1 
1A3EDC8 	A0 6F A0  1 44 ED A3  1 
1A3EDD0 	58 46 A0  1 
: r-cyl@    ( -- cylno )  4 reg@  5 reg@  bwjoin  ;
1A3EDD4 	 0 72 2D 63 
1A3EDD8 	79 6C 40 86 C4 ED A3  1 
1A3EDE0 	20 40 A0  1 B0 6F A0  1 
1A3EDE8 	44 ED A3  1 C0 6F A0  1 
1A3EDF0 	44 ED A3  1 84 FB A0  1 
1A3EDF8 	58 46 A0  1 
: r-head@   ( -- head# unit )  6 reg@ dup 0f and swap 4 rshift 1 and  ;
1A3EDFC 	72 2D 68 65 
1A3EE00 	61 64 40 87 E0 ED A3  1 
1A3EE08 	20 40 A0  1 D0 6F A0  1 
1A3EE10 	44 ED A3  1 40 49 A0  1 
1A3EE18 	58 41 A0  1  F  0  0  0 
1A3EE20 	5C 44 A0  1 68 49 A0  1 
1A3EE28 	B0 6F A0  1 B4 44 A0  1 
1A3EE30 	80 6F A0  1 5C 44 A0  1 
1A3EE38 	58 46 A0  1 
: r-csr@    ( -- stat  )  7 reg@  ;
1A3EE3C 	 0 72 2D 63 
1A3EE40 	73 72 40 86  8 EE A3  1 
1A3EE48 	20 40 A0  1 E0 6F A0  1 
1A3EE50 	44 ED A3  1 58 46 A0  1 
: r-dor@    ( -- stat  )  dor rb@ ;
1A3EE58 	 0 72 2D 64 6F 72 40 86 
1A3EE60 	48 EE A3  1 20 40 A0  1 
1A3EE68 	20 EA A3  1 A8 B1 A2  1 
1A3EE70 	58 46 A0  1 
: r-dor!    ( val   -- )  dor-magic or dor rb!  ;
1A3EE74 	 0 72 2D 64 
1A3EE78 	6F 72 21 86 64 EE A3  1 
1A3EE80 	20 40 A0  1 F8 E9 A3  1 
1A3EE88 	70 44 A0  1 20 EA A3  1 
1A3EE90 	1C B2 A2  1 58 46 A0  1 

\ Spin until BSY == 0, RDY == 1, indicating registers can be touched
: wait-while-busy  ( -- timeout? )
1A3EE98 	77 61 69 74 2D 77 68 69 
1A3EEA0 	6C 65 2D 62 75 73 79 8F 
1A3EEA8 	80 EE A3  1 20 40 A0  1 
   get-msecs  d# 5000 +                 ( end-time )
1A3EEB0 	50 E0 A1  1 58 41 A0  1 
1A3EEB8 	88 13  0  0  4 45 A0  1 
   begin
      r-csr@  dup 0=                    ( end-time csr flag )
1A3EEC0 	48 EE A3  1 40 49 A0  1 
1A3EEC8 	24 47 A0  1 
      over h# ff =              or      ( end-time csr flag )
1A3EECC 	54 49 A0  1 
1A3EED0 	58 41 A0  1 FF  0  0  0 
1A3EED8 	24 48 A0  1 70 44 A0  1 
      swap h# c0 and  h# 40 =   or      ( end-time csr=0|ff|4x? )  \ !BSY (80), DRDY (40)
1A3EEE0 	68 49 A0  1 58 41 A0  1 
1A3EEE8 	C0  0  0  0 5C 44 A0  1 
1A3EEF0 	58 41 A0  1 40  0  0  0 
1A3EEF8 	24 48 A0  1 70 44 A0  1 
      if  drop false exit  then         ( end-time )
1A3EF00 	DC 41 A0  1 10  0  0  0 
1A3EF08 	30 49 A0  1 18 70 A0  1 
1A3EF10 	40 46 A0  1 
      dup get-msecs -                   ( end-time remaining-time )
1A3EF14 	40 49 A0  1 
1A3EF18 	50 E0 A1  1 18 45 A0  1 
   0<= until				( end-time )
1A3EF20 	84 47 A0  1 DC 41 A0  1 
1A3EF28 	98 FF FF FF 
   drop	 true				( true )
1A3EF2C 	30 49 A0  1 
1A3EF30 	 4 70 A0  1 
;
1A3EF34 	58 46 A0  1 

: reg!  ( data reg#  --  )  wait-while-busy drop  chip-base + rb!  ;
1A3EF38 	 0  0  0 72 65 67 21 84 
1A3EF40 	AC EE A3  1 20 40 A0  1 
1A3EF48 	AC EE A3  1 30 49 A0  1 
1A3EF50 	10 EA A3  1  4 45 A0  1 
1A3EF58 	1C B2 A2  1 58 46 A0  1 

: r-data!   ( data  -- )  chip-base w!  ;
1A3EF60 	72 2D 64 61 74 61 21 87 
1A3EF68 	44 EF A3  1 20 40 A0  1 
1A3EF70 	10 EA A3  1 A4 4D A0  1 
1A3EF78 	58 46 A0  1 
: r-features!  ( data -- )  1 reg!  ;
1A3EF7C 	72 2D 66 65 
1A3EF80 	61 74 75 72 65 73 21 8B 
1A3EF88 	6C EF A3  1 20 40 A0  1 
1A3EF90 	80 6F A0  1 44 EF A3  1 
1A3EF98 	58 46 A0  1 
: r-#secs!  ( #secs -- )  2 reg!  ;
1A3EF9C 	 0  0  0 72 
1A3EFA0 	2D 23 73 65 63 73 21 88 
1A3EFA8 	8C EF A3  1 20 40 A0  1 
1A3EFB0 	90 6F A0  1 44 EF A3  1 
1A3EFB8 	58 46 A0  1 
: r-sector! ( secno -- )  3 reg!  ;
1A3EFBC 	 0  0 72 2D 
1A3EFC0 	73 65 63 74 6F 72 21 89 
1A3EFC8 	AC EF A3  1 20 40 A0  1 
1A3EFD0 	A0 6F A0  1 44 EF A3  1 
1A3EFD8 	58 46 A0  1 
: r-cyl!    ( cylno -- )  wbsplit  5 reg!  4 reg!  ;
1A3EFDC 	 0 72 2D 63 
1A3EFE0 	79 6C 21 86 CC EF A3  1 
1A3EFE8 	20 40 A0  1 54 FB A0  1 
1A3EFF0 	C0 6F A0  1 44 EF A3  1 
1A3EFF8 	B0 6F A0  1 44 EF A3  1 
1A3F000 	58 46 A0  1 

\ XXX we should probably convert to logical block addressing, in which
\ case we would use e0 instead of a0

: r-head!   ( head# unit -- )  4 lshift h# a0 or or  6 chip-base +  rb!  ;
1A3F004 	72 2D 68 65 
1A3F008 	61 64 21 87 E8 EF A3  1 
1A3F010 	20 40 A0  1 B0 6F A0  1 
1A3F018 	9C 44 A0  1 58 41 A0  1 
1A3F020 	A0  0  0  0 70 44 A0  1 
1A3F028 	70 44 A0  1 D0 6F A0  1 
1A3F030 	10 EA A3  1  4 45 A0  1 
1A3F038 	1C B2 A2  1 58 46 A0  1 
: r-csr!    ( cmd   -- )  7 reg!  ;
1A3F040 	 0 72 2D 63 73 72 21 86 
1A3F048 	10 F0 A3  1 20 40 A0  1 
1A3F050 	E0 6F A0  1 44 EF A3  1 
1A3F058 	58 46 A0  1 

defer io-blk-w!  defer io-blk-w@
1A3F05C 	 0  0 69 6F 
1A3F060 	2D 62 6C 6B 2D 77 21 89 
1A3F068 	4C F0 A3  1 5C 40 A0  1 
1A3F070 	2C  D  0  0  0  0 69 6F 
1A3F078 	2D 62 6C 6B 2D 77 40 89 
1A3F080 	6C F0 A3  1 5C 40 A0  1 
1A3F088 	30  D  0  0 
: (io-blk-w!)  ( adr len port -- )
1A3F08C 	28 69 6F 2D 
1A3F090 	62 6C 6B 2D 77 21 29 8B 
1A3F098 	84 F0 A3  1 20 40 A0  1 
   -rot bounds  do  i c@  i 1+ c@  bwjoin  over rw!  /w +loop  drop
1A3F0A0 	94 49 A0  1 F0 6D A0  1 
1A3F0A8 	88 42 A0  1 30  0  0  0 
1A3F0B0 	B4 42 A0  1 C4 4C A0  1 
1A3F0B8 	B4 42 A0  1 30 4B A0  1 
1A3F0C0 	C4 4C A0  1 84 FB A0  1 
1A3F0C8 	54 49 A0  1 40 B2 A2  1 
1A3F0D0 	20 51 A0  1 1C 42 A0  1 
1A3F0D8 	D8 FF FF FF 30 49 A0  1 
;
1A3F0E0 	58 46 A0  1 
: (io-blk-w@)  ( adr len port -- )
1A3F0E4 	28 69 6F 2D 
1A3F0E8 	62 6C 6B 2D 77 40 29 8B 
1A3F0F0 	9C F0 A3  1 20 40 A0  1 
   -rot bounds  do  dup rw@  wbsplit  i 1+ c!  i c!  /w +loop  drop
1A3F0F8 	94 49 A0  1 F0 6D A0  1 
1A3F100 	88 42 A0  1 30  0  0  0 
1A3F108 	40 49 A0  1 D0 B1 A2  1 
1A3F110 	54 FB A0  1 B4 42 A0  1 
1A3F118 	30 4B A0  1 B8 4D A0  1 
1A3F120 	B4 42 A0  1 B8 4D A0  1 
1A3F128 	20 51 A0  1 1C 42 A0  1 
1A3F130 	D8 FF FF FF 30 49 A0  1 
;
1A3F138 	58 46 A0  1 
' (io-blk-w!) to io-blk-w!
' (io-blk-w@) to io-blk-w@


\ Command definitions

\ 10 constant calibrate-cmd
\ 20 constant read-cmd
\ 30 constant write-cmd
\ 40 constant verify-cmd
\ 50 constant format-cmd
\ 70 constant seek-cmd
\ 90 constant diag-cmd
\ 91 constant set-drive-parms-cmd
\ ec constant identify-cmd

: wait-until-drq  ( -- error? )
1A3F13C 	 0 77 61 69 
1A3F140 	74 2D 75 6E 74 69 6C 2D 
1A3F148 	64 72 71 8E F4 F0 A3  1 
1A3F150 	20 40 A0  1 
   get-msecs  d# 5000 +          ( end-time )
1A3F154 	50 E0 A1  1 
1A3F158 	58 41 A0  1 88 13  0  0 
1A3F160 	 4 45 A0  1 
   begin                         ( end-time )
      r-csr@                     ( end-time csr )
1A3F164 	48 EE A3  1 

      dup h# c8 and h# 48 =  if  ( end-time csr )  \ !BSY (80), DRDY (40), DRQ (8)
1A3F168 	40 49 A0  1 58 41 A0  1 
1A3F170 	C8  0  0  0 5C 44 A0  1 
1A3F178 	58 41 A0  1 48  0  0  0 
1A3F180 	24 48 A0  1 DC 41 A0  1 
1A3F188 	10  0  0  0 
         2drop false exit
1A3F18C 	AC 49 A0  1 
1A3F190 	18 70 A0  1 40 46 A0  1 
      then                       ( end-time csr )

      h# 21 and  if              ( end-time )  \ DF (20; fault), ERR (1)
1A3F198 	58 41 A0  1 21  0  0  0 
1A3F1A0 	5C 44 A0  1 DC 41 A0  1 
1A3F1A8 	34  0  0  0 
         ." IDE data error: " r-error@ . cr
1A3F1AC 	20 7C A0  1 
1A3F1B0 	10 49 44 45 20 64 61 74 
1A3F1B8 	61 20 65 72 72 6F 72 3A 
1A3F1C0 	20  0  0  0 84 ED A3  1 
1A3F1C8 	94 7A A0  1 80 6D A0  1 
         drop true exit
1A3F1D0 	30 49 A0  1  4 70 A0  1 
1A3F1D8 	40 46 A0  1 
      then                       ( end-time )
      dup get-msecs -            ( end-time remaining-time )
1A3F1DC 	40 49 A0  1 
1A3F1E0 	50 E0 A1  1 18 45 A0  1 
   0<= until                     ( end-time )
1A3F1E8 	84 47 A0  1 DC 41 A0  1 
1A3F1F0 	74 FF FF FF 
   drop true                     ( true )
1A3F1F4 	30 49 A0  1 
1A3F1F8 	 4 70 A0  1 
;
1A3F1FC 	58 46 A0  1 

: wait-until-ready  ( -- error? )
1A3F200 	 0  0  0 77 61 69 74 2D 
1A3F208 	75 6E 74 69 6C 2D 72 65 
1A3F210 	61 64 79 90 50 F1 A3  1 
1A3F218 	20 40 A0  1 
   get-msecs d# 10000 +   ( end-time )
1A3F21C 	50 E0 A1  1 
1A3F220 	58 41 A0  1 10 27  0  0 
1A3F228 	 4 45 A0  1 
   begin                  ( end-time )
      r-csr@              ( end-time csr )
1A3F22C 	48 EE A3  1 

      dup h# 50 =  if     ( end-time csr )  \ DRDY (40), DSC (10; seek complete)
1A3F230 	40 49 A0  1 58 41 A0  1 
1A3F238 	50  0  0  0 24 48 A0  1 
1A3F240 	DC 41 A0  1 10  0  0  0 
         2drop false exit
1A3F248 	AC 49 A0  1 18 70 A0  1 
1A3F250 	40 46 A0  1 
      then                ( end-time )

      h# 21 and  if       ( end-time )      \ DF (20; fault), ERR (1)
1A3F254 	58 41 A0  1 
1A3F258 	21  0  0  0 5C 44 A0  1 
1A3F260 	DC 41 A0  1 2C  0  0  0 
         ." IDE Drive Error" cr
1A3F268 	20 7C A0  1  F 49 44 45 
1A3F270 	20 44 72 69 76 65 20 45 
1A3F278 	72 72 6F 72  0  0  0  0 
1A3F280 	80 6D A0  1 
         drop true exit
1A3F284 	30 49 A0  1 
1A3F288 	 4 70 A0  1 40 46 A0  1 
      then                ( end-time )

      dup get-msecs -     ( end-time remaining-time )
1A3F290 	40 49 A0  1 50 E0 A1  1 
1A3F298 	18 45 A0  1 
   0<= until              ( end-time )
1A3F29C 	84 47 A0  1 
1A3F2A0 	DC 41 A0  1 88 FF FF FF 
   drop true
1A3F2A8 	30 49 A0  1  4 70 A0  1 
;
1A3F2B0 	58 46 A0  1 

: lblk>cyl-head-sect  ( block# -- cyl# head# sect# )
1A3F2B4 	 0 6C 62 6C 
1A3F2B8 	6B 3E 63 79 6C 2D 68 65 
1A3F2C0 	61 64 2D 73 65 63 74 92 
1A3F2C8 	18 F2 A3  1 20 40 A0  1 
   /secs /mod                                 ( sect# residue )
1A3F2D0 	44 EC A3  1 50 5F A0  1 
   /heads /mod swap rot 1+                    ( cyl# head# sect# )
1A3F2D8 	C4 EC A3  1 50 5F A0  1 
1A3F2E0 	68 49 A0  1 7C 49 A0  1 
1A3F2E8 	30 4B A0  1 
;
1A3F2EC 	58 46 A0  1 

defer rblock  ( adr len -- error? )
1A3F2F0 	 0 72 62 6C 6F 63 6B 86 
1A3F2F8 	CC F2 A3  1 5C 40 A0  1 
1A3F300 	34  D  0  0 
defer pio-end-hack  ' noop to pio-end-hack
1A3F304 	 0  0  0 70 
1A3F308 	69 6F 2D 65 6E 64 2D 68 
1A3F310 	61 63 6B 8C FC F2 A3  1 
1A3F318 	5C 40 A0  1 38  D  0  0 
defer pio-start-hack  ' noop to pio-start-hack
1A3F320 	 0 70 69 6F 2D 73 74 61 
1A3F328 	72 74 2D 68 61 63 6B 8E 
1A3F330 	18 F3 A3  1 5C 40 A0  1 
1A3F338 	3C  D  0  0 
: pio-rblock  ( adr len -- error? )
1A3F33C 	 0 70 69 6F 
1A3F340 	2D 72 62 6C 6F 63 6B 8A 
1A3F348 	34 F3 A3  1 20 40 A0  1 
   wait-until-drq  if  2drop true exit  then
1A3F350 	50 F1 A3  1 DC 41 A0  1 
1A3F358 	10  0  0  0 AC 49 A0  1 
1A3F360 	 4 70 A0  1 40 46 A0  1 
   pio-start-hack
1A3F368 	34 F3 A3  1 
   chip-base io-blk-w@  false
1A3F36C 	10 EA A3  1 
1A3F370 	84 F0 A3  1 18 70 A0  1 
   pio-end-hack
1A3F378 	18 F3 A3  1 
;
1A3F37C 	58 46 A0  1 
' pio-rblock to rblock

: (rblocks)  ( adr #blks -- actual# )
1A3F380 	 0  0 28 72 62 6C 6F 63 
1A3F388 	6B 73 29 89 4C F3 A3  1 
1A3F390 	20 40 A0  1 
   0 -rot                                       ( actual#blks adr #blks )
1A3F394 	70 6F A0  1 
1A3F398 	94 49 A0  1 
   /block@ *  bounds  ?do                       ( actual#blks )
1A3F39C 	6C EB A3  1 
1A3F3A0 	1C 5F A0  1 F0 6D A0  1 
1A3F3A8 	50 42 A0  1 30  0  0  0 
      i /block@ rblock  if  unloop exit  then   ( actual#blks )
1A3F3B0 	B4 42 A0  1 6C EB A3  1 
1A3F3B8 	FC F2 A3  1 DC 41 A0  1 
1A3F3C0 	 C  0  0  0 3C 42 A0  1 
1A3F3C8 	40 46 A0  1 
      1+                                        ( actual#blks' )
1A3F3CC 	30 4B A0  1 
   /block@ +loop                                ( actual#blks )
1A3F3D0 	6C EB A3  1 1C 42 A0  1 
1A3F3D8 	D8 FF FF FF 
;
1A3F3DC 	58 46 A0  1 
: pio-rblocks  ( addr #blks -- actual# )
1A3F3E0 	70 69 6F 2D 72 62 6C 6F 
1A3F3E8 	63 6B 73 8B 90 F3 A3  1 
1A3F3F0 	20 40 A0  1 
   ['] pio-rblock to rblock
1A3F3F4 	60 53 A0  1 
1A3F3F8 	4C F3 A3  1 98 40 A0  1 
1A3F400 	FC F2 A3  1 
   h# 20 r-csr!
1A3F404 	58 41 A0  1 
1A3F408 	20  0  0  0 4C F0 A3  1 
   (rblocks)
1A3F410 	90 F3 A3  1 
;
1A3F414 	58 46 A0  1 
defer rblocks
1A3F418 	72 62 6C 6F 63 6B 73 87 
1A3F420 	F0 F3 A3  1 5C 40 A0  1 
1A3F428 	40  D  0  0 
' pio-rblocks to rblocks

: pio-wblock  ( adr len -- error? )
1A3F42C 	 0 70 69 6F 
1A3F430 	2D 77 62 6C 6F 63 6B 8A 
1A3F438 	24 F4 A3  1 20 40 A0  1 
   wait-until-drq  if  2drop true exit  then
1A3F440 	50 F1 A3  1 DC 41 A0  1 
1A3F448 	10  0  0  0 AC 49 A0  1 
1A3F450 	 4 70 A0  1 40 46 A0  1 
   pio-start-hack
1A3F458 	34 F3 A3  1 
   chip-base io-blk-w!
1A3F45C 	10 EA A3  1 
1A3F460 	6C F0 A3  1 
   pio-end-hack
1A3F464 	18 F3 A3  1 
   false
1A3F468 	18 70 A0  1 
;
1A3F46C 	58 46 A0  1 

: pio-wblocks  ( addr #blks -- actual# | 0 )
1A3F470 	70 69 6F 2D 77 62 6C 6F 
1A3F478 	63 6B 73 8B 3C F4 A3  1 
1A3F480 	20 40 A0  1 
   h# 30 r-csr!                                     ( addr #blks )
1A3F484 	58 41 A0  1 
1A3F488 	30  0  0  0 4C F0 A3  1 
   
   tuck  0  ?do                                     ( #blks addr )
1A3F490 	E8 46 A0  1 70 6F A0  1 
1A3F498 	50 42 A0  1 38  0  0  0 
      dup  /block@  pio-wblock  if                  ( #blks addr )
1A3F4A0 	40 49 A0  1 6C EB A3  1 
1A3F4A8 	3C F4 A3  1 DC 41 A0  1 
1A3F4B0 	14  0  0  0 
         2drop  i  unloop exit
1A3F4B4 	AC 49 A0  1 
1A3F4B8 	B4 42 A0  1 3C 42 A0  1 
1A3F4C0 	40 46 A0  1 
      then                                          ( #blks addr )

      /block@ +                                     ( #blks addr' )
1A3F4C4 	6C EB A3  1 
1A3F4C8 	 4 45 A0  1 
   loop                                             ( #blks addr )
1A3F4CC 	F8 41 A0  1 
1A3F4D0 	D0 FF FF FF 
   drop                                             ( actual# )
1A3F4D4 	30 49 A0  1 
;
1A3F4D8 	58 46 A0  1 
defer wblocks
1A3F4DC 	77 62 6C 6F 
1A3F4E0 	63 6B 73 87 80 F4 A3  1 
1A3F4E8 	5C 40 A0  1 44  D  0  0 
' pio-wblocks to wblocks

\ Read or write "#blks" blocks starting at "block#" into memory at "addr"
\ Input? is true for reading or false for writing.

: r/w-blocks  ( addr block# #blks input? -- actual# )
1A3F4F0 	 0 72 2F 77 2D 62 6C 6F 
1A3F4F8 	63 6B 73 8A E8 F4 A3  1 
1A3F500 	20 40 A0  1 

   over 0=  if  2drop 2drop 0 exit  then
1A3F504 	54 49 A0  1 
1A3F508 	24 47 A0  1 DC 41 A0  1 
1A3F510 	14  0  0  0 AC 49 A0  1 
1A3F518 	AC 49 A0  1 70 6F A0  1 
1A3F520 	40 46 A0  1 

   >r dup >r r-#secs!                        ( addr block# ) ( R: input? #blks )
1A3F524 	BC 45 A0  1 
1A3F528 	40 49 A0  1 BC 45 A0  1 
1A3F530 	AC EF A3  1 
   /lba  if                                  ( addr block# ) ( R: input? #blks )
1A3F534 	 4 ED A3  1 
1A3F538 	DC 41 A0  1 38  0  0  0 
      lbsplit                                ( addr 0-7 8-15 16-23 24-32 )
1A3F540 	B4 FB A0  1 
      \ 4, when shifted with drive, sets the LBA bit
      h# f and  drive 4 or  r-head!          ( addr 0-7 8-15 16-23 )
1A3F544 	58 41 A0  1 
1A3F548 	 F  0  0  0 5C 44 A0  1 
1A3F550 	34 EA A3  1 B0 6F A0  1 
1A3F558 	70 44 A0  1 10 F0 A3  1 
      bwjoin r-cyl!  r-sector!               ( addr   R: input? #blks )
1A3F560 	84 FB A0  1 E8 EF A3  1 
1A3F568 	CC EF A3  1 
   else                                      ( addr block# ) ( R: input? #blks )
1A3F56C 	C8 41 A0  1 
1A3F570 	18  0  0  0 
      lblk>cyl-head-sect                     ( addr cyl# head# sect# )
1A3F574 	CC F2 A3  1 
      r-sector! drive r-head! r-cyl!         ( addr #blks input? R: input? #blks )
1A3F578 	CC EF A3  1 34 EA A3  1 
1A3F580 	10 F0 A3  1 E8 EF A3  1 
   then
   r>  r>  if  rblocks  else  wblocks  then               ( actual# | error )
1A3F588 	D0 45 A0  1 D0 45 A0  1 
1A3F590 	DC 41 A0  1 10  0  0  0 
1A3F598 	24 F4 A3  1 C8 41 A0  1 
1A3F5A0 	 8  0  0  0 E8 F4 A3  1 

   dup 0<=  if
1A3F5A8 	40 49 A0  1 84 47 A0  1 
1A3F5B0 	DC 41 A0  1 2C  0  0  0 
      ." Failed to transfer any blocks" cr
1A3F5B8 	20 7C A0  1 1D 46 61 69 
1A3F5C0 	6C 65 64 20 74 6F 20 74 
1A3F5C8 	72 61 6E 73 66 65 72 20 
1A3F5D0 	61 6E 79 20 62 6C 6F 63 
1A3F5D8 	6B 73  0  0 80 6D A0  1 
      \ XXX trouble
   then                                           ( actual# )
;
1A3F5E0 	58 46 A0  1 

\ Determine the physical constants of this drive.
\ XXX - IDENTIFY is not a required command! Still, most drives
\ we'll see will implement it. If this doesn't work, we'll have to
\ read CMOS drive parameters or something equally unpleasant.

\ /block buffer: scratchbuf
create scratchbuf d# 512 allot
1A3F5E4 	 0 73 63 72 
1A3F5E8 	61 74 63 68 62 75 66 8A 
1A3F5F0 	 0 F5 A3  1 30 40 A0  1 
1A3F5F8 	 0  0  0  0  0  0  0  0 
1A3F600 	 0  0  0  0  0  0  0  0 
1A3F608 	 0  0  0  0  0  0  0  0 
1A3F610 	 0  0  0  0  0  0  0  0 
1A3F618 	 0  0  0  0  0  0  0  0 
1A3F620 	 0  0  0  0  0  0  0  0 
1A3F628 	 0  0  0  0  0  0  0  0 
1A3F630 	 0  0  0  0  0  0  0  0 
1A3F638 	 0  0  0  0  0  0  0  0 
1A3F640 	 0  0  0  0  0  0  0  0 
1A3F648 	 0  0  0  0  0  0  0  0 
1A3F650 	 0  0  0  0  0  0  0  0 
1A3F658 	 0  0  0  0  0  0  0  0 
1A3F660 	 0  0  0  0  0  0  0  0 
1A3F668 	 0  0  0  0  0  0  0  0 
1A3F670 	 0  0  0  0  0  0  0  0 
1A3F678 	 0  0  0  0  0  0  0  0 
1A3F680 	 0  0  0  0  0  0  0  0 
1A3F688 	 0  0  0  0  0  0  0  0 
1A3F690 	 0  0  0  0  0  0  0  0 
1A3F698 	 0  0  0  0  0  0  0  0 
1A3F6A0 	 0  0  0  0  0  0  0  0 
1A3F6A8 	 0  0  0  0  0  0  0  0 
1A3F6B0 	 0  0  0  0  0  0  0  0 
1A3F6B8 	 0  0  0  0  0  0  0  0 
1A3F6C0 	 0  0  0  0  0  0  0  0 
1A3F6C8 	 0  0  0  0  0  0  0  0 
1A3F6D0 	 0  0  0  0  0  0  0  0 
1A3F6D8 	 0  0  0  0  0  0  0  0 
1A3F6E0 	 0  0  0  0  0  0  0  0 
1A3F6E8 	 0  0  0  0  0  0  0  0 
1A3F6F0 	 0  0  0  0  0  0  0  0 
1A3F6F8 	 0  0  0  0  0  0  0  0 
1A3F700 	 0  0  0  0  0  0  0  0 
1A3F708 	 0  0  0  0  0  0  0  0 
1A3F710 	 0  0  0  0  0  0  0  0 
1A3F718 	 0  0  0  0  0  0  0  0 
1A3F720 	 0  0  0  0  0  0  0  0 
1A3F728 	 0  0  0  0  0  0  0  0 
1A3F730 	 0  0  0  0  0  0  0  0 
1A3F738 	 0  0  0  0  0  0  0  0 
1A3F740 	 0  0  0  0  0  0  0  0 
1A3F748 	 0  0  0  0  0  0  0  0 
1A3F750 	 0  0  0  0  0  0  0  0 
1A3F758 	 0  0  0  0  0  0  0  0 
1A3F760 	 0  0  0  0  0  0  0  0 
1A3F768 	 0  0  0  0  0  0  0  0 
1A3F770 	 0  0  0  0  0  0  0  0 
1A3F778 	 0  0  0  0  0  0  0  0 
1A3F780 	 0  0  0  0  0  0  0  0 
1A3F788 	 0  0  0  0  0  0  0  0 
1A3F790 	 0  0  0  0  0  0  0  0 
1A3F798 	 0  0  0  0  0  0  0  0 
1A3F7A0 	 0  0  0  0  0  0  0  0 
1A3F7A8 	 0  0  0  0  0  0  0  0 
1A3F7B0 	 0  0  0  0  0  0  0  0 
1A3F7B8 	 0  0  0  0  0  0  0  0 
1A3F7C0 	 0  0  0  0  0  0  0  0 
1A3F7C8 	 0  0  0  0  0  0  0  0 
1A3F7D0 	 0  0  0  0  0  0  0  0 
1A3F7D8 	 0  0  0  0  0  0  0  0 
1A3F7E0 	 0  0  0  0  0  0  0  0 
1A3F7E8 	 0  0  0  0  0  0  0  0 
1A3F7F0 	 0  0  0  0  0  0  0  0 
\eof
fload ${BP}/dev/ide/atapi.fth

: le-w@  ( adr -- w )  dup c@ swap ca1+ c@ bwjoin  ;

: ide-get-drive-parms  ( -- found? )
   d# 512 /block!

   false  atapi-drive?!
   0      drive-type!

   wait-while-busy  if  false exit  then
   2 r-dor!             \ Turn off IRQ14

   0 drive r-head!

   h# ec r-csr!		\ Identify command

   scratchbuf d# 512 pio-rblock  if  false exit  then

   scratchbuf 1 wa+ le-w@ /cyls!
   scratchbuf 3 wa+ le-w@ /heads!
   scratchbuf 6 wa+ le-w@ /secs!

\   /cyls h# 3fff u>=  if
   scratchbuf d# 49 wa+ w@ h# 200 and  if  \ LBA
      scratchbuf d# 60 wa+ le-w@
      scratchbuf d# 61 wa+ le-w@
      wljoin /lba!
   then

   true
;

: get-drive-parms  ( -- found? )
   \ Reset this string (primary or secondary) on the first time through,
   \ in order to clear any errors that might be hanging around from uses
   \ of the drive by previous software.
   drive 0=  if  4 r-dor!  0 r-dor!  then

   wait-while-busy  if  false exit  then
   0 drive r-head!		\ select drive
   0 r-dor!			\ flush ISA bus
   6 reg@ h# a0 drive 4 lshift or  = if
      r-cyl@ eb14 =  if
         \ If H/W reset resets the IDE bus, there's no need for atapi-reset
	 \ Unfortunately, the vl-reset on the Shark does not seem to fully
	 \ reset the ATAPI drive, therefore, we are doing it here.
         atapi-reset		\ atapi soft reset
         atapi-get-drive-parms     ( found? )
      else
         r-csr@ 0<>  r-csr@ h# ff <>  and  if
            drive 0=  if
               wait-until-ready  if  false exit  then
            then	\ wait until spin-up
            r-csr@ h# f0 and h# 50 =  if
               ide-get-drive-parms                 ( found? )
            else
               false                               ( found? )
            then
         else
            false                                  ( found? )
         then
      then
   else
      false                                        ( found? )
   then
;

external

: block-size  ( -- n )  0 drive r-head!  /block@  ;
: #blocks  ( -- n )
   atapi-drive?@  if
     atapi-capacity
   else
     /lba ?dup  0=  if               ( )
        /cyls /secs /heads * *       ( #blocks )
     then                            ( #blocks )
   then                              ( #blocks )
;

: dma-alloc  ( n -- vaddr )  " dma-alloc" $call-parent  ;
: dma-free  ( vaddr n -- )  " dma-free" $call-parent  ;
: max-transfer  ( -- n )   d# 256 /block@ *  ;
: read-blocks   ( addr block# #blocks -- #read )
   atapi-drive?@  if  atapi-read  else  true  r/w-blocks  then
;
: write-blocks  ( addr block# #blocks -- #written )
   atapi-drive?@  if  atapi-write  else  false r/w-blocks  then
;
: ide-inquiry  ( -- false | drive-type true )
   /block@ 0=  if  false  else  drive-type@ true  then
;
: ide-drive-inquiry  ( log-drive -- false | drive-type true )
   dup max#drives >=  if  drop false  else  to log-drive  ide-inquiry  then
;

: set-address  ( dummy unit -- )
   \ units 0 and 1 are primary ide drives, 2 and 3 are secondary ide drives
   nip dup to log-drive 1 and to drive
   log-drive 2 <  if  pri-chip-base pri-dor  else  sec-chip-base sec-dor  then
   to dor to chip-base
;

\ For switching between programmed-I/O and DMA operational modes

0 instance value 'open-dma
0 instance value 'close-dma
0 instance value 'set-drive-cfg
defer close-dma  ' noop is close-dma
defer open-dma   ' noop to open-dma
defer set-drive-cfg  ' noop to set-drive-cfg
: save-dma-open  ( -- )
   ['] open-dma      behavior to 'open-dma
   ['] close-dma     behavior to 'close-dma
   ['] set-drive-cfg behavior to 'set-drive-cfg
;
: restore-open-dma  ( -- )
   'open-dma      ?dup  if  to open-dma       then
   'close-dma     ?dup  if  to close-dma      then
   'set-drive-cfg ?dup  if  to set-drive-cfg  then
;

: parse-args  ( -- flag )
   my-args  begin  dup  while       \ Execute mode modifiers
      ascii , left-parse-string            ( rem$ first$ )
      my-self ['] $call-method  catch  if  ( rem$ x x x )
         ." Unknown argument" cr
         3drop 2drop false exit
      then                                 ( rem$ )
   repeat                                  ( rem$ )
   2drop
   true
;

: open-hardware  ( -- flag )
   parse-args 0=  if  false exit  then
   (map)  to sec-dor  to sec-chip-base  to pri-dor  to pri-chip-base
   open-dma

   first-open?  if
      max#drives 0  do
         d# 80 ms
         0 i  set-address  get-drive-parms  if  set-drive-cfg  then  loop
      false to first-open?
   then

   0 0 set-address		\ Default

   \ should perform a quick "sanity check" selftest here,
   \ returning true iff the test succeeds.

   true
;
: reopen-hardware  ( -- flag )  parse-args  ;

: close-hardware  ( -- )
   close-dma   
   pri-chip-base pri-dor sec-chip-base sec-dor (unmap)
   restore-open-dma
;
: reclose-hardware  ( -- )  restore-open-dma  ;

: selftest  ( -- 0 | error-code )
   \ perform reasonably extensive selftest here, displaying
   \ a message if the test fails, and returning an error code if the
   \ test fails or 0 if the test succeeds.
   0
;

: open  ( -- flag )
   open-count  if
      reopen-hardware  dup  if  open-count 1+ to open-count  then
      exit
   else
      open-hardware  dup  if
         1 to open-count
      then
   then
;
: close  ( -- )
   open-count 1- to open-count
   open-count  if
      reclose-hardware
   else
      close-hardware
   then
;

: set-blk-w  ( w@-addr w!-addr -- )  to io-blk-w! to io-blk-w@  ;

[ifdef] notyet
: set-pio-mode  ( mode -- )
   3 r-features!
   8 or r-#secs!
   h# ef r-csr!
;
[then]

OpenFirmware/dev/ide/generic.fth_AL	ED8 1A3F7F8 \ ATAPI package implementing a "block" device-type interface.
\
\

headers

: waitonbusy  ( -- )
1A3F7F8 	 0 77 61 69 74 6F 6E 62 
1A3F800 	75 73 79 8A F4 F5 A3  1 
1A3F808 	20 40 A0  1 
   h# 2000 0 do
1A3F80C 	58 41 A0  1 
1A3F810 	 0 20  0  0 70 6F A0  1 
1A3F818 	88 42 A0  1 50  0  0  0 
      r-csr@ dup 80 and 0=  if  drop leave  then	\ Exit if not busy
1A3F820 	48 EE A3  1 40 49 A0  1 
1A3F828 	58 41 A0  1 80  0  0  0 
1A3F830 	5C 44 A0  1 24 47 A0  1 
1A3F838 	DC 41 A0  1  C  0  0  0 
1A3F840 	30 49 A0  1 18 43 A0  1 
      1 and  if  leave  then				\ Exit if error
1A3F848 	80 6F A0  1 5C 44 A0  1 
1A3F850 	DC 41 A0  1  8  0  0  0 
1A3F858 	18 43 A0  1 
      1 ms
1A3F85C 	80 6F A0  1 
1A3F860 	60 E0 A1  1 
   loop
1A3F864 	F8 41 A0  1 
1A3F868 	B8 FF FF FF 
;
1A3F86C 	58 46 A0  1 

: atapi-get-drive-parms  ( -- found? )
1A3F870 	 0  0 61 74 61 70 69 2D 
1A3F878 	67 65 74 2D 64 72 69 76 
1A3F880 	65 2D 70 61 72 6D 73 95 
1A3F888 	 8 F8 A3  1 20 40 A0  1 
   h# a1 r-csr!         \ send identify command
1A3F890 	58 41 A0  1 A1  0  0  0 
1A3F898 	4C F0 A3  1 

   waitonbusy	\ The busy bit can be set even if there's no slave drive
1A3F89C 	 8 F8 A3  1 

   r-csr@  dup 0=  swap h# ff =  or  if  false exit  then
1A3F8A0 	48 EE A3  1 40 49 A0  1 
1A3F8A8 	24 47 A0  1 68 49 A0  1 
1A3F8B0 	58 41 A0  1 FF  0  0  0 
1A3F8B8 	24 48 A0  1 70 44 A0  1 
1A3F8C0 	DC 41 A0  1  C  0  0  0 
1A3F8C8 	18 70 A0  1 40 46 A0  1 

   true    atapi-drive?!
1A3F8D0 	 4 70 A0  1 24 EC A3  1 

   scratchbuf d# 512 pio-rblock  if  false exit  then
1A3F8D8 	F4 F5 A3  1 58 41 A0  1 
1A3F8E0 	 0  2  0  0 4C F3 A3  1 
1A3F8E8 	DC 41 A0  1  C  0  0  0 
1A3F8F0 	18 70 A0  1 40 46 A0  1 

   scratchbuf 1+ c@  h# 1f and  dup  drive-type!   ( type )
1A3F8F8 	F4 F5 A3  1 30 4B A0  1 
1A3F900 	C4 4C A0  1 58 41 A0  1 
1A3F908 	1F  0  0  0 5C 44 A0  1 
1A3F910 	40 49 A0  1 D4 EB A3  1 
   5 =  if  d# 2048  else  d# 512  then  /block!
1A3F918 	C0 6F A0  1 24 48 A0  1 
1A3F920 	DC 41 A0  1 14  0  0  0 
1A3F928 	58 41 A0  1  0  8  0  0 
1A3F930 	C8 41 A0  1  C  0  0  0 
1A3F938 	58 41 A0  1  0  2  0  0 
1A3F940 	8C EB A3  1 

[ifdef] notdef
   \ It's possible that the following workaround was caused by a byte-order
   \ dependency, now fixed, that used to exist in the code above.

   \ This is a workaround for ATAPI CD-ROM drives such as the NEC MultiSpin
   \ 2Vi, which do not have the drive-type in the right byte.
   5 drive-type!
[then]
   true
1A3F944 	 4 70 A0  1 
;
1A3F948 	58 46 A0  1 

: waitfordrq  ( -- timeout? )
1A3F94C 	 0 77 61 69 
1A3F950 	74 66 6F 72 64 72 71 8A 
1A3F958 	8C F8 A3  1 20 40 A0  1 
   d# 100 0 do
1A3F960 	58 41 A0  1 64  0  0  0 
1A3F968 	70 6F A0  1 88 42 A0  1 
1A3F970 	58  0  0  0 
      r-csr@ dup h# 80 and  if	\ Ignore DRQ if BSY is set
1A3F974 	48 EE A3  1 
1A3F978 	40 49 A0  1 58 41 A0  1 
1A3F980 	80  0  0  0 5C 44 A0  1 
1A3F988 	DC 41 A0  1 10  0  0  0 
         drop
1A3F990 	30 49 A0  1 
      else
1A3F994 	C8 41 A0  1 
1A3F998 	20  0  0  0 
         8 and  if  false unloop exit  then		\ Exit if DRQ is set
1A3F99C 	F0 6F A0  1 
1A3F9A0 	5C 44 A0  1 DC 41 A0  1 
1A3F9A8 	10  0  0  0 18 70 A0  1 
1A3F9B0 	3C 42 A0  1 40 46 A0  1 
      then
      1 ms
1A3F9B8 	80 6F A0  1 60 E0 A1  1 
   loop
1A3F9C0 	F8 41 A0  1 B0 FF FF FF 
   true
1A3F9C8 	 4 70 A0  1 
;
1A3F9CC 	58 46 A0  1 

: atapi-reset  ( -- )
1A3F9D0 	61 74 61 70 69 2D 72 65 
1A3F9D8 	73 65 74 8B 5C F9 A3  1 
1A3F9E0 	20 40 A0  1 
   8 chip-base 7 + rb!      \ ATAPI soft reset
1A3F9E4 	F0 6F A0  1 
1A3F9E8 	10 EA A3  1 E0 6F A0  1 
1A3F9F0 	 4 45 A0  1 1C B2 A2  1 
   d# 100 0  do
1A3F9F8 	58 41 A0  1 64  0  0  0 
1A3FA00 	70 6F A0  1 88 42 A0  1 
1A3FA08 	48  0  0  0 
      r-csr@ dup 0= swap 1 and 1 = or  if  leave  then
1A3FA0C 	48 EE A3  1 
1A3FA10 	40 49 A0  1 24 47 A0  1 
1A3FA18 	68 49 A0  1 80 6F A0  1 
1A3FA20 	5C 44 A0  1 80 6F A0  1 
1A3FA28 	24 48 A0  1 70 44 A0  1 
1A3FA30 	DC 41 A0  1  8  0  0  0 
1A3FA38 	18 43 A0  1 
      d# 16 ms
1A3FA3C 	58 41 A0  1 
1A3FA40 	10  0  0  0 60 E0 A1  1 
   loop
1A3FA48 	F8 41 A0  1 C0 FF FF FF 
;
1A3FA50 	58 46 A0  1 

: flushdata  ( -- )
1A3FA54 	 0  0 66 6C 
1A3FA58 	75 73 68 64 61 74 61 89 
1A3FA60 	E0 F9 A3  1 20 40 A0  1 
   h# 10000 0  do
1A3FA68 	58 41 A0  1  0  0  1  0 
1A3FA70 	70 6F A0  1 88 42 A0  1 
1A3FA78 	34  0  0  0 
      r-csr@ 8 and 0=  if  unloop exit  then  r-data@ drop
1A3FA7C 	48 EE A3  1 
1A3FA80 	F0 6F A0  1 5C 44 A0  1 
1A3FA88 	24 47 A0  1 DC 41 A0  1 
1A3FA90 	 C  0  0  0 3C 42 A0  1 
1A3FA98 	40 46 A0  1 64 ED A3  1 
1A3FAA0 	30 49 A0  1 
   loop
1A3FAA4 	F8 41 A0  1 
1A3FAA8 	D4 FF FF FF 

   \ If the sucker won't stop sending us data, bonk him on the head
   atapi-reset atapi-get-drive-parms
1A3FAAC 	E0 F9 A3  1 
1A3FAB0 	8C F8 A3  1 
;
1A3FAB4 	58 46 A0  1 

: r-feature!  ( feature -- )  1 reg!  ;
1A3FAB8 	 0 72 2D 66 65 61 74 75 
1A3FAC0 	72 65 21 8A 64 FA A3  1 
1A3FAC8 	20 40 A0  1 80 6F A0  1 
1A3FAD0 	44 EF A3  1 58 46 A0  1 

: sendcmd  ( cmd len -- )  flushdata  0 r-feature!  r-cyl!  r-csr!  ;
1A3FAD8 	73 65 6E 64 63 6D 64 87 
1A3FAE0 	C8 FA A3  1 20 40 A0  1 
1A3FAE8 	64 FA A3  1 70 6F A0  1 
1A3FAF0 	C8 FA A3  1 E8 EF A3  1 
1A3FAF8 	4C F0 A3  1 58 46 A0  1 

d# 12 constant pkt-len
1A3FB00 	70 6B 74 2D 6C 65 6E 87 
1A3FB08 	E4 FA A3  1 68 40 A0  1 
1A3FB10 	 C  0  0  0 

create pkt-buf pkt-len allot
1A3FB14 	70 6B 74 2D 
1A3FB18 	62 75 66 87  C FB A3  1 
1A3FB20 	30 40 A0  1  0  0  0  0 
1A3FB28 	 0  0  0  0  0  0  0  0 

: +c!  ( n addr -- addr' )  tuck c! 1+  ;
1A3FB30 	2B 63 21 83 20 FB A3  1 
1A3FB38 	20 40 A0  1 E8 46 A0  1 
1A3FB40 	B8 4D A0  1 30 4B A0  1 
1A3FB48 	58 46 A0  1 
: 2c!  ( n addr -- )  >r lbsplit 2drop  r> +c!         c!  ;
1A3FB4C 	32 63 21 83 
1A3FB50 	38 FB A3  1 20 40 A0  1 
1A3FB58 	BC 45 A0  1 B4 FB A0  1 
1A3FB60 	AC 49 A0  1 D0 45 A0  1 
1A3FB68 	38 FB A3  1 B8 4D A0  1 
1A3FB70 	58 46 A0  1 
: 4c!  ( n addr -- )  >r lbsplit        r> +c! +c! +c! c!  ;
1A3FB74 	34 63 21 83 
1A3FB78 	54 FB A3  1 20 40 A0  1 
1A3FB80 	BC 45 A0  1 B4 FB A0  1 
1A3FB88 	D0 45 A0  1 38 FB A3  1 
1A3FB90 	38 FB A3  1 38 FB A3  1 
1A3FB98 	B8 4D A0  1 58 46 A0  1 

: >pkt-buf  ( byte offset -- )  pkt-buf + c! ;
1A3FBA0 	 0  0  0 3E 70 6B 74 2D 
1A3FBA8 	62 75 66 88 7C FB A3  1 
1A3FBB0 	20 40 A0  1 20 FB A3  1 
1A3FBB8 	 4 45 A0  1 B8 4D A0  1 
1A3FBC0 	58 46 A0  1 

defer pio-rwblock  ' noop to pio-rwblock
1A3FBC4 	70 69 6F 2D 
1A3FBC8 	72 77 62 6C 6F 63 6B 8B 
1A3FBD0 	B0 FB A3  1 5C 40 A0  1 
1A3FBD8 	48  D  0  0 
: sendpkt  ( addr len pkt-addr -- count )
1A3FBDC 	73 65 6E 64 
1A3FBE0 	70 6B 74 87 D4 FB A3  1 
1A3FBE8 	20 40 A0  1 
   over h# a0 swap sendcmd                         ( addr len pkt-addr )
1A3FBEC 	54 49 A0  1 
1A3FBF0 	58 41 A0  1 A0  0  0  0 
1A3FBF8 	68 49 A0  1 E4 FA A3  1 
   wait-until-drq  pkt-len chip-base io-blk-w!     ( addr len )
1A3FC00 	50 F1 A3  1  C FB A3  1 
1A3FC08 	10 EA A3  1 6C F0 A3  1 
   waitonbusy                                      ( addr len )
1A3FC10 	 8 F8 A3  1 
   waitfordrq  if		\ Timeout          ( addr len )
1A3FC14 	5C F9 A3  1 
1A3FC18 	DC 41 A0  1 20  0  0  0 
      h# 100 ms  2drop 0                           ( 0 )
1A3FC20 	58 41 A0  1  0  1  0  0 
1A3FC28 	60 E0 A1  1 AC 49 A0  1 
1A3FC30 	70 6F A0  1 
   else				\ No timeout       ( addr len )
1A3FC34 	C8 41 A0  1 
1A3FC38 	14  0  0  0 
      tuck  pio-rwblock drop   waitonbusy           ( len )
1A3FC3C 	E8 46 A0  1 
1A3FC40 	D4 FB A3  1 30 49 A0  1 
1A3FC48 	 8 F8 A3  1 
   then
;
1A3FC4C 	58 46 A0  1 

: clear-pkt-buf  ( -- )  pkt-buf pkt-len erase  ;
1A3FC50 	 0  0 63 6C 65 61 72 2D 
1A3FC58 	70 6B 74 2D 62 75 66 8D 
1A3FC60 	E8 FB A3  1 20 40 A0  1 
1A3FC68 	20 FB A3  1  C FB A3  1 
1A3FC70 	F0 72 A0  1 58 46 A0  1 

0 instance value clen
1A3FC78 	 0  0  0 63 6C 65 6E 84 
1A3FC80 	64 FC A3  1 C0 FE A1  1 
1A3FC88 	28  0  0  0 
0 instance value cbuf
1A3FC8C 	 0  0  0 63 
1A3FC90 	62 75 66 84 84 FC A3  1 
1A3FC98 	C0 FE A1  1 2C  0  0  0 

: retry-command  ( addr len -- false | count true )
1A3FCA0 	 0  0 72 65 74 72 79 2D 
1A3FCA8 	63 6F 6D 6D 61 6E 64 8D 
1A3FCB0 	98 FC A3  1 20 40 A0  1 
   to clen to cbuf
1A3FCB8 	48 B8 A1  1 84 FC A3  1 
1A3FCC0 	48 B8 A1  1 98 FC A3  1 
   h# 10 0  do
1A3FCC8 	58 41 A0  1 10  0  0  0 
1A3FCD0 	70 6F A0  1 88 42 A0  1 
1A3FCD8 	44  0  0  0 
      cbuf clen pkt-buf sendpkt
1A3FCDC 	98 FC A3  1 
1A3FCE0 	84 FC A3  1 20 FB A3  1 
1A3FCE8 	E8 FB A3  1 
      r-csr@ 1 and 0=  if  unloop true exit  then
1A3FCEC 	48 EE A3  1 
1A3FCF0 	80 6F A0  1 5C 44 A0  1 
1A3FCF8 	24 47 A0  1 DC 41 A0  1 
1A3FD00 	10  0  0  0 3C 42 A0  1 
1A3FD08 	 4 70 A0  1 40 46 A0  1 
      drop
1A3FD10 	30 49 A0  1 
   loop
1A3FD14 	F8 41 A0  1 
1A3FD18 	C4 FF FF FF 
   false
1A3FD1C 	18 70 A0  1 
;
1A3FD20 	58 46 A0  1 

: atapi-read  ( addr block# #blocks -- #read )
1A3FD24 	 0 61 74 61 
1A3FD28 	70 69 2D 72 65 61 64 8A 
1A3FD30 	B4 FC A3  1 20 40 A0  1 
   ['] pio-rblock to pio-rwblock
1A3FD38 	60 53 A0  1 4C F3 A3  1 
1A3FD40 	98 40 A0  1 D4 FB A3  1 
   >r  0 -rot  r>		( #read addr block# #blocks )
1A3FD48 	BC 45 A0  1 70 6F A0  1 
1A3FD50 	94 49 A0  1 D0 45 A0  1 
   0 ?do			( #read addr block# )
1A3FD58 	70 6F A0  1 50 42 A0  1 
1A3FD60 	94  0  0  0 
      2dup >r >r		( #read addr block# ) ( R: block# addr )
1A3FD64 	C0 49 A0  1 
1A3FD68 	BC 45 A0  1 BC 45 A0  1 
      clear-pkt-buf		( #read addr block# ) ( R: block# addr )
1A3FD70 	64 FC A3  1 
      h# 28 0 >pkt-buf		\ read (10) command
1A3FD74 	58 41 A0  1 
1A3FD78 	28  0  0  0 70 6F A0  1 
1A3FD80 	B0 FB A3  1 
      1 pkt-buf 7 + 2c!		( #read addr block# ) ( R: block# addr )
1A3FD84 	80 6F A0  1 
1A3FD88 	20 FB A3  1 E0 6F A0  1 
1A3FD90 	 4 45 A0  1 54 FB A3  1 
      pkt-buf 2 + 4c!		( #read addr ) ( R: block# addr )
1A3FD98 	20 FB A3  1 90 6F A0  1 
1A3FDA0 	 4 45 A0  1 7C FB A3  1 
      /block@ retry-command  0=  if  r> r> leave  then  ( #read count )
1A3FDA8 	6C EB A3  1 B4 FC A3  1 
1A3FDB0 	24 47 A0  1 DC 41 A0  1 
1A3FDB8 	10  0  0  0 D0 45 A0  1 
1A3FDC0 	D0 45 A0  1 18 43 A0  1 
      swap 1+ swap		( #read' count )
1A3FDC8 	68 49 A0  1 30 4B A0  1 
1A3FDD0 	68 49 A0  1 
      r> r> 1+			( #read' count addr block#' )
1A3FDD4 	D0 45 A0  1 
1A3FDD8 	D0 45 A0  1 30 4B A0  1 
      -rot + swap		( #read' addr' block#' )
1A3FDE0 	94 49 A0  1  4 45 A0  1 
1A3FDE8 	68 49 A0  1 
   loop  2drop			( #read )
1A3FDEC 	F8 41 A0  1 
1A3FDF0 	74 FF FF FF AC 49 A0  1 
;
1A3FDF8 	58 46 A0  1 

: atapi-write  ( addr block# #blocks -- #write )
1A3FDFC 	61 74 61 70 
1A3FE00 	69 2D 77 72 69 74 65 8B 
1A3FE08 	34 FD A3  1 20 40 A0  1 
   ['] pio-wblock to pio-rwblock
1A3FE10 	60 53 A0  1 3C F4 A3  1 
1A3FE18 	98 40 A0  1 D4 FB A3  1 
   >r  0 -rot  r>		( #write addr block# #blocks )
1A3FE20 	BC 45 A0  1 70 6F A0  1 
1A3FE28 	94 49 A0  1 D0 45 A0  1 
   0 ?do			( #write addr block# )
1A3FE30 	70 6F A0  1 50 42 A0  1 
1A3FE38 	94  0  0  0 
      2dup >r >r		( #write addr block# ) ( R: block# addr )
1A3FE3C 	C0 49 A0  1 
1A3FE40 	BC 45 A0  1 BC 45 A0  1 
      clear-pkt-buf		( #write addr block# ) ( R: block# addr )
1A3FE48 	64 FC A3  1 
      h# 2a 0 >pkt-buf		\ write (10) command
1A3FE4C 	58 41 A0  1 
1A3FE50 	2A  0  0  0 70 6F A0  1 
1A3FE58 	B0 FB A3  1 
      1 pkt-buf 7 + 2c!		( #write addr block# ) ( R: block# addr )
1A3FE5C 	80 6F A0  1 
1A3FE60 	20 FB A3  1 E0 6F A0  1 
1A3FE68 	 4 45 A0  1 54 FB A3  1 
      pkt-buf 2 + 4c!		( #write addr ) ( R: block# addr )
1A3FE70 	20 FB A3  1 90 6F A0  1 
1A3FE78 	 4 45 A0  1 7C FB A3  1 
      /block@ retry-command  0=  if  r> r> leave  then  ( #write count )
1A3FE80 	6C EB A3  1 B4 FC A3  1 
1A3FE88 	24 47 A0  1 DC 41 A0  1 
1A3FE90 	10  0  0  0 D0 45 A0  1 
1A3FE98 	D0 45 A0  1 18 43 A0  1 
      swap 1+ swap		( #write' count )
1A3FEA0 	68 49 A0  1 30 4B A0  1 
1A3FEA8 	68 49 A0  1 
      r> r> 1+			( #write' count addr block#' )
1A3FEAC 	D0 45 A0  1 
1A3FEB0 	D0 45 A0  1 30 4B A0  1 
      -rot + swap		( #write' addr' block#' )
1A3FEB8 	94 49 A0  1  4 45 A0  1 
1A3FEC0 	68 49 A0  1 
   loop  2drop			( #write )
1A3FEC4 	F8 41 A0  1 
1A3FEC8 	74 FF FF FF AC 49 A0  1 
;
1A3FED0 	58 46 A0  1 

: be-l@  ( adr -- l )
1A3FED4 	 0  0 62 65 
1A3FED8 	2D 6C 40 85  C FE A3  1 
1A3FEE0 	20 40 A0  1 
   >r  r@ 3 + c@  r@ 2+ c@  r@ 1+ c@  r> c@  bljoin
1A3FEE4 	BC 45 A0  1 
1A3FEE8 	E4 45 A0  1 A0 6F A0  1 
1A3FEF0 	 4 45 A0  1 C4 4C A0  1 
1A3FEF8 	E4 45 A0  1 40 4B A0  1 
1A3FF00 	C4 4C A0  1 E4 45 A0  1 
1A3FF08 	30 4B A0  1 C4 4C A0  1 
1A3FF10 	D0 45 A0  1 C4 4C A0  1 
1A3FF18 	DC FB A0  1 
;
1A3FF1C 	58 46 A0  1 

: atapi-capacity  ( -- n )
1A3FF20 	 0 61 74 61 70 69 2D 63 
1A3FF28 	61 70 61 63 69 74 79 8E 
1A3FF30 	E0 FE A3  1 20 40 A0  1 
   ['] pio-rblock to pio-rwblock
1A3FF38 	60 53 A0  1 4C F3 A3  1 
1A3FF40 	98 40 A0  1 D4 FB A3  1 
   clear-pkt-buf
1A3FF48 	64 FC A3  1 
   h# 25 0 >pkt-buf
1A3FF4C 	58 41 A0  1 
1A3FF50 	25  0  0  0 70 6F A0  1 
1A3FF58 	B0 FB A3  1 
   scratchbuf 8 retry-command  if  drop scratchbuf be-l@  else  0  then
1A3FF5C 	F4 F5 A3  1 
1A3FF60 	F0 6F A0  1 B4 FC A3  1 
1A3FF68 	DC 41 A0  1 18  0  0  0 
1A3FF70 	30 49 A0  1 F4 F5 A3  1 
1A3FF78 	E0 FE A3  1 C8 41 A0  1 
1A3FF80 	 8  0  0  0 70 6F A0  1 
;
1A3FF88 	58 46 A0  1 

OpenFirmware/dev/ide/atapi.fth_AL	794 1A3FF8C 
: le-w@  ( adr -- w )  dup c@ swap ca1+ c@ bwjoin  ;
1A3FF8C 	 0  0 6C 65 
1A3FF90 	2D 77 40 85 34 FF A3  1 
1A3FF98 	20 40 A0  1 40 49 A0  1 
1A3FFA0 	C4 4C A0  1 68 49 A0  1 
1A3FFA8 	78 50 A0  1 C4 4C A0  1 
1A3FFB0 	84 FB A0  1 58 46 A0  1 

: ide-get-drive-parms  ( -- found? )
1A3FFB8 	69 64 65 2D 67 65 74 2D 
1A3FFC0 	64 72 69 76 65 2D 70 61 
1A3FFC8 	72 6D 73 93 98 FF A3  1 
1A3FFD0 	20 40 A0  1 
   d# 512 /block!
1A3FFD4 	58 41 A0  1 
1A3FFD8 	 0  2  0  0 8C EB A3  1 

   false  atapi-drive?!
1A3FFE0 	18 70 A0  1 24 EC A3  1 
   0      drive-type!
1A3FFE8 	70 6F A0  1 D4 EB A3  1 

   wait-while-busy  if  false exit  then
1A3FFF0 	AC EE A3  1 DC 41 A0  1 
1A3FFF8 	 C  0  0  0 18 70 A0  1 
1A40000 	40 46 A0  1 
   2 r-dor!             \ Turn off IRQ14
1A40004 	90 6F A0  1 
1A40008 	80 EE A3  1 

   0 drive r-head!
1A4000C 	70 6F A0  1 
1A40010 	34 EA A3  1 10 F0 A3  1 

   h# ec r-csr!		\ Identify command
1A40018 	58 41 A0  1 EC  0  0  0 
1A40020 	4C F0 A3  1 

   scratchbuf d# 512 pio-rblock  if  false exit  then
1A40024 	F4 F5 A3  1 
1A40028 	58 41 A0  1  0  2  0  0 
1A40030 	4C F3 A3  1 DC 41 A0  1 
1A40038 	 C  0  0  0 18 70 A0  1 
1A40040 	40 46 A0  1 

   scratchbuf 1 wa+ le-w@ /cyls!
1A40044 	F4 F5 A3  1 
1A40048 	80 6F A0  1 18 50 A0  1 
1A40050 	98 FF A3  1 A4 EC A3  1 
   scratchbuf 3 wa+ le-w@ /heads!
1A40058 	F4 F5 A3  1 A0 6F A0  1 
1A40060 	18 50 A0  1 98 FF A3  1 
1A40068 	E4 EC A3  1 
   scratchbuf 6 wa+ le-w@ /secs!
1A4006C 	F4 F5 A3  1 
1A40070 	D0 6F A0  1 18 50 A0  1 
1A40078 	98 FF A3  1 64 EC A3  1 

\   /cyls h# 3fff u>=  if
   scratchbuf d# 49 wa+ w@ h# 200 and  if  \ LBA
1A40080 	F4 F5 A3  1 58 41 A0  1 
1A40088 	31  0  0  0 18 50 A0  1 
1A40090 	94 4C A0  1 58 41 A0  1 
1A40098 	 0  2  0  0 5C 44 A0  1 
1A400A0 	DC 41 A0  1 34  0  0  0 
      scratchbuf d# 60 wa+ le-w@
1A400A8 	F4 F5 A3  1 58 41 A0  1 
1A400B0 	3C  0  0  0 18 50 A0  1 
1A400B8 	98 FF A3  1 
      scratchbuf d# 61 wa+ le-w@
1A400BC 	F4 F5 A3  1 
1A400C0 	58 41 A0  1 3D  0  0  0 
1A400C8 	18 50 A0  1 98 FF A3  1 
      wljoin /lba!
1A400D0 	D4 4F A0  1 24 ED A3  1 
   then

   true
1A400D8 	 4 70 A0  1 
;
1A400DC 	58 46 A0  1 

: get-drive-parms  ( -- found? )
1A400E0 	67 65 74 2D 64 72 69 76 
1A400E8 	65 2D 70 61 72 6D 73 8F 
1A400F0 	D0 FF A3  1 20 40 A0  1 
   \ Reset this string (primary or secondary) on the first time through,
   \ in order to clear any errors that might be hanging around from uses
   \ of the drive by previous software.
   drive 0=  if  4 r-dor!  0 r-dor!  then
1A400F8 	34 EA A3  1 24 47 A0  1 
1A40100 	DC 41 A0  1 14  0  0  0 
1A40108 	B0 6F A0  1 80 EE A3  1 
1A40110 	70 6F A0  1 80 EE A3  1 

   wait-while-busy  if  false exit  then
1A40118 	AC EE A3  1 DC 41 A0  1 
1A40120 	 C  0  0  0 18 70 A0  1 
1A40128 	40 46 A0  1 
   0 drive r-head!		\ select drive
1A4012C 	70 6F A0  1 
1A40130 	34 EA A3  1 10 F0 A3  1 
   0 r-dor!			\ flush ISA bus
1A40138 	70 6F A0  1 80 EE A3  1 
   6 reg@ h# a0 drive 4 lshift or  = if
1A40140 	D0 6F A0  1 44 ED A3  1 
1A40148 	58 41 A0  1 A0  0  0  0 
1A40150 	34 EA A3  1 B0 6F A0  1 
1A40158 	9C 44 A0  1 70 44 A0  1 
1A40160 	24 48 A0  1 DC 41 A0  1 
1A40168 	BC  0  0  0 
      r-cyl@ eb14 =  if
1A4016C 	E0 ED A3  1 
1A40170 	58 41 A0  1 14 EB  0  0 
1A40178 	24 48 A0  1 DC 41 A0  1 
1A40180 	14  0  0  0 
         \ If H/W reset resets the IDE bus, there's no need for atapi-reset
	 \ Unfortunately, the vl-reset on the Shark does not seem to fully
	 \ reset the ATAPI drive, therefore, we are doing it here.
         atapi-reset		\ atapi soft reset
1A40184 	E0 F9 A3  1 
         atapi-get-drive-parms     ( found? )
1A40188 	8C F8 A3  1 
      else
1A4018C 	C8 41 A0  1 
1A40190 	8C  0  0  0 
         r-csr@ 0<>  r-csr@ h# ff <>  and  if
1A40194 	48 EE A3  1 
1A40198 	44 47 A0  1 48 EE A3  1 
1A401A0 	58 41 A0  1 FF  0  0  0 
1A401A8 	44 48 A0  1 5C 44 A0  1 
1A401B0 	DC 41 A0  1 64  0  0  0 
            drive 0=  if
1A401B8 	34 EA A3  1 24 47 A0  1 
1A401C0 	DC 41 A0  1 18  0  0  0 
               wait-until-ready  if  false exit  then
1A401C8 	18 F2 A3  1 DC 41 A0  1 
1A401D0 	 C  0  0  0 18 70 A0  1 
1A401D8 	40 46 A0  1 
            then	\ wait until spin-up
            r-csr@ h# f0 and h# 50 =  if
1A401DC 	48 EE A3  1 
1A401E0 	58 41 A0  1 F0  0  0  0 
1A401E8 	5C 44 A0  1 58 41 A0  1 
1A401F0 	50  0  0  0 24 48 A0  1 
1A401F8 	DC 41 A0  1 10  0  0  0 
               ide-get-drive-parms                 ( found? )
1A40200 	D0 FF A3  1 
            else
1A40204 	C8 41 A0  1 
1A40208 	 8  0  0  0 
               false                               ( found? )
1A4020C 	18 70 A0  1 
            then
         else
1A40210 	C8 41 A0  1  8  0  0  0 
            false                                  ( found? )
1A40218 	18 70 A0  1 
         then
      then
   else
1A4021C 	C8 41 A0  1 
1A40220 	 8  0  0  0 
      false                                        ( found? )
1A40224 	18 70 A0  1 
   then
;
1A40228 	58 46 A0  1 

external

: block-size  ( -- n )  0 drive r-head!  /block@  ;
1A4022C 	 0 62 6C 6F 
1A40230 	63 6B 2D 73 69 7A 65 8A 
1A40238 	F4  0 A4  1 20 40 A0  1 
1A40240 	70 6F A0  1 34 EA A3  1 
1A40248 	10 F0 A3  1 6C EB A3  1 
1A40250 	58 46 A0  1 
: #blocks  ( -- n )
1A40254 	23 62 6C 6F 
1A40258 	63 6B 73 87 3C  2 A4  1 
1A40260 	20 40 A0  1 
   atapi-drive?@  if
1A40264 	FC EB A3  1 
1A40268 	DC 41 A0  1 10  0  0  0 
     atapi-capacity
1A40270 	34 FF A3  1 
   else
1A40274 	C8 41 A0  1 
1A40278 	2C  0  0  0 
     /lba ?dup  0=  if               ( )
1A4027C 	 4 ED A3  1 
1A40280 	B4 70 A0  1 24 47 A0  1 
1A40288 	DC 41 A0  1 18  0  0  0 
        /cyls /secs /heads * *       ( #blocks )
1A40290 	84 EC A3  1 44 EC A3  1 
1A40298 	C4 EC A3  1 1C 5F A0  1 
1A402A0 	1C 5F A0  1 
     then                            ( #blocks )
   then                              ( #blocks )
;
1A402A4 	58 46 A0  1 

: dma-alloc  ( n -- vaddr )  " dma-alloc" $call-parent  ;
1A402A8 	 0  0 64 6D 61 2D 61 6C 
1A402B0 	6C 6F 63 89 60  2 A4  1 
1A402B8 	20 40 A0  1 9C 53 A0  1 
1A402C0 	 9 64 6D 61 2D 61 6C 6C 
1A402C8 	6F 63  0  0 DC 31 A2  1 
1A402D0 	58 46 A0  1 
: dma-free  ( vaddr n -- )  " dma-free" $call-parent  ;
1A402D4 	 0  0  0 64 
1A402D8 	6D 61 2D 66 72 65 65 88 
1A402E0 	B8  2 A4  1 20 40 A0  1 
1A402E8 	9C 53 A0  1  8 64 6D 61 
1A402F0 	2D 66 72 65 65  0  0  0 
1A402F8 	DC 31 A2  1 58 46 A0  1 
: max-transfer  ( -- n )   d# 256 /block@ *  ;
1A40300 	 0  0  0 6D 61 78 2D 74 
1A40308 	72 61 6E 73 66 65 72 8C 
1A40310 	E4  2 A4  1 20 40 A0  1 
1A40318 	58 41 A0  1  0  1  0  0 
1A40320 	6C EB A3  1 1C 5F A0  1 
1A40328 	58 46 A0  1 
: read-blocks   ( addr block# #blocks -- #read )
1A4032C 	72 65 61 64 
1A40330 	2D 62 6C 6F 63 6B 73 8B 
1A40338 	14  3 A4  1 20 40 A0  1 
   atapi-drive?@  if  atapi-read  else  true  r/w-blocks  then
1A40340 	FC EB A3  1 DC 41 A0  1 
1A40348 	10  0  0  0 34 FD A3  1 
1A40350 	C8 41 A0  1  C  0  0  0 
1A40358 	 4 70 A0  1  0 F5 A3  1 
;
1A40360 	58 46 A0  1 
: write-blocks  ( addr block# #blocks -- #written )
1A40364 	 0  0  0 77 
1A40368 	72 69 74 65 2D 62 6C 6F 
1A40370 	63 6B 73 8C 3C  3 A4  1 
1A40378 	20 40 A0  1 
   atapi-drive?@  if  atapi-write  else  false r/w-blocks  then
1A4037C 	FC EB A3  1 
1A40380 	DC 41 A0  1 10  0  0  0 
1A40388 	 C FE A3  1 C8 41 A0  1 
1A40390 	 C  0  0  0 18 70 A0  1 
1A40398 	 0 F5 A3  1 
;
1A4039C 	58 46 A0  1 
: ide-inquiry  ( -- false | drive-type true )
1A403A0 	69 64 65 2D 69 6E 71 75 
1A403A8 	69 72 79 8B 78  3 A4  1 
1A403B0 	20 40 A0  1 
   /block@ 0=  if  false  else  drive-type@ true  then
1A403B4 	6C EB A3  1 
1A403B8 	24 47 A0  1 DC 41 A0  1 
1A403C0 	10  0  0  0 18 70 A0  1 
1A403C8 	C8 41 A0  1  C  0  0  0 
1A403D0 	B0 EB A3  1  4 70 A0  1 
;
1A403D8 	58 46 A0  1 
: ide-drive-inquiry  ( log-drive -- false | drive-type true )
1A403DC 	 0  0 69 64 
1A403E0 	65 2D 64 72 69 76 65 2D 
1A403E8 	69 6E 71 75 69 72 79 91 
1A403F0 	B0  3 A4  1 20 40 A0  1 
   dup max#drives >=  if  drop false  else  to log-drive  ide-inquiry  then
1A403F8 	40 49 A0  1 50 E9 A3  1 
1A40400 	EC 48 A0  1 DC 41 A0  1 
1A40408 	14  0  0  0 30 49 A0  1 
1A40410 	18 70 A0  1 C8 41 A0  1 
1A40418 	10  0  0  0 48 B8 A1  1 
1A40420 	4C EA A3  1 B0  3 A4  1 
;
1A40428 	58 46 A0  1 

: set-address  ( dummy unit -- )
1A4042C 	73 65 74 2D 
1A40430 	61 64 64 72 65 73 73 8B 
1A40438 	F4  3 A4  1 20 40 A0  1 
   \ units 0 and 1 are primary ide drives, 2 and 3 are secondary ide drives
   nip dup to log-drive 1 and to drive
1A40440 	FC 46 A0  1 40 49 A0  1 
1A40448 	48 B8 A1  1 4C EA A3  1 
1A40450 	80 6F A0  1 5C 44 A0  1 
1A40458 	48 B8 A1  1 34 EA A3  1 
   log-drive 2 <  if  pri-chip-base pri-dor  else  sec-chip-base sec-dor  then
1A40460 	4C EA A3  1 90 6F A0  1 
1A40468 	E4 47 A0  1 DC 41 A0  1 
1A40470 	14  0  0  0 9C E9 A3  1 
1A40478 	B0 E9 A3  1 C8 41 A0  1 
1A40480 	 C  0  0  0 CC E9 A3  1 
1A40488 	E0 E9 A3  1 
   to dor to chip-base
1A4048C 	48 B8 A1  1 
1A40490 	20 EA A3  1 48 B8 A1  1 
1A40498 	10 EA A3  1 
;
1A4049C 	58 46 A0  1 

\ For switching between programmed-I/O and DMA operational modes

0 instance value 'open-dma
1A404A0 	 0  0 27 6F 70 65 6E 2D 
1A404A8 	64 6D 61 89 3C  4 A4  1 
1A404B0 	C0 FE A1  1 30  0  0  0 
0 instance value 'close-dma
1A404B8 	 0 27 63 6C 6F 73 65 2D 
1A404C0 	64 6D 61 8A B0  4 A4  1 
1A404C8 	C0 FE A1  1 34  0  0  0 
0 instance value 'set-drive-cfg
1A404D0 	 0 27 73 65 74 2D 64 72 
1A404D8 	69 76 65 2D 63 66 67 8E 
1A404E0 	C8  4 A4  1 C0 FE A1  1 
1A404E8 	38  0  0  0 
defer close-dma  ' noop is close-dma
1A404EC 	 0  0 63 6C 
1A404F0 	6F 73 65 2D 64 6D 61 89 
1A404F8 	E4  4 A4  1 5C 40 A0  1 
1A40500 	4C  D  0  0 
defer open-dma   ' noop to open-dma
1A40504 	 0  0  0 6F 
1A40508 	70 65 6E 2D 64 6D 61 88 
1A40510 	FC  4 A4  1 5C 40 A0  1 
1A40518 	50  D  0  0 
defer set-drive-cfg  ' noop to set-drive-cfg
1A4051C 	 0  0 73 65 
1A40520 	74 2D 64 72 69 76 65 2D 
1A40528 	63 66 67 8D 14  5 A4  1 
1A40530 	5C 40 A0  1 54  D  0  0 
: save-dma-open  ( -- )
1A40538 	 0  0 73 61 76 65 2D 64 
1A40540 	6D 61 2D 6F 70 65 6E 8D 
1A40548 	30  5 A4  1 20 40 A0  1 
   ['] open-dma      behavior to 'open-dma
1A40550 	60 53 A0  1 14  5 A4  1 
1A40558 	10 C7 A0  1 48 B8 A1  1 
1A40560 	B0  4 A4  1 
   ['] close-dma     behavior to 'close-dma
1A40564 	60 53 A0  1 
1A40568 	FC  4 A4  1 10 C7 A0  1 
1A40570 	48 B8 A1  1 C8  4 A4  1 
   ['] set-drive-cfg behavior to 'set-drive-cfg
1A40578 	60 53 A0  1 30  5 A4  1 
1A40580 	10 C7 A0  1 48 B8 A1  1 
1A40588 	E4  4 A4  1 
;
1A4058C 	58 46 A0  1 
: restore-open-dma  ( -- )
1A40590 	 0  0  0 72 65 73 74 6F 
1A40598 	72 65 2D 6F 70 65 6E 2D 
1A405A0 	64 6D 61 90 4C  5 A4  1 
1A405A8 	20 40 A0  1 
   'open-dma      ?dup  if  to open-dma       then
1A405AC 	B0  4 A4  1 
1A405B0 	B4 70 A0  1 DC 41 A0  1 
1A405B8 	 C  0  0  0 98 40 A0  1 
1A405C0 	14  5 A4  1 
   'close-dma     ?dup  if  to close-dma      then
1A405C4 	C8  4 A4  1 
1A405C8 	B4 70 A0  1 DC 41 A0  1 
1A405D0 	 C  0  0  0 98 40 A0  1 
1A405D8 	FC  4 A4  1 
   'set-drive-cfg ?dup  if  to set-drive-cfg  then
1A405DC 	E4  4 A4  1 
1A405E0 	B4 70 A0  1 DC 41 A0  1 
1A405E8 	 C  0  0  0 98 40 A0  1 
1A405F0 	30  5 A4  1 
;
1A405F4 	58 46 A0  1 

: parse-args  ( -- flag )
1A405F8 	 0 70 61 72 73 65 2D 61 
1A40600 	72 67 73 8A A8  5 A4  1 
1A40608 	20 40 A0  1 
   my-args  begin  dup  while       \ Execute mode modifiers
1A4060C 	10  7 A2  1 
1A40610 	40 49 A0  1 DC 41 A0  1 
1A40618 	5C  0  0  0 
      ascii , left-parse-string            ( rem$ first$ )
1A4061C 	58 41 A0  1 
1A40620 	2C  0  0  0 44 D7 A0  1 
      my-self ['] $call-method  catch  if  ( rem$ x x x )
1A40628 	EC 7E A0  1 60 53 A0  1 
1A40630 	B4 31 A2  1 14 7F A0  1 
1A40638 	DC 41 A0  1 30  0  0  0 
         ." Unknown argument" cr
1A40640 	20 7C A0  1 10 55 6E 6B 
1A40648 	6E 6F 77 6E 20 61 72 67 
1A40650 	75 6D 65 6E 74  0  0  0 
1A40658 	80 6D A0  1 
         3drop 2drop false exit
1A4065C 	90 52 A0  1 
1A40660 	AC 49 A0  1 18 70 A0  1 
1A40668 	40 46 A0  1 
      then                                 ( rem$ )
   repeat                                  ( rem$ )
1A4066C 	C8 41 A0  1 
1A40670 	A0 FF FF FF 
   2drop
1A40674 	AC 49 A0  1 
   true
1A40678 	 4 70 A0  1 
;
1A4067C 	58 46 A0  1 

: open-hardware  ( -- flag )
1A40680 	 0  0 6F 70 65 6E 2D 68 
1A40688 	61 72 64 77 61 72 65 8D 
1A40690 	 8  6 A4  1 20 40 A0  1 
   parse-args 0=  if  false exit  then
1A40698 	 8  6 A4  1 24 47 A0  1 
1A406A0 	DC 41 A0  1  C  0  0  0 
1A406A8 	18 70 A0  1 40 46 A0  1 
   (map)  to sec-dor  to sec-chip-base  to pri-dor  to pri-chip-base
1A406B0 	C8 E7 A3  1 B8 40 A0  1 
1A406B8 	E0 E9 A3  1 B8 40 A0  1 
1A406C0 	CC E9 A3  1 B8 40 A0  1 
1A406C8 	B0 E9 A3  1 B8 40 A0  1 
1A406D0 	9C E9 A3  1 
   open-dma
1A406D4 	14  5 A4  1 

   first-open?  if
1A406D8 	68 E9 A3  1 DC 41 A0  1 
1A406E0 	50  0  0  0 
      max#drives 0  do
1A406E4 	50 E9 A3  1 
1A406E8 	70 6F A0  1 88 42 A0  1 
1A406F0 	34  0  0  0 
         d# 80 ms
1A406F4 	58 41 A0  1 
1A406F8 	50  0  0  0 60 E0 A1  1 
         0 i  set-address  get-drive-parms  if  set-drive-cfg  then  loop
1A40700 	70 6F A0  1 B4 42 A0  1 
1A40708 	3C  4 A4  1 F4  0 A4  1 
1A40710 	DC 41 A0  1  8  0  0  0 
1A40718 	30  5 A4  1 F8 41 A0  1 
1A40720 	D4 FF FF FF 
      false to first-open?
1A40724 	18 70 A0  1 
1A40728 	B8 40 A0  1 68 E9 A3  1 
   then

   0 0 set-address		\ Default
1A40730 	70 6F A0  1 70 6F A0  1 
1A40738 	3C  4 A4  1 

   \ should perform a quick "sanity check" selftest here,
   \ returning true iff the test succeeds.

   true
1A4073C 	 4 70 A0  1 
;
1A40740 	58 46 A0  1 
: reopen-hardware  ( -- flag )  parse-args  ;
1A40744 	72 65 6F 70 
1A40748 	65 6E 2D 68 61 72 64 77 
1A40750 	61 72 65 8F 94  6 A4  1 
1A40758 	20 40 A0  1  8  6 A4  1 
1A40760 	58 46 A0  1 

: close-hardware  ( -- )
1A40764 	 0 63 6C 6F 
1A40768 	73 65 2D 68 61 72 64 77 
1A40770 	61 72 65 8E 58  7 A4  1 
1A40778 	20 40 A0  1 
   close-dma   
1A4077C 	FC  4 A4  1 
   pri-chip-base pri-dor sec-chip-base sec-dor (unmap)
1A40780 	9C E9 A3  1 B0 E9 A3  1 
1A40788 	CC E9 A3  1 E0 E9 A3  1 
1A40790 	58 E8 A3  1 
   restore-open-dma
1A40794 	A8  5 A4  1 
;
1A40798 	58 46 A0  1 
: reclose-hardware  ( -- )  restore-open-dma  ;
1A4079C 	 0  0  0 72 
1A407A0 	65 63 6C 6F 73 65 2D 68 
1A407A8 	61 72 64 77 61 72 65 90 
1A407B0 	78  7 A4  1 20 40 A0  1 
1A407B8 	A8  5 A4  1 58 46 A0  1 

: selftest  ( -- 0 | error-code )
1A407C0 	 0  0  0 73 65 6C 66 74 
1A407C8 	65 73 74 88 B4  7 A4  1 
1A407D0 	20 40 A0  1 
   \ perform reasonably extensive selftest here, displaying
   \ a message if the test fails, and returning an error code if the
   \ test fails or 0 if the test succeeds.
   0
1A407D4 	70 6F A0  1 
;
1A407D8 	58 46 A0  1 

: open  ( -- flag )
1A407DC 	 0  0  0 6F 
1A407E0 	70 65 6E 84 D0  7 A4  1 
1A407E8 	20 40 A0  1 
   open-count  if
1A407EC 	80 E9 A3  1 
1A407F0 	DC 41 A0  1 30  0  0  0 
      reopen-hardware  dup  if  open-count 1+ to open-count  then
1A407F8 	58  7 A4  1 40 49 A0  1 
1A40800 	DC 41 A0  1 14  0  0  0 
1A40808 	80 E9 A3  1 30 4B A0  1 
1A40810 	B8 40 A0  1 80 E9 A3  1 
      exit
1A40818 	40 46 A0  1 
   else
1A4081C 	C8 41 A0  1 
1A40820 	20  0  0  0 
      open-hardware  dup  if
1A40824 	94  6 A4  1 
1A40828 	40 49 A0  1 DC 41 A0  1 
1A40830 	10  0  0  0 
         1 to open-count
1A40834 	80 6F A0  1 
1A40838 	B8 40 A0  1 80 E9 A3  1 
      then
   then
;
1A40840 	58 46 A0  1 
: close  ( -- )
1A40844 	 0  0 63 6C 
1A40848 	6F 73 65 85 E8  7 A4  1 
1A40850 	20 40 A0  1 
   open-count 1- to open-count
1A40854 	80 E9 A3  1 
1A40858 	54 4B A0  1 B8 40 A0  1 
1A40860 	80 E9 A3  1 
   open-count  if
1A40864 	80 E9 A3  1 
1A40868 	DC 41 A0  1 10  0  0  0 
      reclose-hardware
1A40870 	B4  7 A4  1 
   else
1A40874 	C8 41 A0  1 
1A40878 	 8  0  0  0 
      close-hardware
1A4087C 	78  7 A4  1 
   then
;
1A40880 	58 46 A0  1 

: set-blk-w  ( w@-addr w!-addr -- )  to io-blk-w! to io-blk-w@  ;
1A40884 	 0  0 73 65 
1A40888 	74 2D 62 6C 6B 2D 77 89 
1A40890 	50  8 A4  1 20 40 A0  1 
1A40898 	98 40 A0  1 6C F0 A3  1 
1A408A0 	98 40 A0  1 84 F0 A3  1 
1A408A8 	58 46 A0  1 

[ifdef] notyet
: set-pio-mode  ( mode -- )
   3 r-features!
   8 or r-#secs!
   h# ef r-csr!
;
[then]

OpenFirmware/dev/ide/generic2.fth_AL	920 1A408AC 
ide
1A408BC 1A408DC 
propset=1A40918 B442E24 1A00D98 
vocset=B442E24 1A00D98 1A40918 
new-node=B442E38 1A00D78 
vocset=B442E38 1A00D78 1A40918 purpose: IDE one-level - master,slave / primary,secondary on same level

" ide" device-name
1A408AC 	69 64 65  0 
1A408B0 	 0  0  0 6E 61 6D 65 84 
1A408B8 	34 E9 A3  1 BC 13 A2  1 
1A408C0 	14  0  0  0  4  0  0  0 
" ide" device-type
1A408C8 	69 64 65  0 64 65 76 69 
1A408D0 	63 65 5F 74 79 70 65 8B 
1A408D8 	BC  8 A4  1 BC 13 A2  1 
1A408E0 	18  0  0  0  4  0  0  0 

\ The IDE device node defines an address space for its children.  That
\ address space is of the form "dummy, unit#".  Both are integers.

: decode-unit  ( addr len -- dummy unit# )  parse-2int  ;
1A408E8 	64 65 63 6F 64 65 2D 75 
1A408F0 	6E 69 74 8B 94  8 A4  1 
1A408F8 	20 40 A0  1  8 4B A2  1 
1A40900 	58 46 A0  1 

new-device
1A40904 	E0 B6 A0  1 
1A40908 	58  D  0  0 88 E7 A3  1 
1A40910 	E0 B6 A0  1 78  D  0  0 

OpenFirmware/dev/ide/onelevel.fth_AL	6C 1A40918 
disk
1A40928 1A4094C 
99DBE94   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99DBEA4   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99DBEB4   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99DADF4   F0 01 00 00  00 00 00 00  00 00 00 00  01 00 00 00 =...............
99DAE04   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99DAE14   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99DAE24   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................\ IDE disk package implementing a "block" device-type interface.
\
\

hex

" disk" device-name
1A40918 	64 69 73 6B  0  0  0 6E 
1A40920 	61 6D 65 84  0  0 A0  1 
1A40928 	BC 13 A2  1 14  0  0  0 
1A40930 	 5  0  0  0 
" block" device-type
1A40934 	62 6C 6F 63 
1A40938 	6B  0  0  0 64 65 76 69 
1A40940 	63 65 5F 74 79 70 65 8B 
1A40948 	28  9 A4  1 BC 13 A2  1 
1A40950 	1C  0  0  0  6  0  0  0 

headers

0 instance value /block
1A40958 	 0 2F 62 6C 6F 63 6B 86 
1A40960 	 0  0 A0  1 C0 FE A1  1 
1A40968 	18  0  0  0 

0 instance value deblocker
1A4096C 	 0  0 64 65 
1A40970 	62 6C 6F 63 6B 65 72 89 
1A40978 	64  9 A4  1 C0 FE A1  1 
1A40980 	1C  0  0  0 
: init-deblocker  ( -- okay? )
1A40984 	 0 69 6E 69 
1A40988 	74 2D 64 65 62 6C 6F 63 
1A40990 	6B 65 72 8E 7C  9 A4  1 
1A40998 	20 40 A0  1 
   " "  " deblocker"  $open-package  to deblocker
1A4099C 	9C 53 A0  1 
1A409A0 	 0  0  0  0 9C 53 A0  1 
1A409A8 	 9 64 65 62 6C 6F 63 6B 
1A409B0 	65 72  0  0 80 3A A2  1 
1A409B8 	48 B8 A1  1 7C  9 A4  1 
   deblocker if
1A409C0 	7C  9 A4  1 DC 41 A0  1 
1A409C8 	10  0  0  0 
      true
1A409CC 	 4 70 A0  1 
   else
1A409D0 	C8 41 A0  1 30  0  0  0 
      ." Can't open deblocker package"  cr  false
1A409D8 	20 7C A0  1 1C 43 61 6E 
1A409E0 	27 74 20 6F 70 65 6E 20 
1A409E8 	64 65 62 6C 6F 63 6B 65 
1A409F0 	72 20 70 61 63 6B 61 67 
1A409F8 	65  0  0  0 80 6D A0  1 
1A40A00 	18 70 A0  1 
   then
;
1A40A04 	58 46 A0  1 

0 instance value offset-low     \ Offset to start of partition
1A40A08 	 0 6F 66 66 73 65 74 2D 
1A40A10 	6C 6F 77 8A 98  9 A4  1 
1A40A18 	C0 FE A1  1 20  0  0  0 
0 instance value offset-high
1A40A20 	6F 66 66 73 65 74 2D 68 
1A40A28 	69 67 68 8B 18  A A4  1 
1A40A30 	C0 FE A1  1 24  0  0  0 

0 instance value label-package
1A40A38 	 0  0 6C 61 62 65 6C 2D 
1A40A40 	70 61 63 6B 61 67 65 8D 
1A40A48 	30  A A4  1 C0 FE A1  1 
1A40A50 	28  0  0  0 

\ Sets offset-low and offset-high, reflecting the starting location of the
\ partition specified by the "my-args" string.

: init-label-package  ( -- okay? )
1A40A54 	 0 69 6E 69 
1A40A58 	74 2D 6C 61 62 65 6C 2D 
1A40A60 	70 61 63 6B 61 67 65 92 
1A40A68 	4C  A A4  1 20 40 A0  1 
   0 to offset-high  0 to offset-low
1A40A70 	70 6F A0  1 48 B8 A1  1 
1A40A78 	30  A A4  1 70 6F A0  1 
1A40A80 	48 B8 A1  1 18  A A4  1 
   my-args  " disk-label"  $open-package to label-package
1A40A88 	10  7 A2  1 9C 53 A0  1 
1A40A90 	 A 64 69 73 6B 2D 6C 61 
1A40A98 	62 65 6C  0 80 3A A2  1 
1A40AA0 	48 B8 A1  1 4C  A A4  1 
   label-package  if
1A40AA8 	4C  A A4  1 DC 41 A0  1 
1A40AB0 	3C  0  0  0 
      0 0  " offset" label-package $call-method to offset-high to offset-low
1A40AB4 	70 6F A0  1 
1A40AB8 	70 6F A0  1 9C 53 A0  1 
1A40AC0 	 6 6F 66 66 73 65 74  0 
1A40AC8 	4C  A A4  1 B4 31 A2  1 
1A40AD0 	48 B8 A1  1 30  A A4  1 
1A40AD8 	48 B8 A1  1 18  A A4  1 
      true
1A40AE0 	 4 70 A0  1 
   else
1A40AE4 	C8 41 A0  1 
1A40AE8 	30  0  0  0 
      ." Can't open disk label package"  cr  false
1A40AEC 	20 7C A0  1 
1A40AF0 	1D 43 61 6E 27 74 20 6F 
1A40AF8 	70 65 6E 20 64 69 73 6B 
1A40B00 	20 6C 61 62 65 6C 20 70 
1A40B08 	61 63 6B 61 67 65  0  0 
1A40B10 	80 6D A0  1 18 70 A0  1 
   then
;
1A40B18 	58 46 A0  1 

\ The IDE disk package needs to export dma-alloc and dma-free
\ methods so the deblocker can allocate DMA-capable buffer memory.

external
: dma-alloc  ( n -- vaddr )  " dma-alloc" $call-parent  ;
1A40B1C 	 0  0 64 6D 
1A40B20 	61 2D 61 6C 6C 6F 63 89 
1A40B28 	6C  A A4  1 20 40 A0  1 
1A40B30 	9C 53 A0  1  9 64 6D 61 
1A40B38 	2D 61 6C 6C 6F 63  0  0 
1A40B40 	DC 31 A2  1 58 46 A0  1 
: dma-free   ( vaddr n -- )  " dma-free"  $call-parent  ;
1A40B48 	 0  0  0 64 6D 61 2D 66 
1A40B50 	72 65 65 88 2C  B A4  1 
1A40B58 	20 40 A0  1 9C 53 A0  1 
1A40B60 	 8 64 6D 61 2D 66 72 65 
1A40B68 	65  0  0  0 DC 31 A2  1 
1A40B70 	58 46 A0  1 

\ Return device block size; cache it the first time we find the information
\ This method is called by the deblocker
: block-size  ( -- n )
1A40B74 	 0 62 6C 6F 
1A40B78 	63 6B 2D 73 69 7A 65 8A 
1A40B80 	58  B A4  1 20 40 A0  1 
   /block  if  /block exit  then        \ Don't ask if we already know
1A40B88 	64  9 A4  1 DC 41 A0  1 
1A40B90 	 C  0  0  0 64  9 A4  1 
1A40B98 	40 46 A0  1 
   " block-size"  $call-parent   dup to /block
1A40B9C 	9C 53 A0  1 
1A40BA0 	 A 62 6C 6F 63 6B 2D 73 
1A40BA8 	69 7A 65  0 DC 31 A2  1 
1A40BB0 	40 49 A0  1 48 B8 A1  1 
1A40BB8 	64  9 A4  1 
;
1A40BBC 	58 46 A0  1 
   
: #blocks  ( -- n )  " #blocks"  $call-parent  ;
1A40BC0 	23 62 6C 6F 63 6B 73 87 
1A40BC8 	84  B A4  1 20 40 A0  1 
1A40BD0 	9C 53 A0  1  7 23 62 6C 
1A40BD8 	6F 63 6B 73  0  0  0  0 
1A40BE0 	DC 31 A2  1 58 46 A0  1 

\ These three methods are called by the deblocker.

: max-transfer  ( -- n )  " max-transfer"  $call-parent  ;
1A40BE8 	 0  0  0 6D 61 78 2D 74 
1A40BF0 	72 61 6E 73 66 65 72 8C 
1A40BF8 	CC  B A4  1 20 40 A0  1 
1A40C00 	9C 53 A0  1  C 6D 61 78 
1A40C08 	2D 74 72 61 6E 73 66 65 
1A40C10 	72  0  0  0 DC 31 A2  1 
1A40C18 	58 46 A0  1 
: read-blocks   ( addr block# #blocks -- #read )  " read-blocks" $call-parent  ;
1A40C1C 	72 65 61 64 
1A40C20 	2D 62 6C 6F 63 6B 73 8B 
1A40C28 	FC  B A4  1 20 40 A0  1 
1A40C30 	9C 53 A0  1  B 72 65 61 
1A40C38 	64 2D 62 6C 6F 63 6B 73 
1A40C40 	 0  0  0  0 DC 31 A2  1 
1A40C48 	58 46 A0  1 
: write-blocks  ( addr block# #blocks -- #written )  " write-blocks" $call-parent  ;
1A40C4C 	 0  0  0 77 
1A40C50 	72 69 74 65 2D 62 6C 6F 
1A40C58 	63 6B 73 8C 2C  C A4  1 
1A40C60 	20 40 A0  1 9C 53 A0  1 
1A40C68 	 C 77 72 69 74 65 2D 62 
1A40C70 	6C 6F 63 6B 73  0  0  0 
1A40C78 	DC 31 A2  1 58 46 A0  1 

\ Stub implementation of asynchronous write interface
0 instance value #written
1A40C80 	 0  0  0 23 77 72 69 74 
1A40C88 	74 65 6E 88 60  C A4  1 
1A40C90 	C0 FE A1  1 2C  0  0  0 
: write-blocks-start  ( addr block# #blocks -- )
1A40C98 	 0 77 72 69 74 65 2D 62 
1A40CA0 	6C 6F 63 6B 73 2D 73 74 
1A40CA8 	61 72 74 92 90  C A4  1 
1A40CB0 	20 40 A0  1 
   " write-blocks" $call-parent to #written
1A40CB4 	9C 53 A0  1 
1A40CB8 	 C 77 72 69 74 65 2D 62 
1A40CC0 	6C 6F 63 6B 73  0  0  0 
1A40CC8 	DC 31 A2  1 48 B8 A1  1 
1A40CD0 	90  C A4  1 
;
1A40CD4 	58 46 A0  1 
: write-blocks-finish  ( -- #written )  #written  ;
1A40CD8 	77 72 69 74 65 2D 62 6C 
1A40CE0 	6F 63 6B 73 2D 66 69 6E 
1A40CE8 	69 73 68 93 B0  C A4  1 
1A40CF0 	20 40 A0  1 90  C A4  1 
1A40CF8 	58 46 A0  1 


\ Methods used by external clients

: open  ( -- flag )
1A40CFC 	 0  0  0 6F 
1A40D00 	70 65 6E 84 F0  C A4  1 
1A40D08 	20 40 A0  1 
   my-unit dup 3 >  if  2drop false exit  then
1A40D0C 	70 10 A2  1 
1A40D10 	40 49 A0  1 A0 6F A0  1 
1A40D18 	 4 48 A0  1 DC 41 A0  1 
1A40D20 	10  0  0  0 AC 49 A0  1 
1A40D28 	18 70 A0  1 40 46 A0  1 
   " set-address" $call-parent
1A40D30 	9C 53 A0  1  B 73 65 74 
1A40D38 	2D 61 64 64 72 65 73 73 
1A40D40 	 0  0  0  0 DC 31 A2  1 

   " ide-inquiry" $call-parent  if  drop  else  false exit  then  ( )
1A40D48 	9C 53 A0  1  B 69 64 65 
1A40D50 	2D 69 6E 71 75 69 72 79 
1A40D58 	 0  0  0  0 DC 31 A2  1 
1A40D60 	DC 41 A0  1 10  0  0  0 
1A40D68 	30 49 A0  1 C8 41 A0  1 
1A40D70 	 C  0  0  0 18 70 A0  1 
1A40D78 	40 46 A0  1 

   block-size ?dup 0=  if  false exit  then  to /block
1A40D7C 	84  B A4  1 
1A40D80 	B4 70 A0  1 24 47 A0  1 
1A40D88 	DC 41 A0  1  C  0  0  0 
1A40D90 	18 70 A0  1 40 46 A0  1 
1A40D98 	48 B8 A1  1 64  9 A4  1 

   #blocks  0=  if  false exit  then
1A40DA0 	CC  B A4  1 24 47 A0  1 
1A40DA8 	DC 41 A0  1  C  0  0  0 
1A40DB0 	18 70 A0  1 40 46 A0  1 

   init-deblocker  0=  if  false exit  then
1A40DB8 	98  9 A4  1 24 47 A0  1 
1A40DC0 	DC 41 A0  1  C  0  0  0 
1A40DC8 	18 70 A0  1 40 46 A0  1 

   init-label-package  0=  if
1A40DD0 	6C  A A4  1 24 47 A0  1 
1A40DD8 	DC 41 A0  1 14  0  0  0 
      deblocker close-package false exit
1A40DE0 	7C  9 A4  1 A4 36 A2  1 
1A40DE8 	18 70 A0  1 40 46 A0  1 
   then

   true
1A40DF0 	 4 70 A0  1 
;
1A40DF4 	58 46 A0  1 

: close  ( -- )
1A40DF8 	 0  0 63 6C 6F 73 65 85 
1A40E00 	 8  D A4  1 20 40 A0  1 
   label-package close-package
1A40E08 	4C  A A4  1 A4 36 A2  1 
   deblocker close-package
1A40E10 	7C  9 A4  1 A4 36 A2  1 
;
1A40E18 	58 46 A0  1 

: seek  ( offset.low offset.high -- okay? )
1A40E1C 	 0  0  0 73 
1A40E20 	65 65 6B 84  4  E A4  1 
1A40E28 	20 40 A0  1 
   offset-low offset-high  d+  " seek"   deblocker $call-method
1A40E2C 	18  A A4  1 
1A40E30 	30  A A4  1 E0 5D A0  1 
1A40E38 	9C 53 A0  1  4 73 65 65 
1A40E40 	6B  0  0  0 7C  9 A4  1 
1A40E48 	B4 31 A2  1 
;
1A40E4C 	58 46 A0  1 

: read  ( addr len -- actual-len )  " read"  deblocker $call-method  ;
1A40E50 	 0  0  0 72 65 61 64 84 
1A40E58 	28  E A4  1 20 40 A0  1 
1A40E60 	9C 53 A0  1  4 72 65 61 
1A40E68 	64  0  0  0 7C  9 A4  1 
1A40E70 	B4 31 A2  1 58 46 A0  1 
: write ( addr len -- actual-len )  " write" deblocker $call-method  ;
1A40E78 	 0  0 77 72 69 74 65 85 
1A40E80 	5C  E A4  1 20 40 A0  1 
1A40E88 	9C 53 A0  1  5 77 72 69 
1A40E90 	74 65  0  0 7C  9 A4  1 
1A40E98 	B4 31 A2  1 58 46 A0  1 
: load  ( addr     -- size )        " load"  label-package $call-method  ;
1A40EA0 	 0  0  0 6C 6F 61 64 84 
1A40EA8 	84  E A4  1 20 40 A0  1 
1A40EB0 	9C 53 A0  1  4 6C 6F 61 
1A40EB8 	64  0  0  0 4C  A A4  1 
1A40EC0 	B4 31 A2  1 58 46 A0  1 

: size  ( -- d.size )               " size"  label-package $call-method  ;
1A40EC8 	 0  0  0 73 69 7A 65 84 
1A40ED0 	AC  E A4  1 20 40 A0  1 
1A40ED8 	9C 53 A0  1  4 73 69 7A 
1A40EE0 	65  0  0  0 4C  A A4  1 
1A40EE8 	B4 31 A2  1 58 46 A0  1 

finish-device
1A40EF0 	 0  0  0  0  0  0  0  0 
1A40EF8 	 0  0  0  0  0  0  0  0 
1A40F00 	 0  0  0  0  0  0  0  0 
1A40F08 	 0  0  0  0  0  0  0  0 
1A40F10 	 0  0  0  0  0  0  0  0 
1A40F18 	 0  0  0  0  0  0  0  0 
end-package
1A40F20 	F0  1  0  0  0  0  0  0 
1A40F28 	 0  0  0  0  1  0  0  0 
1A40F30 	 0  0  0  0  0  0  0  0 
1A40F38 	 0  0  0  0  0  0  0  0 
1A40F40 	 0  0  0  0  0  0  0  0 
1A40F48 	 0  0  0  0  0  0  0  0 
1A40F50 	 0  0  0  0  0  0  0  0 
1A40F58 	 0  0  0  0 

OpenFirmware/dev/ide/idedisk.fth_AL	644 1A40F5C purpose: Diagnostic (before console installation) access to serial port

headerless
[ifdef] mem-uart-base
d# 64,000,000 constant uart-clock-frequency
[else]
d# 1843200 constant uart-clock-frequency
1A4132C 	 0  0  0 75 
1A41330 	61 72 74 2D 63 6C 6F 63 
1A41338 	6B 2D 66 72 65 71 75 65 
1A41340 	6E 63 79 94 28 10 A4  1 
1A41348 	68 40 A0  1  0 20 1C  0 
[then]

[ifdef] mem-uart-base
: uart@  ( reg# -- byte )  mem-uart-base +  c@  ;	\ Read from a UART register
: uart!  ( byte reg# -- )  mem-uart-base +  c!  ;	\ Write to a UART register
[else]
h# 3f8 value uart-base	\ Virtual address of UART; perhaps overridden later
1A41350 	 0  0 75 61 72 74 2D 62 
1A41358 	61 73 65 89 48 13 A4  1 
1A41360 	50 40 A0  1 7C  D  0  0 

: uart@  ( reg# -- byte )  uart-base +  pc@  ;	\ Read from a UART register
1A41368 	 0  0 75 61 72 74 40 85 
1A41370 	60 13 A4  1 20 40 A0  1 
1A41378 	60 13 A4  1  4 45 A0  1 
1A41380 	AC 81 A2  1 58 46 A0  1 
: uart!  ( byte reg# -- )  uart-base +  pc!  ;	\ Write to a UART register
1A41388 	 0  0 75 61 72 74 21 85 
1A41390 	74 13 A4  1 20 40 A0  1 
1A41398 	60 13 A4  1  4 45 A0  1 
1A413A0 	E8 81 A2  1 58 46 A0  1 
[then]

: baud  ( baud-rate -- )
1A413A8 	 0  0  0 62 61 75 64 84 
1A413B0 	94 13 A4  1 20 40 A0  1 
   uart-clock-frequency d# 16 /  swap rounded-/    ( baud-rate-divisor )
1A413B8 	48 13 A4  1 58 41 A0  1 
1A413C0 	10  0  0  0 98 5F A0  1 
1A413C8 	68 49 A0  1 48 13 A1  1 

   begin  5 uart@ h# 40 and  until		\ Wait until transmit done
1A413D0 	C0 6F A0  1 74 13 A4  1 
1A413D8 	58 41 A0  1 40  0  0  0 
1A413E0 	5C 44 A0  1 DC 41 A0  1 
1A413E8 	E8 FF FF FF 

   3 uart@  dup >r  h# 80 or  3 uart!		\ divisor latch access bit on
1A413EC 	A0 6F A0  1 
1A413F0 	74 13 A4  1 40 49 A0  1 
1A413F8 	BC 45 A0  1 58 41 A0  1 
1A41400 	80  0  0  0 70 44 A0  1 
1A41408 	A0 6F A0  1 94 13 A4  1 
   dup h# ff and  0 uart!  8 >> 1 uart!		\ Write lsb and msb
1A41410 	40 49 A0  1 58 41 A0  1 
1A41418 	FF  0  0  0 5C 44 A0  1 
1A41420 	70 6F A0  1 94 13 A4  1 
1A41428 	F0 6F A0  1 DC 44 A0  1 
1A41430 	80 6F A0  1 94 13 A4  1 
   r> 3 uart!					\ Restore old state
1A41438 	D0 45 A0  1 A0 6F A0  1 
1A41440 	94 13 A4  1 
;
1A41444 	58 46 A0  1 

: inituarts  ( -- )
1A41448 	 0  0 69 6E 69 74 75 61 
1A41450 	72 74 73 89 B4 13 A4  1 
1A41458 	20 40 A0  1 
   3 3 uart!  		\ 8 bits, no parity
1A4145C 	A0 6F A0  1 
1A41460 	A0 6F A0  1 94 13 A4  1 
   7 2 uart!		\ Clear and enable FIFOs
1A41468 	E0 6F A0  1 90 6F A0  1 
1A41470 	94 13 A4  1 
\   d# 38400 baud
\   d# 9600 baud
   d# 115200 baud
1A41474 	58 41 A0  1 
1A41478 	 0 C2  1  0 B4 13 A4  1 
;
1A41480 	58 46 A0  1 

: ukey?    ( -- flag )  5 uart@      1 and  0<>  ;  \ Test for rcv character
1A41484 	 0  0 75 6B 
1A41488 	65 79 3F 85 58 14 A4  1 
1A41490 	20 40 A0  1 C0 6F A0  1 
1A41498 	74 13 A4  1 80 6F A0  1 
1A414A0 	5C 44 A0  1 44 47 A0  1 
1A414A8 	58 46 A0  1 
: uemit?   ( -- flag )  5 uart@  h# 20 and  0<>  ;  \ Test for xmit ready
1A414AC 	 0 75 65 6D 
1A414B0 	69 74 3F 86 90 14 A4  1 
1A414B8 	20 40 A0  1 C0 6F A0  1 
1A414C0 	74 13 A4  1 58 41 A0  1 
1A414C8 	20  0  0  0 5C 44 A0  1 
1A414D0 	44 47 A0  1 58 46 A0  1 
: ubreak?  ( -- flag )  5 uart@  h# 10 and  0<>  ;  \ Test for received break
1A414D8 	75 62 72 65 61 6B 3F 87 
1A414E0 	B8 14 A4  1 20 40 A0  1 
1A414E8 	C0 6F A0  1 74 13 A4  1 
1A414F0 	58 41 A0  1 10  0  0  0 
1A414F8 	5C 44 A0  1 44 47 A0  1 
1A41500 	58 46 A0  1 
: clear-break   ( -- )  5 uart@  drop  ;	    \ Clear break indication
1A41504 	63 6C 65 61 
1A41508 	72 2D 62 72 65 61 6B 8B 
1A41510 	E4 14 A4  1 20 40 A0  1 
1A41518 	C0 6F A0  1 74 13 A4  1 
1A41520 	30 49 A0  1 58 46 A0  1 

: ukey   ( -- char )  begin  ukey?   until  0 uart@  ;  \ Receive a character
1A41528 	 0  0  0 75 6B 65 79 84 
1A41530 	14 15 A4  1 20 40 A0  1 
1A41538 	90 14 A4  1 DC 41 A0  1 
1A41540 	F8 FF FF FF 70 6F A0  1 
1A41548 	74 13 A4  1 58 46 A0  1 
: uemit  ( char -- )  begin  uemit?  until  0 uart!  ;  \ Transmit a character
1A41550 	 0  0 75 65 6D 69 74 85 
1A41558 	34 15 A4  1 20 40 A0  1 
1A41560 	B8 14 A4  1 DC 41 A0  1 
1A41568 	F8 FF FF FF 70 6F A0  1 
1A41570 	94 13 A4  1 58 46 A0  1 
headers

OpenFirmware/dev/isa/diaguart.fth_AL	24C 1A41578 \
: install-uart-io  ( -- )
1A41578 	69 6E 73 74 61 6C 6C 2D 
1A41580 	75 61 72 74 2D 69 6F 8F 
1A41588 	5C 15 A4  1 20 40 A0  1 
   ['] lf-pstr          is newline-pstring
1A41590 	60 53 A0  1  8 EF A0  1 
1A41598 	98 40 A0  1 70 71 A0  1 
   ['] ukey?            is key?
1A415A0 	60 53 A0  1 90 14 A4  1 
1A415A8 	98 40 A0  1 64 6C A0  1 
   ['] ukey             is (key
1A415B0 	60 53 A0  1 34 15 A4  1 
1A415B8 	98 40 A0  1 40 6C A0  1 
   ['] uemit            is (emit
1A415C0 	60 53 A0  1 5C 15 A4  1 
1A415C8 	98 40 A0  1 18 6C A0  1 
   ['] default-type     is (type
1A415D0 	60 53 A0  1 94 6E A0  1 
1A415D8 	98 40 A0  1 F0 6B A0  1 
   ['] emit1            is emit
1A415E0 	60 53 A0  1 38 6E A0  1 
1A415E8 	98 40 A0  1 2C 6C A0  1 
   ['] type1            is type
1A415F0 	60 53 A0  1 64 6E A0  1 
1A415F8 	98 40 A0  1  4 6C A0  1 
   ['] crlf             is cr
1A41600 	60 53 A0  1 D4 72 A0  1 
1A41608 	98 40 A0  1 80 6D A0  1 
   ['] true             is (interactive?
1A41610 	60 53 A0  1  4 70 A0  1 
1A41618 	98 40 A0  1 A8 6C A0  1 
   ['] cancel           is light
1A41620 	60 53 A0  1 BC F7 A0  1 
1A41628 	98 40 A0  1 18 F8 A0  1 
;
1A41630 	58 46 A0  1 

\ Set the defer words for dl, dlbin, dlfcode, etc.
[ifdef] diag-key
' ukey to diag-key
[then]
[ifdef] diag-key?
' ukey? to diag-key?
[then]

\

OpenFirmware/forth/lib/sysuart.fth_AL	BC 1A41634 
propset=1A41678 B442EE5 1A00DC8 
vocset=B442EE5 1A00DC8 1A41678 
new-node=B442EF9 1A00DA8 
vocset=B442EF9 1A00DA8 1A41678 
mux
1A41688 
99DCB24   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................
99DCB34   00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00 ................purpose: Multiplexor device collects input and distributes I/O

dev /packages
new-device
1A41664 	E0 B6 A0  1 
1A41668 	88  D  0  0 C8 50 A2  1 
1A41670 	E0 B6 A0  1 A8  D  0  0 
" mux" device-name
1A41678 	6D 75 78  0  0  0  0 6E 
1A41680 	61 6D 65 84  0  0 A0  1 
1A41688 	BC 13 A2  1 14  0  0  0 
1A41690 	 4  0  0  0 

instance variable first-device
1A41694 	 0  0  0 66 
1A41698 	69 72 73 74 2D 64 65 76 
1A416A0 	69 63 65 8C  0  0 A0  1 
1A416A8 	40  1 A2  1 18  0  0  0 
0 first-device !

struct
   /n field >link
1A416B0 	 0  0 3E 6C 69 6E 6B 85 
1A416B8 	A8 16 A4  1 50 EE A0  1 
1A416C0 	 0  0  0  0 
   /n field >ihandle
1A416C4 	 0  0  0 3E 
1A416C8 	69 68 61 6E 64 6C 65 88 
1A416D0 	BC 16 A4  1 50 EE A0  1 
1A416D8 	 4  0  0  0 
   /n field >read
1A416DC 	 0  0 3E 72 
1A416E0 	65 61 64 85 D4 16 A4  1 
1A416E8 	50 EE A0  1  8  0  0  0 
   /n field >write
1A416F0 	 0 3E 77 72 69 74 65 86 
1A416F8 	E8 16 A4  1 50 EE A0  1 
1A41700 	 C  0  0  0 
   /n field >bell
1A41704 	 0  0 3E 62 
1A41708 	65 6C 6C 85 FC 16 A4  1 
1A41710 	50 EE A0  1 10  0  0  0 
constant /list-node
1A41718 	 0 2F 6C 69 73 74 2D 6E 
1A41720 	6F 64 65 8A 10 17 A4  1 
1A41728 	68 40 A0  1 14  0  0  0 

: read  ( adr len -- actual )
1A41730 	 0  0  0 72 65 61 64 84 
1A41738 	28 17 A4  1 20 40 A0  1 
   first-device @
1A41740 	A8 16 A4  1 5C 4C A0  1 
   begin  dup  while        ( adr len listnode )
1A41748 	40 49 A0  1 DC 41 A0  1 
1A41750 	78  0  0  0 
      >r                                            ( adr len )
1A41754 	BC 45 A0  1 
      r@ >read @  ?dup  if                          ( adr len xt )
1A41758 	E4 45 A0  1 E8 16 A4  1 
1A41760 	5C 4C A0  1 B4 70 A0  1 
1A41768 	DC 41 A0  1 48  0  0  0 
         >r 2dup r>                                 ( adr len adr len xt )
1A41770 	BC 45 A0  1 C0 49 A0  1 
1A41778 	D0 45 A0  1 
         r@ >ihandle @  call-package                ( adr len actual )
1A4177C 	E4 45 A0  1 
1A41780 	D4 16 A4  1 5C 4C A0  1 
1A41788 	8C 31 A2  1 
         dup 0>  if  nip nip  r> drop  exit  then   ( adr len actual )
1A4178C 	40 49 A0  1 
1A41790 	A4 47 A0  1 DC 41 A0  1 
1A41798 	18  0  0  0 FC 46 A0  1 
1A417A0 	FC 46 A0  1 D0 45 A0  1 
1A417A8 	30 49 A0  1 40 46 A0  1 
         drop                                       ( adr len )
1A417B0 	30 49 A0  1 
      then                                          ( adr len )
      r> >link @            ( adr len listnode' )
1A417B4 	D0 45 A0  1 
1A417B8 	BC 16 A4  1 5C 4C A0  1 
   repeat                   ( adr len listnode )
1A417C0 	C8 41 A0  1 84 FF FF FF 
   3drop -2
1A417C8 	90 52 A0  1 58 41 A0  1 
1A417D0 	FE FF FF FF 
;
1A417D4 	58 46 A0  1 
: write  ( adr len -- len )
1A417D8 	 0  0 77 72 69 74 65 85 
1A417E0 	3C 17 A4  1 20 40 A0  1 
   first-device @
1A417E8 	A8 16 A4  1 5C 4C A0  1 
   begin  dup  while        ( adr len listnode )
1A417F0 	40 49 A0  1 DC 41 A0  1 
1A417F8 	54  0  0  0 
      >r                                    ( adr len )
1A417FC 	BC 45 A0  1 
      r@ >write @  ?dup  if                 ( adr len xt )
1A41800 	E4 45 A0  1 FC 16 A4  1 
1A41808 	5C 4C A0  1 B4 70 A0  1 
1A41810 	DC 41 A0  1 24  0  0  0 
         >r 2dup r>                         ( adr len adr len xt )
1A41818 	BC 45 A0  1 C0 49 A0  1 
1A41820 	D0 45 A0  1 
         r@ >ihandle @  call-package  drop  ( adr len )
1A41824 	E4 45 A0  1 
1A41828 	D4 16 A4  1 5C 4C A0  1 
1A41830 	8C 31 A2  1 30 49 A0  1 
      then                                  ( adr len )
      r> >link @            ( adr len listnode' )
1A41838 	D0 45 A0  1 BC 16 A4  1 
1A41840 	5C 4C A0  1 
   repeat                   ( adr len listnode )
1A41844 	C8 41 A0  1 
1A41848 	A8 FF FF FF 
   drop nip
1A4184C 	30 49 A0  1 
1A41850 	FC 46 A0  1 
;
1A41854 	58 46 A0  1 
: ring-bell  ( -- )
1A41858 	 0  0 72 69 6E 67 2D 62 
1A41860 	65 6C 6C 89 E4 17 A4  1 
1A41868 	20 40 A0  1 
   first-device @
1A4186C 	A8 16 A4  1 
1A41870 	5C 4C A0  1 
   begin  dup  while        ( listnode )
1A41874 	40 49 A0  1 
1A41878 	DC 41 A0  1 44  0  0  0 
      >r                               ( )
1A41880 	BC 45 A0  1 
      r@ >bell @  ?dup  if             ( xt )
1A41884 	E4 45 A0  1 
1A41888 	10 17 A4  1 5C 4C A0  1 
1A41890 	B4 70 A0  1 DC 41 A0  1 
1A41898 	14  0  0  0 
         r@ >ihandle @  call-package   ( )
1A4189C 	E4 45 A0  1 
1A418A0 	D4 16 A4  1 5C 4C A0  1 
1A418A8 	8C 31 A2  1 
      then                             ( )
      r> >link @            ( listnode' )
1A418AC 	D0 45 A0  1 
1A418B0 	BC 16 A4  1 5C 4C A0  1 
   repeat                   ( listnode )
1A418B8 	C8 41 A0  1 B8 FF FF FF 
   drop                
1A418C0 	30 49 A0  1 
;
1A418C4 	58 46 A0  1 

: show-devices  ( -- )
1A418C8 	 0  0  0 73 68 6F 77 2D 
1A418D0 	64 65 76 69 63 65 73 8C 
1A418D8 	68 18 A4  1 20 40 A0  1 
   first-device @
1A418E0 	A8 16 A4  1 5C 4C A0  1 
   begin  dup  while        ( listnode )
1A418E8 	40 49 A0  1 DC 41 A0  1 
1A418F0 	98  0  0  0 
      >r                    ( )
1A418F4 	BC 45 A0  1 
      r@ >read  @  if  ." R"  else  ."  "  then
1A418F8 	E4 45 A0  1 E8 16 A4  1 
1A41900 	5C 4C A0  1 DC 41 A0  1 
1A41908 	14  0  0  0 20 7C A0  1 
1A41910 	 1 52  0  0 C8 41 A0  1 
1A41918 	 C  0  0  0 20 7C A0  1 
1A41920 	 1 20  0  0 
      r@ >write @  if  ." W"  else  ."  "  then
1A41924 	E4 45 A0  1 
1A41928 	FC 16 A4  1 5C 4C A0  1 
1A41930 	DC 41 A0  1 14  0  0  0 
1A41938 	20 7C A0  1  1 57  0  0 
1A41940 	C8 41 A0  1  C  0  0  0 
1A41948 	20 7C A0  1  1 20  0  0 
      space
1A41950 	CC 71 A0  1 
      r@ >ihandle @  dup .  iselect  pwd  iunselect
1A41954 	E4 45 A0  1 
1A41958 	D4 16 A4  1 5C 4C A0  1 
1A41960 	40 49 A0  1 94 7A A0  1 
1A41968 	3C 40 A2  1 D0 2B A2  1 
1A41970 	94 40 A2  1 
      r> >link @            ( listnode' )
1A41974 	D0 45 A0  1 
1A41978 	BC 16 A4  1 5C 4C A0  1 
   repeat                   ( listnode )
1A41980 	C8 41 A0  1 64 FF FF FF 
   drop                     ( )
1A41988 	30 49 A0  1 
;
1A4198C 	58 46 A0  1 

: add-device  ( ihandle -- )
1A41990 	 0 61 64 64 2D 64 65 76 
1A41998 	69 63 65 8A DC 18 A4  1 
1A419A0 	20 40 A0  1 
   ?dup  0=  if  exit  then                      ( ihandle )
1A419A4 	B4 70 A0  1 
1A419A8 	24 47 A0  1 DC 41 A0  1 
1A419B0 	 8  0  0  0 40 46 A0  1 

   /list-node alloc-mem >r                       ( ihandle r: listnode )
1A419B8 	28 17 A4  1 F0 6C A0  1 
1A419C0 	BC 45 A0  1 

   dup r@ >ihandle !                             ( ihandle r: listnode )
1A419C4 	40 49 A0  1 
1A419C8 	E4 45 A0  1 D4 16 A4  1 
1A419D0 	54 4D A0  1 

   ihandle>phandle                               ( phandle r: listnode )
1A419D4 	 0 32 A2  1 

   " read"  third find-method  0=  if  0  then   ( phandle xt r: listnode )
1A419D8 	9C 53 A0  1  4 72 65 61 
1A419E0 	64  0  0  0 CC 1D A3  1 
1A419E8 	A0 2F A2  1 24 47 A0  1 
1A419F0 	DC 41 A0  1  8  0  0  0 
1A419F8 	70 6F A0  1 
   r@ >read !
1A419FC 	E4 45 A0  1 
1A41A00 	E8 16 A4  1 54 4D A0  1 

   " write" third find-method  0=  if  0  then   ( phandle xt r: listnode )
1A41A08 	9C 53 A0  1  5 77 72 69 
1A41A10 	74 65  0  0 CC 1D A3  1 
1A41A18 	A0 2F A2  1 24 47 A0  1 
1A41A20 	DC 41 A0  1  8  0  0  0 
1A41A28 	70 6F A0  1 
   r@ >write !                                   ( phandle r: listnode )
1A41A2C 	E4 45 A0  1 
1A41A30 	FC 16 A4  1 54 4D A0  1 
   
   " ring-bell" third find-method  0=  if  0  then  ( phandle xt r: listnode )
1A41A38 	9C 53 A0  1  9 72 69 6E 
1A41A40 	67 2D 62 65 6C 6C  0  0 
1A41A48 	CC 1D A3  1 A0 2F A2  1 
1A41A50 	24 47 A0  1 DC 41 A0  1 
1A41A58 	 8  0  0  0 70 6F A0  1 
   r@ >bell !                                    ( phandle r: listnode )
1A41A60 	E4 45 A0  1 10 17 A4  1 
1A41A68 	54 4D A0  1 
   
   " install-abort" third find-method  if        ( phandle xt r: listnode )
1A41A6C 	9C 53 A0  1 
1A41A70 	 D 69 6E 73 74 61 6C 6C 
1A41A78 	2D 61 62 6F 72 74  0  0 
1A41A80 	CC 1D A3  1 A0 2F A2  1 
1A41A88 	DC 41 A0  1 14  0  0  0 
      r@ >ihandle @ call-package                 ( phandle r: listnode )
1A41A90 	E4 45 A0  1 D4 16 A4  1 
1A41A98 	5C 4C A0  1 8C 31 A2  1 
   then                                          ( phandle r: listnode )
   
   drop
1A41AA0 	30 49 A0  1 

   first-device @  r@ >link !                    ( r: listnode )
1A41AA4 	A8 16 A4  1 
1A41AA8 	5C 4C A0  1 E4 45 A0  1 
1A41AB0 	BC 16 A4  1 54 4D A0  1 
   r> first-device !                             ( )
1A41AB8 	D0 45 A0  1 A8 16 A4  1 
1A41AC0 	54 4D A0  1 
;
1A41AC4 	58 46 A0  1 

: open  ( -- true )  true  ;
1A41AC8 	 0  0  0 6F 70 65 6E 84 
1A41AD0 	A0 19 A4  1 20 40 A0  1 
1A41AD8 	 4 70 A0  1 58 46 A0  1 

: close  ( -- )
1A41AE0 	 0  0 63 6C 6F 73 65 85 
1A41AE8 	D4 1A A4  1 20 40 A0  1 
   first-device @
1A41AF0 	A8 16 A4  1 5C 4C A0  1 
   begin  dup  while                    ( listnode )
1A41AF8 	40 49 A0  1 DC 41 A0  1 
1A41B00 	78  0  0  0 
      >r                                ( r: listnode )
1A41B04 	BC 45 A0  1 
      " remove-abort"  r@ >ihandle @    ( $ ihandle r: listnode )
1A41B08 	9C 53 A0  1  C 72 65 6D 
1A41B10 	6F 76 65 2D 61 62 6F 72 
1A41B18 	74  0  0  0 E4 45 A0  1 
1A41B20 	D4 16 A4  1 5C 4C A0  1 
      ihandle>phandle  find-method  if  ( xt r: listnode )
1A41B28 	 0 32 A2  1 A0 2F A2  1 
1A41B30 	DC 41 A0  1 14  0  0  0 
         r> >ihandle @ call-package     ( r: listnode )
1A41B38 	D0 45 A0  1 D4 16 A4  1 
1A41B40 	5C 4C A0  1 8C 31 A2  1 
      then                              ( r: listnode )

      r@ >ihandle @  close-dev          ( r: listnode )
1A41B48 	E4 45 A0  1 D4 16 A4  1 
1A41B50 	5C 4C A0  1 5C 37 A2  1 
      r@ >link @                        ( next r: listnode )
1A41B58 	E4 45 A0  1 BC 16 A4  1 
1A41B60 	5C 4C A0  1 
      r> /list-node free-mem            ( next )
1A41B64 	D0 45 A0  1 
1A41B68 	28 17 A4  1  8 6D A0  1 
   repeat                               ( 0 )
1A41B70 	C8 41 A0  1 84 FF FF FF 
   drop
1A41B78 	30 49 A0  1 
;
1A41B7C 	58 46 A0  1 

: remove-device  ( ihandle -- )
1A41B80 	 0  0 72 65 6D 6F 76 65 
1A41B88 	2D 64 65 76 69 63 65 8D 
1A41B90 	EC 1A A4  1 20 40 A0  1 
   ?dup  0=  if  exit  then             ( ihandle )
1A41B98 	B4 70 A0  1 24 47 A0  1 
1A41BA0 	DC 41 A0  1  8  0  0  0 
1A41BA8 	40 46 A0  1 

   >r  first-device                     ( prev r: ihandle )
1A41BAC 	BC 45 A0  1 
1A41BB0 	A8 16 A4  1 

   begin  dup >link @  dup  while       ( prev this  r: ihandle )
1A41BB4 	40 49 A0  1 
1A41BB8 	BC 16 A4  1 5C 4C A0  1 
1A41BC0 	40 49 A0  1 DC 41 A0  1 
1A41BC8 	88  0  0  0 
      dup >ihandle @  r@ =  if          ( prev this  r: ihandle )
1A41BCC 	40 49 A0  1 
1A41BD0 	D4 16 A4  1 5C 4C A0  1 
1A41BD8 	E4 45 A0  1 24 48 A0  1 
1A41BE0 	DC 41 A0  1 60  0  0  0 

         " remove-abort"  r@ ihandle>phandle  find-method  if  ( prev this xt r: ihandle )
1A41BE8 	9C 53 A0  1  C 72 65 6D 
1A41BF0 	6F 76 65 2D 61 62 6F 72 
1A41BF8 	74  0  0  0 E4 45 A0  1 
1A41C00 	 0 32 A2  1 A0 2F A2  1 
1A41C08 	DC 41 A0  1  C  0  0  0 
            r@ call-package             ( prev this  r: ihandle )
1A41C10 	E4 45 A0  1 8C 31 A2  1 
         then                           ( prev this  r: ihandle )
         r> drop                        ( prev this )
1A41C18 	D0 45 A0  1 30 49 A0  1 

         dup >link @                    ( prev this next )
1A41C20 	40 49 A0  1 BC 16 A4  1 
1A41C28 	5C 4C A0  1 
         rot >link !                    ( this )
1A41C2C 	7C 49 A0  1 
1A41C30 	BC 16 A4  1 54 4D A0  1 
         /list-node free-mem            ( )
1A41C38 	28 17 A4  1  8 6D A0  1 
         exit                           ( )
1A41C40 	40 46 A0  1 
      then                              ( prev this r: ihandle )
      nip                               ( prev'     r: ihandle )
1A41C44 	FC 46 A0  1 
   repeat                               ( prev next r: ihandle )
1A41C48 	C8 41 A0  1 68 FF FF FF 
   r> 3drop
1A41C50 	D0 45 A0  1 90 52 A0  1 
;
1A41C58 	58 46 A0  1 

: install-abort  ( -- )  ;
1A41C5C 	 0  0 69 6E 
1A41C60 	73 74 61 6C 6C 2D 61 62 
1A41C68 	6F 72 74 8D 94 1B A4  1 
1A41C70 	20 40 A0  1 58 46 A0  1 
: remove-abort  ( -- )  ;
1A41C78 	 0  0  0 72 65 6D 6F 76 
1A41C80 	65 2D 61 62 6F 72 74 8C 
1A41C88 	70 1C A4  1 20 40 A0  1 
1A41C90 	58 46 A0  1 

finish-device
1A41C94 	 0  0  0  0 
1A41C98 	 0  0  0  0  0  0  0  0 
1A41CA0 	 0  0  0  0  0  0  0  0 
1A41CA8 	 0  0  0  0  0  0  0  0 
device-end

0 value in-mux-ih
1A41CB0 	 0  0 69 6E 2D 6D 75 78 
1A41CB8 	2D 69 68 89 5C 16 A4  1 
1A41CC0 	50 40 A0  1 AC  D  0  0 
0 value out-mux-ih
1A41CC8 	 0 6F 75 74 2D 6D 75 78 
1A41CD0 	2D 69 68 8A C0 1C A4  1 
1A41CD8 	50 40 A0  1 B0  D  0  0 

: new-mux  ( -- ih )
1A41CE0 	6E 65 77 2D 6D 75 78 87 
1A41CE8 	D8 1C A4  1 20 40 A0  1 
   " "  " mux" $open-package
1A41CF0 	9C 53 A0  1  0  0  0  0 
1A41CF8 	9C 53 A0  1  3 6D 75 78 
1A41D00 	 0  0  0  0 80 3A A2  1 
   dup 0= abort" Can't open mux package"
1A41D08 	40 49 A0  1 24 47 A0  1 
1A41D10 	 8 81 A0  1 16 43 61 6E 
1A41D18 	27 74 20 6F 70 65 6E 20 
1A41D20 	6D 75 78 20 70 61 63 6B 
1A41D28 	61 67 65  0 
;
1A41D2C 	58 46 A0  1 

: add-mux   ( ih mux-ih -- )
1A41D30 	61 64 64 2D 6D 75 78 87 
1A41D38 	EC 1C A4  1 20 40 A0  1 
   over  if  >r " add-device" r>  $call-method  else  2drop  then
1A41D40 	54 49 A0  1 DC 41 A0  1 
1A41D48 	28  0  0  0 BC 45 A0  1 
1A41D50 	9C 53 A0  1  A 61 64 64 
1A41D58 	2D 64 65 76 69 63 65  0 
1A41D60 	D0 45 A0  1 B4 31 A2  1 
1A41D68 	C8 41 A0  1  8  0  0  0 
1A41D70 	AC 49 A0  1 
;
1A41D74 	58 46 A0  1 

: remove-mux  ( ih mux-ih -- )  >r " remove-device" r> $call-method  ;
1A41D78 	 0 72 65 6D 6F 76 65 2D 
1A41D80 	6D 75 78 8A 3C 1D A4  1 
1A41D88 	20 40 A0  1 BC 45 A0  1 
1A41D90 	9C 53 A0  1  D 72 65 6D 
1A41D98 	6F 76 65 2D 64 65 76 69 
1A41DA0 	63 65  0  0 D0 45 A0  1 
1A41DA8 	B4 31 A2  1 58 46 A0  1 

: add-output  ( ih -- )  out-mux-ih add-mux  ;
1A41DB0 	 0 61 64 64 2D 6F 75 74 
1A41DB8 	70 75 74 8A 88 1D A4  1 
1A41DC0 	20 40 A0  1 D8 1C A4  1 
1A41DC8 	3C 1D A4  1 58 46 A0  1 
: remove-output  ( ih -- )  out-mux-ih remove-mux  ;
1A41DD0 	 0  0 72 65 6D 6F 76 65 
1A41DD8 	2D 6F 75 74 70 75 74 8D 
1A41DE0 	C0 1D A4  1 20 40 A0  1 
1A41DE8 	D8 1C A4  1 88 1D A4  1 
1A41DF0 	58 46 A0  1 
: add-input  ( ih -- )  in-mux-ih add-mux  ;
1A41DF4 	 0  0 61 64 
1A41DF8 	64 2D 69 6E 70 75 74 89 
1A41E00 	E4 1D A4  1 20 40 A0  1 
1A41E08 	C0 1C A4  1 3C 1D A4  1 
1A41E10 	58 46 A0  1 
: remove-input  ( ih -- )  in-mux-ih remove-mux  ;
1A41E14 	 0  0  0 72 
1A41E18 	65 6D 6F 76 65 2D 69 6E 
1A41E20 	70 75 74 8C  4 1E A4  1 
1A41E28 	20 40 A0  1 C0 1C A4  1 
1A41E30 	88 1D A4  1 58 46 A0  1 

: .mux  ( -- )
1A41E38 	 0  0  0 2E 6D 75 78 84 
1A41E40 	28 1E A4  1 20 40 A0  1 
   in-mux-ih  if
1A41E48 	C0 1C A4  1 DC 41 A0  1 
1A41E50 	34  0  0  0 
      ." Input mux:" cr
1A41E54 	20 7C A0  1 
1A41E58 	 A 49 6E 70 75 74 20 6D 
1A41E60 	75 78 3A  0 80 6D A0  1 
      " show-devices" in-mux-ih $call-method
1A41E68 	9C 53 A0  1  C 73 68 6F 
1A41E70 	77 2D 64 65 76 69 63 65 
1A41E78 	73  0  0  0 C0 1C A4  1 
1A41E80 	B4 31 A2  1 
   then
   out-mux-ih  if
1A41E84 	D8 1C A4  1 
1A41E88 	DC 41 A0  1 38  0  0  0 
      ." Output mux:" cr
1A41E90 	20 7C A0  1  B 4F 75 74 
1A41E98 	70 75 74 20 6D 75 78 3A 
1A41EA0 	 0  0  0  0 80 6D A0  1 
      " show-devices" out-mux-ih $call-method
1A41EA8 	9C 53 A0  1  C 73 68 6F 
1A41EB0 	77 2D 64 65 76 69 63 65 
1A41EB8 	73  0  0  0 D8 1C A4  1 
1A41EC0 	B4 31 A2  1 
   then
;
1A41EC4 	58 46 A0  1 

0 value fallback-in-ih
1A41EC8 	 0 66 61 6C 6C 62 61 63 
1A41ED0 	6B 2D 69 6E 2D 69 68 8E 
1A41ED8 	44 1E A4  1 50 40 A0  1 
1A41EE0 	B4  D  0  0 
0 value fallback-out-ih
1A41EE4 	66 61 6C 6C 
1A41EE8 	62 61 63 6B 2D 6F 75 74 
1A41EF0 	2D 69 68 8F DC 1E A4  1 
1A41EF8 	50 40 A0  1 B8  D  0  0 

: install-mux-io  ( -- )
1A41F00 	 0 69 6E 73 74 61 6C 6C 
1A41F08 	2D 6D 75 78 2D 69 6F 8E 
1A41F10 	F8 1E A4  1 20 40 A0  1 
   new-mux to in-mux-ih
1A41F18 	EC 1C A4  1 B8 40 A0  1 
1A41F20 	C0 1C A4  1 
   new-mux to out-mux-ih
1A41F24 	EC 1C A4  1 
1A41F28 	B8 40 A0  1 D8 1C A4  1 

   fallback-device open-dev  dup to fallback-in-ih   add-input
1A41F30 	EC E3 A1  1 FC 3E A2  1 
1A41F38 	40 49 A0  1 B8 40 A0  1 
1A41F40 	DC 1E A4  1  4 1E A4  1 
   fallback-device open-dev  dup to fallback-out-ih  add-output
1A41F48 	EC E3 A1  1 FC 3E A2  1 
1A41F50 	40 49 A0  1 B8 40 A0  1 
1A41F58 	F8 1E A4  1 C0 1D A4  1 

   screen open-dev to screen-ih
1A41F60 	B4 5C A2  1 FC 3E A2  1 
1A41F68 	B8 40 A0  1 5C 16 A4  1 
   screen-ih add-output
1A41F70 	5C 16 A4  1 C0 1D A4  1 

   keyboard open-dev to keyboard-ih
1A41F78 	90 5C A2  1 FC 3E A2  1 
1A41F80 	B8 40 A0  1 44 16 A4  1 
   keyboard-ih add-input
1A41F88 	44 16 A4  1  4 1E A4  1 

   in-mux-ih set-stdin  out-mux-ih set-stdout
1A41F90 	C0 1C A4  1 AC 58 A2  1 
1A41F98 	D8 1C A4  1  4 5B A2  1 

   console-io
1A41FA0 	18 5D A2  1 
;
1A41FA4 	58 46 A0  1 


OpenFirmware/ofw/core/muxdev.fth_AL	944 1A41FA8 purpose: Warm reset

\ There are two ways to reset a PC.  Some use a bit in port 92, and
\ others use the keyboard controller.  We try both.

: eat-data  ( -- )  begin  h# 64 pc@  1 and  while  h# 60 pc@ drop  repeat  ;
1A41FA8 	 0  0  0 65 61 74 2D 64 
1A41FB0 	61 74 61 88 14 1F A4  1 
1A41FB8 	20 40 A0  1 58 41 A0  1 
1A41FC0 	64  0  0  0 AC 81 A2  1 
1A41FC8 	80 6F A0  1 5C 44 A0  1 
1A41FD0 	DC 41 A0  1 1C  0  0  0 
1A41FD8 	58 41 A0  1 60  0  0  0 
1A41FE0 	AC 81 A2  1 30 49 A0  1 
1A41FE8 	C8 41 A0  1 D0 FF FF FF 
1A41FF0 	58 46 A0  1 
: inbuf-wait  ( -- )  begin  h# 64 pc@  2 and  0= until  ;
1A41FF4 	 0 69 6E 62 
1A41FF8 	75 66 2D 77 61 69 74 8A 
1A42000 	B8 1F A4  1 20 40 A0  1 
1A42008 	58 41 A0  1 64  0  0  0 
1A42010 	AC 81 A2  1 90 6F A0  1 
1A42018 	5C 44 A0  1 24 47 A0  1 
1A42020 	DC 41 A0  1 E4 FF FF FF 
1A42028 	58 46 A0  1 
: outbuf-wait  ( -- )  begin  h# 64 pc@  1 and  until  ;
1A4202C 	6F 75 74 62 
1A42030 	75 66 2D 77 61 69 74 8B 
1A42038 	 4 20 A4  1 20 40 A0  1 
1A42040 	58 41 A0  1 64  0  0  0 
1A42048 	AC 81 A2  1 80 6F A0  1 
1A42050 	5C 44 A0  1 DC 41 A0  1 
1A42058 	E8 FF FF FF 58 46 A0  1 
: cmd-put  ( cmd -- )  inbuf-wait  h# 64 pc!  ;
1A42060 	63 6D 64 2D 70 75 74 87 
1A42068 	3C 20 A4  1 20 40 A0  1 
1A42070 	 4 20 A4  1 58 41 A0  1 
1A42078 	64  0  0  0 E8 81 A2  1 
1A42080 	58 46 A0  1 
: data-get  ( -- data )   outbuf-wait  h# 60 pc@  ;
1A42084 	 0  0  0 64 
1A42088 	61 74 61 2D 67 65 74 88 
1A42090 	6C 20 A4  1 20 40 A0  1 
1A42098 	3C 20 A4  1 58 41 A0  1 
1A420A0 	60  0  0  0 AC 81 A2  1 
1A420A8 	58 46 A0  1 
: data-put  ( data -- data )   inbuf-wait  h# 60 pc!  ;
1A420AC 	 0  0  0 64 
1A420B0 	61 74 61 2D 70 75 74 88 
1A420B8 	94 20 A4  1 20 40 A0  1 
1A420C0 	 4 20 A4  1 58 41 A0  1 
1A420C8 	60  0  0  0 E8 81 A2  1 
1A420D0 	58 46 A0  1 
: kbd-reset-all  ( -- )
1A420D4 	 0  0 6B 62 
1A420D8 	64 2D 72 65 73 65 74 2D 
1A420E0 	61 6C 6C 8D BC 20 A4  1 
1A420E8 	20 40 A0  1 
   eat-data                           \ Discard pending kbd data
1A420EC 	B8 1F A4  1 
   h# d0 cmd-put  data-get  ( val )   \ Get old output register value
1A420F0 	58 41 A0  1 D0  0  0  0 
1A420F8 	6C 20 A4  1 94 20 A4  1 
   1 invert and             ( val' )  \ Clear RESET* bit
1A42100 	80 6F A0  1 30 45 A0  1 
1A42108 	5C 44 A0  1 
   h# d1 cmd-put  data-put  ( )       \ Write new output register val
1A4210C 	58 41 A0  1 
1A42110 	D1  0  0  0 6C 20 A4  1 
1A42118 	BC 20 A4  1 
;
1A4211C 	58 46 A0  1 

: (reset-all)  ( -- )
1A42120 	28 72 65 73 65 74 2D 61 
1A42128 	6C 6C 29 8B E8 20 A4  1 
1A42130 	20 40 A0  1 
   h# 92 pc@  1 invert and  dup  h# 92 pc!  1 or  h# 92 pc!  d# 1000 ms
1A42134 	58 41 A0  1 
1A42138 	92  0  0  0 AC 81 A2  1 
1A42140 	80 6F A0  1 30 45 A0  1 
1A42148 	5C 44 A0  1 40 49 A0  1 
1A42150 	58 41 A0  1 92  0  0  0 
1A42158 	E8 81 A2  1 80 6F A0  1 
1A42160 	70 44 A0  1 58 41 A0  1 
1A42168 	92  0  0  0 E8 81 A2  1 
1A42170 	58 41 A0  1 E8  3  0  0 
1A42178 	60 E0 A1  1 

   \ If port 92 doesn't work, try the keyboard controller reset
   kbd-reset-all  d# 1000 ms
1A4217C 	E8 20 A4  1 
1A42180 	58 41 A0  1 E8  3  0  0 
1A42188 	60 E0 A1  1 
;
1A4218C 	58 46 A0  1 
' (reset-all) to reset-all

OpenFirmware/cpu/x86/pc/reset.fth_AL	1E8 1A42190 purpose: Stand-alone boot code for running ix86 version Forth

\ create debug-startup

\ Boot code (cold and warm start).  The cold start code is executed
\ when Forth is initially started.  Its job is to initialize the Forth
\ virtual machine registers.  The warm start code is executed when Forth
\ is re-entered, perhaps as a result of an exception.

[ifdef] debug-startup
: ascii-chars " 0123456789abcdef" drop ;
1A42190 	61 73 63 69 69 2D 63 68 
1A42198 	61 72 73 8B 30 21 A4  1 
1A421A0 	20 40 A0  1 9C 53 A0  1 
1A421A8 	10 30 31 32 33 34 35 36 
1A421B0 	37 38 39 61 62 63 64 65 
1A421B8 	66  0  0  0 30 49 A0  1 
1A421C0 	58 46 A0  1 
: hdot  ( n -- )
1A421C4 	 0  0  0 68 
1A421C8 	64 6F 74 84 A0 21 A4  1 
1A421D0 	20 40 A0  1 
   7 0 do  0 h# 10 um/mod  loop  8 0 do  ascii-chars + c@ emit  loop  space
1A421D4 	E0 6F A0  1 
1A421D8 	70 6F A0  1 88 42 A0  1 
1A421E0 	1C  0  0  0 70 6F A0  1 
1A421E8 	58 41 A0  1 10  0  0  0 
1A421F0 	7C 5D A0  1 F8 41 A0  1 
1A421F8 	EC FF FF FF F0 6F A0  1 
1A42200 	70 6F A0  1 88 42 A0  1 
1A42208 	1C  0  0  0 A0 21 A4  1 
1A42210 	 4 45 A0  1 C4 4C A0  1 
1A42218 	2C 6C A0  1 F8 41 A0  1 
1A42220 	EC FF FF FF CC 71 A0  1 
;
1A42228 	58 46 A0  1 
[then]

hex
warning @  warning off 
: stand-init-io  ( -- )
1A4222C 	 0  0 73 74 
1A42230 	61 6E 64 2D 69 6E 69 74 
1A42238 	2D 69 6F 8D D0 21 A4  1 
1A42240 	20 40 A0  1 
   stand-init-io
1A42244 	18 6F A2  1 
   dict-limit to limit
1A42248 	 C 26 A3  1 B8 40 A0  1 
1A42250 	5C 54 A0  1 
   inituarts install-uart-io
1A42254 	58 14 A4  1 
1A42258 	8C 15 A4  1 
   ['] noop          ['] bye    (is
1A4225C 	60 53 A0  1 
1A42260 	64 4F A0  1 60 53 A0  1 
1A42268 	74 6C A0  1 A4 65 A0  1 
   ['] RAMbase       is lo-segment-base
1A42270 	60 53 A0  1 A0 25 A3  1 
1A42278 	98 40 A0  1 70  E A1  1 
   ['] here          is lo-segment-limit
1A42280 	60 53 A0  1 70 54 A0  1 
1A42288 	98 40 A0  1 90  E A1  1 
   ['] here          is hi-segment-base
1A42290 	60 53 A0  1 70 54 A0  1 
1A42298 	98 40 A0  1 AC  E A1  1 
   ['] here          is hi-segment-limit
1A422A0 	60 53 A0  1 70 54 A0  1 
1A422A8 	98 40 A0  1 CC  E A1  1 

   ['] reset-all     is bye
1A422B0 	60 53 A0  1 38 E2 A1  1 
1A422B8 	98 40 A0  1 74 6C A0  1 
   true is flat?
1A422C0 	 4 70 A0  1 B8 40 A0  1 
1A422C8 	44 EF A0  1 
   ['] 2drop         is sync-cache
1A422CC 	60 53 A0  1 
1A422D0 	AC 49 A0  1 98 40 A0  1 
1A422D8 	34 6D A0  1 
;
1A422DC 	58 46 A0  1 
warning !

[ifdef] debug-startup
\ diagnostic macros
\ Assembler macro to assemble code to send the character "char" to COM1
: wait-tx-ready  ( -- )
1A422E0 	 0  0 77 61 69 74 2D 74 
1A422E8 	78 2D 72 65 61 64 79 8D 
1A422F0 	40 22 A4  1 20 40 A0  1 
[ifdef] mem-uart-base   
   " begin   h# 20 #  mem-uart-base 5 + #) byte test  0<> until" evaluate
[else]
   " begin   h# 3fd # dx mov   dx al in  h# 20 # al and   0<> until" evaluate
1A422F8 	9C 53 A0  1 3E 62 65 67 
1A42300 	69 6E 20 20 20 68 23 20 
1A42308 	33 66 64 20 23 20 64 78 
1A42310 	20 6D 6F 76 20 20 20 64 
1A42318 	78 20 61 6C 20 69 6E 20 
1A42320 	20 68 23 20 32 30 20 23 
1A42328 	20 61 6C 20 61 6E 64 20 
1A42330 	20 20 30 3C 3E 20 75 6E 
1A42338 	74 69 6C  0 D8 E5 A0  1 
[then]
;
1A42340 	58 46 A0  1 
: report  ( char -- )
1A42344 	 0 72 65 70 
1A42348 	6F 72 74 86 F4 22 A4  1 
1A42350 	20 40 A0  1 
   wait-tx-ready
1A42354 	F4 22 A4  1 
[ifdef] mem-uart-base
   ( char )  " # mem-uart-base #) byte mov" evaluate
[else]
   ( char )  " # al mov  h# 3f8 # dx mov  al dx out" evaluate
1A42358 	9C 53 A0  1 24 23 20 61 
1A42360 	6C 20 6D 6F 76 20 20 68 
1A42368 	23 20 33 66 38 20 23 20 
1A42370 	64 78 20 6D 6F 76 20 20 
1A42378 	61 6C 20 64 78 20 6F 75 
1A42380 	74  0  0  0 D8 E5 A0  1 
[then]
   wait-tx-ready
1A42388 	F4 22 A4  1 
;
1A4238C 	58 46 A0  1 
: nreport  ( -- )  \ print 4-bit value in bl
1A42390 	6E 72 65 70 6F 72 74 87 
1A42398 	50 23 A4  1 20 40 A0  1 
   wait-tx-ready
1A423A0 	F4 22 A4  1 
[ifdef] mem-uart-base
   " bl al mov  h# 0f # ax and  h# 30 # ax add  al mem-uart-base #) mov" evaluate
[else]
   " bl al mov  h# 0f # ax and  h# 30 # ax add  h# 3f8 # dx mov  al dx out" evaluate
1A423A4 	9C 53 A0  1 
1A423A8 	45 62 6C 20 61 6C 20 6D 
1A423B0 	6F 76 20 20 68 23 20 30 
1A423B8 	66 20 23 20 61 78 20 61 
1A423C0 	6E 64 20 20 68 23 20 33 
1A423C8 	30 20 23 20 61 78 20 61 
1A423D0 	64 64 20 20 68 23 20 33 
1A423D8 	66 38 20 23 20 64 78 20 
1A423E0 	6D 6F 76 20 20 61 6C 20 
1A423E8 	64 78 20 6F 75 74  0  0 
1A423F0 	D8 E5 A0  1 
[then]
;
1A423F4 	58 46 A0  1 
: dotbyte   ( - )     \ print byte in bl
1A423F8 	64 6F 74 62 79 74 65 87 
1A42400 	9C 23 A4  1 20 40 A0  1 
   "  bx 4 # ror " eval  nreport
1A42408 	9C 53 A0  1  C 20 62 78 
1A42410 	20 34 20 23 20 72 6F 72 
1A42418 	20  0  0  0 D8 E5 A0  1 
1A42420 	9C 23 A4  1 
   "  bx 4 # rol " eval  nreport
1A42424 	9C 53 A0  1 
1A42428 	 C 20 62 78 20 34 20 23 
1A42430 	20 72 6F 6C 20  0  0  0 
1A42438 	D8 E5 A0  1 9C 23 A4  1 
   h# 20 nreport
1A42440 	58 41 A0  1 20  0  0  0 
1A42448 	9C 23 A4  1 
;
1A4244C 	58 46 A0  1 

label putchar  ( al:char -- )
1A42450 	70 75 74 63 68 61 72 87 
1A42458 	 4 24 A4  1 30 40 A0  1 
   dx push  bx push
1A42460 	52 53 
[ifdef] mem-uart-base
   wait-tx-ready
   al  mem-uart-base #) mov
[else]
   al bl mov
1A42462 	8A D8 
   wait-tx-ready
1A42464 	BA FD  3  0 
1A42468 	 0 EC 24 20 74 F6 
   bl al mov  h# 3f8 # dx mov  al dx out
1A4246E 	8A C3 
1A42470 	BA F8  3  0  0 EE 
[then]
   wait-tx-ready
1A42476 	BA FD 
1A42478 	 3  0  0 EC 24 20 74 F6 

   bx pop  dx pop
1A42480 	5B 5A 
   ret
1A42482 	C3 
end-code

label puthexit  ( ax:nibble -- )
1A42483 	70 75 74 68 65 
1A42488 	78 69 74 88 5C 24 A4  1 
1A42490 	30 40 A0  1 
   h# f #  ax  and
1A42494 	25  F  0  0 
1A42498 	 0 
   9 # ax cmp  > if
1A42499 	3D  9  0  0  0 7E  7 
      char a d# 10 - #  ax  add
1A424A0 	 5 57  0  0  0 
   else
1A424A5 	EB  5 
      char 0 #  ax  add
1A424A7 	 5 
1A424A8 	30  0  0  0 
   then
   putchar #) call
1A424AC 	E8 AF FF FF 
1A424B0 	FF 
   ret
1A424B1 	C3 
end-code

label dot  ( ax:value -- )
1A424B2 	 0  0 64 6F 74 83 
1A424B8 	90 24 A4  1 30 40 A0  1 
   bx push  cx push
1A424C0 	53 51 
   ax bx mov
1A424C2 	8B D8 
   8 # cx mov
1A424C4 	B9  8  0  0 
1A424C8 	 0 
   begin
      bx 4 # rol
1A424C9 	C1 C3  4 
      bx ax mov
1A424CC 	8B C3 
      puthexit #) call
1A424CE 	E8 C1 
1A424D0 	FF FF FF 
      cx dec
1A424D3 	49 
   0= until
1A424D4 	75 F3 
   h# 20 # ax mov
1A424D6 	B8 20 
1A424D8 	 0  0  0 
   putchar #) call
1A424DB 	E8 80 FF FF FF 
   cx pop bx pop
1A424E0 	59 5B 
   ret
1A424E2 	C3 
end-code

\ *** NOTE: dot is too big to be put inside a control structure ***
: mdot   ( reg - )     \ print 32-bit value in reg
1A424E3 	6D 64 6F 74 84 
1A424E8 	BC 24 A4  1 20 40 A0  1 
   " ax push   bx push   cx push   dx push" eval
1A424F0 	9C 53 A0  1 25 61 78 20 
1A424F8 	70 75 73 68 20 20 20 62 
1A42500 	78 20 70 75 73 68 20 20 
1A42508 	20 63 78 20 70 75 73 68 
1A42510 	20 20 20 64 78 20 70 75 
1A42518 	73 68  0  0 D8 E5 A0  1 
   " bx mov" eval	\ trashes ax,bx,cx,dx
1A42520 	9C 53 A0  1  6 62 78 20 
1A42528 	6D 6F 76  0 D8 E5 A0  1 
\   " 0 # cx mov begin" eval
   8 0 do
1A42530 	F0 6F A0  1 70 6F A0  1 
1A42538 	88 42 A0  1 28  0  0  0 
      "  bx 4 # rol " eval  nreport
1A42540 	9C 53 A0  1  C 20 62 78 
1A42548 	20 34 20 23 20 72 6F 6C 
1A42550 	20  0  0  0 D8 E5 A0  1 
1A42558 	9C 23 A4  1 
   loop
1A4255C 	F8 41 A0  1 
1A42560 	E0 FF FF FF 
\ XXX doesn't cx need to be decremented?
\   " d# 8 # cx cmp >= until" eval
   h# 20 report
1A42564 	58 41 A0  1 
1A42568 	20  0  0  0 50 23 A4  1 
   " dx pop   cx pop   bx pop   ax pop" eval
1A42570 	9C 53 A0  1 21 64 78 20 
1A42578 	70 6F 70 20 20 20 63 78 
1A42580 	20 70 6F 70 20 20 20 62 
1A42588 	78 20 70 6F 70 20 20 20 
1A42590 	61 78 20 70 6F 70  0  0 
1A42598 	D8 E5 A0  1 
;
1A4259C 	58 46 A0  1 

OpenFirmware/cpu/x86/pc/boot.fth_AL	410 1A425A0 : v-report  ( char -- )
1A425A0 	 0  0  0 76 2D 72 65 70 
1A425A8 	6F 72 74 88 EC 24 A4  1 
1A425B0 	20 40 A0  1 
   " # al mov  al h# b8000 #) mov  h# 1d # al mov  al h# b8001 #) mov" evaluate
1A425B4 	9C 53 A0  1 
1A425B8 	40 23 20 61 6C 20 6D 6F 
1A425C0 	76 20 20 61 6C 20 68 23 
1A425C8 	20 62 38 30 30 30 20 23 
1A425D0 	29 20 6D 6F 76 20 20 68 
1A425D8 	23 20 31 64 20 23 20 61 
1A425E0 	6C 20 6D 6F 76 20 20 61 
1A425E8 	6C 20 68 23 20 62 38 30 
1A425F0 	30 31 20 23 29 20 6D 6F 
1A425F8 	76  0  0  0 D8 E5 A0  1 
;
1A42600 	58 46 A0  1 
: vr-report  ( char -- )  \ Real mode version
1A42604 	 0  0 76 72 
1A42608 	2D 72 65 70 6F 72 74 89 
1A42610 	B0 25 A4  1 20 40 A0  1 
   " ds push  h# b000 # push ds pop" evaluate   
1A42618 	9C 53 A0  1 1E 64 73 20 
1A42620 	70 75 73 68 20 20 68 23 
1A42628 	20 62 30 30 30 20 23 20 
1A42630 	70 75 73 68 20 64 73 20 
1A42638 	70 6F 70  0 D8 E5 A0  1 
   " # al mov  al h# 8000 #) mov   h# 1d # al mov  al h# 8001 #) mov"  evaluate
1A42640 	9C 53 A0  1 3F 23 20 61 
1A42648 	6C 20 6D 6F 76 20 20 61 
1A42650 	6C 20 68 23 20 38 30 30 
1A42658 	30 20 23 29 20 6D 6F 76 
1A42660 	20 20 20 68 23 20 31 64 
1A42668 	20 23 20 61 6C 20 6D 6F 
1A42670 	76 20 20 61 6C 20 68 23 
1A42678 	20 38 30 30 31 20 23 29 
1A42680 	20 6D 6F 76  0  0  0  0 
1A42688 	D8 E5 A0  1 
   " ds pop" evaluate
1A4268C 	9C 53 A0  1 
1A42690 	 6 64 73 20 70 6F 70  0 
1A42698 	D8 E5 A0  1 
;
1A4269C 	58 46 A0  1 

\  mmo  from boot.fth 


label prom-cold-code  ( -- )
1A426A0 	 0 70 72 6F 6D 2D 63 6F 
1A426A8 	6C 64 2D 63 6F 64 65 8E 
1A426B0 	14 26 A4  1 30 40 A0  1 

   \ We assume that the machine is already in protected mode, with a
   \ linear mapping.  DS = ES = SS = FS = GS.  The descriptor referenced
   \ by CS maps the same memory as the DS descriptor.
   \ Interrupts are off.

   cld
1A426B8 	FC 

\ carret report
\ linefeed report
ascii c report
1A426B9 	BA FD  3  0  0 EC 24 
1A426C0 	20 74 F6 B0 63 BA F8  3 
1A426C8 	 0  0 EE BA FD  3  0  0 
1A426D0 	EC 24 20 74 F6 

\ Get the origin address
   here 5 + #) call   here origin -  ( offset )
1A426D5 	E8  0  0 
1A426D8 	 0  0 
   bx  pop
1A426DA 	5B 
   ( offset ) #  bx  sub	\ Origin in bx
1A426DB 	81 EB DA 26  4 
1A426E0 	 0 

\ Copy the initial User Area image to the RAM copy
   init-user-area #  si  mov	\ Init-up pointer in bx
1A426E1 	BE 20  0  0  0 
   bx si add                    \ add origin
1A426E6 	 1 DE 
   prom-main-task #  di  mov	\ Destination of copy
1A426E8 	BF  0 C0 BF  1 
   user-size #       cx  mov
1A426ED 	B9  0 40 
1A426F0 	 0  0 
   rep byte movs
1A426F2 	F2 A4 

ascii s report
1A426F4 	BA FD  3  0 
1A426F8 	 0 EC 24 20 74 F6 B0 73 
1A42700 	BA F8  3  0  0 EE BA FD 
1A42708 	 3  0  0 EC 24 20 74 F6 

   prom-main-task #      up  mov        \ Set User Area Pointer
1A42710 	BF  0 C0 BF  1 

\ The User Area is now initialized
   up        'user up0   mov	\ Set the up0 user variable
1A42715 	89 7F 4C 

\ Set the value of flat? so later code knows that we are running
\ in a single address space, i.e. Forth is not in a private segment.

   true #  ax  mov   ax  'user flat?  mov
1A42718 	B8 FF FF FF FF 89 87 F8 
1A42720 	 2  0  0 

   prom-main-task #  rp  mov	\ Initialize the Return Stack Pointer
1A42723 	BD  0 C0 BF  1 
   rp        'user rp0   mov    \ Set the rp0 user variable
1A42728 	89 6F 58 
   rp        ax          mov
1A4272B 	8B C5 
   rs-size # ax          sub
1A4272D 	2D  0  8 
1A42730 	 0  0 

\ Establish the Parameter Stack
   ax        sp          mov
1A42732 	8B E0 
   sp        'user sp0   mov	\ Set the sp0 user variable
1A42734 	89 67 54 

\   ps-size # ax          sub
\   ax  'user next-free-mem   mov        \ Set heap pointer

    'user dp-loc    ax    mov
1A42737 	8B 
1A42738 	87 F8  9  0  0 
    ax        'user dp    mov    \ Initialize the dictionary pointer
1A4273D 	89 47 24 

\ ascii s report
h# 20 report
1A42740 	BA FD  3  0  0 EC 24 20 
1A42748 	74 F6 B0 20 BA F8  3  0 
1A42750 	 0 EE BA FD  3  0  0 EC 
1A42758 	24 20 74 F6 

\ Enter Forth
   make-odd
1A4275C 	90 
   'body cold fw-pa +  dup #  ip  mov
1A4275D 	BE 58 ED 
1A42760 	A0  1 
   -4 allot token,
c;
1A42762 	FF E7 

: patchboot  ( -- )
1A42764 	 0  0 70 61 
1A42768 	74 63 68 62 6F 6F 74 89 
1A42770 	B4 26 A4  1 20 40 A0  1 
   prom-main-task ['] main-task >body !
1A42778 	38 26 A3  1 60 53 A0  1 
1A42780 	94 EF A0  1 E4 59 A0  1 
1A42788 	54 4D A0  1 

   here origin -  RAMbase +  is dp-loc
1A4278C 	70 54 A0  1 
1A42790 	50 55 A0  1 18 45 A0  1 
1A42798 	A0 25 A3  1  4 45 A0  1 
1A427A0 	B8 40 A0  1 D8 25 A3  1 

   \ Set offset field of branch at origin
   prom-cold-code origin 5 + -  origin 1+ !
1A427A8 	B4 26 A4  1 50 55 A0  1 
1A427B0 	C0 6F A0  1  4 45 A0  1 
1A427B8 	18 45 A0  1 50 55 A0  1 
1A427C0 	30 4B A0  1 54 4D A0  1 
;
1A427C8 	58 46 A0  1 

OpenFirmware/cpu/x86/pc/egareport.fth_AL	22C 1A427CC purpose: USB elaborations for the BIOS loaded OFW

0 value usb-delay  \ Milliseconds to wait before set-address
1A427CC 	 0  0 75 73 
1A427D0 	62 2D 64 65 6C 61 79 89 
1A427D8 	74 27 A4  1 50 40 A0  1 
1A427E0 	BC  D  0  0 

devalias u    /usb/disk
1A427E4 	 0  0 75 81 
1A427E8 	98 E6 A3  1 20 21 A2  1 
1A427F0 	 9 2F 75 73 62 2F 64 69 
1A427F8 	73 6B  0  0 

\ Like $show-devs, but ignores pagination keystrokes
: $nopage-show-devs  ( nodename$ -- )
1A427FC 	 0  0 24 6E 
1A42800 	6F 70 61 67 65 2D 73 68 
1A42808 	6F 77 2D 64 65 76 73 91 
1A42810 	DC 27 A4  1 20 40 A0  1 
   ['] exit? behavior >r  ['] false to exit?
1A42818 	60 53 A0  1 34  D A1  1 
1A42820 	10 C7 A0  1 BC 45 A0  1 
1A42828 	60 53 A0  1 18 70 A0  1 
1A42830 	98 40 A0  1 34  D A1  1 
   $show-devs
1A42838 	34 2D A2  1 
   r> to exit?
1A4283C 	D0 45 A0  1 
1A42840 	98 40 A0  1 34  D A1  1 
;
1A42848 	58 46 A0  1 

: (probe-usb2)  ( -- )
1A4284C 	 0  0  0 28 
1A42850 	70 72 6F 62 65 2D 75 73 
1A42858 	62 32 29 8C 14 28 A4  1 
1A42860 	20 40 A0  1 
   " device_type" get-property  if  exit  then
1A42864 	9C 53 A0  1 
1A42868 	 B 64 65 76 69 63 65 5F 
1A42870 	74 79 70 65  0  0  0  0 
1A42878 	F4  D A2  1 DC 41 A0  1 
1A42880 	 8  0  0  0 40 46 A0  1 
[ifdef] use-usb-debug-port
   \ I haven't figured out how to turn on the EHCI cleanly
   \ when the Debug Port is running
   dbgp-off
[then]
   get-encoded-string  " ehci" $=  if
1A42888 	24 F7 A1  1 9C 53 A0  1 
1A42890 	 4 65 68 63 69  0  0  0 
1A42898 	88 8D A0  1 DC 41 A0  1 
1A428A0 	1C  0  0  0 
      pwd$ open-dev  ?dup  if  close-dev  then
1A428A4 	F0 4D A2  1 
1A428A8 	FC 3E A2  1 B4 70 A0  1 
1A428B0 	DC 41 A0  1  8  0  0  0 
1A428B8 	5C 37 A2  1 
   then
;
1A428BC 	58 46 A0  1 
: (show-usb2)  ( -- )
1A428C0 	28 73 68 6F 77 2D 75 73 
1A428C8 	62 32 29 8B 60 28 A4  1 
1A428D0 	20 40 A0  1 
   " device_type" get-property  if  exit  then
1A428D4 	9C 53 A0  1 
1A428D8 	 B 64 65 76 69 63 65 5F 
1A428E0 	74 79 70 65  0  0  0  0 
1A428E8 	F4  D A2  1 DC 41 A0  1 
1A428F0 	 8  0  0  0 40 46 A0  1 
   get-encoded-string  " ehci" $=  if
1A428F8 	24 F7 A1  1 9C 53 A0  1 
1A42900 	 4 65 68 63 69  0  0  0 
1A42908 	88 8D A0  1 DC 41 A0  1 
1A42910 	 C  0  0  0 
      pwd$ $nopage-show-devs
1A42914 	F0 4D A2  1 
1A42918 	14 28 A4  1 
   then
;
1A4291C 	58 46 A0  1 
: (probe-usb1)  ( -- )
1A42920 	 0  0  0 28 70 72 6F 62 
1A42928 	65 2D 75 73 62 31 29 8C 
1A42930 	D0 28 A4  1 20 40 A0  1 
   " device_type" get-property  if  exit  then
1A42938 	9C 53 A0  1  B 64 65 76 
1A42940 	69 63 65 5F 74 79 70 65 
1A42948 	 0  0  0  0 F4  D A2  1 
1A42950 	DC 41 A0  1  8  0  0  0 
1A42958 	40 46 A0  1 
   get-encoded-string  2dup " uhci" $= >r  " ohci" $= r> or  if
1A4295C 	24 F7 A1  1 
1A42960 	C0 49 A0  1 9C 53 A0  1 
1A42968 	 4 75 68 63 69  0  0  0 
1A42970 	88 8D A0  1 BC 45 A0  1 
1A42978 	9C 53 A0  1  4 6F 68 63 
1A42980 	69  0  0  0 88 8D A0  1 
1A42988 	D0 45 A0  1 70 44 A0  1 
1A42990 	DC 41 A0  1 1C  0  0  0 
      pwd$ open-dev  ?dup  if  close-dev  then
1A42998 	F0 4D A2  1 FC 3E A2  1 
1A429A0 	B4 70 A0  1 DC 41 A0  1 
1A429A8 	 8  0  0  0 5C 37 A2  1 
   then
;
1A429B0 	58 46 A0  1 
: (show-usb1)  ( -- )
1A429B4 	28 73 68 6F 
1A429B8 	77 2D 75 73 62 31 29 8B 
1A429C0 	34 29 A4  1 20 40 A0  1 
   " device_type" get-property  if  exit  then
1A429C8 	9C 53 A0  1  B 64 65 76 
1A429D0 	69 63 65 5F 74 79 70 65 
1A429D8 	 0  0  0  0 F4  D A2  1 
1A429E0 	DC 41 A0  1  8  0  0  0 
1A429E8 	40 46 A0  1 
   get-encoded-string  2dup " uhci" $= >r  " ohci" $= r> or  if
1A429EC 	24 F7 A1  1 
1A429F0 	C0 49 A0  1 9C 53 A0  1 
1A429F8 	 4 75 68 63 69  0  0  0 
1A42A00 	88 8D A0  1 BC 45 A0  1 
1A42A08 	9C 53 A0  1  4 6F 68 63 
1A42A10 	69  0  0  0 88 8D A0  1 
1A42A18 	D0 45 A0  1 70 44 A0  1 
1A42A20 	DC 41 A0  1  C  0  0  0 
      pwd$ $nopage-show-devs
1A42A28 	F0 4D A2  1 14 28 A4  1 
   then
;
1A42A30 	58 46 A0  1 
: probe-usb  ( -- )
1A42A34 	 0  0 70 72 
1A42A38 	6F 62 65 2D 75 73 62 89 
1A42A40 	C4 29 A4  1 20 40 A0  1 
   ." USB2 devices:" cr
1A42A48 	20 7C A0  1  D 55 53 42 
1A42A50 	32 20 64 65 76 69 63 65 
1A42A58 	73 3A  0  0 80 6D A0  1 
   " /" ['] (probe-usb2) scan-subtree
1A42A60 	9C 53 A0  1  1 2F  0  0 
1A42A68 	60 53 A0  1 60 28 A4  1 
1A42A70 	70 5E A2  1 
   " /" ['] (show-usb2) scan-subtree
1A42A74 	9C 53 A0  1 
1A42A78 	 1 2F  0  0 60 53 A0  1 
1A42A80 	D0 28 A4  1 70 5E A2  1 
 exit
1A42A88 	40 46 A0  1 
   ." USB1 devices:" cr
1A42A8C 	20 7C A0  1 
1A42A90 	 D 55 53 42 31 20 64 65 
1A42A98 	76 69 63 65 73 3A  0  0 
1A42AA0 	80 6D A0  1 
   " /" ['] (probe-usb1) scan-subtree
1A42AA4 	9C 53 A0  1 
1A42AA8 	 1 2F  0  0 60 53 A0  1 
1A42AB0 	34 29 A4  1 70 5E A2  1 
   " /" ['] (show-usb1) scan-subtree
1A42AB8 	9C 53 A0  1  1 2F  0  0 
1A42AC0 	60 53 A0  1 C4 29 A4  1 
1A42AC8 	70 5E A2  1 
;
1A42ACC 	58 46 A0  1 
alias p2 probe-usb
1A42AD0 	 0 70 32 A2 44 2A A4  1 
1A42AD8 	44 2A A4  1 

: ?usb-keyboard  ( -- )
1A42ADC 	 0  0 3F 75 
1A42AE0 	73 62 2D 6B 65 79 62 6F 
1A42AE8 	61 72 64 8D D8 2A A4  1 
1A42AF0 	20 40 A0  1 
   " keyboard" expand-alias  if   ( devspec$ )
1A42AF4 	9C 53 A0  1 
1A42AF8 	 8 6B 65 79 62 6F 61 72 
1A42B00 	64  0  0  0 40 1E A2  1 
1A42B08 	DC 41 A0  1 64  0  0  0 
      drop " /usb"  comp  0=  if  ( )
1A42B10 	30 49 A0  1 9C 53 A0  1 
1A42B18 	 4 2F 75 73 62  0  0  0 
1A42B20 	38 52 A0  1 24 47 A0  1 
1A42B28 	DC 41 A0  1 44  0  0  0 
         red-letters  ." Using USB keyboard." cr  cancel
1A42B30 	A4 F9 A0  1 20 7C A0  1 
1A42B38 	13 55 73 69 6E 67 20 55 
1A42B40 	53 42 20 6B 65 79 62 6F 
1A42B48 	61 72 64 2E  0  0  0  0 
1A42B50 	80 6D A0  1 BC F7 A0  1 
         " keyboard" input
1A42B58 	9C 53 A0  1  8 6B 65 79 
1A42B60 	62 6F 61 72 64  0  0  0 
1A42B68 	3C 59 A2  1 
         exit
1A42B6C 	40 46 A0  1 
      then
   then
   " /usb/serial" open-dev  ?dup  if
1A42B70 	9C 53 A0  1  B 2F 75 73 
1A42B78 	62 2F 73 65 72 69 61 6C 
1A42B80 	 0  0  0  0 FC 3E A2  1 
1A42B88 	B4 70 A0  1 DC 41 A0  1 
1A42B90 	3C  0  0  0 
      red-letters  ." Using USB serial console." cr  cancel
1A42B94 	A4 F9 A0  1 
1A42B98 	20 7C A0  1 19 55 73 69 
1A42BA0 	6E 67 20 55 53 42 20 73 
1A42BA8 	65 72 69 61 6C 20 63 6F 
1A42BB0 	6E 73 6F 6C 65 2E  0  0 
1A42BB8 	80 6D A0  1 BC F7 A0  1 
      dup set-stdin set-stdout
1A42BC0 	40 49 A0  1 AC 58 A2  1 
1A42BC8 	 4 5B A2  1 
   then
;
1A42BCC 	58 46 A0  1 

\ Unlink every node whose phys.hi component matches port
: port-match?  ( port -- flag )
1A42BD0 	70 6F 72 74 2D 6D 61 74 
1A42BD8 	63 68 3F 8B F0 2A A4  1 
1A42BE0 	20 40 A0  1 
   get-unit  if  drop false exit  then
1A42BE4 	90 15 A2  1 
1A42BE8 	DC 41 A0  1 10  0  0  0 
1A42BF0 	30 49 A0  1 18 70 A0  1 
1A42BF8 	40 46 A0  1 
   get-encoded-int =
1A42BFC 	A0 F7 A1  1 
1A42C00 	24 48 A0  1 
;
1A42C04 	58 46 A0  1 

OpenFirmware/cpu/x86/pc/biosload/usb.fth_AL	43C 1A42C08 purpose: USB error codes for use by USB device drivers

headers
hex

\ Common error codes so that device drivers are EHCI/OHCI/UHCI independent

00000000 constant USB_ERR_NONE
1A42C08 	 0  0  0 75 73 62 5F 65 
1A42C10 	72 72 5F 6E 6F 6E 65 8C 
1A42C18 	E0 2B A4  1 68 40 A0  1 
1A42C20 	 0  0  0  0 
00000001 constant USB_ERR_CRC
1A42C24 	75 73 62 5F 
1A42C28 	65 72 72 5F 63 72 63 8B 
1A42C30 	1C 2C A4  1 68 40 A0  1 
1A42C38 	 1  0  0  0 
00000002 constant USB_ERR_BITSTUFFING
1A42C3C 	75 73 62 5F 
1A42C40 	65 72 72 5F 62 69 74 73 
1A42C48 	74 75 66 66 69 6E 67 93 
1A42C50 	34 2C A4  1 68 40 A0  1 
1A42C58 	 2  0  0  0 
00000004 constant USB_ERR_DATATOGGLEMISMATCH
1A42C5C 	 0 75 73 62 
1A42C60 	5F 65 72 72 5F 64 61 74 
1A42C68 	61 74 6F 67 67 6C 65 6D 
1A42C70 	69 73 6D 61 74 63 68 9A 
1A42C78 	54 2C A4  1 68 40 A0  1 
1A42C80 	 4  0  0  0 
00000008 constant USB_ERR_STALL
1A42C84 	 0  0 75 73 
1A42C88 	62 5F 65 72 72 5F 73 74 
1A42C90 	61 6C 6C 8D 7C 2C A4  1 
1A42C98 	68 40 A0  1  8  0  0  0 
00000010 constant USB_ERR_DEVICENOTRESPONDING
1A42CA0 	75 73 62 5F 65 72 72 5F 
1A42CA8 	64 65 76 69 63 65 6E 6F 
1A42CB0 	74 72 65 73 70 6F 6E 64 
1A42CB8 	69 6E 67 9B 98 2C A4  1 
1A42CC0 	68 40 A0  1 10  0  0  0 
00000020 constant USB_ERR_PIDCHECKFAILURE
1A42CC8 	75 73 62 5F 65 72 72 5F 
1A42CD0 	70 69 64 63 68 65 63 6B 
1A42CD8 	66 61 69 6C 75 72 65 97 
1A42CE0 	C0 2C A4  1 68 40 A0  1 
1A42CE8 	20  0  0  0 
00000040 constant USB_ERR_UNEXPECTEDPIC
1A42CEC 	 0  0 75 73 
1A42CF0 	62 5F 65 72 72 5F 75 6E 
1A42CF8 	65 78 70 65 63 74 65 64 
1A42D00 	70 69 63 95 E4 2C A4  1 
1A42D08 	68 40 A0  1 40  0  0  0 
00000080 constant USB_ERR_DATAOVERRUN
1A42D10 	75 73 62 5F 65 72 72 5F 
1A42D18 	64 61 74 61 6F 76 65 72 
1A42D20 	72 75 6E 93  8 2D A4  1 
1A42D28 	68 40 A0  1 80  0  0  0 
00000100 constant USB_ERR_DATAUNDERRUN
1A42D30 	 0  0  0 75 73 62 5F 65 
1A42D38 	72 72 5F 64 61 74 61 75 
1A42D40 	6E 64 65 72 72 75 6E 94 
1A42D48 	28 2D A4  1 68 40 A0  1 
1A42D50 	 0  1  0  0 
00000200 constant USB_ERR_BUFFEROVERRUN
1A42D54 	 0  0 75 73 
1A42D58 	62 5F 65 72 72 5F 62 75 
1A42D60 	66 66 65 72 6F 76 65 72 
1A42D68 	72 75 6E 95 4C 2D A4  1 
1A42D70 	68 40 A0  1  0  2  0  0 
00000400 constant USB_ERR_BUFFERUNDERRUN
1A42D78 	 0 75 73 62 5F 65 72 72 
1A42D80 	5F 62 75 66 66 65 72 75 
1A42D88 	6E 64 65 72 72 75 6E 96 
1A42D90 	70 2D A4  1 68 40 A0  1 
1A42D98 	 0  4  0  0 
00000800 constant USB_ERR_NOTACCESSED
1A42D9C 	75 73 62 5F 
1A42DA0 	65 72 72 5F 6E 6F 74 61 
1A42DA8 	63 63 65 73 73 65 64 93 
1A42DB0 	94 2D A4  1 68 40 A0  1 
1A42DB8 	 0  8  0  0 
00001000 constant USB_ERR_HCHALTED
1A42DBC 	 0  0  0 75 
1A42DC0 	73 62 5F 65 72 72 5F 68 
1A42DC8 	63 68 61 6C 74 65 64 90 
1A42DD0 	B4 2D A4  1 68 40 A0  1 
1A42DD8 	 0 10  0  0 
00002000 constant USB_ERR_DBUFERR
1A42DDC 	75 73 62 5F 
1A42DE0 	65 72 72 5F 64 62 75 66 
1A42DE8 	65 72 72 8F D4 2D A4  1 
1A42DF0 	68 40 A0  1  0 20  0  0 
00004000 constant USB_ERR_BABBLE
1A42DF8 	 0 75 73 62 5F 65 72 72 
1A42E00 	5F 62 61 62 62 6C 65 8E 
1A42E08 	F0 2D A4  1 68 40 A0  1 
1A42E10 	 0 40  0  0 
00008000 constant USB_ERR_NAK
1A42E14 	75 73 62 5F 
1A42E18 	65 72 72 5F 6E 61 6B 8B 
1A42E20 	 C 2E A4  1 68 40 A0  1 
1A42E28 	 0 80  0  0 
00010000 constant USB_ERR_MICRO_FRAME
1A42E2C 	75 73 62 5F 
1A42E30 	65 72 72 5F 6D 69 63 72 
1A42E38 	6F 5F 66 72 61 6D 65 93 
1A42E40 	24 2E A4  1 68 40 A0  1 
1A42E48 	 0  0  1  0 
00020000 constant USB_ERR_SPLIT
1A42E4C 	 0  0 75 73 
1A42E50 	62 5F 65 72 72 5F 73 70 
1A42E58 	6C 69 74 8D 44 2E A4  1 
1A42E60 	68 40 A0  1  0  0  2  0 
00040000 constant USB_ERR_HCERROR
1A42E68 	75 73 62 5F 65 72 72 5F 
1A42E70 	68 63 65 72 72 6F 72 8F 
1A42E78 	60 2E A4  1 68 40 A0  1 
1A42E80 	 0  0  4  0 
00080000 constant USB_ERR_HOSTERROR
1A42E84 	 0  0 75 73 
1A42E88 	62 5F 65 72 72 5F 68 6F 
1A42E90 	73 74 65 72 72 6F 72 91 
1A42E98 	7C 2E A4  1 68 40 A0  1 
1A42EA0 	 0  0  8  0 
10000000 constant USB_ERR_TIMEOUT
1A42EA4 	75 73 62 5F 
1A42EA8 	65 72 72 5F 74 69 6D 65 
1A42EB0 	6F 75 74 8F 9C 2E A4  1 
1A42EB8 	68 40 A0  1  0  0  0 10 
20000000 constant USB_ERR_INV_OP
1A42EC0 	 0 75 73 62 5F 65 72 72 
1A42EC8 	5F 69 6E 76 5F 6F 70 8E 
1A42ED0 	B8 2E A4  1 68 40 A0  1 
1A42ED8 	 0  0  0 20 
40000000 constant USB_ERR_BAD_PARAM
1A42EDC 	 0  0 75 73 
1A42EE0 	62 5F 65 72 72 5F 62 61 
1A42EE8 	64 5F 70 61 72 61 6D 91 
1A42EF0 	D4 2E A4  1 68 40 A0  1 
1A42EF8 	 0  0  0 40 
80000000 constant USB_ERR_UNKNOWN
1A42EFC 	75 73 62 5F 
1A42F00 	65 72 72 5F 75 6E 6B 6E 
1A42F08 	6F 77 6E 8F F4 2E A4  1 
1A42F10 	68 40 A0  1  0  0  0 80 


OpenFirmware/dev/usb2/error.fth_AL	310 1A42F18 purpose: USB Data Packet Definitions

hex
headers

d# 128 constant #max-dev
1A42F18 	 0  0  0 23 6D 61 78 2D 
1A42F20 	64 65 76 88 10 2F A4  1 
1A42F28 	68 40 A0  1 80  0  0  0 
d#  16 constant #max-endpoint
1A42F30 	 0  0 23 6D 61 78 2D 65 
1A42F38 	6E 64 70 6F 69 6E 74 8D 
1A42F40 	28 2F A4  1 68 40 A0  1 
1A42F48 	10  0  0  0 

0 constant speed-full
1A42F4C 	 0 73 70 65 
1A42F50 	65 64 2D 66 75 6C 6C 8A 
1A42F58 	44 2F A4  1 68 40 A0  1 
1A42F60 	 0  0  0  0 
1 constant speed-low
1A42F64 	 0  0 73 70 
1A42F68 	65 65 64 2D 6C 6F 77 89 
1A42F70 	5C 2F A4  1 68 40 A0  1 
1A42F78 	 1  0  0  0 
2 constant speed-high
1A42F7C 	 0 73 70 65 
1A42F80 	65 64 2D 68 69 67 68 8A 
1A42F88 	74 2F A4  1 68 40 A0  1 
1A42F90 	 2  0  0  0 

    8 constant /pipe0
1A42F94 	 0 2F 70 69 
1A42F98 	70 65 30 86 8C 2F A4  1 
1A42FA0 	68 40 A0  1  8  0  0  0 
10000 constant /cfg
1A42FA8 	 0  0  0 2F 63 66 67 84 
1A42FB0 	A0 2F A4  1 68 40 A0  1 
1A42FB8 	 0  0  1  0 
  100 constant /str
1A42FBC 	 0  0  0 2F 
1A42FC0 	73 74 72 84 B4 2F A4  1 
1A42FC8 	68 40 A0  1  0  1  0  0 

\ Structure of devices requests as defined in USB spec.
struct  ( standard device requests )
1 field >dr-rtype			\ bmRequestType
1A42FD0 	 0  0 3E 64 72 2D 72 74 
1A42FD8 	79 70 65 89 C8 2F A4  1 
1A42FE0 	50 EE A0  1  0  0  0  0 
1 field >dr-request			\ bRequest
1A42FE8 	3E 64 72 2D 72 65 71 75 
1A42FF0 	65 73 74 8B E0 2F A4  1 
1A42FF8 	50 EE A0  1  1  0  0  0 
2 field >dr-value			\ wValue
1A43000 	 0  0 3E 64 72 2D 76 61 
1A43008 	6C 75 65 89 F8 2F A4  1 
1A43010 	50 EE A0  1  2  0  0  0 
2 field >dr-index			\ wIndex
1A43018 	 0  0 3E 64 72 2D 69 6E 
1A43020 	64 65 78 89 10 30 A4  1 
1A43028 	50 EE A0  1  4  0  0  0 
2 field >dr-len				\ wLength
1A43030 	3E 64 72 2D 6C 65 6E 87 
1A43038 	28 30 A4  1 50 EE A0  1 
1A43040 	 6  0  0  0 
					\ Data
constant /dr
1A43044 	2F 64 72 83 
1A43048 	3C 30 A4  1 68 40 A0  1 
1A43050 	 8  0  0  0 

\ >dr-type constants
00 constant DR_OUT
1A43054 	 0 64 72 5F 
1A43058 	6F 75 74 86 4C 30 A4  1 
1A43060 	68 40 A0  1  0  0  0  0 
80 constant DR_IN
1A43068 	 0  0 64 72 5F 69 6E 85 
1A43070 	60 30 A4  1 68 40 A0  1 
1A43078 	80  0  0  0 
00 constant DR_STANDARD
1A4307C 	64 72 5F 73 
1A43080 	74 61 6E 64 61 72 64 8B 
1A43088 	74 30 A4  1 68 40 A0  1 
1A43090 	 0  0  0  0 
20 constant DR_CLASS
1A43094 	 0  0  0 64 
1A43098 	72 5F 63 6C 61 73 73 88 
1A430A0 	8C 30 A4  1 68 40 A0  1 
1A430A8 	20  0  0  0 
40 constant DR_VENDOR
1A430AC 	 0  0 64 72 
1A430B0 	5F 76 65 6E 64 6F 72 89 
1A430B8 	A4 30 A4  1 68 40 A0  1 
1A430C0 	40  0  0  0 
00 constant DR_DEVICE
1A430C4 	 0  0 64 72 
1A430C8 	5F 64 65 76 69 63 65 89 
1A430D0 	BC 30 A4  1 68 40 A0  1 
1A430D8 	 0  0  0  0 
01 constant DR_INTERFACE
1A430DC 	 0  0  0 64 
1A430E0 	72 5F 69 6E 74 65 72 66 
1A430E8 	61 63 65 8C D4 30 A4  1 
1A430F0 	68 40 A0  1  1  0  0  0 
02 constant DR_ENDPOINT
1A430F8 	64 72 5F 65 6E 64 70 6F 
1A43100 	69 6E 74 8B F0 30 A4  1 
1A43108 	68 40 A0  1  2  0  0  0 
03 constant DR_OTHERS
1A43110 	 0  0 64 72 5F 6F 74 68 
1A43118 	65 72 73 89  8 31 A4  1 
1A43120 	68 40 A0  1  3  0  0  0 
DR_CLASS DR_DEVICE    or constant DR_HUB
1A43128 	 0 64 72 5F 68 75 62 86 
1A43130 	20 31 A4  1 68 40 A0  1 
1A43138 	20  0  0  0 
DR_CLASS DR_OTHERS    or constant DR_PORT
1A4313C 	64 72 5F 70 
1A43140 	6F 72 74 87 34 31 A4  1 
1A43148 	68 40 A0  1 23  0  0  0 
DR_CLASS DR_INTERFACE or constant DR_HIDD
1A43150 	64 72 5F 68 69 64 64 87 
1A43158 	48 31 A4  1 68 40 A0  1 
1A43160 	21  0  0  0 

\ >dr-request constants
01 constant CLEAR_FEATURE
1A43164 	 0  0 63 6C 
1A43168 	65 61 72 5F 66 65 61 74 
1A43170 	75 72 65 8D 5C 31 A4  1 
1A43178 	68 40 A0  1  1  0  0  0 
08 constant GET_CONFIGURATION
1A43180 	 0  0 67 65 74 5F 63 6F 
1A43188 	6E 66 69 67 75 72 61 74 
1A43190 	69 6F 6E 91 78 31 A4  1 
1A43198 	68 40 A0  1  8  0  0  0 
06 constant GET_DESCRIPTOR
1A431A0 	 0 67 65 74 5F 64 65 73 
1A431A8 	63 72 69 70 74 6F 72 8E 
1A431B0 	98 31 A4  1 68 40 A0  1 
1A431B8 	 6  0  0  0 
0a constant GET_INTERFACE
1A431BC 	 0  0 67 65 
1A431C0 	74 5F 69 6E 74 65 72 66 
1A431C8 	61 63 65 8D B4 31 A4  1 
1A431D0 	68 40 A0  1  A  0  0  0 
02 constant GET_STATE
1A431D8 	 0  0 67 65 74 5F 73 74 
1A431E0 	61 74 65 89 D0 31 A4  1 
1A431E8 	68 40 A0  1  2  0  0  0 
00 constant GET_STATUS
1A431F0 	 0 67 65 74 5F 73 74 61 
1A431F8 	74 75 73 8A E8 31 A4  1 
1A43200 	68 40 A0  1  0  0  0  0 
05 constant SET_ADDRESS
1A43208 	73 65 74 5F 61 64 64 72 
1A43210 	65 73 73 8B  0 32 A4  1 
1A43218 	68 40 A0  1  5  0  0  0 
09 constant SET_CONFIGURATION
1A43220 	 0  0 73 65 74 5F 63 6F 
1A43228 	6E 66 69 67 75 72 61 74 
1A43230 	69 6F 6E 91 18 32 A4  1 
1A43238 	68 40 A0  1  9  0  0  0 
07 constant SET_DESCRIPTOR
1A43240 	 0 73 65 74 5F 64 65 73 
1A43248 	63 72 69 70 74 6F 72 8E 
1A43250 	38 32 A4  1 68 40 A0  1 
1A43258 	 7  0  0  0 
03 constant SET_FEATURE
1A4325C 	73 65 74 5F 
1A43260 	66 65 61 74 75 72 65 8B 
1A43268 	54 32 A4  1 68 40 A0  1 
1A43270 	 3  0  0  0 
0b constant SET_INTERFACE
1A43274 	 0  0 73 65 
1A43278 	74 5F 69 6E 74 65 72 66 
1A43280 	61 63 65 8D 6C 32 A4  1 
1A43288 	68 40 A0  1  B  0  0  0 
0c constant SYNCH_FRAME
1A43290 	73 79 6E 63 68 5F 66 72 
1A43298 	61 6D 65 8B 88 32 A4  1 
1A432A0 	68 40 A0  1  C  0  0  0 

\ >dr-value (upper byte) for get-/set-descriptor constants
\ lower-byte is descriptor index
01 constant DEVICE
1A432A8 	 0 64 65 76 69 63 65 86 
1A432B0 	A0 32 A4  1 68 40 A0  1 
1A432B8 	 1  0  0  0 
02 constant CONFIGURATION
1A432BC 	 0  0 63 6F 
1A432C0 	6E 66 69 67 75 72 61 74 
1A432C8 	69 6F 6E 8D B4 32 A4  1 
1A432D0 	68 40 A0  1  2  0  0  0 
03 constant STRING
1A432D8 	 0 73 74 72 69 6E 67 86 
1A432E0 	D0 32 A4  1 68 40 A0  1 
1A432E8 	 3  0  0  0 
04 constant INTERFACE
1A432EC 	 0  0 69 6E 
1A432F0 	74 65 72 66 61 63 65 89 
1A432F8 	E4 32 A4  1 68 40 A0  1 
1A43300 	 4  0  0  0 
05 constant ENDPOINT
1A43304 	 0  0  0 65 
1A43308 	6E 64 70 6F 69 6E 74 88 
1A43310 	FC 32 A4  1 68 40 A0  1 
1A43318 	 5  0  0  0 
0b constant INTERFACE_ASSO
1A4331C 	 0 69 6E 74 
1A43320 	65 72 66 61 63 65 5F 61 
1A43328 	73 73 6F 8E 14 33 A4  1 
1A43330 	68 40 A0  1  B  0  0  0 
29 constant HUB
1A43338 	68 75 62 83 30 33 A4  1 
1A43340 	68 40 A0  1 29  0  0  0 

\ Hub Class Feature Selectors (dr-value)
00 constant C_HUB_LOCAL_POWER
1A43348 	 0  0 63 5F 68 75 62 5F 
1A43350 	6C 6F 63 61 6C 5F 70 6F 
1A43358 	77 65 72 91 40 33 A4  1 
1A43360 	68 40 A0  1  0  0  0  0 
01 constant C_HUB_OVER_CURRENT
1A43368 	 0 63 5F 68 75 62 5F 6F 
1A43370 	76 65 72 5F 63 75 72 72 
1A43378 	65 6E 74 92 60 33 A4  1 
1A43380 	68 40 A0  1  1  0  0  0 
00 constant PORT_CONNECTION
1A43388 	70 6F 72 74 5F 63 6F 6E 
1A43390 	6E 65 63 74 69 6F 6E 8F 
1A43398 	80 33 A4  1 68 40 A0  1 
1A433A0 	 0  0  0  0 
01 constant PORT_ENABLE
1A433A4 	70 6F 72 74 
1A433A8 	5F 65 6E 61 62 6C 65 8B 
1A433B0 	9C 33 A4  1 68 40 A0  1 
1A433B8 	 1  0  0  0 
02 constant PORT_SUSPEND
1A433BC 	 0  0  0 70 
1A433C0 	6F 72 74 5F 73 75 73 70 
1A433C8 	65 6E 64 8C B4 33 A4  1 
1A433D0 	68 40 A0  1  2  0  0  0 
03 constant PORT_OVER_CURRENT
1A433D8 	 0  0 70 6F 72 74 5F 6F 
1A433E0 	76 65 72 5F 63 75 72 72 
1A433E8 	65 6E 74 91 D0 33 A4  1 
1A433F0 	68 40 A0  1  3  0  0  0 
04 constant PORT_RESET
1A433F8 	 0 70 6F 72 74 5F 72 65 
1A43400 	73 65 74 8A F0 33 A4  1 
1A43408 	68 40 A0  1  4  0  0  0 
08 constant PORT_POWER
1A43410 	 0 70 6F 72 74 5F 70 6F 
1A43418 	77 65 72 8A  8 34 A4  1 
1A43420 	68 40 A0  1  8  0  0  0 
09 constant PORT_LOW_SPEED
1A43428 	 0 70 6F 72 74 5F 6C 6F 
1A43430 	77 5F 73 70 65 65 64 8E 
1A43438 	20 34 A4  1 68 40 A0  1 
1A43440 	 9  0  0  0 
d# 16 constant C_PORT_CONNECTION
1A43444 	 0  0 63 5F 
1A43448 	70 6F 72 74 5F 63 6F 6E 
1A43450 	6E 65 63 74 69 6F 6E 91 
1A43458 	3C 34 A4  1 68 40 A0  1 
1A43460 	10  0  0  0 
d# 17 constant C_PORT_ENABLE
1A43464 	 0  0 63 5F 
1A43468 	70 6F 72 74 5F 65 6E 61 
1A43470 	62 6C 65 8D 5C 34 A4  1 
1A43478 	68 40 A0  1 11  0  0  0 
d# 18 constant C_PORT_SUSPEND
1A43480 	 0 63 5F 70 6F 72 74 5F 
1A43488 	73 75 73 70 65 6E 64 8E 
1A43490 	78 34 A4  1 68 40 A0  1 
1A43498 	12  0  0  0 
d# 19 constant C_PORT_OVER_CURRENT
1A4349C 	63 5F 70 6F 
1A434A0 	72 74 5F 6F 76 65 72 5F 
1A434A8 	63 75 72 72 65 6E 74 93 
1A434B0 	94 34 A4  1 68 40 A0  1 
1A434B8 	13  0  0  0 
d# 20 constant C_PORT_RESET
1A434BC 	 0  0  0 63 
1A434C0 	5F 70 6F 72 74 5F 72 65 
1A434C8 	73 65 74 8C B4 34 A4  1 
1A434D0 	68 40 A0  1 14  0  0  0 
d# 21 constant PORT_TEST
1A434D8 	 0  0 70 6F 72 74 5F 74 
1A434E0 	65 73 74 89 D0 34 A4  1 
1A434E8 	68 40 A0  1 15  0  0  0 
d# 22 constant PORT_INDICATOR
1A434F0 	 0 70 6F 72 74 5F 69 6E 
1A434F8 	64 69 63 61 74 6F 72 8E 
1A43500 	E8 34 A4  1 68 40 A0  1 
1A43508 	16  0  0  0 

\ Use tmp-l to make sure that le-l! and le-w! are atomic writes

variable tmp-l
1A4350C 	 0  0 74 6D 
1A43510 	70 2D 6C 85  4 35 A4  1 
1A43518 	48 40 A0  1 C0  D  0  0 
: le-w@   ( a -- w )   dup c@ swap ca1+ c@ bwjoin  ;
1A43520 	 0  0 6C 65 2D 77 40 85 
1A43528 	18 35 A4  1 20 40 A0  1 
1A43530 	40 49 A0  1 C4 4C A0  1 
1A43538 	68 49 A0  1 78 50 A0  1 
1A43540 	C4 4C A0  1 84 FB A0  1 
1A43548 	58 46 A0  1 
: (le-w!) ( w a -- )   >r  wbsplit r@ ca1+ c! r> c!  ;
1A4354C 	28 6C 65 2D 
1A43550 	77 21 29 87 2C 35 A4  1 
1A43558 	20 40 A0  1 BC 45 A0  1 
1A43560 	54 FB A0  1 E4 45 A0  1 
1A43568 	78 50 A0  1 B8 4D A0  1 
1A43570 	D0 45 A0  1 B8 4D A0  1 
1A43578 	58 46 A0  1 
: le-w!   ( w a -- )   swap tmp-l (le-w!) tmp-l w@ swap w!  ;
1A4357C 	 0  0 6C 65 
1A43580 	2D 77 21 85 58 35 A4  1 
1A43588 	20 40 A0  1 68 49 A0  1 
1A43590 	18 35 A4  1 58 35 A4  1 
1A43598 	18 35 A4  1 94 4C A0  1 
1A435A0 	68 49 A0  1 A4 4D A0  1 
1A435A8 	58 46 A0  1 

: le-l@   ( a -- l )   >r  r@ c@  r@ 1+ c@  r@ 2+ c@  r> 3 + c@  bljoin  ;
1A435AC 	 0  0 6C 65 
1A435B0 	2D 6C 40 85 88 35 A4  1 
1A435B8 	20 40 A0  1 BC 45 A0  1 
1A435C0 	E4 45 A0  1 C4 4C A0  1 
1A435C8 	E4 45 A0  1 30 4B A0  1 
1A435D0 	C4 4C A0  1 E4 45 A0  1 
1A435D8 	40 4B A0  1 C4 4C A0  1 
1A435E0 	D0 45 A0  1 A0 6F A0  1 
1A435E8 	 4 45 A0  1 C4 4C A0  1 
1A435F0 	DC FB A0  1 58 46 A0  1 
: (le-l!) ( l a -- )   >r lbsplit  r@ 3 + c!  r@ 2+ c!  r@ 1+ c!  r> c!  ;
1A435F8 	28 6C 65 2D 6C 21 29 87 
1A43600 	B8 35 A4  1 20 40 A0  1 
1A43608 	BC 45 A0  1 B4 FB A0  1 
1A43610 	E4 45 A0  1 A0 6F A0  1 
1A43618 	 4 45 A0  1 B8 4D A0  1 
1A43620 	E4 45 A0  1 40 4B A0  1 
1A43628 	B8 4D A0  1 E4 45 A0  1 
1A43630 	30 4B A0  1 B8 4D A0  1 
1A43638 	D0 45 A0  1 B8 4D A0  1 
1A43640 	58 46 A0  1 
: le-l!   ( l a -- )   swap tmp-l (le-l!) tmp-l l@ swap l!  ;
1A43644 	 0  0 6C 65 
1A43648 	2D 6C 21 85  4 36 A4  1 
1A43650 	20 40 A0  1 68 49 A0  1 
1A43658 	18 35 A4  1  4 36 A4  1 
1A43660 	18 35 A4  1 6C 4C A0  1 
1A43668 	68 49 A0  1 7C 4D A0  1 
1A43670 	58 46 A0  1 


headers


OpenFirmware/dev/usb2/pkt-data.fth_AL	75C 1A43674 purpose: Aligned dma aligned alloc and free

hex
headers

d# 256 constant /align256
1A43674 	 0  0 2F 61 
1A43678 	6C 69 67 6E 32 35 36 89 
1A43680 	50 36 A4  1 68 40 A0  1 
1A43688 	 0  1  0  0 
d#  16 constant /align16
1A4368C 	 0  0  0 2F 
1A43690 	61 6C 69 67 6E 31 36 88 
1A43698 	84 36 A4  1 68 40 A0  1 
1A436A0 	10  0  0  0 
d#  32 constant /align32
1A436A4 	 0  0  0 2F 
1A436A8 	61 6C 69 67 6E 33 32 88 
1A436B0 	9C 36 A4  1 68 40 A0  1 
1A436B8 	20  0  0  0 

: round-up  ( n align -- n' )  1- tuck + swap invert and  ;
1A436BC 	 0  0  0 72 
1A436C0 	6F 75 6E 64 2D 75 70 88 
1A436C8 	B4 36 A4  1 20 40 A0  1 
1A436D0 	54 4B A0  1 E8 46 A0  1 
1A436D8 	 4 45 A0  1 68 49 A0  1 
1A436E0 	30 45 A0  1 5C 44 A0  1 
1A436E8 	58 46 A0  1 

external
: dma-push     ( virt phys size -- )         " dma-push" $call-parent     ;
1A436EC 	 0  0  0 64 
1A436F0 	6D 61 2D 70 75 73 68 88 
1A436F8 	CC 36 A4  1 20 40 A0  1 
1A43700 	9C 53 A0  1  8 64 6D 61 
1A43708 	2D 70 75 73 68  0  0  0 
1A43710 	DC 31 A2  1 58 46 A0  1 
: dma-pull     ( virt phys size -- )         " dma-pull" $call-parent     ;
1A43718 	 0  0  0 64 6D 61 2D 70 
1A43720 	75 6C 6C 88 FC 36 A4  1 
1A43728 	20 40 A0  1 9C 53 A0  1 
1A43730 	 8 64 6D 61 2D 70 75 6C 
1A43738 	6C  0  0  0 DC 31 A2  1 
1A43740 	58 46 A0  1 
: dma-alloc    ( size -- virt )              " dma-alloc" $call-parent    ;
1A43744 	 0  0 64 6D 
1A43748 	61 2D 61 6C 6C 6F 63 89 
1A43750 	28 37 A4  1 20 40 A0  1 
1A43758 	9C 53 A0  1  9 64 6D 61 
1A43760 	2D 61 6C 6C 6F 63  0  0 
1A43768 	DC 31 A2  1 58 46 A0  1 
: dma-free     ( virt size -- )              " dma-free" $call-parent     ;
1A43770 	 0  0  0 64 6D 61 2D 66 
1A43778 	72 65 65 88 54 37 A4  1 
1A43780 	20 40 A0  1 9C 53 A0  1 
1A43788 	 8 64 6D 61 2D 66 72 65 
1A43790 	65  0  0  0 DC 31 A2  1 
1A43798 	58 46 A0  1 
: dma-map-in   ( virt size cache? -- phys )  " dma-map-in" $call-parent   ;
1A4379C 	 0 64 6D 61 
1A437A0 	2D 6D 61 70 2D 69 6E 8A 
1A437A8 	80 37 A4  1 20 40 A0  1 
1A437B0 	9C 53 A0  1  A 64 6D 61 
1A437B8 	2D 6D 61 70 2D 69 6E  0 
1A437C0 	DC 31 A2  1 58 46 A0  1 
: dma-map-out  ( virt phys size -- )         " dma-map-out" $call-parent  ;
1A437C8 	64 6D 61 2D 6D 61 70 2D 
1A437D0 	6F 75 74 8B AC 37 A4  1 
1A437D8 	20 40 A0  1 9C 53 A0  1 
1A437E0 	 B 64 6D 61 2D 6D 61 70 
1A437E8 	2D 6F 75 74  0  0  0  0 
1A437F0 	DC 31 A2  1 58 46 A0  1 

headers

: aligned-alloc  ( size align -- unaligned-virt aligned-virtual )
1A437F8 	 0  0 61 6C 69 67 6E 65 
1A43800 	64 2D 61 6C 6C 6F 63 8D 
1A43808 	D8 37 A4  1 20 40 A0  1 
   dup >r + dma-alloc  dup r> round-up
1A43810 	40 49 A0  1 BC 45 A0  1 
1A43818 	 4 45 A0  1 54 37 A4  1 
1A43820 	40 49 A0  1 D0 45 A0  1 
1A43828 	CC 36 A4  1 
;
1A4382C 	58 46 A0  1 
: aligned-free  ( virtual size align -- )  + dma-free  ;
1A43830 	 0  0  0 61 6C 69 67 6E 
1A43838 	65 64 2D 66 72 65 65 8C 
1A43840 	 C 38 A4  1 20 40 A0  1 
1A43848 	 4 45 A0  1 80 37 A4  1 
1A43850 	58 46 A0  1 

: aligned16-alloc  ( size -- unaligned-virt aligned-virtual )
1A43854 	61 6C 69 67 
1A43858 	6E 65 64 31 36 2D 61 6C 
1A43860 	6C 6F 63 8F 44 38 A4  1 
1A43868 	20 40 A0  1 
   /align16 aligned-alloc
1A4386C 	9C 36 A4  1 
1A43870 	 C 38 A4  1 
;
1A43874 	58 46 A0  1 
: aligned16-free  ( virtual size -- )
1A43878 	 0 61 6C 69 67 6E 65 64 
1A43880 	31 36 2D 66 72 65 65 8E 
1A43888 	68 38 A4  1 20 40 A0  1 
   /align16 aligned-free
1A43890 	9C 36 A4  1 44 38 A4  1 
;
1A43898 	58 46 A0  1 

: aligned16-alloc-map-in  ( size -- unaligned-virt aligned-virt phys )
1A4389C 	 0 61 6C 69 
1A438A0 	67 6E 65 64 31 36 2D 61 
1A438A8 	6C 6C 6F 63 2D 6D 61 70 
1A438B0 	2D 69 6E 96 8C 38 A4  1 
1A438B8 	20 40 A0  1 
   dup >r aligned16-alloc
1A438BC 	40 49 A0  1 
1A438C0 	BC 45 A0  1 68 38 A4  1 
   dup r> true dma-map-in
1A438C8 	40 49 A0  1 D0 45 A0  1 
1A438D0 	 4 70 A0  1 AC 37 A4  1 
;
1A438D8 	58 46 A0  1 
: aligned16-free-map-out  ( unaligned virt phys size -- )
1A438DC 	 0 61 6C 69 
1A438E0 	67 6E 65 64 31 36 2D 66 
1A438E8 	72 65 65 2D 6D 61 70 2D 
1A438F0 	6F 75 74 96 B8 38 A4  1 
1A438F8 	20 40 A0  1 
   dup >r dma-map-out
1A438FC 	40 49 A0  1 
1A43900 	BC 45 A0  1 D8 37 A4  1 
   r> aligned16-free
1A43908 	D0 45 A0  1 8C 38 A4  1 
;
1A43910 	58 46 A0  1 

: aligned32-alloc  ( size -- unaligned-virt aligned-virtual )
1A43914 	61 6C 69 67 
1A43918 	6E 65 64 33 32 2D 61 6C 
1A43920 	6C 6F 63 8F F8 38 A4  1 
1A43928 	20 40 A0  1 
   /align32 aligned-alloc
1A4392C 	B4 36 A4  1 
1A43930 	 C 38 A4  1 
;
1A43934 	58 46 A0  1 
: aligned32-free  ( virtual size -- )
1A43938 	 0 61 6C 69 67 6E 65 64 
1A43940 	33 32 2D 66 72 65 65 8E 
1A43948 	28 39 A4  1 20 40 A0  1 
   /align32 aligned-free
1A43950 	B4 36 A4  1 44 38 A4  1 
;
1A43958 	58 46 A0  1 

: aligned32-alloc-map-in  ( size -- unaligned-virt aligned-virt phys )
1A4395C 	 0 61 6C 69 
1A43960 	67 6E 65 64 33 32 2D 61 
1A43968 	6C 6C 6F 63 2D 6D 61 70 
1A43970 	2D 69 6E 96 4C 39 A4  1 
1A43978 	20 40 A0  1 
   dup >r aligned32-alloc
1A4397C 	40 49 A0  1 
1A43980 	BC 45 A0  1 28 39 A4  1 
   dup r> true dma-map-in
1A43988 	40 49 A0  1 D0 45 A0  1 
1A43990 	 4 70 A0  1 AC 37 A4  1 
;
1A43998 	58 46 A0  1 
: aligned32-free-map-out  ( unaligned virt phys size -- )
1A4399C 	 0 61 6C 69 
1A439A0 	67 6E 65 64 33 32 2D 66 
1A439A8 	72 65 65 2D 6D 61 70 2D 
1A439B0 	6F 75 74 96 78 39 A4  1 
1A439B8 	20 40 A0  1 
   dup >r dma-map-out
1A439BC 	40 49 A0  1 
1A439C0 	BC 45 A0  1 D8 37 A4  1 
   r> aligned32-free
1A439C8 	D0 45 A0  1 4C 39 A4  1 
;
1A439D0 	58 46 A0  1 

: aligned256-alloc  ( size -- unaligned-virt aligned-virtual )
1A439D4 	 0  0  0 61 
1A439D8 	6C 69 67 6E 65 64 32 35 
1A439E0 	36 2D 61 6C 6C 6F 63 90 
1A439E8 	B8 39 A4  1 20 40 A0  1 
   /align256 aligned-alloc
1A439F0 	84 36 A4  1  C 38 A4  1 
;
1A439F8 	58 46 A0  1 
: aligned256-free  ( virtual size -- )
1A439FC 	61 6C 69 67 
1A43A00 	6E 65 64 32 35 36 2D 66 
1A43A08 	72 65 65 8F EC 39 A4  1 
1A43A10 	20 40 A0  1 
   /align256 aligned-free
1A43A14 	84 36 A4  1 
1A43A18 	44 38 A4  1 
;
1A43A1C 	58 46 A0  1 


OpenFirmware/dev/usb2/align.fth_AL	3AC 1A43A20 purpose: USB Data Packet Manipulation

hex
headers

\ XXX This code assumes the device and configuration descriptors are ok.

false value class-in-dev?
1A43A20 	 0  0 63 6C 61 73 73 2D 
1A43A28 	69 6E 2D 64 65 76 3F 8D 
1A43A30 	10 3A A4  1 50 40 A0  1 
1A43A38 	C4  D  0  0 

: find-desc  ( adr type -- adr' )
1A43A3C 	 0  0 66 69 
1A43A40 	6E 64 2D 64 65 73 63 89 
1A43A48 	34 3A A4  1 20 40 A0  1 
   swap  begin  ?dup  while		( type adr )
1A43A50 	68 49 A0  1 B4 70 A0  1 
1A43A58 	DC 41 A0  1 44  0  0  0 
      dup 1+ c@ 2 pick =  if  0  else  dup c@ +  then
1A43A60 	40 49 A0  1 30 4B A0  1 
1A43A68 	C4 4C A0  1 90 6F A0  1 
1A43A70 	 C 4A A0  1 24 48 A0  1 
1A43A78 	DC 41 A0  1 10  0  0  0 
1A43A80 	70 6F A0  1 C8 41 A0  1 
1A43A88 	10  0  0  0 40 49 A0  1 
1A43A90 	C4 4C A0  1  4 45 A0  1 
					( type adr' )
   repeat  nip				( adr )
1A43A98 	C8 41 A0  1 B8 FF FF FF 
1A43AA0 	FC 46 A0  1 
;
1A43AA4 	58 46 A0  1 

: find-intf-desc  ( adr intfidx -- adr )
1A43AA8 	 0 66 69 6E 64 2D 69 6E 
1A43AB0 	74 66 2D 64 65 73 63 8E 
1A43AB8 	4C 3A A4  1 20 40 A0  1 
   swap  begin				( intfidx adr )
1A43AC0 	68 49 A0  1 
      INTERFACE find-desc		( intfidx adr' )
1A43AC4 	FC 32 A4  1 
1A43AC8 	4C 3A A4  1 
   swap ?dup  while			( adr intfidx )
1A43ACC 	68 49 A0  1 
1A43AD0 	B4 70 A0  1 DC 41 A0  1 
1A43AD8 	20  0  0  0 
      1- swap				( intfidx' adr )
1A43ADC 	54 4B A0  1 
1A43AE0 	68 49 A0  1 
      dup c@ +				( intfidx adr' )
1A43AE4 	40 49 A0  1 
1A43AE8 	C4 4C A0  1  4 45 A0  1 
   repeat
1A43AF0 	C8 41 A0  1 D0 FF FF FF 
;
1A43AF8 	58 46 A0  1 

: unicode$>ascii$  ( adr -- actual )
1A43AFC 	75 6E 69 63 
1A43B00 	6F 64 65 24 3E 61 73 63 
1A43B08 	69 69 24 8F BC 3A A4  1 
1A43B10 	20 40 A0  1 
   dup c@ 2 - 2/ swap 2 + over 0  ?do	( actual adr' )
1A43B14 	40 49 A0  1 
1A43B18 	C4 4C A0  1 90 6F A0  1 
1A43B20 	18 45 A0  1 78 4B A0  1 
1A43B28 	68 49 A0  1 90 6F A0  1 
1A43B30 	 4 45 A0  1 54 49 A0  1 
1A43B38 	70 6F A0  1 50 42 A0  1 
1A43B40 	6C  0  0  0 
      dup i 2* 1+ + c@ 0=  if		\ ASCII
1A43B44 	40 49 A0  1 
1A43B48 	B4 42 A0  1 A0 4B A0  1 
1A43B50 	30 4B A0  1  4 45 A0  1 
1A43B58 	C4 4C A0  1 24 47 A0  1 
1A43B60 	DC 41 A0  1 20  0  0  0 
         dup i 2* + c@			( actual adr c )
1A43B68 	40 49 A0  1 B4 42 A0  1 
1A43B70 	A0 4B A0  1  4 45 A0  1 
1A43B78 	C4 4C A0  1 
      else				\ Non-ascii
1A43B7C 	C8 41 A0  1 
1A43B80 	 C  0  0  0 
         ascii ?			( actual adr c )
1A43B84 	58 41 A0  1 
1A43B88 	3F  0  0  0 
      then
      over 2 - i + c!			( actual adr )
1A43B8C 	54 49 A0  1 
1A43B90 	90 6F A0  1 18 45 A0  1 
1A43B98 	B4 42 A0  1  4 45 A0  1 
1A43BA0 	B8 4D A0  1 
   loop  drop
1A43BA4 	F8 41 A0  1 
1A43BA8 	9C FF FF FF 30 49 A0  1 
;
1A43BB0 	58 46 A0  1 

\ XXX In the future, maybe we can decode more languages.
: encoded$>ascii$  ( adr lang -- actual )
1A43BB4 	65 6E 63 6F 
1A43BB8 	64 65 64 24 3E 61 73 63 
1A43BC0 	69 69 24 8F 10 3B A4  1 
1A43BC8 	20 40 A0  1 
   drop unicode$>ascii$
1A43BCC 	30 49 A0  1 
1A43BD0 	10 3B A4  1 
;
1A43BD4 	58 46 A0  1 

headers


OpenFirmware/dev/usb2/pkt-func.fth_AL	1B8 1A43BD8 purpose: Generic HCD Driver

hex


d#  50 constant nodata-timeout
1A43BD8 	 0 6E 6F 64 61 74 61 2D 
1A43BE0 	74 69 6D 65 6F 75 74 8E 
1A43BE8 	C8 3B A4  1 68 40 A0  1 
1A43BF0 	32  0  0  0 
d# 500 constant data-timeout
1A43BF4 	 0  0  0 64 
1A43BF8 	61 74 61 2D 74 69 6D 65 
1A43C00 	6F 75 74 8C EC 3B A4  1 
1A43C08 	68 40 A0  1 F4  1  0  0 

: int-property  ( n name$ -- )     rot encode-int  2swap property  ;
1A43C10 	 0  0  0 69 6E 74 2D 70 
1A43C18 	72 6F 70 65 72 74 79 8C 
1A43C20 	 8 3C A4  1 20 40 A0  1 
1A43C28 	7C 49 A0  1 40 F7 A1  1 
1A43C30 	F4 49 A0  1 BC 14 A2  1 
1A43C38 	58 46 A0  1 
: str-property  ( str$ name$ -- )  2swap encode-string 2swap  property  ;
1A43C3C 	 0  0  0 73 
1A43C40 	74 72 2D 70 72 6F 70 65 
1A43C48 	72 74 79 8C 24 3C A4  1 
1A43C50 	20 40 A0  1 F4 49 A0  1 
1A43C58 	A0 F6 A1  1 F4 49 A0  1 
1A43C60 	BC 14 A2  1 58 46 A0  1 


\ ---------------------------------------------------------------------------
\ Common variables
\ ---------------------------------------------------------------------------

false value debug?
1A43C68 	 0 64 65 62 75 67 3F 86 
1A43C70 	50 3C A4  1 50 40 A0  1 
1A43C78 	C8  D  0  0 

\ Setup and descriptor DMA data buffers
0 value setup-buf			\ SETUP packet buffer
1A43C7C 	 0  0 73 65 
1A43C80 	74 75 70 2D 62 75 66 89 
1A43C88 	74 3C A4  1 50 40 A0  1 
1A43C90 	CC  D  0  0 
0 value setup-buf-phys
1A43C94 	 0 73 65 74 
1A43C98 	75 70 2D 62 75 66 2D 70 
1A43CA0 	68 79 73 8E 8C 3C A4  1 
1A43CA8 	50 40 A0  1 D0  D  0  0 
0 value cfg-buf				\ Descriptor packet buffer
1A43CB0 	63 66 67 2D 62 75 66 87 
1A43CB8 	A8 3C A4  1 50 40 A0  1 
1A43CC0 	D4  D  0  0 
0 value cfg-buf-phys
1A43CC4 	 0  0  0 63 
1A43CC8 	66 67 2D 62 75 66 2D 70 
1A43CD0 	68 79 73 8C BC 3C A4  1 
1A43CD8 	50 40 A0  1 D8  D  0  0 

: alloc-dma-buf  ( -- )
1A43CE0 	 0  0 61 6C 6C 6F 63 2D 
1A43CE8 	64 6D 61 2D 62 75 66 8D 
1A43CF0 	D8 3C A4  1 20 40 A0  1 
   setup-buf 0=  if
1A43CF8 	8C 3C A4  1 24 47 A0  1 
1A43D00 	DC 41 A0  1 2C  0  0  0 
      /dr dma-alloc dup to setup-buf
1A43D08 	4C 30 A4  1 54 37 A4  1 
1A43D10 	40 49 A0  1 B8 40 A0  1 
1A43D18 	8C 3C A4  1 
      /dr true dma-map-in to setup-buf-phys
1A43D1C 	4C 30 A4  1 
1A43D20 	 4 70 A0  1 AC 37 A4  1 
1A43D28 	B8 40 A0  1 A8 3C A4  1 
   then
   cfg-buf 0=  if
1A43D30 	BC 3C A4  1 24 47 A0  1 
1A43D38 	DC 41 A0  1 2C  0  0  0 
      /cfg dma-alloc dup to cfg-buf
1A43D40 	B4 2F A4  1 54 37 A4  1 
1A43D48 	40 49 A0  1 B8 40 A0  1 
1A43D50 	BC 3C A4  1 
      /cfg true dma-map-in to cfg-buf-phys
1A43D54 	B4 2F A4  1 
1A43D58 	 4 70 A0  1 AC 37 A4  1 
1A43D60 	B8 40 A0  1 D8 3C A4  1 
   then
;
1A43D68 	58 46 A0  1 
: free-dma-buf  ( -- )
1A43D6C 	 0  0  0 66 
1A43D70 	72 65 65 2D 64 6D 61 2D 
1A43D78 	62 75 66 8C F4 3C A4  1 
1A43D80 	20 40 A0  1 
   setup-buf  if
1A43D84 	8C 3C A4  1 
1A43D88 	DC 41 A0  1 38  0  0  0 
      setup-buf setup-buf-phys /dr dma-map-out
1A43D90 	8C 3C A4  1 A8 3C A4  1 
1A43D98 	4C 30 A4  1 D8 37 A4  1 
      setup-buf /dr dma-free
1A43DA0 	8C 3C A4  1 4C 30 A4  1 
1A43DA8 	80 37 A4  1 
      0 to setup-buf 0 to setup-buf-phys
1A43DAC 	70 6F A0  1 
1A43DB0 	B8 40 A0  1 8C 3C A4  1 
1A43DB8 	70 6F A0  1 B8 40 A0  1 
1A43DC0 	A8 3C A4  1 
   then
   cfg-buf  if
1A43DC4 	BC 3C A4  1 
1A43DC8 	DC 41 A0  1 38  0  0  0 
      cfg-buf cfg-buf-phys /cfg dma-map-out
1A43DD0 	BC 3C A4  1 D8 3C A4  1 
1A43DD8 	B4 2F A4  1 D8 37 A4  1 
      cfg-buf /cfg dma-free
1A43DE0 	BC 3C A4  1 B4 2F A4  1 
1A43DE8 	80 37 A4  1 
      0 to cfg-buf 0 to cfg-buf-phys
1A43DEC 	70 6F A0  1 
1A43DF0 	B8 40 A0  1 BC 3C A4  1 
1A43DF8 	70 6F A0  1 B8 40 A0  1 
1A43E00 	D8 3C A4  1 
   then
;
1A43E04 	58 46 A0  1 



0 value locked?  \ Interrupt lockout for USB keyboard get-data?
1A43E08 	6C 6F 63 6B 65 64 3F 87 
1A43E10 	80 3D A4  1 50 40 A0  1 
1A43E18 	DC  D  0  0 
: lock    ( -- )  true  to locked?  ;
1A43E1C 	 0  0  0 6C 
1A43E20 	6F 63 6B 84 14 3E A4  1 
1A43E28 	20 40 A0  1  4 70 A0  1 
1A43E30 	B8 40 A0  1 14 3E A4  1 
1A43E38 	58 46 A0  1 
: unlock  ( -- )  false to locked?  ;
1A43E3C 	 0 75 6E 6C 
1A43E40 	6F 63 6B 86 28 3E A4  1 
1A43E48 	20 40 A0  1 18 70 A0  1 
1A43E50 	B8 40 A0  1 14 3E A4  1 
1A43E58 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Common routines
\ ---------------------------------------------------------------------------

\ XXX Room for improvement: keep tab of hcd-map-in's to improve performance.
: hcd-map-in   ( virt size -- phys )  false dma-map-in  ;
1A43E5C 	 0 68 63 64 
1A43E60 	2D 6D 61 70 2D 69 6E 8A 
1A43E68 	48 3E A4  1 20 40 A0  1 
1A43E70 	18 70 A0  1 AC 37 A4  1 
1A43E78 	58 46 A0  1 
: hcd-map-out  ( virt phys size -- )  dma-map-out  ;
1A43E7C 	68 63 64 2D 
1A43E80 	6D 61 70 2D 6F 75 74 8B 
1A43E88 	6C 3E A4  1 20 40 A0  1 
1A43E90 	D8 37 A4  1 58 46 A0  1 


: $=  ( adr len adr len -- =? )
1A43E98 	 0 24 3D 82 8C 3E A4  1 
1A43EA0 	20 40 A0  1 
   rot tuck <> if    
1A43EA4 	7C 49 A0  1 
1A43EA8 	E8 46 A0  1 44 48 A0  1 
1A43EB0 	DC 41 A0  1 10  0  0  0 
      3drop false exit 
1A43EB8 	90 52 A0  1 18 70 A0  1 
1A43EC0 	40 46 A0  1 
   then  comp 0= 
1A43EC4 	38 52 A0  1 
1A43EC8 	24 47 A0  1 
; 
1A43ECC 	58 46 A0  1 

: log2  ( n -- log2-of-n )
1A43ED0 	 0  0  0 6C 6F 67 32 84 
1A43ED8 	A0 3E A4  1 20 40 A0  1 
   0  begin        ( n log )
1A43EE0 	70 6F A0  1 
      swap  2/     ( log n' )
1A43EE4 	68 49 A0  1 
1A43EE8 	78 4B A0  1 
   ?dup  while     ( log n' )
1A43EEC 	B4 70 A0  1 
1A43EF0 	DC 41 A0  1 14  0  0  0 
      swap 1+      ( n' log' )
1A43EF8 	68 49 A0  1 30 4B A0  1 
   repeat          ( log )
1A43F00 	C8 41 A0  1 E0 FF FF FF 
;
1A43F08 	58 46 A0  1 
: exp2  ( n -- 2**n )  1 swap 0 ?do  2*  loop  ;
1A43F0C 	 0  0  0 65 
1A43F10 	78 70 32 84 DC 3E A4  1 
1A43F18 	20 40 A0  1 80 6F A0  1 
1A43F20 	68 49 A0  1 70 6F A0  1 
1A43F28 	50 42 A0  1 10  0  0  0 
1A43F30 	A0 4B A0  1 F8 41 A0  1 
1A43F38 	F8 FF FF FF 58 46 A0  1 
: interval  ( interval -- interval' )  log2 exp2  ;
1A43F40 	 0  0  0 69 6E 74 65 72 
1A43F48 	76 61 6C 88 18 3F A4  1 
1A43F50 	20 40 A0  1 DC 3E A4  1 
1A43F58 	18 3F A4  1 58 46 A0  1 

: 3dup   ( n1 n2 n3 -- n1 n2 n3 n1 n2 n3 )  2 pick 2 pick 2 pick  ;
1A43F60 	 0  0  0 33 64 75 70 84 
1A43F68 	50 3F A4  1 20 40 A0  1 
1A43F70 	90 6F A0  1  C 4A A0  1 
1A43F78 	90 6F A0  1  C 4A A0  1 
1A43F80 	90 6F A0  1  C 4A A0  1 
1A43F88 	58 46 A0  1 
: 3drop  ( n1 n2 n3 -- )  2drop drop  ;
1A43F8C 	 0  0 33 64 
1A43F90 	72 6F 70 85 6C 3F A4  1 
1A43F98 	20 40 A0  1 AC 49 A0  1 
1A43FA0 	30 49 A0  1 58 46 A0  1 

: 4dup   ( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2 n3 n4 )  2over 2over  ;
1A43FA8 	 0  0  0 34 64 75 70 84 
1A43FB0 	98 3F A4  1 20 40 A0  1 
1A43FB8 	D8 49 A0  1 D8 49 A0  1 
1A43FC0 	58 46 A0  1 
: 4drop  ( n1 n2 n3 n4 -- )  2drop 2drop  ;
1A43FC4 	 0  0 34 64 
1A43FC8 	72 6F 70 85 B4 3F A4  1 
1A43FD0 	20 40 A0  1 AC 49 A0  1 
1A43FD8 	AC 49 A0  1 58 46 A0  1 

: 5dup   ( n1 n2 n3 n4 n5 -- n1 n2 n3 n4 n5 n1 n2 n3 n4 n5 )
1A43FE0 	 0  0  0 35 64 75 70 84 
1A43FE8 	D0 3F A4  1 20 40 A0  1 
   4 pick 4 pick 4 pick 4 pick 4 pick
1A43FF0 	B0 6F A0  1  C 4A A0  1 
1A43FF8 	B0 6F A0  1  C 4A A0  1 
1A44000 	B0 6F A0  1  C 4A A0  1 
1A44008 	B0 6F A0  1  C 4A A0  1 
1A44010 	B0 6F A0  1  C 4A A0  1 
;
1A44018 	58 46 A0  1 
: 5drop  ( n1 n2 n3 n4 n5 -- )  2drop 3drop  ;
1A4401C 	 0  0 35 64 
1A44020 	72 6F 70 85 EC 3F A4  1 
1A44028 	20 40 A0  1 AC 49 A0  1 
1A44030 	98 3F A4  1 58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Exported methods
\ ---------------------------------------------------------------------------

external


: debug-on  ( -- )  true to debug?  ;
1A44038 	 0  0  0 64 65 62 75 67 
1A44040 	2D 6F 6E 88 28 40 A4  1 
1A44048 	20 40 A0  1  4 70 A0  1 
1A44050 	B8 40 A0  1 74 3C A4  1 
1A44058 	58 46 A0  1 

: decode-unit-m  ( addr len -- interface port )  parse-2int  ;
1A4405C 	 0  0 64 65 
1A44060 	63 6F 64 65 2D 75 6E 69 
1A44068 	74 2D 6D 8D 48 40 A4  1 
1A44070 	20 40 A0  1  8 4B A2  1 
1A44078 	58 46 A0  1 
: encode-unit-m  ( interface port -- adr len )
1A4407C 	 0  0 65 6E 
1A44080 	63 6F 64 65 2D 75 6E 69 
1A44088 	74 2D 6D 8D 70 40 A4  1 
1A44090 	20 40 A0  1 
   >r <# u#s drop ascii , hold r> u#s u#>	\ " port,interface"
1A44094 	BC 45 A0  1 
1A44098 	 8 76 A0  1 BC 76 A0  1 
1A440A0 	30 49 A0  1 58 41 A0  1 
1A440A8 	2C  0  0  0 DC 75 A0  1 
1A440B0 	D0 45 A0  1 BC 76 A0  1 
1A440B8 	E0 76 A0  1 
;
1A440BC 	58 46 A0  1 



OpenFirmware/dev/usb2/hcd/hcd.fth_AL	4E8 1A440C0 purpose: Internal USB error codes for use by USB HCD drivers

headers
hex

\ fl d:include\dev\usbm\error.fth

0 value usb-error
1A440C0 	 0  0 75 73 62 2D 65 72 
1A440C8 	72 6F 72 89 90 40 A4  1 
1A440D0 	50 40 A0  1 E0  D  0  0 

: clear-usb-error  ( -- )  0 to usb-error  ;
1A440D8 	63 6C 65 61 72 2D 75 73 
1A440E0 	62 2D 65 72 72 6F 72 8F 
1A440E8 	D0 40 A4  1 20 40 A0  1 
1A440F0 	70 6F A0  1 B8 40 A0  1 
1A440F8 	D0 40 A4  1 58 46 A0  1 
: set-usb-error  ( $ err -- )
1A44100 	 0  0 73 65 74 2D 75 73 
1A44108 	62 2D 65 72 72 6F 72 8D 
1A44110 	EC 40 A4  1 20 40 A0  1 
   usb-error or to usb-error
1A44118 	D0 40 A4  1 70 44 A0  1 
1A44120 	B8 40 A0  1 D0 40 A4  1 
   debug?  if  type cr  else  2drop  then
1A44128 	74 3C A4  1 DC 41 A0  1 
1A44130 	14  0  0  0  4 6C A0  1 
1A44138 	80 6D A0  1 C8 41 A0  1 
1A44140 	 8  0  0  0 AC 49 A0  1 
;
1A44148 	58 46 A0  1 



OpenFirmware/dev/usb2/hcd/error.fth_AL	8C 1A4414C purpose: Data structures and manuipulation routines for all USB Controllers

hex
headers

\ ---------------------------------------------------------------------------
\ device-info (DI): data structure internal to the OHCI driver.
\ It keeps track of assigned USB addresses.  For each USB device, its speed.
\ And for each endpoint in a device, its max packet size and data toggle bit.
\
\ This data structure, once created, stays around at all time.
\ ---------------------------------------------------------------------------

struct
   2 field >di-ep-maxpayload		\ Max packet size for the endpoint
1A4414C 	 0  0 3E 64 
1A44150 	69 2D 65 70 2D 6D 61 78 
1A44158 	70 61 79 6C 6F 61 64 91 
1A44160 	14 41 A4  1 50 EE A0  1 
1A44168 	 0  0  0  0 
   1 field >di-ep-in-toggle		\ Data toggle state
1A4416C 	 0  0  0 3E 
1A44170 	64 69 2D 65 70 2D 69 6E 
1A44178 	2D 74 6F 67 67 6C 65 90 
1A44180 	64 41 A4  1 50 EE A0  1 
1A44188 	 2  0  0  0 
   1 field >di-ep-out-toggle		\ Data toggle state
1A4418C 	 0  0 3E 64 
1A44190 	69 2D 65 70 2D 6F 75 74 
1A44198 	2D 74 6F 67 67 6C 65 91 
1A441A0 	84 41 A4  1 50 EE A0  1 
1A441A8 	 3  0  0  0 
constant /di-ep-struct
1A441AC 	 0  0 2F 64 
1A441B0 	69 2D 65 70 2D 73 74 72 
1A441B8 	75 63 74 8D A4 41 A4  1 
1A441C0 	68 40 A0  1  4  0  0  0 

struct
   1 field >di-speed			\ Device speed
1A441C8 	 0  0 3E 64 69 2D 73 70 
1A441D0 	65 65 64 89 C0 41 A4  1 
1A441D8 	50 EE A0  1  0  0  0  0 
   1 field >di-hub			\ Hub address (EHCI only)
1A441E0 	3E 64 69 2D 68 75 62 87 
1A441E8 	D8 41 A4  1 50 EE A0  1 
1A441F0 	 1  0  0  0 
   1 field >di-port			\ Port number (EHCI only)
1A441F4 	 0  0  0 3E 
1A441F8 	64 69 2D 70 6F 72 74 88 
1A44200 	EC 41 A4  1 50 EE A0  1 
1A44208 	 2  0  0  0 
   1 field >di-reset			\ reset flag - 0 initially or after a resume, then 1
1A4420C 	 0  0 3E 64 
1A44210 	69 2D 72 65 73 65 74 89 
1A44218 	 4 42 A4  1 50 EE A0  1 
1A44220 	 3  0  0  0 
   /di-ep-struct #max-endpoint * field >di-ep
1A44224 	 0 3E 64 69 
1A44228 	2D 65 70 86 1C 42 A4  1 
1A44230 	50 EE A0  1  4  0  0  0 
					\ Endpoint structure
constant /di-entry
1A44238 	 0  0 2F 64 69 2D 65 6E 
1A44240 	74 72 79 89 30 42 A4  1 
1A44248 	68 40 A0  1 44  0  0  0 

/di-entry #max-dev * constant /di
1A44250 	2F 64 69 83 48 42 A4  1 
1A44258 	68 40 A0  1  0 22  0  0 
0 value di				\ device-info
1A44260 	 0 64 69 82 58 42 A4  1 
1A44268 	50 40 A0  1 E4  D  0  0 

0 value cur-dev				\ Value of the last assigned usb address
1A44270 	63 75 72 2D 64 65 76 87 
1A44278 	68 42 A4  1 50 40 A0  1 
1A44280 	E8  D  0  0 

: 'di     ( idx -- adr )       /di-entry * di +  ;
1A44284 	27 64 69 83 
1A44288 	7C 42 A4  1 20 40 A0  1 
1A44290 	48 42 A4  1 1C 5F A0  1 
1A44298 	68 42 A4  1  4 45 A0  1 
1A442A0 	58 46 A0  1 
: 'di-ep  ( pipe idx -- adr )  'di >di-ep swap /di-ep-struct * +  ;
1A442A4 	 0 27 64 69 
1A442A8 	2D 65 70 86 8C 42 A4  1 
1A442B0 	20 40 A0  1 8C 42 A4  1 
1A442B8 	30 42 A4  1 68 49 A0  1 
1A442C0 	C0 41 A4  1 1C 5F A0  1 
1A442C8 	 4 45 A0  1 58 46 A0  1 

: di-speed!  ( speed idx -- )  'di >di-speed c!  ;
1A442D0 	 0  0 64 69 2D 73 70 65 
1A442D8 	65 64 21 89 B0 42 A4  1 
1A442E0 	20 40 A0  1 8C 42 A4  1 
1A442E8 	D8 41 A4  1 B8 4D A0  1 
1A442F0 	58 46 A0  1 
: di-speed@  ( idx -- speed )  'di >di-speed c@  ;
1A442F4 	 0  0 64 69 
1A442F8 	2D 73 70 65 65 64 40 89 
1A44300 	E0 42 A4  1 20 40 A0  1 
1A44308 	8C 42 A4  1 D8 41 A4  1 
1A44310 	C4 4C A0  1 58 46 A0  1 
: di-hub!    ( hub idx -- )    'di >di-hub   c!  ;
1A44318 	64 69 2D 68 75 62 21 87 
1A44320 	 4 43 A4  1 20 40 A0  1 
1A44328 	8C 42 A4  1 EC 41 A4  1 
1A44330 	B8 4D A0  1 58 46 A0  1 
: di-hub@    ( idx -- hub )    'di >di-hub   c@  ;
1A44338 	64 69 2D 68 75 62 40 87 
1A44340 	24 43 A4  1 20 40 A0  1 
1A44348 	8C 42 A4  1 EC 41 A4  1 
1A44350 	C4 4C A0  1 58 46 A0  1 
: di-port!   ( port idx -- )   'di >di-port  c!  ;
1A44358 	 0  0  0 64 69 2D 70 6F 
1A44360 	72 74 21 88 44 43 A4  1 
1A44368 	20 40 A0  1 8C 42 A4  1 
1A44370 	 4 42 A4  1 B8 4D A0  1 
1A44378 	58 46 A0  1 
: di-port@   ( idx -- port )   'di >di-port  c@  ;
1A4437C 	 0  0  0 64 
1A44380 	69 2D 70 6F 72 74 40 88 
1A44388 	68 43 A4  1 20 40 A0  1 
1A44390 	8C 42 A4  1  4 42 A4  1 
1A44398 	C4 4C A0  1 58 46 A0  1 
: di-is-reset  ( idx -- )
1A443A0 	64 69 2D 69 73 2D 72 65 
1A443A8 	73 65 74 8B 8C 43 A4  1 
1A443B0 	20 40 A0  1 
   'di >di-reset          ( adr )
1A443B4 	8C 42 A4  1 
1A443B8 	1C 42 A4  1 
   0 swap c!
1A443BC 	70 6F A0  1 
1A443C0 	68 49 A0  1 B8 4D A0  1 
;
1A443C8 	58 46 A0  1 
: di-reset?  ( idx -- flag )
1A443CC 	 0  0 64 69 
1A443D0 	2D 72 65 73 65 74 3F 89 
1A443D8 	B0 43 A4  1 20 40 A0  1 
   'di >di-reset          ( adr )
1A443E0 	8C 42 A4  1 1C 42 A4  1 
   dup c@ 0=              ( adr reset? )
1A443E8 	40 49 A0  1 C4 4C A0  1 
1A443F0 	24 47 A0  1 
   1 rot c!               ( reset? )
1A443F4 	80 6F A0  1 
1A443F8 	7C 49 A0  1 B8 4D A0  1 
;
1A44400 	58 46 A0  1 

: 'di-maxpayload  ( pipe idx -- adr )  'di-ep >di-ep-maxpayload  ;
1A44404 	 0 27 64 69 
1A44408 	2D 6D 61 78 70 61 79 6C 
1A44410 	6F 61 64 8E DC 43 A4  1 
1A44418 	20 40 A0  1 B0 42 A4  1 
1A44420 	64 41 A4  1 58 46 A0  1 
: di-maxpayload!  ( len pipe idx -- )  'di-maxpayload w!  ;
1A44428 	 0 64 69 2D 6D 61 78 70 
1A44430 	61 79 6C 6F 61 64 21 8E 
1A44438 	18 44 A4  1 20 40 A0  1 
1A44440 	18 44 A4  1 A4 4D A0  1 
1A44448 	58 46 A0  1 
: di-maxpayload@  ( pipe idx -- len )  'di-maxpayload w@  ;
1A4444C 	 0 64 69 2D 
1A44450 	6D 61 78 70 61 79 6C 6F 
1A44458 	61 64 40 8E 3C 44 A4  1 
1A44460 	20 40 A0  1 18 44 A4  1 
1A44468 	94 4C A0  1 58 46 A0  1 

: di-in-data!   ( n pipe id -- )       'di-ep >di-ep-in-toggle  c!  ;
1A44470 	64 69 2D 69 6E 2D 64 61 
1A44478 	74 61 21 8B 60 44 A4  1 
1A44480 	20 40 A0  1 B0 42 A4  1 
1A44488 	84 41 A4  1 B8 4D A0  1 
1A44490 	58 46 A0  1 
: di-in-data@   ( pipe id -- n )       'di-ep >di-ep-in-toggle  c@  ;
1A44494 	64 69 2D 69 
1A44498 	6E 2D 64 61 74 61 40 8B 
1A444A0 	80 44 A4  1 20 40 A0  1 
1A444A8 	B0 42 A4  1 84 41 A4  1 
1A444B0 	C4 4C A0  1 58 46 A0  1 
: di-out-data!  ( n pipe id -- )       'di-ep >di-ep-out-toggle c!  ;
1A444B8 	 0  0  0 64 69 2D 6F 75 
1A444C0 	74 2D 64 61 74 61 21 8C 
1A444C8 	A4 44 A4  1 20 40 A0  1 
1A444D0 	B0 42 A4  1 A4 41 A4  1 
1A444D8 	B8 4D A0  1 58 46 A0  1 
: di-out-data@  ( pipe id -- n )       'di-ep >di-ep-out-toggle c@  ;
1A444E0 	 0  0  0 64 69 2D 6F 75 
1A444E8 	74 2D 64 61 74 61 40 8C 
1A444F0 	CC 44 A4  1 20 40 A0  1 
1A444F8 	B0 42 A4  1 A4 41 A4  1 
1A44500 	C4 4C A0  1 58 46 A0  1 
: di-in-data-toggle   ( pipe idx -- )  2dup di-in-data@  1 xor -rot di-in-data!   ;
1A44508 	 0  0 64 69 2D 69 6E 2D 
1A44510 	64 61 74 61 2D 74 6F 67 
1A44518 	67 6C 65 91 F4 44 A4  1 
1A44520 	20 40 A0  1 C0 49 A0  1 
1A44528 	A4 44 A4  1 80 6F A0  1 
1A44530 	84 44 A0  1 94 49 A0  1 
1A44538 	80 44 A4  1 58 46 A0  1 
: di-out-data-toggle  ( pipe idx -- )  2dup di-out-data@ 1 xor -rot di-out-data!  ;
1A44540 	 0 64 69 2D 6F 75 74 2D 
1A44548 	64 61 74 61 2D 74 6F 67 
1A44550 	67 6C 65 92 20 45 A4  1 
1A44558 	20 40 A0  1 C0 49 A0  1 
1A44560 	F4 44 A4  1 80 6F A0  1 
1A44568 	84 44 A0  1 94 49 A0  1 
1A44570 	CC 44 A4  1 58 46 A0  1 

: next-device#  ( -- true | dev false )
1A44578 	 0  0  0 6E 65 78 74 2D 
1A44580 	64 65 76 69 63 65 23 8C 
1A44588 	58 45 A4  1 20 40 A0  1 
   cur-dev 1+ #max-dev >=  if  true exit  then
1A44590 	7C 42 A4  1 30 4B A0  1 
1A44598 	28 2F A4  1 EC 48 A0  1 
1A445A0 	DC 41 A0  1  C  0  0  0 
1A445A8 	 4 70 A0  1 40 46 A0  1 
   cur-dev 1+ dup to cur-dev  
1A445B0 	7C 42 A4  1 30 4B A0  1 
1A445B8 	40 49 A0  1 B8 40 A0  1 
1A445C0 	7C 42 A4  1 
   /pipe0 0 cur-dev di-maxpayload!
1A445C4 	A0 2F A4  1 
1A445C8 	70 6F A0  1 7C 42 A4  1 
1A445D0 	3C 44 A4  1 
   false
1A445D4 	18 70 A0  1 
;
1A445D8 	58 46 A0  1 

: init-di  ( -- )
1A445DC 	69 6E 69 74 
1A445E0 	2D 64 69 87 8C 45 A4  1 
1A445E8 	20 40 A0  1 
   di 0=  if
1A445EC 	68 42 A4  1 
1A445F0 	24 47 A0  1 DC 41 A0  1 
1A445F8 	14  0  0  0 
      \ allocate and initialize the device descriptors
      /di alloc-mem to di
1A445FC 	58 42 A4  1 
1A44600 	F0 6C A0  1 B8 40 A0  1 
1A44608 	68 42 A4  1 
   then
   di /di erase
1A4460C 	68 42 A4  1 
1A44610 	58 42 A4  1 F0 72 A0  1 
   /pipe0 0 0 di-maxpayload!		\ Default max payload
1A44618 	A0 2F A4  1 70 6F A0  1 
1A44620 	70 6F A0  1 3C 44 A4  1 
;
1A44628 	58 46 A0  1 

: init-struct  ( -- )
1A4462C 	69 6E 69 74 
1A44630 	2D 73 74 72 75 63 74 8B 
1A44638 	E8 45 A4  1 20 40 A0  1 
   init-di
1A44640 	E8 45 A4  1 
   0 to cur-dev
1A44644 	70 6F A0  1 
1A44648 	B8 40 A0  1 7C 42 A4  1 
;
1A44650 	58 46 A0  1 

headers


OpenFirmware/dev/usb2/hcd/dev-info.fth_AL	508 1A44654 purpose: Functional interface to HCD driver provided for all usb children

\ All hub drivers must forward all the following methods for their children.
\ A device driver may include only a subset of the methods it needs.

: hcdcallfth 
1A44654 	 0 68 63 64 
1A44658 	63 61 6C 6C 66 74 68 8A 
1A44660 	3C 46 A4  1 20 40 A0  1 
hex
1A44668 	C0 8D A0  1 
 " : dma-alloc    ( size -- virt ) "" dma-alloc"" $call-parent ;" eval
1A4466C 	9C 53 A0  1 
1A44670 	3B 3A 20 64 6D 61 2D 61 
1A44678 	6C 6C 6F 63 20 20 20 20 
1A44680 	28 20 73 69 7A 65 20 2D 
1A44688 	2D 20 76 69 72 74 20 29 
1A44690 	20 22 20 64 6D 61 2D 61 
1A44698 	6C 6C 6F 63 22 20 24 63 
1A446A0 	61 6C 6C 2D 70 61 72 65 
1A446A8 	6E 74 20 3B  0  0  0  0 
1A446B0 	D8 E5 A0  1 
 " : dma-free     ( virt size -- ) "" dma-free"" $call-parent  ;" eval
1A446B4 	9C 53 A0  1 
1A446B8 	3B 3A 20 64 6D 61 2D 66 
1A446C0 	72 65 65 20 20 20 20 20 
1A446C8 	28 20 76 69 72 74 20 73 
1A446D0 	69 7A 65 20 2D 2D 20 29 
1A446D8 	20 22 20 64 6D 61 2D 66 
1A446E0 	72 65 65 22 20 24 63 61 
1A446E8 	6C 6C 2D 70 61 72 65 6E 
1A446F0 	74 20 20 3B  0  0  0  0 
1A446F8 	D8 E5 A0  1 
 " : locked?  ( -- flag )   "" locked?"" $call-parent ;" eval
1A446FC 	9C 53 A0  1 
1A44700 	32 3A 20 6C 6F 63 6B 65 
1A44708 	64 3F 20 20 28 20 2D 2D 
1A44710 	20 66 6C 61 67 20 29 20 
1A44718 	20 20 22 20 6C 6F 63 6B 
1A44720 	65 64 3F 22 20 24 63 61 
1A44728 	6C 6C 2D 70 61 72 65 6E 
1A44730 	74 20 3B  0 D8 E5 A0  1 

\ Probing support
 " : set-target  ( device -- )   "" set-target"" $call-parent ;" eval
1A44738 	9C 53 A0  1 3A 3A 20 73 
1A44740 	65 74 2D 74 61 72 67 65 
1A44748 	74 20 20 28 20 64 65 76 
1A44750 	69 63 65 20 2D 2D 20 29 
1A44758 	20 20 20 22 20 73 65 74 
1A44760 	2D 74 61 72 67 65 74 22 
1A44768 	20 24 63 61 6C 6C 2D 70 
1A44770 	61 72 65 6E 74 20 3B  0 
1A44778 	D8 E5 A0  1 
 " : probe-hub-xt  ( -- adr )   "" probe-hub-xt"" $call-parent ;" eval
1A4477C 	9C 53 A0  1 
1A44780 	3B 3A 20 70 72 6F 62 65 
1A44788 	2D 68 75 62 2D 78 74 20 
1A44790 	20 28 20 2D 2D 20 61 64 
1A44798 	72 20 29 20 20 20 22 20 
1A447A0 	70 72 6F 62 65 2D 68 75 
1A447A8 	62 2D 78 74 22 20 24 63 
1A447B0 	61 6C 6C 2D 70 61 72 65 
1A447B8 	6E 74 20 3B  0  0  0  0 
1A447C0 	D8 E5 A0  1 
 " : reprobe-hub-xt  ( -- adr )   "" reprobe-hub-xt"" $call-parent ;" eval
1A447C4 	9C 53 A0  1 
1A447C8 	3F 3A 20 72 65 70 72 6F 
1A447D0 	62 65 2D 68 75 62 2D 78 
1A447D8 	74 20 20 28 20 2D 2D 20 
1A447E0 	61 64 72 20 29 20 20 20 
1A447E8 	22 20 72 65 70 72 6F 62 
1A447F0 	65 2D 68 75 62 2D 78 74 
1A447F8 	22 20 24 63 61 6C 6C 2D 
1A44800 	70 61 72 65 6E 74 20 3B 
1A44808 	 0  0  0  0 D8 E5 A0  1 
 " : hub-selftest-xt  ( -- adr )   "" hub-selftest-xt"" $call-parent ;" eval
1A44810 	9C 53 A0  1 41 3A 20 68 
1A44818 	75 62 2D 73 65 6C 66 74 
1A44820 	65 73 74 2D 78 74 20 20 
1A44828 	28 20 2D 2D 20 61 64 72 
1A44830 	20 29 20 20 20 22 20 68 
1A44838 	75 62 2D 73 65 6C 66 74 
1A44840 	65 73 74 2D 78 74 22 20 
1A44848 	24 63 61 6C 6C 2D 70 61 
1A44850 	72 65 6E 74 20 3B  0  0 
1A44858 	D8 E5 A0  1 
 " : set-pipe-maxpayload  ( size len -- )  "" set-pipe-maxpayload"" $call-parent ;" eval
1A4485C 	9C 53 A0  1 
1A44860 	4D 3A 20 73 65 74 2D 70 
1A44868 	69 70 65 2D 6D 61 78 70 
1A44870 	61 79 6C 6F 61 64 20 20 
1A44878 	28 20 73 69 7A 65 20 6C 
1A44880 	65 6E 20 2D 2D 20 29 20 
1A44888 	20 22 20 73 65 74 2D 70 
1A44890 	69 70 65 2D 6D 61 78 70 
1A44898 	61 79 6C 6F 61 64 22 20 
1A448A0 	24 63 61 6C 6C 2D 70 61 
1A448A8 	72 65 6E 74 20 3B  0  0 
1A448B0 	D8 E5 A0  1 
s" : setup-new-node  ( port speed hub-port hub-dev -- false | port dev xt true )
1A448B4 	9C 53 A0  1 
1A448B8 	4D 3A 20 73 65 74 75 70 
1A448C0 	2D 6E 65 77 2D 6E 6F 64 
1A448C8 	65 20 20 28 20 70 6F 72 
1A448D0 	74 20 73 70 65 65 64 20 
1A448D8 	68 75 62 2D 70 6F 72 74 
1A448E0 	20 68 75 62 2D 64 65 76 
1A448E8 	20 2D 2D 20 66 61 6C 73 
1A448F0 	65 20 7C 20 70 6F 72 74 
1A448F8 	20 64 65 76 20 78 74 20 
1A44900 	74 72 75 65 20 29  0  0 
 "    "" setup-new-node"" $call-parent ;
1A44908 	9C 53 A0  1 23 20 20 20 
1A44910 	22 20 73 65 74 75 70 2D 
1A44918 	6E 65 77 2D 6E 6F 64 65 
1A44920 	22 20 24 63 61 6C 6C 2D 
1A44928 	70 61 72 65 6E 74 20 3B 
1A44930 	 0  0  0  0 
 " : get-initial-descriptors  ( dev -- )  "" get-initial-descriptors"" $call-parent ;" eval
1A44934 	9C 53 A0  1 
1A44938 	50 3A 20 67 65 74 2D 69 
1A44940 	6E 69 74 69 61 6C 2D 64 
1A44948 	65 73 63 72 69 70 74 6F 
1A44950 	72 73 20 20 28 20 64 65 
1A44958 	76 20 2D 2D 20 29 20 20 
1A44960 	22 20 67 65 74 2D 69 6E 
1A44968 	69 74 69 61 6C 2D 64 65 
1A44970 	73 63 72 69 70 74 6F 72 
1A44978 	73 22 20 24 63 61 6C 6C 
1A44980 	2D 70 61 72 65 6E 74 20 
1A44988 	3B  0  0  0 D8 E5 A0  1 
 " : refresh-desc-bufs  ( dev -- )   "" refresh-desc-bufs"" $call-parent ;" eval
1A44990 	9C 53 A0  1 45 3A 20 72 
1A44998 	65 66 72 65 73 68 2D 64 
1A449A0 	65 73 63 2D 62 75 66 73 
1A449A8 	20 20 28 20 64 65 76 20 
1A449B0 	2D 2D 20 29 20 20 20 22 
1A449B8 	20 72 65 66 72 65 73 68 
1A449C0 	2D 64 65 73 63 2D 62 75 
1A449C8 	66 73 22 20 24 63 61 6C 
1A449D0 	6C 2D 70 61 72 65 6E 74 
1A449D8 	20 3B  0  0 D8 E5 A0  1 
 " : get-cfg-desc  ( adr idx -- actual )   "" get-cfg-desc"" $call-parent ;" eval
1A449E0 	9C 53 A0  1 46 3A 20 67 
1A449E8 	65 74 2D 63 66 67 2D 64 
1A449F0 	65 73 63 20 20 28 20 61 
1A449F8 	64 72 20 69 64 78 20 2D 
1A44A00 	2D 20 61 63 74 75 61 6C 
1A44A08 	20 29 20 20 20 22 20 67 
1A44A10 	65 74 2D 63 66 67 2D 64 
1A44A18 	65 73 63 22 20 24 63 61 
1A44A20 	6C 6C 2D 70 61 72 65 6E 
1A44A28 	74 20 3B  0 D8 E5 A0  1 


\ Control pipe operations
s" : control-get" eval  ( adr len idx value rtype req -- actual usberr )
1A44A30 	9C 53 A0  1  D 3A 20 63 
1A44A38 	6F 6E 74 72 6F 6C 2D 67 
1A44A40 	65 74  0  0 D8 E5 A0  1 
 "    "" control-get"" $call-parent ;" eval
1A44A48 	9C 53 A0  1 20 20 20 20 
1A44A50 	22 20 63 6F 6E 74 72 6F 
1A44A58 	6C 2D 67 65 74 22 20 24 
1A44A60 	63 61 6C 6C 2D 70 61 72 
1A44A68 	65 6E 74 20 3B  0  0  0 
1A44A70 	D8 E5 A0  1 
s" : control-set" eval  ( adr len idx value rtype req -- usberr )
1A44A74 	9C 53 A0  1 
1A44A78 	 D 3A 20 63 6F 6E 74 72 
1A44A80 	6F 6C 2D 73 65 74  0  0 
1A44A88 	D8 E5 A0  1 
 "    "" control-set"" $call-parent ;" eval
1A44A8C 	9C 53 A0  1 
1A44A90 	20 20 20 20 22 20 63 6F 
1A44A98 	6E 74 72 6F 6C 2D 73 65 
1A44AA0 	74 22 20 24 63 61 6C 6C 
1A44AA8 	2D 70 61 72 65 6E 74 20 
1A44AB0 	3B  0  0  0 D8 E5 A0  1 
s" : control-set-nostat" eval  ( adr len idx value rtype req -- usberr )
1A44AB8 	9C 53 A0  1 14 3A 20 63 
1A44AC0 	6F 6E 74 72 6F 6C 2D 73 
1A44AC8 	65 74 2D 6E 6F 73 74 61 
1A44AD0 	74  0  0  0 D8 E5 A0  1 
 "  "" control-set-nostat"" $call-parent ;" eval
1A44AD8 	9C 53 A0  1 25 20 22 20 
1A44AE0 	63 6F 6E 74 72 6F 6C 2D 
1A44AE8 	73 65 74 2D 6E 6F 73 74 
1A44AF0 	61 74 22 20 24 63 61 6C 
1A44AF8 	6C 2D 70 61 72 65 6E 74 
1A44B00 	20 3B  0  0 D8 E5 A0  1 
s" : get-desc" eval  ( adr len lang didx dtype rtype -- actual usberr )
1A44B08 	9C 53 A0  1  A 3A 20 67 
1A44B10 	65 74 2D 64 65 73 63  0 
1A44B18 	D8 E5 A0  1 
 "    "" get-desc"" $call-parent ;" eval
1A44B1C 	9C 53 A0  1 
1A44B20 	1D 20 20 20 22 20 67 65 
1A44B28 	74 2D 64 65 73 63 22 20 
1A44B30 	24 63 61 6C 6C 2D 70 61 
1A44B38 	72 65 6E 74 20 3B  0  0 
1A44B40 	D8 E5 A0  1 
s" : get-status" eval  ( adr len intf/endp rtype -- actual usberr )
1A44B44 	9C 53 A0  1 
1A44B48 	 C 3A 20 67 65 74 2D 73 
1A44B50 	74 61 74 75 73  0  0  0 
1A44B58 	D8 E5 A0  1 
 "    "" get-status"" $call-parent ;" eval
1A44B5C 	9C 53 A0  1 
1A44B60 	1F 20 20 20 22 20 67 65 
1A44B68 	74 2D 73 74 61 74 75 73 
1A44B70 	22 20 24 63 61 6C 6C 2D 
1A44B78 	70 61 72 65 6E 74 20 3B 
1A44B80 	 0  0  0  0 D8 E5 A0  1 
s" : set-config" eval  ( cfg -- usberr )
1A44B88 	9C 53 A0  1  C 3A 20 73 
1A44B90 	65 74 2D 63 6F 6E 66 69 
1A44B98 	67  0  0  0 D8 E5 A0  1 
 "    "" set-config"" $call-parent ;" eval
1A44BA0 	9C 53 A0  1 1F 20 20 20 
1A44BA8 	22 20 73 65 74 2D 63 6F 
1A44BB0 	6E 66 69 67 22 20 24 63 
1A44BB8 	61 6C 6C 2D 70 61 72 65 
1A44BC0 	6E 74 20 3B  0  0  0  0 
1A44BC8 	D8 E5 A0  1 


 " : set-interface  ( intf alt -- usberr )  "" set-interface"" $call-parent ;" eval
1A44BCC 	9C 53 A0  1 
1A44BD0 	48 3A 20 73 65 74 2D 69 
1A44BD8 	6E 74 65 72 66 61 63 65 
1A44BE0 	20 20 28 20 69 6E 74 66 
1A44BE8 	20 61 6C 74 20 2D 2D 20 
1A44BF0 	75 73 62 65 72 72 20 29 
1A44BF8 	20 20 22 20 73 65 74 2D 
1A44C00 	69 6E 74 65 72 66 61 63 
1A44C08 	65 22 20 24 63 61 6C 6C 
1A44C10 	2D 70 61 72 65 6E 74 20 
1A44C18 	3B  0  0  0 D8 E5 A0  1 
s" : clear-feature" eval  ( intf/endp feature rtype -- usberr )
1A44C20 	9C 53 A0  1  F 3A 20 63 
1A44C28 	6C 65 61 72 2D 66 65 61 
1A44C30 	74 75 72 65  0  0  0  0 
1A44C38 	D8 E5 A0  1 
 "    "" clear-feature"" $call-parent ;" eval
1A44C3C 	9C 53 A0  1 
1A44C40 	22 20 20 20 22 20 63 6C 
1A44C48 	65 61 72 2D 66 65 61 74 
1A44C50 	75 72 65 22 20 24 63 61 
1A44C58 	6C 6C 2D 70 61 72 65 6E 
1A44C60 	74 20 3B  0 D8 E5 A0  1 

s" : set-feature" eval  ( intf/endp feature rtype -- usberr )
1A44C68 	9C 53 A0  1  D 3A 20 73 
1A44C70 	65 74 2D 66 65 61 74 75 
1A44C78 	72 65  0  0 D8 E5 A0  1 
 "    "" set-feature"" $call-parent ;" eval
1A44C80 	9C 53 A0  1 20 20 20 20 
1A44C88 	22 20 73 65 74 2D 66 65 
1A44C90 	61 74 75 72 65 22 20 24 
1A44C98 	63 61 6C 6C 2D 70 61 72 
1A44CA0 	65 6E 74 20 3B  0  0  0 
1A44CA8 	D8 E5 A0  1 

 " : unstall-pipe  ( pipe -- )  "" unstall-pipe"" $call-parent  ;" eval
1A44CAC 	9C 53 A0  1 
1A44CB0 	3C 3A 20 75 6E 73 74 61 
1A44CB8 	6C 6C 2D 70 69 70 65 20 
1A44CC0 	20 28 20 70 69 70 65 20 
1A44CC8 	2D 2D 20 29 20 20 22 20 
1A44CD0 	75 6E 73 74 61 6C 6C 2D 
1A44CD8 	70 69 70 65 22 20 24 63 
1A44CE0 	61 6C 6C 2D 70 61 72 65 
1A44CE8 	6E 74 20 20 3B  0  0  0 
1A44CF0 	D8 E5 A0  1 

\ alias unstall-pipe unstall-pipe 

s"  alias bulk-in bulk-in-m" eval
1A44CF4 	9C 53 A0  1 
1A44CF8 	18 20 61 6C 69 61 73 20 
1A44D00 	62 75 6C 6B 2D 69 6E 20 
1A44D08 	62 75 6C 6B 2D 69 6E 2D 
1A44D10 	6D  0  0  0 D8 E5 A0  1 
s"  alias bulk-out bulk-out-m" eval
1A44D18 	9C 53 A0  1 1A 20 61 6C 
1A44D20 	69 61 73 20 62 75 6C 6B 
1A44D28 	2D 6F 75 74 20 62 75 6C 
1A44D30 	6B 2D 6F 75 74 2D 6D  0 
1A44D38 	D8 E5 A0  1 
;
1A44D3C 	58 46 A0  1 


\ Bulk pipe operations
: bulk-in-m  ( buf len pipe -- actual usberr )
1A44D40 	 0  0 62 75 6C 6B 2D 69 
1A44D48 	6E 2D 6D 89 64 46 A4  1 
1A44D50 	20 40 A0  1 
   " bulk-in" $call-parent
1A44D54 	9C 53 A0  1 
1A44D58 	 7 62 75 6C 6B 2D 69 6E 
1A44D60 	 0  0  0  0 DC 31 A2  1 
;
1A44D68 	58 46 A0  1 

: bulk-out-m  ( buf len pipe -- usberr )
1A44D6C 	 0 62 75 6C 
1A44D70 	6B 2D 6F 75 74 2D 6D 8A 
1A44D78 	50 4D A4  1 20 40 A0  1 
   " bulk-out" $call-parent
1A44D80 	9C 53 A0  1  8 62 75 6C 
1A44D88 	6B 2D 6F 75 74  0  0  0 
1A44D90 	DC 31 A2  1 
;
1A44D94 	58 46 A0  1 



: begin-bulk-in  ( buf len pipe -- )
1A44D98 	 0  0 62 65 67 69 6E 2D 
1A44DA0 	62 75 6C 6B 2D 69 6E 8D 
1A44DA8 	7C 4D A4  1 20 40 A0  1 
   " begin-bulk-in" $call-parent
1A44DB0 	9C 53 A0  1  D 62 65 67 
1A44DB8 	69 6E 2D 62 75 6C 6B 2D 
1A44DC0 	69 6E  0  0 DC 31 A2  1 
;
1A44DC8 	58 46 A0  1 
: bulk-in?  ( -- actual usberr )
1A44DCC 	 0  0  0 62 
1A44DD0 	75 6C 6B 2D 69 6E 3F 88 
1A44DD8 	AC 4D A4  1 20 40 A0  1 
   " bulk-in?" $call-parent
1A44DE0 	9C 53 A0  1  8 62 75 6C 
1A44DE8 	6B 2D 69 6E 3F  0  0  0 
1A44DF0 	DC 31 A2  1 
;
1A44DF4 	58 46 A0  1 
: restart-bulk-in  ( -- )
1A44DF8 	72 65 73 74 61 72 74 2D 
1A44E00 	62 75 6C 6B 2D 69 6E 8F 
1A44E08 	DC 4D A4  1 20 40 A0  1 
   " restart-bulk-in" $call-parent
1A44E10 	9C 53 A0  1  F 72 65 73 
1A44E18 	74 61 72 74 2D 62 75 6C 
1A44E20 	6B 2D 69 6E  0  0  0  0 
1A44E28 	DC 31 A2  1 
;
1A44E2C 	58 46 A0  1 
: end-bulk-in  ( -- )
1A44E30 	65 6E 64 2D 62 75 6C 6B 
1A44E38 	2D 69 6E 8B  C 4E A4  1 
1A44E40 	20 40 A0  1 
   " end-bulk-in" $call-parent
1A44E44 	9C 53 A0  1 
1A44E48 	 B 65 6E 64 2D 62 75 6C 
1A44E50 	6B 2D 69 6E  0  0  0  0 
1A44E58 	DC 31 A2  1 
;
1A44E5C 	58 46 A0  1 
: set-bulk-in-timeout  ( t -- )
1A44E60 	73 65 74 2D 62 75 6C 6B 
1A44E68 	2D 69 6E 2D 74 69 6D 65 
1A44E70 	6F 75 74 93 40 4E A4  1 
1A44E78 	20 40 A0  1 
   " set-bulk-in-timeout" $call-parent
1A44E7C 	9C 53 A0  1 
1A44E80 	13 73 65 74 2D 62 75 6C 
1A44E88 	6B 2D 69 6E 2D 74 69 6D 
1A44E90 	65 6F 75 74  0  0  0  0 
1A44E98 	DC 31 A2  1 
;
1A44E9C 	58 46 A0  1 
: bulk-in-ready?  ( -- false | error true | buf len 0 true )
1A44EA0 	 0 62 75 6C 6B 2D 69 6E 
1A44EA8 	2D 72 65 61 64 79 3F 8E 
1A44EB0 	78 4E A4  1 20 40 A0  1 
   " bulk-in-ready?" $call-parent
1A44EB8 	9C 53 A0  1  E 62 75 6C 
1A44EC0 	6B 2D 69 6E 2D 72 65 61 
1A44EC8 	64 79 3F  0 DC 31 A2  1 
;
1A44ED0 	58 46 A0  1 

: begin-in-ring  ( /buf #bufs pipe -- )
1A44ED4 	 0  0 62 65 
1A44ED8 	67 69 6E 2D 69 6E 2D 72 
1A44EE0 	69 6E 67 8D B4 4E A4  1 
1A44EE8 	20 40 A0  1 
   " begin-in-ring" $call-parent
1A44EEC 	9C 53 A0  1 
1A44EF0 	 D 62 65 67 69 6E 2D 69 
1A44EF8 	6E 2D 72 69 6E 67  0  0 
1A44F00 	DC 31 A2  1 
;
1A44F04 	58 46 A0  1 
\ : end-in-ring     " end-in-ring" $call-parent  ;
: begin-out-ring  ( /buf #bufs pipe -- )
1A44F08 	 0 62 65 67 69 6E 2D 6F 
1A44F10 	75 74 2D 72 69 6E 67 8E 
1A44F18 	E8 4E A4  1 20 40 A0  1 
   " begin-out-ring" $call-parent
1A44F20 	9C 53 A0  1  E 62 65 67 
1A44F28 	69 6E 2D 6F 75 74 2D 72 
1A44F30 	69 6E 67  0 DC 31 A2  1 
;
1A44F38 	58 46 A0  1 
: end-out-ring   ( -- )
1A44F3C 	 0  0  0 65 
1A44F40 	6E 64 2D 6F 75 74 2D 72 
1A44F48 	69 6E 67 8C 1C 4F A4  1 
1A44F50 	20 40 A0  1 
   " end-out-ring" $call-parent
1A44F54 	9C 53 A0  1 
1A44F58 	 C 65 6E 64 2D 6F 75 74 
1A44F60 	2D 72 69 6E 67  0  0  0 
1A44F68 	DC 31 A2  1 
;
1A44F6C 	58 46 A0  1 
: send-out  ( adr len -- qtd )
1A44F70 	 0  0  0 73 65 6E 64 2D 
1A44F78 	6F 75 74 88 50 4F A4  1 
1A44F80 	20 40 A0  1 
   " send-out" $call-parent
1A44F84 	9C 53 A0  1 
1A44F88 	 8 73 65 6E 64 2D 6F 75 
1A44F90 	74  0  0  0 DC 31 A2  1 
;
1A44F98 	58 46 A0  1 
: wait-out  ( qtd -- error? )
1A44F9C 	 0  0  0 77 
1A44FA0 	61 69 74 2D 6F 75 74 88 
1A44FA8 	80 4F A4  1 20 40 A0  1 
   " wait-out" $call-parent
1A44FB0 	9C 53 A0  1  8 77 61 69 
1A44FB8 	74 2D 6F 75 74  0  0  0 
1A44FC0 	DC 31 A2  1 
;
1A44FC4 	58 46 A0  1 

\ Interrupt pipe operations
: begin-intr-in  ( buf len pipe interval -- )
1A44FC8 	 0  0 62 65 67 69 6E 2D 
1A44FD0 	69 6E 74 72 2D 69 6E 8D 
1A44FD8 	AC 4F A4  1 20 40 A0  1 
   " begin-intr-in" $call-parent
1A44FE0 	9C 53 A0  1  D 62 65 67 
1A44FE8 	69 6E 2D 69 6E 74 72 2D 
1A44FF0 	69 6E  0  0 DC 31 A2  1 
;
1A44FF8 	58 46 A0  1 
: intr-in?  ( -- actual usberr )
1A44FFC 	 0  0  0 69 
1A45000 	6E 74 72 2D 69 6E 3F 88 
1A45008 	DC 4F A4  1 20 40 A0  1 
   " intr-in?" $call-parent
1A45010 	9C 53 A0  1  8 69 6E 74 
1A45018 	72 2D 69 6E 3F  0  0  0 
1A45020 	DC 31 A2  1 
;
1A45024 	58 46 A0  1 
: restart-intr-in  ( -- )
1A45028 	72 65 73 74 61 72 74 2D 
1A45030 	69 6E 74 72 2D 69 6E 8F 
1A45038 	 C 50 A4  1 20 40 A0  1 
   " restart-intr-in" $call-parent
1A45040 	9C 53 A0  1  F 72 65 73 
1A45048 	74 61 72 74 2D 69 6E 74 
1A45050 	72 2D 69 6E  0  0  0  0 
1A45058 	DC 31 A2  1 
;
1A4505C 	58 46 A0  1 
: end-intr-in  ( -- )
1A45060 	65 6E 64 2D 69 6E 74 72 
1A45068 	2D 69 6E 8B 3C 50 A4  1 
1A45070 	20 40 A0  1 
   " end-intr-in" $call-parent
1A45074 	9C 53 A0  1 
1A45078 	 B 65 6E 64 2D 69 6E 74 
1A45080 	72 2D 69 6E  0  0  0  0 
1A45088 	DC 31 A2  1 
;
1A4508C 	58 46 A0  1 
: reset-bulk-toggles  ( bulk-in-pipe bulk-out-pipe -- )
1A45090 	 0 72 65 73 65 74 2D 62 
1A45098 	75 6C 6B 2D 74 6F 67 67 
1A450A0 	6C 65 73 92 70 50 A4  1 
1A450A8 	20 40 A0  1 
   " reset-bulk-toggles" $call-parent
1A450AC 	9C 53 A0  1 
1A450B0 	12 72 65 73 65 74 2D 62 
1A450B8 	75 6C 6B 2D 74 6F 67 67 
1A450C0 	6C 65 73  0 DC 31 A2  1 
;
1A450C8 	58 46 A0  1 

: reset?  ( -- flag )
1A450CC 	 0 72 65 73 
1A450D0 	65 74 3F 86 A8 50 A4  1 
1A450D8 	20 40 A0  1 
   " reset?" $call-parent
1A450DC 	9C 53 A0  1 
1A450E0 	 6 72 65 73 65 74 3F  0 
1A450E8 	DC 31 A2  1 
;
1A450EC 	58 46 A0  1 

headers

OpenFirmware/dev/usb2/hcd/hcd-call.fth_AL	A9C 1A450F0 purpose: Vendor/product table manipulation

headers
hex

\ Each vendor/product table has two fields (each /w length).
\ XXX May consider expanding the table to include a name field for each
\ XXX entry so that we can support drastically different devices without
\ XXX resorting to a super driver.

/w 2* constant /vendor-product
1A450F0 	2F 76 65 6E 64 6F 72 2D 
1A450F8 	70 72 6F 64 75 63 74 8F 
1A45100 	D8 50 A4  1 68 40 A0  1 
1A45108 	 4  0  0  0 

: find-vendor-product?  ( vid pid list /list -- flag )
1A4510C 	 0  0  0 66 
1A45110 	69 6E 64 2D 76 65 6E 64 
1A45118 	6F 72 2D 70 72 6F 64 75 
1A45120 	63 74 3F 94  4 51 A4  1 
1A45128 	20 40 A0  1 
   >r >r 0 -rot r> r>  bounds  ?do
1A4512C 	BC 45 A0  1 
1A45130 	BC 45 A0  1 70 6F A0  1 
1A45138 	94 49 A0  1 D0 45 A0  1 
1A45140 	D0 45 A0  1 F0 6D A0  1 
1A45148 	50 42 A0  1 54  0  0  0 
      over i w@ = 		( flag vid pid vid=? )
1A45150 	54 49 A0  1 B4 42 A0  1 
1A45158 	94 4C A0  1 24 48 A0  1 
      over i wa1+ w@ = and	( flag vid pid flag' )
1A45160 	54 49 A0  1 B4 42 A0  1 
1A45168 	A0 50 A0  1 94 4C A0  1 
1A45170 	24 48 A0  1 5C 44 A0  1 
      if  rot drop true -rot leave  then	( flag vid pid )
1A45178 	DC 41 A0  1 18  0  0  0 
1A45180 	7C 49 A0  1 30 49 A0  1 
1A45188 	 4 70 A0  1 94 49 A0  1 
1A45190 	18 43 A0  1 
   /vendor-product +loop 	( flag' vid pid )
1A45194 	 4 51 A4  1 
1A45198 	1C 42 A0  1 B4 FF FF FF 
   2drop
1A451A0 	AC 49 A0  1 
;
1A451A4 	58 46 A0  1 


OpenFirmware/dev/usb2/vendor.fth_AL	B8 1A451A8 purpose: Common USB control pipe API

hex

defer (control-get-m)
1A451A8 	28 63 6F 6E 74 72 6F 6C 
1A451B0 	2D 67 65 74 2D 6D 29 8F 
1A451B8 	28 51 A4  1 5C 40 A0  1 
1A451C0 	EC  D  0  0 
defer (control-set-m)
1A451C4 	28 63 6F 6E 
1A451C8 	74 72 6F 6C 2D 73 65 74 
1A451D0 	2D 6D 29 8F BC 51 A4  1 
1A451D8 	5C 40 A0  1 F0  D  0  0 
defer (control-set-nostat-m)
1A451E0 	 0 28 63 6F 6E 74 72 6F 
1A451E8 	6C 2D 73 65 74 2D 6E 6F 
1A451F0 	73 74 61 74 2D 6D 29 96 
1A451F8 	D8 51 A4  1 5C 40 A0  1 
1A45200 	F4  D  0  0 
defer set-my-dev
1A45204 	 0 73 65 74 
1A45208 	2D 6D 79 2D 64 65 76 8A 
1A45210 	FC 51 A4  1 5C 40 A0  1 
1A45218 	F8  D  0  0 
defer set-real-dev-m
1A4521C 	 0 73 65 74 
1A45220 	2D 72 65 61 6C 2D 64 65 
1A45228 	76 2D 6D 8E 14 52 A4  1 
1A45230 	5C 40 A0  1 FC  D  0  0 


: setup-buf-arg  ( -- sbuf sphy slen )  setup-buf setup-buf-phys /dr  ;
1A45238 	 0  0 73 65 74 75 70 2D 
1A45240 	62 75 66 2D 61 72 67 8D 
1A45248 	30 52 A4  1 20 40 A0  1 
1A45250 	8C 3C A4  1 A8 3C A4  1 
1A45258 	4C 30 A4  1 58 46 A0  1 
: cfg-buf-arg    ( -- cbuf cphy )       cfg-buf cfg-buf-phys  ;
1A45260 	63 66 67 2D 62 75 66 2D 
1A45268 	61 72 67 8B 4C 52 A4  1 
1A45270 	20 40 A0  1 BC 3C A4  1 
1A45278 	D8 3C A4  1 58 46 A0  1 

: fill-setup-buf  ( len idx value rtype req -- )
1A45280 	 0 66 69 6C 6C 2D 73 65 
1A45288 	74 75 70 2D 62 75 66 8E 
1A45290 	70 52 A4  1 20 40 A0  1 
   setup-buf dup /dr  erase			( len idx value rtype req vpcbp )
1A45298 	8C 3C A4  1 40 49 A0  1 
1A452A0 	4C 30 A4  1 F0 72 A0  1 
   tuck >dr-request c!				( len idx value rtype vpcbp )
1A452A8 	E8 46 A0  1 F8 2F A4  1 
1A452B0 	B8 4D A0  1 
   tuck >dr-rtype c!				( len idx value vpcbp )
1A452B4 	E8 46 A0  1 
1A452B8 	E0 2F A4  1 B8 4D A0  1 
   tuck >dr-value le-w!				( len idx vpcbp )
1A452C0 	E8 46 A0  1 10 30 A4  1 
1A452C8 	88 35 A4  1 
   tuck >dr-index le-w!				( len vpcbp )
1A452CC 	E8 46 A0  1 
1A452D0 	28 30 A4  1 88 35 A4  1 
   >dr-len le-w!				( )
1A452D8 	3C 30 A4  1 88 35 A4  1 
   setup-buf setup-buf-phys /dr dma-push	( )
1A452E0 	8C 3C A4  1 A8 3C A4  1 
1A452E8 	4C 30 A4  1 FC 36 A4  1 
;
1A452F0 	58 46 A0  1 

external
: control-get  ( adr len idx value rtype req -- actual usberr )
1A452F4 	63 6F 6E 74 
1A452F8 	72 6F 6C 2D 67 65 74 8B 
1A45300 	94 52 A4  1 20 40 A0  1 
   4 pick >r					( adr len idx value rtype req )  ( R: len )
1A45308 	B0 6F A0  1  C 4A A0  1 
1A45310 	BC 45 A0  1 
   fill-setup-buf				( adr )  ( R: len )
1A45314 	94 52 A4  1 
   setup-buf-arg cfg-buf-arg r@  (control-get-m)	( adr actual usberr )  ( R: len )
1A45318 	4C 52 A4  1 70 52 A4  1 
1A45320 	E4 45 A0  1 BC 51 A4  1 
   dup  if
1A45328 	40 49 A0  1 DC 41 A0  1 
1A45330 	24  0  0  0 
      r> drop nip nip 0 swap			( actual usberr )
1A45334 	D0 45 A0  1 
1A45338 	30 49 A0  1 FC 46 A0  1 
1A45340 	FC 46 A0  1 70 6F A0  1 
1A45348 	68 49 A0  1 
   else
1A4534C 	C8 41 A0  1 
1A45350 	24  0  0  0 
      -rot r> min tuck cfg-buf -rot move swap	( actual usberr )
1A45354 	94 49 A0  1 
1A45358 	D0 45 A0  1 74 4A A0  1 
1A45360 	E8 46 A0  1 BC 3C A4  1 
1A45368 	94 49 A0  1 F4 4A A0  1 
1A45370 	68 49 A0  1 
   then
;
1A45374 	58 46 A0  1 

: control-set  ( adr len idx value rtype req -- usberr )
1A45378 	63 6F 6E 74 72 6F 6C 2D 
1A45380 	73 65 74 8B  4 53 A4  1 
1A45388 	20 40 A0  1 
   5 pick ?dup  if  cfg-buf 6 pick move	 then	( adr len idx value rtype req )
1A4538C 	C0 6F A0  1 
1A45390 	 C 4A A0  1 B4 70 A0  1 
1A45398 	DC 41 A0  1 14  0  0  0 
1A453A0 	BC 3C A4  1 D0 6F A0  1 
1A453A8 	 C 4A A0  1 F4 4A A0  1 
   4 pick >r					( adr )  ( R: len )
1A453B0 	B0 6F A0  1  C 4A A0  1 
1A453B8 	BC 45 A0  1 
   fill-setup-buf drop				( )  ( R: len )
1A453BC 	94 52 A4  1 
1A453C0 	30 49 A0  1 
   setup-buf-arg cfg-buf-arg r>  (control-set-m) 	( usberr )
1A453C4 	4C 52 A4  1 
1A453C8 	70 52 A4  1 D0 45 A0  1 
1A453D0 	D8 51 A4  1 
;
1A453D4 	58 46 A0  1 

: control-set-nostat  ( adr len idx value rtype req -- usberr )
1A453D8 	 0 63 6F 6E 74 72 6F 6C 
1A453E0 	2D 73 65 74 2D 6E 6F 73 
1A453E8 	74 61 74 92 88 53 A4  1 
1A453F0 	20 40 A0  1 
   5 pick ?dup  if  cfg-buf 6 pick move	 then	( adr len idx value rtype req )
1A453F4 	C0 6F A0  1 
1A453F8 	 C 4A A0  1 B4 70 A0  1 
1A45400 	DC 41 A0  1 14  0  0  0 
1A45408 	BC 3C A4  1 D0 6F A0  1 
1A45410 	 C 4A A0  1 F4 4A A0  1 
   4 pick >r					( adr )  ( R: len )
1A45418 	B0 6F A0  1  C 4A A0  1 
1A45420 	BC 45 A0  1 
   fill-setup-buf drop				( )  ( R: len )
1A45424 	94 52 A4  1 
1A45428 	30 49 A0  1 
   setup-buf-arg cfg-buf-arg r>  (control-set-nostat-m)	( usberr )
1A4542C 	4C 52 A4  1 
1A45430 	70 52 A4  1 D0 45 A0  1 
1A45438 	FC 51 A4  1 
;
1A4543C 	58 46 A0  1 

headers

: set-address  ( dev -- usberr )
1A45440 	73 65 74 2D 61 64 64 72 
1A45448 	65 73 73 8B F0 53 A4  1 
1A45450 	20 40 A0  1 
   " usb-delay" ['] eval catch  if  2drop  else  ms  then
1A45454 	9C 53 A0  1 
1A45458 	 9 75 73 62 2D 64 65 6C 
1A45460 	61 79  0  0 60 53 A0  1 
1A45468 	D8 E5 A0  1 14 7F A0  1 
1A45470 	DC 41 A0  1 10  0  0  0 
1A45478 	AC 49 A0  1 C8 41 A0  1 
1A45480 	 8  0  0  0 60 E0 A1  1 

   \ To get the right characteristics for dev in control-set, then normal
   \ set-my-dev is nooped.  We set my-dev and my-real-dev here instead.
   ['] set-my-dev behavior swap			( xt dev )	\ Save set-my-dev
1A45488 	60 53 A0  1 14 52 A4  1 
1A45490 	10 C7 A0  1 68 49 A0  1 
   ['] noop to set-my-dev			( xt dev )	\ Make it noop
1A45498 	60 53 A0  1 64 4F A0  1 
1A454A0 	98 40 A0  1 14 52 A4  1 
   dup >r					( xt dev )  ( R: dev )
1A454A8 	40 49 A0  1 BC 45 A0  1 
   0 set-real-dev-m				( xt )  ( R: dev )
1A454B0 	70 6F A0  1 30 52 A4  1 

   0 0 0 r@ DR_OUT DR_DEVICE or SET_ADDRESS control-set  if
1A454B8 	70 6F A0  1 70 6F A0  1 
1A454C0 	70 6F A0  1 E4 45 A0  1 
1A454C8 	60 30 A4  1 D4 30 A4  1 
1A454D0 	70 44 A0  1 18 32 A4  1 
1A454D8 	88 53 A4  1 DC 41 A0  1 
1A454E0 	3C  0  0  0 
      ." Failed to set device address: " r> u. cr
1A454E4 	20 7C A0  1 
1A454E8 	1E 46 61 69 6C 65 64 20 
1A454F0 	74 6F 20 73 65 74 20 64 
1A454F8 	65 76 69 63 65 20 61 64 
1A45500 	64 72 65 73 73 3A 20  0 
1A45508 	D0 45 A0  1 C8 77 A0  1 
1A45510 	80 6D A0  1 
   else
1A45514 	C8 41 A0  1 
1A45518 	18  0  0  0 
      r> drop
1A4551C 	D0 45 A0  1 
1A45520 	30 49 A0  1 
      d# 10 ms        				\ Let the SET_ADDRESS settle
1A45524 	58 41 A0  1 
1A45528 	 A  0  0  0 60 E0 A1  1 
   then						( xt )

   to set-my-dev				\ Restore set-my-dev
1A45530 	98 40 A0  1 14 52 A4  1 
   usb-error
1A45538 	D0 40 A4  1 
;
1A4553C 	58 46 A0  1 

external

: get-desc  ( adr len lang didx dtype rtype -- actual usberr )
1A45540 	 0  0  0 67 65 74 2D 64 
1A45548 	65 73 63 88 50 54 A4  1 
1A45550 	20 40 A0  1 
   -rot bwjoin swap DR_IN or GET_DESCRIPTOR control-get
1A45554 	94 49 A0  1 
1A45558 	84 FB A0  1 68 49 A0  1 
1A45560 	74 30 A4  1 70 44 A0  1 
1A45568 	B4 31 A4  1  4 53 A4  1 
;
1A45570 	58 46 A0  1 

: get-status  ( adr len intf/endp rtype -- actual usberr )
1A45574 	 0 67 65 74 
1A45578 	2D 73 74 61 74 75 73 8A 
1A45580 	50 55 A4  1 20 40 A0  1 
   0 swap DR_IN or GET_STATUS control-get
1A45588 	70 6F A0  1 68 49 A0  1 
1A45590 	74 30 A4  1 70 44 A0  1 
1A45598 	 0 32 A4  1  4 53 A4  1 
;
1A455A0 	58 46 A0  1 

: set-config-m  ( cfg -- usberr )
1A455A4 	 0  0  0 73 
1A455A8 	65 74 2D 63 6F 6E 66 69 
1A455B0 	67 2D 6D 8C 84 55 A4  1 
1A455B8 	20 40 A0  1 
   >r 0 0 0 r> DR_DEVICE DR_OUT or SET_CONFIGURATION control-set 
1A455BC 	BC 45 A0  1 
1A455C0 	70 6F A0  1 70 6F A0  1 
1A455C8 	70 6F A0  1 D0 45 A0  1 
1A455D0 	D4 30 A4  1 60 30 A4  1 
1A455D8 	70 44 A0  1 38 32 A4  1 
1A455E0 	88 53 A4  1 
;
1A455E4 	58 46 A0  1 


: set-interface  ( intf alt -- usberr )
1A455E8 	 0  0 73 65 74 2D 69 6E 
1A455F0 	74 65 72 66 61 63 65 8D 
1A455F8 	B8 55 A4  1 20 40 A0  1 
   0 0 2swap DR_INTERFACE DR_OUT or SET_INTERFACE control-set
1A45600 	70 6F A0  1 70 6F A0  1 
1A45608 	F4 49 A0  1 F0 30 A4  1 
1A45610 	60 30 A4  1 70 44 A0  1 
1A45618 	88 32 A4  1 88 53 A4  1 
;
1A45620 	58 46 A0  1 

: clear-feature  ( intf/endp feature rtype -- usberr )
1A45624 	 0  0 63 6C 
1A45628 	65 61 72 2D 66 65 61 74 
1A45630 	75 72 65 8D FC 55 A4  1 
1A45638 	20 40 A0  1 
   >r 0 0 2swap r> DR_OUT or CLEAR_FEATURE control-set
1A4563C 	BC 45 A0  1 
1A45640 	70 6F A0  1 70 6F A0  1 
1A45648 	F4 49 A0  1 D0 45 A0  1 
1A45650 	60 30 A4  1 70 44 A0  1 
1A45658 	78 31 A4  1 88 53 A4  1 
;
1A45660 	58 46 A0  1 
: set-feature  ( intf/endp feature rtype -- usberr )
1A45664 	73 65 74 2D 
1A45668 	66 65 61 74 75 72 65 8B 
1A45670 	38 56 A4  1 20 40 A0  1 
   >r 0 0 2swap r> DR_OUT or SET_FEATURE control-set
1A45678 	BC 45 A0  1 70 6F A0  1 
1A45680 	70 6F A0  1 F4 49 A0  1 
1A45688 	D0 45 A0  1 60 30 A4  1 
1A45690 	70 44 A0  1 6C 32 A4  1 
1A45698 	88 53 A4  1 
;
1A4569C 	58 46 A0  1 

headers


: (unstall-pipe)  ( pipe -- )  0 DR_ENDPOINT clear-feature drop  ;
1A456A0 	 0 28 75 6E 73 74 61 6C 
1A456A8 	6C 2D 70 69 70 65 29 8E 
1A456B0 	74 56 A4  1 20 40 A0  1 
1A456B8 	70 6F A0  1  8 31 A4  1 
1A456C0 	38 56 A4  1 30 49 A0  1 
1A456C8 	58 46 A0  1 

external
: get-cfg-desc  ( adr idx -- actual )
1A456CC 	 0  0  0 67 
1A456D0 	65 74 2D 63 66 67 2D 64 
1A456D8 	65 73 63 8C B4 56 A4  1 
1A456E0 	20 40 A0  1 
   swap >r					( idx )  ( R: adr )
1A456E4 	68 49 A0  1 
1A456E8 	BC 45 A0  1 
   r@ 9 0 3 pick CONFIGURATION DR_DEVICE get-desc nip 0=  if
1A456EC 	E4 45 A0  1 
1A456F0 	58 41 A0  1  9  0  0  0 
1A456F8 	70 6F A0  1 A0 6F A0  1 
1A45700 	 C 4A A0  1 D0 32 A4  1 
1A45708 	D4 30 A4  1 50 55 A4  1 
1A45710 	FC 46 A0  1 24 47 A0  1 
1A45718 	DC 41 A0  1 3C  0  0  0 
      r> dup 2 + le-w@ rot 0 swap CONFIGURATION DR_DEVICE get-desc drop	( actual )
1A45720 	D0 45 A0  1 40 49 A0  1 
1A45728 	90 6F A0  1  4 45 A0  1 
1A45730 	2C 35 A4  1 7C 49 A0  1 
1A45738 	70 6F A0  1 68 49 A0  1 
1A45740 	D0 32 A4  1 D4 30 A4  1 
1A45748 	50 55 A4  1 30 49 A0  1 
   else
1A45750 	C8 41 A0  1 10  0  0  0 
      r> 2drop 0				( actual )
1A45758 	D0 45 A0  1 AC 49 A0  1 
1A45760 	70 6F A0  1 
   then
;
1A45764 	58 46 A0  1 
headers

: get-dev-desc  ( adr len -- actual )
1A45768 	 0  0  0 67 65 74 2D 64 
1A45770 	65 76 2D 64 65 73 63 8C 
1A45778 	E0 56 A4  1 20 40 A0  1 
   0 0 DEVICE DR_DEVICE get-desc drop		( actual )
1A45780 	70 6F A0  1 70 6F A0  1 
1A45788 	B4 32 A4  1 D4 30 A4  1 
1A45790 	50 55 A4  1 30 49 A0  1 
;
1A45798 	58 46 A0  1 
: (get-str-desc)  ( adr len lang idx -- actual )
1A4579C 	 0 28 67 65 
1A457A0 	74 2D 73 74 72 2D 64 65 
1A457A8 	73 63 29 8E 7C 57 A4  1 
1A457B0 	20 40 A0  1 
   STRING DR_DEVICE get-desc drop		( actual )
1A457B4 	E4 32 A4  1 
1A457B8 	D4 30 A4  1 50 55 A4  1 
1A457C0 	30 49 A0  1 
;
1A457C4 	58 46 A0  1 
: get-str-desc  ( adr lang idx -- actual )
1A457C8 	 0  0  0 67 65 74 2D 73 
1A457D0 	74 72 2D 64 65 73 63 8C 
1A457D8 	B0 57 A4  1 20 40 A0  1 
   3dup 2 -rot (get-str-desc) 0=  if  3drop 0 exit  then	\ Read the length
1A457E0 	6C 3F A4  1 90 6F A0  1 
1A457E8 	94 49 A0  1 B0 57 A4  1 
1A457F0 	24 47 A0  1 DC 41 A0  1 
1A457F8 	10  0  0  0 98 3F A4  1 
1A45800 	70 6F A0  1 40 46 A0  1 
   >r 2dup r>					( adr lang adr lang idx )
1A45808 	BC 45 A0  1 C0 49 A0  1 
1A45810 	D0 45 A0  1 
   2 pick c@ -rot  (get-str-desc) 0=  if  2drop 0 exit  then	\ Then read the whole string
1A45814 	90 6F A0  1 
1A45818 	 C 4A A0  1 C4 4C A0  1 
1A45820 	94 49 A0  1 B0 57 A4  1 
1A45828 	24 47 A0  1 DC 41 A0  1 
1A45830 	10  0  0  0 AC 49 A0  1 
1A45838 	70 6F A0  1 40 46 A0  1 
   						( adr lang )
   encoded$>ascii$				( )
1A45840 	C8 3B A4  1 
;
1A45844 	58 46 A0  1 

headers
: controlfth
1A45848 	 0 63 6F 6E 74 72 6F 6C 
1A45850 	66 74 68 8A DC 57 A4  1 
1A45858 	20 40 A0  1 

\ s" ' (unstall-pipe) to unstall-pipe" eval

s" alias set-config set-config-m" eval
1A4585C 	9C 53 A0  1 
1A45860 	1D 61 6C 69 61 73 20 73 
1A45868 	65 74 2D 63 6F 6E 66 69 
1A45870 	67 20 73 65 74 2D 63 6F 
1A45878 	6E 66 69 67 2D 6D  0  0 
1A45880 	D8 E5 A0  1 

\ Must be called after set-config for any device with bulk-in or
\ bulk-out pipes.  Pass in 0 if one of the pipes is nonexistent.
s" : reset-bulk-toggles" eval  ( bulk-in-pipe bulk-out-pipe -- )
1A45884 	9C 53 A0  1 
1A45888 	14 3A 20 72 65 73 65 74 
1A45890 	2D 62 75 6C 6B 2D 74 6F 
1A45898 	67 67 6C 65 73  0  0  0 
1A458A0 	D8 E5 A0  1 
s"    ?dup   if  0 swap  target  di-out-data!  then" eval
1A458A4 	9C 53 A0  1 
1A458A8 	30 20 20 20 3F 64 75 70 
1A458B0 	20 20 20 69 66 20 20 30 
1A458B8 	20 73 77 61 70 20 20 74 
1A458C0 	61 72 67 65 74 20 20 64 
1A458C8 	69 2D 6F 75 74 2D 64 61 
1A458D0 	74 61 21 20 20 74 68 65 
1A458D8 	6E  0  0  0 D8 E5 A0  1 
s"    ?dup   if  0 swap  target  di-in-data!   then ;" eval
1A458E0 	9C 53 A0  1 32 20 20 20 
1A458E8 	3F 64 75 70 20 20 20 69 
1A458F0 	66 20 20 30 20 73 77 61 
1A458F8 	70 20 20 74 61 72 67 65 
1A45900 	74 20 20 64 69 2D 69 6E 
1A45908 	2D 64 61 74 61 21 20 20 
1A45910 	20 74 68 65 6E 20 3B  0 
1A45918 	D8 E5 A0  1 

s" : set-pipe-maxpayload" eval  ( size pipe -- )
1A4591C 	9C 53 A0  1 
1A45920 	15 3A 20 73 65 74 2D 70 
1A45928 	69 70 65 2D 6D 61 78 70 
1A45930 	61 79 6C 6F 61 64  0  0 
1A45938 	D8 E5 A0  1 
s"    target di-maxpayload! ;" eval
1A4593C 	9C 53 A0  1 
1A45940 	1A 20 20 20 74 61 72 67 
1A45948 	65 74 20 64 69 2D 6D 61 
1A45950 	78 70 61 79 6C 6F 61 64 
1A45958 	21 20 3B  0 D8 E5 A0  1 

\ Returns true the first time it is called for a given target device
\ after a reset of the USB subsystem.  Used for reinitializing hardware.

s" : reset?  ( -- flag )  target di-reset?  ;" eval
1A45960 	9C 53 A0  1 2A 3A 20 72 
1A45968 	65 73 65 74 3F 20 20 28 
1A45970 	20 2D 2D 20 66 6C 61 67 
1A45978 	20 29 20 20 74 61 72 67 
1A45980 	65 74 20 64 69 2D 72 65 
1A45988 	73 65 74 3F 20 20 3B  0 
1A45990 	D8 E5 A0  1 


s" ' (control-get) is (control-get-m)" eval
1A45994 	9C 53 A0  1 
1A45998 	22 27 20 28 63 6F 6E 74 
1A459A0 	72 6F 6C 2D 67 65 74 29 
1A459A8 	20 69 73 20 28 63 6F 6E 
1A459B0 	74 72 6F 6C 2D 67 65 74 
1A459B8 	2D 6D 29  0 D8 E5 A0  1 
s" ' (control-set) is (control-set-m)" eval
1A459C0 	9C 53 A0  1 22 27 20 28 
1A459C8 	63 6F 6E 74 72 6F 6C 2D 
1A459D0 	73 65 74 29 20 69 73 20 
1A459D8 	28 63 6F 6E 74 72 6F 6C 
1A459E0 	2D 73 65 74 2D 6D 29  0 
1A459E8 	D8 E5 A0  1 
s" ' (control-set-nostat) is (control-set-nostat-m)" eval
1A459EC 	9C 53 A0  1 
1A459F0 	30 27 20 28 63 6F 6E 74 
1A459F8 	72 6F 6C 2D 73 65 74 2D 
1A45A00 	6E 6F 73 74 61 74 29 20 
1A45A08 	69 73 20 28 63 6F 6E 74 
1A45A10 	72 6F 6C 2D 73 65 74 2D 
1A45A18 	6E 6F 73 74 61 74 2D 6D 
1A45A20 	29  0  0  0 D8 E5 A0  1 
s" ' set-real-dev is set-real-dev-m" eval
1A45A28 	9C 53 A0  1 20 27 20 73 
1A45A30 	65 74 2D 72 65 61 6C 2D 
1A45A38 	64 65 76 20 69 73 20 73 
1A45A40 	65 74 2D 72 65 61 6C 2D 
1A45A48 	64 65 76 2D 6D  0  0  0 
1A45A50 	D8 E5 A0  1 
;
1A45A54 	58 46 A0  1 

OpenFirmware/dev/usb2/hcd/control.fth_AL	8B0 1A45A58 purpose: Load USB device fcode driver

hex
headers

false value probemsg?	\ Optional probing messages
1A45A58 	 0  0 70 72 6F 62 65 6D 
1A45A60 	73 67 3F 89 58 58 A4  1 
1A45A68 	50 40 A0  1  0  E  0  0 

\ $load-driver executes an FCode driver that is stored somewhere
\ other than on the device itself.

: $load  ( name$ -- done? )  " $load-driver" evaluate  ;
1A45A70 	 0  0 24 6C 6F 61 64 85 
1A45A78 	68 5A A4  1 20 40 A0  1 
1A45A80 	9C 53 A0  1  C 24 6C 6F 
1A45A88 	61 64 2D 64 72 69 76 65 
1A45A90 	72  0  0  0 D8 E5 A0  1 
1A45A98 	58 46 A0  1 

\ Words to get my (as a child) properties

: get-int-property  ( name$ -- n )
1A45A9C 	 0  0  0 67 
1A45AA0 	65 74 2D 69 6E 74 2D 70 
1A45AA8 	72 6F 70 65 72 74 79 90 
1A45AB0 	7C 5A A4  1 20 40 A0  1 
   get-my-property 0=  if  decode-int nip nip  else  0  then
1A45AB8 	1C 34 A2  1 24 47 A0  1 
1A45AC0 	DC 41 A0  1 18  0  0  0 
1A45AC8 	68 F7 A1  1 FC 46 A0  1 
1A45AD0 	FC 46 A0  1 C8 41 A0  1 
1A45AD8 	 8  0  0  0 70 6F A0  1 
;
1A45AE0 	58 46 A0  1 
: get-class-properties  ( -- class subclass protocol )
1A45AE4 	 0  0  0 67 
1A45AE8 	65 74 2D 63 6C 61 73 73 
1A45AF0 	2D 70 72 6F 70 65 72 74 
1A45AF8 	69 65 73 94 B4 5A A4  1 
1A45B00 	20 40 A0  1 
   " class"    get-int-property
1A45B04 	9C 53 A0  1 
1A45B08 	 5 63 6C 61 73 73  0  0 
1A45B10 	B4 5A A4  1 
   " subclass" get-int-property
1A45B14 	9C 53 A0  1 
1A45B18 	 8 73 75 62 63 6C 61 73 
1A45B20 	73  0  0  0 B4 5A A4  1 
   " protocol" get-int-property
1A45B28 	9C 53 A0  1  8 70 72 6F 
1A45B30 	74 6F 63 6F 6C  0  0  0 
1A45B38 	B4 5A A4  1 
;
1A45B3C 	58 46 A0  1 
: get-vendor-properties  ( -- vendor product release )
1A45B40 	 0  0 67 65 74 2D 76 65 
1A45B48 	6E 64 6F 72 2D 70 72 6F 
1A45B50 	70 65 72 74 69 65 73 95 
1A45B58 	 0 5B A4  1 20 40 A0  1 
   " vendor-id" get-int-property
1A45B60 	9C 53 A0  1  9 76 65 6E 
1A45B68 	64 6F 72 2D 69 64  0  0 
1A45B70 	B4 5A A4  1 
   " device-id" get-int-property
1A45B74 	9C 53 A0  1 
1A45B78 	 9 64 65 76 69 63 65 2D 
1A45B80 	69 64  0  0 B4 5A A4  1 
   " release"   get-int-property
1A45B88 	9C 53 A0  1  7 72 65 6C 
1A45B90 	65 61 73 65  0  0  0  0 
1A45B98 	B4 5A A4  1 
;
1A45B9C 	58 46 A0  1 

\ Some little pieces for easy formatting of USB name strings

: $hold  ( adr len -- )
1A45BA0 	 0  0 24 68 6F 6C 64 85 
1A45BA8 	5C 5B A4  1 20 40 A0  1 
   dup  if  bounds swap 1-  ?do  i c@ hold  -1 +loop  else  2drop  then
1A45BB0 	40 49 A0  1 DC 41 A0  1 
1A45BB8 	3C  0  0  0 F0 6D A0  1 
1A45BC0 	68 49 A0  1 54 4B A0  1 
1A45BC8 	50 42 A0  1 20  0  0  0 
1A45BD0 	B4 42 A0  1 C4 4C A0  1 
1A45BD8 	DC 75 A0  1 58 41 A0  1 
1A45BE0 	FF FF FF FF 1C 42 A0  1 
1A45BE8 	E8 FF FF FF C8 41 A0  1 
1A45BF0 	 8  0  0  0 AC 49 A0  1 
;
1A45BF8 	58 46 A0  1 

: usb#>   ( n -- )  " usb" $hold  0 u#> ;     \ Prepends: usb
1A45BFC 	 0  0 75 73 
1A45C00 	62 23 3E 85 AC 5B A4  1 
1A45C08 	20 40 A0  1 9C 53 A0  1 
1A45C10 	 3 75 73 62  0  0  0  0 
1A45C18 	AC 5B A4  1 70 6F A0  1 
1A45C20 	E0 76 A0  1 58 46 A0  1 
: #usb#>  ( n -- )  u#s drop  usb#>  ;        \ Prepends: usbN
1A45C28 	 0 23 75 73 62 23 3E 86 
1A45C30 	 8 5C A4  1 20 40 A0  1 
1A45C38 	BC 76 A0  1 30 49 A0  1 
1A45C40 	 8 5C A4  1 58 46 A0  1 
: #,      ( n -- )  u#s drop ascii , hold  ;  \ Prepends: ,N
1A45C48 	 0 23 2C 82 34 5C A4  1 
1A45C50 	20 40 A0  1 BC 76 A0  1 
1A45C58 	30 49 A0  1 58 41 A0  1 
1A45C60 	2C  0  0  0 DC 75 A0  1 
1A45C68 	58 46 A0  1 
: #.      ( n -- )  u#s drop ascii . hold  ;  \ Prepends: .N
1A45C6C 	 0 23 2E 82 
1A45C70 	50 5C A4  1 20 40 A0  1 
1A45C78 	BC 76 A0  1 30 49 A0  1 
1A45C80 	58 41 A0  1 2E  0  0  0 
1A45C88 	DC 75 A0  1 58 46 A0  1 

: ?#,  ( n level test-level -- )   \ Prepends: ,N  if levels match
1A45C90 	3F 23 2C 83 74 5C A4  1 
1A45C98 	20 40 A0  1 
   >=  if  #,  else  drop  then
1A45C9C 	EC 48 A0  1 
1A45CA0 	DC 41 A0  1 10  0  0  0 
1A45CA8 	50 5C A4  1 C8 41 A0  1 
1A45CB0 	 8  0  0  0 30 49 A0  1 
;
1A45CB8 	58 46 A0  1 

: device$  ( -- adr len )
1A45CBC 	64 65 76 69 
1A45CC0 	63 65 24 87 98 5C A4  1 
1A45CC8 	20 40 A0  1 
   get-vendor-properties drop  		( vendor-id device-id )
1A45CCC 	5C 5B A4  1 
1A45CD0 	30 49 A0  1 
   push-hex
1A45CD4 	5C F4 A0  1 
   <# #, #usb#>
1A45CD8 	 8 76 A0  1 50 5C A4  1 
1A45CE0 	34 5C A4  1 
   pop-base
1A45CE4 	9C F4 A0  1 
;
1A45CE8 	58 46 A0  1 

\ Return a string of the form usb,classC[,S[,P]] depending on level
\ Level: 0 -> C   1 -> C,S   2 -> C,S,P
: class$  ( level -- name$ )  
1A45CEC 	 0 63 6C 61 
1A45CF0 	73 73 24 86 C8 5C A4  1 
1A45CF8 	20 40 A0  1 
   >r  get-class-properties  r>	      ( class subclass protocol level )
1A45CFC 	BC 45 A0  1 
1A45D00 	 0 5B A4  1 D0 45 A0  1 
   push-hex                           ( class subclass protocol level )
1A45D08 	5C F4 A0  1 
   <#                                 ( class subclass protocol level )
1A45D0C 	 8 76 A0  1 
      tuck                            ( class subclass level protocol level )
1A45D10 	E8 46 A0  1 
      2 ?#,                           ( class subclass level )
1A45D14 	90 6F A0  1 
1A45D18 	98 5C A4  1 
      1 ?#,                           ( class )
1A45D1C 	80 6F A0  1 
1A45D20 	98 5C A4  1 
      u#s " usb,class" $hold          ( )
1A45D24 	BC 76 A0  1 
1A45D28 	9C 53 A0  1  9 75 73 62 
1A45D30 	2C 63 6C 61 73 73  0  0 
1A45D38 	AC 5B A4  1 
   u#>
1A45D3C 	E0 76 A0  1 
   pop-base
1A45D40 	9C F4 A0  1 
;
1A45D44 	58 46 A0  1 

: usb-storage?  ( -- flag )
1A45D48 	 0  0  0 75 73 62 2D 73 
1A45D50 	74 6F 72 61 67 65 3F 8C 
1A45D58 	F8 5C A4  1 20 40 A0  1 
   get-class-properties			( class subclass protocol )
1A45D60 	 0 5B A4  1 
   h# 50 =  rot  8 =  and  if		( subclass )
1A45D64 	58 41 A0  1 
1A45D68 	50  0  0  0 24 48 A0  1 
1A45D70 	7C 49 A0  1 F0 6F A0  1 
1A45D78 	24 48 A0  1 5C 44 A0  1 
1A45D80 	DC 41 A0  1 68  0  0  0 
      dup 2 =  if			\ atapi
1A45D88 	40 49 A0  1 90 6F A0  1 
1A45D90 	24 48 A0  1 DC 41 A0  1 
1A45D98 	30  0  0  0 
         drop  " " " is-atapi" str-property   true
1A45D9C 	30 49 A0  1 
1A45DA0 	9C 53 A0  1  0  0  0  0 
1A45DA8 	9C 53 A0  1  8 69 73 2D 
1A45DB0 	61 74 61 70 69  0  0  0 
1A45DB8 	50 3C A4  1  4 70 A0  1 
      else
1A45DC0 	C8 41 A0  1 20  0  0  0 
         dup 5 = swap 6 = or		\ removable, scsi
1A45DC8 	40 49 A0  1 C0 6F A0  1 
1A45DD0 	24 48 A0  1 68 49 A0  1 
1A45DD8 	D0 6F A0  1 24 48 A0  1 
1A45DE0 	70 44 A0  1 
      then
   else
1A45DE4 	C8 41 A0  1 
1A45DE8 	 C  0  0  0 
      drop false
1A45DEC 	30 49 A0  1 
1A45DF0 	18 70 A0  1 
   then
;
1A45DF4 	58 46 A0  1 


: load-fcode-driver  ( -- )
1A45DF8 	 0  0 6C 6F 61 64 2D 66 
1A45E00 	63 6F 64 65 2D 64 72 69 
1A45E08 	76 65 72 91 5C 5D A4  1 
1A45E10 	20 40 A0  1 

   usb-storage?    if s" d:include\dev\usbm\device\storage\storage.fth" included then
1A45E14 	5C 5D A4  1 
1A45E18 	DC 41 A0  1 3C  0  0  0 
1A45E20 	9C 53 A0  1 2D 64 3A 69 
1A45E28 	6E 63 6C 75 64 65 5C 64 
1A45E30 	65 76 5C 75 73 62 6D 5C 
1A45E38 	64 65 76 69 63 65 5C 73 
1A45E40 	74 6F 72 61 67 65 5C 73 
1A45E48 	74 6F 72 61 67 65 2E 66 
1A45E50 	74 68  0  0 C8 E8 A0  1 
;
1A45E58 	58 46 A0  1 


OpenFirmware/dev/usb2/hcd/fcode.fth_AL	404 1A45E5C 
hex
headers

defer make-dev-property-hook  ( speed dev port -- )
1A45E5C 	 0 6D 61 6B 
1A45E60 	65 2D 64 65 76 2D 70 72 
1A45E68 	6F 70 65 72 74 79 2D 68 
1A45E70 	6F 6F 6B 96 10 5E A4  1 
1A45E78 	5C 40 A0  1  4  E  0  0 
' 3drop to make-dev-property-hook

\ Buffers for descriptor manipulation
0 value cfg-desc-buf			\ Configuration Descriptor
1A45E80 	 0  0  0 63 66 67 2D 64 
1A45E88 	65 73 63 2D 62 75 66 8C 
1A45E90 	78 5E A4  1 50 40 A0  1 
1A45E98 	 8  E  0  0 
0 value dev-desc-buf			\ Device Descriptor
1A45E9C 	 0  0  0 64 
1A45EA0 	65 76 2D 64 65 73 63 2D 
1A45EA8 	62 75 66 8C 94 5E A4  1 
1A45EB0 	50 40 A0  1  C  E  0  0 
0 value d$-desc-buf			\ Device String Descriptor
1A45EB8 	64 24 2D 64 65 73 63 2D 
1A45EC0 	62 75 66 8B B0 5E A4  1 
1A45EC8 	50 40 A0  1 10  E  0  0 
0 value v$-desc-buf			\ Vendor String Descriptor
1A45ED0 	76 24 2D 64 65 73 63 2D 
1A45ED8 	62 75 66 8B C8 5E A4  1 
1A45EE0 	50 40 A0  1 14  E  0  0 
0 value s$-desc-buf			\ Serial Number String Descriptor
1A45EE8 	73 24 2D 64 65 73 63 2D 
1A45EF0 	62 75 66 8B E0 5E A4  1 
1A45EF8 	50 40 A0  1 18  E  0  0 

0 value /cfg-desc-buf			\ Length of data in cfg-desc-buf
1A45F00 	 0  0 2F 63 66 67 2D 64 
1A45F08 	65 73 63 2D 62 75 66 8D 
1A45F10 	F8 5E A4  1 50 40 A0  1 
1A45F18 	1C  E  0  0 
0 value /dev-desc-buf			\ Length of data in dev-desc-buf
1A45F1C 	 0  0 2F 64 
1A45F20 	65 76 2D 64 65 73 63 2D 
1A45F28 	62 75 66 8D 14 5F A4  1 
1A45F30 	50 40 A0  1 20  E  0  0 
0 value /d$-desc-buf			\ Length of data in d$-desc-buf
1A45F38 	 0  0  0 2F 64 24 2D 64 
1A45F40 	65 73 63 2D 62 75 66 8C 
1A45F48 	30 5F A4  1 50 40 A0  1 
1A45F50 	24  E  0  0 
0 value /v$-desc-buf			\ Length of data in v$-desc-buf
1A45F54 	 0  0  0 2F 
1A45F58 	76 24 2D 64 65 73 63 2D 
1A45F60 	62 75 66 8C 4C 5F A4  1 
1A45F68 	50 40 A0  1 28  E  0  0 
0 value /s$-desc-buf			\ Length of data in s$-desc-buf
1A45F70 	 0  0  0 2F 73 24 2D 64 
1A45F78 	65 73 63 2D 62 75 66 8C 
1A45F80 	68 5F A4  1 50 40 A0  1 
1A45F88 	2C  E  0  0 

: alloc-pkt-buf  ( -- )
1A45F8C 	 0  0 61 6C 
1A45F90 	6C 6F 63 2D 70 6B 74 2D 
1A45F98 	62 75 66 8D 84 5F A4  1 
1A45FA0 	20 40 A0  1 
   cfg-desc-buf 0=  if
1A45FA4 	94 5E A4  1 
1A45FA8 	24 47 A0  1 DC 41 A0  1 
1A45FB0 	90  0  0  0 
      /cfg alloc-mem dup to cfg-desc-buf /cfg erase
1A45FB4 	B4 2F A4  1 
1A45FB8 	F0 6C A0  1 40 49 A0  1 
1A45FC0 	B8 40 A0  1 94 5E A4  1 
1A45FC8 	B4 2F A4  1 F0 72 A0  1 
      /cfg alloc-mem dup to dev-desc-buf /cfg erase
1A45FD0 	B4 2F A4  1 F0 6C A0  1 
1A45FD8 	40 49 A0  1 B8 40 A0  1 
1A45FE0 	B0 5E A4  1 B4 2F A4  1 
1A45FE8 	F0 72 A0  1 
      /str alloc-mem dup to d$-desc-buf /str erase
1A45FEC 	C8 2F A4  1 
1A45FF0 	F0 6C A0  1 40 49 A0  1 
1A45FF8 	B8 40 A0  1 C8 5E A4  1 
1A46000 	C8 2F A4  1 F0 72 A0  1 
      /str alloc-mem dup to v$-desc-buf /str erase
1A46008 	C8 2F A4  1 F0 6C A0  1 
1A46010 	40 49 A0  1 B8 40 A0  1 
1A46018 	E0 5E A4  1 C8 2F A4  1 
1A46020 	F0 72 A0  1 
      /str alloc-mem dup to s$-desc-buf /str erase
1A46024 	C8 2F A4  1 
1A46028 	F0 6C A0  1 40 49 A0  1 
1A46030 	B8 40 A0  1 F8 5E A4  1 
1A46038 	C8 2F A4  1 F0 72 A0  1 
   then
;
1A46040 	58 46 A0  1 
: free-pkt-buf  ( -- )
1A46044 	 0  0  0 66 
1A46048 	72 65 65 2D 70 6B 74 2D 
1A46050 	62 75 66 8C A0 5F A4  1 
1A46058 	20 40 A0  1 
   cfg-desc-buf ?dup  if  /cfg free-mem  0 to cfg-desc-buf  then
1A4605C 	94 5E A4  1 
1A46060 	B4 70 A0  1 DC 41 A0  1 
1A46068 	18  0  0  0 B4 2F A4  1 
1A46070 	 8 6D A0  1 70 6F A0  1 
1A46078 	B8 40 A0  1 94 5E A4  1 
   dev-desc-buf ?dup  if  /cfg free-mem  0 to dev-desc-buf  then
1A46080 	B0 5E A4  1 B4 70 A0  1 
1A46088 	DC 41 A0  1 18  0  0  0 
1A46090 	B4 2F A4  1  8 6D A0  1 
1A46098 	70 6F A0  1 B8 40 A0  1 
1A460A0 	B0 5E A4  1 
   d$-desc-buf  ?dup  if  /str free-mem  0 to d$-desc-buf   then
1A460A4 	C8 5E A4  1 
1A460A8 	B4 70 A0  1 DC 41 A0  1 
1A460B0 	18  0  0  0 C8 2F A4  1 
1A460B8 	 8 6D A0  1 70 6F A0  1 
1A460C0 	B8 40 A0  1 C8 5E A4  1 
   v$-desc-buf  ?dup  if  /str free-mem  0 to v$-desc-buf   then
1A460C8 	E0 5E A4  1 B4 70 A0  1 
1A460D0 	DC 41 A0  1 18  0  0  0 
1A460D8 	C8 2F A4  1  8 6D A0  1 
1A460E0 	70 6F A0  1 B8 40 A0  1 
1A460E8 	E0 5E A4  1 
   s$-desc-buf  ?dup  if  /str free-mem  0 to s$-desc-buf   then
1A460EC 	F8 5E A4  1 
1A460F0 	B4 70 A0  1 DC 41 A0  1 
1A460F8 	18  0  0  0 C8 2F A4  1 
1A46100 	 8 6D A0  1 70 6F A0  1 
1A46108 	B8 40 A0  1 F8 5E A4  1 
;
1A46110 	58 46 A0  1 

: dev-desc@  ( index -- byte )  dev-desc-buf + c@  ;
1A46114 	 0  0 64 65 
1A46118 	76 2D 64 65 73 63 40 89 
1A46120 	58 60 A4  1 20 40 A0  1 
1A46128 	B0 5E A4  1  4 45 A0  1 
1A46130 	C4 4C A0  1 58 46 A0  1 
: asso-class?  ( -- asso? )
1A46138 	61 73 73 6F 2D 63 6C 61 
1A46140 	73 73 3F 8B 24 61 A4  1 
1A46148 	20 40 A0  1 
   4 dev-desc@ h# ef =  5 dev-desc@ 2 =  and  6 dev-desc@ 1 =  and
1A4614C 	B0 6F A0  1 
1A46150 	24 61 A4  1 58 41 A0  1 
1A46158 	EF  0  0  0 24 48 A0  1 
1A46160 	C0 6F A0  1 24 61 A4  1 
1A46168 	90 6F A0  1 24 48 A0  1 
1A46170 	5C 44 A0  1 D0 6F A0  1 
1A46178 	24 61 A4  1 80 6F A0  1 
1A46180 	24 48 A0  1 5C 44 A0  1 
;
1A46188 	58 46 A0  1 
: get-class  ( -- class subclass protocol )
1A4618C 	 0  0 67 65 
1A46190 	74 2D 63 6C 61 73 73 89 
1A46198 	48 61 A4  1 20 40 A0  1 
   asso-class?  if
1A461A0 	48 61 A4  1 DC 41 A0  1 
1A461A8 	58  0  0  0 
      \ Class is in interface association descriptor
      true to class-in-dev?
1A461AC 	 4 70 A0  1 
1A461B0 	B8 40 A0  1 34 3A A4  1 
      cfg-desc-buf INTERFACE_ASSO find-desc	( intf-adr )
1A461B8 	94 5E A4  1 30 33 A4  1 
1A461C0 	4C 3A A4  1 
      >r  r@ 4 + c@  r@ 5 + c@   r> 6 + c@	( class subclass protocol )
1A461C4 	BC 45 A0  1 
1A461C8 	E4 45 A0  1 B0 6F A0  1 
1A461D0 	 4 45 A0  1 C4 4C A0  1 
1A461D8 	E4 45 A0  1 C0 6F A0  1 
1A461E0 	 4 45 A0  1 C4 4C A0  1 
1A461E8 	D0 45 A0  1 D0 6F A0  1 
1A461F0 	 4 45 A0  1 C4 4C A0  1 
   else
1A461F8 	C8 41 A0  1 88  0  0  0 
   4 dev-desc@ ?dup  if			        ( class )
1A46200 	B0 6F A0  1 24 61 A4  1 
1A46208 	B4 70 A0  1 DC 41 A0  1 
1A46210 	28  0  0  0 
      \ Class is in device descriptor
      true to class-in-dev?			( class )
1A46214 	 4 70 A0  1 
1A46218 	B8 40 A0  1 34 3A A4  1 
      5 dev-desc@  6 dev-desc@			( class subclass protocol )
1A46220 	C0 6F A0  1 24 61 A4  1 
1A46228 	D0 6F A0  1 24 61 A4  1 
   else
1A46230 	C8 41 A0  1 50  0  0  0 
      \ Class is in interface descriptor
      false to class-in-dev?
1A46238 	18 70 A0  1 B8 40 A0  1 
1A46240 	34 3A A4  1 
      cfg-desc-buf my-address find-intf-desc	( intf-adr )
1A46244 	94 5E A4  1 
1A46248 	20 10 A2  1 BC 3A A4  1 
      >r  r@ 5 + c@  r@ 6 + c@   r> 7 + c@	( class subclass protocol )
1A46250 	BC 45 A0  1 E4 45 A0  1 
1A46258 	C0 6F A0  1  4 45 A0  1 
1A46260 	C4 4C A0  1 E4 45 A0  1 
1A46268 	D0 6F A0  1  4 45 A0  1 
1A46270 	C4 4C A0  1 D0 45 A0  1 
1A46278 	E0 6F A0  1  4 45 A0  1 
1A46280 	C4 4C A0  1 
   then  then
;
1A46284 	58 46 A0  1 

: make-class-properties  ( -- )
1A46288 	 0  0 6D 61 6B 65 2D 63 
1A46290 	6C 61 73 73 2D 70 72 6F 
1A46298 	70 65 72 74 69 65 73 95 
1A462A0 	9C 61 A4  1 20 40 A0  1 
   get-class  ( class subclass protocol )
1A462A8 	9C 61 A4  1 
   " protocol" int-property
1A462AC 	9C 53 A0  1 
1A462B0 	 8 70 72 6F 74 6F 63 6F 
1A462B8 	6C  0  0  0 24 3C A4  1 
   " subclass" int-property
1A462C0 	9C 53 A0  1  8 73 75 62 
1A462C8 	63 6C 61 73 73  0  0  0 
1A462D0 	24 3C A4  1 
   " class"    int-property
1A462D4 	9C 53 A0  1 
1A462D8 	 5 63 6C 61 73 73  0  0 
1A462E0 	24 3C A4  1 
;
1A462E4 	58 46 A0  1 

: make-name-property  ( -- )
1A462E8 	 0 6D 61 6B 65 2D 6E 61 
1A462F0 	6D 65 2D 70 72 6F 70 65 
1A462F8 	72 74 79 92 A4 62 A4  1 
1A46300 	20 40 A0  1 
   get-class-properties				( class subclass protocol )
1A46304 	 0 5B A4  1 
   swap rot					( protocol subclass class )
1A46308 	68 49 A0  1 7C 49 A0  1 
   case
      1  of  2drop " audio"  endof		( name$ )
1A46310 	80 6F A0  1 48 43 A0  1 
1A46318 	1C  0  0  0 AC 49 A0  1 
1A46320 	9C 53 A0  1  5 61 75 64 
1A46328 	69 6F  0  0 6C 43 A0  1 
1A46330 	A8  2  0  0 
      2  of  2drop " network"  endof		( name$ )
1A46334 	90 6F A0  1 
1A46338 	48 43 A0  1 20  0  0  0 
1A46340 	AC 49 A0  1 9C 53 A0  1 
1A46348 	 7 6E 65 74 77 6F 72 6B 
1A46350 	 0  0  0  0 6C 43 A0  1 
1A46358 	80  2  0  0 
      3  of  case
1A4635C 	A0 6F A0  1 
1A46360 	48 43 A0  1  0  1  0  0 
             1  of  case
1A46368 	80 6F A0  1 48 43 A0  1 
1A46370 	D4  0  0  0 
                      1  of  " keyboard"  endof
1A46374 	80 6F A0  1 
1A46378 	48 43 A0  1 1C  0  0  0 
1A46380 	9C 53 A0  1  8 6B 65 79 
1A46388 	62 6F 61 72 64  0  0  0 
1A46390 	6C 43 A0  1 A8  0  0  0 
                      2  of  " mouse"  endof
1A46398 	90 6F A0  1 48 43 A0  1 
1A463A0 	18  0  0  0 9C 53 A0  1 
1A463A8 	 5 6D 6F 75 73 65  0  0 
1A463B0 	6C 43 A0  1 88  0  0  0 
		      4  of  " joystick"  endof
1A463B8 	B0 6F A0  1 48 43 A0  1 
1A463C0 	1C  0  0  0 9C 53 A0  1 
1A463C8 	 8 6A 6F 79 73 74 69 63 
1A463D0 	6B  0  0  0 6C 43 A0  1 
1A463D8 	64  0  0  0 
		      5  of  " gamepad"  endof
1A463DC 	C0 6F A0  1 
1A463E0 	48 43 A0  1 1C  0  0  0 
1A463E8 	9C 53 A0  1  7 67 61 6D 
1A463F0 	65 70 61 64  0  0  0  0 
1A463F8 	6C 43 A0  1 40  0  0  0 
		      39 of  " hatswitch"  endof
1A46400 	58 41 A0  1 39  0  0  0 
1A46408 	48 43 A0  1 1C  0  0  0 
1A46410 	9C 53 A0  1  9 68 61 74 
1A46418 	73 77 69 74 63 68  0  0 
1A46420 	6C 43 A0  1 18  0  0  0 
                      ( default )  " device" rot
1A46428 	9C 53 A0  1  6 64 65 76 
1A46430 	69 63 65  0 7C 49 A0  1 
                    endcase
1A46438 	84 43 A0  1 
                    endof
1A4643C 	6C 43 A0  1 
1A46440 	1C  0  0  0 
             ( default ) nip " hid" rot
1A46444 	FC 46 A0  1 
1A46448 	9C 53 A0  1  3 68 69 64 
1A46450 	 0  0  0  0 7C 49 A0  1 
             endcase
1A46458 	84 43 A0  1 
             endof
1A4645C 	6C 43 A0  1 
1A46460 	78  1  0  0 
      7  of  2drop " printer"  endof		( name$ )
1A46464 	E0 6F A0  1 
1A46468 	48 43 A0  1 20  0  0  0 
1A46470 	AC 49 A0  1 9C 53 A0  1 
1A46478 	 7 70 72 69 6E 74 65 72 
1A46480 	 0  0  0  0 6C 43 A0  1 
1A46488 	50  1  0  0 
      8  of  case
1A4648C 	F0 6F A0  1 
1A46490 	48 43 A0  1  0  1  0  0 
             1  of  drop " flash"  endof
1A46498 	80 6F A0  1 48 43 A0  1 
1A464A0 	1C  0  0  0 30 49 A0  1 
1A464A8 	9C 53 A0  1  5 66 6C 61 
1A464B0 	73 68  0  0 6C 43 A0  1 
1A464B8 	D4  0  0  0 
             2  of  drop " cdrom"  endof
1A464BC 	90 6F A0  1 
1A464C0 	48 43 A0  1 1C  0  0  0 
1A464C8 	30 49 A0  1 9C 53 A0  1 
1A464D0 	 5 63 64 72 6F 6D  0  0 
1A464D8 	6C 43 A0  1 B0  0  0  0 
             3  of  drop " tape"  endof
1A464E0 	A0 6F A0  1 48 43 A0  1 
1A464E8 	1C  0  0  0 30 49 A0  1 
1A464F0 	9C 53 A0  1  4 74 61 70 
1A464F8 	65  0  0  0 6C 43 A0  1 
1A46500 	8C  0  0  0 
             4  of  drop " floppy"  endof
1A46504 	B0 6F A0  1 
1A46508 	48 43 A0  1 1C  0  0  0 
1A46510 	30 49 A0  1 9C 53 A0  1 
1A46518 	 6 66 6C 6F 70 70 79  0 
1A46520 	6C 43 A0  1 68  0  0  0 
             5  of  drop " scsi"  endof		\ removable
1A46528 	C0 6F A0  1 48 43 A0  1 
1A46530 	1C  0  0  0 30 49 A0  1 
1A46538 	9C 53 A0  1  4 73 63 73 
1A46540 	69  0  0  0 6C 43 A0  1 
1A46548 	44  0  0  0 
             6  of  drop " scsi"  endof
1A4654C 	D0 6F A0  1 
1A46550 	48 43 A0  1 1C  0  0  0 
1A46558 	30 49 A0  1 9C 53 A0  1 
1A46560 	 4 73 63 73 69  0  0  0 
1A46568 	6C 43 A0  1 20  0  0  0 
             ( default ) nip " storage" rot
1A46570 	FC 46 A0  1 9C 53 A0  1 
1A46578 	 7 73 74 6F 72 61 67 65 
1A46580 	 0  0  0  0 7C 49 A0  1 
             endcase
1A46588 	84 43 A0  1 
             endof
1A4658C 	6C 43 A0  1 
1A46590 	48  0  0  0 
      9  of  2drop " hub"  endof		( name$ )
1A46594 	58 41 A0  1 
1A46598 	 9  0  0  0 48 43 A0  1 
1A465A0 	1C  0  0  0 AC 49 A0  1 
1A465A8 	9C 53 A0  1  3 68 75 62 
1A465B0 	 0  0  0  0 6C 43 A0  1 
1A465B8 	20  0  0  0 
      ( default )  nip nip " device" rot	( name$ )
1A465BC 	FC 46 A0  1 
1A465C0 	FC 46 A0  1 9C 53 A0  1 
1A465C8 	 6 64 65 76 69 63 65  0 
1A465D0 	7C 49 A0  1 
   endcase
1A465D4 	84 43 A0  1 
   device-name
1A465D8 	20 49 A2  1 
;
1A465DC 	58 46 A0  1 

: get-vid  ( adr -- vendor product rev )
1A465E0 	67 65 74 2D 76 69 64 87 
1A465E8 	 0 63 A4  1 20 40 A0  1 
   dev-desc-buf 8 + le-w@   dev-desc-buf d# 10 + le-w@  dev-desc-buf c + le-w@
1A465F0 	B0 5E A4  1 F0 6F A0  1 
1A465F8 	 4 45 A0  1 2C 35 A4  1 
1A46600 	B0 5E A4  1 58 41 A0  1 
1A46608 	 A  0  0  0  4 45 A0  1 
1A46610 	2C 35 A4  1 B0 5E A4  1 
1A46618 	58 41 A0  1  C  0  0  0 
1A46620 	 4 45 A0  1 2C 35 A4  1 
;
1A46628 	58 46 A0  1 

: make-vendor-properties  ( -- )
1A4662C 	 0 6D 61 6B 
1A46630 	65 2D 76 65 6E 64 6F 72 
1A46638 	2D 70 72 6F 70 65 72 74 
1A46640 	69 65 73 96 EC 65 A4  1 
1A46648 	20 40 A0  1 
   get-vid			( vendor product rev )
1A4664C 	EC 65 A4  1 
   " release"   int-property
1A46650 	9C 53 A0  1  7 72 65 6C 
1A46658 	65 61 73 65  0  0  0  0 
1A46660 	24 3C A4  1 
   " device-id" int-property
1A46664 	9C 53 A0  1 
1A46668 	 9 64 65 76 69 63 65 2D 
1A46670 	69 64  0  0 24 3C A4  1 
   " vendor-id" int-property
1A46678 	9C 53 A0  1  9 76 65 6E 
1A46680 	64 6F 72 2D 69 64  0  0 
1A46688 	24 3C A4  1 
;
1A4668C 	58 46 A0  1 

\ A little tool so "make-compatible-property" reads better
0 value sadr
1A46690 	 0  0  0 73 61 64 72 84 
1A46698 	48 66 A4  1 50 40 A0  1 
1A466A0 	30  E  0  0 
0 value slen
1A466A4 	 0  0  0 73 
1A466A8 	6C 65 6E 84 9C 66 A4  1 
1A466B0 	50 40 A0  1 34  E  0  0 
: +$  ( add$ -- )
1A466B8 	 0 2B 24 82 B0 66 A4  1 
1A466C0 	20 40 A0  1 
   sadr slen 2swap encode-string encode+  to slen  to sadr
1A466C4 	9C 66 A4  1 
1A466C8 	B0 66 A4  1 F4 49 A0  1 
1A466D0 	A0 F6 A1  1 F0 F5 A1  1 
1A466D8 	B8 40 A0  1 B0 66 A4  1 
1A466E0 	B8 40 A0  1 9C 66 A4  1 
;
1A466E8 	58 46 A0  1 
: usb,class#>     ( n -- )  " usb,class" $hold  0 u#> ;     \ Prepends: usb,class
1A466EC 	75 73 62 2C 
1A466F0 	63 6C 61 73 73 23 3E 8B 
1A466F8 	C0 66 A4  1 20 40 A0  1 
1A46700 	9C 53 A0  1  9 75 73 62 
1A46708 	2C 63 6C 61 73 73  0  0 
1A46710 	AC 5B A4  1 70 6F A0  1 
1A46718 	E0 76 A0  1 58 46 A0  1 
: #usb,class#>    ( n -- )  u#s drop  usb,class#>  ;        \ Prepends: usb,classN
1A46720 	 0  0  0 23 75 73 62 2C 
1A46728 	63 6C 61 73 73 23 3E 8C 
1A46730 	FC 66 A4  1 20 40 A0  1 
1A46738 	BC 76 A0  1 30 49 A0  1 
1A46740 	FC 66 A4  1 58 46 A0  1 
: usbif#>         ( n -- )  " usbif" $hold  0 u#> ;         \ Prepends: usbif
1A46748 	75 73 62 69 66 23 3E 87 
1A46750 	34 67 A4  1 20 40 A0  1 
1A46758 	9C 53 A0  1  5 75 73 62 
1A46760 	69 66  0  0 AC 5B A4  1 
1A46768 	70 6F A0  1 E0 76 A0  1 
1A46770 	58 46 A0  1 
: #usbif#>        ( n -- )  u#s drop  usbif#>  ;            \ Prepends: usbifN
1A46774 	 0  0  0 23 
1A46778 	75 73 62 69 66 23 3E 88 
1A46780 	54 67 A4  1 20 40 A0  1 
1A46788 	BC 76 A0  1 30 49 A0  1 
1A46790 	54 67 A4  1 58 46 A0  1 
: usbif,class#>   ( n -- )  " usbif,class" $hold  0 u#> ;   \ Prepends: usbif,class
1A46798 	 0  0 75 73 62 69 66 2C 
1A467A0 	63 6C 61 73 73 23 3E 8D 
1A467A8 	84 67 A4  1 20 40 A0  1 
1A467B0 	9C 53 A0  1  B 75 73 62 
1A467B8 	69 66 2C 63 6C 61 73 73 
1A467C0 	 0  0  0  0 AC 5B A4  1 
1A467C8 	70 6F A0  1 E0 76 A0  1 
1A467D0 	58 46 A0  1 
: #usbif,class#>  ( n -- )  u#s drop  usbif,class#>  ;      \ Prepends: usbif,classN
1A467D4 	 0 23 75 73 
1A467D8 	62 69 66 2C 63 6C 61 73 
1A467E0 	73 23 3E 8E AC 67 A4  1 
1A467E8 	20 40 A0  1 BC 76 A0  1 
1A467F0 	30 49 A0  1 AC 67 A4  1 
1A467F8 	58 46 A0  1 
: #class,         ( n -- )  u#s drop " ,class" $hold  ;     \ Prepends: class,N
1A467FC 	23 63 6C 61 
1A46800 	73 73 2C 87 E8 67 A4  1 
1A46808 	20 40 A0  1 BC 76 A0  1 
1A46810 	30 49 A0  1 9C 53 A0  1 
1A46818 	 6 2C 63 6C 61 73 73  0 
1A46820 	AC 5B A4  1 58 46 A0  1 

: make-compatible-property  ( -- )
1A46828 	 0  0  0 6D 61 6B 65 2D 
1A46830 	63 6F 6D 70 61 74 69 62 
1A46838 	6C 65 2D 70 72 6F 70 65 
1A46840 	72 74 79 98  8 68 A4  1 
1A46848 	20 40 A0  1 
   0 0 encode-bytes  to slen  to sadr		\ Initial empty string
1A4684C 	70 6F A0  1 
1A46850 	70 6F A0  1 14 F6 A1  1 
1A46858 	B8 40 A0  1 B0 66 A4  1 
1A46860 	B8 40 A0  1 9C 66 A4  1 

   push-hex
1A46868 	5C F4 A0  1 

   get-vendor-properties			( vendor product rev )
1A4686C 	5C 5B A4  1 
   3dup      <# #. #, #usb#>  +$		( v p r )	\ usbV,product.rev
1A46870 	6C 3F A4  1  8 76 A0  1 
1A46878 	74 5C A4  1 50 5C A4  1 
1A46880 	34 5C A4  1 C0 66 A4  1 
   drop 2dup <#    #, #usb#>  +$		( v p )		\ usbV,product
1A46888 	30 49 A0  1 C0 49 A0  1 
1A46890 	 8 76 A0  1 50 5C A4  1 
1A46898 	34 5C A4  1 C0 66 A4  1 
   drop						( vendor )
1A468A0 	30 49 A0  1 

   get-class-properties				( vendor class subclass protocol )
1A468A4 	 0 5B A4  1 
   2 pick 0<>  if       			( vendor class subclass protocol )
1A468A8 	90 6F A0  1  C 4A A0  1 
1A468B0 	44 47 A0  1 DC 41 A0  1 
1A468B8 	50  1  0  0 
      class-in-dev?  if
1A468BC 	34 3A A4  1 
1A468C0 	DC 41 A0  1 A8  0  0  0 
         4dup          <# #. #. #class, #usb#>         +$  ( v c s p )  \ usbV,classC.S.P
1A468C8 	B4 3F A4  1  8 76 A0  1 
1A468D0 	74 5C A4  1 74 5C A4  1 
1A468D8 	 8 68 A4  1 34 5C A4  1 
1A468E0 	C0 66 A4  1 
         4dup  drop    <#    #. #class, #usb#>         +$  ( v c s p )  \ usbV,classC,S
1A468E4 	B4 3F A4  1 
1A468E8 	30 49 A0  1  8 76 A0  1 
1A468F0 	74 5C A4  1  8 68 A4  1 
1A468F8 	34 5C A4  1 C0 66 A4  1 
         4dup 2drop    <#       #class, #usb#>         +$  ( v c s p )  \ usbV,classC
1A46900 	B4 3F A4  1 AC 49 A0  1 
1A46908 	 8 76 A0  1  8 68 A4  1 
1A46910 	34 5C A4  1 C0 66 A4  1 
         3dup          <# #. #.         #usb,class#>   +$  ( v c s p )  \ usb,classC.S.P
1A46918 	6C 3F A4  1  8 76 A0  1 
1A46920 	74 5C A4  1 74 5C A4  1 
1A46928 	34 67 A4  1 C0 66 A4  1 
         2 pick 2 pick <# #.            #usb,class#>   +$  ( v c s p )  \ usb,classC,S
1A46930 	90 6F A0  1  C 4A A0  1 
1A46938 	90 6F A0  1  C 4A A0  1 
1A46940 	 8 76 A0  1 74 5C A4  1 
1A46948 	34 67 A4  1 C0 66 A4  1 
         2 pick        <#               #usb,class#>   +$  ( v c s p )  \ usb,classC
1A46950 	90 6F A0  1  C 4A A0  1 
1A46958 	 8 76 A0  1 34 67 A4  1 
1A46960 	C0 66 A4  1 
      else
1A46964 	C8 41 A0  1 
1A46968 	A0  0  0  0 
         4dup          <# #. #. #class, #usbif#>       +$  ( v c s p )  \ usbifV,classC.S.P
1A4696C 	B4 3F A4  1 
1A46970 	 8 76 A0  1 74 5C A4  1 
1A46978 	74 5C A4  1  8 68 A4  1 
1A46980 	84 67 A4  1 C0 66 A4  1 
         4dup  drop    <#    #. #class, #usbif#>       +$  ( v c s p )  \ usbifV,classC,S
1A46988 	B4 3F A4  1 30 49 A0  1 
1A46990 	 8 76 A0  1 74 5C A4  1 
1A46998 	 8 68 A4  1 84 67 A4  1 
1A469A0 	C0 66 A4  1 
         4dup 2drop    <#       #class, #usbif#>       +$  ( v c s p )  \ usbifV,classC
1A469A4 	B4 3F A4  1 
1A469A8 	AC 49 A0  1  8 76 A0  1 
1A469B0 	 8 68 A4  1 84 67 A4  1 
1A469B8 	C0 66 A4  1 
         3dup          <# #. #.         #usbif,class#> +$  ( v c s p )  \ usbif,classC.S.P
1A469BC 	6C 3F A4  1 
1A469C0 	 8 76 A0  1 74 5C A4  1 
1A469C8 	74 5C A4  1 E8 67 A4  1 
1A469D0 	C0 66 A4  1 
         2 pick 2 pick <# #.            #usbif,class#> +$  ( v c s p )  \ usbif,classC,S
1A469D4 	90 6F A0  1 
1A469D8 	 C 4A A0  1 90 6F A0  1 
1A469E0 	 C 4A A0  1  8 76 A0  1 
1A469E8 	74 5C A4  1 E8 67 A4  1 
1A469F0 	C0 66 A4  1 
         2 pick        <#               #usbif,class#> +$  ( v c s p )  \ usbif,classC
1A469F4 	90 6F A0  1 
1A469F8 	 C 4A A0  1  8 76 A0  1 
1A46A00 	E8 67 A4  1 C0 66 A4  1 
      then
   then						( vendor class subclass protocol )
   4drop					( )
1A46A08 	D0 3F A4  1 
   " usb,device"  +$
1A46A0C 	9C 53 A0  1 
1A46A10 	 A 75 73 62 2C 64 65 76 
1A46A18 	69 63 65  0 C0 66 A4  1 
   sadr slen  " compatible"  property
1A46A20 	9C 66 A4  1 B0 66 A4  1 
1A46A28 	9C 53 A0  1  A 63 6F 6D 
1A46A30 	70 61 74 69 62 6C 65  0 
1A46A38 	BC 14 A2  1 
   pop-base
1A46A3C 	9C F4 A0  1 
;
1A46A40 	58 46 A0  1 

: make-string-properties  ( -- )
1A46A44 	 0 6D 61 6B 
1A46A48 	65 2D 73 74 72 69 6E 67 
1A46A50 	2D 70 72 6F 70 65 72 74 
1A46A58 	69 65 73 96 48 68 A4  1 
1A46A60 	20 40 A0  1 
   v$-desc-buf /v$-desc-buf " vendor$" str-property
1A46A64 	E0 5E A4  1 
1A46A68 	68 5F A4  1 9C 53 A0  1 
1A46A70 	 7 76 65 6E 64 6F 72 24 
1A46A78 	 0  0  0  0 50 3C A4  1 
   d$-desc-buf /d$-desc-buf " device$" str-property
1A46A80 	C8 5E A4  1 4C 5F A4  1 
1A46A88 	9C 53 A0  1  7 64 65 76 
1A46A90 	69 63 65 24  0  0  0  0 
1A46A98 	50 3C A4  1 
   s$-desc-buf /s$-desc-buf " serial$" str-property
1A46A9C 	F8 5E A4  1 
1A46AA0 	84 5F A4  1 9C 53 A0  1 
1A46AA8 	 7 73 65 72 69 61 6C 24 
1A46AB0 	 0  0  0  0 50 3C A4  1 
;
1A46AB8 	58 46 A0  1 

: make-misc-properties  ( -- )
1A46ABC 	 0  0  0 6D 
1A46AC0 	61 6B 65 2D 6D 69 73 63 
1A46AC8 	2D 70 72 6F 70 65 72 74 
1A46AD0 	69 65 73 94 60 6A A4  1 
1A46AD8 	20 40 A0  1 
   cfg-desc-buf 5 + c@ " configuration#" int-property
1A46ADC 	94 5E A4  1 
1A46AE0 	C0 6F A0  1  4 45 A0  1 
1A46AE8 	C4 4C A0  1 9C 53 A0  1 
1A46AF0 	 E 63 6F 6E 66 69 67 75 
1A46AF8 	72 61 74 69 6F 6E 23  0 
1A46B00 	24 3C A4  1 
;
1A46B04 	58 46 A0  1 

: register-pipe  ( pipe size -- )
1A46B08 	 0  0 72 65 67 69 73 74 
1A46B10 	65 72 2D 70 69 70 65 8D 
1A46B18 	D8 6A A4  1 20 40 A0  1 
   swap h# 0f and 				( size pipe' )
1A46B20 	68 49 A0  1 58 41 A0  1 
1A46B28 	 F  0  0  0 5C 44 A0  1 
   " assigned-address" get-my-property  0=  if
1A46B30 	9C 53 A0  1 10 61 73 73 
1A46B38 	69 67 6E 65 64 2D 61 64 
1A46B40 	64 72 65 73 73  0  0  0 
1A46B48 	1C 34 A2  1 24 47 A0  1 
1A46B50 	DC 41 A0  1 1C  0  0  0 
      decode-int nip nip di-maxpayload!		( )
1A46B58 	68 F7 A1  1 FC 46 A0  1 
1A46B60 	FC 46 A0  1 3C 44 A4  1 
   else
1A46B68 	C8 41 A0  1  8  0  0  0 
      2drop
1A46B70 	AC 49 A0  1 
   then
;
1A46B74 	58 46 A0  1 

: make-ctrl-pipe-property  ( pipe size interval -- )
1A46B78 	6D 61 6B 65 2D 63 74 72 
1A46B80 	6C 2D 70 69 70 65 2D 70 
1A46B88 	72 6F 70 65 72 74 79 97 
1A46B90 	1C 6B A4  1 20 40 A0  1 
   drop					( pipe size )
1A46B98 	30 49 A0  1 
   over h# f and rot h# 80 and  if	( size pipe )
1A46B9C 	54 49 A0  1 
1A46BA0 	58 41 A0  1  F  0  0  0 
1A46BA8 	5C 44 A0  1 7C 49 A0  1 
1A46BB0 	58 41 A0  1 80  0  0  0 
1A46BB8 	5C 44 A0  1 DC 41 A0  1 
1A46BC0 	40  0  0  0 
      " control-in-pipe"  int-property
1A46BC4 	9C 53 A0  1 
1A46BC8 	 F 63 6F 6E 74 72 6F 6C 
1A46BD0 	2D 69 6E 2D 70 69 70 65 
1A46BD8 	 0  0  0  0 24 3C A4  1 
      " control-in-size"
1A46BE0 	9C 53 A0  1  F 63 6F 6E 
1A46BE8 	74 72 6F 6C 2D 69 6E 2D 
1A46BF0 	73 69 7A 65  0  0  0  0 
   else
1A46BF8 	C8 41 A0  1 38  0  0  0 
      " control-out-pipe" int-property
1A46C00 	9C 53 A0  1 10 63 6F 6E 
1A46C08 	74 72 6F 6C 2D 6F 75 74 
1A46C10 	2D 70 69 70 65  0  0  0 
1A46C18 	24 3C A4  1 
      " control-out-size"
1A46C1C 	9C 53 A0  1 
1A46C20 	10 63 6F 6E 74 72 6F 6C 
1A46C28 	2D 6F 75 74 2D 73 69 7A 
1A46C30 	65  0  0  0 
   then  int-property
1A46C34 	24 3C A4  1 
;
1A46C38 	58 46 A0  1 
: make-iso-pipe-property  ( pipe size interval -- )
1A46C3C 	 0 6D 61 6B 
1A46C40 	65 2D 69 73 6F 2D 70 69 
1A46C48 	70 65 2D 70 72 6F 70 65 
1A46C50 	72 74 79 96 94 6B A4  1 
1A46C58 	20 40 A0  1 
   drop					( pipe size )
1A46C5C 	30 49 A0  1 
   over h# 0f and rot h# 80 and  if	( size pipe )
1A46C60 	54 49 A0  1 58 41 A0  1 
1A46C68 	 F  0  0  0 5C 44 A0  1 
1A46C70 	7C 49 A0  1 58 41 A0  1 
1A46C78 	80  0  0  0 5C 44 A0  1 
1A46C80 	DC 41 A0  1 38  0  0  0 
      " iso-in-pipe"  int-property
1A46C88 	9C 53 A0  1  B 69 73 6F 
1A46C90 	2D 69 6E 2D 70 69 70 65 
1A46C98 	 0  0  0  0 24 3C A4  1 
      " iso-in-size"
1A46CA0 	9C 53 A0  1  B 69 73 6F 
1A46CA8 	2D 69 6E 2D 73 69 7A 65 
1A46CB0 	 0  0  0  0 
   else
1A46CB4 	C8 41 A0  1 
1A46CB8 	30  0  0  0 
      " iso-out-pipe" int-property
1A46CBC 	9C 53 A0  1 
1A46CC0 	 C 69 73 6F 2D 6F 75 74 
1A46CC8 	2D 70 69 70 65  0  0  0 
1A46CD0 	24 3C A4  1 
      " iso-out-size"
1A46CD4 	9C 53 A0  1 
1A46CD8 	 C 69 73 6F 2D 6F 75 74 
1A46CE0 	2D 73 69 7A 65  0  0  0 
   then  int-property
1A46CE8 	24 3C A4  1 
;
1A46CEC 	58 46 A0  1 
: make-bulk-pipe-property  ( pipe size interval -- )
1A46CF0 	6D 61 6B 65 2D 62 75 6C 
1A46CF8 	6B 2D 70 69 70 65 2D 70 
1A46D00 	72 6F 70 65 72 74 79 97 
1A46D08 	58 6C A4  1 20 40 A0  1 
   drop 				( pipe size )
1A46D10 	30 49 A0  1 
   over h# f and rot h# 80 and  if	( size pipe )
1A46D14 	54 49 A0  1 
1A46D18 	58 41 A0  1  F  0  0  0 
1A46D20 	5C 44 A0  1 7C 49 A0  1 
1A46D28 	58 41 A0  1 80  0  0  0 
1A46D30 	5C 44 A0  1 DC 41 A0  1 
1A46D38 	38  0  0  0 
      " bulk-in-pipe"  int-property
1A46D3C 	9C 53 A0  1 
1A46D40 	 C 62 75 6C 6B 2D 69 6E 
1A46D48 	2D 70 69 70 65  0  0  0 
1A46D50 	24 3C A4  1 
      " bulk-in-size"
1A46D54 	9C 53 A0  1 
1A46D58 	 C 62 75 6C 6B 2D 69 6E 
1A46D60 	2D 73 69 7A 65  0  0  0 
   else
1A46D68 	C8 41 A0  1 30  0  0  0 
      " bulk-out-pipe" int-property
1A46D70 	9C 53 A0  1  D 62 75 6C 
1A46D78 	6B 2D 6F 75 74 2D 70 69 
1A46D80 	70 65  0  0 24 3C A4  1 
      " bulk-out-size" 
1A46D88 	9C 53 A0  1  D 62 75 6C 
1A46D90 	6B 2D 6F 75 74 2D 73 69 
1A46D98 	7A 65  0  0 
   then  int-property
1A46D9C 	24 3C A4  1 
;
1A46DA0 	58 46 A0  1 
: make-intr-pipe-property  ( pipe size interval -- )
1A46DA4 	6D 61 6B 65 
1A46DA8 	2D 69 6E 74 72 2D 70 69 
1A46DB0 	70 65 2D 70 72 6F 70 65 
1A46DB8 	72 74 79 97  C 6D A4  1 
1A46DC0 	20 40 A0  1 
   rot dup h# f and swap h# 80 and  if	( size interval pipe )
1A46DC4 	7C 49 A0  1 
1A46DC8 	40 49 A0  1 58 41 A0  1 
1A46DD0 	 F  0  0  0 5C 44 A0  1 
1A46DD8 	68 49 A0  1 58 41 A0  1 
1A46DE0 	80  0  0  0 5C 44 A0  1 
1A46DE8 	DC 41 A0  1 54  0  0  0 
      " intr-in-pipe"      int-property
1A46DF0 	9C 53 A0  1  C 69 6E 74 
1A46DF8 	72 2D 69 6E 2D 70 69 70 
1A46E00 	65  0  0  0 24 3C A4  1 
      " intr-in-interval"  int-property
1A46E08 	9C 53 A0  1 10 69 6E 74 
1A46E10 	72 2D 69 6E 2D 69 6E 74 
1A46E18 	65 72 76 61 6C  0  0  0 
1A46E20 	24 3C A4  1 
      " intr-in-size"
1A46E24 	9C 53 A0  1 
1A46E28 	 C 69 6E 74 72 2D 69 6E 
1A46E30 	2D 73 69 7A 65  0  0  0 
   else
1A46E38 	C8 41 A0  1 4C  0  0  0 
      " intr-out-pipe"     int-property
1A46E40 	9C 53 A0  1  D 69 6E 74 
1A46E48 	72 2D 6F 75 74 2D 70 69 
1A46E50 	70 65  0  0 24 3C A4  1 
      " intr-out-interval" int-property
1A46E58 	9C 53 A0  1 11 69 6E 74 
1A46E60 	72 2D 6F 75 74 2D 69 6E 
1A46E68 	74 65 72 76 61 6C  0  0 
1A46E70 	24 3C A4  1 
      " intr-out-size"
1A46E74 	9C 53 A0  1 
1A46E78 	 D 69 6E 74 72 2D 6F 75 
1A46E80 	74 2D 73 69 7A 65  0  0 
   then  int-property
1A46E88 	24 3C A4  1 
;
1A46E8C 	58 46 A0  1 

: make-pipe-properties  ( adr -- )
1A46E90 	 0  0  0 6D 61 6B 65 2D 
1A46E98 	70 69 70 65 2D 70 72 6F 
1A46EA0 	70 65 72 74 69 65 73 94 
1A46EA8 	C0 6D A4  1 20 40 A0  1 
   dup c@ over + swap 4 + c@ 		( adr' #endpoints )
1A46EB0 	40 49 A0  1 C4 4C A0  1 
1A46EB8 	54 49 A0  1  4 45 A0  1 
1A46EC0 	68 49 A0  1 B0 6F A0  1 
1A46EC8 	 4 45 A0  1 C4 4C A0  1 
   swap ENDPOINT find-desc swap 0  ?do	( adr' )
1A46ED0 	68 49 A0  1 14 33 A4  1 
1A46ED8 	4C 3A A4  1 68 49 A0  1 
1A46EE0 	70 6F A0  1 50 42 A0  1 
1A46EE8 	D4  0  0  0 
      dup 2 + c@			( adr pipe )
1A46EEC 	40 49 A0  1 
1A46EF0 	90 6F A0  1  4 45 A0  1 
1A46EF8 	C4 4C A0  1 
      over 4 + le-w@			( adr pipe size )
1A46EFC 	54 49 A0  1 
1A46F00 	B0 6F A0  1  4 45 A0  1 
1A46F08 	2C 35 A4  1 
      2dup register-pipe		( adr pipe size )
1A46F0C 	C0 49 A0  1 
1A46F10 	1C 6B A4  1 
      2 pick 6 + c@			( adr pipe size interval )
1A46F14 	90 6F A0  1 
1A46F18 	 C 4A A0  1 D0 6F A0  1 
1A46F20 	 4 45 A0  1 C4 4C A0  1 
      3 pick 3 + c@ 3 and  case		( adr pipe size interval type )
1A46F28 	A0 6F A0  1  C 4A A0  1 
1A46F30 	A0 6F A0  1  4 45 A0  1 
1A46F38 	C4 4C A0  1 A0 6F A0  1 
1A46F40 	5C 44 A0  1 
         0  of  make-ctrl-pipe-property  endof
1A46F44 	70 6F A0  1 
1A46F48 	48 43 A0  1 10  0  0  0 
1A46F50 	94 6B A4  1 6C 43 A0  1 
1A46F58 	50  0  0  0 
         1  of  make-iso-pipe-property   endof
1A46F5C 	80 6F A0  1 
1A46F60 	48 43 A0  1 10  0  0  0 
1A46F68 	58 6C A4  1 6C 43 A0  1 
1A46F70 	38  0  0  0 
         2  of  make-bulk-pipe-property  endof
1A46F74 	90 6F A0  1 
1A46F78 	48 43 A0  1 10  0  0  0 
1A46F80 	 C 6D A4  1 6C 43 A0  1 
1A46F88 	20  0  0  0 
         3  of  make-intr-pipe-property  endof
1A46F8C 	A0 6F A0  1 
1A46F90 	48 43 A0  1 10  0  0  0 
1A46F98 	C0 6D A4  1 6C 43 A0  1 
1A46FA0 	 8  0  0  0 
      endcase
1A46FA4 	84 43 A0  1 
      dup c@ +				( adr' )
1A46FA8 	40 49 A0  1 C4 4C A0  1 
1A46FB0 	 4 45 A0  1 
   loop  drop
1A46FB4 	F8 41 A0  1 
1A46FB8 	34 FF FF FF 30 49 A0  1 
;
1A46FC0 	58 46 A0  1 

: make-descriptor-properties  ( -- )
1A46FC4 	 0 6D 61 6B 
1A46FC8 	65 2D 64 65 73 63 72 69 
1A46FD0 	70 74 6F 72 2D 70 72 6F 
1A46FD8 	70 65 72 74 69 65 73 9A 
1A46FE0 	AC 6E A4  1 20 40 A0  1 
   make-class-properties		\ Must make class properties first
1A46FE8 	A4 62 A4  1 
   make-name-property
1A46FEC 	 0 63 A4  1 
   make-vendor-properties
1A46FF0 	48 66 A4  1 
   make-compatible-property		\ Must come after vendor and class
1A46FF4 	48 68 A4  1 
   make-string-properties
1A46FF8 	60 6A A4  1 
   cfg-desc-buf my-address find-intf-desc make-pipe-properties
1A46FFC 	94 5E A4  1 
1A47000 	20 10 A2  1 BC 3A A4  1 
1A47008 	AC 6E A4  1 
   make-misc-properties
1A4700C 	D8 6A A4  1 
;
1A47010 	58 46 A0  1 

: make-common-properties  ( dev -- )
1A47014 	 0 6D 61 6B 
1A47018 	65 2D 63 6F 6D 6D 6F 6E 
1A47020 	2D 70 72 6F 70 65 72 74 
1A47028 	69 65 73 96 E4 6F A4  1 
1A47030 	20 40 A0  1 
   1 " #address-cells" int-property
1A47034 	80 6F A0  1 
1A47038 	9C 53 A0  1  E 23 61 64 
1A47040 	64 72 65 73 73 2D 63 65 
1A47048 	6C 6C 73  0 24 3C A4  1 
   0 " #size-cells"    int-property
1A47050 	70 6F A0  1 9C 53 A0  1 
1A47058 	 B 23 73 69 7A 65 2D 63 
1A47060 	65 6C 6C 73  0  0  0  0 
1A47068 	24 3C A4  1 
   my-address my-space encode-phys " reg" property	\ my-address=intf, my-space=port
1A4706C 	20 10 A2  1 
1A47070 	AC  3 A2  1 E0 47 A2  1 
1A47078 	9C 53 A0  1  3 72 65 67 
1A47080 	 0  0  0  0 BC 14 A2  1 
   dup " assigned-address" int-property
1A47088 	40 49 A0  1 9C 53 A0  1 
1A47090 	10 61 73 73 69 67 6E 65 
1A47098 	64 2D 61 64 64 72 65 73 
1A470A0 	73  0  0  0 24 3C A4  1 
   ( dev ) di-speed@  case
1A470A8 	 4 43 A4  1 
      speed-low  of  " low-speed"   endof
1A470AC 	74 2F A4  1 
1A470B0 	48 43 A0  1 1C  0  0  0 
1A470B8 	9C 53 A0  1  9 6C 6F 77 
1A470C0 	2D 73 70 65 65 64  0  0 
1A470C8 	6C 43 A0  1 40  0  0  0 
      speed-full of  " full-speed"  endof
1A470D0 	5C 2F A4  1 48 43 A0  1 
1A470D8 	1C  0  0  0 9C 53 A0  1 
1A470E0 	 A 66 75 6C 6C 2D 73 70 
1A470E8 	65 65 64  0 6C 43 A0  1 
1A470F0 	1C  0  0  0 
      ( default )  " high-speed" rot
1A470F4 	9C 53 A0  1 
1A470F8 	 A 68 69 67 68 2D 73 70 
1A47100 	65 65 64  0 7C 49 A0  1 
   endcase
1A47108 	84 43 A0  1 
   0 0 2swap str-property
1A4710C 	70 6F A0  1 
1A47110 	70 6F A0  1 F4 49 A0  1 
1A47118 	50 3C A4  1 
;
1A4711C 	58 46 A0  1 

\ Sets the di-maxpayload fields in the dev-info endpoint descriptor array
: reregister-pipes  ( dev intf -- )
1A47120 	 0  0  0 72 65 72 65 67 
1A47128 	69 73 74 65 72 2D 70 69 
1A47130 	70 65 73 90 30 70 A4  1 
1A47138 	20 40 A0  1 
   cfg-desc-buf swap find-intf-desc	( dev adr )
1A4713C 	94 5E A4  1 
1A47140 	68 49 A0  1 BC 3A A4  1 
   dup c@  over +  swap 4 + c@ 		( dev adr' #endpoints )
1A47148 	40 49 A0  1 C4 4C A0  1 
1A47150 	54 49 A0  1  4 45 A0  1 
1A47158 	68 49 A0  1 B0 6F A0  1 
1A47160 	 4 45 A0  1 C4 4C A0  1 
   swap  ENDPOINT find-desc		( dev #endpoints adr' )
1A47168 	68 49 A0  1 14 33 A4  1 
1A47170 	4C 3A A4  1 
   swap 0  ?do				( dev adr' )
1A47174 	68 49 A0  1 
1A47178 	70 6F A0  1 50 42 A0  1 
1A47180 	58  0  0  0 
      over di-is-reset                  ( dev adr )
1A47184 	54 49 A0  1 
1A47188 	B0 43 A4  1 
      dup 4 + le-w@			( dev adr size )
1A4718C 	40 49 A0  1 
1A47190 	B0 6F A0  1  4 45 A0  1 
1A47198 	2C 35 A4  1 
      over 2 + c@  h# f and		( dev adr size pipe )
1A4719C 	54 49 A0  1 
1A471A0 	90 6F A0  1  4 45 A0  1 
1A471A8 	C4 4C A0  1 58 41 A0  1 
1A471B0 	 F  0  0  0 5C 44 A0  1 
      3 pick di-maxpayload!		( dev adr )
1A471B8 	A0 6F A0  1  C 4A A0  1 
1A471C0 	3C 44 A4  1 
      dup c@ +				( dev adr' )
1A471C4 	40 49 A0  1 
1A471C8 	C4 4C A0  1  4 45 A0  1 
   loop  2drop				( )
1A471D0 	F8 41 A0  1 B0 FF FF FF 
1A471D8 	AC 49 A0  1 
;
1A471DC 	58 46 A0  1 

: be-l!  ( n adr -- )
1A471E0 	 0  0 62 65 2D 6C 21 85 
1A471E8 	38 71 A4  1 20 40 A0  1 
   >r lbsplit r@ c!  r@ 1+ c!  r@ 2+ c!  r> 3 + c!
1A471F0 	BC 45 A0  1 B4 FB A0  1 
1A471F8 	E4 45 A0  1 B8 4D A0  1 
1A47200 	E4 45 A0  1 30 4B A0  1 
1A47208 	B8 4D A0  1 E4 45 A0  1 
1A47210 	40 4B A0  1 B8 4D A0  1 
1A47218 	D0 45 A0  1 A0 6F A0  1 
1A47220 	 4 45 A0  1 B8 4D A0  1 
;
1A47228 	58 46 A0  1 

: probe-hub-node  ( phandle -- )
1A4722C 	 0 70 72 6F 
1A47230 	62 65 2D 68 75 62 2D 6E 
1A47238 	6F 64 65 8E EC 71 A4  1 
1A47240 	20 40 A0  1 
   >r                                       ( r: phandle )
1A47244 	BC 45 A0  1 
   " probe-hub" r@ find-method  if          ( xt r: phandle )
1A47248 	9C 53 A0  1  9 70 72 6F 
1A47250 	62 65 2D 68 75 62  0  0 
1A47258 	E4 45 A0  1 A0 2F A2  1 
1A47260 	DC 41 A0  1 28  0  0  0 
      r@ push-package                       ( xt r: phandle )
1A47268 	E4 45 A0  1 7C FB A1  1 
      " " new-instance                      ( xt r: phandle )
1A47270 	9C 53 A0  1  0  0  0  0 
1A47278 	9C  8 A2  1 
      set-default-unit                      ( xt r: phandle )
1A4727C 	68 3B A2  1 
      execute                               ( r: phandle )
1A47280 	98 41 A0  1 
      destroy-instance                      ( r: phandle )
1A47284 	38  9 A2  1 
      pop-package                           ( r: phandle )
1A47288 	D8 FB A1  1 
   then                                     ( r: phandle )
   r> drop
1A4728C 	D0 45 A0  1 
1A47290 	30 49 A0  1 
;
1A47294 	58 46 A0  1 
: reuse-node  ( dev intf port phandle -- )
1A47298 	 0 72 65 75 73 65 2D 6E 
1A472A0 	6F 64 65 8A 40 72 A4  1 
1A472A8 	20 40 A0  1 
   >r drop			  ( dev intf r: phandle )
1A472AC 	BC 45 A0  1 
1A472B0 	30 49 A0  1 

   2dup reregister-pipes	  ( dev intf r: phandle )
1A472B4 	C0 49 A0  1 
1A472B8 	38 71 A4  1 
   drop                           ( dev      r: phandle )
1A472BC 	30 49 A0  1 

   \ Change the assigned-address property without leaking memory
   " assigned-address" r@ get-package-property  if  ( dev r: phandle )
1A472C0 	9C 53 A0  1 10 61 73 73 
1A472C8 	69 67 6E 65 64 2D 61 64 
1A472D0 	64 72 65 73 73  0  0  0 
1A472D8 	E4 45 A0  1 98 33 A2  1 
1A472E0 	DC 41 A0  1 10  0  0  0 
      drop                                  ( r: phandle )
1A472E8 	30 49 A0  1 
   else                                     ( dev adr len r: phandle )
1A472EC 	C8 41 A0  1 
1A472F0 	 C  0  0  0 
      drop be-l!                            ( r: phandle )
1A472F4 	30 49 A0  1 
1A472F8 	EC 71 A4  1 
   then                                     ( r: phandle )

   r> probe-hub-node
1A472FC 	D0 45 A0  1 
1A47300 	40 72 A4  1 
;
1A47304 	58 46 A0  1 
: id-match?  ( dev intf port phandle -- dev intf port phandle flag? )
1A47308 	 0  0 69 64 2D 6D 61 74 
1A47310 	63 68 3F 89 A8 72 A4  1 
1A47318 	20 40 A0  1 
   " vendor-id" 2 pick get-package-property  if  false exit  then
1A4731C 	9C 53 A0  1 
1A47320 	 9 76 65 6E 64 6F 72 2D 
1A47328 	69 64  0  0 90 6F A0  1 
1A47330 	 C 4A A0  1 98 33 A2  1 
1A47338 	DC 41 A0  1  C  0  0  0 
1A47340 	18 70 A0  1 40 46 A0  1 
   decode-int nip nip   >r     ( dev intf port phandle r: vid )
1A47348 	68 F7 A1  1 FC 46 A0  1 
1A47350 	FC 46 A0  1 BC 45 A0  1 
   " device-id" 2 pick get-package-property  if  r> drop  false exit  then
1A47358 	9C 53 A0  1  9 64 65 76 
1A47360 	69 63 65 2D 69 64  0  0 
1A47368 	90 6F A0  1  C 4A A0  1 
1A47370 	98 33 A2  1 DC 41 A0  1 
1A47378 	14  0  0  0 D0 45 A0  1 
1A47380 	30 49 A0  1 18 70 A0  1 
1A47388 	40 46 A0  1 
   decode-int nip nip   >r     ( dev intf port phandle r: vid did )
1A4738C 	68 F7 A1  1 
1A47390 	FC 46 A0  1 FC 46 A0  1 
1A47398 	BC 45 A0  1 
   " release" 2 pick get-package-property  if  r> r> 2drop  false exit  then
1A4739C 	9C 53 A0  1 
1A473A0 	 7 72 65 6C 65 61 73 65 
1A473A8 	 0  0  0  0 90 6F A0  1 
1A473B0 	 C 4A A0  1 98 33 A2  1 
1A473B8 	DC 41 A0  1 18  0  0  0 
1A473C0 	D0 45 A0  1 D0 45 A0  1 
1A473C8 	AC 49 A0  1 18 70 A0  1 
1A473D0 	40 46 A0  1 
   decode-int nip nip   >r     ( dev intf port phandle r: vid did rev )
1A473D4 	68 F7 A1  1 
1A473D8 	FC 46 A0  1 FC 46 A0  1 
1A473E0 	BC 45 A0  1 
   get-vid                     ( dev intf port phandle  vid1 did1 rev1 r: vid did rev )
1A473E4 	EC 65 A4  1 
   r> = -rot  r> = -rot  r> =  and and
1A473E8 	D0 45 A0  1 24 48 A0  1 
1A473F0 	94 49 A0  1 D0 45 A0  1 
1A473F8 	24 48 A0  1 94 49 A0  1 
1A47400 	D0 45 A0  1 24 48 A0  1 
1A47408 	5C 44 A0  1 5C 44 A0  1 
;
1A47410 	58 46 A0  1 

: reuse-old-node?  ( dev intf port -- reused? )
1A47414 	72 65 75 73 
1A47418 	65 2D 6F 6C 64 2D 6E 6F 
1A47420 	64 65 3F 8F 18 73 A4  1 
1A47428 	20 40 A0  1 
   my-self ihandle>phandle child                 ( dev intf port phandle )
1A4742C 	EC 7E A0  1 
1A47430 	 0 32 A2  1 58 74 A2  1 
   begin  ?dup  while                            ( dev intf port phandle )
1A47438 	B4 70 A0  1 DC 41 A0  1 
1A47440 	90  0  0  0 
      " reg" 2 pick get-package-property 0=  if  ( dev intf port phandle adr len )
1A47444 	9C 53 A0  1 
1A47448 	 3 72 65 67  0  0  0  0 
1A47450 	90 6F A0  1  C 4A A0  1 
1A47458 	98 33 A2  1 24 47 A0  1 
1A47460 	DC 41 A0  1 60  0  0  0 
         decode-int                              ( dev intf port phandle adr len' port1 )
1A47468 	68 F7 A1  1 
         4 pick  =  if                           ( dev intf port phandle adr len )
1A4746C 	B0 6F A0  1 
1A47470 	 C 4A A0  1 24 48 A0  1 
1A47478 	DC 41 A0  1 44  0  0  0 
            decode-int nip nip                   ( dev intf port phandle intf1 )
1A47480 	68 F7 A1  1 FC 46 A0  1 
1A47488 	FC 46 A0  1 
            3 pick  =  if                        ( dev intf port phandle )
1A4748C 	A0 6F A0  1 
1A47490 	 C 4A A0  1 24 48 A0  1 
1A47498 	DC 41 A0  1 1C  0  0  0 
               id-match?  if                     ( dev intf port phandle )
1A474A0 	18 73 A4  1 DC 41 A0  1 
1A474A8 	10  0  0  0 
                  reuse-node                     ( )
1A474AC 	A8 72 A4  1 
                  true exit                      ( -- true )
1A474B0 	 4 70 A0  1 40 46 A0  1 
               then                              ( dev intf port phandle )
            then                                 ( dev intf port phandle )
         else                                    ( dev intf port phandle adr len )
1A474B8 	C8 41 A0  1  8  0  0  0 
            2drop                                ( dev intf port phandle )
1A474C0 	AC 49 A0  1 
         then                                    ( dev intf port phandle )
      then                                       ( dev intf port phandle )
      peer                                       ( dev intf port phandle' )
1A474C4 	B4 74 A2  1 
   repeat                                        ( dev intf port )
1A474C8 	C8 41 A0  1 6C FF FF FF 
   3drop false
1A474D0 	98 3F A4  1 18 70 A0  1 
;
1A474D8 	58 46 A0  1 

: disable-old-nodes  ( port -- )
1A474DC 	 0  0 64 69 
1A474E0 	73 61 62 6C 65 2D 6F 6C 
1A474E8 	64 2D 6E 6F 64 65 73 91 
1A474F0 	28 74 A4  1 20 40 A0  1 
   my-self ihandle>phandle child                 ( port phandle )
1A474F8 	EC 7E A0  1  0 32 A2  1 
1A47500 	58 74 A2  1 
   begin  ?dup  while                            ( port phandle )
1A47504 	B4 70 A0  1 
1A47508 	DC 41 A0  1 98  0  0  0 
      " reg" 2 pick get-package-property 0=  if  ( port phandle adr len )
1A47510 	9C 53 A0  1  3 72 65 67 
1A47518 	 0  0  0  0 90 6F A0  1 
1A47520 	 C 4A A0  1 98 33 A2  1 
1A47528 	24 47 A0  1 DC 41 A0  1 
1A47530 	68  0  0  0 
         decode-int  nip nip                     ( port phandle port1 )
1A47534 	68 F7 A1  1 
1A47538 	FC 46 A0  1 FC 46 A0  1 
         2 pick  =  if                           ( port phandle )
1A47540 	90 6F A0  1  C 4A A0  1 
1A47548 	24 48 A0  1 DC 41 A0  1 
1A47550 	48  0  0  0 
            " assigned-address"                  ( port phandle propname$ )
1A47554 	9C 53 A0  1 
1A47558 	10 61 73 73 69 67 6E 65 
1A47560 	64 2D 61 64 64 72 65 73 
1A47568 	73  0  0  0 
            2 pick  get-package-property 0=  if  ( port phandle adr len )
1A4756C 	90 6F A0  1 
1A47570 	 C 4A A0  1 98 33 A2  1 
1A47578 	24 47 A0  1 DC 41 A0  1 
1A47580 	18  0  0  0 
               drop -1 swap be-l!                ( port phandle )
1A47584 	30 49 A0  1 
1A47588 	58 41 A0  1 FF FF FF FF 
1A47590 	68 49 A0  1 EC 71 A4  1 
            then                                 ( port phandle )
         then                                    ( port phandle )
      then                                       ( port phandle )
      peer                                       ( port phandle' )
1A47598 	B4 74 A2  1 
   repeat                                        ( port )
1A4759C 	C8 41 A0  1 
1A475A0 	64 FF FF FF 
   drop                                          ( )
1A475A4 	30 49 A0  1 
;
1A475A8 	58 46 A0  1 
\ cr .( disable-old-nodes=) '  disable-old-nodes .h

: find-port-node  ( port -- true | phandle false)
1A475AC 	 0 66 69 6E 
1A475B0 	64 2D 70 6F 72 74 2D 6E 
1A475B8 	6F 64 65 8E F4 74 A4  1 
1A475C0 	20 40 A0  1 
   my-self ihandle>phandle child                 ( port phandle )
1A475C4 	EC 7E A0  1 
1A475C8 	 0 32 A2  1 58 74 A2  1 
   begin  ?dup  while                            ( port phandle )
1A475D0 	B4 70 A0  1 DC 41 A0  1 
1A475D8 	B0  0  0  0 
      " reg" 2 pick get-package-property 0=  if  ( port phandle adr len )
1A475DC 	9C 53 A0  1 
1A475E0 	 3 72 65 67  0  0  0  0 
1A475E8 	90 6F A0  1  C 4A A0  1 
1A475F0 	98 33 A2  1 24 47 A0  1 
1A475F8 	DC 41 A0  1 80  0  0  0 
         decode-int  nip nip                     ( port phandle port1 )
1A47600 	68 F7 A1  1 FC 46 A0  1 
1A47608 	FC 46 A0  1 
         2 pick  =  if                           ( port phandle )
1A4760C 	90 6F A0  1 
1A47610 	 C 4A A0  1 24 48 A0  1 
1A47618 	DC 41 A0  1 60  0  0  0 
            \ Check if the node has been disabled
            " assigned-address"                  ( port phandle propname$ )
1A47620 	9C 53 A0  1 10 61 73 73 
1A47628 	69 67 6E 65 64 2D 61 64 
1A47630 	64 72 65 73 73  0  0  0 
            2 pick  get-package-property 0=  if  ( port phandle adr len )
1A47638 	90 6F A0  1  C 4A A0  1 
1A47640 	98 33 A2  1 24 47 A0  1 
1A47648 	DC 41 A0  1 30  0  0  0 
               decode-int  nip nip               ( port phandle assigned-address )
1A47650 	68 F7 A1  1 FC 46 A0  1 
1A47658 	FC 46 A0  1 
               -1 <>  if                         ( port phandle )
1A4765C 	58 41 A0  1 
1A47660 	FF FF FF FF 44 48 A0  1 
1A47668 	DC 41 A0  1 10  0  0  0 
                  nip false exit
1A47670 	FC 46 A0  1 18 70 A0  1 
1A47678 	40 46 A0  1 
               then
            then                                 ( port phandle )
         then                                    ( port phandle )
      then                                       ( port phandle )
      peer                                       ( port phandle' )
1A4767C 	B4 74 A2  1 
   repeat                                        ( port )
1A47680 	C8 41 A0  1 4C FF FF FF 
   drop                                          ( )
1A47688 	30 49 A0  1 
   true
1A4768C 	 4 70 A0  1 
;
1A47690 	58 46 A0  1 

: .phandle-property  ( phandle prop-name$ -- )
1A47694 	 0  0 2E 70 
1A47698 	68 61 6E 64 6C 65 2D 70 
1A476A0 	72 6F 70 65 72 74 79 91 
1A476A8 	C0 75 A4  1 20 40 A0  1 
   rot get-package-property 0=  if    ( adr len )
1A476B0 	7C 49 A0  1 98 33 A2  1 
1A476B8 	24 47 A0  1 DC 41 A0  1 
1A476C0 	10  0  0  0 
      decode-string type  2drop
1A476C4 	FC F6 A1  1 
1A476C8 	 4 6C A0  1 AC 49 A0  1 
   then
;
1A476D0 	58 46 A0  1 
: .usb-device  ( port -- )
1A476D4 	2E 75 73 62 
1A476D8 	2D 64 65 76 69 63 65 8B 
1A476E0 	AC 76 A4  1 20 40 A0  1 
   find-port-node  if
1A476E8 	C0 75 A4  1 DC 41 A0  1 
1A476F0 	40  0  0  0 
      ." Can't find device node for USB port!" cr abort
1A476F4 	20 7C A0  1 
1A476F8 	24 43 61 6E 27 74 20 66 
1A47700 	69 6E 64 20 64 65 76 69 
1A47708 	63 65 20 6E 6F 64 65 20 
1A47710 	66 6F 72 20 55 53 42 20 
1A47718 	70 6F 72 74 21  0  0  0 
1A47720 	80 6D A0  1 28 91 A0  1 
   else                                      ( phandle )
1A47728 	C8 41 A0  1 64  0  0  0 
      dup " device_type" .phandle-property   ( phandle )
1A47730 	40 49 A0  1 9C 53 A0  1 
1A47738 	 B 64 65 76 69 63 65 5F 
1A47740 	74 79 70 65  0  0  0  0 
1A47748 	AC 76 A4  1 
      ." ,"
1A4774C 	20 7C A0  1 
1A47750 	 1 2C  0  0 
      dup " vendor$" .phandle-property       ( phandle )
1A47754 	40 49 A0  1 
1A47758 	9C 53 A0  1  7 76 65 6E 
1A47760 	64 6F 72 24  0  0  0  0 
1A47768 	AC 76 A4  1 
      ." ,"
1A4776C 	20 7C A0  1 
1A47770 	 1 2C  0  0 
      dup " device$" .phandle-property       ( phandle )
1A47774 	40 49 A0  1 
1A47778 	9C 53 A0  1  7 64 65 76 
1A47780 	69 63 65 24  0  0  0  0 
1A47788 	AC 76 A4  1 
      drop                                   ( )
1A4778C 	30 49 A0  1 
   then
;
1A47790 	58 46 A0  1 

: (make-device-node)  ( dev port intf -- )
1A47794 	 0 28 6D 61 
1A47798 	6B 65 2D 64 65 76 69 63 
1A477A0 	65 2D 6E 6F 64 65 29 92 
1A477A8 	E4 76 A4  1 20 40 A0  1 
   swap                              ( dev intf port )
1A477B0 	68 49 A0  1 
   3dup  reuse-old-node?  if         ( dev intf port )
1A477B4 	6C 3F A4  1 
1A477B8 	28 74 A4  1 DC 41 A0  1 
1A477C0 	14  0  0  0 
      3drop exit
1A477C4 	98 3F A4  1 
1A477C8 	40 46 A0  1 
   else
1A477CC 	C8 41 A0  1 
1A477D0 	 4  0  0  0 
      \ As a possible improvement, the old child node could be linked to
      \ a retained list for possible reuse later
\ We don't do this because it can remove nodes we just created.
\   say we create  keyboard@3,0  then we try to create  hid@3,1
\   rm-obsolete-children will delete  keyboard@3,0
\     dup rm-obsolete-children       ( dev intf port )
   then
   dup >r encode-unit-m " " 2swap  new-device set-args		( dev )  ( R: port )
1A477D4 	40 49 A0  1 
1A477D8 	BC 45 A0  1 90 40 A4  1 
1A477E0 	9C 53 A0  1  0  0  0  0 
1A477E8 	F4 49 A0  1 74  F A2  1 
1A477F0 	 4 33 A2  1 
   dup dup di-speed@ swap r> make-dev-property-hook		( dev )
1A477F4 	40 49 A0  1 
1A477F8 	40 49 A0  1  4 43 A4  1 
1A47800 	68 49 A0  1 D0 45 A0  1 
1A47808 	78 5E A4  1 
   make-common-properties			\ Make non-descriptor based properties
1A4780C 	30 70 A4  1 
   make-descriptor-properties			\ Make descriptor based properties
1A47810 	E4 6F A4  1 
   load-fcode-driver				\ Find and load fcode driver
1A47814 	10 5E A4  1 
   finish-device
1A47818 	74 11 A2  1 
;
1A4781C 	58 46 A0  1 

\ Get all the descriptors we need in making properties now because target is
\ questionable in the child's context.  The descriptor buffers are not instance
\ data, so they can be accessed by code that is defined in the root hub node
\ but executing in a subordinate hub node context or a child node context.

h# 409 constant language  			\ Unicode id
1A47820 	 0  0  0 6C 61 6E 67 75 
1A47828 	61 67 65 88 AC 77 A4  1 
1A47830 	68 40 A0  1  9  4  0  0 
\ Executed in root hub node context
: get-string ( lang idx adr -- actual )
1A47838 	 0 67 65 74 2D 73 74 72 
1A47840 	69 6E 67 8A 30 78 A4  1 
1A47848 	20 40 A0  1 
   over 0=  if  3drop  0 exit  then		\ No string index
1A4784C 	54 49 A0  1 
1A47850 	24 47 A0  1 DC 41 A0  1 
1A47858 	10  0  0  0 98 3F A4  1 
1A47860 	70 6F A0  1 40 46 A0  1 
   -rot get-str-desc
1A47868 	94 49 A0  1 DC 57 A4  1 
;
1A47870 	58 46 A0  1 

\ Executed in root hub node context
: get-str-descriptors  ( -- )
1A47874 	67 65 74 2D 
1A47878 	73 74 72 2D 64 65 73 63 
1A47880 	72 69 70 74 6F 72 73 93 
1A47888 	48 78 A4  1 20 40 A0  1 
   language					( lang )
1A47890 	30 78 A4  1 
   dup d# 14 dev-desc@ v$-desc-buf get-string to /v$-desc-buf
1A47894 	40 49 A0  1 
1A47898 	58 41 A0  1  E  0  0  0 
1A478A0 	24 61 A4  1 E0 5E A4  1 
1A478A8 	48 78 A4  1 B8 40 A0  1 
1A478B0 	68 5F A4  1 
   dup d# 15 dev-desc@ d$-desc-buf get-string to /d$-desc-buf
1A478B4 	40 49 A0  1 
1A478B8 	58 41 A0  1  F  0  0  0 
1A478C0 	24 61 A4  1 C8 5E A4  1 
1A478C8 	48 78 A4  1 B8 40 A0  1 
1A478D0 	4C 5F A4  1 
       d# 16 dev-desc@ s$-desc-buf get-string to /s$-desc-buf
1A478D4 	58 41 A0  1 
1A478D8 	10  0  0  0 24 61 A4  1 
1A478E0 	F8 5E A4  1 48 78 A4  1 
1A478E8 	B8 40 A0  1 84 5F A4  1 
;
1A478F0 	58 46 A0  1 



: get-initial-dev-desc  ( dev -- )
1A478F4 	 0  0  0 67 
1A478F8 	65 74 2D 69 6E 69 74 69 
1A47900 	61 6C 2D 64 65 76 2D 64 
1A47908 	65 73 63 94 8C 78 A4  1 
1A47910 	20 40 A0  1 
   dev-desc-buf d# 18 erase                     ( dev )
1A47914 	B0 5E A4  1 
1A47918 	58 41 A0  1 12  0  0  0 
1A47920 	F0 72 A0  1 

   \ Until we know the size of the control endpoint, we must be
   \ conservative about the transfer size.
   dev-desc-buf /pipe0 get-dev-desc  if		( dev )
1A47924 	B0 5E A4  1 
1A47928 	A0 2F A4  1 7C 57 A4  1 
1A47930 	DC 41 A0  1 4C  0  0  0 
      7 dev-desc@                               ( dev maxtransfer )
1A47938 	E0 6F A0  1 24 61 A4  1 
      tuck  0 rot di-maxpayload!	        ( maxtransfer )
1A47940 	E8 46 A0  1 70 6F A0  1 
1A47948 	7C 49 A0  1 3C 44 A4  1 
      d# 18 >=  if                              ( )
1A47950 	58 41 A0  1 12  0  0  0 
1A47958 	EC 48 A0  1 DC 41 A0  1 
1A47960 	18  0  0  0 
         dev-desc-buf d# 18 get-dev-desc drop   ( )
1A47964 	B0 5E A4  1 
1A47968 	58 41 A0  1 12  0  0  0 
1A47970 	7C 57 A4  1 30 49 A0  1 
      then                                      ( )
   else						( dev )
1A47978 	C8 41 A0  1  8  0  0  0 
      drop					( )
1A47980 	30 49 A0  1 
   then						( )
;
1A47984 	58 46 A0  1 

: devicefth
1A47988 	 0  0 64 65 76 69 63 65 
1A47990 	66 74 68 89 10 79 A4  1 
1A47998 	20 40 A0  1 

\ Executed in root hub node context
s" : refresh-desc-bufs" eval  ( dev -- )
1A4799C 	9C 53 A0  1 
1A479A0 	13 3A 20 72 65 66 72 65 
1A479A8 	73 68 2D 64 65 73 63 2D 
1A479B0 	62 75 66 73  0  0  0  0 
1A479B8 	D8 E5 A0  1 
s"    set-target" eval
1A479BC 	9C 53 A0  1 
1A479C0 	 D 20 20 20 73 65 74 2D 
1A479C8 	74 61 72 67 65 74  0  0 
1A479D0 	D8 E5 A0  1 
s"    dev-desc-buf d# 18 get-dev-desc to /dev-desc-buf" eval		\ Refresh dev-desc-buf
1A479D4 	9C 53 A0  1 
1A479D8 	33 20 20 20 64 65 76 2D 
1A479E0 	64 65 73 63 2D 62 75 66 
1A479E8 	20 64 23 20 31 38 20 67 
1A479F0 	65 74 2D 64 65 76 2D 64 
1A479F8 	65 73 63 20 74 6F 20 2F 
1A47A00 	64 65 76 2D 64 65 73 63 
1A47A08 	2D 62 75 66  0  0  0  0 
1A47A10 	D8 E5 A0  1 
s"    cfg-desc-buf     0 get-cfg-desc to /cfg-desc-buf" eval		\ Refresh cfg-desc-buf
1A47A14 	9C 53 A0  1 
1A47A18 	33 20 20 20 63 66 67 2D 
1A47A20 	64 65 73 63 2D 62 75 66 
1A47A28 	20 20 20 20 20 30 20 67 
1A47A30 	65 74 2D 63 66 67 2D 64 
1A47A38 	65 73 63 20 74 6F 20 2F 
1A47A40 	63 66 67 2D 64 65 73 63 
1A47A48 	2D 62 75 66  0  0  0  0 
1A47A50 	D8 E5 A0  1 
s"    get-str-descriptors ;" eval
1A47A54 	9C 53 A0  1 
1A47A58 	18 20 20 20 67 65 74 2D 
1A47A60 	73 74 72 2D 64 65 73 63 
1A47A68 	72 69 70 74 6F 72 73 20 
1A47A70 	3B  0  0  0 D8 E5 A0  1 

\ \ \ \

\ Executed in root hub node context
s" : get-initial-descriptors" eval  ( dev -- )
1A47A78 	9C 53 A0  1 19 3A 20 67 
1A47A80 	65 74 2D 69 6E 69 74 69 
1A47A88 	61 6C 2D 64 65 73 63 72 
1A47A90 	69 70 74 6F 72 73  0  0 
1A47A98 	D8 E5 A0  1 
s"    get-initial-dev-desc" eval                         ( )
1A47A9C 	9C 53 A0  1 
1A47AA0 	17 20 20 20 67 65 74 2D 
1A47AA8 	69 6E 69 74 69 61 6C 2D 
1A47AB0 	64 65 76 2D 64 65 73 63 
1A47AB8 	 0  0  0  0 D8 E5 A0  1 
s"    cfg-desc-buf 0 get-cfg-desc to /cfg-desc-buf	;" eval
1A47AC0 	9C 53 A0  1 31 20 20 20 
1A47AC8 	63 66 67 2D 64 65 73 63 
1A47AD0 	2D 62 75 66 20 30 20 67 
1A47AD8 	65 74 2D 63 66 67 2D 64 
1A47AE0 	65 73 63 20 74 6F 20 2F 
1A47AE8 	63 66 67 2D 64 65 73 63 
1A47AF0 	2D 62 75 66  9 3B  0  0 
1A47AF8 	D8 E5 A0  1 

\ Executed in hub node context (root hub or subordinate hub) - creates new child nodes via (make-device-node)
s" : make-device-node" eval  ( port dev -- )
1A47AFC 	9C 53 A0  1 
1A47B00 	12 3A 20 6D 61 6B 65 2D 
1A47B08 	64 65 76 69 63 65 2D 6E 
1A47B10 	6F 64 65  0 D8 E5 A0  1 
 "    dup "" get-initial-descriptors"" my-self $call-method" eval	( port dev )
1A47B18 	9C 53 A0  1 36 20 20 20 
1A47B20 	64 75 70 20 22 20 67 65 
1A47B28 	74 2D 69 6E 69 74 69 61 
1A47B30 	6C 2D 64 65 73 63 72 69 
1A47B38 	70 74 6F 72 73 22 20 6D 
1A47B40 	79 2D 73 65 6C 66 20 24 
1A47B48 	63 61 6C 6C 2D 6D 65 74 
1A47B50 	68 6F 64  0 D8 E5 A0  1 
s"    /cfg-desc-buf 0=  if  2drop  exit  then" eval		( port dev )
1A47B58 	9C 53 A0  1 2A 20 20 20 
1A47B60 	2F 63 66 67 2D 64 65 73 
1A47B68 	63 2D 62 75 66 20 30 3D 
1A47B70 	20 20 69 66 20 20 32 64 
1A47B78 	72 6F 70 20 20 65 78 69 
1A47B80 	74 20 20 74 68 65 6E  0 
1A47B88 	D8 E5 A0  1 
s"    asso-class?  if  1  else  cfg-desc-buf 4 + c@  then" eval  ( port dev #intf )
1A47B8C 	9C 53 A0  1 
1A47B90 	36 20 20 20 61 73 73 6F 
1A47B98 	2D 63 6C 61 73 73 3F 20 
1A47BA0 	20 69 66 20 20 31 20 20 
1A47BA8 	65 6C 73 65 20 20 63 66 
1A47BB0 	67 2D 64 65 73 63 2D 62 
1A47BB8 	75 66 20 34 20 2B 20 63 
1A47BC0 	40 20 20 74 68 65 6E  0 
1A47BC8 	D8 E5 A0  1 
s"    0  ?do" eval				                ( port dev )
1A47BCC 	9C 53 A0  1 
1A47BD0 	 9 20 20 20 30 20 20 3F 
1A47BD8 	64 6F  0  0 D8 E5 A0  1 
 "       dup "" refresh-desc-bufs"" my-self $call-method" eval	( port dev )
1A47BE0 	9C 53 A0  1 33 20 20 20 
1A47BE8 	20 20 20 64 75 70 20 22 
1A47BF0 	20 72 65 66 72 65 73 68 
1A47BF8 	2D 64 65 73 63 2D 62 75 
1A47C00 	66 73 22 20 6D 79 2D 73 
1A47C08 	65 6C 66 20 24 63 61 6C 
1A47C10 	6C 2D 6D 65 74 68 6F 64 
1A47C18 	 0  0  0  0 D8 E5 A0  1 
s"       2dup swap i (make-device-node)" eval			( port dev )
1A47C20 	9C 53 A0  1 24 20 20 20 
1A47C28 	20 20 20 32 64 75 70 20 
1A47C30 	73 77 61 70 20 69 20 28 
1A47C38 	6D 61 6B 65 2D 64 65 76 
1A47C40 	69 63 65 2D 6E 6F 64 65 
1A47C48 	29  0  0  0 D8 E5 A0  1 
s"    loop  2drop ;" eval
1A47C50 	9C 53 A0  1 10 20 20 20 
1A47C58 	6C 6F 6F 70 20 20 32 64 
1A47C60 	72 6F 70 20 3B  0  0  0 
1A47C68 	D8 E5 A0  1 


\ See hcd/ehci/probehub.fth for information about hub20-dev and hub20-port

s" : get-hub20-dev" eval  ( -- hub-dev )
1A47C6C 	9C 53 A0  1 
1A47C70 	 F 3A 20 67 65 74 2D 68 
1A47C78 	75 62 32 30 2D 64 65 76 
1A47C80 	 0  0  0  0 D8 E5 A0  1 
 "    "" hub20-dev"" get-inherited-property 0=  if" eval   ( value$ )
1A47C88 	9C 53 A0  1 2D 20 20 20 
1A47C90 	22 20 68 75 62 32 30 2D 
1A47C98 	64 65 76 22 20 67 65 74 
1A47CA0 	2D 69 6E 68 65 72 69 74 
1A47CA8 	65 64 2D 70 72 6F 70 65 
1A47CB0 	72 74 79 20 30 3D 20 20 
1A47CB8 	69 66  0  0 D8 E5 A0  1 
s"       decode-int nip nip" eval                        ( hub-dev )
1A47CC0 	9C 53 A0  1 18 20 20 20 
1A47CC8 	20 20 20 64 65 63 6F 64 
1A47CD0 	65 2D 69 6E 74 20 6E 69 
1A47CD8 	70 20 6E 69 70  0  0  0 
1A47CE0 	D8 E5 A0  1 
s"    else" eval                                         ( )
1A47CE4 	9C 53 A0  1 
1A47CE8 	 7 20 20 20 65 6C 73 65 
1A47CF0 	 0  0  0  0 D8 E5 A0  1 
s"       1" eval                                         ( hub-dev )
1A47CF8 	9C 53 A0  1  7 20 20 20 
1A47D00 	20 20 20 31  0  0  0  0 
1A47D08 	D8 E5 A0  1 
s"    then ;" eval                                        ( hub-dev )
1A47D0C 	9C 53 A0  1 
1A47D10 	 9 20 20 20 74 68 65 6E 
1A47D18 	20 3B  0  0 D8 E5 A0  1 

s" : get-hub20-port" eval  ( port -- port' )
1A47D20 	9C 53 A0  1 10 3A 20 67 
1A47D28 	65 74 2D 68 75 62 32 30 
1A47D30 	2D 70 6F 72 74  0  0  0 
1A47D38 	D8 E5 A0  1 
 "    "" hub20-port"" get-inherited-property 0=  if" eval  ( port value$ )
1A47D3C 	9C 53 A0  1 
1A47D40 	2E 20 20 20 22 20 68 75 
1A47D48 	62 32 30 2D 70 6F 72 74 
1A47D50 	22 20 67 65 74 2D 69 6E 
1A47D58 	68 65 72 69 74 65 64 2D 
1A47D60 	70 72 6F 70 65 72 74 79 
1A47D68 	20 30 3D 20 20 69 66  0 
1A47D70 	D8 E5 A0  1 
s"       rot drop" eval				        ( value$ )
1A47D74 	9C 53 A0  1 
1A47D78 	 E 20 20 20 20 20 20 72 
1A47D80 	6F 74 20 64 72 6F 70  0 
1A47D88 	D8 E5 A0  1 
s"       decode-int nip nip" eval                        ( port' )
1A47D8C 	9C 53 A0  1 
1A47D90 	18 20 20 20 20 20 20 64 
1A47D98 	65 63 6F 64 65 2D 69 6E 
1A47DA0 	74 20 6E 69 70 20 6E 69 
1A47DA8 	70  0  0  0 D8 E5 A0  1 
s"    then ;" eval                                         ( port )
1A47DB0 	9C 53 A0  1  9 20 20 20 
1A47DB8 	74 68 65 6E 20 3B  0  0 
1A47DC0 	D8 E5 A0  1 


\ Executed in the root hub node context
s" : setup-new-node" eval  ( port speed hub-port hub-dev -- true | port dev xt false )
1A47DC4 	9C 53 A0  1 
1A47DC8 	10 3A 20 73 65 74 75 70 
1A47DD0 	2D 6E 65 77 2D 6E 6F 64 
1A47DD8 	65  0  0  0 D8 E5 A0  1 
  \ Allocate device number
s"   next-device#  if  2drop  exit  then" eval	( port speed hub-port hub-dev dev )
1A47DE0 	9C 53 A0  1 25 20 20 6E 
1A47DE8 	65 78 74 2D 64 65 76 69 
1A47DF0 	63 65 23 20 20 69 66 20 
1A47DF8 	20 32 64 72 6F 70 20 20 
1A47E00 	65 78 69 74 20 20 74 68 
1A47E08 	65 6E  0  0 D8 E5 A0  1 

s"    tuck di-hub!" eval				( port speed hub-port dev )
1A47E10 	9C 53 A0  1  F 20 20 20 
1A47E18 	74 75 63 6B 20 64 69 2D 
1A47E20 	68 75 62 21  0  0  0  0 
1A47E28 	D8 E5 A0  1 
s"    tuck di-port!" eval			( port speed dev )
1A47E2C 	9C 53 A0  1 
1A47E30 	10 20 20 20 74 75 63 6B 
1A47E38 	20 64 69 2D 70 6F 72 74 
1A47E40 	21  0  0  0 D8 E5 A0  1 
s"    tuck di-speed!" eval			( port dev )
1A47E48 	9C 53 A0  1 11 20 20 20 
1A47E50 	74 75 63 6B 20 64 69 2D 
1A47E58 	73 70 65 65 64 21  0  0 
1A47E60 	D8 E5 A0  1 

s"    0 set-target" eval				( port dev )	\ Address it as device 0
1A47E64 	9C 53 A0  1 
1A47E68 	 F 20 20 20 30 20 73 65 
1A47E70 	74 2D 74 61 72 67 65 74 
1A47E78 	 0  0  0  0 D8 E5 A0  1 

   \ Some devices (e.g. Lexar USB-to-SD and at least one USB FLASH drive) fail
   \ on set-address unless you first read the device descriptor from address 0.
   \ On other devices, this will fail, but it won't cause problems, and the
   \ descriptor will be re-read later by make-device-node
s"    dup get-initial-dev-desc" eval             ( port dev )
1A47E80 	9C 53 A0  1 1B 20 20 20 
1A47E88 	64 75 70 20 67 65 74 2D 
1A47E90 	69 6E 69 74 69 61 6C 2D 
1A47E98 	64 65 76 2D 64 65 73 63 
1A47EA0 	 0  0  0  0 D8 E5 A0  1 

\  over reset-port                	( port dev )	\ Some devices want to be reset here

s"    dup set-address  if" eval			( port dev )	\ Assign it usb addr dev
1A47EA8 	9C 53 A0  1 16 20 20 20 
1A47EB0 	64 75 70 20 73 65 74 2D 
1A47EB8 	61 64 64 72 65 73 73 20 
1A47EC0 	20 69 66  0 D8 E5 A0  1 
 "       ."" Retrying with a delay"" cr" eval
1A47EC8 	9C 53 A0  1 22 20 20 20 
1A47ED0 	20 20 20 2E 22 20 52 65 
1A47ED8 	74 72 79 69 6E 67 20 77 
1A47EE0 	69 74 68 20 61 20 64 65 
1A47EE8 	6C 61 79 22 20 63 72  0 
1A47EF0 	D8 E5 A0  1 
s"       over reset-port  d# 5000 ms" eval
1A47EF4 	9C 53 A0  1 
1A47EF8 	21 20 20 20 20 20 20 6F 
1A47F00 	76 65 72 20 72 65 73 65 
1A47F08 	74 2D 70 6F 72 74 20 20 
1A47F10 	64 23 20 35 30 30 30 20 
1A47F18 	6D 73  0  0 D8 E5 A0  1 
s"       dup set-address  if" eval		( port dev )	\ Assign it usb addr dev
1A47F20 	9C 53 A0  1 19 20 20 20 
1A47F28 	20 20 20 64 75 70 20 73 
1A47F30 	65 74 2D 61 64 64 72 65 
1A47F38 	73 73 20 20 69 66  0  0 
1A47F40 	D8 E5 A0  1 
         \ Recycle device number?
s"          2drop false exit" eval		( -- false )
1A47F44 	9C 53 A0  1 
1A47F48 	19 20 20 20 20 20 20 20 
1A47F50 	20 20 32 64 72 6F 70 20 
1A47F58 	66 61 6C 73 65 20 65 78 
1A47F60 	69 74  0  0 D8 E5 A0  1 
s"       then" eval				( port dev )
1A47F68 	9C 53 A0  1  A 20 20 20 
1A47F70 	20 20 20 74 68 65 6E  0 
1A47F78 	D8 E5 A0  1 
s"    then" eval					( port dev )
1A47F7C 	9C 53 A0  1 
1A47F80 	 7 20 20 20 74 68 65 6E 
1A47F88 	 0  0  0  0 D8 E5 A0  1 
 
s"    dup set-target" eval			( port dev )	\ Address it as device dev
1A47F90 	9C 53 A0  1 11 20 20 20 
1A47F98 	64 75 70 20 73 65 74 2D 
1A47FA0 	74 61 72 67 65 74  0  0 
1A47FA8 	D8 E5 A0  1 
s"    ['] make-device-node	 true	;" eval	( port dev xt )
1A47FAC 	9C 53 A0  1 
1A47FB0 	1F 20 20 20 5B 27 5D 20 
1A47FB8 	6D 61 6B 65 2D 64 65 76 
1A47FC0 	69 63 65 2D 6E 6F 64 65 
1A47FC8 	 9 20 74 72 75 65  9 3B 
1A47FD0 	 0  0  0  0 D8 E5 A0  1 


\ Begins execution in a (root or subordinate) hub node context, creates an instance record
\ for the subordinate hub node "phandle", switches to that instance context, executes
\ "reprobe-hub" in that context, destroys the instance, and returns to the original context.
s" : reprobe-hub-node" eval  ( phandle -- )
1A47FD8 	9C 53 A0  1 12 3A 20 72 
1A47FE0 	65 70 72 6F 62 65 2D 68 
1A47FE8 	75 62 2D 6E 6F 64 65  0 
1A47FF0 	D8 E5 A0  1 
s"    >r" eval                                       ( r: phandle )
1A47FF4 	9C 53 A0  1 
1A47FF8 	 5 20 20 20 3E 72  0  0 
1A48000 	D8 E5 A0  1 
 "    "" reprobe-hub"" r@ find-method  if" eval        ( xt r: phandle )
1A48004 	9C 53 A0  1 
1A48008 	24 20 20 20 22 20 72 65 
1A48010 	70 72 6F 62 65 2D 68 75 
1A48018 	62 22 20 72 40 20 66 69 
1A48020 	6E 64 2D 6D 65 74 68 6F 
1A48028 	64 20 20 69 66  0  0  0 
1A48030 	D8 E5 A0  1 
s"       r@ push-package" eval                       ( xt r: phandle )
1A48034 	9C 53 A0  1 
1A48038 	15 20 20 20 20 20 20 72 
1A48040 	40 20 70 75 73 68 2D 70 
1A48048 	61 63 6B 61 67 65  0  0 
1A48050 	D8 E5 A0  1 
 "       "" "" new-instance" eval                      ( xt r: phandle )
1A48054 	9C 53 A0  1 
1A48058 	16 20 20 20 20 20 20 22 
1A48060 	20 22 20 6E 65 77 2D 69 
1A48068 	6E 73 74 61 6E 63 65  0 
1A48070 	D8 E5 A0  1 
s"       set-default-unit" eval                      ( xt r: phandle )
1A48074 	9C 53 A0  1 
1A48078 	16 20 20 20 20 20 20 73 
1A48080 	65 74 2D 64 65 66 61 75 
1A48088 	6C 74 2D 75 6E 69 74  0 
1A48090 	D8 E5 A0  1 
s"       execute" eval                               ( r: phandle )
1A48094 	9C 53 A0  1 
1A48098 	 D 20 20 20 20 20 20 65 
1A480A0 	78 65 63 75 74 65  0  0 
1A480A8 	D8 E5 A0  1 
s"       destroy-instance" eval                      ( r: phandle )
1A480AC 	9C 53 A0  1 
1A480B0 	16 20 20 20 20 20 20 64 
1A480B8 	65 73 74 72 6F 79 2D 69 
1A480C0 	6E 73 74 61 6E 63 65  0 
1A480C8 	D8 E5 A0  1 
s"       pop-package" eval                           ( r: phandle )
1A480CC 	9C 53 A0  1 
1A480D0 	11 20 20 20 20 20 20 70 
1A480D8 	6F 70 2D 70 61 63 6B 61 
1A480E0 	67 65  0  0 D8 E5 A0  1 
s"    then" eval                                     ( r: phandle )
1A480E8 	9C 53 A0  1  7 20 20 20 
1A480F0 	74 68 65 6E  0  0  0  0 
1A480F8 	D8 E5 A0  1 
s"    r> drop ;" eval
1A480FC 	9C 53 A0  1 
1A48100 	 C 20 20 20 72 3E 20 64 
1A48108 	72 6F 70 20 3B  0  0  0 
1A48110 	D8 E5 A0  1 

\ Returns true if there is a child hub node associated with port
s" : port-is-hub?" eval  ( port -- false | phandle true )
1A48114 	9C 53 A0  1 
1A48118 	 E 3A 20 70 6F 72 74 2D 
1A48120 	69 73 2D 68 75 62 3F  0 
1A48128 	D8 E5 A0  1 
s"    my-self ihandle>phandle child" eval                       ( port phandle )
1A4812C 	9C 53 A0  1 
1A48130 	20 20 20 20 6D 79 2D 73 
1A48138 	65 6C 66 20 69 68 61 6E 
1A48140 	64 6C 65 3E 70 68 61 6E 
1A48148 	64 6C 65 20 63 68 69 6C 
1A48150 	64  0  0  0 D8 E5 A0  1 
s"    begin  ?dup  while" eval                                  ( port phandle )
1A48158 	9C 53 A0  1 15 20 20 20 
1A48160 	62 65 67 69 6E 20 20 3F 
1A48168 	64 75 70 20 20 77 68 69 
1A48170 	6C 65  0  0 D8 E5 A0  1 
 "       "" name"" 2 pick get-package-property 0=  if" eval       ( port phandle adr len )
1A48178 	9C 53 A0  1 30 20 20 20 
1A48180 	20 20 20 22 20 6E 61 6D 
1A48188 	65 22 20 32 20 70 69 63 
1A48190 	6B 20 67 65 74 2D 70 61 
1A48198 	63 6B 61 67 65 2D 70 72 
1A481A0 	6F 70 65 72 74 79 20 30 
1A481A8 	3D 20 20 69 66  0  0  0 
1A481B0 	D8 E5 A0  1 
 "          1-  "" hub"" $=  if" eval                             ( port phandle )
1A481B4 	9C 53 A0  1 
1A481B8 	1A 20 20 20 20 20 20 20 
1A481C0 	20 20 31 2D 20 20 22 20 
1A481C8 	68 75 62 22 20 24 3D 20 
1A481D0 	20 69 66  0 D8 E5 A0  1 
 "             "" reg"" 2 pick get-package-property 0=  if" eval  ( port phandle adr len )
1A481D8 	9C 53 A0  1 35 20 20 20 
1A481E0 	20 20 20 20 20 20 20 20 
1A481E8 	20 22 20 72 65 67 22 20 
1A481F0 	32 20 70 69 63 6B 20 67 
1A481F8 	65 74 2D 70 61 63 6B 61 
1A48200 	67 65 2D 70 72 6F 70 65 
1A48208 	72 74 79 20 30 3D 20 20 
1A48210 	69 66  0  0 D8 E5 A0  1 
s"                decode-int nip nip" eval                      ( port phandle port1 )
1A48218 	9C 53 A0  1 21 20 20 20 
1A48220 	20 20 20 20 20 20 20 20 
1A48228 	20 20 20 20 64 65 63 6F 
1A48230 	64 65 2D 69 6E 74 20 6E 
1A48238 	69 70 20 6E 69 70  0  0 
1A48240 	D8 E5 A0  1 
s"                2 pick =  if" eval                            ( port phandle )
1A48244 	9C 53 A0  1 
1A48248 	1B 20 20 20 20 20 20 20 
1A48250 	20 20 20 20 20 20 20 20 
1A48258 	32 20 70 69 63 6B 20 3D 
1A48260 	20 20 69 66  0  0  0  0 
1A48268 	D8 E5 A0  1 
s"                   nip true exit" eval                        ( -- phandle true )
1A4826C 	9C 53 A0  1 
1A48270 	1F 20 20 20 20 20 20 20 
1A48278 	20 20 20 20 20 20 20 20 
1A48280 	20 20 20 6E 69 70 20 74 
1A48288 	72 75 65 20 65 78 69 74 
1A48290 	 0  0  0  0 D8 E5 A0  1 
s"                then" eval                                    ( port phandle )
1A48298 	9C 53 A0  1 13 20 20 20 
1A482A0 	20 20 20 20 20 20 20 20 
1A482A8 	20 20 20 20 74 68 65 6E 
1A482B0 	 0  0  0  0 D8 E5 A0  1 
s"             then" eval                                       ( port phandle )
1A482B8 	9C 53 A0  1 10 20 20 20 
1A482C0 	20 20 20 20 20 20 20 20 
1A482C8 	20 74 68 65 6E  0  0  0 
1A482D0 	D8 E5 A0  1 
s"          then" eval                                          ( port phandle )
1A482D4 	9C 53 A0  1 
1A482D8 	 D 20 20 20 20 20 20 20 
1A482E0 	20 20 74 68 65 6E  0  0 
1A482E8 	D8 E5 A0  1 
s"       then" eval                                             ( port phandle )
1A482EC 	9C 53 A0  1 
1A482F0 	 A 20 20 20 20 20 20 74 
1A482F8 	68 65 6E  0 D8 E5 A0  1 
s"       peer" eval                                             ( port phandle' )
1A48300 	9C 53 A0  1  A 20 20 20 
1A48308 	20 20 20 70 65 65 72  0 
1A48310 	D8 E5 A0  1 
s"    repeat" eval                                              ( port )
1A48314 	9C 53 A0  1 
1A48318 	 9 20 20 20 72 65 70 65 
1A48320 	61 74  0  0 D8 E5 A0  1 
s"    drop false ;" eval                                         ( false )
1A48328 	9C 53 A0  1  F 20 20 20 
1A48330 	64 72 6F 70 20 66 61 6C 
1A48338 	73 65 20 3B  0  0  0  0 
1A48340 	D8 E5 A0  1 


s" : probe-setup" eval  ( -- )
1A48344 	9C 53 A0  1 
1A48348 	 D 3A 20 70 72 6F 62 65 
1A48350 	2D 73 65 74 75 70  0  0 
1A48358 	D8 E5 A0  1 
    \ Set active-package so device nodes can be added and removed
s"    my-self ihandle>phandle push-package" eval
1A4835C 	9C 53 A0  1 
1A48360 	27 20 20 20 6D 79 2D 73 
1A48368 	65 6C 66 20 69 68 61 6E 
1A48370 	64 6C 65 3E 70 68 61 6E 
1A48378 	64 6C 65 20 70 75 73 68 
1A48380 	2D 70 61 63 6B 61 67 65 
1A48388 	 0  0  0  0 D8 E5 A0  1 

s"    alloc-pkt-buf ;" eval
1A48390 	9C 53 A0  1 12 20 20 20 
1A48398 	61 6C 6C 6F 63 2D 70 6B 
1A483A0 	74 2D 62 75 66 20 3B  0 
1A483A8 	D8 E5 A0  1 

s" : probe-teardown" eval  ( -- )
1A483AC 	9C 53 A0  1 
1A483B0 	10 3A 20 70 72 6F 62 65 
1A483B8 	2D 74 65 61 72 64 6F 77 
1A483C0 	6E  0  0  0 D8 E5 A0  1 
s"    free-pkt-buf" eval
1A483C8 	9C 53 A0  1  F 20 20 20 
1A483D0 	66 72 65 65 2D 70 6B 74 
1A483D8 	2D 62 75 66  0  0  0  0 
1A483E0 	D8 E5 A0  1 
s"    pop-package ;" eval
1A483E4 	9C 53 A0  1 
1A483E8 	10 20 20 20 70 6F 70 2D 
1A483F0 	70 61 63 6B 61 67 65 20 
1A483F8 	3B  0  0  0 D8 E5 A0  1 
;
1A48400 	58 46 A0  1 

OpenFirmware/dev/usb2/hcd/device.fth_AL	25A8 1A48404 purpose: USB Hub Probing Code

hex

: probehubfth
1A48404 	70 72 6F 62 
1A48408 	65 68 75 62 66 74 68 8B 
1A48410 	98 79 A4  1 20 40 A0  1 

s" set-usb20-char" $find ?dup
1A48418 	9C 53 A0  1  E 73 65 74 
1A48420 	2D 75 73 62 32 30 2D 63 
1A48428 	68 61 72  0 C4 93 A0  1 
1A48430 	B4 70 A0  1 
if s" : set-usb20-char ( port dev -- ) 2drop  ;" eval then
1A48434 	DC 41 A0  1 
1A48438 	38  0  0  0 9C 53 A0  1 
1A48440 	29 3A 20 73 65 74 2D 75 
1A48448 	73 62 32 30 2D 63 68 61 
1A48450 	72 20 28 20 70 6F 72 74 
1A48458 	20 64 65 76 20 2D 2D 20 
1A48460 	29 20 32 64 72 6F 70 20 
1A48468 	20 3B  0  0 D8 E5 A0  1 
2drop
1A48470 	AC 49 A0  1 

s" 8 buffer: hub-buf" eval   \ For hub probing
1A48474 	9C 53 A0  1 
1A48478 	11 38 20 62 75 66 66 65 
1A48480 	72 3A 20 68 75 62 2D 62 
1A48488 	75 66  0  0 D8 E5 A0  1 

 " : power-hub-port   ( port -- )  PORT_POWER  DR_PORT "" set-feature"" $call-parent drop  ;" eval
1A48490 	9C 53 A0  1 57 3A 20 70 
1A48498 	6F 77 65 72 2D 68 75 62 
1A484A0 	2D 70 6F 72 74 20 20 20 
1A484A8 	28 20 70 6F 72 74 20 2D 
1A484B0 	2D 20 29 20 20 50 4F 52 
1A484B8 	54 5F 50 4F 57 45 52 20 
1A484C0 	20 44 52 5F 50 4F 52 54 
1A484C8 	20 22 20 73 65 74 2D 66 
1A484D0 	65 61 74 75 72 65 22 20 
1A484D8 	24 63 61 6C 6C 2D 70 61 
1A484E0 	72 65 6E 74 20 64 72 6F 
1A484E8 	70 20 20 3B  0  0  0  0 
1A484F0 	D8 E5 A0  1 
 " : reset-hub-port   ( port -- )  PORT_RESET  DR_PORT "" set-feature"" $call-parent drop  d# 20 ms  ;" eval
1A484F4 	9C 53 A0  1 
1A484F8 	61 3A 20 72 65 73 65 74 
1A48500 	2D 68 75 62 2D 70 6F 72 
1A48508 	74 20 20 20 28 20 70 6F 
1A48510 	72 74 20 2D 2D 20 29 20 
1A48518 	20 50 4F 52 54 5F 52 45 
1A48520 	53 45 54 20 20 44 52 5F 
1A48528 	50 4F 52 54 20 22 20 73 
1A48530 	65 74 2D 66 65 61 74 75 
1A48538 	72 65 22 20 24 63 61 6C 
1A48540 	6C 2D 70 61 72 65 6E 74 
1A48548 	20 64 72 6F 70 20 20 64 
1A48550 	23 20 32 30 20 6D 73 20 
1A48558 	20 3B  0  0 D8 E5 A0  1 
\ Test modes: 1:J 2:K 3:SE0_NAK 4:Packet 5:ForceEnable
 " : test-hub-port    ( port test-mode -- )  wljoin  PORT_TEST   DR_PORT "" set-feature"" $call-parent drop  ;" eval
1A48560 	9C 53 A0  1 69 3A 20 74 
1A48568 	65 73 74 2D 68 75 62 2D 
1A48570 	70 6F 72 74 20 20 20 20 
1A48578 	28 20 70 6F 72 74 20 74 
1A48580 	65 73 74 2D 6D 6F 64 65 
1A48588 	20 2D 2D 20 29 20 20 77 
1A48590 	6C 6A 6F 69 6E 20 20 50 
1A48598 	4F 52 54 5F 54 45 53 54 
1A485A0 	20 20 20 44 52 5F 50 4F 
1A485A8 	52 54 20 22 20 73 65 74 
1A485B0 	2D 66 65 61 74 75 72 65 
1A485B8 	22 20 24 63 61 6C 6C 2D 
1A485C0 	70 61 72 65 6E 74 20 64 
1A485C8 	72 6F 70 20 20 3B  0  0 
1A485D0 	D8 E5 A0  1 
 " : untest-hub-port  ( port -- )  PORT_TEST   DR_PORT "" clear-feature"" $call-parent drop  ;" eval
1A485D4 	9C 53 A0  1 
1A485D8 	59 3A 20 75 6E 74 65 73 
1A485E0 	74 2D 68 75 62 2D 70 6F 
1A485E8 	72 74 20 20 28 20 70 6F 
1A485F0 	72 74 20 2D 2D 20 29 20 
1A485F8 	20 50 4F 52 54 5F 54 45 
1A48600 	53 54 20 20 20 44 52 5F 
1A48608 	50 4F 52 54 20 22 20 63 
1A48610 	6C 65 61 72 2D 66 65 61 
1A48618 	74 75 72 65 22 20 24 63 
1A48620 	61 6C 6C 2D 70 61 72 65 
1A48628 	6E 74 20 64 72 6F 70 20 
1A48630 	20 3B  0  0 D8 E5 A0  1 
 " : clear-status-change  ( port -- )  C_PORT_CONNECTION  DR_PORT "" clear-feature"" $call-parent drop  ;" eval
1A48638 	9C 53 A0  1 64 3A 20 63 
1A48640 	6C 65 61 72 2D 73 74 61 
1A48648 	74 75 73 2D 63 68 61 6E 
1A48650 	67 65 20 20 28 20 70 6F 
1A48658 	72 74 20 2D 2D 20 29 20 
1A48660 	20 43 5F 50 4F 52 54 5F 
1A48668 	43 4F 4E 4E 45 43 54 49 
1A48670 	4F 4E 20 20 44 52 5F 50 
1A48678 	4F 52 54 20 22 20 63 6C 
1A48680 	65 61 72 2D 66 65 61 74 
1A48688 	75 72 65 22 20 24 63 61 
1A48690 	6C 6C 2D 70 61 72 65 6E 
1A48698 	74 20 64 72 6F 70 20 20 
1A486A0 	3B  0  0  0 D8 E5 A0  1 
 " : parent-set-target  ( dev -- )  "" set-target"" $call-parent  ;" eval
1A486A8 	9C 53 A0  1 3E 3A 20 70 
1A486B0 	61 72 65 6E 74 2D 73 65 
1A486B8 	74 2D 74 61 72 67 65 74 
1A486C0 	20 20 28 20 64 65 76 20 
1A486C8 	2D 2D 20 29 20 20 22 20 
1A486D0 	73 65 74 2D 74 61 72 67 
1A486D8 	65 74 22 20 24 63 61 6C 
1A486E0 	6C 2D 70 61 72 65 6E 74 
1A486E8 	20 20 3B  0 D8 E5 A0  1 
s" : hub-error?" eval  ( -- error? )
1A486F0 	9C 53 A0  1  C 3A 20 68 
1A486F8 	75 62 2D 65 72 72 6F 72 
1A48700 	3F  0  0  0 D8 E5 A0  1 
 "    hub-buf 4  0  DR_HUB "" get-status"" $call-parent" eval    ( actual usberror )
1A48708 	9C 53 A0  1 32 20 20 20 
1A48710 	68 75 62 2D 62 75 66 20 
1A48718 	34 20 20 30 20 20 44 52 
1A48720 	5F 48 55 42 20 22 20 67 
1A48728 	65 74 2D 73 74 61 74 75 
1A48730 	73 22 20 24 63 61 6C 6C 
1A48738 	2D 70 61 72 65 6E 74  0 
1A48740 	D8 E5 A0  1 
s"    nip  if" eval                                   ( )
1A48744 	9C 53 A0  1 
1A48748 	 A 20 20 20 6E 69 70 20 
1A48750 	20 69 66  0 D8 E5 A0  1 
 "       ."" Failed to get hub status"" cr" eval
1A48758 	9C 53 A0  1 25 20 20 20 
1A48760 	20 20 20 2E 22 20 46 61 
1A48768 	69 6C 65 64 20 74 6F 20 
1A48770 	67 65 74 20 68 75 62 20 
1A48778 	73 74 61 74 75 73 22 20 
1A48780 	63 72  0  0 D8 E5 A0  1 
s"       true" eval                                   ( true )
1A48788 	9C 53 A0  1  A 20 20 20 
1A48790 	20 20 20 74 72 75 65  0 
1A48798 	D8 E5 A0  1 
s"    else" eval                                      ( )
1A4879C 	9C 53 A0  1 
1A487A0 	 7 20 20 20 65 6C 73 65 
1A487A8 	 0  0  0  0 D8 E5 A0  1 
s"       hub-buf 2+ c@ 2 and  if" eval                ( )
1A487B0 	9C 53 A0  1 1D 20 20 20 
1A487B8 	20 20 20 68 75 62 2D 62 
1A487C0 	75 66 20 32 2B 20 63 40 
1A487C8 	20 32 20 61 6E 64 20 20 
1A487D0 	69 66  0  0 D8 E5 A0  1 
 "          ."" USB Hub shut down due to over-current"" cr" eval
1A487D8 	9C 53 A0  1 35 20 20 20 
1A487E0 	20 20 20 20 20 20 2E 22 
1A487E8 	20 55 53 42 20 48 75 62 
1A487F0 	20 73 68 75 74 20 64 6F 
1A487F8 	77 6E 20 64 75 65 20 74 
1A48800 	6F 20 6F 76 65 72 2D 63 
1A48808 	75 72 72 65 6E 74 22 20 
1A48810 	63 72  0  0 D8 E5 A0  1 
s"          true" eval                                ( true )
1A48818 	9C 53 A0  1  D 20 20 20 
1A48820 	20 20 20 20 20 20 74 72 
1A48828 	75 65  0  0 D8 E5 A0  1 
s"       else" eval                                   ( )
1A48830 	9C 53 A0  1  A 20 20 20 
1A48838 	20 20 20 65 6C 73 65  0 
1A48840 	D8 E5 A0  1 
s"          false" eval                               ( false )
1A48844 	9C 53 A0  1 
1A48848 	 E 20 20 20 20 20 20 20 
1A48850 	20 20 66 61 6C 73 65  0 
1A48858 	D8 E5 A0  1 
s"       then" eval                                   ( error? )
1A4885C 	9C 53 A0  1 
1A48860 	 A 20 20 20 20 20 20 74 
1A48868 	68 65 6E  0 D8 E5 A0  1 
s"    then ;" eval                                     ( error? )
1A48870 	9C 53 A0  1  9 20 20 20 
1A48878 	74 68 65 6E 20 3B  0  0 
1A48880 	D8 E5 A0  1 


s" : get-port-status" eval  ( port -- error? )
1A48884 	9C 53 A0  1 
1A48888 	11 3A 20 67 65 74 2D 70 
1A48890 	6F 72 74 2D 73 74 61 74 
1A48898 	75 73  0  0 D8 E5 A0  1 
 "    hub-buf 4  2 pick   DR_PORT "" get-status"" $call-parent" eval    ( port actual usberror )
1A488A0 	9C 53 A0  1 39 20 20 20 
1A488A8 	68 75 62 2D 62 75 66 20 
1A488B0 	34 20 20 32 20 70 69 63 
1A488B8 	6B 20 20 20 44 52 5F 50 
1A488C0 	4F 52 54 20 22 20 67 65 
1A488C8 	74 2D 73 74 61 74 75 73 
1A488D0 	22 20 24 63 61 6C 6C 2D 
1A488D8 	70 61 72 65 6E 74  0  0 
1A488E0 	D8 E5 A0  1 
s"    nip  if" eval                                   ( port )
1A488E4 	9C 53 A0  1 
1A488E8 	 A 20 20 20 6E 69 70 20 
1A488F0 	20 69 66  0 D8 E5 A0  1 
 "       ."" Failed to get port status for port "" u. cr" eval
1A488F8 	9C 53 A0  1 33 20 20 20 
1A48900 	20 20 20 2E 22 20 46 61 
1A48908 	69 6C 65 64 20 74 6F 20 
1A48910 	67 65 74 20 70 6F 72 74 
1A48918 	20 73 74 61 74 75 73 20 
1A48920 	66 6F 72 20 70 6F 72 74 
1A48928 	20 22 20 75 2E 20 63 72 
1A48930 	 0  0  0  0 D8 E5 A0  1 
s"       true" eval                                   ( true )
1A48938 	9C 53 A0  1  A 20 20 20 
1A48940 	20 20 20 74 72 75 65  0 
1A48948 	D8 E5 A0  1 
s"    else" eval                                      ( port )
1A4894C 	9C 53 A0  1 
1A48950 	 7 20 20 20 65 6C 73 65 
1A48958 	 0  0  0  0 D8 E5 A0  1 
s"       drop false" eval                             ( false )
1A48960 	9C 53 A0  1 10 20 20 20 
1A48968 	20 20 20 64 72 6F 70 20 
1A48970 	66 61 6C 73 65  0  0  0 
1A48978 	D8 E5 A0  1 
s"    then ;" eval
1A4897C 	9C 53 A0  1 
1A48980 	 9 20 20 20 74 68 65 6E 
1A48988 	20 3B  0  0 D8 E5 A0  1 

s" : port-status-changed?" eval  ( hub-dev port -- false | connected? true )
1A48990 	9C 53 A0  1 16 3A 20 70 
1A48998 	6F 72 74 2D 73 74 61 74 
1A489A0 	75 73 2D 63 68 61 6E 67 
1A489A8 	65 64 3F  0 D8 E5 A0  1 
s"    swap parent-set-target" eval       ( port )
1A489B0 	9C 53 A0  1 19 20 20 20 
1A489B8 	73 77 61 70 20 70 61 72 
1A489C0 	65 6E 74 2D 73 65 74 2D 
1A489C8 	74 61 72 67 65 74  0  0 
1A489D0 	D8 E5 A0  1 
s"    dup get-port-status  if" eval      ( port )
1A489D4 	9C 53 A0  1 
1A489D8 	1A 20 20 20 64 75 70 20 
1A489E0 	67 65 74 2D 70 6F 72 74 
1A489E8 	2D 73 74 61 74 75 73 20 
1A489F0 	20 69 66  0 D8 E5 A0  1 
s"       drop false exit" eval           ( -- false )
1A489F8 	9C 53 A0  1 15 20 20 20 
1A48A00 	20 20 20 64 72 6F 70 20 
1A48A08 	66 61 6C 73 65 20 65 78 
1A48A10 	69 74  0  0 D8 E5 A0  1 
s"    then" eval                         ( port )
1A48A18 	9C 53 A0  1  7 20 20 20 
1A48A20 	74 68 65 6E  0  0  0  0 
1A48A28 	D8 E5 A0  1 
 
s"    hub-buf c@ 8 and  if" eval         ( port )
1A48A2C 	9C 53 A0  1 
1A48A30 	17 20 20 20 68 75 62 2D 
1A48A38 	62 75 66 20 63 40 20 38 
1A48A40 	20 61 6E 64 20 20 69 66 
1A48A48 	 0  0  0  0 D8 E5 A0  1 
 "       ."" Hub port "" . ."" is over current"" cr" eval
1A48A50 	9C 53 A0  1 2C 20 20 20 
1A48A58 	20 20 20 2E 22 20 48 75 
1A48A60 	62 20 70 6F 72 74 20 22 
1A48A68 	20 2E 20 2E 22 20 69 73 
1A48A70 	20 6F 76 65 72 20 63 75 
1A48A78 	72 72 65 6E 74 22 20 63 
1A48A80 	72  0  0  0 D8 E5 A0  1 
s"       false  exit" eval               ( -- false )
1A48A88 	9C 53 A0  1 11 20 20 20 
1A48A90 	20 20 20 66 61 6C 73 65 
1A48A98 	20 20 65 78 69 74  0  0 
1A48AA0 	D8 E5 A0  1 
s"   then" eval
1A48AA4 	9C 53 A0  1 
1A48AA8 	 6 20 20 74 68 65 6E  0 
1A48AB0 	D8 E5 A0  1 

s"    hub-buf 2+ c@  1 and  if" eval     ( port )
1A48AB4 	9C 53 A0  1 
1A48AB8 	1B 20 20 20 68 75 62 2D 
1A48AC0 	62 75 66 20 32 2B 20 63 
1A48AC8 	40 20 20 31 20 61 6E 64 
1A48AD0 	20 20 69 66  0  0  0  0 
1A48AD8 	D8 E5 A0  1 
       \ Status changed
s"       clear-status-change" eval
1A48ADC 	9C 53 A0  1 
1A48AE0 	19 20 20 20 20 20 20 63 
1A48AE8 	6C 65 61 72 2D 73 74 61 
1A48AF0 	74 75 73 2D 63 68 61 6E 
1A48AF8 	67 65  0  0 D8 E5 A0  1 
s"       hub-buf c@ 1 and  0<>" eval     ( connected? )
1A48B00 	9C 53 A0  1 1B 20 20 20 
1A48B08 	20 20 20 68 75 62 2D 62 
1A48B10 	75 66 20 63 40 20 31 20 
1A48B18 	61 6E 64 20 20 30 3C 3E 
1A48B20 	 0  0  0  0 D8 E5 A0  1 
s"       true" eval                      ( connected? true )
1A48B28 	9C 53 A0  1  A 20 20 20 
1A48B30 	20 20 20 74 72 75 65  0 
1A48B38 	D8 E5 A0  1 
s"    else" eval                         ( port )
1A48B3C 	9C 53 A0  1 
1A48B40 	 7 20 20 20 65 6C 73 65 
1A48B48 	 0  0  0  0 D8 E5 A0  1 
s"       drop false" eval                ( false )
1A48B50 	9C 53 A0  1 10 20 20 20 
1A48B58 	20 20 20 64 72 6F 70 20 
1A48B60 	66 61 6C 73 65  0  0  0 
1A48B68 	D8 E5 A0  1 
s"    then ;" eval
1A48B6C 	9C 53 A0  1 
1A48B70 	 9 20 20 20 74 68 65 6E 
1A48B78 	20 3B  0  0 D8 E5 A0  1 

s" : probe-hub-port" eval  ( hub-dev port -- )
1A48B80 	9C 53 A0  1 10 3A 20 70 
1A48B88 	72 6F 62 65 2D 68 75 62 
1A48B90 	2D 70 6F 72 74  0  0  0 
1A48B98 	D8 E5 A0  1 
    \ Reset the port to determine the speed
s"    swap parent-set-target" eval			( port )
1A48B9C 	9C 53 A0  1 
1A48BA0 	19 20 20 20 73 77 61 70 
1A48BA8 	20 70 61 72 65 6E 74 2D 
1A48BB0 	73 65 74 2D 74 61 72 67 
1A48BB8 	65 74  0  0 D8 E5 A0  1 
s"    dup reset-hub-port" eval				( port )
1A48BC0 	9C 53 A0  1 15 20 20 20 
1A48BC8 	64 75 70 20 72 65 73 65 
1A48BD0 	74 2D 68 75 62 2D 70 6F 
1A48BD8 	72 74  0  0 D8 E5 A0  1 
 
    \ get-port-status fills hub-buf with connection status, speed, and other information
s"    dup get-port-status" eval  			( port error? )
1A48BE0 	9C 53 A0  1 16 20 20 20 
1A48BE8 	64 75 70 20 67 65 74 2D 
1A48BF0 	70 6F 72 74 2D 73 74 61 
1A48BF8 	74 75 73  0 D8 E5 A0  1 
s"    over clear-status-change" eval              	( port error? )
1A48C00 	9C 53 A0  1 1B 20 20 20 
1A48C08 	6F 76 65 72 20 63 6C 65 
1A48C10 	61 72 2D 73 74 61 74 75 
1A48C18 	73 2D 63 68 61 6E 67 65 
1A48C20 	 0  0  0  0 D8 E5 A0  1 
s"    if  drop exit  then" eval				( port )
1A48C28 	9C 53 A0  1 16 20 20 20 
1A48C30 	69 66 20 20 64 72 6F 70 
1A48C38 	20 65 78 69 74 20 20 74 
1A48C40 	68 65 6E  0 D8 E5 A0  1 

s"    dup disable-old-nodes" eval			( port ) 
1A48C48 	9C 53 A0  1 18 20 20 20 
1A48C50 	64 75 70 20 64 69 73 61 
1A48C58 	62 6C 65 2D 6F 6C 64 2D 
1A48C60 	6E 6F 64 65 73  0  0  0 
1A48C68 	D8 E5 A0  1 
s"    hub-buf c@ 1 and 0=  if  drop exit  then" eval	( port )  \ No device connected
1A48C6C 	9C 53 A0  1 
1A48C70 	2B 20 20 20 68 75 62 2D 
1A48C78 	62 75 66 20 63 40 20 31 
1A48C80 	20 61 6E 64 20 30 3D 20 
1A48C88 	20 69 66 20 20 64 72 6F 
1A48C90 	70 20 65 78 69 74 20 20 
1A48C98 	74 68 65 6E  0  0  0  0 
1A48CA0 	D8 E5 A0  1 
s"    hub-buf le-w@ h# 600 and 9 >>" eval  		( port speed )
1A48CA4 	9C 53 A0  1 
1A48CA8 	20 20 20 20 68 75 62 2D 
1A48CB0 	62 75 66 20 6C 65 2D 77 
1A48CB8 	40 20 68 23 20 36 30 30 
1A48CC0 	20 61 6E 64 20 39 20 3E 
1A48CC8 	3E  0  0  0 D8 E5 A0  1 

   \ hub-port and hub-dev route USB 1.1 transactions through USB 2.0 hubs
s"    over get-hub20-port  get-hub20-dev" eval		( port speed hub-port hub-dev )
1A48CD0 	9C 53 A0  1 25 20 20 20 
1A48CD8 	6F 76 65 72 20 67 65 74 
1A48CE0 	2D 68 75 62 32 30 2D 70 
1A48CE8 	6F 72 74 20 20 67 65 74 
1A48CF0 	2D 68 75 62 32 30 2D 64 
1A48CF8 	65 76  0  0 D8 E5 A0  1 

 \ Execute setup-new-node in root context and make-device-node in hub node context
 "   "" setup-new-node"" $call-parent  if  execute  then ;" eval
1A48D00 	9C 53 A0  1 35 20 20 22 
1A48D08 	20 73 65 74 75 70 2D 6E 
1A48D10 	65 77 2D 6E 6F 64 65 22 
1A48D18 	20 24 63 61 6C 6C 2D 70 
1A48D20 	61 72 65 6E 74 20 20 69 
1A48D28 	66 20 20 65 78 65 63 75 
1A48D30 	74 65 20 20 74 68 65 6E 
1A48D38 	20 3B  0  0 D8 E5 A0  1 

s" : hub-#ports" eval  ( -- #ports )
1A48D40 	9C 53 A0  1  C 3A 20 68 
1A48D48 	75 62 2D 23 70 6F 72 74 
1A48D50 	73  0  0  0 D8 E5 A0  1 
 "    hub-buf 8 0 0 HUB DR_HUB "" get-desc"" $call-parent nip  if" eval
1A48D58 	9C 53 A0  1 3C 20 20 20 
1A48D60 	68 75 62 2D 62 75 66 20 
1A48D68 	38 20 30 20 30 20 48 55 
1A48D70 	42 20 44 52 5F 48 55 42 
1A48D78 	20 22 20 67 65 74 2D 64 
1A48D80 	65 73 63 22 20 24 63 61 
1A48D88 	6C 6C 2D 70 61 72 65 6E 
1A48D90 	74 20 6E 69 70 20 20 69 
1A48D98 	66  0  0  0 D8 E5 A0  1 
 "       ."" Failed to get hub descriptor"" cr" eval
1A48DA0 	9C 53 A0  1 29 20 20 20 
1A48DA8 	20 20 20 2E 22 20 46 61 
1A48DB0 	69 6C 65 64 20 74 6F 20 
1A48DB8 	67 65 74 20 68 75 62 20 
1A48DC0 	64 65 73 63 72 69 70 74 
1A48DC8 	6F 72 22 20 63 72  0  0 
1A48DD0 	D8 E5 A0  1 
s"       0 exit" eval
1A48DD4 	9C 53 A0  1 
1A48DD8 	 C 20 20 20 20 20 20 30 
1A48DE0 	20 65 78 69 74  0  0  0 
1A48DE8 	D8 E5 A0  1 
s"    then" eval
1A48DEC 	9C 53 A0  1 
1A48DF0 	 7 20 20 20 74 68 65 6E 
1A48DF8 	 0  0  0  0 D8 E5 A0  1 
s"    hub-buf 2 + c@ ;" eval 		( #ports )
1A48E00 	9C 53 A0  1 13 20 20 20 
1A48E08 	68 75 62 2D 62 75 66 20 
1A48E10 	32 20 2B 20 63 40 20 3B 
1A48E18 	 0  0  0  0 D8 E5 A0  1 

s" : hub-delay  ( -- #2ms )  hub-buf 5 + c@  ;" eval
1A48E20 	9C 53 A0  1 2B 3A 20 68 
1A48E28 	75 62 2D 64 65 6C 61 79 
1A48E30 	20 20 28 20 2D 2D 20 23 
1A48E38 	32 6D 73 20 29 20 20 68 
1A48E40 	75 62 2D 62 75 66 20 35 
1A48E48 	20 2B 20 63 40 20 20 3B 
1A48E50 	 0  0  0  0 D8 E5 A0  1 

s" : power-hub-ports" eval  ( #ports -- )
1A48E58 	9C 53 A0  1 11 3A 20 70 
1A48E60 	6F 77 65 72 2D 68 75 62 
1A48E68 	2D 70 6F 72 74 73  0  0 
1A48E70 	D8 E5 A0  1 
s"    1+  1  ?do  i power-hub-port  loop" eval
1A48E74 	9C 53 A0  1 
1A48E78 	25 20 20 20 31 2B 20 20 
1A48E80 	31 20 20 3F 64 6F 20 20 
1A48E88 	69 20 70 6F 77 65 72 2D 
1A48E90 	68 75 62 2D 70 6F 72 74 
1A48E98 	20 20 6C 6F 6F 70  0  0 
1A48EA0 	D8 E5 A0  1 

s"    hub-delay 2* ms" eval
1A48EA4 	9C 53 A0  1 
1A48EA8 	12 20 20 20 68 75 62 2D 
1A48EB0 	64 65 6C 61 79 20 32 2A 
1A48EB8 	20 6D 73  0 D8 E5 A0  1 

 "    "" usb-delay"" ['] evaluate catch  if" eval      ( )
1A48EC0 	9C 53 A0  1 26 20 20 20 
1A48EC8 	22 20 75 73 62 2D 64 65 
1A48ED0 	6C 61 79 22 20 5B 27 5D 
1A48ED8 	20 65 76 61 6C 75 61 74 
1A48EE0 	65 20 63 61 74 63 68 20 
1A48EE8 	20 69 66  0 D8 E5 A0  1 
s"       2drop  d# 100" eval                         ( ms )
1A48EF0 	9C 53 A0  1 13 20 20 20 
1A48EF8 	20 20 20 32 64 72 6F 70 
1A48F00 	20 20 64 23 20 31 30 30 
1A48F08 	 0  0  0  0 D8 E5 A0  1 
s"    then" eval                                     ( ms )
1A48F10 	9C 53 A0  1  7 20 20 20 
1A48F18 	74 68 65 6E  0  0  0  0 
1A48F20 	D8 E5 A0  1 
s"    ms ;" eval
1A48F24 	9C 53 A0  1 
1A48F28 	 7 20 20 20 6D 73 20 3B 
1A48F30 	 0  0  0  0 D8 E5 A0  1 

s" : safe-probe-hub-port" eval  ( hub-dev port -- )
1A48F38 	9C 53 A0  1 15 3A 20 73 
1A48F40 	61 66 65 2D 70 72 6F 62 
1A48F48 	65 2D 68 75 62 2D 70 6F 
1A48F50 	72 74  0  0 D8 E5 A0  1 
s"    tuck ['] probe-hub-port catch  if" eval    ( port x x )
1A48F58 	9C 53 A0  1 24 20 20 20 
1A48F60 	74 75 63 6B 20 5B 27 5D 
1A48F68 	20 70 72 6F 62 65 2D 68 
1A48F70 	75 62 2D 70 6F 72 74 20 
1A48F78 	63 61 74 63 68 20 20 69 
1A48F80 	66  0  0  0 D8 E5 A0  1 
 "       2drop  ."" Failed to probe hub port "" . cr" eval
1A48F88 	9C 53 A0  1 2F 20 20 20 
1A48F90 	20 20 20 32 64 72 6F 70 
1A48F98 	20 20 2E 22 20 46 61 69 
1A48FA0 	6C 65 64 20 74 6F 20 70 
1A48FA8 	72 6F 62 65 20 68 75 62 
1A48FB0 	20 70 6F 72 74 20 22 20 
1A48FB8 	2E 20 63 72  0  0  0  0 
1A48FC0 	D8 E5 A0  1 
s"    else" eval                                 ( port )
1A48FC4 	9C 53 A0  1 
1A48FC8 	 7 20 20 20 65 6C 73 65 
1A48FD0 	 0  0  0  0 D8 E5 A0  1 
s"       drop" eval
1A48FD8 	9C 53 A0  1  A 20 20 20 
1A48FE0 	20 20 20 64 72 6F 70  0 
1A48FE8 	D8 E5 A0  1 
s"    then ;" eval
1A48FEC 	9C 53 A0  1 
1A48FF0 	 9 20 20 20 74 68 65 6E 
1A48FF8 	20 3B  0  0 D8 E5 A0  1 

s" : probe-hub" eval  ( dev -- )
1A49000 	9C 53 A0  1  B 3A 20 70 
1A49008 	72 6F 62 65 2D 68 75 62 
1A49010 	 0  0  0  0 D8 E5 A0  1 
s"    dup parent-set-target" eval		( hub-dev )
1A49018 	9C 53 A0  1 18 20 20 20 
1A49020 	64 75 70 20 70 61 72 65 
1A49028 	6E 74 2D 73 65 74 2D 74 
1A49030 	61 72 67 65 74  0  0  0 
1A49038 	D8 E5 A0  1 
s"    hub-#ports  dup  0=  if" eval		( hub-dev #ports )
1A4903C 	9C 53 A0  1 
1A49040 	1A 20 20 20 68 75 62 2D 
1A49048 	23 70 6F 72 74 73 20 20 
1A49050 	64 75 70 20 20 30 3D 20 
1A49058 	20 69 66  0 D8 E5 A0  1 
s"       2drop exit" eval			( -- )
1A49060 	9C 53 A0  1 10 20 20 20 
1A49068 	20 20 20 32 64 72 6F 70 
1A49070 	20 65 78 69 74  0  0  0 
1A49078 	D8 E5 A0  1 
s"    then" eval					( hub-dev #ports )
1A4907C 	9C 53 A0  1 
1A49080 	 7 20 20 20 74 68 65 6E 
1A49088 	 0  0  0  0 D8 E5 A0  1 

 "    "" configuration#"" get-int-property" eval	( hub-dev #ports config# )
1A49090 	9C 53 A0  1 25 20 20 20 
1A49098 	22 20 63 6F 6E 66 69 67 
1A490A0 	75 72 61 74 69 6F 6E 23 
1A490A8 	22 20 67 65 74 2D 69 6E 
1A490B0 	74 2D 70 72 6F 70 65 72 
1A490B8 	74 79  0  0 D8 E5 A0  1 
 "    "" set-config"" $call-parent" eval           ( hub-dev #ports usberr )
1A490C0 	9C 53 A0  1 1D 20 20 20 
1A490C8 	22 20 73 65 74 2D 63 6F 
1A490D0 	6E 66 69 67 22 20 24 63 
1A490D8 	61 6C 6C 2D 70 61 72 65 
1A490E0 	6E 74  0  0 D8 E5 A0  1 
 "    if  drop  ."" Failed to set config for hub at "" u. cr exit  then" eval  ( hub-dev #ports )
1A490E8 	9C 53 A0  1 42 20 20 20 
1A490F0 	69 66 20 20 64 72 6F 70 
1A490F8 	20 20 2E 22 20 46 61 69 
1A49100 	6C 65 64 20 74 6F 20 73 
1A49108 	65 74 20 63 6F 6E 66 69 
1A49110 	67 20 66 6F 72 20 68 75 
1A49118 	62 20 61 74 20 22 20 75 
1A49120 	2E 20 63 72 20 65 78 69 
1A49128 	74 20 20 74 68 65 6E  0 
1A49130 	D8 E5 A0  1 

s"    dup power-hub-ports" eval			( hub-dev #ports )
1A49134 	9C 53 A0  1 
1A49138 	16 20 20 20 64 75 70 20 
1A49140 	70 6F 77 65 72 2D 68 75 
1A49148 	62 2D 70 6F 72 74 73  0 
1A49150 	D8 E5 A0  1 

s"   hub-error?  if  2drop exit  then" eval	( hub-dev #ports )
1A49154 	9C 53 A0  1 
1A49158 	22 20 20 68 75 62 2D 65 
1A49160 	72 72 6F 72 3F 20 20 69 
1A49168 	66 20 20 32 64 72 6F 70 
1A49170 	20 65 78 69 74 20 20 74 
1A49178 	68 65 6E  0 D8 E5 A0  1 

s"    1+ 1  ?do" eval				( hub-dev )
1A49180 	9C 53 A0  1  C 20 20 20 
1A49188 	31 2B 20 31 20 20 3F 64 
1A49190 	6F  0  0  0 D8 E5 A0  1 
s"       dup i safe-probe-hub-port" eval		( hub-dev )
1A49198 	9C 53 A0  1 1F 20 20 20 
1A491A0 	20 20 20 64 75 70 20 69 
1A491A8 	20 73 61 66 65 2D 70 72 
1A491B0 	6F 62 65 2D 68 75 62 2D 
1A491B8 	70 6F 72 74  0  0  0  0 
1A491C0 	D8 E5 A0  1 
s"    loop" eval					( hub-dev )
1A491C4 	9C 53 A0  1 
1A491C8 	 7 20 20 20 6C 6F 6F 70 
1A491D0 	 0  0  0  0 D8 E5 A0  1 
s"    drop ;" eval
1A491D8 	9C 53 A0  1  9 20 20 20 
1A491E0 	64 72 6F 70 20 3B  0  0 
1A491E8 	D8 E5 A0  1 

s" : probe-hub-xt  ( -- adr )  ['] probe-hub  ;" eval
1A491EC 	9C 53 A0  1 
1A491F0 	2C 3A 20 70 72 6F 62 65 
1A491F8 	2D 68 75 62 2D 78 74 20 
1A49200 	20 28 20 2D 2D 20 61 64 
1A49208 	72 20 29 20 20 5B 27 5D 
1A49210 	20 70 72 6F 62 65 2D 68 
1A49218 	75 62 20 20 3B  0  0  0 
1A49220 	D8 E5 A0  1 

s" : do-reprobe-hub" eval  ( dev -- )
1A49224 	9C 53 A0  1 
1A49228 	10 3A 20 64 6F 2D 72 65 
1A49230 	70 72 6F 62 65 2D 68 75 
1A49238 	62  0  0  0 D8 E5 A0  1 
s"    dup parent-set-target" eval			( hub-dev )
1A49240 	9C 53 A0  1 18 20 20 20 
1A49248 	64 75 70 20 70 61 72 65 
1A49250 	6E 74 2D 73 65 74 2D 74 
1A49258 	61 72 67 65 74  0  0  0 
1A49260 	D8 E5 A0  1 
   
s"    hub-#ports  dup 0=  if" eval                       ( hub-dev #ports )
1A49264 	9C 53 A0  1 
1A49268 	19 20 20 20 68 75 62 2D 
1A49270 	23 70 6F 72 74 73 20 20 
1A49278 	64 75 70 20 30 3D 20 20 
1A49280 	69 66  0  0 D8 E5 A0  1 
s"       2drop exit" eval                                ( -- )
1A49288 	9C 53 A0  1 10 20 20 20 
1A49290 	20 20 20 32 64 72 6F 70 
1A49298 	20 65 78 69 74  0  0  0 
1A492A0 	D8 E5 A0  1 
s"    then" eval                                         ( hub-dev #ports )
1A492A4 	9C 53 A0  1 
1A492A8 	 7 20 20 20 74 68 65 6E 
1A492B0 	 0  0  0  0 D8 E5 A0  1 

s"    hub-error?  if  2drop exit  then" eval		( hub-dev #ports )
1A492B8 	9C 53 A0  1 23 20 20 20 
1A492C0 	68 75 62 2D 65 72 72 6F 
1A492C8 	72 3F 20 20 69 66 20 20 
1A492D0 	32 64 72 6F 70 20 65 78 
1A492D8 	69 74 20 20 74 68 65 6E 
1A492E0 	 0  0  0  0 D8 E5 A0  1 

s"    1+  1  ?do" eval                                   ( hub-dev )
1A492E8 	9C 53 A0  1  D 20 20 20 
1A492F0 	31 2B 20 20 31 20 20 3F 
1A492F8 	64 6F  0  0 D8 E5 A0  1 
s"       dup i port-status-changed?  if" eval            ( hub-dev connected? )
1A49300 	9C 53 A0  1 24 20 20 20 
1A49308 	20 20 20 64 75 70 20 69 
1A49310 	20 70 6F 72 74 2D 73 74 
1A49318 	61 74 75 73 2D 63 68 61 
1A49320 	6E 67 65 64 3F 20 20 69 
1A49328 	66  0  0  0 D8 E5 A0  1 
s"          i disable-old-nodes" eval                    ( hub-dev connected? )
1A49330 	9C 53 A0  1 1C 20 20 20 
1A49338 	20 20 20 20 20 20 69 20 
1A49340 	64 69 73 61 62 6C 65 2D 
1A49348 	6F 6C 64 2D 6E 6F 64 65 
1A49350 	73  0  0  0 D8 E5 A0  1 
s"          if" eval                                     ( hub-dev )
1A49358 	9C 53 A0  1  B 20 20 20 
1A49360 	20 20 20 20 20 20 69 66 
1A49368 	 0  0  0  0 D8 E5 A0  1 
s"             d# 100 ms" eval                           ( hub-dev )  \ Time for device to wake up
1A49370 	9C 53 A0  1 15 20 20 20 
1A49378 	20 20 20 20 20 20 20 20 
1A49380 	20 64 23 20 31 30 30 20 
1A49388 	6D 73  0  0 D8 E5 A0  1 
s"             dup i safe-probe-hub-port" eval           ( hub-dev )
1A49390 	9C 53 A0  1 25 20 20 20 
1A49398 	20 20 20 20 20 20 20 20 
1A493A0 	20 64 75 70 20 69 20 73 
1A493A8 	61 66 65 2D 70 72 6F 62 
1A493B0 	65 2D 68 75 62 2D 70 6F 
1A493B8 	72 74  0  0 D8 E5 A0  1 
s"          then" eval                                   ( hub-dev )
1A493C0 	9C 53 A0  1  D 20 20 20 
1A493C8 	20 20 20 20 20 20 74 68 
1A493D0 	65 6E  0  0 D8 E5 A0  1 
s"       else" eval                                      ( hub-dev )
1A493D8 	9C 53 A0  1  A 20 20 20 
1A493E0 	20 20 20 65 6C 73 65  0 
1A493E8 	D8 E5 A0  1 
s"          i port-is-hub?  if" eval                     ( hub-dev phandle )
1A493EC 	9C 53 A0  1 
1A493F0 	1B 20 20 20 20 20 20 20 
1A493F8 	20 20 69 20 70 6F 72 74 
1A49400 	2D 69 73 2D 68 75 62 3F 
1A49408 	20 20 69 66  0  0  0  0 
1A49410 	D8 E5 A0  1 
s"             reprobe-hub-node" eval                    ( hub-dev )
1A49414 	9C 53 A0  1 
1A49418 	1C 20 20 20 20 20 20 20 
1A49420 	20 20 20 20 20 72 65 70 
1A49428 	72 6F 62 65 2D 68 75 62 
1A49430 	2D 6E 6F 64 65  0  0  0 
1A49438 	D8 E5 A0  1 
s"          then" eval                                   ( hub-dev )
1A4943C 	9C 53 A0  1 
1A49440 	 D 20 20 20 20 20 20 20 
1A49448 	20 20 74 68 65 6E  0  0 
1A49450 	D8 E5 A0  1 
s"       then" eval                                      ( hub-dev )
1A49454 	9C 53 A0  1 
1A49458 	 A 20 20 20 20 20 20 74 
1A49460 	68 65 6E  0 D8 E5 A0  1 
s"    loop" eval                                         ( hub-dev )
1A49468 	9C 53 A0  1  7 20 20 20 
1A49470 	6C 6F 6F 70  0  0  0  0 
1A49478 	D8 E5 A0  1 
s"    drop ;" eval                                        ( )
1A4947C 	9C 53 A0  1 
1A49480 	 9 20 20 20 64 72 6F 70 
1A49488 	20 3B  0  0 D8 E5 A0  1 


s" : reprobe-hub-xt  ( -- adr )  ['] do-reprobe-hub  ;" eval
1A49490 	9C 53 A0  1 33 3A 20 72 
1A49498 	65 70 72 6F 62 65 2D 68 
1A494A0 	75 62 2D 78 74 20 20 28 
1A494A8 	20 2D 2D 20 61 64 72 20 
1A494B0 	29 20 20 5B 27 5D 20 64 
1A494B8 	6F 2D 72 65 70 72 6F 62 
1A494C0 	65 2D 68 75 62 20 20 3B 
1A494C8 	 0  0  0  0 D8 E5 A0  1 

s" : hub-port-connected?" eval  ( port# -- flag )
1A494D0 	9C 53 A0  1 15 3A 20 68 
1A494D8 	75 62 2D 70 6F 72 74 2D 
1A494E0 	63 6F 6E 6E 65 63 74 65 
1A494E8 	64 3F  0  0 D8 E5 A0  1 
s"    get-port-status  if  false exit  then" eval
1A494F0 	9C 53 A0  1 28 20 20 20 
1A494F8 	67 65 74 2D 70 6F 72 74 
1A49500 	2D 73 74 61 74 75 73 20 
1A49508 	20 69 66 20 20 66 61 6C 
1A49510 	73 65 20 65 78 69 74 20 
1A49518 	20 74 68 65 6E  0  0  0 
1A49520 	D8 E5 A0  1 
s"    hub-buf c@ 1 and  0<> ;" eval
1A49524 	9C 53 A0  1 
1A49528 	1A 20 20 20 68 75 62 2D 
1A49530 	62 75 66 20 63 40 20 31 
1A49538 	20 61 6E 64 20 20 30 3C 
1A49540 	3E 20 3B  0 D8 E5 A0  1 
s" 0 value hub-dev" eval
1A49548 	9C 53 A0  1  F 30 20 76 
1A49550 	61 6C 75 65 20 68 75 62 
1A49558 	2D 64 65 76  0  0  0  0 
1A49560 	D8 E5 A0  1 
s" : wait-hub-connect" eval  ( port# -- error? )
1A49564 	9C 53 A0  1 
1A49568 	12 3A 20 77 61 69 74 2D 
1A49570 	68 75 62 2D 63 6F 6E 6E 
1A49578 	65 63 74  0 D8 E5 A0  1 
s"    begin" eval                            ( port# )
1A49580 	9C 53 A0  1  8 20 20 20 
1A49588 	62 65 67 69 6E  0  0  0 
1A49590 	D8 E5 A0  1 
s"       dup hub-port-connected?  0=" eval   ( port# unconnected? )
1A49594 	9C 53 A0  1 
1A49598 	21 20 20 20 20 20 20 64 
1A495A0 	75 70 20 68 75 62 2D 70 
1A495A8 	6F 72 74 2D 63 6F 6E 6E 
1A495B0 	65 63 74 65 64 3F 20 20 
1A495B8 	30 3D  0  0 D8 E5 A0  1 
s"    while" eval                            ( port# )
1A495C0 	9C 53 A0  1  8 20 20 20 
1A495C8 	77 68 69 6C 65  0  0  0 
1A495D0 	D8 E5 A0  1 
s"       key?  if" eval                      ( port# )
1A495D4 	9C 53 A0  1 
1A495D8 	 E 20 20 20 20 20 20 6B 
1A495E0 	65 79 3F 20 20 69 66  0 
1A495E8 	D8 E5 A0  1 
s"          key h# 1b =  if" eval            ( port# )   \ ESC aborts
1A495EC 	9C 53 A0  1 
1A495F0 	18 20 20 20 20 20 20 20 
1A495F8 	20 20 6B 65 79 20 68 23 
1A49600 	20 31 62 20 3D 20 20 69 
1A49608 	66  0  0  0 D8 E5 A0  1 
s"             drop true exit" eval          ( -- true )
1A49610 	9C 53 A0  1 1A 20 20 20 
1A49618 	20 20 20 20 20 20 20 20 
1A49620 	20 64 72 6F 70 20 74 72 
1A49628 	75 65 20 65 78 69 74  0 
1A49630 	D8 E5 A0  1 
s"          then" eval                       ( port# )
1A49634 	9C 53 A0  1 
1A49638 	 D 20 20 20 20 20 20 20 
1A49640 	20 20 74 68 65 6E  0  0 
1A49648 	D8 E5 A0  1 
s"       then" eval                          ( port# )
1A4964C 	9C 53 A0  1 
1A49650 	 A 20 20 20 20 20 20 74 
1A49658 	68 65 6E  0 D8 E5 A0  1 
s"    repeat" eval                           ( port# )
1A49660 	9C 53 A0  1  9 20 20 20 
1A49668 	72 65 70 65 61 74  0  0 
1A49670 	D8 E5 A0  1 
 "    ."" Device connected - probing ... "" " eval
1A49674 	9C 53 A0  1 
1A49678 	27 20 20 20 2E 22 20 44 
1A49680 	65 76 69 63 65 20 63 6F 
1A49688 	6E 6E 65 63 74 65 64 20 
1A49690 	2D 20 70 72 6F 62 69 6E 
1A49698 	67 20 2E 2E 2E 20 22 20 
1A496A0 	 0  0  0  0 D8 E5 A0  1 
s"    d# 150 ms" eval                        ( port# )   \ Wakeup time
1A496A8 	9C 53 A0  1  C 20 20 20 
1A496B0 	64 23 20 31 35 30 20 6D 
1A496B8 	73  0  0  0 D8 E5 A0  1 
s"    probe-setup" eval                      ( port# )
1A496C0 	9C 53 A0  1  E 20 20 20 
1A496C8 	70 72 6F 62 65 2D 73 65 
1A496D0 	74 75 70  0 D8 E5 A0  1 
s"    hub-dev swap ['] probe-hub-port  catch  if" eval  ( x x  )
1A496D8 	9C 53 A0  1 2D 20 20 20 
1A496E0 	68 75 62 2D 64 65 76 20 
1A496E8 	73 77 61 70 20 5B 27 5D 
1A496F0 	20 70 72 6F 62 65 2D 68 
1A496F8 	75 62 2D 70 6F 72 74 20 
1A49700 	20 63 61 74 63 68 20 20 
1A49708 	69 66  0  0 D8 E5 A0  1 
s"       2drop" eval                         ( )
1A49710 	9C 53 A0  1  B 20 20 20 
1A49718 	20 20 20 32 64 72 6F 70 
1A49720 	 0  0  0  0 D8 E5 A0  1 
 "      ."" Failed"" cr" eval                 ( )
1A49728 	9C 53 A0  1 12 20 20 20 
1A49730 	20 20 2E 22 20 46 61 69 
1A49738 	6C 65 64 22 20 63 72  0 
1A49740 	D8 E5 A0  1 
s"      true" eval                          ( true )
1A49744 	9C 53 A0  1 
1A49748 	 9 20 20 20 20 20 74 72 
1A49750 	75 65  0  0 D8 E5 A0  1 
s"   else" eval                             ( )
1A49758 	9C 53 A0  1  6 20 20 65 
1A49760 	6C 73 65  0 D8 E5 A0  1 
 "      ."" Done"" cr" eval                   ( )
1A49768 	9C 53 A0  1 10 20 20 20 
1A49770 	20 20 2E 22 20 44 6F 6E 
1A49778 	65 22 20 63 72  0  0  0 
1A49780 	D8 E5 A0  1 
s"      false" eval                         ( false )
1A49784 	9C 53 A0  1 
1A49788 	 A 20 20 20 20 20 66 61 
1A49790 	6C 73 65  0 D8 E5 A0  1 
s"   then" eval                             ( error? )
1A49798 	9C 53 A0  1  6 20 20 74 
1A497A0 	68 65 6E  0 D8 E5 A0  1 
s"   probe-teardown ;" eval                  ( error? )
1A497A8 	9C 53 A0  1 12 20 20 70 
1A497B0 	72 6F 62 65 2D 74 65 61 
1A497B8 	72 64 6F 77 6E 20 3B  0 
1A497C0 	D8 E5 A0  1 

s" : (hub-selftest)" eval  ( port -- stop? )
1A497C4 	9C 53 A0  1 
1A497C8 	10 3A 20 28 68 75 62 2D 
1A497D0 	73 65 6C 66 74 65 73 74 
1A497D8 	29  0  0  0 D8 E5 A0  1 
s"    >r" eval
1A497E0 	9C 53 A0  1  5 20 20 20 
1A497E8 	3E 72  0  0 D8 E5 A0  1 
s"    hub-dev parent-set-target" eval              ( )
1A497F0 	9C 53 A0  1 1C 20 20 20 
1A497F8 	68 75 62 2D 64 65 76 20 
1A49800 	70 61 72 65 6E 74 2D 73 
1A49808 	65 74 2D 74 61 72 67 65 
1A49810 	74  0  0  0 D8 E5 A0  1 
s"    r@ get-port-status  if" eval                 ( )
1A49818 	9C 53 A0  1 19 20 20 20 
1A49820 	72 40 20 67 65 74 2D 70 
1A49828 	6F 72 74 2D 73 74 61 74 
1A49830 	75 73 20 20 69 66  0  0 
1A49838 	D8 E5 A0  1 
 "       ."" Get-port-status failed for hub port "" r@ u. cr" eval
1A4983C 	9C 53 A0  1 
1A49840 	37 20 20 20 20 20 20 2E 
1A49848 	22 20 47 65 74 2D 70 6F 
1A49850 	72 74 2D 73 74 61 74 75 
1A49858 	73 20 66 61 69 6C 65 64 
1A49860 	20 66 6F 72 20 68 75 62 
1A49868 	20 70 6F 72 74 20 22 20 
1A49870 	72 40 20 75 2E 20 63 72 
1A49878 	 0  0  0  0 D8 E5 A0  1 
s"       r> drop true exit" eval                   ( -- true )
1A49880 	9C 53 A0  1 17 20 20 20 
1A49888 	20 20 20 72 3E 20 64 72 
1A49890 	6F 70 20 74 72 75 65 20 
1A49898 	65 78 69 74  0  0  0  0 
1A498A0 	D8 E5 A0  1 
s"    then" eval                                   ( )
1A498A4 	9C 53 A0  1 
1A498A8 	 7 20 20 20 74 68 65 6E 
1A498B0 	 0  0  0  0 D8 E5 A0  1 
 "    ."" Hub port "" r@ u. ."" : "" " eval            ( )
1A498B8 	9C 53 A0  1 1E 20 20 20 
1A498C0 	2E 22 20 48 75 62 20 70 
1A498C8 	6F 72 74 20 22 20 72 40 
1A498D0 	20 75 2E 20 2E 22 20 3A 
1A498D8 	20 22 20  0 D8 E5 A0  1 
s"    hub-buf c@ 8 and  if" eval   \ Connected     ( )
1A498E0 	9C 53 A0  1 17 20 20 20 
1A498E8 	68 75 62 2D 62 75 66 20 
1A498F0 	63 40 20 38 20 61 6E 64 
1A498F8 	20 20 69 66  0  0  0  0 
1A49900 	D8 E5 A0  1 
 "       ."" In over current"" cr" eval              ( )
1A49904 	9C 53 A0  1 
1A49908 	1C 20 20 20 20 20 20 2E 
1A49910 	22 20 49 6E 20 6F 76 65 
1A49918 	72 20 63 75 72 72 65 6E 
1A49920 	74 22 20 63 72  0  0  0 
1A49928 	D8 E5 A0  1 
s"       r> drop true exit" eval                   ( -- true )
1A4992C 	9C 53 A0  1 
1A49930 	17 20 20 20 20 20 20 72 
1A49938 	3E 20 64 72 6F 70 20 74 
1A49940 	72 75 65 20 65 78 69 74 
1A49948 	 0  0  0  0 D8 E5 A0  1 
s"    then" eval                                   ( )
1A49950 	9C 53 A0  1  7 20 20 20 
1A49958 	74 68 65 6E  0  0  0  0 
1A49960 	D8 E5 A0  1 
s"    hub-buf c@ 1 and  if" eval   \ Connected     ( )
1A49964 	9C 53 A0  1 
1A49968 	17 20 20 20 68 75 62 2D 
1A49970 	62 75 66 20 63 40 20 31 
1A49978 	20 61 6E 64 20 20 69 66 
1A49980 	 0  0  0  0 D8 E5 A0  1 
 "       ."" In use - "" " eval                      ( )
1A49988 	9C 53 A0  1 14 20 20 20 
1A49990 	20 20 20 2E 22 20 49 6E 
1A49998 	20 75 73 65 20 2D 20 22 
1A499A0 	20  0  0  0 D8 E5 A0  1 
s"       r@ .usb-device cr" eval                   ( )
1A499A8 	9C 53 A0  1 17 20 20 20 
1A499B0 	20 20 20 72 40 20 2E 75 
1A499B8 	73 62 2D 64 65 76 69 63 
1A499C0 	65 20 63 72  0  0  0  0 
1A499C8 	D8 E5 A0  1 
s"    else" eval                                   ( )
1A499CC 	9C 53 A0  1 
1A499D0 	 7 20 20 20 65 6C 73 65 
1A499D8 	 0  0  0  0 D8 E5 A0  1 
s"       diagnostic-mode?  if" eval                ( )
1A499E0 	9C 53 A0  1 1A 20 20 20 
1A499E8 	20 20 20 64 69 61 67 6E 
1A499F0 	6F 73 74 69 63 2D 6D 6F 
1A499F8 	64 65 3F 20 20 69 66  0 
1A49A00 	D8 E5 A0  1 
 "          ."" Please connect a device""  cr" eval  ( )
1A49A04 	9C 53 A0  1 
1A49A08 	28 20 20 20 20 20 20 20 
1A49A10 	20 20 2E 22 20 50 6C 65 
1A49A18 	61 73 65 20 63 6F 6E 6E 
1A49A20 	65 63 74 20 61 20 64 65 
1A49A28 	76 69 63 65 22 20 20 63 
1A49A30 	72  0  0  0 D8 E5 A0  1 
s"          r@ wait-hub-connect  if  r> drop true exit  then" eval   ( )
1A49A38 	9C 53 A0  1 39 20 20 20 
1A49A40 	20 20 20 20 20 20 72 40 
1A49A48 	20 77 61 69 74 2D 68 75 
1A49A50 	62 2D 63 6F 6E 6E 65 63 
1A49A58 	74 20 20 69 66 20 20 72 
1A49A60 	3E 20 64 72 6F 70 20 74 
1A49A68 	72 75 65 20 65 78 69 74 
1A49A70 	20 20 74 68 65 6E  0  0 
1A49A78 	D8 E5 A0  1 
s"          r@ .usb-device cr" eval                                  ( )
1A49A7C 	9C 53 A0  1 
1A49A80 	1A 20 20 20 20 20 20 20 
1A49A88 	20 20 72 40 20 2E 75 73 
1A49A90 	62 2D 64 65 76 69 63 65 
1A49A98 	20 63 72  0 D8 E5 A0  1 
s"       else" eval                                                  ( )
1A49AA0 	9C 53 A0  1  A 20 20 20 
1A49AA8 	20 20 20 65 6C 73 65  0 
1A49AB0 	D8 E5 A0  1 
 "          "" fisheye?"" $call-parent  if" eval                       ( )
1A49AB4 	9C 53 A0  1 
1A49AB8 	25 20 20 20 20 20 20 20 
1A49AC0 	20 20 22 20 66 69 73 68 
1A49AC8 	65 79 65 3F 22 20 24 63 
1A49AD0 	61 6C 6C 2D 70 61 72 65 
1A49AD8 	6E 74 20 20 69 66  0  0 
1A49AE0 	D8 E5 A0  1 
 "             ."" Fisheye pattern"" cr" eval                          ( )
1A49AE4 	9C 53 A0  1 
1A49AE8 	22 20 20 20 20 20 20 20 
1A49AF0 	20 20 20 20 20 2E 22 20 
1A49AF8 	46 69 73 68 65 79 65 20 
1A49B00 	70 61 74 74 65 72 6E 22 
1A49B08 	20 63 72  0 D8 E5 A0  1 
s"             r@ 4 test-hub-port" eval                              ( )
1A49B10 	9C 53 A0  1 1E 20 20 20 
1A49B18 	20 20 20 20 20 20 20 20 
1A49B20 	20 72 40 20 34 20 74 65 
1A49B28 	73 74 2D 68 75 62 2D 70 
1A49B30 	6F 72 74  0 D8 E5 A0  1 
s"             d# 2,000 ms" eval                                     ( )
1A49B38 	9C 53 A0  1 17 20 20 20 
1A49B40 	20 20 20 20 20 20 20 20 
1A49B48 	20 64 23 20 32 2C 30 30 
1A49B50 	30 20 6D 73  0  0  0  0 
1A49B58 	D8 E5 A0  1 
s"             r@ untest-hub-port" eval                              ( )
1A49B5C 	9C 53 A0  1 
1A49B60 	1E 20 20 20 20 20 20 20 
1A49B68 	20 20 20 20 20 72 40 20 
1A49B70 	75 6E 74 65 73 74 2D 68 
1A49B78 	75 62 2D 70 6F 72 74  0 
1A49B80 	D8 E5 A0  1 
s"             r@ reset-hub-port  r@ power-hub-port" eval            ( )
1A49B84 	9C 53 A0  1 
1A49B88 	30 20 20 20 20 20 20 20 
1A49B90 	20 20 20 20 20 72 40 20 
1A49B98 	72 65 73 65 74 2D 68 75 
1A49BA0 	62 2D 70 6F 72 74 20 20 
1A49BA8 	72 40 20 70 6F 77 65 72 
1A49BB0 	2D 68 75 62 2D 70 6F 72 
1A49BB8 	74  0  0  0 D8 E5 A0  1 
s"          else" eval                                               ( )
1A49BC0 	9C 53 A0  1  D 20 20 20 
1A49BC8 	20 20 20 20 20 20 65 6C 
1A49BD0 	73 65  0  0 D8 E5 A0  1 
 "             ."" Empty"" cr" eval                                 ( )
1A49BD8 	9C 53 A0  1 18 20 20 20 
1A49BE0 	20 20 20 20 20 20 20 20 
1A49BE8 	20 2E 22 20 45 6D 70 74 
1A49BF0 	79 22 20 63 72  0  0  0 
1A49BF8 	D8 E5 A0  1 
s"          then" eval                                               ( )
1A49BFC 	9C 53 A0  1 
1A49C00 	 D 20 20 20 20 20 20 20 
1A49C08 	20 20 74 68 65 6E  0  0 
1A49C10 	D8 E5 A0  1 
s"       then" eval                                                  ( )
1A49C14 	9C 53 A0  1 
1A49C18 	 A 20 20 20 20 20 20 74 
1A49C20 	68 65 6E  0 D8 E5 A0  1 
s"    then" eval                                                     ( )
1A49C28 	9C 53 A0  1  7 20 20 20 
1A49C30 	74 68 65 6E  0  0  0  0 
1A49C38 	D8 E5 A0  1 
s"    r> drop false ;" eval
1A49C3C 	9C 53 A0  1 
1A49C40 	12 20 20 20 72 3E 20 64 
1A49C48 	72 6F 70 20 66 61 6C 73 
1A49C50 	65 20 3B  0 D8 E5 A0  1 

s" : hub-selftest" eval  ( hub-dev -- error? )
1A49C58 	9C 53 A0  1  E 3A 20 68 
1A49C60 	75 62 2D 73 65 6C 66 74 
1A49C68 	65 73 74  0 D8 E5 A0  1 
s"    to hub-dev" eval                                           ( )
1A49C70 	9C 53 A0  1  D 20 20 20 
1A49C78 	74 6F 20 68 75 62 2D 64 
1A49C80 	65 76  0  0 D8 E5 A0  1 

 "    "" usb-hub-test-list"" get-inherited-property  if" eval      ( )
1A49C88 	9C 53 A0  1 32 20 20 20 
1A49C90 	22 20 75 73 62 2D 68 75 
1A49C98 	62 2D 74 65 73 74 2D 6C 
1A49CA0 	69 73 74 22 20 67 65 74 
1A49CA8 	2D 69 6E 68 65 72 69 74 
1A49CB0 	65 64 2D 70 72 6F 70 65 
1A49CB8 	72 74 79 20 20 69 66  0 
1A49CC0 	D8 E5 A0  1 
s"       hub-#ports 1+  1  ?do" eval                             ( )
1A49CC4 	9C 53 A0  1 
1A49CC8 	1B 20 20 20 20 20 20 68 
1A49CD0 	75 62 2D 23 70 6F 72 74 
1A49CD8 	73 20 31 2B 20 20 31 20 
1A49CE0 	20 3F 64 6F  0  0  0  0 
1A49CE8 	D8 E5 A0  1 
s"          i (hub-selftest)  if  true unloop exit  then" eval   ( )
1A49CEC 	9C 53 A0  1 
1A49CF0 	35 20 20 20 20 20 20 20 
1A49CF8 	20 20 69 20 28 68 75 62 
1A49D00 	2D 73 65 6C 66 74 65 73 
1A49D08 	74 29 20 20 69 66 20 20 
1A49D10 	74 72 75 65 20 75 6E 6C 
1A49D18 	6F 6F 70 20 65 78 69 74 
1A49D20 	20 20 74 68 65 6E  0  0 
1A49D28 	D8 E5 A0  1 
s"       loop" eval                                              ( )
1A49D2C 	9C 53 A0  1 
1A49D30 	 A 20 20 20 20 20 20 6C 
1A49D38 	6F 6F 70  0 D8 E5 A0  1 
s"    else" eval                                                 ( propval$ )
1A49D40 	9C 53 A0  1  7 20 20 20 
1A49D48 	65 6C 73 65  0  0  0  0 
1A49D50 	D8 E5 A0  1 
s"       decode-string 2swap 2drop" eval                         ( list$ )
1A49D54 	9C 53 A0  1 
1A49D58 	1F 20 20 20 20 20 20 64 
1A49D60 	65 63 6F 64 65 2D 73 74 
1A49D68 	72 69 6E 67 20 32 73 77 
1A49D70 	61 70 20 32 64 72 6F 70 
1A49D78 	 0  0  0  0 D8 E5 A0  1 
s"       begin  dup  while" eval                                 ( list$ )
1A49D80 	9C 53 A0  1 17 20 20 20 
1A49D88 	20 20 20 62 65 67 69 6E 
1A49D90 	20 20 64 75 70 20 20 77 
1A49D98 	68 69 6C 65  0  0  0  0 
1A49DA0 	D8 E5 A0  1 
s"          ascii , left-parse-string" eval                      ( list$' dev#$ )
1A49DA4 	9C 53 A0  1 
1A49DA8 	22 20 20 20 20 20 20 20 
1A49DB0 	20 20 61 73 63 69 69 20 
1A49DB8 	2C 20 6C 65 66 74 2D 70 
1A49DC0 	61 72 73 65 2D 73 74 72 
1A49DC8 	69 6E 67  0 D8 E5 A0  1 
s"          base @ >r decimal" eval                              ( list$' dev#$ )
1A49DD0 	9C 53 A0  1 1A 20 20 20 
1A49DD8 	20 20 20 20 20 20 62 61 
1A49DE0 	73 65 20 40 20 3E 72 20 
1A49DE8 	64 65 63 69 6D 61 6C  0 
1A49DF0 	D8 E5 A0  1 
s"          $number  if  0  then" eval                           ( list$' port# )
1A49DF4 	9C 53 A0  1 
1A49DF8 	1D 20 20 20 20 20 20 20 
1A49E00 	20 20 24 6E 75 6D 62 65 
1A49E08 	72 20 20 69 66 20 20 30 
1A49E10 	20 20 74 68 65 6E  0  0 
1A49E18 	D8 E5 A0  1 
s"          r> base !" eval                                      ( list$ port# )
1A49E1C 	9C 53 A0  1 
1A49E20 	12 20 20 20 20 20 20 20 
1A49E28 	20 20 72 3E 20 62 61 73 
1A49E30 	65 20 21  0 D8 E5 A0  1 
s"          (hub-selftest)  if  2drop true exit  then" eval      ( list$ )
1A49E38 	9C 53 A0  1 32 20 20 20 
1A49E40 	20 20 20 20 20 20 28 68 
1A49E48 	75 62 2D 73 65 6C 66 74 
1A49E50 	65 73 74 29 20 20 69 66 
1A49E58 	20 20 32 64 72 6F 70 20 
1A49E60 	74 72 75 65 20 65 78 69 
1A49E68 	74 20 20 74 68 65 6E  0 
1A49E70 	D8 E5 A0  1 
s"       repeat" eval                                            ( list$ )
1A49E74 	9C 53 A0  1 
1A49E78 	 C 20 20 20 20 20 20 72 
1A49E80 	65 70 65 61 74  0  0  0 
1A49E88 	D8 E5 A0  1 
s"       2drop" eval                                             ( )
1A49E8C 	9C 53 A0  1 
1A49E90 	 B 20 20 20 20 20 20 32 
1A49E98 	64 72 6F 70  0  0  0  0 
1A49EA0 	D8 E5 A0  1 
s"    then" eval                                                 ( )
1A49EA4 	9C 53 A0  1 
1A49EA8 	 7 20 20 20 74 68 65 6E 
1A49EB0 	 0  0  0  0 D8 E5 A0  1 

    \ Maybe need to reset the entire hub here
s"    false ;" eval                                               ( false )
1A49EB8 	9C 53 A0  1  A 20 20 20 
1A49EC0 	66 61 6C 73 65 20 3B  0 
1A49EC8 	D8 E5 A0  1 
s" : hub-selftest-xt  ( -- xt )  ['] hub-selftest  ;" eval
1A49ECC 	9C 53 A0  1 
1A49ED0 	31 3A 20 68 75 62 2D 73 
1A49ED8 	65 6C 66 74 65 73 74 2D 
1A49EE0 	78 74 20 20 28 20 2D 2D 
1A49EE8 	20 78 74 20 29 20 20 5B 
1A49EF0 	27 5D 20 68 75 62 2D 73 
1A49EF8 	65 6C 66 74 65 73 74 20 
1A49F00 	20 3B  0  0 D8 E5 A0  1 
;
1A49F08 	58 46 A0  1 

OpenFirmware/dev/usb2/hcd/probehub.fth_AL	1B08 1A49F0C purpose: USB device driver common routines


\ fl d:include\dev\usbm\error.fth			\ USB error definitions
\ fl d:include\dev\usbm\pkt-data.fth		\ Packet data definitions
\ hcdcallfth  \ ( ) fl d:include\dev\usbm\hcd\hcd-call.fth		\ HCD interface
: commonfth
1A49F0C 	 0  0 63 6F 
1A49F10 	6D 6D 6F 6E 66 74 68 89 
1A49F18 	14 84 A4  1 20 40 A0  1 
hex
1A49F20 	C0 8D A0  1 
hcdcallfth
1A49F24 	64 46 A4  1 
S" 0 value device" eval
1A49F28 	9C 53 A0  1  E 30 20 76 
1A49F30 	61 6C 75 65 20 64 65 76 
1A49F38 	69 63 65  0 D8 E5 A0  1 
S" 0 value configuration" eval
1A49F40 	9C 53 A0  1 15 30 20 76 
1A49F48 	61 6C 75 65 20 63 6F 6E 
1A49F50 	66 69 67 75 72 61 74 69 
1A49F58 	6F 6E  0  0 D8 E5 A0  1 
S" 0 value bulk-in-pipe" eval
1A49F60 	9C 53 A0  1 14 30 20 76 
1A49F68 	61 6C 75 65 20 62 75 6C 
1A49F70 	6B 2D 69 6E 2D 70 69 70 
1A49F78 	65  0  0  0 D8 E5 A0  1 
S" 0 value bulk-out-pipe" eval
1A49F80 	9C 53 A0  1 15 30 20 76 
1A49F88 	61 6C 75 65 20 62 75 6C 
1A49F90 	6B 2D 6F 75 74 2D 70 69 
1A49F98 	70 65  0  0 D8 E5 A0  1 
S" 0 value /bulk-in-pipe" eval
1A49FA0 	9C 53 A0  1 15 30 20 76 
1A49FA8 	61 6C 75 65 20 2F 62 75 
1A49FB0 	6C 6B 2D 69 6E 2D 70 69 
1A49FB8 	70 65  0  0 D8 E5 A0  1 
S" 0 value /bulk-out-pipe" eval
1A49FC0 	9C 53 A0  1 16 30 20 76 
1A49FC8 	61 6C 75 65 20 2F 62 75 
1A49FD0 	6C 6B 2D 6F 75 74 2D 70 
1A49FD8 	69 70 65  0 D8 E5 A0  1 
S" 0 value intr-in-pipe" eval
1A49FE0 	9C 53 A0  1 14 30 20 76 
1A49FE8 	61 6C 75 65 20 69 6E 74 
1A49FF0 	72 2D 69 6E 2D 70 69 70 
1A49FF8 	65  0  0  0 D8 E5 A0  1 
S" 0 value intr-out-pipe" eval
1A4A000 	9C 53 A0  1 15 30 20 76 
1A4A008 	61 6C 75 65 20 69 6E 74 
1A4A010 	72 2D 6F 75 74 2D 70 69 
1A4A018 	70 65  0  0 D8 E5 A0  1 
S" 0 value intr-in-interval" eval
1A4A020 	9C 53 A0  1 18 30 20 76 
1A4A028 	61 6C 75 65 20 69 6E 74 
1A4A030 	72 2D 69 6E 2D 69 6E 74 
1A4A038 	65 72 76 61 6C  0  0  0 
1A4A040 	D8 E5 A0  1 
S" 0 value intr-out-interval" eval
1A4A044 	9C 53 A0  1 
1A4A048 	19 30 20 76 61 6C 75 65 
1A4A050 	20 69 6E 74 72 2D 6F 75 
1A4A058 	74 2D 69 6E 74 65 72 76 
1A4A060 	61 6C  0  0 D8 E5 A0  1 
S" 0 value /intr-in-pipe" eval
1A4A068 	9C 53 A0  1 15 30 20 76 
1A4A070 	61 6C 75 65 20 2F 69 6E 
1A4A078 	74 72 2D 69 6E 2D 70 69 
1A4A080 	70 65  0  0 D8 E5 A0  1 
S" 0 value /intr-out-pipe" eval
1A4A088 	9C 53 A0  1 16 30 20 76 
1A4A090 	61 6C 75 65 20 2F 69 6E 
1A4A098 	74 72 2D 6F 75 74 2D 70 
1A4A0A0 	69 70 65  0 D8 E5 A0  1 
S" 0 value iso-in-pipe" eval
1A4A0A8 	9C 53 A0  1 13 30 20 76 
1A4A0B0 	61 6C 75 65 20 69 73 6F 
1A4A0B8 	2D 69 6E 2D 70 69 70 65 
1A4A0C0 	 0  0  0  0 D8 E5 A0  1 
S" 0 value iso-out-pipe" eval
1A4A0C8 	9C 53 A0  1 14 30 20 76 
1A4A0D0 	61 6C 75 65 20 69 73 6F 
1A4A0D8 	2D 6F 75 74 2D 70 69 70 
1A4A0E0 	65  0  0  0 D8 E5 A0  1 
S" 0 value iso-in-interval" eval
1A4A0E8 	9C 53 A0  1 17 30 20 76 
1A4A0F0 	61 6C 75 65 20 69 73 6F 
1A4A0F8 	2D 69 6E 2D 69 6E 74 65 
1A4A100 	72 76 61 6C  0  0  0  0 
1A4A108 	D8 E5 A0  1 
S" 0 value iso-out-interval" eval
1A4A10C 	9C 53 A0  1 
1A4A110 	18 30 20 76 61 6C 75 65 
1A4A118 	20 69 73 6F 2D 6F 75 74 
1A4A120 	2D 69 6E 74 65 72 76 61 
1A4A128 	6C  0  0  0 D8 E5 A0  1 
S" 0 value /iso-in-pipe" eval
1A4A130 	9C 53 A0  1 14 30 20 76 
1A4A138 	61 6C 75 65 20 2F 69 73 
1A4A140 	6F 2D 69 6E 2D 70 69 70 
1A4A148 	65  0  0  0 D8 E5 A0  1 
S" 0 value /iso-out-pipe" eval
1A4A150 	9C 53 A0  1 15 30 20 76 
1A4A158 	61 6C 75 65 20 2F 69 73 
1A4A160 	6F 2D 6F 75 74 2D 70 69 
1A4A168 	70 65  0  0 D8 E5 A0  1 

S" false instance value debug?" eval
1A4A170 	9C 53 A0  1 1B 66 61 6C 
1A4A178 	73 65 20 69 6E 73 74 61 
1A4A180 	6E 63 65 20 76 61 6C 75 
1A4A188 	65 20 64 65 62 75 67 3F 
1A4A190 	 0  0  0  0 D8 E5 A0  1 

S" : debug-on  ( -- )  true to debug?  ;" eval
1A4A198 	9C 53 A0  1 25 3A 20 64 
1A4A1A0 	65 62 75 67 2D 6F 6E 20 
1A4A1A8 	20 28 20 2D 2D 20 29 20 
1A4A1B0 	20 74 72 75 65 20 74 6F 
1A4A1B8 	20 64 65 62 75 67 3F 20 
1A4A1C0 	20 3B  0  0 D8 E5 A0  1 

S" : get-int-property" eval  ( name$ -- n )
1A4A1C8 	9C 53 A0  1 12 3A 20 67 
1A4A1D0 	65 74 2D 69 6E 74 2D 70 
1A4A1D8 	72 6F 70 65 72 74 79  0 
1A4A1E0 	D8 E5 A0  1 
S"  get-my-property  if  0  else  decode-int nip nip  then ;" eval
1A4A1E4 	9C 53 A0  1 
1A4A1E8 	39 20 67 65 74 2D 6D 79 
1A4A1F0 	2D 70 72 6F 70 65 72 74 
1A4A1F8 	79 20 20 69 66 20 20 30 
1A4A200 	20 20 65 6C 73 65 20 20 
1A4A208 	64 65 63 6F 64 65 2D 69 
1A4A210 	6E 74 20 6E 69 70 20 6E 
1A4A218 	69 70 20 20 74 68 65 6E 
1A4A220 	20 3B  0  0 D8 E5 A0  1 

\ This needs to be called every time that the device could have changed
 " : set-device  ( -- ) "" assigned-address""  get-int-property  to device  ;" eval
1A4A228 	9C 53 A0  1 48 3A 20 73 
1A4A230 	65 74 2D 64 65 76 69 63 
1A4A238 	65 20 20 28 20 2D 2D 20 
1A4A240 	29 20 22 20 61 73 73 69 
1A4A248 	67 6E 65 64 2D 61 64 64 
1A4A250 	72 65 73 73 22 20 20 67 
1A4A258 	65 74 2D 69 6E 74 2D 70 
1A4A260 	72 6F 70 65 72 74 79 20 
1A4A268 	20 74 6F 20 64 65 76 69 
1A4A270 	63 65 20 20 3B  0  0  0 
1A4A278 	D8 E5 A0  1 
S" : set-device?  ( -- error?  )  set-device  device -1 =  ;" eval
1A4A27C 	9C 53 A0  1 
1A4A280 	39 3A 20 73 65 74 2D 64 
1A4A288 	65 76 69 63 65 3F 20 20 
1A4A290 	28 20 2D 2D 20 65 72 72 
1A4A298 	6F 72 3F 20 20 29 20 20 
1A4A2A0 	73 65 74 2D 64 65 76 69 
1A4A2A8 	63 65 20 20 64 65 76 69 
1A4A2B0 	63 65 20 2D 31 20 3D 20 
1A4A2B8 	20 3B  0  0 D8 E5 A0  1 


S" : init  ( -- ) set-device" eval
1A4A2C0 	9C 53 A0  1 19 3A 20 69 
1A4A2C8 	6E 69 74 20 20 28 20 2D 
1A4A2D0 	2D 20 29 20 73 65 74 2D 
1A4A2D8 	64 65 76 69 63 65  0  0 
1A4A2E0 	D8 E5 A0  1 
 "  "" configuration#""    get-int-property  to configuration" eval
1A4A2E4 	9C 53 A0  1 
1A4A2E8 	38 20 22 20 63 6F 6E 66 
1A4A2F0 	69 67 75 72 61 74 69 6F 
1A4A2F8 	6E 23 22 20 20 20 20 67 
1A4A300 	65 74 2D 69 6E 74 2D 70 
1A4A308 	72 6F 70 65 72 74 79 20 
1A4A310 	20 74 6F 20 63 6F 6E 66 
1A4A318 	69 67 75 72 61 74 69 6F 
1A4A320 	6E  0  0  0 D8 E5 A0  1 
 "  "" bulk-in-pipe""      get-int-property  to bulk-in-pipe" eval
1A4A328 	9C 53 A0  1 37 20 22 20 
1A4A330 	62 75 6C 6B 2D 69 6E 2D 
1A4A338 	70 69 70 65 22 20 20 20 
1A4A340 	20 20 20 67 65 74 2D 69 
1A4A348 	6E 74 2D 70 72 6F 70 65 
1A4A350 	72 74 79 20 20 74 6F 20 
1A4A358 	62 75 6C 6B 2D 69 6E 2D 
1A4A360 	70 69 70 65  0  0  0  0 
1A4A368 	D8 E5 A0  1 
 "  "" bulk-out-pipe""     get-int-property  to bulk-out-pipe" eval
1A4A36C 	9C 53 A0  1 
1A4A370 	38 20 22 20 62 75 6C 6B 
1A4A378 	2D 6F 75 74 2D 70 69 70 
1A4A380 	65 22 20 20 20 20 20 67 
1A4A388 	65 74 2D 69 6E 74 2D 70 
1A4A390 	72 6F 70 65 72 74 79 20 
1A4A398 	20 74 6F 20 62 75 6C 6B 
1A4A3A0 	2D 6F 75 74 2D 70 69 70 
1A4A3A8 	65  0  0  0 D8 E5 A0  1 
 "  "" bulk-in-size""      get-int-property  to /bulk-in-pipe" eval
1A4A3B0 	9C 53 A0  1 38 20 22 20 
1A4A3B8 	62 75 6C 6B 2D 69 6E 2D 
1A4A3C0 	73 69 7A 65 22 20 20 20 
1A4A3C8 	20 20 20 67 65 74 2D 69 
1A4A3D0 	6E 74 2D 70 72 6F 70 65 
1A4A3D8 	72 74 79 20 20 74 6F 20 
1A4A3E0 	2F 62 75 6C 6B 2D 69 6E 
1A4A3E8 	2D 70 69 70 65  0  0  0 
1A4A3F0 	D8 E5 A0  1 
 "  "" bulk-out-size""     get-int-property  to /bulk-out-pipe" eval
1A4A3F4 	9C 53 A0  1 
1A4A3F8 	39 20 22 20 62 75 6C 6B 
1A4A400 	2D 6F 75 74 2D 73 69 7A 
1A4A408 	65 22 20 20 20 20 20 67 
1A4A410 	65 74 2D 69 6E 74 2D 70 
1A4A418 	72 6F 70 65 72 74 79 20 
1A4A420 	20 74 6F 20 2F 62 75 6C 
1A4A428 	6B 2D 6F 75 74 2D 70 69 
1A4A430 	70 65  0  0 D8 E5 A0  1 
 "  "" iso-in-pipe""       get-int-property  to iso-in-pipe" eval
1A4A438 	9C 53 A0  1 36 20 22 20 
1A4A440 	69 73 6F 2D 69 6E 2D 70 
1A4A448 	69 70 65 22 20 20 20 20 
1A4A450 	20 20 20 67 65 74 2D 69 
1A4A458 	6E 74 2D 70 72 6F 70 65 
1A4A460 	72 74 79 20 20 74 6F 20 
1A4A468 	69 73 6F 2D 69 6E 2D 70 
1A4A470 	69 70 65  0 D8 E5 A0  1 
 "  "" iso-out-pipe""      get-int-property  to iso-out-pipe" eval
1A4A478 	9C 53 A0  1 37 20 22 20 
1A4A480 	69 73 6F 2D 6F 75 74 2D 
1A4A488 	70 69 70 65 22 20 20 20 
1A4A490 	20 20 20 67 65 74 2D 69 
1A4A498 	6E 74 2D 70 72 6F 70 65 
1A4A4A0 	72 74 79 20 20 74 6F 20 
1A4A4A8 	69 73 6F 2D 6F 75 74 2D 
1A4A4B0 	70 69 70 65  0  0  0  0 
1A4A4B8 	D8 E5 A0  1 
 "  "" iso-in-size""       get-int-property  to /iso-in-pipe" eval
1A4A4BC 	9C 53 A0  1 
1A4A4C0 	37 20 22 20 69 73 6F 2D 
1A4A4C8 	69 6E 2D 73 69 7A 65 22 
1A4A4D0 	20 20 20 20 20 20 20 67 
1A4A4D8 	65 74 2D 69 6E 74 2D 70 
1A4A4E0 	72 6F 70 65 72 74 79 20 
1A4A4E8 	20 74 6F 20 2F 69 73 6F 
1A4A4F0 	2D 69 6E 2D 70 69 70 65 
1A4A4F8 	 0  0  0  0 D8 E5 A0  1 
 "  "" iso-out-size""      get-int-property  to /iso-out-pipe" eval
1A4A500 	9C 53 A0  1 38 20 22 20 
1A4A508 	69 73 6F 2D 6F 75 74 2D 
1A4A510 	73 69 7A 65 22 20 20 20 
1A4A518 	20 20 20 67 65 74 2D 69 
1A4A520 	6E 74 2D 70 72 6F 70 65 
1A4A528 	72 74 79 20 20 74 6F 20 
1A4A530 	2F 69 73 6F 2D 6F 75 74 
1A4A538 	2D 70 69 70 65  0  0  0 
1A4A540 	D8 E5 A0  1 
 "  "" iso-in-interval""   get-int-property  to iso-in-interval" eval
1A4A544 	9C 53 A0  1 
1A4A548 	3A 20 22 20 69 73 6F 2D 
1A4A550 	69 6E 2D 69 6E 74 65 72 
1A4A558 	76 61 6C 22 20 20 20 67 
1A4A560 	65 74 2D 69 6E 74 2D 70 
1A4A568 	72 6F 70 65 72 74 79 20 
1A4A570 	20 74 6F 20 69 73 6F 2D 
1A4A578 	69 6E 2D 69 6E 74 65 72 
1A4A580 	76 61 6C  0 D8 E5 A0  1 
 "  "" iso-out-interval""  get-int-property  to iso-out-interval" eval
1A4A588 	9C 53 A0  1 3B 20 22 20 
1A4A590 	69 73 6F 2D 6F 75 74 2D 
1A4A598 	69 6E 74 65 72 76 61 6C 
1A4A5A0 	22 20 20 67 65 74 2D 69 
1A4A5A8 	6E 74 2D 70 72 6F 70 65 
1A4A5B0 	72 74 79 20 20 74 6F 20 
1A4A5B8 	69 73 6F 2D 6F 75 74 2D 
1A4A5C0 	69 6E 74 65 72 76 61 6C 
1A4A5C8 	 0  0  0  0 D8 E5 A0  1 
 "  "" intr-in-pipe""      get-int-property  to intr-in-pipe" eval
1A4A5D0 	9C 53 A0  1 37 20 22 20 
1A4A5D8 	69 6E 74 72 2D 69 6E 2D 
1A4A5E0 	70 69 70 65 22 20 20 20 
1A4A5E8 	20 20 20 67 65 74 2D 69 
1A4A5F0 	6E 74 2D 70 72 6F 70 65 
1A4A5F8 	72 74 79 20 20 74 6F 20 
1A4A600 	69 6E 74 72 2D 69 6E 2D 
1A4A608 	70 69 70 65  0  0  0  0 
1A4A610 	D8 E5 A0  1 
 "  "" intr-out-pipe""     get-int-property  to intr-out-pipe" eval
1A4A614 	9C 53 A0  1 
1A4A618 	38 20 22 20 69 6E 74 72 
1A4A620 	2D 6F 75 74 2D 70 69 70 
1A4A628 	65 22 20 20 20 20 20 67 
1A4A630 	65 74 2D 69 6E 74 2D 70 
1A4A638 	72 6F 70 65 72 74 79 20 
1A4A640 	20 74 6F 20 69 6E 74 72 
1A4A648 	2D 6F 75 74 2D 70 69 70 
1A4A650 	65  0  0  0 D8 E5 A0  1 
 "  "" intr-in-size""      get-int-property  to /intr-in-pipe" eval
1A4A658 	9C 53 A0  1 38 20 22 20 
1A4A660 	69 6E 74 72 2D 69 6E 2D 
1A4A668 	73 69 7A 65 22 20 20 20 
1A4A670 	20 20 20 67 65 74 2D 69 
1A4A678 	6E 74 2D 70 72 6F 70 65 
1A4A680 	72 74 79 20 20 74 6F 20 
1A4A688 	2F 69 6E 74 72 2D 69 6E 
1A4A690 	2D 70 69 70 65  0  0  0 
1A4A698 	D8 E5 A0  1 
 "  "" intr-out-size""     get-int-property  to /intr-out-pipe" eval
1A4A69C 	9C 53 A0  1 
1A4A6A0 	39 20 22 20 69 6E 74 72 
1A4A6A8 	2D 6F 75 74 2D 73 69 7A 
1A4A6B0 	65 22 20 20 20 20 20 67 
1A4A6B8 	65 74 2D 69 6E 74 2D 70 
1A4A6C0 	72 6F 70 65 72 74 79 20 
1A4A6C8 	20 74 6F 20 2F 69 6E 74 
1A4A6D0 	72 2D 6F 75 74 2D 70 69 
1A4A6D8 	70 65  0  0 D8 E5 A0  1 
 "  "" intr-in-interval""  get-int-property  to intr-in-interval" eval
1A4A6E0 	9C 53 A0  1 3B 20 22 20 
1A4A6E8 	69 6E 74 72 2D 69 6E 2D 
1A4A6F0 	69 6E 74 65 72 76 61 6C 
1A4A6F8 	22 20 20 67 65 74 2D 69 
1A4A700 	6E 74 2D 70 72 6F 70 65 
1A4A708 	72 74 79 20 20 74 6F 20 
1A4A710 	69 6E 74 72 2D 69 6E 2D 
1A4A718 	69 6E 74 65 72 76 61 6C 
1A4A720 	 0  0  0  0 D8 E5 A0  1 
 "  "" intr-out-interval"" get-int-property  to intr-out-interval ;" eval
1A4A728 	9C 53 A0  1 3E 20 22 20 
1A4A730 	69 6E 74 72 2D 6F 75 74 
1A4A738 	2D 69 6E 74 65 72 76 61 
1A4A740 	6C 22 20 67 65 74 2D 69 
1A4A748 	6E 74 2D 70 72 6F 70 65 
1A4A750 	72 74 79 20 20 74 6F 20 
1A4A758 	69 6E 74 72 2D 6F 75 74 
1A4A760 	2D 69 6E 74 65 72 76 61 
1A4A768 	6C 20 3B  0 D8 E5 A0  1 
;
1A4A770 	58 46 A0  1 


OpenFirmware/dev/usb2/device/common.fth_AL	868 1A4A774 purpose: words which are useful for both SCSI disk and SCSI tape device drivers.

: scsicomfth 
1A4A774 	 0 73 63 73 
1A4A778 	69 63 6F 6D 66 74 68 8A 
1A4A780 	1C 9F A4  1 20 40 A0  1 
hex
1A4A788 	C0 8D A0  1 
\ The SCSI disk and SCSI tape packages need to export dma-alloc and dma-free
\ methods so the deblocker can allocate DMA-capable buffer memory.

 " : dma-alloc  ( n -- vaddr )  "" dma-alloc"" $call-parent  ;" eval
1A4A78C 	9C 53 A0  1 
1A4A790 	39 3A 20 64 6D 61 2D 61 
1A4A798 	6C 6C 6F 63 20 20 28 20 
1A4A7A0 	6E 20 2D 2D 20 76 61 64 
1A4A7A8 	64 72 20 29 20 20 22 20 
1A4A7B0 	64 6D 61 2D 61 6C 6C 6F 
1A4A7B8 	63 22 20 24 63 61 6C 6C 
1A4A7C0 	2D 70 61 72 65 6E 74 20 
1A4A7C8 	20 3B  0  0 D8 E5 A0  1 
 " : dma-free   ( vaddr n -- )  "" dma-free""  $call-parent  ;" eval
1A4A7D0 	9C 53 A0  1 39 3A 20 64 
1A4A7D8 	6D 61 2D 66 72 65 65 20 
1A4A7E0 	20 20 28 20 76 61 64 64 
1A4A7E8 	72 20 6E 20 2D 2D 20 29 
1A4A7F0 	20 20 22 20 64 6D 61 2D 
1A4A7F8 	66 72 65 65 22 20 20 24 
1A4A800 	63 61 6C 6C 2D 70 61 72 
1A4A808 	65 6E 74 20 20 3B  0  0 
1A4A810 	D8 E5 A0  1 
 " : parent-max-transfer  ( -- n )  "" max-transfer""  $call-parent  ;" eval
1A4A814 	9C 53 A0  1 
1A4A818 	41 3A 20 70 61 72 65 6E 
1A4A820 	74 2D 6D 61 78 2D 74 72 
1A4A828 	61 6E 73 66 65 72 20 20 
1A4A830 	28 20 2D 2D 20 6E 20 29 
1A4A838 	20 20 22 20 6D 61 78 2D 
1A4A840 	74 72 61 6E 73 66 65 72 
1A4A848 	22 20 20 24 63 61 6C 6C 
1A4A850 	2D 70 61 72 65 6E 74 20 
1A4A858 	20 3B  0  0 D8 E5 A0  1 
 " : parent-set-address  ( lun -- )  "" set-address"" $call-parent  ;" eval
1A4A860 	9C 53 A0  1 40 3A 20 70 
1A4A868 	61 72 65 6E 74 2D 73 65 
1A4A870 	74 2D 61 64 64 72 65 73 
1A4A878 	73 20 20 28 20 6C 75 6E 
1A4A880 	20 2D 2D 20 29 20 20 22 
1A4A888 	20 73 65 74 2D 61 64 64 
1A4A890 	72 65 73 73 22 20 24 63 
1A4A898 	61 6C 6C 2D 70 61 72 65 
1A4A8A0 	6E 74 20 20 3B  0  0  0 
1A4A8A8 	D8 E5 A0  1 


\ Calls the parent device's "retry-command?" method.  The parent device is
\ assumed to be a driver for a SCSI host adapter (device-type = "scsi")

s" : retry-command?" eval  ( dma-addr dma-len dma-dir cmd-addr cmd-len #retries -- actual errcode )
1A4A8AC 	9C 53 A0  1 
1A4A8B0 	10 3A 20 72 65 74 72 79 
1A4A8B8 	2D 63 6F 6D 6D 61 6E 64 
1A4A8C0 	3F  0  0  0 D8 E5 A0  1 
 "    "" retry-command?"" $call-parent ;" eval
1A4A8C8 	9C 53 A0  1 23 20 20 20 
1A4A8D0 	22 20 72 65 74 72 79 2D 
1A4A8D8 	63 6F 6D 6D 61 6E 64 3F 
1A4A8E0 	22 20 24 63 61 6C 6C 2D 
1A4A8E8 	70 61 72 65 6E 74 20 3B 
1A4A8F0 	 0  0  0  0 D8 E5 A0  1 


\ Simplified command execution routines for common simple command forms

 " : no-data-command  ( cmdbuf -- error? )  "" no-data-command"" $call-parent  ;" eval
1A4A8F8 	9C 53 A0  1 4B 3A 20 6E 
1A4A900 	6F 2D 64 61 74 61 2D 63 
1A4A908 	6F 6D 6D 61 6E 64 20 20 
1A4A910 	28 20 63 6D 64 62 75 66 
1A4A918 	20 2D 2D 20 65 72 72 6F 
1A4A920 	72 3F 20 29 20 20 22 20 
1A4A928 	6E 6F 2D 64 61 74 61 2D 
1A4A930 	63 6F 6D 6D 61 6E 64 22 
1A4A938 	20 24 63 61 6C 6C 2D 70 
1A4A940 	61 72 65 6E 74 20 20 3B 
1A4A948 	 0  0  0  0 D8 E5 A0  1 

s" : short-data-command" eval  ( data-len cmdbuf cmdlen #retries -- true | buffer len false )
1A4A950 	9C 53 A0  1 14 3A 20 73 
1A4A958 	68 6F 72 74 2D 64 61 74 
1A4A960 	61 2D 63 6F 6D 6D 61 6E 
1A4A968 	64  0  0  0 D8 E5 A0  1 
 "    "" short-data-command"" $call-parent ;" eval
1A4A970 	9C 53 A0  1 27 20 20 20 
1A4A978 	22 20 73 68 6F 72 74 2D 
1A4A980 	64 61 74 61 2D 63 6F 6D 
1A4A988 	6D 61 6E 64 22 20 24 63 
1A4A990 	61 6C 6C 2D 70 61 72 65 
1A4A998 	6E 74 20 3B  0  0  0  0 
1A4A9A0 	D8 E5 A0  1 


\ Some tools for reading and writing 2, 3, and 4 byte numbers to and from
\ SCSI command and data buffers.  The ones defined below are used both in
\ the SCSI disk and the SCSI tape packages.  Other variations that are
\ used only by one of the packages are defined in the package where they
\ are used.

s" : +c!  ( n addr -- addr' )  tuck c! 1+  ;" eval
1A4A9A4 	9C 53 A0  1 
1A4A9A8 	29 3A 20 2B 63 21 20 20 
1A4A9B0 	28 20 6E 20 61 64 64 72 
1A4A9B8 	20 2D 2D 20 61 64 64 72 
1A4A9C0 	27 20 29 20 20 74 75 63 
1A4A9C8 	6B 20 63 21 20 31 2B 20 
1A4A9D0 	20 3B  0  0 D8 E5 A0  1 
s" : 3c!  ( n addr -- )  >r lbsplit drop  r> +c! +c! c!  ;" eval
1A4A9D8 	9C 53 A0  1 37 3A 20 33 
1A4A9E0 	63 21 20 20 28 20 6E 20 
1A4A9E8 	61 64 64 72 20 2D 2D 20 
1A4A9F0 	29 20 20 3E 72 20 6C 62 
1A4A9F8 	73 70 6C 69 74 20 64 72 
1A4AA00 	6F 70 20 20 72 3E 20 2B 
1A4AA08 	63 21 20 2B 63 21 20 63 
1A4AA10 	21 20 20 3B  0  0  0  0 
1A4AA18 	D8 E5 A0  1 
s" : -c@  ( addr -- n addr' )  dup c@  swap 1-  ;" eval
1A4AA1C 	9C 53 A0  1 
1A4AA20 	2E 3A 20 2D 63 40 20 20 
1A4AA28 	28 20 61 64 64 72 20 2D 
1A4AA30 	2D 20 6E 20 61 64 64 72 
1A4AA38 	27 20 29 20 20 64 75 70 
1A4AA40 	20 63 40 20 20 73 77 61 
1A4AA48 	70 20 31 2D 20 20 3B  0 
1A4AA50 	D8 E5 A0  1 
s" : 3c@  ( addr -- n )  2 +  -c@ -c@  c@       0  bljoin  ;" eval
1A4AA54 	9C 53 A0  1 
1A4AA58 	39 3A 20 33 63 40 20 20 
1A4AA60 	28 20 61 64 64 72 20 2D 
1A4AA68 	2D 20 6E 20 29 20 20 32 
1A4AA70 	20 2B 20 20 2D 63 40 20 
1A4AA78 	2D 63 40 20 20 63 40 20 
1A4AA80 	20 20 20 20 20 20 30 20 
1A4AA88 	20 62 6C 6A 6F 69 6E 20 
1A4AA90 	20 3B  0  0 D8 E5 A0  1 
s" : 4c@  ( addr -- n )  3 +  -c@ -c@ -c@  c@      bljoin  ;" eval
1A4AA98 	9C 53 A0  1 39 3A 20 34 
1A4AAA0 	63 40 20 20 28 20 61 64 
1A4AAA8 	64 72 20 2D 2D 20 6E 20 
1A4AAB0 	29 20 20 33 20 2B 20 20 
1A4AAB8 	2D 63 40 20 2D 63 40 20 
1A4AAC0 	2D 63 40 20 20 63 40 20 
1A4AAC8 	20 20 20 20 20 62 6C 6A 
1A4AAD0 	6F 69 6E 20 20 3B  0  0 
1A4AAD8 	D8 E5 A0  1 


\ "Scratch" command buffer useful for construction of read and write commands

s" d# 10 constant /cmdbuf" eval
1A4AADC 	9C 53 A0  1 
1A4AAE0 	16 64 23 20 31 30 20 63 
1A4AAE8 	6F 6E 73 74 61 6E 74 20 
1A4AAF0 	2F 63 6D 64 62 75 66  0 
1A4AAF8 	D8 E5 A0  1 
s" create cmdbuf  0 c, 0 c, 0 c, 0 c, 0 c, 0 c, 0 c, 0 c, 0 c, 0 c," eval
1A4AAFC 	9C 53 A0  1 
1A4AB00 	40 63 72 65 61 74 65 20 
1A4AB08 	63 6D 64 62 75 66 20 20 
1A4AB10 	30 20 63 2C 20 30 20 63 
1A4AB18 	2C 20 30 20 63 2C 20 30 
1A4AB20 	20 63 2C 20 30 20 63 2C 
1A4AB28 	20 30 20 63 2C 20 30 20 
1A4AB30 	63 2C 20 30 20 63 2C 20 
1A4AB38 	30 20 63 2C 20 30 20 63 
1A4AB40 	2C  0  0  0 D8 E5 A0  1 
s" : cb!  ( byte index -- )  cmdbuf + c!  ;" eval        \ Write byte to command buffer
1A4AB48 	9C 53 A0  1 28 3A 20 63 
1A4AB50 	62 21 20 20 28 20 62 79 
1A4AB58 	74 65 20 69 6E 64 65 78 
1A4AB60 	20 2D 2D 20 29 20 20 63 
1A4AB68 	6D 64 62 75 66 20 2B 20 
1A4AB70 	63 21 20 20 3B  0  0  0 
1A4AB78 	D8 E5 A0  1 

s" create eject-cmd  h# 1b c, 1 c, 0 c, 0 c, 2 c, 0 c," eval
1A4AB7C 	9C 53 A0  1 
1A4AB80 	33 63 72 65 61 74 65 20 
1A4AB88 	65 6A 65 63 74 2D 63 6D 
1A4AB90 	64 20 20 68 23 20 31 62 
1A4AB98 	20 63 2C 20 31 20 63 2C 
1A4ABA0 	20 30 20 63 2C 20 30 20 
1A4ABA8 	63 2C 20 32 20 63 2C 20 
1A4ABB0 	30 20 63 2C  0  0  0  0 
1A4ABB8 	D8 E5 A0  1 

s" : device-present?" eval  ( lun -- present? )  
1A4ABBC 	9C 53 A0  1 
1A4ABC0 	11 3A 20 64 65 76 69 63 
1A4ABC8 	65 2D 70 72 65 73 65 6E 
1A4ABD0 	74 3F  0  0 D8 E5 A0  1 
s"    parent-set-address" eval
1A4ABD8 	9C 53 A0  1 15 20 20 20 
1A4ABE0 	70 61 72 65 6E 74 2D 73 
1A4ABE8 	65 74 2D 61 64 64 72 65 
1A4ABF0 	73 73  0  0 D8 E5 A0  1 
 "    "" inquiry""  $call-parent  0= ;" eval
1A4ABF8 	9C 53 A0  1 21 20 20 20 
1A4AC00 	22 20 69 6E 71 75 69 72 
1A4AC08 	79 22 20 20 24 63 61 6C 
1A4AC10 	6C 2D 70 61 72 65 6E 74 
1A4AC18 	20 20 30 3D 20 3B  0  0 
1A4AC20 	D8 E5 A0  1 
s" : eject ( -- )" eval
1A4AC24 	9C 53 A0  1 
1A4AC28 	 E 3A 20 65 6A 65 63 74 
1A4AC30 	20 28 20 2D 2D 20 29  0 
1A4AC38 	D8 E5 A0  1 
s"    my-unit device-present?  if" eval
1A4AC3C 	9C 53 A0  1 
1A4AC40 	1E 20 20 20 6D 79 2D 75 
1A4AC48 	6E 69 74 20 64 65 76 69 
1A4AC50 	63 65 2D 70 72 65 73 65 
1A4AC58 	6E 74 3F 20 20 69 66  0 
1A4AC60 	D8 E5 A0  1 
s"       eject-cmd no-data-command  drop" eval
1A4AC64 	9C 53 A0  1 
1A4AC68 	25 20 20 20 20 20 20 65 
1A4AC70 	6A 65 63 74 2D 63 6D 64 
1A4AC78 	20 6E 6F 2D 64 61 74 61 
1A4AC80 	2D 63 6F 6D 6D 61 6E 64 
1A4AC88 	20 20 64 72 6F 70  0  0 
1A4AC90 	D8 E5 A0  1 
s"    then ;" eval
1A4AC94 	9C 53 A0  1 
1A4AC98 	 9 20 20 20 74 68 65 6E 
1A4ACA0 	20 3B  0  0 D8 E5 A0  1 
 
\ The deblocker converts a block/record-oriented interface to a byte-oriented
\ interface, using internal buffering.  Disk and tape devices are usually
\ block or record oriented, but the OBP external interface is byte-oriented,
\ in order to be independent of particular device block sizes.

s" 0 value deblocker" eval
1A4ACA8 	9C 53 A0  1 11 30 20 76 
1A4ACB0 	61 6C 75 65 20 64 65 62 
1A4ACB8 	6C 6F 63 6B 65 72  0  0 
1A4ACC0 	D8 E5 A0  1 
s" : init-deblocker  ( -- okay? )" eval
1A4ACC4 	9C 53 A0  1 
1A4ACC8 	1E 3A 20 69 6E 69 74 2D 
1A4ACD0 	64 65 62 6C 6F 63 6B 65 
1A4ACD8 	72 20 20 28 20 2D 2D 20 
1A4ACE0 	6F 6B 61 79 3F 20 29  0 
1A4ACE8 	D8 E5 A0  1 
 "    "" ""  "" deblocker""  $open-package  to deblocker" eval
1A4ACEC 	9C 53 A0  1 
1A4ACF0 	31 20 20 20 22 20 22 20 
1A4ACF8 	20 22 20 64 65 62 6C 6F 
1A4AD00 	63 6B 65 72 22 20 20 24 
1A4AD08 	6F 70 65 6E 2D 70 61 63 
1A4AD10 	6B 61 67 65 20 20 74 6F 
1A4AD18 	20 64 65 62 6C 6F 63 6B 
1A4AD20 	65 72  0  0 D8 E5 A0  1 
s"    deblocker if" eval
1A4AD28 	9C 53 A0  1  F 20 20 20 
1A4AD30 	64 65 62 6C 6F 63 6B 65 
1A4AD38 	72 20 69 66  0  0  0  0 
1A4AD40 	D8 E5 A0  1 
s"       true" eval
1A4AD44 	9C 53 A0  1 
1A4AD48 	 A 20 20 20 20 20 20 74 
1A4AD50 	72 75 65  0 D8 E5 A0  1 
s"    else" eval
1A4AD58 	9C 53 A0  1  7 20 20 20 
1A4AD60 	65 6C 73 65  0  0  0  0 
1A4AD68 	D8 E5 A0  1 
 "       ."" Can't open deblocker package""  cr  false" eval
1A4AD6C 	9C 53 A0  1 
1A4AD70 	31 20 20 20 20 20 20 2E 
1A4AD78 	22 20 43 61 6E 27 74 20 
1A4AD80 	6F 70 65 6E 20 64 65 62 
1A4AD88 	6C 6F 63 6B 65 72 20 70 
1A4AD90 	61 63 6B 61 67 65 22 20 
1A4AD98 	20 63 72 20 20 66 61 6C 
1A4ADA0 	73 65  0  0 D8 E5 A0  1 
s"    then ;" eval
1A4ADA8 	9C 53 A0  1  9 20 20 20 
1A4ADB0 	74 68 65 6E 20 3B  0  0 
1A4ADB8 	D8 E5 A0  1 

\ headerless
\ : selftest  ( -- )
\       my-unit " set-address" $call-parent
\       " diagnose" $call-parent
\ ;
;
1A4ADBC 	58 46 A0  1 


OpenFirmware/dev/usb2/device/storage/scsicom.fth_AL	64C 1A4ADC0 purpose: USB Mass Storage Device Driver

: scsifth 
1A4ADC0 	73 63 73 69 66 74 68 87 
1A4ADC8 	84 A7 A4  1 20 40 A0  1 
hex
1A4ADD0 	C0 8D A0  1 
s" 0          value max-lun" eval
1A4ADD4 	9C 53 A0  1 
1A4ADD8 	18 30 20 20 20 20 20 20 
1A4ADE0 	20 20 20 20 76 61 6C 75 
1A4ADE8 	65 20 6D 61 78 2D 6C 75 
1A4ADF0 	6E  0  0  0 D8 E5 A0  1 
s" 0 instance value lun" eval
1A4ADF8 	9C 53 A0  1 14 30 20 69 
1A4AE00 	6E 73 74 61 6E 63 65 20 
1A4AE08 	76 61 6C 75 65 20 6C 75 
1A4AE10 	6E  0  0  0 D8 E5 A0  1 

s" USB_ERR_STALL constant bus-reset" eval
1A4AE18 	9C 53 A0  1 20 55 53 42 
1A4AE20 	5F 45 52 52 5F 53 54 41 
1A4AE28 	4C 4C 20 63 6F 6E 73 74 
1A4AE30 	61 6E 74 20 62 75 73 2D 
1A4AE38 	72 65 73 65 74  0  0  0 
1A4AE40 	D8 E5 A0  1 

s" defer execute-command-hook  ' noop to execute-command-hook" eval
1A4AE44 	9C 53 A0  1 
1A4AE48 	3A 64 65 66 65 72 20 65 
1A4AE50 	78 65 63 75 74 65 2D 63 
1A4AE58 	6F 6D 6D 61 6E 64 2D 68 
1A4AE60 	6F 6F 6B 20 20 27 20 6E 
1A4AE68 	6F 6F 70 20 74 6F 20 65 
1A4AE70 	78 65 63 75 74 65 2D 63 
1A4AE78 	6F 6D 6D 61 6E 64 2D 68 
1A4AE80 	6F 6F 6B  0 D8 E5 A0  1 
s" defer init-execute-command  ' noop to init-execute-command" eval
1A4AE88 	9C 53 A0  1 3A 64 65 66 
1A4AE90 	65 72 20 69 6E 69 74 2D 
1A4AE98 	65 78 65 63 75 74 65 2D 
1A4AEA0 	63 6F 6D 6D 61 6E 64 20 
1A4AEA8 	20 27 20 6E 6F 6F 70 20 
1A4AEB0 	74 6F 20 69 6E 69 74 2D 
1A4AEB8 	65 78 65 63 75 74 65 2D 
1A4AEC0 	63 6F 6D 6D 61 6E 64  0 
1A4AEC8 	D8 E5 A0  1 


\ Class specific >dr-request constants
s" h# ff constant DEV_RESET" eval
1A4AECC 	9C 53 A0  1 
1A4AED0 	18 68 23 20 66 66 20 63 
1A4AED8 	6F 6E 73 74 61 6E 74 20 
1A4AEE0 	44 45 56 5F 52 45 53 45 
1A4AEE8 	54  0  0  0 D8 E5 A0  1 
s" h# fe constant GET_MAX_LUN" eval
1A4AEF0 	9C 53 A0  1 1A 68 23 20 
1A4AEF8 	66 65 20 63 6F 6E 73 74 
1A4AF00 	61 6E 74 20 47 45 54 5F 
1A4AF08 	4D 41 58 5F 4C 55 4E  0 
1A4AF10 	D8 E5 A0  1 

\ Command Block Wrapper
s" struct" eval
1A4AF14 	9C 53 A0  1 
1A4AF18 	 6 73 74 72 75 63 74  0 
1A4AF20 	D8 E5 A0  1 
s"     4 field >cbw-sig" eval
1A4AF24 	9C 53 A0  1 
1A4AF28 	14 20 20 20 20 34 20 66 
1A4AF30 	69 65 6C 64 20 3E 63 62 
1A4AF38 	77 2D 73 69 67  0  0  0 
1A4AF40 	D8 E5 A0  1 
s"     4 field >cbw-tag" eval
1A4AF44 	9C 53 A0  1 
1A4AF48 	14 20 20 20 20 34 20 66 
1A4AF50 	69 65 6C 64 20 3E 63 62 
1A4AF58 	77 2D 74 61 67  0  0  0 
1A4AF60 	D8 E5 A0  1 
s"     4 field >cbw-dlen" eval
1A4AF64 	9C 53 A0  1 
1A4AF68 	15 20 20 20 20 34 20 66 
1A4AF70 	69 65 6C 64 20 3E 63 62 
1A4AF78 	77 2D 64 6C 65 6E  0  0 
1A4AF80 	D8 E5 A0  1 
s"     1 field >cbw-flag" eval
1A4AF84 	9C 53 A0  1 
1A4AF88 	15 20 20 20 20 31 20 66 
1A4AF90 	69 65 6C 64 20 3E 63 62 
1A4AF98 	77 2D 66 6C 61 67  0  0 
1A4AFA0 	D8 E5 A0  1 
s"     1 field >cbw-lun" eval
1A4AFA4 	9C 53 A0  1 
1A4AFA8 	14 20 20 20 20 31 20 66 
1A4AFB0 	69 65 6C 64 20 3E 63 62 
1A4AFB8 	77 2D 6C 75 6E  0  0  0 
1A4AFC0 	D8 E5 A0  1 
s"     1 field >cbw-cblen" eval
1A4AFC4 	9C 53 A0  1 
1A4AFC8 	16 20 20 20 20 31 20 66 
1A4AFD0 	69 65 6C 64 20 3E 63 62 
1A4AFD8 	77 2D 63 62 6C 65 6E  0 
1A4AFE0 	D8 E5 A0  1 
s" h# 10 field >cbw-cb" eval
1A4AFE4 	9C 53 A0  1 
1A4AFE8 	13 68 23 20 31 30 20 66 
1A4AFF0 	69 65 6C 64 20 3E 63 62 
1A4AFF8 	77 2D 63 62  0  0  0  0 
1A4B000 	D8 E5 A0  1 
s" constant /cbw" eval
1A4B004 	9C 53 A0  1 
1A4B008 	 D 63 6F 6E 73 74 61 6E 
1A4B010 	74 20 2F 63 62 77  0  0 
1A4B018 	D8 E5 A0  1 

\ >cbw-flag definitions
s" 80 constant cbw-flag-in" eval
1A4B01C 	9C 53 A0  1 
1A4B020 	17 38 30 20 63 6F 6E 73 
1A4B028 	74 61 6E 74 20 63 62 77 
1A4B030 	2D 66 6C 61 67 2D 69 6E 
1A4B038 	 0  0  0  0 D8 E5 A0  1 
s" 00 constant cbw-flag-out" eval
1A4B040 	9C 53 A0  1 18 30 30 20 
1A4B048 	63 6F 6E 73 74 61 6E 74 
1A4B050 	20 63 62 77 2D 66 6C 61 
1A4B058 	67 2D 6F 75 74  0  0  0 
1A4B060 	D8 E5 A0  1 

\ Command Status Wrapper
s" struct" eval
1A4B064 	9C 53 A0  1 
1A4B068 	 6 73 74 72 75 63 74  0 
1A4B070 	D8 E5 A0  1 
s"    4 field >csw-sig" eval
1A4B074 	9C 53 A0  1 
1A4B078 	13 20 20 20 34 20 66 69 
1A4B080 	65 6C 64 20 3E 63 73 77 
1A4B088 	2D 73 69 67  0  0  0  0 
1A4B090 	D8 E5 A0  1 
s"    4 field >csw-tag" eval
1A4B094 	9C 53 A0  1 
1A4B098 	13 20 20 20 34 20 66 69 
1A4B0A0 	65 6C 64 20 3E 63 73 77 
1A4B0A8 	2D 74 61 67  0  0  0  0 
1A4B0B0 	D8 E5 A0  1 
s"    4 field >csw-dlen" eval
1A4B0B4 	9C 53 A0  1 
1A4B0B8 	14 20 20 20 34 20 66 69 
1A4B0C0 	65 6C 64 20 3E 63 73 77 
1A4B0C8 	2D 64 6C 65 6E  0  0  0 
1A4B0D0 	D8 E5 A0  1 
s"    1 field >csw-stat" eval
1A4B0D4 	9C 53 A0  1 
1A4B0D8 	14 20 20 20 31 20 66 69 
1A4B0E0 	65 6C 64 20 3E 63 73 77 
1A4B0E8 	2D 73 74 61 74  0  0  0 
1A4B0F0 	D8 E5 A0  1 
s" constant /csw" eval
1A4B0F4 	9C 53 A0  1 
1A4B0F8 	 D 63 6F 6E 73 74 61 6E 
1A4B100 	74 20 2F 63 73 77  0  0 
1A4B108 	D8 E5 A0  1 

s" h# 43425355 constant cbw-signature" eval	\ little-endian (USBC)
1A4B10C 	9C 53 A0  1 
1A4B110 	22 68 23 20 34 33 34 32 
1A4B118 	35 33 35 35 20 63 6F 6E 
1A4B120 	73 74 61 6E 74 20 63 62 
1A4B128 	77 2D 73 69 67 6E 61 74 
1A4B130 	75 72 65  0 D8 E5 A0  1 
s" h# 53425355 constant csw-signature" eval	\ little-endian (USBS)
1A4B138 	9C 53 A0  1 22 68 23 20 
1A4B140 	35 33 34 32 35 33 35 35 
1A4B148 	20 63 6F 6E 73 74 61 6E 
1A4B150 	74 20 63 73 77 2D 73 69 
1A4B158 	67 6E 61 74 75 72 65  0 
1A4B160 	D8 E5 A0  1 

s" 0 value cbw-tag" eval
1A4B164 	9C 53 A0  1 
1A4B168 	 F 30 20 76 61 6C 75 65 
1A4B170 	20 63 62 77 2D 74 61 67 
1A4B178 	 0  0  0  0 D8 E5 A0  1 
s" 0 value cbw" eval
1A4B180 	9C 53 A0  1  B 30 20 76 
1A4B188 	61 6C 75 65 20 63 62 77 
1A4B190 	 0  0  0  0 D8 E5 A0  1 
s" 0 value csw" eval
1A4B198 	9C 53 A0  1  B 30 20 76 
1A4B1A0 	61 6C 75 65 20 63 73 77 
1A4B1A8 	 0  0  0  0 D8 E5 A0  1 
s" : init-cbw  ( -- )" eval
1A4B1B0 	9C 53 A0  1 12 3A 20 69 
1A4B1B8 	6E 69 74 2D 63 62 77 20 
1A4B1C0 	20 28 20 2D 2D 20 29  0 
1A4B1C8 	D8 E5 A0  1 
s"    cbw /cbw erase" eval
1A4B1CC 	9C 53 A0  1 
1A4B1D0 	11 20 20 20 63 62 77 20 
1A4B1D8 	2F 63 62 77 20 65 72 61 
1A4B1E0 	73 65  0  0 D8 E5 A0  1 
s"    cbw-signature cbw >cbw-sig le-l!" eval
1A4B1E8 	9C 53 A0  1 23 20 20 20 
1A4B1F0 	63 62 77 2D 73 69 67 6E 
1A4B1F8 	61 74 75 72 65 20 63 62 
1A4B200 	77 20 3E 63 62 77 2D 73 
1A4B208 	69 67 20 6C 65 2D 6C 21 
1A4B210 	 0  0  0  0 D8 E5 A0  1 
s"    cbw-tag 1+ to cbw-tag" eval
1A4B218 	9C 53 A0  1 18 20 20 20 
1A4B220 	63 62 77 2D 74 61 67 20 
1A4B228 	31 2B 20 74 6F 20 63 62 
1A4B230 	77 2D 74 61 67  0  0  0 
1A4B238 	D8 E5 A0  1 
s"    cbw-tag cbw >cbw-tag le-l! ;" eval
1A4B23C 	9C 53 A0  1 
1A4B240 	1F 20 20 20 63 62 77 2D 
1A4B248 	74 61 67 20 63 62 77 20 
1A4B250 	3E 63 62 77 2D 74 61 67 
1A4B258 	20 6C 65 2D 6C 21 20 3B 
1A4B260 	 0  0  0  0 D8 E5 A0  1 
s" : alloc-bulk  ( -- )" eval
1A4B268 	9C 53 A0  1 14 3A 20 61 
1A4B270 	6C 6C 6F 63 2D 62 75 6C 
1A4B278 	6B 20 20 28 20 2D 2D 20 
1A4B280 	29  0  0  0 D8 E5 A0  1 
s"    cbw 0=  if  /cbw dma-alloc to cbw  then" eval
1A4B288 	9C 53 A0  1 2A 20 20 20 
1A4B290 	63 62 77 20 30 3D 20 20 
1A4B298 	69 66 20 20 2F 63 62 77 
1A4B2A0 	20 64 6D 61 2D 61 6C 6C 
1A4B2A8 	6F 63 20 74 6F 20 63 62 
1A4B2B0 	77 20 20 74 68 65 6E  0 
1A4B2B8 	D8 E5 A0  1 
s"    csw 0=  if  /csw dma-alloc to csw  then ;" eval
1A4B2BC 	9C 53 A0  1 
1A4B2C0 	2C 20 20 20 63 73 77 20 
1A4B2C8 	30 3D 20 20 69 66 20 20 
1A4B2D0 	2F 63 73 77 20 64 6D 61 
1A4B2D8 	2D 61 6C 6C 6F 63 20 74 
1A4B2E0 	6F 20 63 73 77 20 20 74 
1A4B2E8 	68 65 6E 20 3B  0  0  0 
1A4B2F0 	D8 E5 A0  1 
s" : free-bulk  ( -- )" eval
1A4B2F4 	9C 53 A0  1 
1A4B2F8 	13 3A 20 66 72 65 65 2D 
1A4B300 	62 75 6C 6B 20 20 28 20 
1A4B308 	2D 2D 20 29  0  0  0  0 
1A4B310 	D8 E5 A0  1 
s"    cbw  if  cbw /cbw dma-free  0 to cbw  then" eval
1A4B314 	9C 53 A0  1 
1A4B318 	2D 20 20 20 63 62 77 20 
1A4B320 	20 69 66 20 20 63 62 77 
1A4B328 	20 2F 63 62 77 20 64 6D 
1A4B330 	61 2D 66 72 65 65 20 20 
1A4B338 	30 20 74 6F 20 63 62 77 
1A4B340 	20 20 74 68 65 6E  0  0 
1A4B348 	D8 E5 A0  1 
s"   csw  if  csw /csw dma-free  0 to csw  then ;" eval
1A4B34C 	9C 53 A0  1 
1A4B350 	2E 20 20 63 73 77 20 20 
1A4B358 	69 66 20 20 63 73 77 20 
1A4B360 	2F 63 73 77 20 64 6D 61 
1A4B368 	2D 66 72 65 65 20 20 30 
1A4B370 	20 74 6F 20 63 73 77 20 
1A4B378 	20 74 68 65 6E 20 3B  0 
1A4B380 	D8 E5 A0  1 
s" 1 buffer: max-lun-buf" eval
1A4B384 	9C 53 A0  1 
1A4B388 	15 31 20 62 75 66 66 65 
1A4B390 	72 3A 20 6D 61 78 2D 6C 
1A4B398 	75 6E 2D 62 75 66  0  0 
1A4B3A0 	D8 E5 A0  1 

s" : get-max-lun  ( -- )" eval
1A4B3A4 	9C 53 A0  1 
1A4B3A8 	15 3A 20 67 65 74 2D 6D 
1A4B3B0 	61 78 2D 6C 75 6E 20 20 
1A4B3B8 	28 20 2D 2D 20 29  0  0 
1A4B3C0 	D8 E5 A0  1 
s"    max-lun-buf 1 my-address ( interface ) 0 DR_IN DR_CLASS DR_INTERFACE or or" eval
1A4B3C4 	9C 53 A0  1 
1A4B3C8 	4D 20 20 20 6D 61 78 2D 
1A4B3D0 	6C 75 6E 2D 62 75 66 20 
1A4B3D8 	31 20 6D 79 2D 61 64 64 
1A4B3E0 	72 65 73 73 20 28 20 69 
1A4B3E8 	6E 74 65 72 66 61 63 65 
1A4B3F0 	20 29 20 30 20 44 52 5F 
1A4B3F8 	49 4E 20 44 52 5F 43 4C 
1A4B400 	41 53 53 20 44 52 5F 49 
1A4B408 	4E 54 45 52 46 41 43 45 
1A4B410 	20 6F 72 20 6F 72  0  0 
1A4B418 	D8 E5 A0  1 
s"    GET_MAX_LUN control-get  if			" eval ( actual usberr )
1A4B41C 	9C 53 A0  1 
1A4B420 	21 20 20 20 47 45 54 5F 
1A4B428 	4D 41 58 5F 4C 55 4E 20 
1A4B430 	63 6F 6E 74 72 6F 6C 2D 
1A4B438 	67 65 74 20 20 69 66  9 
1A4B440 	 9  9  0  0 D8 E5 A0  1 
s"       drop 0" eval
1A4B448 	9C 53 A0  1  C 20 20 20 
1A4B450 	20 20 20 64 72 6F 70 20 
1A4B458 	30  0  0  0 D8 E5 A0  1 
s"    else" eval
1A4B460 	9C 53 A0  1  7 20 20 20 
1A4B468 	65 6C 73 65  0  0  0  0 
1A4B470 	D8 E5 A0  1 
s"       ( actual )  if  max-lun-buf c@  else  0  then" eval
1A4B474 	9C 53 A0  1 
1A4B478 	33 20 20 20 20 20 20 28 
1A4B480 	20 61 63 74 75 61 6C 20 
1A4B488 	29 20 20 69 66 20 20 6D 
1A4B490 	61 78 2D 6C 75 6E 2D 62 
1A4B498 	75 66 20 63 40 20 20 65 
1A4B4A0 	6C 73 65 20 20 30 20 20 
1A4B4A8 	74 68 65 6E  0  0  0  0 
1A4B4B0 	D8 E5 A0  1 
s"    then" eval
1A4B4B4 	9C 53 A0  1 
1A4B4B8 	 7 20 20 20 74 68 65 6E 
1A4B4C0 	 0  0  0  0 D8 E5 A0  1 
s"    to max-lun ;" eval
1A4B4C8 	9C 53 A0  1  F 20 20 20 
1A4B4D0 	74 6F 20 6D 61 78 2D 6C 
1A4B4D8 	75 6E 20 3B  0  0  0  0 
1A4B4E0 	D8 E5 A0  1 

s" : init  ( -- )" eval
1A4B4E4 	9C 53 A0  1 
1A4B4E8 	 E 3A 20 69 6E 69 74 20 
1A4B4F0 	20 28 20 2D 2D 20 29  0 
1A4B4F8 	D8 E5 A0  1 
s"    init" eval
1A4B4FC 	9C 53 A0  1 
1A4B500 	 7 20 20 20 69 6E 69 74 
1A4B508 	 0  0  0  0 D8 E5 A0  1 
s"    init-execute-command" eval
1A4B510 	9C 53 A0  1 17 20 20 20 
1A4B518 	69 6E 69 74 2D 65 78 65 
1A4B520 	63 75 74 65 2D 63 6F 6D 
1A4B528 	6D 61 6E 64  0  0  0  0 
1A4B530 	D8 E5 A0  1 
s"    alloc-bulk" eval
1A4B534 	9C 53 A0  1 
1A4B538 	 D 20 20 20 61 6C 6C 6F 
1A4B540 	63 2D 62 75 6C 6B  0  0 
1A4B548 	D8 E5 A0  1 
s"    device set-target" eval
1A4B54C 	9C 53 A0  1 
1A4B550 	14 20 20 20 64 65 76 69 
1A4B558 	63 65 20 73 65 74 2D 74 
1A4B560 	61 72 67 65 74  0  0  0 
1A4B568 	D8 E5 A0  1 
s"    get-max-lun" eval
1A4B56C 	9C 53 A0  1 
1A4B570 	 E 20 20 20 67 65 74 2D 
1A4B578 	6D 61 78 2D 6C 75 6E  0 
1A4B580 	D8 E5 A0  1 
s"    free-bulk ;" eval
1A4B584 	9C 53 A0  1 
1A4B588 	 E 20 20 20 66 72 65 65 
1A4B590 	2D 62 75 6C 6B 20 3B  0 
1A4B598 	D8 E5 A0  1 
s" : transport-reset" eval  ( -- )
1A4B59C 	9C 53 A0  1 
1A4B5A0 	11 3A 20 74 72 61 6E 73 
1A4B5A8 	70 6F 72 74 2D 72 65 73 
1A4B5B0 	65 74  0  0 D8 E5 A0  1 
s"    0 0 my-address ( interface ) 0 DR_OUT DR_CLASS DR_INTERFACE or or" eval
1A4B5B8 	9C 53 A0  1 44 20 20 20 
1A4B5C0 	30 20 30 20 6D 79 2D 61 
1A4B5C8 	64 64 72 65 73 73 20 28 
1A4B5D0 	20 69 6E 74 65 72 66 61 
1A4B5D8 	63 65 20 29 20 30 20 44 
1A4B5E0 	52 5F 4F 55 54 20 44 52 
1A4B5E8 	5F 43 4C 41 53 53 20 44 
1A4B5F0 	52 5F 49 4E 54 45 52 46 
1A4B5F8 	41 43 45 20 6F 72 20 6F 
1A4B600 	72  0  0  0 D8 E5 A0  1 
s"    DEV_RESET control-set-nostat  drop" eval
1A4B608 	9C 53 A0  1 25 20 20 20 
1A4B610 	44 45 56 5F 52 45 53 45 
1A4B618 	54 20 63 6F 6E 74 72 6F 
1A4B620 	6C 2D 73 65 74 2D 6E 6F 
1A4B628 	73 74 61 74 20 20 64 72 
1A4B630 	6F 70  0  0 D8 E5 A0  1 
    \ XXX Wait until devices does not NAK anymore
s"    bulk-in-pipe  h# 80 or unstall-pipe" eval
1A4B638 	9C 53 A0  1 26 20 20 20 
1A4B640 	62 75 6C 6B 2D 69 6E 2D 
1A4B648 	70 69 70 65 20 20 68 23 
1A4B650 	20 38 30 20 6F 72 20 75 
1A4B658 	6E 73 74 61 6C 6C 2D 70 
1A4B660 	69 70 65  0 D8 E5 A0  1 
s"    bulk-out-pipe          unstall-pipe ;" eval
1A4B668 	9C 53 A0  1 28 20 20 20 
1A4B670 	62 75 6C 6B 2D 6F 75 74 
1A4B678 	2D 70 69 70 65 20 20 20 
1A4B680 	20 20 20 20 20 20 20 75 
1A4B688 	6E 73 74 61 6C 6C 2D 70 
1A4B690 	69 70 65 20 3B  0  0  0 
1A4B698 	D8 E5 A0  1 

s" : wrap-cbw" eval  ( data-len dir cmd-adr,len -- cbw-adr,len )
1A4B69C 	9C 53 A0  1 
1A4B6A0 	 A 3A 20 77 72 61 70 2D 
1A4B6A8 	63 62 77  0 D8 E5 A0  1 
s"    init-cbw" eval				( data-len dir cmd-adr,len )
1A4B6B0 	9C 53 A0  1  B 20 20 20 
1A4B6B8 	69 6E 69 74 2D 63 62 77 
1A4B6C0 	 0  0  0  0 D8 E5 A0  1 
s"    cbw >r" eval				( data-len dir cmd-adr,len )  ( R: cbw )
1A4B6C8 	9C 53 A0  1  9 20 20 20 
1A4B6D0 	63 62 77 20 3E 72  0  0 
1A4B6D8 	D8 E5 A0  1 
s"    dup r@ >cbw-cblen c!" eval			( data-len dir cmd-adr,len )  ( R: cbw )
1A4B6DC 	9C 53 A0  1 
1A4B6E0 	17 20 20 20 64 75 70 20 
1A4B6E8 	72 40 20 3E 63 62 77 2D 
1A4B6F0 	63 62 6C 65 6E 20 63 21 
1A4B6F8 	 0  0  0  0 D8 E5 A0  1 
s"    r@ >cbw-cb swap move" eval			( data-len dir )  ( R: cbw )
1A4B700 	9C 53 A0  1 17 20 20 20 
1A4B708 	72 40 20 3E 63 62 77 2D 
1A4B710 	63 62 20 73 77 61 70 20 
1A4B718 	6D 6F 76 65  0  0  0  0 
1A4B720 	D8 E5 A0  1 
s"    if  cbw-flag-in  else  cbw-flag-out  then" eval	( data-len cbw-flag )  ( R: cbw )
1A4B724 	9C 53 A0  1 
1A4B728 	2C 20 20 20 69 66 20 20 
1A4B730 	63 62 77 2D 66 6C 61 67 
1A4B738 	2D 69 6E 20 20 65 6C 73 
1A4B740 	65 20 20 63 62 77 2D 66 
1A4B748 	6C 61 67 2D 6F 75 74 20 
1A4B750 	20 74 68 65 6E  0  0  0 
1A4B758 	D8 E5 A0  1 
s"    r@ >cbw-flag c!" eval			( data-len )  ( R: cbw )
1A4B75C 	9C 53 A0  1 
1A4B760 	12 20 20 20 72 40 20 3E 
1A4B768 	63 62 77 2D 66 6C 61 67 
1A4B770 	20 63 21  0 D8 E5 A0  1 
s"    r@ >cbw-dlen le-l!" eval			( )  ( R: cbw )
1A4B778 	9C 53 A0  1 15 20 20 20 
1A4B780 	72 40 20 3E 63 62 77 2D 
1A4B788 	64 6C 65 6E 20 6C 65 2D 
1A4B790 	6C 21  0  0 D8 E5 A0  1 
s"    lun r@ >cbw-lun c!" eval			( )  ( R: cbw )
1A4B798 	9C 53 A0  1 15 20 20 20 
1A4B7A0 	6C 75 6E 20 72 40 20 3E 
1A4B7A8 	63 62 77 2D 6C 75 6E 20 
1A4B7B0 	63 21  0  0 D8 E5 A0  1 
s"    r> /cbw ;" eval				( cbw-adr,len )
1A4B7B8 	9C 53 A0  1  C 20 20 20 
1A4B7C0 	72 3E 20 2F 63 62 77 20 
1A4B7C8 	3B  0  0  0 D8 E5 A0  1 

s" : (get-csw)  ( -- len usberr )  csw /csw erase  csw /csw bulk-in-pipe bulk-in  ;" eval
1A4B7D0 	9C 53 A0  1 50 3A 20 28 
1A4B7D8 	67 65 74 2D 63 73 77 29 
1A4B7E0 	20 20 28 20 2D 2D 20 6C 
1A4B7E8 	65 6E 20 75 73 62 65 72 
1A4B7F0 	72 20 29 20 20 63 73 77 
1A4B7F8 	20 2F 63 73 77 20 65 72 
1A4B800 	61 73 65 20 20 63 73 77 
1A4B808 	20 2F 63 73 77 20 62 75 
1A4B810 	6C 6B 2D 69 6E 2D 70 69 
1A4B818 	70 65 20 62 75 6C 6B 2D 
1A4B820 	69 6E 20 20 3B  0  0  0 
1A4B828 	D8 E5 A0  1 
s" : get-csw" eval  ( -- len usberr )
1A4B82C 	9C 53 A0  1 
1A4B830 	 9 3A 20 67 65 74 2D 63 
1A4B838 	73 77  0  0 D8 E5 A0  1 
s"    (get-csw) dup  if  2drop (get-csw)  then ;" eval
1A4B840 	9C 53 A0  1 2D 20 20 20 
1A4B848 	28 67 65 74 2D 63 73 77 
1A4B850 	29 20 64 75 70 20 20 69 
1A4B858 	66 20 20 32 64 72 6F 70 
1A4B860 	20 28 67 65 74 2D 63 73 
1A4B868 	77 29 20 20 74 68 65 6E 
1A4B870 	20 3B  0  0 D8 E5 A0  1 

\ This used to be 15 seconds but I shortened it so timeouts can be
\ retried without having to wait too long.
s" d# 2000 constant bulk-timeout" eval
1A4B878 	9C 53 A0  1 1D 64 23 20 
1A4B880 	32 30 30 30 20 63 6F 6E 
1A4B888 	73 74 61 6E 74 20 62 75 
1A4B890 	6C 6B 2D 74 69 6D 65 6F 
1A4B898 	75 74  0  0 D8 E5 A0  1 

s" : (execute-command)" eval  ( data-adr,len dir cbw-adr,len -- actual-len cswStatus  )
1A4B8A0 	9C 53 A0  1 13 3A 20 28 
1A4B8A8 	65 78 65 63 75 74 65 2D 
1A4B8B0 	63 6F 6D 6D 61 6E 64 29 
1A4B8B8 	 0  0  0  0 D8 E5 A0  1 
s"    debug?  if" eval
1A4B8C0 	9C 53 A0  1  D 20 20 20 
1A4B8C8 	64 65 62 75 67 3F 20 20 
1A4B8D0 	69 66  0  0 D8 E5 A0  1 
 "       2dup "" dump"" evaluate cr" eval
1A4B8D8 	9C 53 A0  1 1E 20 20 20 
1A4B8E0 	20 20 20 32 64 75 70 20 
1A4B8E8 	22 20 64 75 6D 70 22 20 
1A4B8F0 	65 76 61 6C 75 61 74 65 
1A4B8F8 	20 63 72  0 D8 E5 A0  1 
s"    then" eval
1A4B900 	9C 53 A0  1  7 20 20 20 
1A4B908 	74 68 65 6E  0  0  0  0 
1A4B910 	D8 E5 A0  1 
s"    bulk-out-pipe bulk-out" eval		( data-adr,len dir usberr )
1A4B914 	9C 53 A0  1 
1A4B918 	19 20 20 20 62 75 6C 6B 
1A4B920 	2D 6F 75 74 2D 70 69 70 
1A4B928 	65 20 62 75 6C 6B 2D 6F 
1A4B930 	75 74  0  0 D8 E5 A0  1 
s"    USB_ERR_CRC invert and  if" eval		( data-adr,len dir )
1A4B938 	9C 53 A0  1 1D 20 20 20 
1A4B940 	55 53 42 5F 45 52 52 5F 
1A4B948 	43 52 43 20 69 6E 76 65 
1A4B950 	72 74 20 61 6E 64 20 20 
1A4B958 	69 66  0  0 D8 E5 A0  1 
s"       transport-reset  3drop 0 2 exit" eval   ( actual=0 status=retry )
1A4B960 	9C 53 A0  1 25 20 20 20 
1A4B968 	20 20 20 74 72 61 6E 73 
1A4B970 	70 6F 72 74 2D 72 65 73 
1A4B978 	65 74 20 20 33 64 72 6F 
1A4B980 	70 20 30 20 32 20 65 78 
1A4B988 	69 74  0  0 D8 E5 A0  1 
s"    then" eval                                 ( data-adr,len dir )
1A4B990 	9C 53 A0  1  7 20 20 20 
1A4B998 	74 68 65 6E  0  0  0  0 
1A4B9A0 	D8 E5 A0  1 
s"    over  if" eval                             ( data-adr,len dir )
1A4B9A4 	9C 53 A0  1 
1A4B9A8 	 B 20 20 20 6F 76 65 72 
1A4B9B0 	20 20 69 66  0  0  0  0 
1A4B9B8 	D8 E5 A0  1 
s"       if" eval				( data-adr,len )
1A4B9BC 	9C 53 A0  1 
1A4B9C0 	 8 20 20 20 20 20 20 69 
1A4B9C8 	66  0  0  0 D8 E5 A0  1 
s"          bulk-in-pipe bulk-in" eval           ( actual usberror )
1A4B9D0 	9C 53 A0  1 1D 20 20 20 
1A4B9D8 	20 20 20 20 20 20 62 75 
1A4B9E0 	6C 6B 2D 69 6E 2D 70 69 
1A4B9E8 	70 65 20 62 75 6C 6B 2D 
1A4B9F0 	69 6E  0  0 D8 E5 A0  1 
s"       else" eval				( data-adr,len )
1A4B9F8 	9C 53 A0  1  A 20 20 20 
1A4BA00 	20 20 20 65 6C 73 65  0 
1A4BA08 	D8 E5 A0  1 
s"          tuck bulk-out-pipe bulk-out" eval    ( len usberror )
1A4BA0C 	9C 53 A0  1 
1A4BA10 	24 20 20 20 20 20 20 20 
1A4BA18 	20 20 74 75 63 6B 20 62 
1A4BA20 	75 6C 6B 2D 6F 75 74 2D 
1A4BA28 	70 69 70 65 20 62 75 6C 
1A4BA30 	6B 2D 6F 75 74  0  0  0 
1A4BA38 	D8 E5 A0  1 
s"          dup  if  nip 0 swap  then" eval      ( len' usberror )
1A4BA3C 	9C 53 A0  1 
1A4BA40 	22 20 20 20 20 20 20 20 
1A4BA48 	20 20 64 75 70 20 20 69 
1A4BA50 	66 20 20 6E 69 70 20 30 
1A4BA58 	20 73 77 61 70 20 20 74 
1A4BA60 	68 65 6E  0 D8 E5 A0  1 
s"       then" eval				( usberror )
1A4BA68 	9C 53 A0  1  A 20 20 20 
1A4BA70 	20 20 20 74 68 65 6E  0 
1A4BA78 	D8 E5 A0  1 
s"    else" eval					( data-adr,len dir )
1A4BA7C 	9C 53 A0  1 
1A4BA80 	 7 20 20 20 65 6C 73 65 
1A4BA88 	 0  0  0  0 D8 E5 A0  1 
s"       drop nip  0" eval			( len usberror )
1A4BA90 	9C 53 A0  1 11 20 20 20 
1A4BA98 	20 20 20 64 72 6F 70 20 
1A4BAA0 	6E 69 70 20 20 30  0  0 
1A4BAA8 	D8 E5 A0  1 
s"    then" eval					( actual usberror )
1A4BAAC 	9C 53 A0  1 
1A4BAB0 	 7 20 20 20 74 68 65 6E 
1A4BAB8 	 0  0  0  0 D8 E5 A0  1 
s"    get-csw" eval				( actual usberror csw-len csw-usberror )
1A4BAC0 	9C 53 A0  1  A 20 20 20 
1A4BAC8 	67 65 74 2D 63 73 77  0 
1A4BAD0 	D8 E5 A0  1 
s"    rot  drop" eval				( actual csw-len csw-usberror )
1A4BAD4 	9C 53 A0  1 
1A4BAD8 	 C 20 20 20 72 6F 74 20 
1A4BAE0 	20 64 72 6F 70  0  0  0 
1A4BAE8 	D8 E5 A0  1 
s"    ?dup  if" eval                             ( actual csw-len csw-usberror )
1A4BAEC 	9C 53 A0  1 
1A4BAF0 	 B 20 20 20 3F 64 75 70 
1A4BAF8 	20 20 69 66  0  0  0  0 
1A4BB00 	D8 E5 A0  1 
s"       nip" eval                               ( actual csw-usberror )
1A4BB04 	9C 53 A0  1 
1A4BB08 	 9 20 20 20 20 20 20 6E 
1A4BB10 	69 70  0  0 D8 E5 A0  1 
s"       dup h# 10000000 =  if" eval             ( actual csw-usberror )
1A4BB18 	9C 53 A0  1 1B 20 20 20 
1A4BB20 	20 20 20 64 75 70 20 68 
1A4BB28 	23 20 31 30 30 30 30 30 
1A4BB30 	30 30 20 3D 20 20 69 66 
1A4BB38 	 0  0  0  0 D8 E5 A0  1 
s" notdef" $find ?dup
1A4BB40 	9C 53 A0  1  6 6E 6F 74 
1A4BB48 	64 65 66  0 C4 93 A0  1 
1A4BB50 	B4 70 A0  1 
if
1A4BB54 	DC 41 A0  1 
1A4BB58 	64  0  0  0 
\ This is for testing the problem described in OLPC trac #9423
\ The problem has been worked around so users no longer see it,
\ apart from a short delay when it happens, but for testing you
\ can enable this code to report the problem and count occurrences.
 " cr 7 emit ."" TIMEOUT "" 7 emit" eval
1A4BB5C 	9C 53 A0  1 
1A4BB60 	1D 63 72 20 37 20 65 6D 
1A4BB68 	69 74 20 2E 22 20 54 49 
1A4BB70 	4D 45 4F 55 54 20 22 20 
1A4BB78 	37 20 65 6D 69 74  0  0 
1A4BB80 	D8 E5 A0  1 
 " h# 72 cmos@ 1+ dup .d h# 72 cmos!" postpone eval
1A4BB84 	9C 53 A0  1 
1A4BB88 	21 68 23 20 37 32 20 63 
1A4BB90 	6D 6F 73 40 20 31 2B 20 
1A4BB98 	64 75 70 20 2E 64 20 68 
1A4BBA0 	23 20 37 32 20 63 6D 6F 
1A4BBA8 	73 21  0  0 8C 75 A0  1 
1A4BBB0 	D8 E5 A0  1 
  postpone cr
1A4BBB4 	8C 75 A0  1 
1A4BBB8 	80 6D A0  1 
then 2drop
1A4BBBC 	AC 49 A0  1 
s"          2drop 0 2" eval                      ( 0 2 )  \ Convert timeout error to a retry
1A4BBC0 	9C 53 A0  1 12 20 20 20 
1A4BBC8 	20 20 20 20 20 20 32 64 
1A4BBD0 	72 6F 70 20 30 20 32  0 
1A4BBD8 	D8 E5 A0  1 
s"       then" eval				( actual usberror )
1A4BBDC 	9C 53 A0  1 
1A4BBE0 	 A 20 20 20 20 20 20 74 
1A4BBE8 	68 65 6E  0 D8 E5 A0  1 
s"       exit" eval
1A4BBF0 	9C 53 A0  1  A 20 20 20 
1A4BBF8 	20 20 20 65 78 69 74  0 
1A4BC00 	D8 E5 A0  1 
s"    then" eval					( actual csw-len csw-usberror )
1A4BC04 	9C 53 A0  1 
1A4BC08 	 7 20 20 20 74 68 65 6E 
1A4BC10 	 0  0  0  0 D8 E5 A0  1 
s"    drop" eval                                 ( actual )
1A4BC18 	9C 53 A0  1  7 20 20 20 
1A4BC20 	64 72 6F 70  0  0  0  0 
1A4BC28 	D8 E5 A0  1 

s"    debug?  if" eval
1A4BC2C 	9C 53 A0  1 
1A4BC30 	 D 20 20 20 64 65 62 75 
1A4BC38 	67 3F 20 20 69 66  0  0 
1A4BC40 	D8 E5 A0  1 
 "       csw /csw "" dump"" evaluate cr" eval
1A4BC44 	9C 53 A0  1 
1A4BC48 	22 20 20 20 20 20 20 63 
1A4BC50 	73 77 20 2F 63 73 77 20 
1A4BC58 	22 20 64 75 6D 70 22 20 
1A4BC60 	65 76 61 6C 75 61 74 65 
1A4BC68 	20 63 72  0 D8 E5 A0  1 
s"    then" eval
1A4BC70 	9C 53 A0  1  7 20 20 20 
1A4BC78 	74 68 65 6E  0  0  0  0 
1A4BC80 	D8 E5 A0  1 

s"    csw >csw-stat c@" eval		        ( actual cswStatus )
1A4BC84 	9C 53 A0  1 
1A4BC88 	13 20 20 20 63 73 77 20 
1A4BC90 	3E 63 73 77 2D 73 74 61 
1A4BC98 	74 20 63 40  0  0  0  0 
1A4BCA0 	D8 E5 A0  1 
s"    dup 2 =  if  transport-reset  then" eval   ( actual cswStatus )
1A4BCA4 	9C 53 A0  1 
1A4BCA8 	25 20 20 20 64 75 70 20 
1A4BCB0 	32 20 3D 20 20 69 66 20 
1A4BCB8 	20 74 72 61 6E 73 70 6F 
1A4BCC0 	72 74 2D 72 65 73 65 74 
1A4BCC8 	20 20 74 68 65 6E  0  0 
1A4BCD0 	D8 E5 A0  1 
   \ Values are:
   \  0: No error - command is finished
   \  1: Error - do get-sense and possibly retry
   \  2: Phase error - retry after transport-reset
   \  else: Invalid status code - abort command
postpone ;
1A4BCD4 	E4 A6 A0  1 

s" : execute-command" eval  ( data-adr,len dir cmd-adr,len -- actual cswStatus )
1A4BCD8 	9C 53 A0  1 11 3A 20 65 
1A4BCE0 	78 65 63 75 74 65 2D 63 
1A4BCE8 	6F 6D 6D 61 6E 64  0  0 
1A4BCF0 	D8 E5 A0  1 
s"    execute-command-hook" eval                         ( data$ dir cmd$ )
1A4BCF4 	9C 53 A0  1 
1A4BCF8 	17 20 20 20 65 78 65 63 
1A4BD00 	75 74 65 2D 63 6F 6D 6D 
1A4BD08 	61 6E 64 2D 68 6F 6F 6B 
1A4BD10 	 0  0  0  0 D8 E5 A0  1 
s"    over c@ h# 1b =" eval                              ( data$ dir cmd$ flag )
1A4BD18 	9C 53 A0  1 12 20 20 20 
1A4BD20 	6F 76 65 72 20 63 40 20 
1A4BD28 	68 23 20 31 62 20 3D  0 
1A4BD30 	D8 E5 A0  1 
s"    2 pick 4 + c@  1 =  and  >r" eval	                ( data$ dir cmd$ r: Start-command? )
1A4BD34 	9C 53 A0  1 
1A4BD38 	1E 20 20 20 32 20 70 69 
1A4BD40 	63 6B 20 34 20 2B 20 63 
1A4BD48 	40 20 20 31 20 3D 20 20 
1A4BD50 	61 6E 64 20 20 3E 72  0 
1A4BD58 	D8 E5 A0  1 
s"    2over 2swap wrap-cbw" eval				( data-adr,len dir cbw-adr,len )
1A4BD5C 	9C 53 A0  1 
1A4BD60 	17 20 20 20 32 6F 76 65 
1A4BD68 	72 20 32 73 77 61 70 20 
1A4BD70 	77 72 61 70 2D 63 62 77 
1A4BD78 	 0  0  0  0 D8 E5 A0  1 
s"    (execute-command)" eval                            ( actual cswStatus )
1A4BD80 	9C 53 A0  1 14 20 20 20 
1A4BD88 	28 65 78 65 63 75 74 65 
1A4BD90 	2D 63 6F 6D 6D 61 6E 64 
1A4BD98 	29  0  0  0 D8 E5 A0  1 
s"    r>  if  drop 0  then ;" eval \ Fake ok if it's a start commmand
1A4BDA0 	9C 53 A0  1 19 20 20 20 
1A4BDA8 	72 3E 20 20 69 66 20 20 
1A4BDB0 	64 72 6F 70 20 30 20 20 
1A4BDB8 	74 68 65 6E 20 3B  0  0 
1A4BDC0 	D8 E5 A0  1 
s" : set-address" eval  ( lun -- )
1A4BDC4 	9C 53 A0  1 
1A4BDC8 	 D 3A 20 73 65 74 2D 61 
1A4BDD0 	64 64 72 65 73 73  0  0 
1A4BDD8 	D8 E5 A0  1 
s"    0 max max-lun min  to lun" eval
1A4BDDC 	9C 53 A0  1 
1A4BDE0 	1C 20 20 20 30 20 6D 61 
1A4BDE8 	78 20 6D 61 78 2D 6C 75 
1A4BDF0 	6E 20 6D 69 6E 20 20 74 
1A4BDF8 	6F 20 6C 75 6E  0  0  0 
1A4BE00 	D8 E5 A0  1 
s"    reset?  if" eval
1A4BE04 	9C 53 A0  1 
1A4BE08 	 D 20 20 20 72 65 73 65 
1A4BE10 	74 3F 20 20 69 66  0  0 
1A4BE18 	D8 E5 A0  1 
s"       configuration set-config  if" eval
1A4BE1C 	9C 53 A0  1 
1A4BE20 	22 20 20 20 20 20 20 63 
1A4BE28 	6F 6E 66 69 67 75 72 61 
1A4BE30 	74 69 6F 6E 20 73 65 74 
1A4BE38 	2D 63 6F 6E 66 69 67 20 
1A4BE40 	20 69 66  0 D8 E5 A0  1 
 "          ."" USB storage scsi layer: Failed to set configuration"" cr" eval
1A4BE48 	9C 53 A0  1 43 20 20 20 
1A4BE50 	20 20 20 20 20 20 2E 22 
1A4BE58 	20 55 53 42 20 73 74 6F 
1A4BE60 	72 61 67 65 20 73 63 73 
1A4BE68 	69 20 6C 61 79 65 72 3A 
1A4BE70 	20 46 61 69 6C 65 64 20 
1A4BE78 	74 6F 20 73 65 74 20 63 
1A4BE80 	6F 6E 66 69 67 75 72 61 
1A4BE88 	74 69 6F 6E 22 20 63 72 
1A4BE90 	 0  0  0  0 D8 E5 A0  1 
s"       then" eval
1A4BE98 	9C 53 A0  1  A 20 20 20 
1A4BEA0 	20 20 20 74 68 65 6E  0 
1A4BEA8 	D8 E5 A0  1 
s"       bulk-in-pipe bulk-out-pipe reset-bulk-toggles" eval
1A4BEAC 	9C 53 A0  1 
1A4BEB0 	33 20 20 20 20 20 20 62 
1A4BEB8 	75 6C 6B 2D 69 6E 2D 70 
1A4BEC0 	69 70 65 20 62 75 6C 6B 
1A4BEC8 	2D 6F 75 74 2D 70 69 70 
1A4BED0 	65 20 72 65 73 65 74 2D 
1A4BED8 	62 75 6C 6B 2D 74 6F 67 
1A4BEE0 	67 6C 65 73  0  0  0  0 
1A4BEE8 	D8 E5 A0  1 
s"    then ;" eval
1A4BEEC 	9C 53 A0  1 
1A4BEF0 	 9 20 20 20 74 68 65 6E 
1A4BEF8 	20 3B  0  0 D8 E5 A0  1 
s" : set-timeout  ( n -- )  bulk-timeout max set-bulk-in-timeout  ;" eval
1A4BF00 	9C 53 A0  1 40 3A 20 73 
1A4BF08 	65 74 2D 74 69 6D 65 6F 
1A4BF10 	75 74 20 20 28 20 6E 20 
1A4BF18 	2D 2D 20 29 20 20 62 75 
1A4BF20 	6C 6B 2D 74 69 6D 65 6F 
1A4BF28 	75 74 20 6D 61 78 20 73 
1A4BF30 	65 74 2D 62 75 6C 6B 2D 
1A4BF38 	69 6E 2D 74 69 6D 65 6F 
1A4BF40 	75 74 20 20 3B  0  0  0 
1A4BF48 	D8 E5 A0  1 
s" : reopen-hardware" eval   ( -- ok? )
1A4BF4C 	9C 53 A0  1 
1A4BF50 	11 3A 20 72 65 6F 70 65 
1A4BF58 	6E 2D 68 61 72 64 77 61 
1A4BF60 	72 65  0  0 D8 E5 A0  1 
s"    set-device?  if  false exit  then" eval  \ The device number may have changed if we recycled the node
1A4BF68 	9C 53 A0  1 24 20 20 20 
1A4BF70 	73 65 74 2D 64 65 76 69 
1A4BF78 	63 65 3F 20 20 69 66 20 
1A4BF80 	20 66 61 6C 73 65 20 65 
1A4BF88 	78 69 74 20 20 74 68 65 
1A4BF90 	6E  0  0  0 D8 E5 A0  1 
s"    device set-target" eval
1A4BF98 	9C 53 A0  1 14 20 20 20 
1A4BFA0 	64 65 76 69 63 65 20 73 
1A4BFA8 	65 74 2D 74 61 72 67 65 
1A4BFB0 	74  0  0  0 D8 E5 A0  1 
s"    true ;" eval
1A4BFB8 	9C 53 A0  1  9 20 20 20 
1A4BFC0 	74 72 75 65 20 3B  0  0 
1A4BFC8 	D8 E5 A0  1 
s" : open-hardware     ( -- ok? )  alloc-bulk  reopen-hardware  ;" eval
1A4BFCC 	9C 53 A0  1 
1A4BFD0 	3E 3A 20 6F 70 65 6E 2D 
1A4BFD8 	68 61 72 64 77 61 72 65 
1A4BFE0 	20 20 20 20 20 28 20 2D 
1A4BFE8 	2D 20 6F 6B 3F 20 29 20 
1A4BFF0 	20 61 6C 6C 6F 63 2D 62 
1A4BFF8 	75 6C 6B 20 20 72 65 6F 
1A4C000 	70 65 6E 2D 68 61 72 64 
1A4C008 	77 61 72 65 20 20 3B  0 
1A4C010 	D8 E5 A0  1 
s" : reclose-hardware  ( -- )	;" eval
1A4C014 	9C 53 A0  1 
1A4C018 	1C 3A 20 72 65 63 6C 6F 
1A4C020 	73 65 2D 68 61 72 64 77 
1A4C028 	61 72 65 20 20 28 20 2D 
1A4C030 	2D 20 29  9 3B  0  0  0 
1A4C038 	D8 E5 A0  1 
s" : close-hardware    ( -- )      free-bulk  ;" eval
1A4C03C 	9C 53 A0  1 
1A4C040 	2C 3A 20 63 6C 6F 73 65 
1A4C048 	2D 68 61 72 64 77 61 72 
1A4C050 	65 20 20 20 20 28 20 2D 
1A4C058 	2D 20 29 20 20 20 20 20 
1A4C060 	20 66 72 65 65 2D 62 75 
1A4C068 	6C 6B 20 20 3B  0  0  0 
1A4C070 	D8 E5 A0  1 
s" : reset  ( -- )  transport-reset  ;" eval
1A4C074 	9C 53 A0  1 
1A4C078 	23 3A 20 72 65 73 65 74 
1A4C080 	20 20 28 20 2D 2D 20 29 
1A4C088 	20 20 74 72 61 6E 73 70 
1A4C090 	6F 72 74 2D 72 65 73 65 
1A4C098 	74 20 20 3B  0  0  0  0 
1A4C0A0 	D8 E5 A0  1 
s" : selftest  ( -- 0 | error-code )  0  ;" eval
1A4C0A4 	9C 53 A0  1 
1A4C0A8 	27 3A 20 73 65 6C 66 74 
1A4C0B0 	65 73 74 20 20 28 20 2D 
1A4C0B8 	2D 20 30 20 7C 20 65 72 
1A4C0C0 	72 6F 72 2D 63 6F 64 65 
1A4C0C8 	20 29 20 20 30 20 20 3B 
1A4C0D0 	 0  0  0  0 D8 E5 A0  1 
;
1A4C0D8 	58 46 A0  1 

OpenFirmware/dev/usb2/device/storage/scsi.fth_AL	131C 1A4C0DC purpose: ATAPI interface

: atapifth 
1A4C0DC 	 0  0  0 61 
1A4C0E0 	74 61 70 69 66 74 68 88 
1A4C0E8 	CC AD A4  1 20 40 A0  1 
hex
1A4C0F0 	C0 8D A0  1 
s" d# 12 dup constant pkt-len" eval
1A4C0F4 	9C 53 A0  1 
1A4C0F8 	1A 64 23 20 31 32 20 64 
1A4C100 	75 70 20 63 6F 6E 73 74 
1A4C108 	61 6E 74 20 70 6B 74 2D 
1A4C110 	6C 65 6E  0 D8 E5 A0  1 
s" buffer: pkt-buf" eval
1A4C118 	9C 53 A0  1  F 62 75 66 
1A4C120 	66 65 72 3A 20 70 6B 74 
1A4C128 	2D 62 75 66  0  0  0  0 
1A4C130 	D8 E5 A0  1 

\ ATAPI devices only accept 12 byte long commands
\ Fixup the SCSI commands before sending them out

s" : translate-atapi-command" eval  ( cmd-adr,len -- pkt-buf,len )
1A4C134 	9C 53 A0  1 
1A4C138 	19 3A 20 74 72 61 6E 73 
1A4C140 	6C 61 74 65 2D 61 74 61 
1A4C148 	70 69 2D 63 6F 6D 6D 61 
1A4C150 	6E 64  0  0 D8 E5 A0  1 
s"    pkt-buf dup >r pkt-len erase" eval			\ Zero pkt-buf
1A4C158 	9C 53 A0  1 1F 20 20 20 
1A4C160 	70 6B 74 2D 62 75 66 20 
1A4C168 	64 75 70 20 3E 72 20 70 
1A4C170 	6B 74 2D 6C 65 6E 20 65 
1A4C178 	72 61 73 65  0  0  0  0 
1A4C180 	D8 E5 A0  1 
s"    r@ swap move" eval				\ Copy cmd$ to pkt-buf
1A4C184 	9C 53 A0  1 
1A4C188 	 F 20 20 20 72 40 20 73 
1A4C190 	77 61 70 20 6D 6F 76 65 
1A4C198 	 0  0  0  0 D8 E5 A0  1 
s"    r@ c@ dup h# 15 = swap h# 1a = or  if" eval	\ Mode send or mode select command
1A4C1A0 	9C 53 A0  1 28 20 20 20 
1A4C1A8 	72 40 20 63 40 20 64 75 
1A4C1B0 	70 20 68 23 20 31 35 20 
1A4C1B8 	3D 20 73 77 61 70 20 68 
1A4C1C0 	23 20 31 61 20 3D 20 6F 
1A4C1C8 	72 20 20 69 66  0  0  0 
1A4C1D0 	D8 E5 A0  1 
s"       r@ c@ h# 40 or r@ c!" eval		\ Fix it
1A4C1D4 	9C 53 A0  1 
1A4C1D8 	1A 20 20 20 20 20 20 72 
1A4C1E0 	40 20 63 40 20 68 23 20 
1A4C1E8 	34 30 20 6F 72 20 72 40 
1A4C1F0 	20 63 21  0 D8 E5 A0  1 
s"       r@ 4 + c@ r@ 8 + c!" eval
1A4C1F8 	9C 53 A0  1 19 20 20 20 
1A4C200 	20 20 20 72 40 20 34 20 
1A4C208 	2B 20 63 40 20 72 40 20 
1A4C210 	38 20 2B 20 63 21  0  0 
1A4C218 	D8 E5 A0  1 
s"       0 r@ 4 + c!" eval
1A4C21C 	9C 53 A0  1 
1A4C220 	11 20 20 20 20 20 20 30 
1A4C228 	20 72 40 20 34 20 2B 20 
1A4C230 	63 21  0  0 D8 E5 A0  1 
s"    else" eval
1A4C238 	9C 53 A0  1  7 20 20 20 
1A4C240 	65 6C 73 65  0  0  0  0 
1A4C248 	D8 E5 A0  1 
s"       r@ c@ dup 8 = swap h# a = or  if" eval		\ Read or write command
1A4C24C 	9C 53 A0  1 
1A4C250 	26 20 20 20 20 20 20 72 
1A4C258 	40 20 63 40 20 64 75 70 
1A4C260 	20 38 20 3D 20 73 77 61 
1A4C268 	70 20 68 23 20 61 20 3D 
1A4C270 	20 6F 72 20 20 69 66  0 
1A4C278 	D8 E5 A0  1 
s"          r@ c@ h# 20 or r@ c!" eval			\ Fix it
1A4C27C 	9C 53 A0  1 
1A4C280 	1D 20 20 20 20 20 20 20 
1A4C288 	20 20 72 40 20 63 40 20 
1A4C290 	68 23 20 32 30 20 6F 72 
1A4C298 	20 72 40 20 63 21  0  0 
1A4C2A0 	D8 E5 A0  1 
s"          r@ 1+ c@ dup h# e0 and r@ 1+ c!" eval
1A4C2A4 	9C 53 A0  1 
1A4C2A8 	28 20 20 20 20 20 20 20 
1A4C2B0 	20 20 72 40 20 31 2B 20 
1A4C2B8 	63 40 20 64 75 70 20 68 
1A4C2C0 	23 20 65 30 20 61 6E 64 
1A4C2C8 	20 72 40 20 31 2B 20 63 
1A4C2D0 	21  0  0  0 D8 E5 A0  1 
s"          r@ 4 + c@ r@ 8 + c!" eval
1A4C2D8 	9C 53 A0  1 1C 20 20 20 
1A4C2E0 	20 20 20 20 20 20 72 40 
1A4C2E8 	20 34 20 2B 20 63 40 20 
1A4C2F0 	72 40 20 38 20 2B 20 63 
1A4C2F8 	21  0  0  0 D8 E5 A0  1 
s"          r@ 3 + c@ r@ 5 + c!" eval
1A4C300 	9C 53 A0  1 1C 20 20 20 
1A4C308 	20 20 20 20 20 20 72 40 
1A4C310 	20 33 20 2B 20 63 40 20 
1A4C318 	72 40 20 35 20 2B 20 63 
1A4C320 	21  0  0  0 D8 E5 A0  1 
s"          r@ 2 + c@ r@ 4 + c!" eval
1A4C328 	9C 53 A0  1 1C 20 20 20 
1A4C330 	20 20 20 20 20 20 72 40 
1A4C338 	20 32 20 2B 20 63 40 20 
1A4C340 	72 40 20 34 20 2B 20 63 
1A4C348 	21  0  0  0 D8 E5 A0  1 
s"          h# 1f and r@ 3 + c!" eval
1A4C350 	9C 53 A0  1 1C 20 20 20 
1A4C358 	20 20 20 20 20 20 68 23 
1A4C360 	20 31 66 20 61 6E 64 20 
1A4C368 	72 40 20 33 20 2B 20 63 
1A4C370 	21  0  0  0 D8 E5 A0  1 
s"          0 r@ 2 + c!" eval
1A4C378 	9C 53 A0  1 14 20 20 20 
1A4C380 	20 20 20 20 20 20 30 20 
1A4C388 	72 40 20 32 20 2B 20 63 
1A4C390 	21  0  0  0 D8 E5 A0  1 
s"       then" eval
1A4C398 	9C 53 A0  1  A 20 20 20 
1A4C3A0 	20 20 20 74 68 65 6E  0 
1A4C3A8 	D8 E5 A0  1 
s"    then" eval
1A4C3AC 	9C 53 A0  1 
1A4C3B0 	 7 20 20 20 74 68 65 6E 
1A4C3B8 	 0  0  0  0 D8 E5 A0  1 
s"    r> pkt-len ;" eval
1A4C3C0 	9C 53 A0  1  F 20 20 20 
1A4C3C8 	72 3E 20 70 6B 74 2D 6C 
1A4C3D0 	65 6E 20 3B  0  0  0  0 
1A4C3D8 	D8 E5 A0  1 
s" : init-atapi-execute-command" eval  ( -- )
1A4C3DC 	9C 53 A0  1 
1A4C3E0 	1C 3A 20 69 6E 69 74 2D 
1A4C3E8 	61 74 61 70 69 2D 65 78 
1A4C3F0 	65 63 75 74 65 2D 63 6F 
1A4C3F8 	6D 6D 61 6E 64  0  0  0 
1A4C400 	D8 E5 A0  1 
 "    "" is-atapi"" get-my-property 0=  if" eval
1A4C404 	9C 53 A0  1 
1A4C408 	25 20 20 20 22 20 69 73 
1A4C410 	2D 61 74 61 70 69 22 20 
1A4C418 	67 65 74 2D 6D 79 2D 70 
1A4C420 	72 6F 70 65 72 74 79 20 
1A4C428 	30 3D 20 20 69 66  0  0 
1A4C430 	D8 E5 A0  1 
s"       2drop" eval
1A4C434 	9C 53 A0  1 
1A4C438 	 B 20 20 20 20 20 20 32 
1A4C440 	64 72 6F 70  0  0  0  0 
1A4C448 	D8 E5 A0  1 
s"       ['] translate-atapi-command to execute-command-hook" eval
1A4C44C 	9C 53 A0  1 
1A4C450 	39 20 20 20 20 20 20 5B 
1A4C458 	27 5D 20 74 72 61 6E 73 
1A4C460 	6C 61 74 65 2D 61 74 61 
1A4C468 	70 69 2D 63 6F 6D 6D 61 
1A4C470 	6E 64 20 74 6F 20 65 78 
1A4C478 	65 63 75 74 65 2D 63 6F 
1A4C480 	6D 6D 61 6E 64 2D 68 6F 
1A4C488 	6F 6B  0  0 D8 E5 A0  1 
s"    then ;" eval
1A4C490 	9C 53 A0  1  9 20 20 20 
1A4C498 	74 68 65 6E 20 3B  0  0 
1A4C4A0 	D8 E5 A0  1 
s" ' init-atapi-execute-command  to init-execute-command" eval
1A4C4A4 	9C 53 A0  1 
1A4C4A8 	35 27 20 69 6E 69 74 2D 
1A4C4B0 	61 74 61 70 69 2D 65 78 
1A4C4B8 	65 63 75 74 65 2D 63 6F 
1A4C4C0 	6D 6D 61 6E 64 20 20 74 
1A4C4C8 	6F 20 69 6E 69 74 2D 65 
1A4C4D0 	78 65 63 75 74 65 2D 63 
1A4C4D8 	6F 6D 6D 61 6E 64  0  0 
1A4C4E0 	D8 E5 A0  1 
;
1A4C4E4 	58 46 A0  1 
\

OpenFirmware/dev/usb2/device/storage/atapi.fth_AL	40C 1A4C4E8 \ Common code for SCSI host adapter drivers.

\ The following code is intended to be independent of the details of the
\ SCSI hardware implementation.  It is loaded after the hardware-dependent
\ file that defines execute-command, set-address, open-hardware, etc.

: hacomfth 
1A4C4E8 	 0  0  0 68 61 63 6F 6D 
1A4C4F0 	66 74 68 88 EC C0 A4  1 
1A4C4F8 	20 40 A0  1 
s" -1 value inq-buf" eval                  \ Address of inquiry data buffer
1A4C4FC 	9C 53 A0  1 
1A4C500 	10 2D 31 20 76 61 6C 75 
1A4C508 	65 20 69 6E 71 2D 62 75 
1A4C510 	66  0  0  0 D8 E5 A0  1 
s" -1 value sense-buf" eval                \ holds extended error information
1A4C518 	9C 53 A0  1 12 2D 31 20 
1A4C520 	76 61 6C 75 65 20 73 65 
1A4C528 	6E 73 65 2D 62 75 66  0 
1A4C530 	D8 E5 A0  1 


s" 0 value #retries" eval  ( -- n )        \ number of times to retry SCSI transaction
1A4C534 	9C 53 A0  1 
1A4C538 	10 30 20 76 61 6C 75 65 
1A4C540 	20 23 72 65 74 72 69 65 
1A4C548 	73  0  0  0 D8 E5 A0  1 

\ Classifies the sense condition as either okay (0), retryable (1),
\ or non-retryable (-1)
s" : classify-sense" eval  ( -- 0 | 1 | -1 )
1A4C550 	9C 53 A0  1 10 3A 20 63 
1A4C558 	6C 61 73 73 69 66 79 2D 
1A4C560 	73 65 6E 73 65  0  0  0 
1A4C568 	D8 E5 A0  1 
s"    debug?  if" eval
1A4C56C 	9C 53 A0  1 
1A4C570 	 D 20 20 20 64 65 62 75 
1A4C578 	67 3F 20 20 69 66  0  0 
1A4C580 	D8 E5 A0  1 
s"       base @ >r hex" eval
1A4C584 	9C 53 A0  1 
1A4C588 	13 20 20 20 20 20 20 62 
1A4C590 	61 73 65 20 40 20 3E 72 
1A4C598 	20 68 65 78  0  0  0  0 
1A4C5A0 	D8 E5 A0  1 
 "       ."" Sense:  "" sense-buf 11 bounds  do  i c@ 3 u.r  loop  .""  ..."" cr" eval
1A4C5A4 	9C 53 A0  1 
1A4C5A8 	49 20 20 20 20 20 20 2E 
1A4C5B0 	22 20 53 65 6E 73 65 3A 
1A4C5B8 	20 20 22 20 73 65 6E 73 
1A4C5C0 	65 2D 62 75 66 20 31 31 
1A4C5C8 	20 62 6F 75 6E 64 73 20 
1A4C5D0 	20 64 6F 20 20 69 20 63 
1A4C5D8 	40 20 33 20 75 2E 72 20 
1A4C5E0 	20 6C 6F 6F 70 20 20 2E 
1A4C5E8 	22 20 20 2E 2E 2E 22 20 
1A4C5F0 	63 72  0  0 D8 E5 A0  1 
s"       r> base !" eval
1A4C5F8 	9C 53 A0  1  F 20 20 20 
1A4C600 	20 20 20 72 3E 20 62 61 
1A4C608 	73 65 20 21  0  0  0  0 
1A4C610 	D8 E5 A0  1 
s"    then        " eval
1A4C614 	9C 53 A0  1 
1A4C618 	 F 20 20 20 74 68 65 6E 
1A4C620 	20 20 20 20 20 20 20 20 
1A4C628 	 0  0  0  0 D8 E5 A0  1 
s"    sense-buf   " eval
1A4C630 	9C 53 A0  1  F 20 20 20 
1A4C638 	73 65 6E 73 65 2D 62 75 
1A4C640 	66 20 20 20  0  0  0  0 
1A4C648 	D8 E5 A0  1 

   \ Make sure we understand the error class code
s"    dup c@  h# 7f and h# 70 <>  if  drop -1 exit  then" eval
1A4C64C 	9C 53 A0  1 
1A4C650 	35 20 20 20 64 75 70 20 
1A4C658 	63 40 20 20 68 23 20 37 
1A4C660 	66 20 61 6E 64 20 68 23 
1A4C668 	20 37 30 20 3C 3E 20 20 
1A4C670 	69 66 20 20 64 72 6F 70 
1A4C678 	20 2D 31 20 65 78 69 74 
1A4C680 	20 20 74 68 65 6E  0  0 
1A4C688 	D8 E5 A0  1 

   \ Check for filemark, end-of-media, or illegal block length
s"    dup 2+ c@  h# e0  and  if  drop -1 exit  then" eval
1A4C68C 	9C 53 A0  1 
1A4C690 	30 20 20 20 64 75 70 20 
1A4C698 	32 2B 20 63 40 20 20 68 
1A4C6A0 	23 20 65 30 20 20 61 6E 
1A4C6A8 	64 20 20 69 66 20 20 64 
1A4C6B0 	72 6F 70 20 2D 31 20 65 
1A4C6B8 	78 69 74 20 20 74 68 65 
1A4C6C0 	6E  0  0  0 D8 E5 A0  1 

s"    2 + c@  h# f and" eval   ( sense-key )
1A4C6C8 	9C 53 A0  1 13 20 20 20 
1A4C6D0 	32 20 2B 20 63 40 20 20 
1A4C6D8 	68 23 20 66 20 61 6E 64 
1A4C6E0 	 0  0  0  0 D8 E5 A0  1 

   \ no_sense(0) and recoverable(1) are okay
s"    dup 1 <=  if  drop 0 exit  then" eval   ( sense-key )
1A4C6E8 	9C 53 A0  1 22 20 20 20 
1A4C6F0 	64 75 70 20 31 20 3C 3D 
1A4C6F8 	20 20 69 66 20 20 64 72 
1A4C700 	6F 70 20 30 20 65 78 69 
1A4C708 	74 20 20 74 68 65 6E  0 
1A4C710 	D8 E5 A0  1 

   \ not-ready(2) may be retryable
s"    dup 2 =  if" eval
1A4C714 	9C 53 A0  1 
1A4C718 	 E 20 20 20 64 75 70 20 
1A4C720 	32 20 3D 20 20 69 66  0 
1A4C728 	D8 E5 A0  1 
      \ check (tapes, especially) for MEDIA NOT PRESENT: if the
      \ media's not there the command is not retryable
s"       drop" eval
1A4C72C 	9C 53 A0  1 
1A4C730 	 A 20 20 20 20 20 20 64 
1A4C738 	72 6F 70  0 D8 E5 A0  1 
s"       sense-buf h# c + c@  h# 3a =  sense-buf h# d + c@ 0=  and" eval  ( not-present? )
1A4C740 	9C 53 A0  1 3F 20 20 20 
1A4C748 	20 20 20 73 65 6E 73 65 
1A4C750 	2D 62 75 66 20 68 23 20 
1A4C758 	63 20 2B 20 63 40 20 20 
1A4C760 	68 23 20 33 61 20 3D 20 
1A4C768 	20 73 65 6E 73 65 2D 62 
1A4C770 	75 66 20 68 23 20 64 20 
1A4C778 	2B 20 63 40 20 30 3D 20 
1A4C780 	20 61 6E 64  0  0  0  0 
1A4C788 	D8 E5 A0  1 
s"       if  -1  else  1  then  exit" eval
1A4C78C 	9C 53 A0  1 
1A4C790 	21 20 20 20 20 20 20 69 
1A4C798 	66 20 20 2D 31 20 20 65 
1A4C7A0 	6C 73 65 20 20 31 20 20 
1A4C7A8 	74 68 65 6E 20 20 65 78 
1A4C7B0 	69 74  0  0 D8 E5 A0  1 
s"    then" eval
1A4C7B8 	9C 53 A0  1  7 20 20 20 
1A4C7C0 	74 68 65 6E  0  0  0  0 
1A4C7C8 	D8 E5 A0  1 

   \ Media-error(3) is not retryable
s"    dup 3 =  if  drop -1 exit  then" eval
1A4C7CC 	9C 53 A0  1 
1A4C7D0 	22 20 20 20 64 75 70 20 
1A4C7D8 	33 20 3D 20 20 69 66 20 
1A4C7E0 	20 64 72 6F 70 20 2D 31 
1A4C7E8 	20 65 78 69 74 20 20 74 
1A4C7F0 	68 65 6E  0 D8 E5 A0  1 

   \ Attention(6), and target aborted (b) are retryable.
s"    dup 6 =  swap 0b =  or if  1  else  -1  then ;" eval
1A4C7F8 	9C 53 A0  1 31 20 20 20 
1A4C800 	64 75 70 20 36 20 3D 20 
1A4C808 	20 73 77 61 70 20 30 62 
1A4C810 	20 3D 20 20 6F 72 20 69 
1A4C818 	66 20 20 31 20 20 65 6C 
1A4C820 	73 65 20 20 2D 31 20 20 
1A4C828 	74 68 65 6E 20 3B  0  0 
1A4C830 	D8 E5 A0  1 

s" 0 value open-count" eval
1A4C834 	9C 53 A0  1 
1A4C838 	12 30 20 76 61 6C 75 65 
1A4C840 	20 6F 70 65 6E 2D 63 6F 
1A4C848 	75 6E 74  0 D8 E5 A0  1 

s" : open" eval  ( -- flag )
1A4C850 	9C 53 A0  1  6 3A 20 6F 
1A4C858 	70 65 6E  0 D8 E5 A0  1 
 "    my-args  "" debug"" $=  if  debug-on  then" eval
1A4C860 	9C 53 A0  1 2B 20 20 20 
1A4C868 	6D 79 2D 61 72 67 73 20 
1A4C870 	20 22 20 64 65 62 75 67 
1A4C878 	22 20 24 3D 20 20 69 66 
1A4C880 	20 20 64 65 62 75 67 2D 
1A4C888 	6F 6E 20 20 74 68 65 6E 
1A4C890 	 0  0  0  0 D8 E5 A0  1 
s"    open-count  if" eval
1A4C898 	9C 53 A0  1 11 20 20 20 
1A4C8A0 	6F 70 65 6E 2D 63 6F 75 
1A4C8A8 	6E 74 20 20 69 66  0  0 
1A4C8B0 	D8 E5 A0  1 
s"       reopen-hardware  dup  if  open-count 1+ to open-count  then" eval
1A4C8B4 	9C 53 A0  1 
1A4C8B8 	41 20 20 20 20 20 20 72 
1A4C8C0 	65 6F 70 65 6E 2D 68 61 
1A4C8C8 	72 64 77 61 72 65 20 20 
1A4C8D0 	64 75 70 20 20 69 66 20 
1A4C8D8 	20 6F 70 65 6E 2D 63 6F 
1A4C8E0 	75 6E 74 20 31 2B 20 74 
1A4C8E8 	6F 20 6F 70 65 6E 2D 63 
1A4C8F0 	6F 75 6E 74 20 20 74 68 
1A4C8F8 	65 6E  0  0 D8 E5 A0  1 
s"       exit" eval
1A4C900 	9C 53 A0  1  A 20 20 20 
1A4C908 	20 20 20 65 78 69 74  0 
1A4C910 	D8 E5 A0  1 
s"    else" eval
1A4C914 	9C 53 A0  1 
1A4C918 	 7 20 20 20 65 6C 73 65 
1A4C920 	 0  0  0  0 D8 E5 A0  1 
s"       open-hardware  dup  if" eval
1A4C928 	9C 53 A0  1 1C 20 20 20 
1A4C930 	20 20 20 6F 70 65 6E 2D 
1A4C938 	68 61 72 64 77 61 72 65 
1A4C940 	20 20 64 75 70 20 20 69 
1A4C948 	66  0  0  0 D8 E5 A0  1 
s"          1 to open-count" eval
1A4C950 	9C 53 A0  1 18 20 20 20 
1A4C958 	20 20 20 20 20 20 31 20 
1A4C960 	74 6F 20 6F 70 65 6E 2D 
1A4C968 	63 6F 75 6E 74  0  0  0 
1A4C970 	D8 E5 A0  1 
s"          100 dma-alloc to sense-buf" eval
1A4C974 	9C 53 A0  1 
1A4C978 	23 20 20 20 20 20 20 20 
1A4C980 	20 20 31 30 30 20 64 6D 
1A4C988 	61 2D 61 6C 6C 6F 63 20 
1A4C990 	74 6F 20 73 65 6E 73 65 
1A4C998 	2D 62 75 66  0  0  0  0 
1A4C9A0 	D8 E5 A0  1 
s"          100 dma-alloc to inq-buf" eval
1A4C9A4 	9C 53 A0  1 
1A4C9A8 	21 20 20 20 20 20 20 20 
1A4C9B0 	20 20 31 30 30 20 64 6D 
1A4C9B8 	61 2D 61 6C 6C 6F 63 20 
1A4C9C0 	74 6F 20 69 6E 71 2D 62 
1A4C9C8 	75 66  0  0 D8 E5 A0  1 
s"       then" eval
1A4C9D0 	9C 53 A0  1  A 20 20 20 
1A4C9D8 	20 20 20 74 68 65 6E  0 
1A4C9E0 	D8 E5 A0  1 
s"    then ;" eval
1A4C9E4 	9C 53 A0  1 
1A4C9E8 	 9 20 20 20 74 68 65 6E 
1A4C9F0 	20 3B  0  0 D8 E5 A0  1 
s" : close" eval  ( -- )
1A4C9F8 	9C 53 A0  1  7 3A 20 63 
1A4CA00 	6C 6F 73 65  0  0  0  0 
1A4CA08 	D8 E5 A0  1 
s"    open-count 1- to open-count" eval
1A4CA0C 	9C 53 A0  1 
1A4CA10 	1E 20 20 20 6F 70 65 6E 
1A4CA18 	2D 63 6F 75 6E 74 20 31 
1A4CA20 	2D 20 74 6F 20 6F 70 65 
1A4CA28 	6E 2D 63 6F 75 6E 74  0 
1A4CA30 	D8 E5 A0  1 
s"    open-count  if" eval
1A4CA34 	9C 53 A0  1 
1A4CA38 	11 20 20 20 6F 70 65 6E 
1A4CA40 	2D 63 6F 75 6E 74 20 20 
1A4CA48 	69 66  0  0 D8 E5 A0  1 
s"       reclose-hardware" eval
1A4CA50 	9C 53 A0  1 16 20 20 20 
1A4CA58 	20 20 20 72 65 63 6C 6F 
1A4CA60 	73 65 2D 68 61 72 64 77 
1A4CA68 	61 72 65  0 D8 E5 A0  1 
s"    else" eval
1A4CA70 	9C 53 A0  1  7 20 20 20 
1A4CA78 	65 6C 73 65  0  0  0  0 
1A4CA80 	D8 E5 A0  1 
s"       close-hardware" eval
1A4CA84 	9C 53 A0  1 
1A4CA88 	14 20 20 20 20 20 20 63 
1A4CA90 	6C 6F 73 65 2D 68 61 72 
1A4CA98 	64 77 61 72 65  0  0  0 
1A4CAA0 	D8 E5 A0  1 
s"       inq-buf   100 dma-free" eval
1A4CAA4 	9C 53 A0  1 
1A4CAA8 	1C 20 20 20 20 20 20 69 
1A4CAB0 	6E 71 2D 62 75 66 20 20 
1A4CAB8 	20 31 30 30 20 64 6D 61 
1A4CAC0 	2D 66 72 65 65  0  0  0 
1A4CAC8 	D8 E5 A0  1 
s"       sense-buf 100 dma-free" eval
1A4CACC 	9C 53 A0  1 
1A4CAD0 	1C 20 20 20 20 20 20 73 
1A4CAD8 	65 6E 73 65 2D 62 75 66 
1A4CAE0 	20 31 30 30 20 64 6D 61 
1A4CAE8 	2D 66 72 65 65  0  0  0 
1A4CAF0 	D8 E5 A0  1 
s"    then ;" eval
1A4CAF4 	9C 53 A0  1 
1A4CAF8 	 9 20 20 20 74 68 65 6E 
1A4CB00 	20 3B  0  0 D8 E5 A0  1 
s" create sense-cmd  3 c, 0 c, 0 c, 0 c, ff c, 0 c," eval
1A4CB08 	9C 53 A0  1 30 63 72 65 
1A4CB10 	61 74 65 20 73 65 6E 73 
1A4CB18 	65 2D 63 6D 64 20 20 33 
1A4CB20 	20 63 2C 20 30 20 63 2C 
1A4CB28 	20 30 20 63 2C 20 30 20 
1A4CB30 	63 2C 20 66 66 20 63 2C 
1A4CB38 	20 30 20 63 2C  0  0  0 
1A4CB40 	D8 E5 A0  1 
s" : get-sense" eval  ( -- failed? )     \ Issue REQUEST SENSE
1A4CB44 	9C 53 A0  1 
1A4CB48 	 B 3A 20 67 65 74 2D 73 
1A4CB50 	65 6E 73 65  0  0  0  0 
1A4CB58 	D8 E5 A0  1 
s"    sense-buf ff  true  sense-cmd 6  execute-command" eval  ( actual cswStatus )
1A4CB5C 	9C 53 A0  1 
1A4CB60 	33 20 20 20 73 65 6E 73 
1A4CB68 	65 2D 62 75 66 20 66 66 
1A4CB70 	20 20 74 72 75 65 20 20 
1A4CB78 	73 65 6E 73 65 2D 63 6D 
1A4CB80 	64 20 36 20 20 65 78 65 
1A4CB88 	63 75 74 65 2D 63 6F 6D 
1A4CB90 	6D 61 6E 64  0  0  0  0 
1A4CB98 	D8 E5 A0  1 
s"   if  drop true  else  8 <  then ;" eval
1A4CB9C 	9C 53 A0  1 
1A4CBA0 	22 20 20 69 66 20 20 64 
1A4CBA8 	72 6F 70 20 74 72 75 65 
1A4CBB0 	20 20 65 6C 73 65 20 20 
1A4CBB8 	38 20 3C 20 20 74 68 65 
1A4CBC0 	6E 20 3B  0 D8 E5 A0  1 

\ Give the device a little time to recover before retrying the command.
s" : delay-retry  ( -- )   1 ms  ;" eval
1A4CBC8 	9C 53 A0  1 1F 3A 20 64 
1A4CBD0 	65 6C 61 79 2D 72 65 74 
1A4CBD8 	72 79 20 20 28 20 2D 2D 
1A4CBE0 	20 29 20 20 20 31 20 6D 
1A4CBE8 	73 20 20 3B  0  0  0  0 
1A4CBF0 	D8 E5 A0  1 

\ RETRY-COMMAND executes a SCSI command.  If a check condition is indicated,
\ performs a "get-sense" command.  If the sense bytes indicate a non-fatal
\ condition (e.g. power-on reset occurred, not ready yet, or recoverable
\ error), the command is retried until the condition either goes away or
\ changes to a fatal error.
\
\ The command is retried until:
\ a) The command succeeds, or
\ b) The select fails, or dma fails, or
\ c) The sense bytes indicate an error that we can't retry at this level
\ d) The number of retries is exceeded.

\ #retries is number of times to retry (0: don't retry, -1: retry forever)
\
\ dma-dir is necessary because it is not always possible to infer the DMA
\ direction from the command.

\ Local variables used by retry-command?

s" 0 instance value dbuf" eval             \ Data transfer buffer
1A4CBF4 	9C 53 A0  1 
1A4CBF8 	15 30 20 69 6E 73 74 61 
1A4CC00 	6E 63 65 20 76 61 6C 75 
1A4CC08 	65 20 64 62 75 66  0  0 
1A4CC10 	D8 E5 A0  1 
s" 0 instance value dlen" eval             \ Expected length of data transfer
1A4CC14 	9C 53 A0  1 
1A4CC18 	15 30 20 69 6E 73 74 61 
1A4CC20 	6E 63 65 20 76 61 6C 75 
1A4CC28 	65 20 64 6C 65 6E  0  0 
1A4CC30 	D8 E5 A0  1 
s" 0 instance value direction-in" eval     \ Direction for data transfer
1A4CC34 	9C 53 A0  1 
1A4CC38 	1D 30 20 69 6E 73 74 61 
1A4CC40 	6E 63 65 20 76 61 6C 75 
1A4CC48 	65 20 64 69 72 65 63 74 
1A4CC50 	69 6F 6E 2D 69 6E  0  0 
1A4CC58 	D8 E5 A0  1 
s" -1 instance value cbuf" eval            \ Command base address
1A4CC5C 	9C 53 A0  1 
1A4CC60 	16 2D 31 20 69 6E 73 74 
1A4CC68 	61 6E 63 65 20 76 61 6C 
1A4CC70 	75 65 20 63 62 75 66  0 
1A4CC78 	D8 E5 A0  1 
s"  0 instance value clen" eval            \ Actual length of this command
1A4CC7C 	9C 53 A0  1 
1A4CC80 	16 20 30 20 69 6E 73 74 
1A4CC88 	61 6E 63 65 20 76 61 6C 
1A4CC90 	75 65 20 63 6C 65 6E  0 
1A4CC98 	D8 E5 A0  1 

external
1A4CC9C 	90 B2 A2  1 

\ errcode values:  0: okay   -1: phase error  otherwise: sense-key

s" : retry-command?" eval  ( dma-buf dma-len dma-dir cmdbuf cmdlen #retries -- actual errcode )
1A4CCA0 	9C 53 A0  1 10 3A 20 72 
1A4CCA8 	65 74 72 79 2D 63 6F 6D 
1A4CCB0 	6D 61 6E 64 3F  0  0  0 
1A4CCB8 	D8 E5 A0  1 
s"    to #retries   to clen  to cbuf  to direction-in  to dlen  to dbuf" eval
1A4CCBC 	9C 53 A0  1 
1A4CCC0 	44 20 20 20 74 6F 20 23 
1A4CCC8 	72 65 74 72 69 65 73 20 
1A4CCD0 	20 20 74 6F 20 63 6C 65 
1A4CCD8 	6E 20 20 74 6F 20 63 62 
1A4CCE0 	75 66 20 20 74 6F 20 64 
1A4CCE8 	69 72 65 63 74 69 6F 6E 
1A4CCF0 	2D 69 6E 20 20 74 6F 20 
1A4CCF8 	64 6C 65 6E 20 20 74 6F 
1A4CD00 	20 64 62 75 66  0  0  0 
1A4CD08 	D8 E5 A0  1 
s"    begin" eval
1A4CD0C 	9C 53 A0  1 
1A4CD10 	 8 20 20 20 62 65 67 69 
1A4CD18 	6E  0  0  0 D8 E5 A0  1 
s"       dbuf dlen  direction-in  cbuf clen  execute-command" eval  ( actual cswStatus )
1A4CD20 	9C 53 A0  1 39 20 20 20 
1A4CD28 	20 20 20 64 62 75 66 20 
1A4CD30 	64 6C 65 6E 20 20 64 69 
1A4CD38 	72 65 63 74 69 6F 6E 2D 
1A4CD40 	69 6E 20 20 63 62 75 66 
1A4CD48 	20 63 6C 65 6E 20 20 65 
1A4CD50 	78 65 63 75 74 65 2D 63 
1A4CD58 	6F 6D 6D 61 6E 64  0  0 
1A4CD60 	D8 E5 A0  1 
s"       dup 0=   if  drop  0 exit  then" eval   \ Exit reporting success
1A4CD64 	9C 53 A0  1 
1A4CD68 	25 20 20 20 20 20 20 64 
1A4CD70 	75 70 20 30 3D 20 20 20 
1A4CD78 	69 66 20 20 64 72 6F 70 
1A4CD80 	20 20 30 20 65 78 69 74 
1A4CD88 	20 20 74 68 65 6E  0  0 
1A4CD90 	D8 E5 A0  1 
s"       dup 2 >  if  drop -1 exit  then" eval   \ Exit reporting invalid CSW result code
1A4CD94 	9C 53 A0  1 
1A4CD98 	25 20 20 20 20 20 20 64 
1A4CDA0 	75 70 20 32 20 3E 20 20 
1A4CDA8 	69 66 20 20 64 72 6F 70 
1A4CDB0 	20 2D 31 20 65 78 69 74 
1A4CDB8 	20 20 74 68 65 6E  0  0 
1A4CDC0 	D8 E5 A0  1 

s"      1 =  if" eval                              ( actual )
1A4CDC4 	9C 53 A0  1 
1A4CDC8 	 C 20 20 20 20 20 31 20 
1A4CDD0 	3D 20 20 69 66  0  0  0 
1A4CDD8 	D8 E5 A0  1 
         \ Do gs"et-sense to determine what to do next
s"          get-sense  if" eval                     ( actual )
1A4CDDC 	9C 53 A0  1 
1A4CDE0 	16 20 20 20 20 20 20 20 
1A4CDE8 	20 20 67 65 74 2D 73 65 
1A4CDF0 	6E 73 65 20 20 69 66  0 
1A4CDF8 	D8 E5 A0  1 
            \ Treat a gets"-sense failure like a phase error; just retry the command
s"            -1" eval                             ( actual errcode )
1A4CDFC 	9C 53 A0  1 
1A4CE00 	 D 20 20 20 20 20 20 20 
1A4CE08 	20 20 20 20 2D 31  0  0 
1A4CE10 	D8 E5 A0  1 
s"          else" eval                              ( actual )
1A4CE14 	9C 53 A0  1 
1A4CE18 	 D 20 20 20 20 20 20 20 
1A4CE20 	20 20 65 6C 73 65  0  0 
1A4CE28 	D8 E5 A0  1 
s"            classify-sense  case" eval   ( actual -1|0|1 )
1A4CE2C 	9C 53 A0  1 
1A4CE30 	1F 20 20 20 20 20 20 20 
1A4CE38 	20 20 20 20 63 6C 61 73 
1A4CE40 	73 69 66 79 2D 73 65 6E 
1A4CE48 	73 65 20 20 63 61 73 65 
1A4CE50 	 0  0  0  0 D8 E5 A0  1 
               \ If the sense information says "no sense", return "no-error"
s"               0  of  0 exit  endof" eval
1A4CE58 	9C 53 A0  1 22 20 20 20 
1A4CE60 	20 20 20 20 20 20 20 20 
1A4CE68 	20 20 20 30 20 20 6F 66 
1A4CE70 	20 20 30 20 65 78 69 74 
1A4CE78 	20 20 65 6E 64 6F 66  0 
1A4CE80 	D8 E5 A0  1 

               \ If the error is fatal, return the sense-key
s"                -1  of  sense-buf 2+ c@  exit  endof" eval
1A4CE84 	9C 53 A0  1 
1A4CE88 	33 20 20 20 20 20 20 20 
1A4CE90 	20 20 20 20 20 20 20 20 
1A4CE98 	2D 31 20 20 6F 66 20 20 
1A4CEA0 	73 65 6E 73 65 2D 62 75 
1A4CEA8 	66 20 32 2B 20 63 40 20 
1A4CEB0 	20 65 78 69 74 20 20 65 
1A4CEB8 	6E 64 6F 66  0  0  0  0 
1A4CEC0 	D8 E5 A0  1 
s"             endcase" eval
1A4CEC4 	9C 53 A0  1 
1A4CEC8 	13 20 20 20 20 20 20 20 
1A4CED0 	20 20 20 20 20 65 6E 64 
1A4CED8 	63 61 73 65  0  0  0  0 
1A4CEE0 	D8 E5 A0  1 
s"             sense-buf 2+ c@" eval                ( actual errcode )
1A4CEE4 	9C 53 A0  1 
1A4CEE8 	1B 20 20 20 20 20 20 20 
1A4CEF0 	20 20 20 20 20 73 65 6E 
1A4CEF8 	73 65 2D 62 75 66 20 32 
1A4CF00 	2B 20 63 40  0  0  0  0 
1A4CF08 	D8 E5 A0  1 
s"          then" eval
1A4CF0C 	9C 53 A0  1 
1A4CF10 	 D 20 20 20 20 20 20 20 
1A4CF18 	20 20 74 68 65 6E  0  0 
1A4CF20 	D8 E5 A0  1 
s"       else" eval                                 ( actual )
1A4CF24 	9C 53 A0  1 
1A4CF28 	 A 20 20 20 20 20 20 65 
1A4CF30 	6C 73 65  0 D8 E5 A0  1 
s"          -1" eval     \ Was phase error          ( actual errcode )
1A4CF38 	9C 53 A0  1  B 20 20 20 
1A4CF40 	20 20 20 20 20 20 2D 31 
1A4CF48 	 0  0  0  0 D8 E5 A0  1 
s"       then" eval                                 ( actual errcode )
1A4CF50 	9C 53 A0  1  A 20 20 20 
1A4CF58 	20 20 20 74 68 65 6E  0 
1A4CF60 	D8 E5 A0  1 

      \ If we get here, the command is retryable - either a phase error
      \ or a non-fatal sense code

s"       #retries 1- dup  to #retries" eval         ( actual errcode #retries )
1A4CF64 	9C 53 A0  1 
1A4CF68 	22 20 20 20 20 20 20 23 
1A4CF70 	72 65 74 72 69 65 73 20 
1A4CF78 	31 2D 20 64 75 70 20 20 
1A4CF80 	74 6F 20 23 72 65 74 72 
1A4CF88 	69 65 73  0 D8 E5 A0  1 
s"    while" eval                                   ( actual errcode )
1A4CF90 	9C 53 A0  1  8 20 20 20 
1A4CF98 	77 68 69 6C 65  0  0  0 
1A4CFA0 	D8 E5 A0  1 
s"       2drop" eval                                ( )
1A4CFA4 	9C 53 A0  1 
1A4CFA8 	 B 20 20 20 20 20 20 32 
1A4CFB0 	64 72 6F 70  0  0  0  0 
1A4CFB8 	D8 E5 A0  1 
s"       delay-retry" eval
1A4CFBC 	9C 53 A0  1 
1A4CFC0 	11 20 20 20 20 20 20 64 
1A4CFC8 	65 6C 61 79 2D 72 65 74 
1A4CFD0 	72 79  0  0 D8 E5 A0  1 
s"    repeat ;" eval                                  ( actual errcode )
1A4CFD8 	9C 53 A0  1  B 20 20 20 
1A4CFE0 	72 65 70 65 61 74 20 3B 
1A4CFE8 	 0  0  0  0 D8 E5 A0  1 

\ Simplified routine for commands with no data transfer phase
\ and simple error checking requirements.

s" : no-data-command" eval  ( cmdbuf -- error? )
1A4CFF0 	9C 53 A0  1 11 3A 20 6E 
1A4CFF8 	6F 2D 64 61 74 61 2D 63 
1A4D000 	6F 6D 6D 61 6E 64  0  0 
1A4D008 	D8 E5 A0  1 
s"    >r  0 0 true  r> 6  -1  retry-command?  nip ;" eval
1A4D00C 	9C 53 A0  1 
1A4D010 	30 20 20 20 3E 72 20 20 
1A4D018 	30 20 30 20 74 72 75 65 
1A4D020 	20 20 72 3E 20 36 20 20 
1A4D028 	2D 31 20 20 72 65 74 72 
1A4D030 	79 2D 63 6F 6D 6D 61 6E 
1A4D038 	64 3F 20 20 6E 69 70 20 
1A4D040 	3B  0  0  0 D8 E5 A0  1 

\ short-data-command executes a command with the following characteristics:
\  a) The data direction is incoming
\  b) The data length is less than 256 bytes

\ The host adapter driver is responsible for supplying the DMA data
\ buffer; if the command succeeds, the buffer address is returned.
\ The buffer contents become invalid when another SCSI command is
\ executed, or when the driver is closed.

s" : short-data-command" eval  ( data-len cmdbuf cmdlen #retries -- true | buffer len false )
1A4D048 	9C 53 A0  1 14 3A 20 73 
1A4D050 	68 6F 72 74 2D 64 61 74 
1A4D058 	61 2D 63 6F 6D 6D 61 6E 
1A4D060 	64  0  0  0 D8 E5 A0  1 
s"    >r >r >r  inq-buf swap  true  r> r> r>  retry-command?" eval   ( actual error-code )
1A4D068 	9C 53 A0  1 39 20 20 20 
1A4D070 	3E 72 20 3E 72 20 3E 72 
1A4D078 	20 20 69 6E 71 2D 62 75 
1A4D080 	66 20 73 77 61 70 20 20 
1A4D088 	74 72 75 65 20 20 72 3E 
1A4D090 	20 72 3E 20 72 3E 20 20 
1A4D098 	72 65 74 72 79 2D 63 6F 
1A4D0A0 	6D 6D 61 6E 64 3F  0  0 
1A4D0A8 	D8 E5 A0  1 
s"    if  drop true  else  inq-buf swap false  then ;" eval
1A4D0AC 	9C 53 A0  1 
1A4D0B0 	32 20 20 20 69 66 20 20 
1A4D0B8 	64 72 6F 70 20 74 72 75 
1A4D0C0 	65 20 20 65 6C 73 65 20 
1A4D0C8 	20 69 6E 71 2D 62 75 66 
1A4D0D0 	20 73 77 61 70 20 66 61 
1A4D0D8 	6C 73 65 20 20 74 68 65 
1A4D0E0 	6E 20 3B  0 D8 E5 A0  1 

\ Here begins the implementation of "show-children", a word that
\ is intended to be executed interactively, showing the user the
\ devices that are attached to the SCSI bus.

\ Tool for storing a big-endian 24-bit number at an unaligned address

s" : 3c!  ( n addr -- )  >r lbsplit drop  r@ c!  r@ 1+ c!  r> 2+ c!  ;" eval
1A4D0E8 	9C 53 A0  1 43 3A 20 33 
1A4D0F0 	63 21 20 20 28 20 6E 20 
1A4D0F8 	61 64 64 72 20 2D 2D 20 
1A4D100 	29 20 20 3E 72 20 6C 62 
1A4D108 	73 70 6C 69 74 20 64 72 
1A4D110 	6F 70 20 20 72 40 20 63 
1A4D118 	21 20 20 72 40 20 31 2B 
1A4D120 	20 63 21 20 20 72 3E 20 
1A4D128 	32 2B 20 63 21 20 20 3B 
1A4D130 	 0  0  0  0 D8 E5 A0  1 


\ Command block template for Inquiry command

s" create inquiry-cmd  h# 12 c, 0 c, 0 c, 0 c, ff c, 0 c," eval
1A4D138 	9C 53 A0  1 36 63 72 65 
1A4D140 	61 74 65 20 69 6E 71 75 
1A4D148 	69 72 79 2D 63 6D 64 20 
1A4D150 	20 68 23 20 31 32 20 63 
1A4D158 	2C 20 30 20 63 2C 20 30 
1A4D160 	20 63 2C 20 30 20 63 2C 
1A4D168 	20 66 66 20 63 2C 20 30 
1A4D170 	20 63 2C  0 D8 E5 A0  1 

s" : inquiry" eval  ( -- error? )
1A4D178 	9C 53 A0  1  9 3A 20 69 
1A4D180 	6E 71 75 69 72 79  0  0 
1A4D188 	D8 E5 A0  1 
   \ 8 retries should be more than enough; inquiry commands aren't
   \ supposed to respond with "check condition".
   \ However, empirically, on MC2 EVT1, 8 proves insufficient.

s"    inq-buf ff  true  inquiry-cmd 6  10  retry-command?  nip ;" eval
1A4D18C 	9C 53 A0  1 
1A4D190 	3D 20 20 20 69 6E 71 2D 
1A4D198 	62 75 66 20 66 66 20 20 
1A4D1A0 	74 72 75 65 20 20 69 6E 
1A4D1A8 	71 75 69 72 79 2D 63 6D 
1A4D1B0 	64 20 36 20 20 31 30 20 
1A4D1B8 	20 72 65 74 72 79 2D 63 
1A4D1C0 	6F 6D 6D 61 6E 64 3F 20 
1A4D1C8 	20 6E 69 70 20 3B  0  0 
1A4D1D0 	D8 E5 A0  1 

\ Reads the indicated byte from the Inquiry data buffer

s" : inq@  ( offset -- value )  inq-buf +  c@  ;" eval
1A4D1D4 	9C 53 A0  1 
1A4D1D8 	2D 3A 20 69 6E 71 40 20 
1A4D1E0 	20 28 20 6F 66 66 73 65 
1A4D1E8 	74 20 2D 2D 20 76 61 6C 
1A4D1F0 	75 65 20 29 20 20 69 6E 
1A4D1F8 	71 2D 62 75 66 20 2B 20 
1A4D200 	20 63 40 20 20 3B  0  0 
1A4D208 	D8 E5 A0  1 

s" : .scsi1-inquiry  ( -- )  inq-buf 5 ca+  4 inq@  fa min  type  ;" eval
1A4D20C 	9C 53 A0  1 
1A4D210 	40 3A 20 2E 73 63 73 69 
1A4D218 	31 2D 69 6E 71 75 69 72 
1A4D220 	79 20 20 28 20 2D 2D 20 
1A4D228 	29 20 20 69 6E 71 2D 62 
1A4D230 	75 66 20 35 20 63 61 2B 
1A4D238 	20 20 34 20 69 6E 71 40 
1A4D240 	20 20 66 61 20 6D 69 6E 
1A4D248 	20 20 74 79 70 65 20 20 
1A4D250 	3B  0  0  0 D8 E5 A0  1 
s" : .scsi2-inquiry  ( -- )  inq-buf 8 ca+  d# 28 type    ;" eval
1A4D258 	9C 53 A0  1 38 3A 20 2E 
1A4D260 	73 63 73 69 32 2D 69 6E 
1A4D268 	71 75 69 72 79 20 20 28 
1A4D270 	20 2D 2D 20 29 20 20 69 
1A4D278 	6E 71 2D 62 75 66 20 38 
1A4D280 	20 63 61 2B 20 20 64 23 
1A4D288 	20 32 38 20 74 79 70 65 
1A4D290 	20 20 20 20 3B  0  0  0 
1A4D298 	D8 E5 A0  1 

\ Displays the results of an Inquiry command to the indicated device

s" : show-lun" eval  ( unit -- )
1A4D29C 	9C 53 A0  1 
1A4D2A0 	 A 3A 20 73 68 6F 77 2D 
1A4D2A8 	6C 75 6E  0 D8 E5 A0  1 
s"    dup  set-address" eval                               ( unit )
1A4D2B0 	9C 53 A0  1 13 20 20 20 
1A4D2B8 	64 75 70 20 20 73 65 74 
1A4D2C0 	2D 61 64 64 72 65 73 73 
1A4D2C8 	 0  0  0  0 D8 E5 A0  1 
s"    inquiry  if  drop exit  then" eval                   ( unit )
1A4D2D0 	9C 53 A0  1 1F 20 20 20 
1A4D2D8 	69 6E 71 75 69 72 79 20 
1A4D2E0 	20 69 66 20 20 64 72 6F 
1A4D2E8 	70 20 65 78 69 74 20 20 
1A4D2F0 	74 68 65 6E  0  0  0  0 
1A4D2F8 	D8 E5 A0  1 
s"    0 inq@  h# 60 and  if  drop exit  then" eval         ( unit )
1A4D2FC 	9C 53 A0  1 
1A4D300 	29 20 20 20 30 20 69 6E 
1A4D308 	71 40 20 20 68 23 20 36 
1A4D310 	30 20 61 6E 64 20 20 69 
1A4D318 	66 20 20 64 72 6F 70 20 
1A4D320 	65 78 69 74 20 20 74 68 
1A4D328 	65 6E  0  0 D8 E5 A0  1 
 "    .""   Unit "" . .""   "" " eval                          ( )
1A4D330 	9C 53 A0  1 18 20 20 20 
1A4D338 	2E 22 20 20 20 55 6E 69 
1A4D340 	74 20 22 20 2E 20 2E 22 
1A4D348 	20 20 20 22 20  0  0  0 
1A4D350 	D8 E5 A0  1 
 "    1 inq@  h# 80 and  if  ."" Removable ""  then" eval
1A4D354 	9C 53 A0  1 
1A4D358 	2E 20 20 20 31 20 69 6E 
1A4D360 	71 40 20 20 68 23 20 38 
1A4D368 	30 20 61 6E 64 20 20 69 
1A4D370 	66 20 20 2E 22 20 52 65 
1A4D378 	6D 6F 76 61 62 6C 65 20 
1A4D380 	22 20 20 74 68 65 6E  0 
1A4D388 	D8 E5 A0  1 
s"    0 inq@  case" eval
1A4D38C 	9C 53 A0  1 
1A4D390 	 F 20 20 20 30 20 69 6E 
1A4D398 	71 40 20 20 63 61 73 65 
1A4D3A0 	 0  0  0  0 D8 E5 A0  1 

 "       0 of  ."" Disk ""              endof" eval
1A4D3A8 	9C 53 A0  1 28 20 20 20 
1A4D3B0 	20 20 20 30 20 6F 66 20 
1A4D3B8 	20 2E 22 20 44 69 73 6B 
1A4D3C0 	20 22 20 20 20 20 20 20 
1A4D3C8 	20 20 20 20 20 20 20 20 
1A4D3D0 	65 6E 64 6F 66  0  0  0 
1A4D3D8 	D8 E5 A0  1 
 "       1 of  ."" Tape ""              endof" eval
1A4D3DC 	9C 53 A0  1 
1A4D3E0 	28 20 20 20 20 20 20 31 
1A4D3E8 	20 6F 66 20 20 2E 22 20 
1A4D3F0 	54 61 70 65 20 22 20 20 
1A4D3F8 	20 20 20 20 20 20 20 20 
1A4D400 	20 20 20 20 65 6E 64 6F 
1A4D408 	66  0  0  0 D8 E5 A0  1 
 "       2 of  ."" Printer ""           endof" eval
1A4D410 	9C 53 A0  1 28 20 20 20 
1A4D418 	20 20 20 32 20 6F 66 20 
1A4D420 	20 2E 22 20 50 72 69 6E 
1A4D428 	74 65 72 20 22 20 20 20 
1A4D430 	20 20 20 20 20 20 20 20 
1A4D438 	65 6E 64 6F 66  0  0  0 
1A4D440 	D8 E5 A0  1 
 "       3 of  ."" Processor ""         endof" eval
1A4D444 	9C 53 A0  1 
1A4D448 	28 20 20 20 20 20 20 33 
1A4D450 	20 6F 66 20 20 2E 22 20 
1A4D458 	50 72 6F 63 65 73 73 6F 
1A4D460 	72 20 22 20 20 20 20 20 
1A4D468 	20 20 20 20 65 6E 64 6F 
1A4D470 	66  0  0  0 D8 E5 A0  1 
 "       4 of  ."" WORM ""              endof" eval
1A4D478 	9C 53 A0  1 28 20 20 20 
1A4D480 	20 20 20 34 20 6F 66 20 
1A4D488 	20 2E 22 20 57 4F 52 4D 
1A4D490 	20 22 20 20 20 20 20 20 
1A4D498 	20 20 20 20 20 20 20 20 
1A4D4A0 	65 6E 64 6F 66  0  0  0 
1A4D4A8 	D8 E5 A0  1 
 "       5 of  ."" Read Only device""   endof" eval
1A4D4AC 	9C 53 A0  1 
1A4D4B0 	28 20 20 20 20 20 20 35 
1A4D4B8 	20 6F 66 20 20 2E 22 20 
1A4D4C0 	52 65 61 64 20 4F 6E 6C 
1A4D4C8 	79 20 64 65 76 69 63 65 
1A4D4D0 	22 20 20 20 65 6E 64 6F 
1A4D4D8 	66  0  0  0 D8 E5 A0  1 
 "       ( default ) ."" Device type "" dup .h" eval
1A4D4E0 	9C 53 A0  1 29 20 20 20 
1A4D4E8 	20 20 20 28 20 64 65 66 
1A4D4F0 	61 75 6C 74 20 29 20 2E 
1A4D4F8 	22 20 44 65 76 69 63 65 
1A4D500 	20 74 79 70 65 20 22 20 
1A4D508 	64 75 70 20 2E 68  0  0 
1A4D510 	D8 E5 A0  1 
s"    endcase" eval
1A4D514 	9C 53 A0  1 
1A4D518 	 A 20 20 20 65 6E 64 63 
1A4D520 	61 73 65  0 D8 E5 A0  1 

s"    4 spaces" eval
1A4D528 	9C 53 A0  1  B 20 20 20 
1A4D530 	34 20 73 70 61 63 65 73 
1A4D538 	 0  0  0  0 D8 E5 A0  1 
s"    3 inq@ 0f and  2 =  if  .scsi2-inquiry  else  .scsi1-inquiry  then" eval
1A4D540 	9C 53 A0  1 45 20 20 20 
1A4D548 	33 20 69 6E 71 40 20 30 
1A4D550 	66 20 61 6E 64 20 20 32 
1A4D558 	20 3D 20 20 69 66 20 20 
1A4D560 	2E 73 63 73 69 32 2D 69 
1A4D568 	6E 71 75 69 72 79 20 20 
1A4D570 	65 6C 73 65 20 20 2E 73 
1A4D578 	63 73 69 31 2D 69 6E 71 
1A4D580 	75 69 72 79 20 20 74 68 
1A4D588 	65 6E  0  0 D8 E5 A0  1 
s"    cr ;" eval
1A4D590 	9C 53 A0  1  7 20 20 20 
1A4D598 	63 72 20 3B  0  0  0  0 
1A4D5A0 	D8 E5 A0  1 

\ Searches for devices on the SCSI bus, displaying the Inquiry information
\ for each device that responds.

s" : show-children" eval  ( -- )
1A4D5A4 	9C 53 A0  1 
1A4D5A8 	 F 3A 20 73 68 6F 77 2D 
1A4D5B0 	63 68 69 6C 64 72 65 6E 
1A4D5B8 	 0  0  0  0 D8 E5 A0  1 
 "    open  0=  if  ."" Can't open SCSI host adapter"" cr  exit  then" eval
1A4D5C0 	9C 53 A0  1 40 20 20 20 
1A4D5C8 	6F 70 65 6E 20 20 30 3D 
1A4D5D0 	20 20 69 66 20 20 2E 22 
1A4D5D8 	20 43 61 6E 27 74 20 6F 
1A4D5E0 	70 65 6E 20 53 43 53 49 
1A4D5E8 	20 68 6F 73 74 20 61 64 
1A4D5F0 	61 70 74 65 72 22 20 63 
1A4D5F8 	72 20 20 65 78 69 74 20 
1A4D600 	20 74 68 65 6E  0  0  0 
1A4D608 	D8 E5 A0  1 
s"    max-lun 1+ 0  do  i show-lun  loop" eval
1A4D60C 	9C 53 A0  1 
1A4D610 	25 20 20 20 6D 61 78 2D 
1A4D618 	6C 75 6E 20 31 2B 20 30 
1A4D620 	20 20 64 6F 20 20 69 20 
1A4D628 	73 68 6F 77 2D 6C 75 6E 
1A4D630 	20 20 6C 6F 6F 70  0  0 
1A4D638 	D8 E5 A0  1 
s"    close ;" eval
1A4D63C 	9C 53 A0  1 
1A4D640 	 A 20 20 20 63 6C 6F 73 
1A4D648 	65 20 3B  0 D8 E5 A0  1 

\ Inquire into the specified scsi device type and return the scsi
\ type and true if the device at the specified scsi address is found.

s" : get-scsi-type" eval  ( lun -- false | type true )
1A4D650 	9C 53 A0  1  F 3A 20 67 
1A4D658 	65 74 2D 73 63 73 69 2D 
1A4D660 	74 79 70 65  0  0  0  0 
1A4D668 	D8 E5 A0  1 
s"    open  0=  if  2drop false exit  then" eval
1A4D66C 	9C 53 A0  1 
1A4D670 	27 20 20 20 6F 70 65 6E 
1A4D678 	20 20 30 3D 20 20 69 66 
1A4D680 	20 20 32 64 72 6F 70 20 
1A4D688 	66 61 6C 73 65 20 65 78 
1A4D690 	69 74 20 20 74 68 65 6E 
1A4D698 	 0  0  0  0 D8 E5 A0  1 
s"    set-address inquiry" eval
1A4D6A0 	9C 53 A0  1 16 20 20 20 
1A4D6A8 	73 65 74 2D 61 64 64 72 
1A4D6B0 	65 73 73 20 69 6E 71 75 
1A4D6B8 	69 72 79  0 D8 E5 A0  1 
s"    if  false  else  0 inq@ dup 7f =  if  drop false  else  true  then  then" eval
1A4D6C0 	9C 53 A0  1 4B 20 20 20 
1A4D6C8 	69 66 20 20 66 61 6C 73 
1A4D6D0 	65 20 20 65 6C 73 65 20 
1A4D6D8 	20 30 20 69 6E 71 40 20 
1A4D6E0 	64 75 70 20 37 66 20 3D 
1A4D6E8 	20 20 69 66 20 20 64 72 
1A4D6F0 	6F 70 20 66 61 6C 73 65 
1A4D6F8 	20 20 65 6C 73 65 20 20 
1A4D700 	74 72 75 65 20 20 74 68 
1A4D708 	65 6E 20 20 74 68 65 6E 
1A4D710 	 0  0  0  0 D8 E5 A0  1 
s"   close ;" eval
1A4D718 	9C 53 A0  1  9 20 20 63 
1A4D720 	6C 6F 73 65 20 3B  0  0 
1A4D728 	D8 E5 A0  1 

\ The diagnose command is useful for generic SCSI devices.
\ It executes both the "test-unit-ready" and "send-diagnostic"
\ commands, decoding the error status information they return.

s" create test-unit-rdy-cmd        0 c, 0 c, 0 c, 0 c, 0 c, 0 c," eval
1A4D72C 	9C 53 A0  1 
1A4D730 	3D 63 72 65 61 74 65 20 
1A4D738 	74 65 73 74 2D 75 6E 69 
1A4D740 	74 2D 72 64 79 2D 63 6D 
1A4D748 	64 20 20 20 20 20 20 20 
1A4D750 	20 30 20 63 2C 20 30 20 
1A4D758 	63 2C 20 30 20 63 2C 20 
1A4D760 	30 20 63 2C 20 30 20 63 
1A4D768 	2C 20 30 20 63 2C  0  0 
1A4D770 	D8 E5 A0  1 
s" create send-diagnostic-cmd  h# 1d c, 4 c, 0 c, 0 c, 0 c, 0 c," eval
1A4D774 	9C 53 A0  1 
1A4D778 	3D 63 72 65 61 74 65 20 
1A4D780 	73 65 6E 64 2D 64 69 61 
1A4D788 	67 6E 6F 73 74 69 63 2D 
1A4D790 	63 6D 64 20 20 68 23 20 
1A4D798 	31 64 20 63 2C 20 34 20 
1A4D7A0 	63 2C 20 30 20 63 2C 20 
1A4D7A8 	30 20 63 2C 20 30 20 63 
1A4D7B0 	2C 20 30 20 63 2C  0  0 
1A4D7B8 	D8 E5 A0  1 
s" : send-diagnostic ( -- error? )  send-diagnostic-cmd  no-data-command  ;" eval
1A4D7BC 	9C 53 A0  1 
1A4D7C0 	48 3A 20 73 65 6E 64 2D 
1A4D7C8 	64 69 61 67 6E 6F 73 74 
1A4D7D0 	69 63 20 28 20 2D 2D 20 
1A4D7D8 	65 72 72 6F 72 3F 20 29 
1A4D7E0 	20 20 73 65 6E 64 2D 64 
1A4D7E8 	69 61 67 6E 6F 73 74 69 
1A4D7F0 	63 2D 63 6D 64 20 20 6E 
1A4D7F8 	6F 2D 64 61 74 61 2D 63 
1A4D800 	6F 6D 6D 61 6E 64 20 20 
1A4D808 	3B  0  0  0 D8 E5 A0  1 
s" : diagnose" eval  ( -- flag )
1A4D810 	9C 53 A0  1  A 3A 20 64 
1A4D818 	69 61 67 6E 6F 73 65  0 
1A4D820 	D8 E5 A0  1 
s"    0 0 true  test-unit-rdy-cmd 6   -1 " eval  ( dma$ dir cmd$ #retries )
1A4D824 	9C 53 A0  1 
1A4D828 	26 20 20 20 30 20 30 20 
1A4D830 	74 72 75 65 20 20 74 65 
1A4D838 	73 74 2D 75 6E 69 74 2D 
1A4D840 	72 64 79 2D 63 6D 64 20 
1A4D848 	36 20 20 20 2D 31 20  0 
1A4D850 	D8 E5 A0  1 
s"    retry-command?  ?dup  if " eval  ( actual error-code )
1A4D854 	9C 53 A0  1 
1A4D858 	1C 20 20 20 72 65 74 72 
1A4D860 	79 2D 63 6F 6D 6D 61 6E 
1A4D868 	64 3F 20 20 3F 64 75 70 
1A4D870 	20 20 69 66 20  0  0  0 
1A4D878 	D8 E5 A0  1 
s"       nip " eval  ( error-code )
1A4D87C 	9C 53 A0  1 
1A4D880 	 A 20 20 20 20 20 20 6E 
1A4D888 	69 70 20  0 D8 E5 A0  1 
 "       ."" Test unit ready failed - "" " eval    ( error-code )
1A4D890 	9C 53 A0  1 24 20 20 20 
1A4D898 	20 20 20 2E 22 20 54 65 
1A4D8A0 	73 74 20 75 6E 69 74 20 
1A4D8A8 	72 65 61 64 79 20 66 61 
1A4D8B0 	69 6C 65 64 20 2D 20 22 
1A4D8B8 	20  0  0  0 D8 E5 A0  1 
s"       dup -1  if " eval   ( error-code )
1A4D8C0 	9C 53 A0  1 11 20 20 20 
1A4D8C8 	20 20 20 64 75 70 20 2D 
1A4D8D0 	31 20 20 69 66 20  0  0 
1A4D8D8 	D8 E5 A0  1 
 "          ."" phase error "" . cr" eval     ( )
1A4D8DC 	9C 53 A0  1 
1A4D8E0 	1E 20 20 20 20 20 20 20 
1A4D8E8 	20 20 2E 22 20 70 68 61 
1A4D8F0 	73 65 20 65 72 72 6F 72 
1A4D8F8 	20 22 20 2E 20 63 72  0 
1A4D900 	D8 E5 A0  1 
s"       else" eval   ( error-code )
1A4D904 	9C 53 A0  1 
1A4D908 	 A 20 20 20 20 20 20 65 
1A4D910 	6C 73 65  0 D8 E5 A0  1 
 "          ."" Sense code "" . " eval
1A4D918 	9C 53 A0  1 1B 20 20 20 
1A4D920 	20 20 20 20 20 20 2E 22 
1A4D928 	20 53 65 6E 73 65 20 63 
1A4D930 	6F 64 65 20 22 20 2E 20 
1A4D938 	 0  0  0  0 D8 E5 A0  1 
 "          ."" extended status = "" cr " eval
1A4D940 	9C 53 A0  1 23 20 20 20 
1A4D948 	20 20 20 20 20 20 2E 22 
1A4D950 	20 65 78 74 65 6E 64 65 
1A4D958 	64 20 73 74 61 74 75 73 
1A4D960 	20 3D 20 22 20 63 72 20 
1A4D968 	 0  0  0  0 D8 E5 A0  1 
s"          base @ >r  hex " eval
1A4D970 	9C 53 A0  1 18 20 20 20 
1A4D978 	20 20 20 20 20 20 62 61 
1A4D980 	73 65 20 40 20 3E 72 20 
1A4D988 	20 68 65 78 20  0  0  0 
1A4D990 	D8 E5 A0  1 
s"          sense-buf 8 bounds ?do  i 3 u.r  loop cr " eval
1A4D994 	9C 53 A0  1 
1A4D998 	32 20 20 20 20 20 20 20 
1A4D9A0 	20 20 73 65 6E 73 65 2D 
1A4D9A8 	62 75 66 20 38 20 62 6F 
1A4D9B0 	75 6E 64 73 20 3F 64 6F 
1A4D9B8 	20 20 69 20 33 20 75 2E 
1A4D9C0 	72 20 20 6C 6F 6F 70 20 
1A4D9C8 	63 72 20  0 D8 E5 A0  1 
s"          r> base !" eval
1A4D9D0 	9C 53 A0  1 12 20 20 20 
1A4D9D8 	20 20 20 20 20 20 72 3E 
1A4D9E0 	20 62 61 73 65 20 21  0 
1A4D9E8 	D8 E5 A0  1 
s"       then" eval
1A4D9EC 	9C 53 A0  1 
1A4D9F0 	 A 20 20 20 20 20 20 74 
1A4D9F8 	68 65 6E  0 D8 E5 A0  1 
s"       true" eval
1A4DA00 	9C 53 A0  1  A 20 20 20 
1A4DA08 	20 20 20 74 72 75 65  0 
1A4DA10 	D8 E5 A0  1 
s"    else " eval                 ( actual )
1A4DA14 	9C 53 A0  1 
1A4DA18 	 8 20 20 20 65 6C 73 65 
1A4DA20 	20  0  0  0 D8 E5 A0  1 
s"       drop" eval                 ( )
1A4DA28 	9C 53 A0  1  A 20 20 20 
1A4DA30 	20 20 20 64 72 6F 70  0 
1A4DA38 	D8 E5 A0  1 
s"       send-diagnostic" eval                 ( fail? )
1A4DA3C 	9C 53 A0  1 
1A4DA40 	15 20 20 20 20 20 20 73 
1A4DA48 	65 6E 64 2D 64 69 61 67 
1A4DA50 	6E 6F 73 74 69 63  0  0 
1A4DA58 	D8 E5 A0  1 
s"    then ; " eval
1A4DA5C 	9C 53 A0  1 
1A4DA60 	 A 20 20 20 74 68 65 6E 
1A4DA68 	20 3B 20  0 D8 E5 A0  1 
;
1A4DA70 	58 46 A0  1 

headers


OpenFirmware/dev/usb2/device/storage/hacom.fth_AL	158C 1A4DA74 purpose: SCSI disk package implementing a "block" device-type interface.


: scsidiskfth 
1A4DA74 	73 63 73 69 
1A4DA78 	64 69 73 6B 66 74 68 8B 
1A4DA80 	F8 C4 A4  1 20 40 A0  1 
hex
1A4DA88 	C0 8D A0  1 

" block" device-type
1A4DA8C 	9C 53 A0  1 
1A4DA90 	 5 62 6C 6F 63 6B  0  0 
1A4DA98 	B8 49 A2  1 
" disk"  encode-string  " compatible" property
1A4DA9C 	9C 53 A0  1 
1A4DAA0 	 4 64 69 73 6B  0  0  0 
1A4DAA8 	A0 F6 A1  1 9C 53 A0  1 
1A4DAB0 	 A 63 6F 6D 70 61 74 69 
1A4DAB8 	62 6C 65  0 BC 14 A2  1 
" usbdisk" " iconname" string-property
1A4DAC0 	9C 53 A0  1  7 75 73 62 
1A4DAC8 	64 69 73 6B  0  0  0  0 
1A4DAD0 	9C 53 A0  1  8 69 63 6F 
1A4DAD8 	6E 6E 61 6D 65  0  0  0 
1A4DAE0 	C8 48 A2  1 

scsicomfth \ fload d:include\dev\usbm\device\storage\scsicom.fth	\ Utility routines for SCSI commands
1A4DAE4 	84 A7 A4  1 

hex
1A4DAE8 	C0 8D A0  1 

\ 0 means no timeout
 " : set-timeout  ( msecs -- )  "" set-timeout"" $call-parent  ;" eval
1A4DAEC 	9C 53 A0  1 
1A4DAF0 	3B 3A 20 73 65 74 2D 74 
1A4DAF8 	69 6D 65 6F 75 74 20 20 
1A4DB00 	28 20 6D 73 65 63 73 20 
1A4DB08 	2D 2D 20 29 20 20 22 20 
1A4DB10 	73 65 74 2D 74 69 6D 65 
1A4DB18 	6F 75 74 22 20 24 63 61 
1A4DB20 	6C 6C 2D 70 61 72 65 6E 
1A4DB28 	74 20 20 3B  0  0  0  0 
1A4DB30 	D8 E5 A0  1 

s" 0 instance value offset-low" eval     \ Offset to start of partition
1A4DB34 	9C 53 A0  1 
1A4DB38 	1B 30 20 69 6E 73 74 61 
1A4DB40 	6E 63 65 20 76 61 6C 75 
1A4DB48 	65 20 6F 66 66 73 65 74 
1A4DB50 	2D 6C 6F 77  0  0  0  0 
1A4DB58 	D8 E5 A0  1 
s" 0 instance value offset-high" eval
1A4DB5C 	9C 53 A0  1 
1A4DB60 	1C 30 20 69 6E 73 74 61 
1A4DB68 	6E 63 65 20 76 61 6C 75 
1A4DB70 	65 20 6F 66 66 73 65 74 
1A4DB78 	2D 68 69 67 68  0  0  0 
1A4DB80 	D8 E5 A0  1 

external
1A4DB84 	90 B2 A2  1 
s" 0 instance value label-package" eval
1A4DB88 	9C 53 A0  1 1E 30 20 69 
1A4DB90 	6E 73 74 61 6E 63 65 20 
1A4DB98 	76 61 6C 75 65 20 6C 61 
1A4DBA0 	62 65 6C 2D 70 61 63 6B 
1A4DBA8 	61 67 65  0 D8 E5 A0  1 
s" true value report-failure" eval
1A4DBB0 	9C 53 A0  1 19 74 72 75 
1A4DBB8 	65 20 76 61 6C 75 65 20 
1A4DBC0 	72 65 70 6F 72 74 2D 66 
1A4DBC8 	61 69 6C 75 72 65  0  0 
1A4DBD0 	D8 E5 A0  1 
headers
1A4DBD4 	74 25 A3  1 

\ Sets offset-low and offset-high, reflecting the starting location of the
\ partition specified by the "my-args" string.

s" : init-label-package" eval  ( -- okay? )
1A4DBD8 	9C 53 A0  1 14 3A 20 69 
1A4DBE0 	6E 69 74 2D 6C 61 62 65 
1A4DBE8 	6C 2D 70 61 63 6B 61 67 
1A4DBF0 	65  0  0  0 D8 E5 A0  1 
s"    0 to offset-high  0 to offset-low" eval
1A4DBF8 	9C 53 A0  1 24 20 20 20 
1A4DC00 	30 20 74 6F 20 6F 66 66 
1A4DC08 	73 65 74 2D 68 69 67 68 
1A4DC10 	20 20 30 20 74 6F 20 6F 
1A4DC18 	66 66 73 65 74 2D 6C 6F 
1A4DC20 	77  0  0  0 D8 E5 A0  1 
 "    my-args  "" disk-label""  $open-package to label-package" eval
1A4DC28 	9C 53 A0  1 39 20 20 20 
1A4DC30 	6D 79 2D 61 72 67 73 20 
1A4DC38 	20 22 20 64 69 73 6B 2D 
1A4DC40 	6C 61 62 65 6C 22 20 20 
1A4DC48 	24 6F 70 65 6E 2D 70 61 
1A4DC50 	63 6B 61 67 65 20 74 6F 
1A4DC58 	20 6C 61 62 65 6C 2D 70 
1A4DC60 	61 63 6B 61 67 65  0  0 
1A4DC68 	D8 E5 A0  1 
s"    label-package dup  if" eval
1A4DC6C 	9C 53 A0  1 
1A4DC70 	18 20 20 20 6C 61 62 65 
1A4DC78 	6C 2D 70 61 63 6B 61 67 
1A4DC80 	65 20 64 75 70 20 20 69 
1A4DC88 	66  0  0  0 D8 E5 A0  1 
 "       0 0  "" offset"" label-package $call-method to offset-high to offset-low" eval
1A4DC90 	9C 53 A0  1 4C 20 20 20 
1A4DC98 	20 20 20 30 20 30 20 20 
1A4DCA0 	22 20 6F 66 66 73 65 74 
1A4DCA8 	22 20 6C 61 62 65 6C 2D 
1A4DCB0 	70 61 63 6B 61 67 65 20 
1A4DCB8 	24 63 61 6C 6C 2D 6D 65 
1A4DCC0 	74 68 6F 64 20 74 6F 20 
1A4DCC8 	6F 66 66 73 65 74 2D 68 
1A4DCD0 	69 67 68 20 74 6F 20 6F 
1A4DCD8 	66 66 73 65 74 2D 6C 6F 
1A4DCE0 	77  0  0  0 D8 E5 A0  1 
s"    else" eval
1A4DCE8 	9C 53 A0  1  7 20 20 20 
1A4DCF0 	65 6C 73 65  0  0  0  0 
1A4DCF8 	D8 E5 A0  1 
s"       report-failure  if" eval
1A4DCFC 	9C 53 A0  1 
1A4DD00 	18 20 20 20 20 20 20 72 
1A4DD08 	65 70 6F 72 74 2D 66 61 
1A4DD10 	69 6C 75 72 65 20 20 69 
1A4DD18 	66  0  0  0 D8 E5 A0  1 
 "          ."" Can't open disk label package""  cr" eval
1A4DD20 	9C 53 A0  1 2E 20 20 20 
1A4DD28 	20 20 20 20 20 20 2E 22 
1A4DD30 	20 43 61 6E 27 74 20 6F 
1A4DD38 	70 65 6E 20 64 69 73 6B 
1A4DD40 	20 6C 61 62 65 6C 20 70 
1A4DD48 	61 63 6B 61 67 65 22 20 
1A4DD50 	20 63 72  0 D8 E5 A0  1 
s"       then" eval
1A4DD58 	9C 53 A0  1  A 20 20 20 
1A4DD60 	20 20 20 74 68 65 6E  0 
1A4DD68 	D8 E5 A0  1 
s"    then ;" eval
1A4DD6C 	9C 53 A0  1 
1A4DD70 	 9 20 20 20 74 68 65 6E 
1A4DD78 	20 3B  0  0 D8 E5 A0  1 

\ Checks to see if a device is ready

s" : unit-ready?" eval  ( -- ready? )
1A4DD80 	9C 53 A0  1  D 3A 20 75 
1A4DD88 	6E 69 74 2D 72 65 61 64 
1A4DD90 	79 3F  0  0 D8 E5 A0  1 
 "    "" ""(00 00 00 00 00 00)"" drop  no-data-command  0= ;" eval
1A4DD98 	9C 53 A0  1 36 20 20 20 
1A4DDA0 	22 20 22 28 30 30 20 30 
1A4DDA8 	30 20 30 30 20 30 30 20 
1A4DDB0 	30 30 20 30 30 29 22 20 
1A4DDB8 	64 72 6F 70 20 20 6E 6F 
1A4DDC0 	2D 64 61 74 61 2D 63 6F 
1A4DDC8 	6D 6D 61 6E 64 20 20 30 
1A4DDD0 	3D 20 3B  0 D8 E5 A0  1 

\ Some devices require a second TEST UNIT READY, despite returning
\ CHECK CONDITION, with sense NOT READY and MEDIUM NOT PRESENT.

s" : retry-unit-ready?" eval  ( -- ready? )
1A4DDD8 	9C 53 A0  1 13 3A 20 72 
1A4DDE0 	65 74 72 79 2D 75 6E 69 
1A4DDE8 	74 2D 72 65 61 64 79 3F 
1A4DDF0 	 0  0  0  0 D8 E5 A0  1 
s"    unit-ready?  ?dup  if  exit  then" eval
1A4DDF8 	9C 53 A0  1 24 20 20 20 
1A4DE00 	75 6E 69 74 2D 72 65 61 
1A4DE08 	64 79 3F 20 20 3F 64 75 
1A4DE10 	70 20 20 69 66 20 20 65 
1A4DE18 	78 69 74 20 20 74 68 65 
1A4DE20 	6E  0  0  0 D8 E5 A0  1 
s"    unit-ready? ;" eval
1A4DE28 	9C 53 A0  1 10 20 20 20 
1A4DE30 	75 6E 69 74 2D 72 65 61 
1A4DE38 	64 79 3F 20 3B  0  0  0 
1A4DE40 	D8 E5 A0  1 

\ Ensures that the disk is spinning, but doesn't wait forever

s" create sstart-cmd  h# 1b c, 0 c, 0 c, 0 c, 1 c, 0 c," eval
1A4DE44 	9C 53 A0  1 
1A4DE48 	34 63 72 65 61 74 65 20 
1A4DE50 	73 73 74 61 72 74 2D 63 
1A4DE58 	6D 64 20 20 68 23 20 31 
1A4DE60 	62 20 63 2C 20 30 20 63 
1A4DE68 	2C 20 30 20 63 2C 20 30 
1A4DE70 	20 63 2C 20 31 20 63 2C 
1A4DE78 	20 30 20 63 2C  0  0  0 
1A4DE80 	D8 E5 A0  1 

s" : timed-spin" eval  ( -- error? )
1A4DE84 	9C 53 A0  1 
1A4DE88 	 C 3A 20 74 69 6D 65 64 
1A4DE90 	2D 73 70 69 6E  0  0  0 
1A4DE98 	D8 E5 A0  1 
s"    0 0 true  sstart-cmd 6  -1 retry-command?  nip  ?dup  if" eval  ( error-code )
1A4DE9C 	9C 53 A0  1 
1A4DEA0 	3B 20 20 20 30 20 30 20 
1A4DEA8 	74 72 75 65 20 20 73 73 
1A4DEB0 	74 61 72 74 2D 63 6D 64 
1A4DEB8 	20 36 20 20 2D 31 20 72 
1A4DEC0 	65 74 72 79 2D 63 6F 6D 
1A4DEC8 	6D 61 6E 64 3F 20 20 6E 
1A4DED0 	69 70 20 20 3F 64 75 70 
1A4DED8 	20 20 69 66  0  0  0  0 
1A4DEE0 	D8 E5 A0  1 
      \ true on top of the stack indicates a hardware error.
      \ We don't treat "illegal request" as an error because some drives
      \ don't support the start command.  Everything else other than
      \ success is considered an error.
s"       5 <>" eval                                       ( error? )
1A4DEE4 	9C 53 A0  1 
1A4DEE8 	 A 20 20 20 20 20 20 35 
1A4DEF0 	20 3C 3E  0 D8 E5 A0  1 
s"    else      false" eval                                      ( false )
1A4DEF8 	9C 53 A0  1 12 20 20 20 
1A4DF00 	65 6C 73 65 20 20 20 20 
1A4DF08 	20 20 66 61 6C 73 65  0 
1A4DF10 	D8 E5 A0  1 
s"    then" eval                                          ( error? )
1A4DF14 	9C 53 A0  1 
1A4DF18 	 7 20 20 20 74 68 65 6E 
1A4DF20 	 0  0  0  0 D8 E5 A0  1 
s"    0 set-timeout ;" eval
1A4DF28 	9C 53 A0  1 12 20 20 20 
1A4DF30 	30 20 73 65 74 2D 74 69 
1A4DF38 	6D 65 6F 75 74 20 3B  0 
1A4DF40 	D8 E5 A0  1 

s" create read-capacity-cmd h# 25 c, 0 c, 0 c, 0 c, 0 c, 0 c, 0 c, 0 c, 0 c, 0 c," eval
1A4DF44 	9C 53 A0  1 
1A4DF48 	4E 63 72 65 61 74 65 20 
1A4DF50 	72 65 61 64 2D 63 61 70 
1A4DF58 	61 63 69 74 79 2D 63 6D 
1A4DF60 	64 20 68 23 20 32 35 20 
1A4DF68 	63 2C 20 30 20 63 2C 20 
1A4DF70 	30 20 63 2C 20 30 20 63 
1A4DF78 	2C 20 30 20 63 2C 20 30 
1A4DF80 	20 63 2C 20 30 20 63 2C 
1A4DF88 	20 30 20 63 2C 20 30 20 
1A4DF90 	63 2C 20 30 20 63 2C  0 
1A4DF98 	D8 E5 A0  1 

s" : get-capacity" eval  ( -- false | block-size #blocks false true )
1A4DF9C 	9C 53 A0  1 
1A4DFA0 	 E 3A 20 67 65 74 2D 63 
1A4DFA8 	61 70 61 63 69 74 79  0 
1A4DFB0 	D8 E5 A0  1 
s"    8  read-capacity-cmd 0a  0  short-data-command  if  false" eval
1A4DFB4 	9C 53 A0  1 
1A4DFB8 	3C 20 20 20 38 20 20 72 
1A4DFC0 	65 61 64 2D 63 61 70 61 
1A4DFC8 	63 69 74 79 2D 63 6D 64 
1A4DFD0 	20 30 61 20 20 30 20 20 
1A4DFD8 	73 68 6F 72 74 2D 64 61 
1A4DFE0 	74 61 2D 63 6F 6D 6D 61 
1A4DFE8 	6E 64 20 20 69 66 20 20 
1A4DFF0 	66 61 6C 73 65  0  0  0 
1A4DFF8 	D8 E5 A0  1 
s"    else" eval                                        ( adr len )
1A4DFFC 	9C 53 A0  1 
1A4E000 	 7 20 20 20 65 6C 73 65 
1A4E008 	 0  0  0  0 D8 E5 A0  1 
s"       8 <>  if  drop false exit  then" eval          ( adr )
1A4E010 	9C 53 A0  1 25 20 20 20 
1A4E018 	20 20 20 38 20 3C 3E 20 
1A4E020 	20 69 66 20 20 64 72 6F 
1A4E028 	70 20 66 61 6C 73 65 20 
1A4E030 	65 78 69 74 20 20 74 68 
1A4E038 	65 6E  0  0 D8 E5 A0  1 
s"       dup 4 + 4c@  swap 4c@  1+  false true" eval
1A4E040 	9C 53 A0  1 2B 20 20 20 
1A4E048 	20 20 20 64 75 70 20 34 
1A4E050 	20 2B 20 34 63 40 20 20 
1A4E058 	73 77 61 70 20 34 63 40 
1A4E060 	20 20 31 2B 20 20 66 61 
1A4E068 	6C 73 65 20 74 72 75 65 
1A4E070 	 0  0  0  0 D8 E5 A0  1 
s"    then ;" eval
1A4E078 	9C 53 A0  1  9 20 20 20 
1A4E080 	74 68 65 6E 20 3B  0  0 
1A4E088 	D8 E5 A0  1 

s" notdef" $find ?dup
1A4E08C 	9C 53 A0  1 
1A4E090 	 6 6E 6F 74 64 65 66  0 
1A4E098 	C4 93 A0  1 B4 70 A0  1 
if
1A4E0A0 	DC 41 A0  1 CC  0  0  0 
\ This is a "read for nothing", discarding the result.  It's a
\ workaround for a problem with the "Silicon Motion SMI331" controller
\ as used in the "Transcend TS2GUSD-S3" USB / MicroSD reader.  That
\ device stalls "read capacity" commands until you do the first block
\ read. The first block read stalls too, but afterwards everything works. 
s" : nonce-read" eval  ( -- )
1A4E0A8 	9C 53 A0  1  C 3A 20 6E 
1A4E0B0 	6F 6E 63 65 2D 72 65 61 
1A4E0B8 	64  0  0  0 D8 E5 A0  1 
s"    d# 512 dma-alloc  >r" eval
1A4E0C0 	9C 53 A0  1 17 20 20 20 
1A4E0C8 	64 23 20 35 31 32 20 64 
1A4E0D0 	6D 61 2D 61 6C 6C 6F 63 
1A4E0D8 	20 20 3E 72  0  0  0  0 
1A4E0E0 	D8 E5 A0  1 
 "    r@ d# 512 true  "" ""(28 00 00 00 00 00 00 00 01 00)"" " eval ( data$ in? cmd$ )
1A4E0E4 	9C 53 A0  1 
1A4E0E8 	37 20 20 20 72 40 20 64 
1A4E0F0 	23 20 35 31 32 20 74 72 
1A4E0F8 	75 65 20 20 22 20 22 28 
1A4E100 	32 38 20 30 30 20 30 30 
1A4E108 	20 30 30 20 30 30 20 30 
1A4E110 	30 20 30 30 20 30 30 20 
1A4E118 	30 31 20 30 30 29 22 20 
1A4E120 	 0  0  0  0 D8 E5 A0  1 
s"    0  retry-command? 2drop" eval
1A4E128 	9C 53 A0  1 1A 20 20 20 
1A4E130 	30 20 20 72 65 74 72 79 
1A4E138 	2D 63 6F 6D 6D 61 6E 64 
1A4E140 	3F 20 32 64 72 6F 70  0 
1A4E148 	D8 E5 A0  1 
s"    r> d# 512 dma-free ;" eval
1A4E14C 	9C 53 A0  1 
1A4E150 	17 20 20 20 72 3E 20 64 
1A4E158 	23 20 35 31 32 20 64 6D 
1A4E160 	61 2D 66 72 65 65 20 3B 
1A4E168 	 0  0  0  0 D8 E5 A0  1 
then 2drop
1A4E170 	AC 49 A0  1 

s" : read-block-extent" eval  ( -- true | block-size #blocks false )
1A4E174 	9C 53 A0  1 
1A4E178 	13 3A 20 72 65 61 64 2D 
1A4E180 	62 6C 6F 63 6B 2D 65 78 
1A4E188 	74 65 6E 74  0  0  0  0 
1A4E190 	D8 E5 A0  1 
   \ Try "read capacity" a few times.  Support for that command is
   \ mandatory, but some devices aren't ready for it immediately.
s"    d# 20  0  do" eval
1A4E194 	9C 53 A0  1 
1A4E198 	 F 20 20 20 64 23 20 32 
1A4E1A0 	30 20 20 30 20 20 64 6F 
1A4E1A8 	 0  0  0  0 D8 E5 A0  1 
s"       get-capacity  if  unloop exit  then" eval  ( )
1A4E1B0 	9C 53 A0  1 29 20 20 20 
1A4E1B8 	20 20 20 67 65 74 2D 63 
1A4E1C0 	61 70 61 63 69 74 79 20 
1A4E1C8 	20 69 66 20 20 75 6E 6C 
1A4E1D0 	6F 6F 70 20 65 78 69 74 
1A4E1D8 	20 20 74 68 65 6E  0  0 
1A4E1E0 	D8 E5 A0  1 
s"       d# 200 ms" eval
1A4E1E4 	9C 53 A0  1 
1A4E1E8 	 F 20 20 20 20 20 20 64 
1A4E1F0 	23 20 32 30 30 20 6D 73 
1A4E1F8 	 0  0  0  0 D8 E5 A0  1 
s"    loop" eval
1A4E200 	9C 53 A0  1  7 20 20 20 
1A4E208 	6C 6F 6F 70  0  0  0  0 
1A4E210 	D8 E5 A0  1 

s" notdef" $find ?dup
1A4E214 	9C 53 A0  1 
1A4E218 	 6 6E 6F 74 64 65 66  0 
1A4E220 	C4 93 A0  1 B4 70 A0  1 
if
1A4E228 	DC 41 A0  1 9C  0  0  0 
   \ At least one device stalls read-capacity until the first block read
s"    nonce-read" eval
1A4E230 	9C 53 A0  1  D 20 20 20 
1A4E238 	6E 6F 6E 63 65 2D 72 65 
1A4E240 	61 64  0  0 D8 E5 A0  1 

   \ Retry it a few more times
s"    d# 18  0  do" eval
1A4E248 	9C 53 A0  1  F 20 20 20 
1A4E250 	64 23 20 31 38 20 20 30 
1A4E258 	20 20 64 6F  0  0  0  0 
1A4E260 	D8 E5 A0  1 
s"       get-capacity  if  unloop exit  then" eval
1A4E264 	9C 53 A0  1 
1A4E268 	29 20 20 20 20 20 20 67 
1A4E270 	65 74 2D 63 61 70 61 63 
1A4E278 	69 74 79 20 20 69 66 20 
1A4E280 	20 75 6E 6C 6F 6F 70 20 
1A4E288 	65 78 69 74 20 20 74 68 
1A4E290 	65 6E  0  0 D8 E5 A0  1 
s"       d# 200 ms" eval
1A4E298 	9C 53 A0  1  F 20 20 20 
1A4E2A0 	20 20 20 64 23 20 32 30 
1A4E2A8 	30 20 6D 73  0  0  0  0 
1A4E2B0 	D8 E5 A0  1 
s"    loop" eval
1A4E2B4 	9C 53 A0  1 
1A4E2B8 	 7 20 20 20 6C 6F 6F 70 
1A4E2C0 	 0  0  0  0 D8 E5 A0  1 
then 2drop
1A4E2C8 	AC 49 A0  1 

   \ If it fails, we just guess.  Some devices violate the spec and
   \ fail to implement read_capacity
s"    d# 512  h# ffffffff  false ;" eval
1A4E2CC 	9C 53 A0  1 
1A4E2D0 	1F 20 20 20 64 23 20 35 
1A4E2D8 	31 32 20 20 68 23 20 66 
1A4E2E0 	66 66 66 66 66 66 66 20 
1A4E2E8 	20 66 61 6C 73 65 20 3B 
1A4E2F0 	 0  0  0  0 D8 E5 A0  1 

s" report-geometry" $find ?dup
1A4E2F8 	9C 53 A0  1  F 72 65 70 
1A4E300 	6F 72 74 2D 67 65 6F 6D 
1A4E308 	65 74 72 79  0  0  0  0 
1A4E310 	C4 93 A0  1 B4 70 A0  1 
if
1A4E318 	DC 41 A0  1 8C  1  0  0 
s" create mode-sense-geometry    h# 1a c, 0 c, 4 c, 0 c, d# 36 c, 0 c," eval
1A4E320 	9C 53 A0  1 43 63 72 65 
1A4E328 	61 74 65 20 6D 6F 64 65 
1A4E330 	2D 73 65 6E 73 65 2D 67 
1A4E338 	65 6F 6D 65 74 72 79 20 
1A4E340 	20 20 20 68 23 20 31 61 
1A4E348 	20 63 2C 20 30 20 63 2C 
1A4E350 	20 34 20 63 2C 20 30 20 
1A4E358 	63 2C 20 64 23 20 33 36 
1A4E360 	20 63 2C 20 30 20 63 2C 
1A4E368 	 0  0  0  0 D8 E5 A0  1 

\ The sector/track value reported below is an average, because modern SCSI
\ disks often have variable geometry - fewer sectors on the inner cylinders
\ and spare sectors and tracks located at various places on the disk.
\ If you multiply the sectors/track number obtained from the format info
\ mode sense code page by the heads and cylinders obtained from the geometry
\ page, the number of blocks thus calculated usually exceeds the number of
\ logical blocks reported in the mode sense block descriptor, often by a
\ factor of about 25%.

\ Return true for error, otherwise disk geometry and false
s" : geometry" eval  ( -- true | sectors/track #heads #cylinders false )
1A4E370 	9C 53 A0  1  A 3A 20 67 
1A4E378 	65 6F 6D 65 74 72 79  0 
1A4E380 	D8 E5 A0  1 
s"    d# 36  mode-sense-geometry  6  2" eval  ( len cmd$ #retries )
1A4E384 	9C 53 A0  1 
1A4E388 	23 20 20 20 64 23 20 33 
1A4E390 	36 20 20 6D 6F 64 65 2D 
1A4E398 	73 65 6E 73 65 2D 67 65 
1A4E3A0 	6F 6D 65 74 72 79 20 20 
1A4E3A8 	36 20 20 32  0  0  0  0 
1A4E3B0 	D8 E5 A0  1 
s"    short-data-command  if  true exit  then" eval   ( adr len )
1A4E3B4 	9C 53 A0  1 
1A4E3B8 	2A 20 20 20 73 68 6F 72 
1A4E3C0 	74 2D 64 61 74 61 2D 63 
1A4E3C8 	6F 6D 6D 61 6E 64 20 20 
1A4E3D0 	69 66 20 20 74 72 75 65 
1A4E3D8 	20 65 78 69 74 20 20 74 
1A4E3E0 	68 65 6E  0 D8 E5 A0  1 
s"    d# 36 <>  if  drop true exit  then" eval        ( adr )
1A4E3E8 	9C 53 A0  1 25 20 20 20 
1A4E3F0 	64 23 20 33 36 20 3C 3E 
1A4E3F8 	20 20 69 66 20 20 64 72 
1A4E400 	6F 70 20 74 72 75 65 20 
1A4E408 	65 78 69 74 20 20 74 68 
1A4E410 	65 6E  0  0 D8 E5 A0  1 
s"    >r" eval                                ( r: adr )
1A4E418 	9C 53 A0  1  5 20 20 20 
1A4E420 	3E 72  0  0 D8 E5 A0  1 
s"    r@ d# 17 + c@   r@ d# 14 + 3c@" eval   ( heads cylinders )
1A4E428 	9C 53 A0  1 21 20 20 20 
1A4E430 	72 40 20 64 23 20 31 37 
1A4E438 	20 2B 20 63 40 20 20 20 
1A4E440 	72 40 20 64 23 20 31 34 
1A4E448 	20 2B 20 33 63 40  0  0 
1A4E450 	D8 E5 A0  1 
s"    2dup *  r> d# 4 + 4c@" eval             ( heads cylinders heads*cylinders #blocks )
1A4E454 	9C 53 A0  1 
1A4E458 	18 20 20 20 32 64 75 70 
1A4E460 	20 2A 20 20 72 3E 20 64 
1A4E468 	23 20 34 20 2B 20 34 63 
1A4E470 	40  0  0  0 D8 E5 A0  1 
s"    swap /  -rot" eval                      ( sectors/track heads cylinders )
1A4E478 	9C 53 A0  1  F 20 20 20 
1A4E480 	73 77 61 70 20 2F 20 20 
1A4E488 	2D 72 6F 74  0  0  0  0 
1A4E490 	D8 E5 A0  1 
s"    false ;" eval
1A4E494 	9C 53 A0  1 
1A4E498 	 A 20 20 20 66 61 6C 73 
1A4E4A0 	65 20 3B  0 D8 E5 A0  1 
then 2drop
1A4E4A8 	AC 49 A0  1 

\ This method is called by the deblocker

s" 0 value #blocks" eval
1A4E4AC 	9C 53 A0  1 
1A4E4B0 	 F 30 20 76 61 6C 75 65 
1A4E4B8 	20 23 62 6C 6F 63 6B 73 
1A4E4C0 	 0  0  0  0 D8 E5 A0  1 
s" 0 value block-size" eval
1A4E4C8 	9C 53 A0  1 12 30 20 76 
1A4E4D0 	61 6C 75 65 20 62 6C 6F 
1A4E4D8 	63 6B 2D 73 69 7A 65  0 
1A4E4E0 	D8 E5 A0  1 

headers
1A4E4E4 	74 25 A3  1 

\ Read or write "#blks" blocks starting at "block#" into memory at "addr"
\ Input? is true for reading or false for writing.
\ command is  8  for reading or  h# a  for writing
\ We use the 6-byte forms of the disk read and write commands where possible.

s" : 2c!  ( n addr -- )  >r lbsplit 2drop  r> +c!         c!  ;" eval
1A4E4E8 	9C 53 A0  1 3C 3A 20 32 
1A4E4F0 	63 21 20 20 28 20 6E 20 
1A4E4F8 	61 64 64 72 20 2D 2D 20 
1A4E500 	29 20 20 3E 72 20 6C 62 
1A4E508 	73 70 6C 69 74 20 32 64 
1A4E510 	72 6F 70 20 20 72 3E 20 
1A4E518 	2B 63 21 20 20 20 20 20 
1A4E520 	20 20 20 20 63 21 20 20 
1A4E528 	3B  0  0  0 D8 E5 A0  1 
s" : 4c!  ( n addr -- )  >r lbsplit        r> +c! +c! +c! c!  ;" eval
1A4E530 	9C 53 A0  1 3C 3A 20 34 
1A4E538 	63 21 20 20 28 20 6E 20 
1A4E540 	61 64 64 72 20 2D 2D 20 
1A4E548 	29 20 20 3E 72 20 6C 62 
1A4E550 	73 70 6C 69 74 20 20 20 
1A4E558 	20 20 20 20 20 72 3E 20 
1A4E560 	2B 63 21 20 2B 63 21 20 
1A4E568 	2B 63 21 20 63 21 20 20 
1A4E570 	3B  0  0  0 D8 E5 A0  1 

s" : r/w-blocks" eval  ( addr block# #blks input? command -- actual# )
1A4E578 	9C 53 A0  1  C 3A 20 72 
1A4E580 	2F 77 2D 62 6C 6F 63 6B 
1A4E588 	73  0  0  0 D8 E5 A0  1 
s"    cmdbuf /cmdbuf erase" eval
1A4E590 	9C 53 A0  1 17 20 20 20 
1A4E598 	63 6D 64 62 75 66 20 2F 
1A4E5A0 	63 6D 64 62 75 66 20 65 
1A4E5A8 	72 61 73 65  0  0  0  0 
1A4E5B0 	D8 E5 A0  1 
s" use-short-form" $find ?dup
1A4E5B4 	9C 53 A0  1 
1A4E5B8 	 E 75 73 65 2D 73 68 6F 
1A4E5C0 	72 74 2D 66 6F 72 6D  0 
1A4E5C8 	C4 93 A0  1 B4 70 A0  1 
if
1A4E5D0 	DC 41 A0  1 40  0  0  0 
s"    2over  h# 100 u>  swap h# 200000 u>=  or  if" eval  ( addr block# #blks dir cmd )
1A4E5D8 	9C 53 A0  1 2F 20 20 20 
1A4E5E0 	32 6F 76 65 72 20 20 68 
1A4E5E8 	23 20 31 30 30 20 75 3E 
1A4E5F0 	20 20 73 77 61 70 20 68 
1A4E5F8 	23 20 32 30 30 30 30 30 
1A4E600 	20 75 3E 3D 20 20 6F 72 
1A4E608 	20 20 69 66  0  0  0  0 
1A4E610 	D8 E5 A0  1 
then 2drop
1A4E614 	AC 49 A0  1 
      \ Use 10-byte form
s"       h# 20 or  0 cb!" eval  \ 28 (read) or 2a (write)  ( addr block# #blks dir )
1A4E618 	9C 53 A0  1 15 20 20 20 
1A4E620 	20 20 20 68 23 20 32 30 
1A4E628 	20 6F 72 20 20 30 20 63 
1A4E630 	62 21  0  0 D8 E5 A0  1 
s"       -rot swap" eval                                   ( addr dir #blks block# )
1A4E638 	9C 53 A0  1  F 20 20 20 
1A4E640 	20 20 20 2D 72 6F 74 20 
1A4E648 	73 77 61 70  0  0  0  0 
1A4E650 	D8 E5 A0  1 
s"       cmdbuf 2 + 4c!" eval                              ( addr dir #blks )
1A4E654 	9C 53 A0  1 
1A4E658 	14 20 20 20 20 20 20 63 
1A4E660 	6D 64 62 75 66 20 32 20 
1A4E668 	2B 20 34 63 21  0  0  0 
1A4E670 	D8 E5 A0  1 
s"       dup cmdbuf 7 + 2c!" eval                          ( addr dir #blks )
1A4E674 	9C 53 A0  1 
1A4E678 	18 20 20 20 20 20 20 64 
1A4E680 	75 70 20 63 6D 64 62 75 
1A4E688 	66 20 37 20 2B 20 32 63 
1A4E690 	21  0  0  0 D8 E5 A0  1 
s"       d# 10" eval                                       ( addr dir #blks cmdlen )
1A4E698 	9C 53 A0  1  B 20 20 20 
1A4E6A0 	20 20 20 64 23 20 31 30 
1A4E6A8 	 0  0  0  0 D8 E5 A0  1 
s" use-short-form" $find ?dup
1A4E6B0 	9C 53 A0  1  E 75 73 65 
1A4E6B8 	2D 73 68 6F 72 74 2D 66 
1A4E6C0 	6F 72 6D  0 C4 93 A0  1 
1A4E6C8 	B4 70 A0  1 
if
1A4E6CC 	DC 41 A0  1 
1A4E6D0 	B0  0  0  0 
s"    else" eval                                           ( addr block# #blks dir cmd )
1A4E6D4 	9C 53 A0  1 
1A4E6D8 	 7 20 20 20 65 6C 73 65 
1A4E6E0 	 0  0  0  0 D8 E5 A0  1 
      \ Use 6-byte form
s"       0 cb!" eval                                       ( addr block# #blks dir )
1A4E6E8 	9C 53 A0  1  B 20 20 20 
1A4E6F0 	20 20 20 30 20 63 62 21 
1A4E6F8 	 0  0  0  0 D8 E5 A0  1 
s"       -rot swap" eval                                   ( addr dir #blks block# )
1A4E700 	9C 53 A0  1  F 20 20 20 
1A4E708 	20 20 20 2D 72 6F 74 20 
1A4E710 	73 77 61 70  0  0  0  0 
1A4E718 	D8 E5 A0  1 
s"       cmdbuf 1+ 3c!" eval                               ( addr dir #blks )
1A4E71C 	9C 53 A0  1 
1A4E720 	13 20 20 20 20 20 20 63 
1A4E728 	6D 64 62 75 66 20 31 2B 
1A4E730 	20 33 63 21  0  0  0  0 
1A4E738 	D8 E5 A0  1 
s"       dup 4 cb!" eval                                   ( addr dir #blks )
1A4E73C 	9C 53 A0  1 
1A4E740 	 F 20 20 20 20 20 20 64 
1A4E748 	75 70 20 34 20 63 62 21 
1A4E750 	 0  0  0  0 D8 E5 A0  1 
s"       6" eval                                           ( addr dir #blks cmdlen )
1A4E758 	9C 53 A0  1  7 20 20 20 
1A4E760 	20 20 20 36  0  0  0  0 
1A4E768 	D8 E5 A0  1 
s"    then" eval
1A4E76C 	9C 53 A0  1 
1A4E770 	 7 20 20 20 74 68 65 6E 
1A4E778 	 0  0  0  0 D8 E5 A0  1 
then 2drop
1A4E780 	AC 49 A0  1 
s"    swap" eval                                           ( addr dir cmdlen #blks )
1A4E784 	9C 53 A0  1 
1A4E788 	 7 20 20 20 73 77 61 70 
1A4E790 	 0  0  0  0 D8 E5 A0  1 
s"    dup >r" eval                                         ( addr input? cmdlen #blks )
1A4E798 	9C 53 A0  1  9 20 20 20 
1A4E7A0 	64 75 70 20 3E 72  0  0 
1A4E7A8 	D8 E5 A0  1 
s"    block-size *  -rot  cmdbuf swap  -1" eval  ( data-adr,len in? cmd-adr,len #retries )
1A4E7AC 	9C 53 A0  1 
1A4E7B0 	26 20 20 20 62 6C 6F 63 
1A4E7B8 	6B 2D 73 69 7A 65 20 2A 
1A4E7C0 	20 20 2D 72 6F 74 20 20 
1A4E7C8 	63 6D 64 62 75 66 20 73 
1A4E7D0 	77 61 70 20 20 2D 31  0 
1A4E7D8 	D8 E5 A0  1 
s"    retry-command?  nip  if" eval                        ( r: #blks )
1A4E7DC 	9C 53 A0  1 
1A4E7E0 	1A 20 20 20 72 65 74 72 
1A4E7E8 	79 2D 63 6F 6D 6D 61 6E 
1A4E7F0 	64 3F 20 20 6E 69 70 20 
1A4E7F8 	20 69 66  0 D8 E5 A0  1 
s"       r> drop 0" eval
1A4E800 	9C 53 A0  1  F 20 20 20 
1A4E808 	20 20 20 72 3E 20 64 72 
1A4E810 	6F 70 20 30  0  0  0  0 
1A4E818 	D8 E5 A0  1 
s"    else" eval
1A4E81C 	9C 53 A0  1 
1A4E820 	 7 20 20 20 65 6C 73 65 
1A4E828 	 0  0  0  0 D8 E5 A0  1 
s"       r>" eval
1A4E830 	9C 53 A0  1  8 20 20 20 
1A4E838 	20 20 20 72 3E  0  0  0 
1A4E840 	D8 E5 A0  1 
s"    then ;" eval   ( actual# )
1A4E844 	9C 53 A0  1 
1A4E848 	 9 20 20 20 74 68 65 6E 
1A4E850 	20 3B  0  0 D8 E5 A0  1 

\ These three methods are called by the deblocker.

s" : max-transfer  ( -- n )   parent-max-transfer  ;" eval
1A4E858 	9C 53 A0  1 31 3A 20 6D 
1A4E860 	61 78 2D 74 72 61 6E 73 
1A4E868 	66 65 72 20 20 28 20 2D 
1A4E870 	2D 20 6E 20 29 20 20 20 
1A4E878 	70 61 72 65 6E 74 2D 6D 
1A4E880 	61 78 2D 74 72 61 6E 73 
1A4E888 	66 65 72 20 20 3B  0  0 
1A4E890 	D8 E5 A0  1 
s" : read-blocks   ( addr block# #blocks -- #read )   true  d# 8  r/w-blocks  ;" eval
1A4E894 	9C 53 A0  1 
1A4E898 	4C 3A 20 72 65 61 64 2D 
1A4E8A0 	62 6C 6F 63 6B 73 20 20 
1A4E8A8 	20 28 20 61 64 64 72 20 
1A4E8B0 	62 6C 6F 63 6B 23 20 23 
1A4E8B8 	62 6C 6F 63 6B 73 20 2D 
1A4E8C0 	2D 20 23 72 65 61 64 20 
1A4E8C8 	29 20 20 20 74 72 75 65 
1A4E8D0 	20 20 64 23 20 38 20 20 
1A4E8D8 	72 2F 77 2D 62 6C 6F 63 
1A4E8E0 	6B 73 20 20 3B  0  0  0 
1A4E8E8 	D8 E5 A0  1 
s" : write-blocks  ( addr block# #blocks -- #written )  false d# 10 r/w-blocks  ;" eval
1A4E8EC 	9C 53 A0  1 
1A4E8F0 	4E 3A 20 77 72 69 74 65 
1A4E8F8 	2D 62 6C 6F 63 6B 73 20 
1A4E900 	20 28 20 61 64 64 72 20 
1A4E908 	62 6C 6F 63 6B 23 20 23 
1A4E910 	62 6C 6F 63 6B 73 20 2D 
1A4E918 	2D 20 23 77 72 69 74 74 
1A4E920 	65 6E 20 29 20 20 66 61 
1A4E928 	6C 73 65 20 64 23 20 31 
1A4E930 	30 20 72 2F 77 2D 62 6C 
1A4E938 	6F 63 6B 73 20 20 3B  0 
1A4E940 	D8 E5 A0  1 

\ Methods used by external clients

s" 0 value open-count" eval
1A4E944 	9C 53 A0  1 
1A4E948 	12 30 20 76 61 6C 75 65 
1A4E950 	20 6F 70 65 6E 2D 63 6F 
1A4E958 	75 6E 74  0 D8 E5 A0  1 

s" : open" eval  ( -- flag )
1A4E960 	9C 53 A0  1  6 3A 20 6F 
1A4E968 	70 65 6E  0 D8 E5 A0  1 
s"    my-unit parent-set-address" eval
1A4E970 	9C 53 A0  1 1D 20 20 20 
1A4E978 	6D 79 2D 75 6E 69 74 20 
1A4E980 	70 61 72 65 6E 74 2D 73 
1A4E988 	65 74 2D 61 64 64 72 65 
1A4E990 	73 73  0  0 D8 E5 A0  1 
s"    open-count  if" eval
1A4E998 	9C 53 A0  1 11 20 20 20 
1A4E9A0 	6F 70 65 6E 2D 63 6F 75 
1A4E9A8 	6E 74 20 20 69 66  0  0 
1A4E9B0 	D8 E5 A0  1 
s"       d# 2000 set-timeout" eval
1A4E9B4 	9C 53 A0  1 
1A4E9B8 	19 20 20 20 20 20 20 64 
1A4E9C0 	23 20 32 30 30 30 20 73 
1A4E9C8 	65 74 2D 74 69 6D 65 6F 
1A4E9D0 	75 74  0  0 D8 E5 A0  1 
s"    else" eval
1A4E9D8 	9C 53 A0  1  7 20 20 20 
1A4E9E0 	65 6C 73 65  0  0  0  0 
1A4E9E8 	D8 E5 A0  1 

      \ Set timeout to 45 sec: some large (>1GB) drives take
      \ up to 30 secs to spin up.
s"       d# 45 d# 1000 *  set-timeout" eval
1A4E9EC 	9C 53 A0  1 
1A4E9F0 	22 20 20 20 20 20 20 64 
1A4E9F8 	23 20 34 35 20 64 23 20 
1A4EA00 	31 30 30 30 20 2A 20 20 
1A4EA08 	73 65 74 2D 74 69 6D 65 
1A4EA10 	6F 75 74  0 D8 E5 A0  1 

s"       retry-unit-ready?  0=  if  false  exit  then" eval
1A4EA18 	9C 53 A0  1 32 20 20 20 
1A4EA20 	20 20 20 72 65 74 72 79 
1A4EA28 	2D 75 6E 69 74 2D 72 65 
1A4EA30 	61 64 79 3F 20 20 30 3D 
1A4EA38 	20 20 69 66 20 20 66 61 
1A4EA40 	6C 73 65 20 20 65 78 69 
1A4EA48 	74 20 20 74 68 65 6E  0 
1A4EA50 	D8 E5 A0  1 

      \ It might be a good idea to do an inquiry here to determine the
      \ device configuration, checking the result to see if the device
      \ really is a disk.

      \ Make sure the disk is spinning

s"       timed-spin  if  false exit  then" eval
1A4EA54 	9C 53 A0  1 
1A4EA58 	26 20 20 20 20 20 20 74 
1A4EA60 	69 6D 65 64 2D 73 70 69 
1A4EA68 	6E 20 20 69 66 20 20 66 
1A4EA70 	61 6C 73 65 20 65 78 69 
1A4EA78 	74 20 20 74 68 65 6E  0 
1A4EA80 	D8 E5 A0  1 

s"       read-block-extent  if  false exit  then" eval  ( block-size #blocks )
1A4EA84 	9C 53 A0  1 
1A4EA88 	2D 20 20 20 20 20 20 72 
1A4EA90 	65 61 64 2D 62 6C 6F 63 
1A4EA98 	6B 2D 65 78 74 65 6E 74 
1A4EAA0 	20 20 69 66 20 20 66 61 
1A4EAA8 	6C 73 65 20 65 78 69 74 
1A4EAB0 	20 20 74 68 65 6E  0  0 
1A4EAB8 	D8 E5 A0  1 
s"       to #blocks  to block-size" eval
1A4EABC 	9C 53 A0  1 
1A4EAC0 	1F 20 20 20 20 20 20 74 
1A4EAC8 	6F 20 23 62 6C 6F 63 6B 
1A4EAD0 	73 20 20 74 6F 20 62 6C 
1A4EAD8 	6F 63 6B 2D 73 69 7A 65 
1A4EAE0 	 0  0  0  0 D8 E5 A0  1 

s"       d# 2000 set-timeout" eval
1A4EAE8 	9C 53 A0  1 19 20 20 20 
1A4EAF0 	20 20 20 64 23 20 32 30 
1A4EAF8 	30 30 20 73 65 74 2D 74 
1A4EB00 	69 6D 65 6F 75 74  0  0 
1A4EB08 	D8 E5 A0  1 
s"       init-deblocker  0=  if  false exit  then" eval
1A4EB0C 	9C 53 A0  1 
1A4EB10 	2E 20 20 20 20 20 20 69 
1A4EB18 	6E 69 74 2D 64 65 62 6C 
1A4EB20 	6F 63 6B 65 72 20 20 30 
1A4EB28 	3D 20 20 69 66 20 20 66 
1A4EB30 	61 6C 73 65 20 65 78 69 
1A4EB38 	74 20 20 74 68 65 6E  0 
1A4EB40 	D8 E5 A0  1 
s"    then" eval
1A4EB44 	9C 53 A0  1 
1A4EB48 	 7 20 20 20 74 68 65 6E 
1A4EB50 	 0  0  0  0 D8 E5 A0  1 

s"    init-label-package  0=  if" eval
1A4EB58 	9C 53 A0  1 1D 20 20 20 
1A4EB60 	69 6E 69 74 2D 6C 61 62 
1A4EB68 	65 6C 2D 70 61 63 6B 61 
1A4EB70 	67 65 20 20 30 3D 20 20 
1A4EB78 	69 66  0  0 D8 E5 A0  1 
s"       open-count 0=  if" eval
1A4EB80 	9C 53 A0  1 17 20 20 20 
1A4EB88 	20 20 20 6F 70 65 6E 2D 
1A4EB90 	63 6F 75 6E 74 20 30 3D 
1A4EB98 	20 20 69 66  0  0  0  0 
1A4EBA0 	D8 E5 A0  1 
s"          deblocker close-package" eval
1A4EBA4 	9C 53 A0  1 
1A4EBA8 	20 20 20 20 20 20 20 20 
1A4EBB0 	20 20 64 65 62 6C 6F 63 
1A4EBB8 	6B 65 72 20 63 6C 6F 73 
1A4EBC0 	65 2D 70 61 63 6B 61 67 
1A4EBC8 	65  0  0  0 D8 E5 A0  1 
s"       then" eval
1A4EBD0 	9C 53 A0  1  A 20 20 20 
1A4EBD8 	20 20 20 74 68 65 6E  0 
1A4EBE0 	D8 E5 A0  1 
s"       false exit" eval
1A4EBE4 	9C 53 A0  1 
1A4EBE8 	10 20 20 20 20 20 20 66 
1A4EBF0 	61 6C 73 65 20 65 78 69 
1A4EBF8 	74  0  0  0 D8 E5 A0  1 
s"    then" eval
1A4EC00 	9C 53 A0  1  7 20 20 20 
1A4EC08 	74 68 65 6E  0  0  0  0 
1A4EC10 	D8 E5 A0  1 
s"    open-count 1+ to open-count" eval
1A4EC14 	9C 53 A0  1 
1A4EC18 	1E 20 20 20 6F 70 65 6E 
1A4EC20 	2D 63 6F 75 6E 74 20 31 
1A4EC28 	2B 20 74 6F 20 6F 70 65 
1A4EC30 	6E 2D 63 6F 75 6E 74  0 
1A4EC38 	D8 E5 A0  1 

s"    true ;" eval
1A4EC3C 	9C 53 A0  1 
1A4EC40 	 9 20 20 20 74 72 75 65 
1A4EC48 	20 3B  0  0 D8 E5 A0  1 
s" : close" eval  ( -- )
1A4EC50 	9C 53 A0  1  7 3A 20 63 
1A4EC58 	6C 6F 73 65  0  0  0  0 
1A4EC60 	D8 E5 A0  1 
s"    open-count dup  1- 0 max to open-count" eval  ( old-open-count )
1A4EC64 	9C 53 A0  1 
1A4EC68 	29 20 20 20 6F 70 65 6E 
1A4EC70 	2D 63 6F 75 6E 74 20 64 
1A4EC78 	75 70 20 20 31 2D 20 30 
1A4EC80 	20 6D 61 78 20 74 6F 20 
1A4EC88 	6F 70 65 6E 2D 63 6F 75 
1A4EC90 	6E 74  0  0 D8 E5 A0  1 
s"    label-package close-package" eval             ( old-open-count )
1A4EC98 	9C 53 A0  1 1E 20 20 20 
1A4ECA0 	6C 61 62 65 6C 2D 70 61 
1A4ECA8 	63 6B 61 67 65 20 63 6C 
1A4ECB0 	6F 73 65 2D 70 61 63 6B 
1A4ECB8 	61 67 65  0 D8 E5 A0  1 
s"    1 =  if" eval
1A4ECC0 	9C 53 A0  1  A 20 20 20 
1A4ECC8 	31 20 3D 20 20 69 66  0 
1A4ECD0 	D8 E5 A0  1 
s"       deblocker close-package" eval
1A4ECD4 	9C 53 A0  1 
1A4ECD8 	1D 20 20 20 20 20 20 64 
1A4ECE0 	65 62 6C 6F 63 6B 65 72 
1A4ECE8 	20 63 6C 6F 73 65 2D 70 
1A4ECF0 	61 63 6B 61 67 65  0  0 
1A4ECF8 	D8 E5 A0  1 
s"    then ;" eval
1A4ECFC 	9C 53 A0  1 
1A4ED00 	 9 20 20 20 74 68 65 6E 
1A4ED08 	20 3B  0  0 D8 E5 A0  1 

s" : seek" eval  ( offset.low offset.high -- okay? )
1A4ED10 	9C 53 A0  1  6 3A 20 73 
1A4ED18 	65 65 6B  0 D8 E5 A0  1 
 "    offset-low offset-high d+  "" seek""   deblocker $call-method ;" eval
1A4ED20 	9C 53 A0  1 40 20 20 20 
1A4ED28 	6F 66 66 73 65 74 2D 6C 
1A4ED30 	6F 77 20 6F 66 66 73 65 
1A4ED38 	74 2D 68 69 67 68 20 64 
1A4ED40 	2B 20 20 22 20 73 65 65 
1A4ED48 	6B 22 20 20 20 64 65 62 
1A4ED50 	6C 6F 63 6B 65 72 20 24 
1A4ED58 	63 61 6C 6C 2D 6D 65 74 
1A4ED60 	68 6F 64 20 3B  0  0  0 
1A4ED68 	D8 E5 A0  1 

 " : read  ( addr len -- actual-len )  "" read""  deblocker $call-method  ;" eval
1A4ED6C 	9C 53 A0  1 
1A4ED70 	46 3A 20 72 65 61 64 20 
1A4ED78 	20 28 20 61 64 64 72 20 
1A4ED80 	6C 65 6E 20 2D 2D 20 61 
1A4ED88 	63 74 75 61 6C 2D 6C 65 
1A4ED90 	6E 20 29 20 20 22 20 72 
1A4ED98 	65 61 64 22 20 20 64 65 
1A4EDA0 	62 6C 6F 63 6B 65 72 20 
1A4EDA8 	24 63 61 6C 6C 2D 6D 65 
1A4EDB0 	74 68 6F 64 20 20 3B  0 
1A4EDB8 	D8 E5 A0  1 
 " : write ( addr len -- actual-len )  "" write"" deblocker $call-method  ;" eval
1A4EDBC 	9C 53 A0  1 
1A4EDC0 	46 3A 20 77 72 69 74 65 
1A4EDC8 	20 28 20 61 64 64 72 20 
1A4EDD0 	6C 65 6E 20 2D 2D 20 61 
1A4EDD8 	63 74 75 61 6C 2D 6C 65 
1A4EDE0 	6E 20 29 20 20 22 20 77 
1A4EDE8 	72 69 74 65 22 20 64 65 
1A4EDF0 	62 6C 6F 63 6B 65 72 20 
1A4EDF8 	24 63 61 6C 6C 2D 6D 65 
1A4EE00 	74 68 6F 64 20 20 3B  0 
1A4EE08 	D8 E5 A0  1 
 " : load  ( addr -- size )            "" load""  label-package $call-method  ;" eval
1A4EE0C 	9C 53 A0  1 
1A4EE10 	4A 3A 20 6C 6F 61 64 20 
1A4EE18 	20 28 20 61 64 64 72 20 
1A4EE20 	2D 2D 20 73 69 7A 65 20 
1A4EE28 	29 20 20 20 20 20 20 20 
1A4EE30 	20 20 20 20 20 22 20 6C 
1A4EE38 	6F 61 64 22 20 20 6C 61 
1A4EE40 	62 65 6C 2D 70 61 63 6B 
1A4EE48 	61 67 65 20 24 63 61 6C 
1A4EE50 	6C 2D 6D 65 74 68 6F 64 
1A4EE58 	20 20 3B  0 D8 E5 A0  1 
 " : size  ( -- d.size )  "" size"" label-package $call-method  ;" eval
1A4EE60 	9C 53 A0  1 3C 3A 20 73 
1A4EE68 	69 7A 65 20 20 28 20 2D 
1A4EE70 	2D 20 64 2E 73 69 7A 65 
1A4EE78 	20 29 20 20 22 20 73 69 
1A4EE80 	7A 65 22 20 6C 61 62 65 
1A4EE88 	6C 2D 70 61 63 6B 61 67 
1A4EE90 	65 20 24 63 61 6C 6C 2D 
1A4EE98 	6D 65 74 68 6F 64 20 20 
1A4EEA0 	3B  0  0  0 D8 E5 A0  1 
;
1A4EEA8 	58 46 A0  1 

OpenFirmware/dev/usb2/device/storage/scsidisk.fth_AL	1438 1A4EEAC 
: init-lists Context: <NONAME>:5D8A18  FORTH FORTH <NONAME>:5D88B8  root 
Current: <NONAME>:5D8A18 

; init-lists purpose: Data structures and manuipulation routines for UHCI USB Controller

\ XXX Isochronous is not supported in the current version of the UHCI driver

\ ---------------------------------------------------------------------------
\ Data structures for this implementation of the UHCI USB Driver include:
\   - frame-list (an array of 1024 entries of TD/QH pointers, physical)
\   - intr-qh (a queue head for interrupt transactions)
\   - low-qh (a queue head for control & bulk transactions for low-speed devices)
\   - full-qh (a queue head for control & bulk transactions for high-speed devices)
\ ---------------------------------------------------------------------------

hex
headers

\ Constants common to most UHCI data structures
1 constant TERMINATE
1A4EEAC 	 0  0 74 65 
1A4EEB0 	72 6D 69 6E 61 74 65 89 
1A4EEB8 	 0  0 A0  1 68 40 A0  1 
1A4EEC0 	 1  0  0  0 

0 constant TYP_TD
1A4EEC4 	 0 74 79 70 
1A4EEC8 	5F 74 64 86 BC EE A4  1 
1A4EED0 	68 40 A0  1  0  0  0  0 
2 constant TYP_QH
1A4EED8 	 0 74 79 70 5F 71 68 86 
1A4EEE0 	D0 EE A4  1 68 40 A0  1 
1A4EEE8 	 2  0  0  0 

\ ---------------------------------------------------------------------------
\ Frame List as defined by the UHCI Spec; 4-KB aligned
\
\ Each entry is composed of:  bit 0     TERMINATE
\                             bit 1     1=QH, 0=TD
\                             bits 31:4	Frame List Pointer
\ ---------------------------------------------------------------------------

h# 1000 constant /align4kb
1A4EEEC 	 0  0 2F 61 
1A4EEF0 	6C 69 67 6E 34 6B 62 89 
1A4EEF8 	E4 EE A4  1 68 40 A0  1 
1A4EF00 	 0 10  0  0 

d# 1024 dup constant #framelist			\ # of entries in framelist
1A4EF04 	 0 23 66 72 
1A4EF08 	61 6D 65 6C 69 73 74 8A 
1A4EF10 	FC EE A4  1 68 40 A0  1 
1A4EF18 	 0  4  0  0 
4 *         constant /framelist			\ Size of framelist
1A4EF1C 	 0 2F 66 72 
1A4EF20 	61 6D 65 6C 69 73 74 8A 
1A4EF28 	14 EF A4  1 68 40 A0  1 
1A4EF30 	 0 10  0  0 

0 value framelist
1A4EF34 	 0  0 66 72 
1A4EF38 	61 6D 65 6C 69 73 74 89 
1A4EF40 	2C EF A4  1 50 40 A0  1 
1A4EF48 	38  E  0  0 
0 value framelist-phys
1A4EF4C 	 0 66 72 61 
1A4EF50 	6D 65 6C 69 73 74 2D 70 
1A4EF58 	68 79 73 8E 44 EF A4  1 
1A4EF60 	50 40 A0  1 3C  E  0  0 
0 value framelist-unaligned
1A4EF68 	66 72 61 6D 65 6C 69 73 
1A4EF70 	74 2D 75 6E 61 6C 69 67 
1A4EF78 	6E 65 64 93 60 EF A4  1 
1A4EF80 	50 40 A0  1 40  E  0  0 

: framelist!  ( n idx -- )  4 * framelist + le-l!  ;
1A4EF88 	 0 66 72 61 6D 65 6C 69 
1A4EF90 	73 74 21 8A 80 EF A4  1 
1A4EF98 	20 40 A0  1 B0 6F A0  1 
1A4EFA0 	1C 5F A0  1 44 EF A4  1 
1A4EFA8 	 4 45 A0  1 50 36 A4  1 
1A4EFB0 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Queue Head as defined by the UHCI Spec; 16-byte aligned
\ ---------------------------------------------------------------------------

struct
   4 field >hcqh-next				\ QH link pointer
1A4EFB4 	 0 3E 68 63 
1A4EFB8 	71 68 2D 6E 65 78 74 8A 
1A4EFC0 	98 EF A4  1 50 EE A0  1 
1A4EFC8 	 0  0  0  0 
   4 field >hcqh-elem				\ Queue element link pointer
1A4EFCC 	 0 3E 68 63 
1A4EFD0 	71 68 2D 65 6C 65 6D 8A 
1A4EFD8 	C4 EF A4  1 50 EE A0  1 
1A4EFE0 	 4  0  0  0 
dup constant /hcqh
1A4EFE4 	 0  0 2F 68 
1A4EFE8 	63 71 68 85 DC EF A4  1 
1A4EFF0 	68 40 A0  1  8  0  0  0 
   8 +						\ Make it easier to look at
   4 field >qh-phys				\ QH's physical address
1A4EFF8 	 0  0  0 3E 71 68 2D 70 
1A4F000 	68 79 73 88 F0 EF A4  1 
1A4F008 	50 EE A0  1 10  0  0  0 
   4 field >qh-next				\ Virtual address of >hcqh-next
1A4F010 	 0  0  0 3E 71 68 2D 6E 
1A4F018 	65 78 74 88  8 F0 A4  1 
1A4F020 	50 EE A0  1 14  0  0  0 
   4 field >qh-prev				\ Virtual address of previous QH
1A4F028 	 0  0  0 3E 71 68 2D 70 
1A4F030 	72 65 76 88 20 F0 A4  1 
1A4F038 	50 EE A0  1 18  0  0  0 
   4 field >qh-unaligned			\ QH's unaligned address
1A4F040 	 0  0 3E 71 68 2D 75 6E 
1A4F048 	61 6C 69 67 6E 65 64 8D 
1A4F050 	38 F0 A4  1 50 EE A0  1 
1A4F058 	1C  0  0  0 
   4 field >qh-size				\ Size of QH+TDs
1A4F05C 	 0  0  0 3E 
1A4F060 	71 68 2D 73 69 7A 65 88 
1A4F068 	54 F0 A4  1 50 EE A0  1 
1A4F070 	20  0  0  0 
   4 field >qh-#tds				\ Number of TDs in >hcqh-elem
1A4F074 	 0  0  0 3E 
1A4F078 	71 68 2D 23 74 64 73 88 
1A4F080 	6C F0 A4  1 50 EE A0  1 
1A4F088 	24  0  0  0 
   4 field >qh-elem				\ Virtual address of >hcqh-elem
1A4F08C 	 0  0  0 3E 
1A4F090 	71 68 2D 65 6C 65 6D 88 
1A4F098 	84 F0 A4  1 50 EE A0  1 
1A4F0A0 	28  0  0  0 
d# 16 round-up
constant /qh
1A4F0A4 	2F 71 68 83 
1A4F0A8 	9C F0 A4  1 68 40 A0  1 
1A4F0B0 	30  0  0  0 

\ ---------------------------------------------------------------------------
\ Transfer Descriptor as defined by the UHCI Spec; 16-byte aligned
\ ---------------------------------------------------------------------------
struct
   4 field >hctd-next				\ TD link pointer
1A4F0B4 	 0 3E 68 63 
1A4F0B8 	74 64 2D 6E 65 78 74 8A 
1A4F0C0 	AC F0 A4  1 50 EE A0  1 
1A4F0C8 	 0  0  0  0 
   4 field >hctd-stat				\ TD control and status
1A4F0CC 	 0 3E 68 63 
1A4F0D0 	74 64 2D 73 74 61 74 8A 
1A4F0D8 	C4 F0 A4  1 50 EE A0  1 
1A4F0E0 	 4  0  0  0 
   4 field >hctd-token				\ TD token
1A4F0E4 	3E 68 63 74 
1A4F0E8 	64 2D 74 6F 6B 65 6E 8B 
1A4F0F0 	DC F0 A4  1 50 EE A0  1 
1A4F0F8 	 8  0  0  0 
   4 field >hctd-buf				\ TD buffer pointer
1A4F0FC 	 0  0 3E 68 
1A4F100 	63 74 64 2D 62 75 66 89 
1A4F108 	F4 F0 A4  1 50 EE A0  1 
1A4F110 	 C  0  0  0 
dup constant /hctd
1A4F114 	 0  0 2F 68 
1A4F118 	63 74 64 85  C F1 A4  1 
1A4F120 	68 40 A0  1 10  0  0  0 
   4 field >td-phys				\ TD's physical address
1A4F128 	 0  0  0 3E 74 64 2D 70 
1A4F130 	68 79 73 88 20 F1 A4  1 
1A4F138 	50 EE A0  1 10  0  0  0 
   4 field >td-next				\ Next TD's virtual address
1A4F140 	 0  0  0 3E 74 64 2D 6E 
1A4F148 	65 78 74 88 38 F1 A4  1 
1A4F150 	50 EE A0  1 14  0  0  0 
   4 field >td-buf				\ Virtual address of >hctd-buf
1A4F158 	3E 74 64 2D 62 75 66 87 
1A4F160 	50 F1 A4  1 50 EE A0  1 
1A4F168 	18  0  0  0 
   4 field >td-pbuf				\ Physical address of >hctd-buf
1A4F16C 	 0  0  0 3E 
1A4F170 	74 64 2D 70 62 75 66 88 
1A4F178 	64 F1 A4  1 50 EE A0  1 
1A4F180 	1C  0  0  0 
   4 field >td-/buf-all				\ Buffer length (size of the entire buffer)
1A4F184 	 0  0  0 3E 
1A4F188 	74 64 2D 2F 62 75 66 2D 
1A4F190 	61 6C 6C 8C 7C F1 A4  1 
1A4F198 	50 EE A0  1 20  0  0  0 
						\ Only the first TD has the entire size of buffer
						\ For bulk and intr TDs
d# 16 round-up
constant /td
1A4F1A0 	2F 74 64 83 98 F1 A4  1 
1A4F1A8 	68 40 A0  1 30  0  0  0 

\ >hctd-next constants
0 constant TD_BREADTH				\ Next transaction in next QH
1A4F1B0 	 0 74 64 5F 62 72 65 61 
1A4F1B8 	64 74 68 8A A8 F1 A4  1 
1A4F1C0 	68 40 A0  1  0  0  0  0 
4 constant TD_DEPTH				\ Next transaction in next TD
1A4F1C8 	 0  0  0 74 64 5F 64 65 
1A4F1D0 	70 74 68 88 C0 F1 A4  1 
1A4F1D8 	68 40 A0  1  4  0  0  0 

\ >hctd-stat constants
h# 20000000 constant TD_CTRL_SPD		\ Short packet detect
1A4F1E0 	74 64 5F 63 74 72 6C 5F 
1A4F1E8 	73 70 64 8B D8 F1 A4  1 
1A4F1F0 	68 40 A0  1  0  0  0 20 
h# 18000000 constant TD_CTRL_C_ERR_MASK	\ Error counter bits
1A4F1F8 	 0 74 64 5F 63 74 72 6C 
1A4F200 	5F 63 5F 65 72 72 5F 6D 
1A4F208 	61 73 6B 92 F0 F1 A4  1 
1A4F210 	68 40 A0  1  0  0  0 18 
h# 08000000 constant TD_CTRL_C_ERR1		\ Interrupt on one error
1A4F218 	 0 74 64 5F 63 74 72 6C 
1A4F220 	5F 63 5F 65 72 72 31 8E 
1A4F228 	10 F2 A4  1 68 40 A0  1 
1A4F230 	 0  0  0  8 
h# 10000000 constant TD_CTRL_C_ERR2		\ Interrupt on two errors
1A4F234 	 0 74 64 5F 
1A4F238 	63 74 72 6C 5F 63 5F 65 
1A4F240 	72 72 32 8E 2C F2 A4  1 
1A4F248 	68 40 A0  1  0  0  0 10 
h# 18000000 constant TD_CTRL_C_ERR3		\ Interrupt on three errors
1A4F250 	 0 74 64 5F 63 74 72 6C 
1A4F258 	5F 63 5F 65 72 72 33 8E 
1A4F260 	48 F2 A4  1 68 40 A0  1 
1A4F268 	 0  0  0 18 
h# 04000000 constant TD_CTRL_LOW		\ Low speed device
1A4F26C 	74 64 5F 63 
1A4F270 	74 72 6C 5F 6C 6F 77 8B 
1A4F278 	64 F2 A4  1 68 40 A0  1 
1A4F280 	 0  0  0  4 
h# 00000000 constant TD_CTRL_FULL		\ Full speed device
1A4F284 	 0  0  0 74 
1A4F288 	64 5F 63 74 72 6C 5F 66 
1A4F290 	75 6C 6C 8C 7C F2 A4  1 
1A4F298 	68 40 A0  1  0  0  0  0 
h# 02000000 constant TD_CTRL_ISO		\ Isochonous select
1A4F2A0 	74 64 5F 63 74 72 6C 5F 
1A4F2A8 	69 73 6F 8B 98 F2 A4  1 
1A4F2B0 	68 40 A0  1  0  0  0  2 
h# 01000000 constant TD_CTRL_IOC		\ Interrupt on complete
1A4F2B8 	74 64 5F 63 74 72 6C 5F 
1A4F2C0 	69 6F 63 8B B0 F2 A4  1 
1A4F2C8 	68 40 A0  1  0  0  0  1 
h# 00800000 constant TD_STAT_ACTIVE		\ TD active
1A4F2D0 	 0 74 64 5F 73 74 61 74 
1A4F2D8 	5F 61 63 74 69 76 65 8E 
1A4F2E0 	C8 F2 A4  1 68 40 A0  1 
1A4F2E8 	 0  0 80  0 
h# 00400000 constant TD_STAT_STALLED		\ TD stalled
1A4F2EC 	74 64 5F 73 
1A4F2F0 	74 61 74 5F 73 74 61 6C 
1A4F2F8 	6C 65 64 8F E4 F2 A4  1 
1A4F300 	68 40 A0  1  0  0 40  0 
h# 00200000 constant TD_STAT_DBUFERR		\ Data buffer error
1A4F308 	74 64 5F 73 74 61 74 5F 
1A4F310 	64 62 75 66 65 72 72 8F 
1A4F318 	 0 F3 A4  1 68 40 A0  1 
1A4F320 	 0  0 20  0 
h# 00100000 constant TD_STAT_BABBLE		\ Babble detected
1A4F324 	 0 74 64 5F 
1A4F328 	73 74 61 74 5F 62 61 62 
1A4F330 	62 6C 65 8E 1C F3 A4  1 
1A4F338 	68 40 A0  1  0  0 10  0 
h# 00080000 constant TD_STAT_NAK		\ NAK received
1A4F340 	74 64 5F 73 74 61 74 5F 
1A4F348 	6E 61 6B 8B 38 F3 A4  1 
1A4F350 	68 40 A0  1  0  0  8  0 
h# 00040000 constant TD_STAT_CRCTIME		\ CRC or timeout error
1A4F358 	74 64 5F 73 74 61 74 5F 
1A4F360 	63 72 63 74 69 6D 65 8F 
1A4F368 	50 F3 A4  1 68 40 A0  1 
1A4F370 	 0  0  4  0 
h# 00020000 constant TD_STAT_BITSTUFF		\ Bit stuff error
1A4F374 	 0  0  0 74 
1A4F378 	64 5F 73 74 61 74 5F 62 
1A4F380 	69 74 73 74 75 66 66 90 
1A4F388 	6C F3 A4  1 68 40 A0  1 
1A4F390 	 0  0  2  0 
h# 00ff0000 constant TD_STAT_MASK		\ Status mask
1A4F394 	 0  0  0 74 
1A4F398 	64 5F 73 74 61 74 5F 6D 
1A4F3A0 	61 73 6B 8C 8C F3 A4  1 
1A4F3A8 	68 40 A0  1  0  0 FF  0 

TD_STAT_STALLED TD_STAT_DBUFERR or TD_STAT_BABBLE or TD_STAT_CRCTIME or
TD_STAT_BITSTUFF or TD_STAT_NAK or constant TD_STAT_ANY_ERROR
1A4F3B0 	 0  0 74 64 5F 73 74 61 
1A4F3B8 	74 5F 61 6E 79 5F 65 72 
1A4F3C0 	72 6F 72 91 A8 F3 A4  1 
1A4F3C8 	68 40 A0  1  0  0 7E  0 

h# 07ff constant TD_NULL_DATA_SIZE		\ Null data length
1A4F3D0 	 0  0 74 64 5F 6E 75 6C 
1A4F3D8 	6C 5F 64 61 74 61 5F 73 
1A4F3E0 	69 7A 65 91 C8 F3 A4  1 
1A4F3E8 	68 40 A0  1 FF  7  0  0 
h# 07ff constant TD_ACTUAL_MASK			\ TD actual length mask
1A4F3F0 	 0 74 64 5F 61 63 74 75 
1A4F3F8 	61 6C 5F 6D 61 73 6B 8E 
1A4F400 	E8 F3 A4  1 68 40 A0  1 
1A4F408 	FF  7  0  0 

\ >hctd-token constants
h# 00ff constant TD_PID_MASK			\ PID mask
1A4F40C 	74 64 5F 70 
1A4F410 	69 64 5F 6D 61 73 6B 8B 
1A4F418 	 4 F4 A4  1 68 40 A0  1 
1A4F420 	FF  0  0  0 
h# 002d constant TD_PID_SETUP
1A4F424 	 0  0  0 74 
1A4F428 	64 5F 70 69 64 5F 73 65 
1A4F430 	74 75 70 8C 1C F4 A4  1 
1A4F438 	68 40 A0  1 2D  0  0  0 
h# 0069 constant TD_PID_IN
1A4F440 	 0  0 74 64 5F 70 69 64 
1A4F448 	5F 69 6E 89 38 F4 A4  1 
1A4F450 	68 40 A0  1 69  0  0  0 
h# 00e1 constant TD_PID_OUT
1A4F458 	 0 74 64 5F 70 69 64 5F 
1A4F460 	6F 75 74 8A 50 F4 A4  1 
1A4F468 	68 40 A0  1 E1  0  0  0 

h# 00080000 constant TD_TOKEN_DATA1		\ Data1
1A4F470 	 0 74 64 5F 74 6F 6B 65 
1A4F478 	6E 5F 64 61 74 61 31 8E 
1A4F480 	68 F4 A4  1 68 40 A0  1 
1A4F488 	 0  0  8  0 
h# 00000000 constant TD_TOKEN_DATA0		\ Data0
1A4F48C 	 0 74 64 5F 
1A4F490 	74 6F 6B 65 6E 5F 64 61 
1A4F498 	74 61 30 8E 84 F4 A4  1 
1A4F4A0 	68 40 A0  1  0  0  0  0 
h# 00080000 constant TD_TOKEN_MASK		\ Data toggle mask
1A4F4A8 	 0  0 74 64 5F 74 6F 6B 
1A4F4B0 	65 6E 5F 6D 61 73 6B 8D 
1A4F4B8 	A0 F4 A4  1 68 40 A0  1 
1A4F4C0 	 0  0  8  0 

: di-data>td-data  ( n -- n' )  if  TD_TOKEN_DATA1  else  TD_TOKEN_DATA0  then  ;
1A4F4C4 	64 69 2D 64 
1A4F4C8 	61 74 61 3E 74 64 2D 64 
1A4F4D0 	61 74 61 8F BC F4 A4  1 
1A4F4D8 	20 40 A0  1 DC 41 A0  1 
1A4F4E0 	10  0  0  0 84 F4 A4  1 
1A4F4E8 	C8 41 A0  1  8  0  0  0 
1A4F4F0 	A0 F4 A4  1 58 46 A0  1 
: td-data>di-data  ( n -- n' )  TD_TOKEN_MASK and  if  1  else  0  then  ;
1A4F4F8 	74 64 2D 64 61 74 61 3E 
1A4F500 	64 69 2D 64 61 74 61 8F 
1A4F508 	D8 F4 A4  1 20 40 A0  1 
1A4F510 	BC F4 A4  1 5C 44 A0  1 
1A4F518 	DC 41 A0  1 10  0  0  0 
1A4F520 	80 6F A0  1 C8 41 A0  1 
1A4F528 	 8  0  0  0 70 6F A0  1 
1A4F530 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Permanent QHs for interrupt, low-speed and high-speed transactions.
\
\ These are place holders so we know where to insert new QHs depending on
\ their characteristics easily.  
\ Link: intr-qh -> low-qh -> full-qh -> last-qh 
\
\ XXX My initial design was to have last-qh pointing to full-qh to allow
\ XXX reclaimation.  But I get all sort of HC errors.  Now, it's painfully
\ XXX slow but it gets there eventually.
\ ---------------------------------------------------------------------------

4 constant #fixed-qhs
1A4F534 	 0 23 66 69 
1A4F538 	78 65 64 2D 71 68 73 8A 
1A4F540 	 C F5 A4  1 68 40 A0  1 
1A4F548 	 4  0  0  0 
0 value fixed-qh
1A4F54C 	 0  0  0 66 
1A4F550 	69 78 65 64 2D 71 68 88 
1A4F558 	44 F5 A4  1 50 40 A0  1 
1A4F560 	44  E  0  0 
0 value fixed-qh-phys
1A4F564 	 0  0 66 69 
1A4F568 	78 65 64 2D 71 68 2D 70 
1A4F570 	68 79 73 8D 5C F5 A4  1 
1A4F578 	50 40 A0  1 48  E  0  0 
0 value fixed-qh-unaligned
1A4F580 	 0 66 69 78 65 64 2D 71 
1A4F588 	68 2D 75 6E 61 6C 69 67 
1A4F590 	6E 65 64 92 78 F5 A4  1 
1A4F598 	50 40 A0  1 4C  E  0  0 

: intr-qh  ( -- qh )  fixed-qh  ;
1A4F5A0 	69 6E 74 72 2D 71 68 87 
1A4F5A8 	98 F5 A4  1 20 40 A0  1 
1A4F5B0 	5C F5 A4  1 58 46 A0  1 
: low-qh   ( -- qh )  intr-qh /qh +  ;
1A4F5B8 	 0 6C 6F 77 2D 71 68 86 
1A4F5C0 	AC F5 A4  1 20 40 A0  1 
1A4F5C8 	AC F5 A4  1 AC F0 A4  1 
1A4F5D0 	 4 45 A0  1 58 46 A0  1 
: full-qh  ( -- qh )  low-qh  /qh +  ;
1A4F5D8 	66 75 6C 6C 2D 71 68 87 
1A4F5E0 	C4 F5 A4  1 20 40 A0  1 
1A4F5E8 	C4 F5 A4  1 AC F0 A4  1 
1A4F5F0 	 4 45 A0  1 58 46 A0  1 
: last-qh  ( -- qh )  full-qh /qh +  ;
1A4F5F8 	6C 61 73 74 2D 71 68 87 
1A4F600 	E4 F5 A4  1 20 40 A0  1 
1A4F608 	E4 F5 A4  1 AC F0 A4  1 
1A4F610 	 4 45 A0  1 58 46 A0  1 

: link-qhs  ( virt phys #qh -- )
1A4F618 	 0  0  0 6C 69 6E 6B 2D 
1A4F620 	71 68 73 88  4 F6 A4  1 
1A4F628 	20 40 A0  1 
   0  do					( virt phys )
1A4F62C 	70 6F A0  1 
1A4F630 	88 42 A0  1 C0  0  0  0 
      2dup swap >qh-phys l!			( virt phys )
1A4F638 	C0 49 A0  1 68 49 A0  1 
1A4F640 	 8 F0 A4  1 7C 4D A0  1 
      dup /qh + TYP_QH or 2 pick >hcqh-next le-l! ( virt phys )
1A4F648 	40 49 A0  1 AC F0 A4  1 
1A4F650 	 4 45 A0  1 E4 EE A4  1 
1A4F658 	70 44 A0  1 90 6F A0  1 
1A4F660 	 C 4A A0  1 C4 EF A4  1 
1A4F668 	50 36 A4  1 
      over /qh + 2 pick >qh-next l!		( virt phys )
1A4F66C 	54 49 A0  1 
1A4F670 	AC F0 A4  1  4 45 A0  1 
1A4F678 	90 6F A0  1  C 4A A0  1 
1A4F680 	20 F0 A4  1 7C 4D A0  1 
      i 0=  if  0  else  over /qh -  then	( virt phys prev ) 
1A4F688 	B4 42 A0  1 24 47 A0  1 
1A4F690 	DC 41 A0  1 10  0  0  0 
1A4F698 	70 6F A0  1 C8 41 A0  1 
1A4F6A0 	10  0  0  0 54 49 A0  1 
1A4F6A8 	AC F0 A4  1 18 45 A0  1 
      2 pick >qh-prev l!			( virt phys )
1A4F6B0 	90 6F A0  1  C 4A A0  1 
1A4F6B8 	38 F0 A4  1 7C 4D A0  1 
      TERMINATE 2 pick >hcqh-elem le-l!		( virt phys )
1A4F6C0 	BC EE A4  1 90 6F A0  1 
1A4F6C8 	 C 4A A0  1 DC EF A4  1 
1A4F6D0 	50 36 A4  1 
      /qh + swap /qh + swap			( virt' phys' )
1A4F6D4 	AC F0 A4  1 
1A4F6D8 	 4 45 A0  1 68 49 A0  1 
1A4F6E0 	AC F0 A4  1  4 45 A0  1 
1A4F6E8 	68 49 A0  1 
   loop  2drop 					( virt phys )
1A4F6EC 	F8 41 A0  1 
1A4F6F0 	48 FF FF FF AC 49 A0  1 
;
1A4F6F8 	58 46 A0  1 
: fixup-fixed-qhs  ( -- )
1A4F6FC 	66 69 78 75 
1A4F700 	70 2D 66 69 78 65 64 2D 
1A4F708 	71 68 73 8F 28 F6 A4  1 
1A4F710 	20 40 A0  1 
   TERMINATE last-qh >hcqh-next le-l!
1A4F714 	BC EE A4  1 
1A4F718 	 4 F6 A4  1 C4 EF A4  1 
1A4F720 	50 36 A4  1 
   0 last-qh >qh-next l!
1A4F724 	70 6F A0  1 
1A4F728 	 4 F6 A4  1 20 F0 A4  1 
1A4F730 	7C 4D A0  1 
;
1A4F734 	58 46 A0  1 
: alloc-qhs  ( #qh -- )
1A4F738 	 0  0 61 6C 6C 6F 63 2D 
1A4F740 	71 68 73 89 10 F7 A4  1 
1A4F748 	20 40 A0  1 
   /qh * dup >r aligned16-alloc-map-in		( qh.u,v,p )  ( R: size )
1A4F74C 	AC F0 A4  1 
1A4F750 	1C 5F A0  1 40 49 A0  1 
1A4F758 	BC 45 A0  1 B8 38 A4  1 
   over r> erase				( qh.u,v,p )
1A4F760 	54 49 A0  1 D0 45 A0  1 
1A4F768 	F0 72 A0  1 
   to fixed-qh-phys to fixed-qh to fixed-qh-unaligned
1A4F76C 	B8 40 A0  1 
1A4F770 	78 F5 A4  1 B8 40 A0  1 
1A4F778 	5C F5 A4  1 B8 40 A0  1 
1A4F780 	98 F5 A4  1 
;
1A4F784 	58 46 A0  1 
: alloc-fixed-qhs  ( -- )
1A4F788 	61 6C 6C 6F 63 2D 66 69 
1A4F790 	78 65 64 2D 71 68 73 8F 
1A4F798 	48 F7 A4  1 20 40 A0  1 
   #fixed-qhs alloc-qhs				( qh.u,v,p )
1A4F7A0 	44 F5 A4  1 48 F7 A4  1 
   fixed-qh fixed-qh-phys #fixed-qhs link-qhs
1A4F7A8 	5C F5 A4  1 78 F5 A4  1 
1A4F7B0 	44 F5 A4  1 28 F6 A4  1 
   fixup-fixed-qhs
1A4F7B8 	10 F7 A4  1 
;
1A4F7BC 	58 46 A0  1 

: init-framelist  ( -- )
1A4F7C0 	 0 69 6E 69 74 2D 66 72 
1A4F7C8 	61 6D 65 6C 69 73 74 8E 
1A4F7D0 	9C F7 A4  1 20 40 A0  1 
   \ Allocate framelist
   /framelist /align4kb aligned-alloc		( unaligned virt )
1A4F7D8 	2C EF A4  1 FC EE A4  1 
1A4F7E0 	 C 38 A4  1 
   swap to framelist-unaligned			( virt )
1A4F7E4 	68 49 A0  1 
1A4F7E8 	B8 40 A0  1 80 EF A4  1 
   dup to framelist				( virt )
1A4F7F0 	40 49 A0  1 B8 40 A0  1 
1A4F7F8 	44 EF A4  1 
   /framelist true dma-map-in to framelist-phys	( )
1A4F7FC 	2C EF A4  1 
1A4F800 	 4 70 A0  1 AC 37 A4  1 
1A4F808 	B8 40 A0  1 60 EF A4  1 

   \ Initialize framelist
   #framelist 0  do  fixed-qh-phys TYP_QH or i framelist!  loop
1A4F810 	14 EF A4  1 70 6F A0  1 
1A4F818 	88 42 A0  1 20  0  0  0 
1A4F820 	78 F5 A4  1 E4 EE A4  1 
1A4F828 	70 44 A0  1 B4 42 A0  1 
1A4F830 	98 EF A4  1 F8 41 A0  1 
1A4F838 	E8 FF FF FF 
;
1A4F83C 	58 46 A0  1 
cr .( : init-lists ) order
: init-lists  ( -- )
1A4F840 	 0 69 6E 69 74 2D 6C 69 
1A4F848 	73 74 73 8A D4 F7 A4  1 
1A4F850 	20 40 A0  1 
   framelist 0=  if
1A4F854 	44 EF A4  1 
1A4F858 	24 47 A0  1 DC 41 A0  1 
1A4F860 	 C  0  0  0 
      alloc-fixed-qhs
1A4F864 	9C F7 A4  1 
      init-framelist
1A4F868 	D4 F7 A4  1 
   then
;
1A4F86C 	58 46 A0  1 
cr .( ; init-lists )

\ ---------------------------------------------------------------------------
\ Dynamically allocate QH and TDs all transactions.
\ ---------------------------------------------------------------------------

: link-tds  ( td.v td.p #td -- )
1A4F870 	 0  0  0 6C 69 6E 6B 2D 
1A4F878 	74 64 73 88 50 F8 A4  1 
1A4F880 	20 40 A0  1 
   0  do
1A4F884 	70 6F A0  1 
1A4F888 	88 42 A0  1 58  0  0  0 
      over >r					( td.v,p )  ( R: td )
1A4F890 	54 49 A0  1 BC 45 A0  1 
      dup r@ >td-phys l!			( td.v,p )  ( R: td )
1A4F898 	40 49 A0  1 E4 45 A0  1 
1A4F8A0 	38 F1 A4  1 7C 4D A0  1 
      /td +					( td.v,p' )  ( R: td )
1A4F8A8 	A8 F1 A4  1  4 45 A0  1 
      dup r@ >hctd-next le-l!			( td.v,p )  ( R: td )
1A4F8B0 	40 49 A0  1 E4 45 A0  1 
1A4F8B8 	C4 F0 A4  1 50 36 A4  1 
      swap /td + tuck r> >td-next l!		( td.v',p )
1A4F8C0 	68 49 A0  1 A8 F1 A4  1 
1A4F8C8 	 4 45 A0  1 E8 46 A0  1 
1A4F8D0 	D0 45 A0  1 50 F1 A4  1 
1A4F8D8 	7C 4D A0  1 
   loop
1A4F8DC 	F8 41 A0  1 
1A4F8E0 	B0 FF FF FF 
   drop /td -					( td.v' )
1A4F8E4 	30 49 A0  1 
1A4F8E8 	A8 F1 A4  1 18 45 A0  1 
   TERMINATE over >hctd-next le-l!		( td.v' )
1A4F8F0 	BC EE A4  1 54 49 A0  1 
1A4F8F8 	C4 F0 A4  1 50 36 A4  1 
   0 swap >td-next l!				( )
1A4F900 	70 6F A0  1 68 49 A0  1 
1A4F908 	50 F1 A4  1 7C 4D A0  1 
;
1A4F910 	58 46 A0  1 
: link-qhtds  ( td.v td.p qh -- )
1A4F914 	 0 6C 69 6E 
1A4F918 	6B 2D 71 68 74 64 73 8A 
1A4F920 	80 F8 A4  1 20 40 A0  1 
   >r						( td.v,p )  ( R: qh )
1A4F928 	BC 45 A0  1 
   dup TYP_TD or r@ >hcqh-elem le-l!		( td.v,p )  ( R: qh )
1A4F92C 	40 49 A0  1 
1A4F930 	D0 EE A4  1 70 44 A0  1 
1A4F938 	E4 45 A0  1 DC EF A4  1 
1A4F940 	50 36 A4  1 
   over r@ >qh-elem l!				( td.v,p )  ( R: qh )
1A4F944 	54 49 A0  1 
1A4F948 	E4 45 A0  1 9C F0 A4  1 
1A4F950 	7C 4D A0  1 
   r> >qh-#tds l@ link-tds			( )
1A4F954 	D0 45 A0  1 
1A4F958 	84 F0 A4  1 6C 4C A0  1 
1A4F960 	80 F8 A4  1 
;
1A4F964 	58 46 A0  1 
: init-qh  ( qh.u,v,p size #tds -- )
1A4F968 	69 6E 69 74 2D 71 68 87 
1A4F970 	24 F9 A4  1 20 40 A0  1 
   3 pick >qh-#tds l!				( qh.u,v,p size )
1A4F978 	A0 6F A0  1  C 4A A0  1 
1A4F980 	84 F0 A4  1 7C 4D A0  1 
   2 pick >qh-size l!				( qh.u,v,p )
1A4F988 	90 6F A0  1  C 4A A0  1 
1A4F990 	6C F0 A4  1 7C 4D A0  1 
   over >qh-phys l!				( qh.u,v )
1A4F998 	54 49 A0  1  8 F0 A4  1 
1A4F9A0 	7C 4D A0  1 
   >qh-unaligned l!				( )
1A4F9A4 	54 F0 A4  1 
1A4F9A8 	7C 4D A0  1 
;
1A4F9AC 	58 46 A0  1 

: alloc-qhtds  ( #td -- qh td )
1A4F9B0 	61 6C 6C 6F 63 2D 71 68 
1A4F9B8 	74 64 73 8B 74 F9 A4  1 
1A4F9C0 	20 40 A0  1 
   dup >r /td * /qh + dup >r			( size )  ( R: #td size )
1A4F9C4 	40 49 A0  1 
1A4F9C8 	BC 45 A0  1 A8 F1 A4  1 
1A4F9D0 	1C 5F A0  1 AC F0 A4  1 
1A4F9D8 	 4 45 A0  1 40 49 A0  1 
1A4F9E0 	BC 45 A0  1 
   aligned16-alloc-map-in			( qh.u,v,p )  ( R: #td size )
1A4F9E4 	B8 38 A4  1 
   over r@ erase				( qh.u,v,p )  ( R: #td )
1A4F9E8 	54 49 A0  1 E4 45 A0  1 
1A4F9F0 	F0 72 A0  1 
   3dup r> r> init-qh				( qh.u,v,p )
1A4F9F4 	6C 3F A4  1 
1A4F9F8 	D0 45 A0  1 D0 45 A0  1 
1A4FA00 	74 F9 A4  1 
   rot drop					( qh.v,p )
1A4FA04 	7C 49 A0  1 
1A4FA08 	30 49 A0  1 
   over /qh + dup -rot				( qh td qh.p td )
1A4FA0C 	54 49 A0  1 
1A4FA10 	AC F0 A4  1  4 45 A0  1 
1A4FA18 	40 49 A0  1 94 49 A0  1 
   swap /qh +					( qh td td.v,p )
1A4FA20 	68 49 A0  1 AC F0 A4  1 
1A4FA28 	 4 45 A0  1 
   3 pick link-qhtds				( qh td )
1A4FA2C 	A0 6F A0  1 
1A4FA30 	 C 4A A0  1 24 F9 A4  1 
;
1A4FA38 	58 46 A0  1 

: free-qhtds  ( qh -- )
1A4FA3C 	 0 66 72 65 
1A4FA40 	65 2D 71 68 74 64 73 8A 
1A4FA48 	C0 F9 A4  1 20 40 A0  1 
   dup >qh-unaligned l@ over >qh-phys l@ 2 pick >qh-size l@
1A4FA50 	40 49 A0  1 54 F0 A4  1 
1A4FA58 	6C 4C A0  1 54 49 A0  1 
1A4FA60 	 8 F0 A4  1 6C 4C A0  1 
1A4FA68 	90 6F A0  1  C 4A A0  1 
1A4FA70 	6C F0 A4  1 6C 4C A0  1 
   aligned16-free-map-out
1A4FA78 	F8 38 A4  1 
;
1A4FA7C 	58 46 A0  1 

: push-qhtds  ( qh -- )
1A4FA80 	 0 70 75 73 68 2D 71 68 
1A4FA88 	74 64 73 8A 4C FA A4  1 
1A4FA90 	20 40 A0  1 
   dup >qh-phys l@ over >qh-size l@  dma-push
1A4FA94 	40 49 A0  1 
1A4FA98 	 8 F0 A4  1 6C 4C A0  1 
1A4FAA0 	54 49 A0  1 6C F0 A4  1 
1A4FAA8 	6C 4C A0  1 FC 36 A4  1 
;
1A4FAB0 	58 46 A0  1 

: pull-qhtds  ( qh -- )
1A4FAB4 	 0 70 75 6C 
1A4FAB8 	6C 2D 71 68 74 64 73 8A 
1A4FAC0 	90 FA A4  1 20 40 A0  1 
   dup >qh-phys l@ over >qh-size l@  dma-pull
1A4FAC8 	40 49 A0  1  8 F0 A4  1 
1A4FAD0 	6C 4C A0  1 54 49 A0  1 
1A4FAD8 	6C F0 A4  1 6C 4C A0  1 
1A4FAE0 	28 37 A4  1 
;
1A4FAE4 	58 46 A0  1 

: map-out-buf  ( td -- )
1A4FAE8 	6D 61 70 2D 6F 75 74 2D 
1A4FAF0 	62 75 66 8B C4 FA A4  1 
1A4FAF8 	20 40 A0  1 
   dup >td-buf l@ over >td-pbuf l@ rot >td-/buf-all l@ hcd-map-out
1A4FAFC 	40 49 A0  1 
1A4FB00 	64 F1 A4  1 6C 4C A0  1 
1A4FB08 	54 49 A0  1 7C F1 A4  1 
1A4FB10 	6C 4C A0  1 7C 49 A0  1 
1A4FB18 	98 F1 A4  1 6C 4C A0  1 
1A4FB20 	8C 3E A4  1 
;
1A4FB24 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Transaction scheduling
\ ---------------------------------------------------------------------------

: insert-qh  ( qh head -- )
1A4FB28 	 0  0 69 6E 73 65 72 74 
1A4FB30 	2D 71 68 89 F8 FA A4  1 
1A4FB38 	20 40 A0  1 
   >r						( qh )  ( R: head )
1A4FB3C 	BC 45 A0  1 
   \ Fixup the QH link pointers
   r@ >hcqh-next le-l@ over >hcqh-next le-l!	( qh )  ( R: head )
1A4FB40 	E4 45 A0  1 C4 EF A4  1 
1A4FB48 	B8 35 A4  1 54 49 A0  1 
1A4FB50 	C4 EF A4  1 50 36 A4  1 
   dup >qh-phys l@ TYP_QH or r@ >hcqh-next le-l! ( qh )  ( R: head )
1A4FB58 	40 49 A0  1  8 F0 A4  1 
1A4FB60 	6C 4C A0  1 E4 EE A4  1 
1A4FB68 	70 44 A0  1 E4 45 A0  1 
1A4FB70 	C4 EF A4  1 50 36 A4  1 

   \ Fixup the next QH's pointers
   dup r@ >qh-next l@ >qh-prev l!		( qh )  ( R: head )
1A4FB78 	40 49 A0  1 E4 45 A0  1 
1A4FB80 	20 F0 A4  1 6C 4C A0  1 
1A4FB88 	38 F0 A4  1 7C 4D A0  1 

   \ Fixup QH's pointers
   r@ >qh-next l@ over >qh-next l!		( qh )  ( R: head )
1A4FB90 	E4 45 A0  1 20 F0 A4  1 
1A4FB98 	6C 4C A0  1 54 49 A0  1 
1A4FBA0 	20 F0 A4  1 7C 4D A0  1 
   r@ over >qh-prev l!				( qh )  ( R: head )
1A4FBA8 	E4 45 A0  1 54 49 A0  1 
1A4FBB0 	38 F0 A4  1 7C 4D A0  1 

   \ Fixup head's pointers
   r> >qh-next l!				( )
1A4FBB8 	D0 45 A0  1 20 F0 A4  1 
1A4FBC0 	7C 4D A0  1 
;
1A4FBC4 	58 46 A0  1 

\ Due to the fact that we have fixed QHs, an allocated QH will always be
\ in between two other QHs.
: remove-qh  ( qh -- )
1A4FBC8 	 0  0 72 65 6D 6F 76 65 
1A4FBD0 	2D 71 68 89 38 FB A4  1 
1A4FBD8 	20 40 A0  1 
   dup >qh-next l@ over >qh-prev l@ >qh-next l!
1A4FBDC 	40 49 A0  1 
1A4FBE0 	20 F0 A4  1 6C 4C A0  1 
1A4FBE8 	54 49 A0  1 38 F0 A4  1 
1A4FBF0 	6C 4C A0  1 20 F0 A4  1 
1A4FBF8 	7C 4D A0  1 
   dup >qh-prev l@ over >qh-next l@ >qh-prev l!
1A4FBFC 	40 49 A0  1 
1A4FC00 	38 F0 A4  1 6C 4C A0  1 
1A4FC08 	54 49 A0  1 20 F0 A4  1 
1A4FC10 	6C 4C A0  1 38 F0 A4  1 
1A4FC18 	7C 4D A0  1 
   dup >hcqh-next le-l@ swap >qh-prev l@ >hcqh-next le-l!
1A4FC1C 	40 49 A0  1 
1A4FC20 	C4 EF A4  1 B8 35 A4  1 
1A4FC28 	68 49 A0  1 38 F0 A4  1 
1A4FC30 	6C 4C A0  1 C4 EF A4  1 
1A4FC38 	50 36 A4  1 
;
1A4FC3C 	58 46 A0  1 

: insert-ctrl-qh  ( qh speed -- )
1A4FC40 	 0 69 6E 73 65 72 74 2D 
1A4FC48 	63 74 72 6C 2D 71 68 8E 
1A4FC50 	D8 FB A4  1 20 40 A0  1 
   TD_CTRL_LOW =  if  low-qh  else  full-qh  then
1A4FC58 	7C F2 A4  1 24 48 A0  1 
1A4FC60 	DC 41 A0  1 10  0  0  0 
1A4FC68 	C4 F5 A4  1 C8 41 A0  1 
1A4FC70 	 8  0  0  0 E4 F5 A4  1 
   insert-qh
1A4FC78 	38 FB A4  1 
;
1A4FC7C 	58 46 A0  1 

: insert-bulk-qh  ( qh speed -- )  insert-ctrl-qh  ;
1A4FC80 	 0 69 6E 73 65 72 74 2D 
1A4FC88 	62 75 6C 6B 2D 71 68 8E 
1A4FC90 	54 FC A4  1 20 40 A0  1 
1A4FC98 	54 FC A4  1 58 46 A0  1 

: insert-intr-qh  ( qh interval -- )  drop intr-qh insert-qh  ;
1A4FCA0 	 0 69 6E 73 65 72 74 2D 
1A4FCA8 	69 6E 74 72 2D 71 68 8E 
1A4FCB0 	94 FC A4  1 20 40 A0  1 
1A4FCB8 	30 49 A0  1 AC F5 A4  1 
1A4FCC0 	38 FB A4  1 58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Wait for a QH to be done and proocess any errors.
\ ---------------------------------------------------------------------------

defer process-hc-status
1A4FCC8 	 0  0 70 72 6F 63 65 73 
1A4FCD0 	73 2D 68 63 2D 73 74 61 
1A4FCD8 	74 75 73 91 B4 FC A4  1 
1A4FCE0 	5C 40 A0  1 50  E  0  0 
0 value timeout
1A4FCE8 	74 69 6D 65 6F 75 74 87 
1A4FCF0 	E0 FC A4  1 50 40 A0  1 
1A4FCF8 	54  E  0  0 

: .td-error  ( stat -- )
1A4FCFC 	 0  0 2E 74 
1A4FD00 	64 2D 65 72 72 6F 72 89 
1A4FD08 	F4 FC A4  1 20 40 A0  1 
   dup TD_STAT_STALLED  and  if  " Stalled; "            USB_ERR_STALL set-usb-error        then
1A4FD10 	40 49 A0  1  0 F3 A4  1 
1A4FD18 	5C 44 A0  1 DC 41 A0  1 
1A4FD20 	1C  0  0  0 9C 53 A0  1 
1A4FD28 	 9 53 74 61 6C 6C 65 64 
1A4FD30 	3B 20  0  0 98 2C A4  1 
1A4FD38 	14 41 A4  1 
   dup TD_STAT_DBUFERR  and  if  " Data Buffer Error; "  USB_ERR_DBUFERR set-usb-error      then
1A4FD3C 	40 49 A0  1 
1A4FD40 	1C F3 A4  1 5C 44 A0  1 
1A4FD48 	DC 41 A0  1 28  0  0  0 
1A4FD50 	9C 53 A0  1 13 44 61 74 
1A4FD58 	61 20 42 75 66 66 65 72 
1A4FD60 	20 45 72 72 6F 72 3B 20 
1A4FD68 	 0  0  0  0 F0 2D A4  1 
1A4FD70 	14 41 A4  1 
   dup TD_STAT_BABBLE   and  if  " Babble Detected; "    USB_ERR_BABBLE set-usb-error       then
1A4FD74 	40 49 A0  1 
1A4FD78 	38 F3 A4  1 5C 44 A0  1 
1A4FD80 	DC 41 A0  1 24  0  0  0 
1A4FD88 	9C 53 A0  1 11 42 61 62 
1A4FD90 	62 6C 65 20 44 65 74 65 
1A4FD98 	63 74 65 64 3B 20  0  0 
1A4FDA0 	 C 2E A4  1 14 41 A4  1 
   dup TD_STAT_CRCTIME  and  if  " CRC/Timeout Error; "  USB_ERR_CRC set-usb-error          then
1A4FDA8 	40 49 A0  1 6C F3 A4  1 
1A4FDB0 	5C 44 A0  1 DC 41 A0  1 
1A4FDB8 	28  0  0  0 9C 53 A0  1 
1A4FDC0 	13 43 52 43 2F 54 69 6D 
1A4FDC8 	65 6F 75 74 20 45 72 72 
1A4FDD0 	6F 72 3B 20  0  0  0  0 
1A4FDD8 	34 2C A4  1 14 41 A4  1 
   dup TD_STAT_BITSTUFF and  if  " Bitstuff Error; "     USB_ERR_BITSTUFFING set-usb-error  then
1A4FDE0 	40 49 A0  1 8C F3 A4  1 
1A4FDE8 	5C 44 A0  1 DC 41 A0  1 
1A4FDF0 	24  0  0  0 9C 53 A0  1 
1A4FDF8 	10 42 69 74 73 74 75 66 
1A4FE00 	66 20 45 72 72 6F 72 3B 
1A4FE08 	20  0  0  0 54 2C A4  1 
1A4FE10 	14 41 A4  1 
       TD_STAT_NAK      and  if  " NAK"                  USB_ERR_NAK set-usb-error          then
1A4FE14 	50 F3 A4  1 
1A4FE18 	5C 44 A0  1 DC 41 A0  1 
1A4FE20 	18  0  0  0 9C 53 A0  1 
1A4FE28 	 3 4E 41 4B  0  0  0  0 
1A4FE30 	24 2E A4  1 14 41 A4  1 
;
1A4FE38 	58 46 A0  1 

: qh-done?  ( qh -- done? )  >hcqh-elem le-l@  TERMINATE and  ;
1A4FE3C 	 0  0  0 71 
1A4FE40 	68 2D 64 6F 6E 65 3F 88 
1A4FE48 	 C FD A4  1 20 40 A0  1 
1A4FE50 	DC EF A4  1 B8 35 A4  1 
1A4FE58 	BC EE A4  1 5C 44 A0  1 
1A4FE60 	58 46 A0  1 

: done?  ( qh -- error? )
1A4FE64 	 0  0 64 6F 
1A4FE68 	6E 65 3F 85 4C FE A4  1 
1A4FE70 	20 40 A0  1 
   begin
      process-hc-status  usb-error  if
1A4FE74 	E0 FC A4  1 
1A4FE78 	D0 40 A4  1 DC 41 A0  1 
1A4FE80 	10  0  0  0 
         true
1A4FE84 	 4 70 A0  1 
      else
1A4FE88 	C8 41 A0  1 44  0  0  0 
         dup pull-qhtds
1A4FE90 	40 49 A0  1 C4 FA A4  1 
         dup qh-done? ?dup 0=   if
1A4FE98 	40 49 A0  1 4C FE A4  1 
1A4FEA0 	B4 70 A0  1 24 47 A0  1 
1A4FEA8 	DC 41 A0  1 24  0  0  0 
            1 ms
1A4FEB0 	80 6F A0  1 60 E0 A1  1 
	    timeout 1- dup to timeout 0=
1A4FEB8 	F4 FC A4  1 54 4B A0  1 
1A4FEC0 	40 49 A0  1 B8 40 A0  1 
1A4FEC8 	F4 FC A4  1 24 47 A0  1 
         then
      then
   until
1A4FED0 	DC 41 A0  1 A0 FF FF FF 

   ( qh ) dup qh-done? 0=  if
1A4FED8 	40 49 A0  1 4C FE A4  1 
1A4FEE0 	24 47 A0  1 DC 41 A0  1 
1A4FEE8 	40  0  0  0 
      " Timeout" USB_ERR_TIMEOUT set-usb-error
1A4FEEC 	9C 53 A0  1 
1A4FEF0 	 7 54 69 6D 65 6F 75 74 
1A4FEF8 	 0  0  0  0 B8 2E A4  1 
1A4FF00 	14 41 A4  1 
      TERMINATE over >hcqh-elem le-l!		\ Terminate QH
1A4FF04 	BC EE A4  1 
1A4FF08 	54 49 A0  1 DC EF A4  1 
1A4FF10 	50 36 A4  1 
      push-qhtds
1A4FF14 	90 FA A4  1 
      1 ms
1A4FF18 	80 6F A0  1 60 E0 A1  1 
   else
1A4FF20 	C8 41 A0  1  8  0  0  0 
      drop
1A4FF28 	30 49 A0  1 
   then
   usb-error
1A4FF2C 	D0 40 A4  1 
;
1A4FF30 	58 46 A0  1 

: error?  ( td -- error? )
1A4FF34 	 0 65 72 72 
1A4FF38 	6F 72 3F 86 70 FE A4  1 
1A4FF40 	20 40 A0  1 
   false swap  begin				( error? td )
1A4FF44 	18 70 A0  1 
1A4FF48 	68 49 A0  1 
      dup >hctd-stat le-l@ TD_STAT_ANY_ERROR and ?dup  if
1A4FF4C 	40 49 A0  1 
1A4FF50 	DC F0 A4  1 B8 35 A4  1 
1A4FF58 	C8 F3 A4  1 5C 44 A0  1 
1A4FF60 	B4 70 A0  1 DC 41 A0  1 
1A4FF68 	1C  0  0  0 
         .td-error
1A4FF6C 	 C FD A4  1 
         2drop true 0				( error? stop )
1A4FF70 	AC 49 A0  1  4 70 A0  1 
1A4FF78 	70 6F A0  1 
      else					( error? td )
1A4FF7C 	C8 41 A0  1 
1A4FF80 	 C  0  0  0 
         >td-next l@				( error? td' )
1A4FF84 	50 F1 A4  1 
1A4FF88 	6C 4C A0  1 
      then
   ?dup 0=  until
1A4FF8C 	B4 70 A0  1 
1A4FF90 	24 47 A0  1 DC 41 A0  1 
1A4FF98 	B4 FF FF FF 
;
1A4FF9C 	58 46 A0  1 

: get-actual  ( td #td -- actual )
1A4FFA0 	 0 67 65 74 2D 61 63 74 
1A4FFA8 	75 61 6C 8A 40 FF A4  1 
1A4FFB0 	20 40 A0  1 
   0 -rot 0  ?do				( actual td )
1A4FFB4 	70 6F A0  1 
1A4FFB8 	94 49 A0  1 70 6F A0  1 
1A4FFC0 	50 42 A0  1 80  0  0  0 
      dup >hctd-stat le-l@ dup TD_STAT_ACTIVE and 0=  if
1A4FFC8 	40 49 A0  1 DC F0 A4  1 
1A4FFD0 	B8 35 A4  1 40 49 A0  1 
1A4FFD8 	E4 F2 A4  1 5C 44 A0  1 
1A4FFE0 	24 47 A0  1 DC 41 A0  1 
1A4FFE8 	48  0  0  0 
         TD_ACTUAL_MASK and                     ( actual td size-code )
1A4FFEC 	 4 F4 A4  1 
1A4FFF0 	5C 44 A0  1 
         dup TD_NULL_DATA_SIZE =  if  drop 0  else  1+  then  ( actual td this-size )
1A4FFF4 	40 49 A0  1 
1A4FFF8 	E8 F3 A4  1 24 48 A0  1 
1A50000 	DC 41 A0  1 14  0  0  0 
1A50008 	30 49 A0  1 70 6F A0  1 
1A50010 	C8 41 A0  1  8  0  0  0 
1A50018 	30 4B A0  1 
         rot + swap				( actual' td )
1A5001C 	7C 49 A0  1 
1A50020 	 4 45 A0  1 68 49 A0  1 
      else  drop  then
1A50028 	C8 41 A0  1  8  0  0  0 
1A50030 	30 49 A0  1 
      >td-next l@				( actual td' )
1A50034 	50 F1 A4  1 
1A50038 	6C 4C A0  1 
   loop  drop					( actual )
1A5003C 	F8 41 A0  1 
1A50040 	88 FF FF FF 30 49 A0  1 
;
1A50048 	58 46 A0  1 

headers

OpenFirmware/dev/usb2/hcd/uhci/qhtd.fth_AL	11A0 1A5004C h# 400 constant /regs
1A5004C 	 0  0 2F 72 
1A50050 	65 67 73 85 B0 FF A4  1 
1A50058 	68 40 A0  1  0  4  0  0 


: my-b@  ( offset -- b )  my-space +  " config-b@" $call-parent  ;
1A50060 	 0  0 6D 79 2D 62 40 85 
1A50068 	58  0 A5  1 20 40 A0  1 
1A50070 	AC  3 A2  1  4 45 A0  1 
1A50078 	9C 53 A0  1  9 63 6F 6E 
1A50080 	66 69 67 2D 62 40  0  0 
1A50088 	DC 31 A2  1 58 46 A0  1 
: my-b!  ( b offset -- )  my-space +  " config-b!" $call-parent  ;
1A50090 	 0  0 6D 79 2D 62 21 85 
1A50098 	6C  0 A5  1 20 40 A0  1 
1A500A0 	AC  3 A2  1  4 45 A0  1 
1A500A8 	9C 53 A0  1  9 63 6F 6E 
1A500B0 	66 69 67 2D 62 21  0  0 
1A500B8 	DC 31 A2  1 58 46 A0  1 

: my-w@  ( offset -- w )  my-space +  " config-w@" $call-parent  ;
1A500C0 	 0  0 6D 79 2D 77 40 85 
1A500C8 	9C  0 A5  1 20 40 A0  1 
1A500D0 	AC  3 A2  1  4 45 A0  1 
1A500D8 	9C 53 A0  1  9 63 6F 6E 
1A500E0 	66 69 67 2D 77 40  0  0 
1A500E8 	DC 31 A2  1 58 46 A0  1 
: my-w!  ( w offset -- )  my-space +  " config-w!" $call-parent  ;
1A500F0 	 0  0 6D 79 2D 77 21 85 
1A500F8 	CC  0 A5  1 20 40 A0  1 
1A50100 	AC  3 A2  1  4 45 A0  1 
1A50108 	9C 53 A0  1  9 63 6F 6E 
1A50110 	66 69 67 2D 77 21  0  0 
1A50118 	DC 31 A2  1 58 46 A0  1 

: my-l@  ( offset -- l )  my-space +  " config-l@" $call-parent  ;
1A50120 	 0  0 6D 79 2D 6C 40 85 
1A50128 	FC  0 A5  1 20 40 A0  1 
1A50130 	AC  3 A2  1  4 45 A0  1 
1A50138 	9C 53 A0  1  9 63 6F 6E 
1A50140 	66 69 67 2D 6C 40  0  0 
1A50148 	DC 31 A2  1 58 46 A0  1 
: my-l!  ( l offset -- )  my-space +  " config-l!" $call-parent  ;
1A50150 	 0  0 6D 79 2D 6C 21 85 
1A50158 	2C  1 A5  1 20 40 A0  1 
1A50160 	AC  3 A2  1  4 45 A0  1 
1A50168 	9C 53 A0  1  9 63 6F 6E 
1A50170 	66 69 67 2D 6C 21  0  0 
1A50178 	DC 31 A2  1 58 46 A0  1 


: my-map-in  ( len -- adr )
1A50180 	 0  0 6D 79 2D 6D 61 70 
1A50188 	2D 69 6E 89 5C  1 A5  1 
1A50190 	20 40 A0  1 
   >r
1A50194 	BC 45 A0  1 
   0 0 my-space h# 01000020 +  r>  " map-in" $call-parent  ( adr )
1A50198 	70 6F A0  1 70 6F A0  1 
1A501A0 	AC  3 A2  1 58 41 A0  1 
1A501A8 	20  0  0  1  4 45 A0  1 
1A501B0 	D0 45 A0  1 9C 53 A0  1 
1A501B8 	 6 6D 61 70 2D 69 6E  0 
1A501C0 	DC 31 A2  1 
   4 my-w@  h# 17 or  4 my-w!                               ( adr )
1A501C4 	B0 6F A0  1 
1A501C8 	CC  0 A5  1 58 41 A0  1 
1A501D0 	17  0  0  0 70 44 A0  1 
1A501D8 	B0 6F A0  1 FC  0 A5  1 
;
1A501E0 	58 46 A0  1 
: my-map-out  ( adr len -- )
1A501E4 	 0 6D 79 2D 
1A501E8 	6D 61 70 2D 6F 75 74 8A 
1A501F0 	90  1 A5  1 20 40 A0  1 
   4 my-w@  7 invert and  4 my-w!   ( adr len )
1A501F8 	B0 6F A0  1 CC  0 A5  1 
1A50200 	E0 6F A0  1 30 45 A0  1 
1A50208 	5C 44 A0  1 B0 6F A0  1 
1A50210 	FC  0 A5  1 
   " map-out" $call-parent          ( )
1A50214 	9C 53 A0  1 
1A50218 	 7 6D 61 70 2D 6F 75 74 
1A50220 	 0  0  0  0 DC 31 A2  1 
;
1A50228 	58 46 A0  1 

: ?disable-smis  ( -- )
1A5022C 	 0  0 3F 64 
1A50230 	69 73 61 62 6C 65 2D 73 
1A50238 	6D 69 73 8D F4  1 A5  1 
1A50240 	20 40 A0  1 
   0 my-l@ h# 27c88086 =  if   h# af00 h# 80 my-w!  then
1A50244 	70 6F A0  1 
1A50248 	2C  1 A5  1 58 41 A0  1 
1A50250 	86 80 C8 27 24 48 A0  1 
1A50258 	DC 41 A0  1 18  0  0  0 
1A50260 	58 41 A0  1  0 AF  0  0 
1A50268 	58 41 A0  1 80  0  0  0 
1A50270 	FC  0 A5  1 
;
1A50274 	58 46 A0  1 

OpenFirmware/dev/usb2/hcd/uhci/pci.fth_AL	22C 1A50278 purpose: Driver for UHCI USB Controller

hex
headers

defer end-extra			' noop to end-extra
1A50278 	 0  0 65 6E 64 2D 65 78 
1A50280 	74 72 61 89 40  2 A5  1 
1A50288 	5C 40 A0  1 58  E  0  0 

true value first-open?
1A50290 	66 69 72 73 74 2D 6F 70 
1A50298 	65 6E 3F 8B 88  2 A5  1 
1A502A0 	50 40 A0  1 5C  E  0  0 
0 value open-count
1A502A8 	 0 6F 70 65 6E 2D 63 6F 
1A502B0 	75 6E 74 8A A0  2 A5  1 
1A502B8 	50 40 A0  1 60  E  0  0 
0 value uhci-reg
1A502C0 	 0  0  0 75 68 63 69 2D 
1A502C8 	72 65 67 88 B8  2 A5  1 
1A502D0 	50 40 A0  1 64  E  0  0 

: map-regs  ( -- )  /regs my-map-in to uhci-reg  ;
1A502D8 	 0  0  0 6D 61 70 2D 72 
1A502E0 	65 67 73 88 D0  2 A5  1 
1A502E8 	20 40 A0  1 58  0 A5  1 
1A502F0 	90  1 A5  1 B8 40 A0  1 
1A502F8 	D0  2 A5  1 58 46 A0  1 

: unmap-regs  ( -- )
1A50300 	 0 75 6E 6D 61 70 2D 72 
1A50308 	65 67 73 8A E8  2 A5  1 
1A50310 	20 40 A0  1 
   uhci-reg  /regs  my-map-out  0 to uhci-reg
1A50314 	D0  2 A5  1 
1A50318 	58  0 A5  1 F4  1 A5  1 
1A50320 	70 6F A0  1 B8 40 A0  1 
1A50328 	D0  2 A5  1 
;
1A5032C 	58 46 A0  1 

: uhci-b@  ( idx -- data )  uhci-reg + rb@  ;
1A50330 	75 68 63 69 2D 62 40 87 
1A50338 	10  3 A5  1 20 40 A0  1 
1A50340 	D0  2 A5  1  4 45 A0  1 
1A50348 	A8 B1 A2  1 58 46 A0  1 
: uhci-b!  ( data idx -- )  uhci-reg + rb!  ;
1A50350 	75 68 63 69 2D 62 21 87 
1A50358 	3C  3 A5  1 20 40 A0  1 
1A50360 	D0  2 A5  1  4 45 A0  1 
1A50368 	1C B2 A2  1 58 46 A0  1 
: uhci-w@  ( idx -- data )  uhci-reg + rw@  ;
1A50370 	75 68 63 69 2D 77 40 87 
1A50378 	5C  3 A5  1 20 40 A0  1 
1A50380 	D0  2 A5  1  4 45 A0  1 
1A50388 	D0 B1 A2  1 58 46 A0  1 
: uhci-w!  ( data idx -- )  uhci-reg + rw!  ;
1A50390 	75 68 63 69 2D 77 21 87 
1A50398 	7C  3 A5  1 20 40 A0  1 
1A503A0 	D0  2 A5  1  4 45 A0  1 
1A503A8 	40 B2 A2  1 58 46 A0  1 
: uhci-l@  ( idx -- data )  uhci-reg + rl@  ;
1A503B0 	75 68 63 69 2D 6C 40 87 
1A503B8 	9C  3 A5  1 20 40 A0  1 
1A503C0 	D0  2 A5  1  4 45 A0  1 
1A503C8 	F8 B1 A2  1 58 46 A0  1 
: uhci-l!  ( data idx -- )  uhci-reg + rl!  ;
1A503D0 	75 68 63 69 2D 6C 21 87 
1A503D8 	BC  3 A5  1 20 40 A0  1 
1A503E0 	D0  2 A5  1  4 45 A0  1 
1A503E8 	68 B2 A2  1 58 46 A0  1 

: usbcmd@     ( -- data )   0 uhci-w@  ;
1A503F0 	75 73 62 63 6D 64 40 87 
1A503F8 	DC  3 A5  1 20 40 A0  1 
1A50400 	70 6F A0  1 7C  3 A5  1 
1A50408 	58 46 A0  1 
: usbcmd!     ( data -- )   0 uhci-w!  ;
1A5040C 	75 73 62 63 
1A50410 	6D 64 21 87 FC  3 A5  1 
1A50418 	20 40 A0  1 70 6F A0  1 
1A50420 	9C  3 A5  1 58 46 A0  1 
: usbsts@     ( -- data )   2 uhci-w@  ;
1A50428 	75 73 62 73 74 73 40 87 
1A50430 	18  4 A5  1 20 40 A0  1 
1A50438 	90 6F A0  1 7C  3 A5  1 
1A50440 	58 46 A0  1 
: usbsts!     ( data -- )   2 uhci-w!  ;
1A50444 	75 73 62 73 
1A50448 	74 73 21 87 34  4 A5  1 
1A50450 	20 40 A0  1 90 6F A0  1 
1A50458 	9C  3 A5  1 58 46 A0  1 
: usbintr@    ( -- data )   4 uhci-w@  ;
1A50460 	 0  0  0 75 73 62 69 6E 
1A50468 	74 72 40 88 50  4 A5  1 
1A50470 	20 40 A0  1 B0 6F A0  1 
1A50478 	7C  3 A5  1 58 46 A0  1 
: usbintr!    ( data -- )   4 uhci-w!  ;
1A50480 	 0  0  0 75 73 62 69 6E 
1A50488 	74 72 21 88 70  4 A5  1 
1A50490 	20 40 A0  1 B0 6F A0  1 
1A50498 	9C  3 A5  1 58 46 A0  1 
: frnum@      ( -- data )   6 uhci-w@  ;
1A504A0 	 0 66 72 6E 75 6D 40 86 
1A504A8 	90  4 A5  1 20 40 A0  1 
1A504B0 	D0 6F A0  1 7C  3 A5  1 
1A504B8 	58 46 A0  1 
: frnum!      ( data -- )   6 uhci-w!  ;
1A504BC 	 0 66 72 6E 
1A504C0 	75 6D 21 86 AC  4 A5  1 
1A504C8 	20 40 A0  1 D0 6F A0  1 
1A504D0 	9C  3 A5  1 58 46 A0  1 
: flbaseadd@  ( -- data )   8 uhci-l@  ;
1A504D8 	 0 66 6C 62 61 73 65 61 
1A504E0 	64 64 40 8A C8  4 A5  1 
1A504E8 	20 40 A0  1 F0 6F A0  1 
1A504F0 	BC  3 A5  1 58 46 A0  1 
: flbaseadd!  ( data -- )   8 uhci-l!  ;
1A504F8 	 0 66 6C 62 61 73 65 61 
1A50500 	64 64 21 8A E8  4 A5  1 
1A50508 	20 40 A0  1 F0 6F A0  1 
1A50510 	DC  3 A5  1 58 46 A0  1 
: sof@        ( -- data )   c uhci-b@  ;
1A50518 	 0  0  0 73 6F 66 40 84 
1A50520 	 8  5 A5  1 20 40 A0  1 
1A50528 	58 41 A0  1  C  0  0  0 
1A50530 	3C  3 A5  1 58 46 A0  1 
: sof!        ( data -- )   c uhci-b!  ;
1A50538 	 0  0  0 73 6F 66 21 84 
1A50540 	24  5 A5  1 20 40 A0  1 
1A50548 	58 41 A0  1  C  0  0  0 
1A50550 	5C  3 A5  1 58 46 A0  1 
: portsc@     ( port -- data )  2* 10 + uhci-w@  ;
1A50558 	70 6F 72 74 73 63 40 87 
1A50560 	44  5 A5  1 20 40 A0  1 
1A50568 	A0 4B A0  1 58 41 A0  1 
1A50570 	10  0  0  0  4 45 A0  1 
1A50578 	7C  3 A5  1 58 46 A0  1 
: portsc!     ( data port -- )  2* 10 + uhci-w!  ;
1A50580 	70 6F 72 74 73 63 21 87 
1A50588 	64  5 A5  1 20 40 A0  1 
1A50590 	A0 4B A0  1 58 41 A0  1 
1A50598 	10  0  0  0  4 45 A0  1 
1A505A0 	9C  3 A5  1 58 46 A0  1 

\ We mustn't wait more than 3 ms between releasing the reset and enabling
\ the port to begin the SOF stream, otherwise some devices (e.g. pl2303)
\ will go into suspend state and then not respond to set-address.
: reset-port  ( port -- )
1A505A8 	 0 72 65 73 65 74 2D 70 
1A505B0 	6F 72 74 8A 8C  5 A5  1 
1A505B8 	20 40 A0  1 
   dup >r  portsc@ h# 20e invert and    ( value r: port )  \ Clear reset, enable, status
1A505BC 	40 49 A0  1 
1A505C0 	BC 45 A0  1 64  5 A5  1 
1A505C8 	58 41 A0  1  E  2  0  0 
1A505D0 	30 45 A0  1 5C 44 A0  1 
   dup h# 200 or  r@ portsc!	        ( value r: port )  \ Reset port
1A505D8 	40 49 A0  1 58 41 A0  1 
1A505E0 	 0  2  0  0 70 44 A0  1 
1A505E8 	E4 45 A0  1 8C  5 A5  1 
   d# 30 ms                             ( value r: port )  \ > 10 ms - reset time
1A505F0 	58 41 A0  1 1E  0  0  0 
1A505F8 	60 E0 A1  1 
   dup r@ portsc!                       ( value r: port )  \ Release reset
1A505FC 	40 49 A0  1 
1A50600 	E4 45 A0  1 8C  5 A5  1 
   1 ms                                 ( value r: port )  \ > 5.3 uS - reconnect time
1A50608 	80 6F A0  1 60 E0 A1  1 
   h# e or  r> portsc!	                ( )  \ Enable port and clear status
1A50610 	58 41 A0  1  E  0  0  0 
1A50618 	70 44 A0  1 D0 45 A0  1 
1A50620 	8C  5 A5  1 
;
1A50624 	58 46 A0  1 

: reset-usb  ( -- )
1A50628 	 0  0 72 65 73 65 74 2D 
1A50630 	75 73 62 89 B8  5 A5  1 
1A50638 	20 40 A0  1 
   uhci-reg dup 0=  if  map-regs  then
1A5063C 	D0  2 A5  1 
1A50640 	40 49 A0  1 24 47 A0  1 
1A50648 	DC 41 A0  1  8  0  0  0 
1A50650 	E8  2 A5  1 
   4 usbcmd!			\ Global reset
1A50654 	B0 6F A0  1 
1A50658 	18  4 A5  1 
   50 ms
1A5065C 	58 41 A0  1 
1A50660 	50  0  0  0 60 E0 A1  1 
   0 usbcmd!
1A50668 	70 6F A0  1 18  4 A5  1 
   10 ms
1A50670 	58 41 A0  1 10  0  0  0 
1A50678 	60 E0 A1  1 

   2 usbcmd!			\ Host reset
1A5067C 	90 6F A0  1 
1A50680 	18  4 A5  1 
   d# 10 0  do
1A50684 	58 41 A0  1 
1A50688 	 A  0  0  0 70 6F A0  1 
1A50690 	88 42 A0  1 28  0  0  0 
      usbcmd@ 2 and  0=  ?leave
1A50698 	FC  3 A5  1 90 6F A0  1 
1A506A0 	5C 44 A0  1 24 47 A0  1 
1A506A8 	34 43 A0  1 
      1 ms
1A506AC 	80 6F A0  1 
1A506B0 	60 E0 A1  1 
   loop
1A506B4 	F8 41 A0  1 
1A506B8 	E0 FF FF FF 
   0=  if  unmap-regs  then
1A506BC 	24 47 A0  1 
1A506C0 	DC 41 A0  1  8  0  0  0 
1A506C8 	10  3 A5  1 
;
1A506CC 	58 46 A0  1 

: (process-hc-status)  ( -- )
1A506D0 	28 70 72 6F 63 65 73 73 
1A506D8 	2D 68 63 2D 73 74 61 74 
1A506E0 	75 73 29 93 38  6 A5  1 
1A506E8 	20 40 A0  1 
   usbsts@ dup h# 3e and usbsts!	\ Clear errors and interrupts
1A506EC 	34  4 A5  1 
1A506F0 	40 49 A0  1 58 41 A0  1 
1A506F8 	3E  0  0  0 5C 44 A0  1 
1A50700 	50  4 A5  1 
   38 and ?dup  if
1A50704 	58 41 A0  1 
1A50708 	38  0  0  0 5C 44 A0  1 
1A50710 	B4 70 A0  1 DC 41 A0  1 
1A50718 	C4  0  0  0 
      usbcmd@ 1 or usbcmd!		\ Exit halted state
1A5071C 	FC  3 A5  1 
1A50720 	80 6F A0  1 70 44 A0  1 
1A50728 	18  4 A5  1 
      dup 20 and  if  " Host controller halted"  USB_ERR_HCHALTED set-usb-error  then
1A5072C 	40 49 A0  1 
1A50730 	58 41 A0  1 20  0  0  0 
1A50738 	5C 44 A0  1 DC 41 A0  1 
1A50740 	28  0  0  0 9C 53 A0  1 
1A50748 	16 48 6F 73 74 20 63 6F 
1A50750 	6E 74 72 6F 6C 6C 65 72 
1A50758 	20 68 61 6C 74 65 64  0 
1A50760 	D4 2D A4  1 14 41 A4  1 
      dup 10 and  if  " Host controller process error"  USB_ERR_HCERROR set-usb-error  then
1A50768 	40 49 A0  1 58 41 A0  1 
1A50770 	10  0  0  0 5C 44 A0  1 
1A50778 	DC 41 A0  1 30  0  0  0 
1A50780 	9C 53 A0  1 1D 48 6F 73 
1A50788 	74 20 63 6F 6E 74 72 6F 
1A50790 	6C 6C 65 72 20 70 72 6F 
1A50798 	63 65 73 73 20 65 72 72 
1A507A0 	6F 72  0  0 7C 2E A4  1 
1A507A8 	14 41 A4  1 
           8 and  if  " Host system error"  USB_ERR_HOSTERROR set-usb-error  then
1A507AC 	F0 6F A0  1 
1A507B0 	5C 44 A0  1 DC 41 A0  1 
1A507B8 	24  0  0  0 9C 53 A0  1 
1A507C0 	11 48 6F 73 74 20 73 79 
1A507C8 	73 74 65 6D 20 65 72 72 
1A507D0 	6F 72  0  0 9C 2E A4  1 
1A507D8 	14 41 A4  1 
   then
;
1A507DC 	58 46 A0  1 
' (process-hc-status) to process-hc-status

external
\ Kick the USB controller into operation mode.
: start-usb     ( -- )
1A507E0 	 0  0 73 74 61 72 74 2D 
1A507E8 	75 73 62 89 E8  6 A5  1 
1A507F0 	20 40 A0  1 
   0 frnum!			\ Start at frame 0
1A507F4 	70 6F A0  1 
1A507F8 	C8  4 A5  1 
   framelist-phys flbaseadd!
1A507FC 	60 EF A4  1 
1A50800 	 8  5 A5  1 
   h# c1 usbcmd!		\ Run, Config, Max Packet=64
1A50804 	58 41 A0  1 
1A50808 	C1  0  0  0 18  4 A5  1 
;
1A50810 	58 46 A0  1 
: stop-usb  ( -- )  h# c0 usbcmd!  ;
1A50814 	 0  0  0 73 
1A50818 	74 6F 70 2D 75 73 62 88 
1A50820 	F0  7 A5  1 20 40 A0  1 
1A50828 	58 41 A0  1 C0  0  0  0 
1A50830 	18  4 A5  1 58 46 A0  1 
: suspend-usb   ( -- )  ;
1A50838 	73 75 73 70 65 6E 64 2D 
1A50840 	75 73 62 8B 24  8 A5  1 
1A50848 	20 40 A0  1 58 46 A0  1 

OpenFirmware/dev/usb2/hcd/uhci/uhci.fth_AL	5D8 1A50850 purpose: UHCI USB Controller control pipe transaction processing

hex
headers

\ Local temporary variables (common for control, bulk & interrupt)

\ my-dev and my-real-dev are created here to deal with set-address.
\ Normally my-dev and my-real-dev are both of the value of target.
\ However, during set-address, target=my-dev=0, my-real-dev is the
\ address to be assigned to my-real-dev.  The correct path to get
\ a device's characteristics is via my-real-dev.

0 value my-dev					\ Equals to target
1A50850 	 0 6D 79 2D 64 65 76 86 
1A50858 	48  8 A5  1 50 40 A0  1 
1A50860 	68  E  0  0 
0 value my-real-dev				\ Path to dev's characteristics
1A50864 	6D 79 2D 72 
1A50868 	65 61 6C 2D 64 65 76 8B 
1A50870 	5C  8 A5  1 50 40 A0  1 
1A50878 	6C  E  0  0 
0 value my-dev/pipe				\ Device/pipe for ED
1A5087C 	6D 79 2D 64 
1A50880 	65 76 2F 70 69 70 65 8B 
1A50888 	74  8 A5  1 50 40 A0  1 
1A50890 	70  E  0  0 

0 value my-speed				\ Speed of my-real-dev
1A50894 	 0  0  0 6D 
1A50898 	79 2D 73 70 65 65 64 88 
1A508A0 	8C  8 A5  1 50 40 A0  1 
1A508A8 	74  E  0  0 
0 value my-maxpayload				\ Pipe's max payload
1A508AC 	 0  0 6D 79 
1A508B0 	2D 6D 61 78 70 61 79 6C 
1A508B8 	6F 61 64 8D A4  8 A5  1 
1A508C0 	50 40 A0  1 78  E  0  0 

0 value my-#tds					\ # of input or output qTDs
1A508C8 	6D 79 2D 23 74 64 73 87 
1A508D0 	C0  8 A5  1 50 40 A0  1 
1A508D8 	7C  E  0  0 

0 value my-buf					\ Virtual address of data buffer
1A508DC 	 0 6D 79 2D 
1A508E0 	62 75 66 86 D4  8 A5  1 
1A508E8 	50 40 A0  1 80  E  0  0 
0 value my-buf-phys				\ Physical address of data buffer
1A508F0 	6D 79 2D 62 75 66 2D 70 
1A508F8 	68 79 73 8B E8  8 A5  1 
1A50900 	50 40 A0  1 84  E  0  0 
0 value /my-buf					\ Size of data buffer
1A50908 	2F 6D 79 2D 62 75 66 87 
1A50910 	 0  9 A5  1 50 40 A0  1 
1A50918 	88  E  0  0 

0 value my-td					\ Current TD head
1A5091C 	 0  0 6D 79 
1A50920 	2D 74 64 85 14  9 A5  1 
1A50928 	50 40 A0  1 8C  E  0  0 
0 value my-qh					\ Current QH
1A50930 	 0  0 6D 79 2D 71 68 85 
1A50938 	28  9 A5  1 50 40 A0  1 
1A50940 	90  E  0  0 

: set-real-dev  ( real-dev target -- )		\ For set-address only
1A50944 	 0  0  0 73 
1A50948 	65 74 2D 72 65 61 6C 2D 
1A50950 	64 65 76 8C 3C  9 A5  1 
1A50958 	20 40 A0  1 
   to my-dev to my-real-dev
1A5095C 	B8 40 A0  1 
1A50960 	5C  8 A5  1 B8 40 A0  1 
1A50968 	74  8 A5  1 
;
1A5096C 	58 46 A0  1 

: set-my-char  ( pipe -- )
1A50970 	73 65 74 2D 6D 79 2D 63 
1A50978 	68 61 72 8B 58  9 A5  1 
1A50980 	20 40 A0  1 
   dup d# 15 << my-dev 8 << or to my-dev/pipe	( pipe )
1A50984 	40 49 A0  1 
1A50988 	58 41 A0  1  F  0  0  0 
1A50990 	C8 44 A0  1 5C  8 A5  1 
1A50998 	F0 6F A0  1 C8 44 A0  1 
1A509A0 	70 44 A0  1 B8 40 A0  1 
1A509A8 	8C  8 A5  1 
   my-real-dev dup di-speed@			( pipe dev speed )
1A509AC 	74  8 A5  1 
1A509B0 	40 49 A0  1  4 43 A4  1 
   speed-low =  if  TD_CTRL_LOW  else  TD_CTRL_FULL  then  to my-speed
1A509B8 	74 2F A4  1 24 48 A0  1 
1A509C0 	DC 41 A0  1 10  0  0  0 
1A509C8 	7C F2 A4  1 C8 41 A0  1 
1A509D0 	 8  0  0  0 98 F2 A4  1 
1A509D8 	B8 40 A0  1 A4  8 A5  1 
   di-maxpayload@  to my-maxpayload		( )
1A509E0 	60 44 A4  1 B8 40 A0  1 
1A509E8 	C0  8 A5  1 
;
1A509EC 	58 46 A0  1 
: process-control-args  ( buf phy len -- )
1A509F0 	 0  0  0 70 72 6F 63 65 
1A509F8 	73 73 2D 63 6F 6E 74 72 
1A50A00 	6F 6C 2D 61 72 67 73 94 
1A50A08 	80  9 A5  1 20 40 A0  1 
   to /my-buf to my-buf-phys to my-buf
1A50A10 	B8 40 A0  1 14  9 A5  1 
1A50A18 	B8 40 A0  1  0  9 A5  1 
1A50A20 	B8 40 A0  1 E8  8 A5  1 
   clear-usb-error
1A50A28 	EC 40 A4  1 
   set-my-dev
1A50A2C 	14 52 A4  1 
   0 set-my-char
1A50A30 	70 6F A0  1 80  9 A5  1 
;
1A50A38 	58 46 A0  1 

: alloc-control-qhtds  ( extra-tds -- )
1A50A3C 	61 6C 6C 6F 
1A50A40 	63 2D 63 6F 6E 74 72 6F 
1A50A48 	6C 2D 71 68 74 64 73 93 
1A50A50 	 C  A A5  1 20 40 A0  1 
   >r
1A50A58 	BC 45 A0  1 
   my-maxpayload /my-buf    ( maxpayload /buf )
1A50A5C 	C0  8 A5  1 
1A50A60 	14  9 A5  1 
   over round-up            ( maxpayload /buf-rounded )
1A50A64 	54 49 A0  1 
1A50A68 	CC 36 A4  1 
   swap /  dup to my-#tds   ( maxpayload #tds )
1A50A6C 	68 49 A0  1 
1A50A70 	98 5F A0  1 40 49 A0  1 
1A50A78 	B8 40 A0  1 D4  8 A5  1 
   dup  if  data-timeout  else  nodata-timeout  then  to timeout  ( maxpayload #tds )
1A50A80 	40 49 A0  1 DC 41 A0  1 
1A50A88 	10  0  0  0  8 3C A4  1 
1A50A90 	C8 41 A0  1  8  0  0  0 
1A50A98 	EC 3B A4  1 B8 40 A0  1 
1A50AA0 	F4 FC A4  1 
   r> + alloc-qhtds  to my-td  to my-qh
1A50AA4 	D0 45 A0  1 
1A50AA8 	 4 45 A0  1 C0 F9 A4  1 
1A50AB0 	B8 40 A0  1 28  9 A5  1 
1A50AB8 	B8 40 A0  1 3C  9 A5  1 
;
1A50AC0 	58 46 A0  1 

: fill-setup-td  ( sbuf sphy slen -- )
1A50AC4 	 0  0 66 69 
1A50AC8 	6C 6C 2D 73 65 74 75 70 
1A50AD0 	2D 74 64 8D 54  A A5  1 
1A50AD8 	20 40 A0  1 
   TD_STAT_ACTIVE TD_CTRL_C_ERR3 or my-speed or
1A50ADC 	E4 F2 A4  1 
1A50AE0 	64 F2 A4  1 70 44 A0  1 
1A50AE8 	A4  8 A5  1 70 44 A0  1 
   my-td >hctd-stat le-l!
1A50AF0 	28  9 A5  1 DC F0 A4  1 
1A50AF8 	50 36 A4  1 
   ( slen ) 1- d# 21 << TD_PID_SETUP or my-dev/pipe or
1A50AFC 	54 4B A0  1 
1A50B00 	58 41 A0  1 15  0  0  0 
1A50B08 	C8 44 A0  1 38 F4 A4  1 
1A50B10 	70 44 A0  1 8C  8 A5  1 
1A50B18 	70 44 A0  1 
   my-td >hctd-token le-l!
1A50B1C 	28  9 A5  1 
1A50B20 	F4 F0 A4  1 50 36 A4  1 
   ( sphy ) my-td 2dup >hctd-buf le-l!
1A50B28 	28  9 A5  1 C0 49 A0  1 
1A50B30 	 C F1 A4  1 50 36 A4  1 
   >td-pbuf l!
1A50B38 	7C F1 A4  1 7C 4D A0  1 
   ( sbuf ) my-td >td-buf l!
1A50B40 	28  9 A5  1 64 F1 A4  1 
1A50B48 	7C 4D A0  1 
;
1A50B4C 	58 46 A0  1 
: my-buf++ ( len -- )
1A50B50 	 0  0  0 6D 79 2D 62 75 
1A50B58 	66 2B 2B 88 D8  A A5  1 
1A50B60 	20 40 A0  1 
   /my-buf     over - to /my-buf
1A50B64 	14  9 A5  1 
1A50B68 	54 49 A0  1 18 45 A0  1 
1A50B70 	B8 40 A0  1 14  9 A5  1 
   my-buf-phys over + to my-buf-phys
1A50B78 	 0  9 A5  1 54 49 A0  1 
1A50B80 	 4 45 A0  1 B8 40 A0  1 
1A50B88 	 0  9 A5  1 
   my-buf      swap + to my-buf
1A50B8C 	E8  8 A5  1 
1A50B90 	68 49 A0  1  4 45 A0  1 
1A50B98 	B8 40 A0  1 E8  8 A5  1 
;
1A50BA0 	58 46 A0  1 
: fill-control-io-tds  ( dir -- std )
1A50BA4 	66 69 6C 6C 
1A50BA8 	2D 63 6F 6E 74 72 6F 6C 
1A50BB0 	2D 69 6F 2D 74 64 73 93 
1A50BB8 	60  B A5  1 20 40 A0  1 
   my-td >td-next l@				( dir td )
1A50BC0 	28  9 A5  1 50 F1 A4  1 
1A50BC8 	6C 4C A0  1 
   my-#tds 0  ?do				( dir td )
1A50BCC 	D4  8 A5  1 
1A50BD0 	70 6F A0  1 50 42 A0  1 
1A50BD8 	D0  0  0  0 
      TD_STAT_ACTIVE TD_CTRL_C_ERR3 or		( dir td stat )
1A50BDC 	E4 F2 A4  1 
1A50BE0 	64 F2 A4  1 70 44 A0  1 
      my-speed or				( dir td stat' )
1A50BE8 	A4  8 A5  1 70 44 A0  1 
      over >hctd-stat le-l!			( dir td )
1A50BF0 	54 49 A0  1 DC F0 A4  1 
1A50BF8 	50 36 A4  1 
      /my-buf my-maxpayload min dup 1- d# 21 <<	( dir td /buf token )
1A50BFC 	14  9 A5  1 
1A50C00 	C0  8 A5  1 74 4A A0  1 
1A50C08 	40 49 A0  1 54 4B A0  1 
1A50C10 	58 41 A0  1 15  0  0  0 
1A50C18 	C8 44 A0  1 
      i 1 and 0=  if  TD_TOKEN_DATA1 or  then   ( dir td /buf token' )
1A50C1C 	B4 42 A0  1 
1A50C20 	80 6F A0  1 5C 44 A0  1 
1A50C28 	24 47 A0  1 DC 41 A0  1 
1A50C30 	 C  0  0  0 84 F4 A4  1 
1A50C38 	70 44 A0  1 
      3 pick or my-dev/pipe or			( dir td /buf token' )
1A50C3C 	A0 6F A0  1 
1A50C40 	 C 4A A0  1 70 44 A0  1 
1A50C48 	8C  8 A5  1 70 44 A0  1 
      2 pick >hctd-token le-l!			( dir td /buf )
1A50C50 	90 6F A0  1  C 4A A0  1 
1A50C58 	F4 F0 A4  1 50 36 A4  1 
      my-buf-phys 2 pick 2dup >hctd-buf le-l!	( dir td /buf pbuf td )
1A50C60 	 0  9 A5  1 90 6F A0  1 
1A50C68 	 C 4A A0  1 C0 49 A0  1 
1A50C70 	 C F1 A4  1 50 36 A4  1 
      >td-pbuf l!				( dir td /buf )
1A50C78 	7C F1 A4  1 7C 4D A0  1 
      my-buf 2 pick >td-buf l!			( dir td /buf )
1A50C80 	E8  8 A5  1 90 6F A0  1 
1A50C88 	 C 4A A0  1 64 F1 A4  1 
1A50C90 	7C 4D A0  1 
      my-buf++					( dir td )
1A50C94 	60  B A5  1 
      >td-next l@				( dir td' )
1A50C98 	50 F1 A4  1 6C 4C A0  1 
   loop	 nip					( std )
1A50CA0 	F8 41 A0  1 38 FF FF FF 
1A50CA8 	FC 46 A0  1 
;
1A50CAC 	58 46 A0  1 
: fill-status-td  ( std control -- )
1A50CB0 	 0 66 69 6C 6C 2D 73 74 
1A50CB8 	61 74 75 73 2D 74 64 8E 
1A50CC0 	BC  B A5  1 20 40 A0  1 
   TD_NULL_DATA_SIZE d# 21 << or TD_TOKEN_DATA1 or
1A50CC8 	E8 F3 A4  1 58 41 A0  1 
1A50CD0 	15  0  0  0 C8 44 A0  1 
1A50CD8 	70 44 A0  1 84 F4 A4  1 
1A50CE0 	70 44 A0  1 
   my-dev/pipe or  over >hctd-token le-l!
1A50CE4 	8C  8 A5  1 
1A50CE8 	70 44 A0  1 54 49 A0  1 
1A50CF0 	F4 F0 A4  1 50 36 A4  1 
   TD_STAT_ACTIVE TD_CTRL_IOC or my-speed or
1A50CF8 	E4 F2 A4  1 C8 F2 A4  1 
1A50D00 	70 44 A0  1 A4  8 A5  1 
1A50D08 	70 44 A0  1 
   swap >hctd-stat le-l!
1A50D0C 	68 49 A0  1 
1A50D10 	DC F0 A4  1 50 36 A4  1 
;
1A50D18 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ CONTROL pipe operations
\ ---------------------------------------------------------------------------

: (control-get)  ( sbuf sphy slen buf phy len -- actual usberr )
1A50D1C 	 0  0 28 63 
1A50D20 	6F 6E 74 72 6F 6C 2D 67 
1A50D28 	65 74 29 8D C4  C A5  1 
1A50D30 	20 40 A0  1 
   process-control-args				( sbuf sphy slen )
1A50D34 	 C  A A5  1 
   /my-buf 0=  if  3drop 0 USB_ERR_INV_OP exit  then
1A50D38 	14  9 A5  1 24 47 A0  1 
1A50D40 	DC 41 A0  1 14  0  0  0 
1A50D48 	98 3F A4  1 70 6F A0  1 
1A50D50 	D4 2E A4  1 40 46 A0  1 
   2 alloc-control-qhtds			( sbuf sphy slen )
1A50D58 	90 6F A0  1 54  A A5  1 

   \ SETUP TD
   fill-setup-td				( )
1A50D60 	D8  A A5  1 

   \ IN TD
   TD_PID_IN fill-control-io-tds		( std )
1A50D64 	50 F4 A4  1 
1A50D68 	BC  B A5  1 

   \ Status TD (OUT)
   TD_PID_OUT fill-status-td			( )
1A50D6C 	68 F4 A4  1 
1A50D70 	C4  C A5  1 

   \ Start control transaction
   my-qh my-speed insert-ctrl-qh		( )
1A50D74 	3C  9 A5  1 
1A50D78 	A4  8 A5  1 54 FC A4  1 

   \ Process results
   my-qh done?  if
1A50D80 	3C  9 A5  1 70 FE A4  1 
1A50D88 	DC 41 A0  1 10  0  0  0 
      0						( actual )	\ System error, timeout
1A50D90 	70 6F A0  1 
   else
1A50D94 	C8 41 A0  1 
1A50D98 	5C  0  0  0 
      my-td error?  if
1A50D9C 	28  9 A5  1 
1A50DA0 	40 FF A4  1 DC 41 A0  1 
1A50DA8 	10  0  0  0 
         0					( actual )	\ USB error
1A50DAC 	70 6F A0  1 
      else
1A50DB0 	C8 41 A0  1 40  0  0  0 
         my-td >td-next l@ dup my-#tds get-actual		( td actual )
1A50DB8 	28  9 A5  1 50 F1 A4  1 
1A50DC0 	6C 4C A0  1 40 49 A0  1 
1A50DC8 	D4  8 A5  1 B0 FF A4  1 
         over >td-buf l@ rot >td-pbuf l@ 2 pick dma-pull	( actual )
1A50DD0 	54 49 A0  1 64 F1 A4  1 
1A50DD8 	6C 4C A0  1 7C 49 A0  1 
1A50DE0 	7C F1 A4  1 6C 4C A0  1 
1A50DE8 	90 6F A0  1  C 4A A0  1 
1A50DF0 	28 37 A4  1 
      then
   then

   my-qh dup remove-qh  free-qhtds		( actual )
1A50DF4 	3C  9 A5  1 
1A50DF8 	40 49 A0  1 D8 FB A4  1 
1A50E00 	4C FA A4  1 
   usb-error					( actual usberr )
1A50E04 	D0 40 A4  1 
;
1A50E08 	58 46 A0  1 

: (control-set)  ( sbuf sphy slen buf phy len -- usberr )
1A50E0C 	 0  0 28 63 
1A50E10 	6F 6E 74 72 6F 6C 2D 73 
1A50E18 	65 74 29 8D 30  D A5  1 
1A50E20 	20 40 A0  1 
   process-control-args				( sbuf sphy slen )
1A50E24 	 C  A A5  1 
   2 alloc-control-qhtds			( sbuf sphy slen )
1A50E28 	90 6F A0  1 54  A A5  1 

   \ SETUP TD
   fill-setup-td				( )
1A50E30 	D8  A A5  1 

   \ OUT TD
   TD_PID_OUT fill-control-io-tds		( std )
1A50E34 	68 F4 A4  1 
1A50E38 	BC  B A5  1 

   \ Status TD (IN)
   TD_PID_IN fill-status-td			( )
1A50E3C 	50 F4 A4  1 
1A50E40 	C4  C A5  1 

   \ Start control transaction
   my-qh my-speed insert-ctrl-qh
1A50E44 	3C  9 A5  1 
1A50E48 	A4  8 A5  1 54 FC A4  1 

   \ Process results
   my-qh done? 0=  if   my-td error? drop  then
1A50E50 	3C  9 A5  1 70 FE A4  1 
1A50E58 	24 47 A0  1 DC 41 A0  1 
1A50E60 	10  0  0  0 28  9 A5  1 
1A50E68 	40 FF A4  1 30 49 A0  1 

   my-qh dup remove-qh  free-qhtds
1A50E70 	3C  9 A5  1 40 49 A0  1 
1A50E78 	D8 FB A4  1 4C FA A4  1 
   usb-error					( usberr )
1A50E80 	D0 40 A4  1 
;
1A50E84 	58 46 A0  1 

: (control-set-nostat)  ( sbuf sphy slen buf phy len -- usberr )
1A50E88 	 0  0  0 28 63 6F 6E 74 
1A50E90 	72 6F 6C 2D 73 65 74 2D 
1A50E98 	6E 6F 73 74 61 74 29 94 
1A50EA0 	20  E A5  1 20 40 A0  1 
   process-control-args				( sbuf sphy slen )
1A50EA8 	 C  A A5  1 
   1 alloc-control-qhtds			( sbuf sphy slen )
1A50EAC 	80 6F A0  1 
1A50EB0 	54  A A5  1 

   \ SETUP TD
   fill-setup-td				( )
1A50EB4 	D8  A A5  1 

   \ OUT TD
   TD_PID_OUT fill-control-io-tds drop		( )
1A50EB8 	68 F4 A4  1 BC  B A5  1 
1A50EC0 	30 49 A0  1 

   \ Start control transaction
   my-qh my-speed insert-ctrl-qh
1A50EC4 	3C  9 A5  1 
1A50EC8 	A4  8 A5  1 54 FC A4  1 

   \ Process results
   my-qh done? 0=  if   my-td error? drop  then
1A50ED0 	3C  9 A5  1 70 FE A4  1 
1A50ED8 	24 47 A0  1 DC 41 A0  1 
1A50EE0 	10  0  0  0 28  9 A5  1 
1A50EE8 	40 FF A4  1 30 49 A0  1 

   my-qh dup remove-qh  free-qhtds
1A50EF0 	3C  9 A5  1 40 49 A0  1 
1A50EF8 	D8 FB A4  1 4C FA A4  1 
   usb-error					( usberr )
1A50F00 	D0 40 A4  1 
;
1A50F04 	58 46 A0  1 

headers

OpenFirmware/dev/usb2/hcd/uhci/control.fth_AL	6B8 1A50F08 purpose: UHCI USB Controller bulk pipes transaction processing

: bulkfth
1A50F08 	62 75 6C 6B 66 74 68 87 
1A50F10 	A4  E A5  1 20 40 A0  1 
hex
1A50F18 	C0 8D A0  1 

s" d# 500 instance value bulk-in-timeout" eval
1A50F1C 	9C 53 A0  1 
1A50F20 	25 64 23 20 35 30 30 20 
1A50F28 	69 6E 73 74 61 6E 63 65 
1A50F30 	20 76 61 6C 75 65 20 62 
1A50F38 	75 6C 6B 2D 69 6E 2D 74 
1A50F40 	69 6D 65 6F 75 74  0  0 
1A50F48 	D8 E5 A0  1 
s" d# 500 constant bulk-out-timeout" eval
1A50F4C 	9C 53 A0  1 
1A50F50 	20 64 23 20 35 30 30 20 
1A50F58 	63 6F 6E 73 74 61 6E 74 
1A50F60 	20 62 75 6C 6B 2D 6F 75 
1A50F68 	74 2D 74 69 6D 65 6F 75 
1A50F70 	74  0  0  0 D8 E5 A0  1 

s" 0 instance value bulk-in-pipe" eval
1A50F78 	9C 53 A0  1 1D 30 20 69 
1A50F80 	6E 73 74 61 6E 63 65 20 
1A50F88 	76 61 6C 75 65 20 62 75 
1A50F90 	6C 6B 2D 69 6E 2D 70 69 
1A50F98 	70 65  0  0 D8 E5 A0  1 
s" 0 instance value bulk-out-pipe" eval
1A50FA0 	9C 53 A0  1 1E 30 20 69 
1A50FA8 	6E 73 74 61 6E 63 65 20 
1A50FB0 	76 61 6C 75 65 20 62 75 
1A50FB8 	6C 6B 2D 6F 75 74 2D 70 
1A50FC0 	69 70 65  0 D8 E5 A0  1 

s" 0 instance value bulk-in-qh" eval
1A50FC8 	9C 53 A0  1 1B 30 20 69 
1A50FD0 	6E 73 74 61 6E 63 65 20 
1A50FD8 	76 61 6C 75 65 20 62 75 
1A50FE0 	6C 6B 2D 69 6E 2D 71 68 
1A50FE8 	 0  0  0  0 D8 E5 A0  1 
s" 0 instance value bulk-in-td" eval
1A50FF0 	9C 53 A0  1 1B 30 20 69 
1A50FF8 	6E 73 74 61 6E 63 65 20 
1A51000 	76 61 6C 75 65 20 62 75 
1A51008 	6C 6B 2D 69 6E 2D 74 64 
1A51010 	 0  0  0  0 D8 E5 A0  1 

s" : bulk-in-data@   ( -- n )  bulk-in-pipe  target di-in-data@  di-data>td-data  ;" eval
1A51018 	9C 53 A0  1 50 3A 20 62 
1A51020 	75 6C 6B 2D 69 6E 2D 64 
1A51028 	61 74 61 40 20 20 20 28 
1A51030 	20 2D 2D 20 6E 20 29 20 
1A51038 	20 62 75 6C 6B 2D 69 6E 
1A51040 	2D 70 69 70 65 20 20 74 
1A51048 	61 72 67 65 74 20 64 69 
1A51050 	2D 69 6E 2D 64 61 74 61 
1A51058 	40 20 20 64 69 2D 64 61 
1A51060 	74 61 3E 74 64 2D 64 61 
1A51068 	74 61 20 20 3B  0  0  0 
1A51070 	D8 E5 A0  1 
s" : bulk-out-data@  ( -- n )  bulk-out-pipe target di-out-data@ di-data>td-data  ;" eval
1A51074 	9C 53 A0  1 
1A51078 	50 3A 20 62 75 6C 6B 2D 
1A51080 	6F 75 74 2D 64 61 74 61 
1A51088 	40 20 20 28 20 2D 2D 20 
1A51090 	6E 20 29 20 20 62 75 6C 
1A51098 	6B 2D 6F 75 74 2D 70 69 
1A510A0 	70 65 20 74 61 72 67 65 
1A510A8 	74 20 64 69 2D 6F 75 74 
1A510B0 	2D 64 61 74 61 40 20 64 
1A510B8 	69 2D 64 61 74 61 3E 74 
1A510C0 	64 2D 64 61 74 61 20 20 
1A510C8 	3B  0  0  0 D8 E5 A0  1 
s" : bulk-in-data!   ( n -- )  td-data>di-data bulk-in-pipe  target di-in-data!   ;" eval
1A510D0 	9C 53 A0  1 50 3A 20 62 
1A510D8 	75 6C 6B 2D 69 6E 2D 64 
1A510E0 	61 74 61 21 20 20 20 28 
1A510E8 	20 6E 20 2D 2D 20 29 20 
1A510F0 	20 74 64 2D 64 61 74 61 
1A510F8 	3E 64 69 2D 64 61 74 61 
1A51100 	20 62 75 6C 6B 2D 69 6E 
1A51108 	2D 70 69 70 65 20 20 74 
1A51110 	61 72 67 65 74 20 64 69 
1A51118 	2D 69 6E 2D 64 61 74 61 
1A51120 	21 20 20 20 3B  0  0  0 
1A51128 	D8 E5 A0  1 
s" : bulk-out-data!  ( n -- )  td-data>di-data bulk-out-pipe target di-out-data!  ;" eval
1A5112C 	9C 53 A0  1 
1A51130 	50 3A 20 62 75 6C 6B 2D 
1A51138 	6F 75 74 2D 64 61 74 61 
1A51140 	21 20 20 28 20 6E 20 2D 
1A51148 	2D 20 29 20 20 74 64 2D 
1A51150 	64 61 74 61 3E 64 69 2D 
1A51158 	64 61 74 61 20 62 75 6C 
1A51160 	6B 2D 6F 75 74 2D 70 69 
1A51168 	70 65 20 74 61 72 67 65 
1A51170 	74 20 64 69 2D 6F 75 74 
1A51178 	2D 64 61 74 61 21 20 20 
1A51180 	3B  0  0  0 D8 E5 A0  1 
s" : toggle-bulk-in-data   ( -- )  bulk-in-pipe  target di-in-data-toggle   ;" eval
1A51188 	9C 53 A0  1 4A 3A 20 74 
1A51190 	6F 67 67 6C 65 2D 62 75 
1A51198 	6C 6B 2D 69 6E 2D 64 61 
1A511A0 	74 61 20 20 20 28 20 2D 
1A511A8 	2D 20 29 20 20 62 75 6C 
1A511B0 	6B 2D 69 6E 2D 70 69 70 
1A511B8 	65 20 20 74 61 72 67 65 
1A511C0 	74 20 64 69 2D 69 6E 2D 
1A511C8 	64 61 74 61 2D 74 6F 67 
1A511D0 	67 6C 65 20 20 20 3B  0 
1A511D8 	D8 E5 A0  1 
s" : toggle-bulk-out-data  ( -- )  bulk-out-pipe target di-out-data-toggle  ;" eval
1A511DC 	9C 53 A0  1 
1A511E0 	4A 3A 20 74 6F 67 67 6C 
1A511E8 	65 2D 62 75 6C 6B 2D 6F 
1A511F0 	75 74 2D 64 61 74 61 20 
1A511F8 	20 28 20 2D 2D 20 29 20 
1A51200 	20 62 75 6C 6B 2D 6F 75 
1A51208 	74 2D 70 69 70 65 20 74 
1A51210 	61 72 67 65 74 20 64 69 
1A51218 	2D 6F 75 74 2D 64 61 74 
1A51220 	61 2D 74 6F 67 67 6C 65 
1A51228 	20 20 3B  0 D8 E5 A0  1 

\ Fix up data toggle bit if error OR partially finished Q context.
s" : fixup-bulk-in-data" eval  ( td #td -- )
1A51230 	9C 53 A0  1 14 3A 20 66 
1A51238 	69 78 75 70 2D 62 75 6C 
1A51240 	6B 2D 69 6E 2D 64 61 74 
1A51248 	61  0  0  0 D8 E5 A0  1 
s"    usb-error USB_ERR_STALL and  if" eval
1A51250 	9C 53 A0  1 22 20 20 20 
1A51258 	75 73 62 2D 65 72 72 6F 
1A51260 	72 20 55 53 42 5F 45 52 
1A51268 	52 5F 53 54 41 4C 4C 20 
1A51270 	61 6E 64 20 20 69 66  0 
1A51278 	D8 E5 A0  1 
s"      2drop bulk-in-pipe h# 80 or unstall-pipe" eval
1A5127C 	9C 53 A0  1 
1A51280 	2D 20 20 20 20 20 32 64 
1A51288 	72 6F 70 20 62 75 6C 6B 
1A51290 	2D 69 6E 2D 70 69 70 65 
1A51298 	20 68 23 20 38 30 20 6F 
1A512A0 	72 20 75 6E 73 74 61 6C 
1A512A8 	6C 2D 70 69 70 65  0  0 
1A512B0 	D8 E5 A0  1 
s"      0 bulk-in-data!" eval
1A512B4 	9C 53 A0  1 
1A512B8 	14 20 20 20 20 20 30 20 
1A512C0 	62 75 6C 6B 2D 69 6E 2D 
1A512C8 	64 61 74 61 21  0  0  0 
1A512D0 	D8 E5 A0  1 
s"      exit" eval
1A512D4 	9C 53 A0  1 
1A512D8 	 9 20 20 20 20 20 65 78 
1A512E0 	69 74  0  0 D8 E5 A0  1 
s"    then" eval
1A512E8 	9C 53 A0  1  7 20 20 20 
1A512F0 	74 68 65 6E  0  0  0  0 
1A512F8 	D8 E5 A0  1 
s"    0  ?do" eval
1A512FC 	9C 53 A0  1 
1A51300 	 9 20 20 20 30 20 20 3F 
1A51308 	64 6F  0  0 D8 E5 A0  1 
s"       dup >hctd-stat le-l@ TD_STAT_ACTIVE  and  if" eval
1A51310 	9C 53 A0  1 32 20 20 20 
1A51318 	20 20 20 64 75 70 20 3E 
1A51320 	68 63 74 64 2D 73 74 61 
1A51328 	74 20 6C 65 2D 6C 40 20 
1A51330 	54 44 5F 53 54 41 54 5F 
1A51338 	41 43 54 49 56 45 20 20 
1A51340 	61 6E 64 20 20 69 66  0 
1A51348 	D8 E5 A0  1 
s"          dup >hctd-token le-l@  bulk-in-data!" eval
1A5134C 	9C 53 A0  1 
1A51350 	2D 20 20 20 20 20 20 20 
1A51358 	20 20 64 75 70 20 3E 68 
1A51360 	63 74 64 2D 74 6F 6B 65 
1A51368 	6E 20 6C 65 2D 6C 40 20 
1A51370 	20 62 75 6C 6B 2D 69 6E 
1A51378 	2D 64 61 74 61 21  0  0 
1A51380 	D8 E5 A0  1 
s"          leave" eval
1A51384 	9C 53 A0  1 
1A51388 	 E 20 20 20 20 20 20 20 
1A51390 	20 20 6C 65 61 76 65  0 
1A51398 	D8 E5 A0  1 
s"       then" eval
1A5139C 	9C 53 A0  1 
1A513A0 	 A 20 20 20 20 20 20 74 
1A513A8 	68 65 6E  0 D8 E5 A0  1 
s"       >td-next @" eval
1A513B0 	9C 53 A0  1 10 20 20 20 
1A513B8 	20 20 20 3E 74 64 2D 6E 
1A513C0 	65 78 74 20 40  0  0  0 
1A513C8 	D8 E5 A0  1 
s"    loop  drop ;" eval
1A513CC 	9C 53 A0  1 
1A513D0 	 F 20 20 20 6C 6F 6F 70 
1A513D8 	20 20 64 72 6F 70 20 3B 
1A513E0 	 0  0  0  0 D8 E5 A0  1 

s" : fixup-bulk-out-data" eval  ( td #td -- )
1A513E8 	9C 53 A0  1 15 3A 20 66 
1A513F0 	69 78 75 70 2D 62 75 6C 
1A513F8 	6B 2D 6F 75 74 2D 64 61 
1A51400 	74 61  0  0 D8 E5 A0  1 
s"    usb-error USB_ERR_STALL and  if" eval
1A51408 	9C 53 A0  1 22 20 20 20 
1A51410 	75 73 62 2D 65 72 72 6F 
1A51418 	72 20 55 53 42 5F 45 52 
1A51420 	52 5F 53 54 41 4C 4C 20 
1A51428 	61 6E 64 20 20 69 66  0 
1A51430 	D8 E5 A0  1 
s"      2drop bulk-out-pipe unstall-pipe" eval
1A51434 	9C 53 A0  1 
1A51438 	25 20 20 20 20 20 32 64 
1A51440 	72 6F 70 20 62 75 6C 6B 
1A51448 	2D 6F 75 74 2D 70 69 70 
1A51450 	65 20 75 6E 73 74 61 6C 
1A51458 	6C 2D 70 69 70 65  0  0 
1A51460 	D8 E5 A0  1 
s"      0 bulk-out-data!" eval
1A51464 	9C 53 A0  1 
1A51468 	15 20 20 20 20 20 30 20 
1A51470 	62 75 6C 6B 2D 6F 75 74 
1A51478 	2D 64 61 74 61 21  0  0 
1A51480 	D8 E5 A0  1 
s"      exit" eval
1A51484 	9C 53 A0  1 
1A51488 	 9 20 20 20 20 20 65 78 
1A51490 	69 74  0  0 D8 E5 A0  1 
s"    then" eval
1A51498 	9C 53 A0  1  7 20 20 20 
1A514A0 	74 68 65 6E  0  0  0  0 
1A514A8 	D8 E5 A0  1 
s"    0  ?do" eval
1A514AC 	9C 53 A0  1 
1A514B0 	 9 20 20 20 30 20 20 3F 
1A514B8 	64 6F  0  0 D8 E5 A0  1 
s"       dup >hctd-stat le-l@ TD_STAT_ACTIVE  and  if" eval
1A514C0 	9C 53 A0  1 32 20 20 20 
1A514C8 	20 20 20 64 75 70 20 3E 
1A514D0 	68 63 74 64 2D 73 74 61 
1A514D8 	74 20 6C 65 2D 6C 40 20 
1A514E0 	54 44 5F 53 54 41 54 5F 
1A514E8 	41 43 54 49 56 45 20 20 
1A514F0 	61 6E 64 20 20 69 66  0 
1A514F8 	D8 E5 A0  1 
s"          dup >hctd-token le-l@  bulk-out-data!" eval
1A514FC 	9C 53 A0  1 
1A51500 	2E 20 20 20 20 20 20 20 
1A51508 	20 20 64 75 70 20 3E 68 
1A51510 	63 74 64 2D 74 6F 6B 65 
1A51518 	6E 20 6C 65 2D 6C 40 20 
1A51520 	20 62 75 6C 6B 2D 6F 75 
1A51528 	74 2D 64 61 74 61 21  0 
1A51530 	D8 E5 A0  1 
s"          leave" eval
1A51534 	9C 53 A0  1 
1A51538 	 E 20 20 20 20 20 20 20 
1A51540 	20 20 6C 65 61 76 65  0 
1A51548 	D8 E5 A0  1 
s"       then" eval
1A5154C 	9C 53 A0  1 
1A51550 	 A 20 20 20 20 20 20 74 
1A51558 	68 65 6E  0 D8 E5 A0  1 
s"       >td-next @" eval
1A51560 	9C 53 A0  1 10 20 20 20 
1A51568 	20 20 20 3E 74 64 2D 6E 
1A51570 	65 78 74 20 40  0  0  0 
1A51578 	D8 E5 A0  1 
s"    loop  drop ;" eval
1A5157C 	9C 53 A0  1 
1A51580 	 F 20 20 20 6C 6F 6F 70 
1A51588 	20 20 64 72 6F 70 20 3B 
1A51590 	 0  0  0  0 D8 E5 A0  1 

s" : process-bulk-args" eval  ( buf len pipe timeout -- )
1A51598 	9C 53 A0  1 13 3A 20 70 
1A515A0 	72 6F 63 65 73 73 2D 62 
1A515A8 	75 6C 6B 2D 61 72 67 73 
1A515B0 	 0  0  0  0 D8 E5 A0  1 
s"    to timeout" eval
1A515B8 	9C 53 A0  1  D 20 20 20 
1A515C0 	74 6F 20 74 69 6D 65 6F 
1A515C8 	75 74  0  0 D8 E5 A0  1 
s"    clear-usb-error" eval
1A515D0 	9C 53 A0  1 12 20 20 20 
1A515D8 	63 6C 65 61 72 2D 75 73 
1A515E0 	62 2D 65 72 72 6F 72  0 
1A515E8 	D8 E5 A0  1 
s"    set-my-dev" eval
1A515EC 	9C 53 A0  1 
1A515F0 	 D 20 20 20 73 65 74 2D 
1A515F8 	6D 79 2D 64 65 76  0  0 
1A51600 	D8 E5 A0  1 
s"    ( pipe ) set-my-char" eval
1A51604 	9C 53 A0  1 
1A51608 	17 20 20 20 28 20 70 69 
1A51610 	70 65 20 29 20 73 65 74 
1A51618 	2D 6D 79 2D 63 68 61 72 
1A51620 	 0  0  0  0 D8 E5 A0  1 
s"    2dup hcd-map-in  to my-buf-phys to /my-buf to my-buf ;" eval
1A51628 	9C 53 A0  1 39 20 20 20 
1A51630 	32 64 75 70 20 68 63 64 
1A51638 	2D 6D 61 70 2D 69 6E 20 
1A51640 	20 74 6F 20 6D 79 2D 62 
1A51648 	75 66 2D 70 68 79 73 20 
1A51650 	74 6F 20 2F 6D 79 2D 62 
1A51658 	75 66 20 74 6F 20 6D 79 
1A51660 	2D 62 75 66 20 3B  0  0 
1A51668 	D8 E5 A0  1 

s" : alloc-bulk-qhtds" eval  ( -- qh td )
1A5166C 	9C 53 A0  1 
1A51670 	12 3A 20 61 6C 6C 6F 63 
1A51678 	2D 62 75 6C 6B 2D 71 68 
1A51680 	74 64 73  0 D8 E5 A0  1 
s"    my-maxpayload /my-buf over round-up swap / dup to my-#tds" eval
1A51688 	9C 53 A0  1 3C 20 20 20 
1A51690 	6D 79 2D 6D 61 78 70 61 
1A51698 	79 6C 6F 61 64 20 2F 6D 
1A516A0 	79 2D 62 75 66 20 6F 76 
1A516A8 	65 72 20 72 6F 75 6E 64 
1A516B0 	2D 75 70 20 73 77 61 70 
1A516B8 	20 2F 20 64 75 70 20 74 
1A516C0 	6F 20 6D 79 2D 23 74 64 
1A516C8 	73  0  0  0 D8 E5 A0  1 
s"    alloc-qhtds ;" eval
1A516D0 	9C 53 A0  1 10 20 20 20 
1A516D8 	61 6C 6C 6F 63 2D 71 68 
1A516E0 	74 64 73 20 3B  0  0  0 
1A516E8 	D8 E5 A0  1 

s" : fill-bulk-io-tds" eval  ( dir td -- )
1A516EC 	9C 53 A0  1 
1A516F0 	12 3A 20 66 69 6C 6C 2D 
1A516F8 	62 75 6C 6B 2D 69 6F 2D 
1A51700 	74 64 73  0 D8 E5 A0  1 
s"    /my-buf over >td-/buf-all l!" eval			( dir td )
1A51708 	9C 53 A0  1 1F 20 20 20 
1A51710 	2F 6D 79 2D 62 75 66 20 
1A51718 	6F 76 65 72 20 3E 74 64 
1A51720 	2D 2F 62 75 66 2D 61 6C 
1A51728 	6C 20 6C 21  0  0  0  0 
1A51730 	D8 E5 A0  1 
s"    my-#tds 0  ?do" eval				( dir td )
1A51734 	9C 53 A0  1 
1A51738 	11 20 20 20 6D 79 2D 23 
1A51740 	74 64 73 20 30 20 20 3F 
1A51748 	64 6F  0  0 D8 E5 A0  1 
s"       TD_STAT_ACTIVE TD_CTRL_C_ERR3 or" eval		( dir td stat )
1A51750 	9C 53 A0  1 26 20 20 20 
1A51758 	20 20 20 54 44 5F 53 54 
1A51760 	41 54 5F 41 43 54 49 56 
1A51768 	45 20 54 44 5F 43 54 52 
1A51770 	4C 5F 43 5F 45 52 52 33 
1A51778 	20 6F 72  0 D8 E5 A0  1 
s"       TD_CTRL_SPD or my-speed or" eval		( dir td stat' )
1A51780 	9C 53 A0  1 20 20 20 20 
1A51788 	20 20 20 54 44 5F 43 54 
1A51790 	52 4C 5F 53 50 44 20 6F 
1A51798 	72 20 6D 79 2D 73 70 65 
1A517A0 	65 64 20 6F 72  0  0  0 
1A517A8 	D8 E5 A0  1 
s"       over >td-next l@ 0=  if  TD_CTRL_IOC or  then" eval	( dir td stat' )
1A517AC 	9C 53 A0  1 
1A517B0 	33 20 20 20 20 20 20 6F 
1A517B8 	76 65 72 20 3E 74 64 2D 
1A517C0 	6E 65 78 74 20 6C 40 20 
1A517C8 	30 3D 20 20 69 66 20 20 
1A517D0 	54 44 5F 43 54 52 4C 5F 
1A517D8 	49 4F 43 20 6F 72 20 20 
1A517E0 	74 68 65 6E  0  0  0  0 
1A517E8 	D8 E5 A0  1 
s"       over >hctd-stat le-l!" eval			( dir td )
1A517EC 	9C 53 A0  1 
1A517F0 	1B 20 20 20 20 20 20 6F 
1A517F8 	76 65 72 20 3E 68 63 74 
1A51800 	64 2D 73 74 61 74 20 6C 
1A51808 	65 2D 6C 21  0  0  0  0 
1A51810 	D8 E5 A0  1 
s"       /my-buf my-maxpayload min dup 1- d# 21 <<" eval	( dir td /buf token )
1A51814 	9C 53 A0  1 
1A51818 	2F 20 20 20 20 20 20 2F 
1A51820 	6D 79 2D 62 75 66 20 6D 
1A51828 	79 2D 6D 61 78 70 61 79 
1A51830 	6C 6F 61 64 20 6D 69 6E 
1A51838 	20 64 75 70 20 31 2D 20 
1A51840 	64 23 20 32 31 20 3C 3C 
1A51848 	 0  0  0  0 D8 E5 A0  1 
s"       3 pick TD_PID_IN =  if" eval
1A51850 	9C 53 A0  1 1C 20 20 20 
1A51858 	20 20 20 33 20 70 69 63 
1A51860 	6B 20 54 44 5F 50 49 44 
1A51868 	5F 49 4E 20 3D 20 20 69 
1A51870 	66  0  0  0 D8 E5 A0  1 
s"          bulk-in-data@  toggle-bulk-in-data" eval	( dir td /buf token' )
1A51878 	9C 53 A0  1 2B 20 20 20 
1A51880 	20 20 20 20 20 20 62 75 
1A51888 	6C 6B 2D 69 6E 2D 64 61 
1A51890 	74 61 40 20 20 74 6F 67 
1A51898 	67 6C 65 2D 62 75 6C 6B 
1A518A0 	2D 69 6E 2D 64 61 74 61 
1A518A8 	 0  0  0  0 D8 E5 A0  1 
s"       else" eval
1A518B0 	9C 53 A0  1  A 20 20 20 
1A518B8 	20 20 20 65 6C 73 65  0 
1A518C0 	D8 E5 A0  1 
s"          bulk-out-data@ toggle-bulk-out-data" eval	( dir td /buf token' )
1A518C4 	9C 53 A0  1 
1A518C8 	2C 20 20 20 20 20 20 20 
1A518D0 	20 20 62 75 6C 6B 2D 6F 
1A518D8 	75 74 2D 64 61 74 61 40 
1A518E0 	20 74 6F 67 67 6C 65 2D 
1A518E8 	62 75 6C 6B 2D 6F 75 74 
1A518F0 	2D 64 61 74 61  0  0  0 
1A518F8 	D8 E5 A0  1 
s"       then  or" eval
1A518FC 	9C 53 A0  1 
1A51900 	 E 20 20 20 20 20 20 74 
1A51908 	68 65 6E 20 20 6F 72  0 
1A51910 	D8 E5 A0  1 
s"       3 pick or my-dev/pipe or" eval			( dir td /buf token' )
1A51914 	9C 53 A0  1 
1A51918 	1E 20 20 20 20 20 20 33 
1A51920 	20 70 69 63 6B 20 6F 72 
1A51928 	20 6D 79 2D 64 65 76 2F 
1A51930 	70 69 70 65 20 6F 72  0 
1A51938 	D8 E5 A0  1 
s"       2 pick >hctd-token le-l!" eval			( dir td /buf )
1A5193C 	9C 53 A0  1 
1A51940 	1E 20 20 20 20 20 20 32 
1A51948 	20 70 69 63 6B 20 3E 68 
1A51950 	63 74 64 2D 74 6F 6B 65 
1A51958 	6E 20 6C 65 2D 6C 21  0 
1A51960 	D8 E5 A0  1 
s"       my-buf-phys 2 pick 2dup >hctd-buf le-l!" eval	( dir td /buf pbuf td )
1A51964 	9C 53 A0  1 
1A51968 	2D 20 20 20 20 20 20 6D 
1A51970 	79 2D 62 75 66 2D 70 68 
1A51978 	79 73 20 32 20 70 69 63 
1A51980 	6B 20 32 64 75 70 20 3E 
1A51988 	68 63 74 64 2D 62 75 66 
1A51990 	20 6C 65 2D 6C 21  0  0 
1A51998 	D8 E5 A0  1 
s"       >td-pbuf l!" eval				( dir td /buf )
1A5199C 	9C 53 A0  1 
1A519A0 	11 20 20 20 20 20 20 3E 
1A519A8 	74 64 2D 70 62 75 66 20 
1A519B0 	6C 21  0  0 D8 E5 A0  1 
s"       my-buf 2 pick >td-buf l!" eval			( dir td /buf )
1A519B8 	9C 53 A0  1 1E 20 20 20 
1A519C0 	20 20 20 6D 79 2D 62 75 
1A519C8 	66 20 32 20 70 69 63 6B 
1A519D0 	20 3E 74 64 2D 62 75 66 
1A519D8 	20 6C 21  0 D8 E5 A0  1 
s"       my-buf++" eval					( dir td )
1A519E0 	9C 53 A0  1  E 20 20 20 
1A519E8 	20 20 20 6D 79 2D 62 75 
1A519F0 	66 2B 2B  0 D8 E5 A0  1 
s"       >td-next l@" eval				( dir td' )
1A519F8 	9C 53 A0  1 11 20 20 20 
1A51A00 	20 20 20 3E 74 64 2D 6E 
1A51A08 	65 78 74 20 6C 40  0  0 
1A51A10 	D8 E5 A0  1 
s"    loop  2drop ;" eval
1A51A14 	9C 53 A0  1 
1A51A18 	10 20 20 20 6C 6F 6F 70 
1A51A20 	20 20 32 64 72 6F 70 20 
1A51A28 	3B  0  0  0 D8 E5 A0  1 

s" : set-bulk-in-timeout  ( t -- )  ?dup  if  to bulk-in-timeout  then  ;" eval
1A51A30 	9C 53 A0  1 46 3A 20 73 
1A51A38 	65 74 2D 62 75 6C 6B 2D 
1A51A40 	69 6E 2D 74 69 6D 65 6F 
1A51A48 	75 74 20 20 28 20 74 20 
1A51A50 	2D 2D 20 29 20 20 3F 64 
1A51A58 	75 70 20 20 69 66 20 20 
1A51A60 	74 6F 20 62 75 6C 6B 2D 
1A51A68 	69 6E 2D 74 69 6D 65 6F 
1A51A70 	75 74 20 20 74 68 65 6E 
1A51A78 	20 20 3B  0 D8 E5 A0  1 

s" : begin-bulk-in" eval  ( buf len pipe -- )
1A51A80 	9C 53 A0  1  F 3A 20 62 
1A51A88 	65 67 69 6E 2D 62 75 6C 
1A51A90 	6B 2D 69 6E  0  0  0  0 
1A51A98 	D8 E5 A0  1 
 "    debug?  if  ."" begin-bulk-in"" cr  then" eval
1A51A9C 	9C 53 A0  1 
1A51AA0 	29 20 20 20 64 65 62 75 
1A51AA8 	67 3F 20 20 69 66 20 20 
1A51AB0 	2E 22 20 62 65 67 69 6E 
1A51AB8 	2D 62 75 6C 6B 2D 69 6E 
1A51AC0 	22 20 63 72 20 20 74 68 
1A51AC8 	65 6E  0  0 D8 E5 A0  1 
s"    bulk-in-qh  if  3drop exit  then" eval		\ Already started
1A51AD0 	9C 53 A0  1 23 20 20 20 
1A51AD8 	62 75 6C 6B 2D 69 6E 2D 
1A51AE0 	71 68 20 20 69 66 20 20 
1A51AE8 	33 64 72 6F 70 20 65 78 
1A51AF0 	69 74 20 20 74 68 65 6E 
1A51AF8 	 0  0  0  0 D8 E5 A0  1 

s"    dup to bulk-in-pipe" eval
1A51B00 	9C 53 A0  1 16 20 20 20 
1A51B08 	64 75 70 20 74 6F 20 62 
1A51B10 	75 6C 6B 2D 69 6E 2D 70 
1A51B18 	69 70 65  0 D8 E5 A0  1 
s"    bulk-in-timeout process-bulk-args" eval
1A51B20 	9C 53 A0  1 24 20 20 20 
1A51B28 	62 75 6C 6B 2D 69 6E 2D 
1A51B30 	74 69 6D 65 6F 75 74 20 
1A51B38 	70 72 6F 63 65 73 73 2D 
1A51B40 	62 75 6C 6B 2D 61 72 67 
1A51B48 	73  0  0  0 D8 E5 A0  1 
s"    alloc-bulk-qhtds  to bulk-in-td  to bulk-in-qh" eval
1A51B50 	9C 53 A0  1 31 20 20 20 
1A51B58 	61 6C 6C 6F 63 2D 62 75 
1A51B60 	6C 6B 2D 71 68 74 64 73 
1A51B68 	20 20 74 6F 20 62 75 6C 
1A51B70 	6B 2D 69 6E 2D 74 64 20 
1A51B78 	20 74 6F 20 62 75 6C 6B 
1A51B80 	2D 69 6E 2D 71 68  0  0 
1A51B88 	D8 E5 A0  1 

   \ IN TDs
s"    TD_PID_IN bulk-in-td fill-bulk-io-tds" eval
1A51B8C 	9C 53 A0  1 
1A51B90 	28 20 20 20 54 44 5F 50 
1A51B98 	49 44 5F 49 4E 20 62 75 
1A51BA0 	6C 6B 2D 69 6E 2D 74 64 
1A51BA8 	20 66 69 6C 6C 2D 62 75 
1A51BB0 	6C 6B 2D 69 6F 2D 74 64 
1A51BB8 	73  0  0  0 D8 E5 A0  1 

   \ Start bulk in transaction
s"    bulk-in-qh my-speed insert-bulk-qh ;" eval
1A51BC0 	9C 53 A0  1 27 20 20 20 
1A51BC8 	62 75 6C 6B 2D 69 6E 2D 
1A51BD0 	71 68 20 6D 79 2D 73 70 
1A51BD8 	65 65 64 20 69 6E 73 65 
1A51BE0 	72 74 2D 62 75 6C 6B 2D 
1A51BE8 	71 68 20 3B  0  0  0  0 
1A51BF0 	D8 E5 A0  1 

s" : bulk-in-actual" eval  ( -- actual usberr )
1A51BF4 	9C 53 A0  1 
1A51BF8 	10 3A 20 62 75 6C 6B 2D 
1A51C00 	69 6E 2D 61 63 74 75 61 
1A51C08 	6C  0  0  0 D8 E5 A0  1 
s"    bulk-in-td bulk-in-qh >qh-#tds l@ get-actual" eval	( actual )
1A51C10 	9C 53 A0  1 2F 20 20 20 
1A51C18 	62 75 6C 6B 2D 69 6E 2D 
1A51C20 	74 64 20 62 75 6C 6B 2D 
1A51C28 	69 6E 2D 71 68 20 3E 71 
1A51C30 	68 2D 23 74 64 73 20 6C 
1A51C38 	40 20 67 65 74 2D 61 63 
1A51C40 	74 75 61 6C  0  0  0  0 
1A51C48 	D8 E5 A0  1 
s"    usb-error" eval						( actual usberr )
1A51C4C 	9C 53 A0  1 
1A51C50 	 C 20 20 20 75 73 62 2D 
1A51C58 	65 72 72 6F 72  0  0  0 
1A51C60 	D8 E5 A0  1 
s"    bulk-in-td bulk-in-qh >qh-#tds l@ fixup-bulk-in-data ;" eval
1A51C64 	9C 53 A0  1 
1A51C68 	39 20 20 20 62 75 6C 6B 
1A51C70 	2D 69 6E 2D 74 64 20 62 
1A51C78 	75 6C 6B 2D 69 6E 2D 71 
1A51C80 	68 20 3E 71 68 2D 23 74 
1A51C88 	64 73 20 6C 40 20 66 69 
1A51C90 	78 75 70 2D 62 75 6C 6B 
1A51C98 	2D 69 6E 2D 64 61 74 61 
1A51CA0 	20 3B  0  0 D8 E5 A0  1 

s" : bulk-in?" eval  ( -- actual usberr )
1A51CA8 	9C 53 A0  1  A 3A 20 62 
1A51CB0 	75 6C 6B 2D 69 6E 3F  0 
1A51CB8 	D8 E5 A0  1 
s"    bulk-in-qh 0=  if  0 USB_ERR_INV_OP exit  then" eval
1A51CBC 	9C 53 A0  1 
1A51CC0 	31 20 20 20 62 75 6C 6B 
1A51CC8 	2D 69 6E 2D 71 68 20 30 
1A51CD0 	3D 20 20 69 66 20 20 30 
1A51CD8 	20 55 53 42 5F 45 52 52 
1A51CE0 	5F 49 4E 56 5F 4F 50 20 
1A51CE8 	65 78 69 74 20 20 74 68 
1A51CF0 	65 6E  0  0 D8 E5 A0  1 
s"    lock" eval
1A51CF8 	9C 53 A0  1  7 20 20 20 
1A51D00 	6C 6F 63 6B  0  0  0  0 
1A51D08 	D8 E5 A0  1 
s"    clear-usb-error" eval
1A51D0C 	9C 53 A0  1 
1A51D10 	12 20 20 20 63 6C 65 61 
1A51D18 	72 2D 75 73 62 2D 65 72 
1A51D20 	72 6F 72  0 D8 E5 A0  1 
s"    process-hc-status" eval
1A51D28 	9C 53 A0  1 14 20 20 20 
1A51D30 	70 72 6F 63 65 73 73 2D 
1A51D38 	68 63 2D 73 74 61 74 75 
1A51D40 	73  0  0  0 D8 E5 A0  1 
s"    bulk-in-qh dup pull-qhtds" eval                            ( bulk-in-qh )
1A51D48 	9C 53 A0  1 1C 20 20 20 
1A51D50 	62 75 6C 6B 2D 69 6E 2D 
1A51D58 	71 68 20 64 75 70 20 70 
1A51D60 	75 6C 6C 2D 71 68 74 64 
1A51D68 	73  0  0  0 D8 E5 A0  1 
s"    qh-done?  if" eval
1A51D70 	9C 53 A0  1  F 20 20 20 
1A51D78 	71 68 2D 64 6F 6E 65 3F 
1A51D80 	20 20 69 66  0  0  0  0 
1A51D88 	D8 E5 A0  1 
s"       bulk-in-actual" eval                                    ( actual usberr )
1A51D8C 	9C 53 A0  1 
1A51D90 	14 20 20 20 20 20 20 62 
1A51D98 	75 6C 6B 2D 69 6E 2D 61 
1A51DA0 	63 74 75 61 6C  0  0  0 
1A51DA8 	D8 E5 A0  1 
s"    else" eval
1A51DAC 	9C 53 A0  1 
1A51DB0 	 7 20 20 20 65 6C 73 65 
1A51DB8 	 0  0  0  0 D8 E5 A0  1 
s"       bulk-in-qh dup >hcqh-elem le-l@" eval			( qh elem )
1A51DC0 	9C 53 A0  1 25 20 20 20 
1A51DC8 	20 20 20 62 75 6C 6B 2D 
1A51DD0 	69 6E 2D 71 68 20 64 75 
1A51DD8 	70 20 3E 68 63 71 68 2D 
1A51DE0 	65 6C 65 6D 20 6C 65 2D 
1A51DE8 	6C 40  0  0 D8 E5 A0  1 
s"       1 ms  over pull-qhtds" eval				( qh elem )
1A51DF0 	9C 53 A0  1 1B 20 20 20 
1A51DF8 	20 20 20 31 20 6D 73 20 
1A51E00 	20 6F 76 65 72 20 70 75 
1A51E08 	6C 6C 2D 71 68 74 64 73 
1A51E10 	 0  0  0  0 D8 E5 A0  1 
s"       swap >hcqh-elem le-l@ =  if" eval			\ No movement in the past ms
1A51E18 	9C 53 A0  1 21 20 20 20 
1A51E20 	20 20 20 73 77 61 70 20 
1A51E28 	3E 68 63 71 68 2D 65 6C 
1A51E30 	65 6D 20 6C 65 2D 6C 40 
1A51E38 	20 3D 20 20 69 66  0  0 
1A51E40 	D8 E5 A0  1 
s"          bulk-in-actual" eval                                 ( actual usberr )
1A51E44 	9C 53 A0  1 
1A51E48 	17 20 20 20 20 20 20 20 
1A51E50 	20 20 62 75 6C 6B 2D 69 
1A51E58 	6E 2D 61 63 74 75 61 6C 
1A51E60 	 0  0  0  0 D8 E5 A0  1 
s"          bulk-in-td bulk-in-qh >qh-#tds l@ fixup-bulk-in-data" eval
1A51E68 	9C 53 A0  1 3D 20 20 20 
1A51E70 	20 20 20 20 20 20 62 75 
1A51E78 	6C 6B 2D 69 6E 2D 74 64 
1A51E80 	20 62 75 6C 6B 2D 69 6E 
1A51E88 	2D 71 68 20 3E 71 68 2D 
1A51E90 	23 74 64 73 20 6C 40 20 
1A51E98 	66 69 78 75 70 2D 62 75 
1A51EA0 	6C 6B 2D 69 6E 2D 64 61 
1A51EA8 	74 61  0  0 D8 E5 A0  1 
s"       else" eval						\ It may not be done yet
1A51EB0 	9C 53 A0  1  A 20 20 20 
1A51EB8 	20 20 20 65 6C 73 65  0 
1A51EC0 	D8 E5 A0  1 
s"          0 usb-error" eval					( actual usberr )
1A51EC4 	9C 53 A0  1 
1A51EC8 	14 20 20 20 20 20 20 20 
1A51ED0 	20 20 30 20 75 73 62 2D 
1A51ED8 	65 72 72 6F 72  0  0  0 
1A51EE0 	D8 E5 A0  1 
s"       then" eval
1A51EE4 	9C 53 A0  1 
1A51EE8 	 A 20 20 20 20 20 20 74 
1A51EF0 	68 65 6E  0 D8 E5 A0  1 
s"    then" eval
1A51EF8 	9C 53 A0  1  7 20 20 20 
1A51F00 	74 68 65 6E  0  0  0  0 
1A51F08 	D8 E5 A0  1 
s"    over  if" eval
1A51F0C 	9C 53 A0  1 
1A51F10 	 B 20 20 20 6F 76 65 72 
1A51F18 	20 20 69 66  0  0  0  0 
1A51F20 	D8 E5 A0  1 
s"       bulk-in-td dup >td-buf l@ swap >td-pbuf l@ 2 pick dma-pull" eval
1A51F24 	9C 53 A0  1 
1A51F28 	40 20 20 20 20 20 20 62 
1A51F30 	75 6C 6B 2D 69 6E 2D 74 
1A51F38 	64 20 64 75 70 20 3E 74 
1A51F40 	64 2D 62 75 66 20 6C 40 
1A51F48 	20 73 77 61 70 20 3E 74 
1A51F50 	64 2D 70 62 75 66 20 6C 
1A51F58 	40 20 32 20 70 69 63 6B 
1A51F60 	20 64 6D 61 2D 70 75 6C 
1A51F68 	6C  0  0  0 D8 E5 A0  1 
s"    then" eval
1A51F70 	9C 53 A0  1  7 20 20 20 
1A51F78 	74 68 65 6E  0  0  0  0 
1A51F80 	D8 E5 A0  1 
s"    unlock ;" eval
1A51F84 	9C 53 A0  1 
1A51F88 	 B 20 20 20 75 6E 6C 6F 
1A51F90 	63 6B 20 3B  0  0  0  0 
1A51F98 	D8 E5 A0  1 

s" : restart-bulk-in-td" eval  ( td -- )
1A51F9C 	9C 53 A0  1 
1A51FA0 	14 3A 20 72 65 73 74 61 
1A51FA8 	72 74 2D 62 75 6C 6B 2D 
1A51FB0 	69 6E 2D 74 64  0  0  0 
1A51FB8 	D8 E5 A0  1 
s"    begin  ?dup  while" eval                                 ( td )
1A51FBC 	9C 53 A0  1 
1A51FC0 	15 20 20 20 62 65 67 69 
1A51FC8 	6E 20 20 3F 64 75 70 20 
1A51FD0 	20 77 68 69 6C 65  0  0 
1A51FD8 	D8 E5 A0  1 
s"       toggle-bulk-in-data" eval                             ( td )
1A51FDC 	9C 53 A0  1 
1A51FE0 	19 20 20 20 20 20 20 74 
1A51FE8 	6F 67 67 6C 65 2D 62 75 
1A51FF0 	6C 6B 2D 69 6E 2D 64 61 
1A51FF8 	74 61  0  0 D8 E5 A0  1 
s"       dup >hctd-token" eval                                 ( td &token )
1A52000 	9C 53 A0  1 15 20 20 20 
1A52008 	20 20 20 64 75 70 20 3E 
1A52010 	68 63 74 64 2D 74 6F 6B 
1A52018 	65 6E  0  0 D8 E5 A0  1 
s"       dup le-l@  TD_TOKEN_DATA1 invert and" eval            ( td &token value )
1A52020 	9C 53 A0  1 2A 20 20 20 
1A52028 	20 20 20 64 75 70 20 6C 
1A52030 	65 2D 6C 40 20 20 54 44 
1A52038 	5F 54 4F 4B 45 4E 5F 44 
1A52040 	41 54 41 31 20 69 6E 76 
1A52048 	65 72 74 20 61 6E 64  0 
1A52050 	D8 E5 A0  1 
s"       bulk-in-data@ or  swap le-l!" eval                    ( td )
1A52054 	9C 53 A0  1 
1A52058 	22 20 20 20 20 20 20 62 
1A52060 	75 6C 6B 2D 69 6E 2D 64 
1A52068 	61 74 61 40 20 6F 72 20 
1A52070 	20 73 77 61 70 20 6C 65 
1A52078 	2D 6C 21  0 D8 E5 A0  1 
s"       dup >hctd-stat dup le-l@" eval                        ( td &stat value )
1A52080 	9C 53 A0  1 1E 20 20 20 
1A52088 	20 20 20 64 75 70 20 3E 
1A52090 	68 63 74 64 2D 73 74 61 
1A52098 	74 20 64 75 70 20 6C 65 
1A520A0 	2D 6C 40  0 D8 E5 A0  1 
s"       TD_STAT_ANY_ERROR TD_ACTUAL_MASK or invert and" eval  ( td &stat value' )
1A520A8 	9C 53 A0  1 34 20 20 20 
1A520B0 	20 20 20 54 44 5F 53 54 
1A520B8 	41 54 5F 41 4E 59 5F 45 
1A520C0 	52 52 4F 52 20 54 44 5F 
1A520C8 	41 43 54 55 41 4C 5F 4D 
1A520D0 	41 53 4B 20 6F 72 20 69 
1A520D8 	6E 76 65 72 74 20 61 6E 
1A520E0 	64  0  0  0 D8 E5 A0  1 
s"       TD_STAT_ACTIVE or swap le-l!" eval                    ( td )
1A520E8 	9C 53 A0  1 22 20 20 20 
1A520F0 	20 20 20 54 44 5F 53 54 
1A520F8 	41 54 5F 41 43 54 49 56 
1A52100 	45 20 6F 72 20 73 77 61 
1A52108 	70 20 6C 65 2D 6C 21  0 
1A52110 	D8 E5 A0  1 
s"       >td-next l@" eval                                     ( td' )
1A52114 	9C 53 A0  1 
1A52118 	11 20 20 20 20 20 20 3E 
1A52120 	74 64 2D 6E 65 78 74 20 
1A52128 	6C 40  0  0 D8 E5 A0  1 
s"    repeat ;" eval
1A52130 	9C 53 A0  1  B 20 20 20 
1A52138 	72 65 70 65 61 74 20 3B 
1A52140 	 0  0  0  0 D8 E5 A0  1 

s" : restart-bulk-in" eval  ( -- )
1A52148 	9C 53 A0  1 11 3A 20 72 
1A52150 	65 73 74 61 72 74 2D 62 
1A52158 	75 6C 6B 2D 69 6E  0  0 
1A52160 	D8 E5 A0  1 
 "    debug?  if  ."" restart-bulk-in"" cr  then" eval
1A52164 	9C 53 A0  1 
1A52168 	2B 20 20 20 64 65 62 75 
1A52170 	67 3F 20 20 69 66 20 20 
1A52178 	2E 22 20 72 65 73 74 61 
1A52180 	72 74 2D 62 75 6C 6B 2D 
1A52188 	69 6E 22 20 63 72 20 20 
1A52190 	74 68 65 6E  0  0  0  0 
1A52198 	D8 E5 A0  1 
s"    bulk-in-qh 0=  if  exit  then" eval
1A5219C 	9C 53 A0  1 
1A521A0 	20 20 20 20 62 75 6C 6B 
1A521A8 	2D 69 6E 2D 71 68 20 30 
1A521B0 	3D 20 20 69 66 20 20 65 
1A521B8 	78 69 74 20 20 74 68 65 
1A521C0 	6E  0  0  0 D8 E5 A0  1 

   \ Setup TD again
s"    bulk-in-td restart-bulk-in-td" eval
1A521C8 	9C 53 A0  1 20 20 20 20 
1A521D0 	62 75 6C 6B 2D 69 6E 2D 
1A521D8 	74 64 20 72 65 73 74 61 
1A521E0 	72 74 2D 62 75 6C 6B 2D 
1A521E8 	69 6E 2D 74 64  0  0  0 
1A521F0 	D8 E5 A0  1 

   \ Setup QH again
s"    bulk-in-td >td-phys l@ bulk-in-qh >hcqh-elem le-l!" eval
1A521F4 	9C 53 A0  1 
1A521F8 	35 20 20 20 62 75 6C 6B 
1A52200 	2D 69 6E 2D 74 64 20 3E 
1A52208 	74 64 2D 70 68 79 73 20 
1A52210 	6C 40 20 62 75 6C 6B 2D 
1A52218 	69 6E 2D 71 68 20 3E 68 
1A52220 	63 71 68 2D 65 6C 65 6D 
1A52228 	20 6C 65 2D 6C 21  0  0 
1A52230 	D8 E5 A0  1 
s"    bulk-in-qh push-qhtds ;" eval
1A52234 	9C 53 A0  1 
1A52238 	1A 20 20 20 62 75 6C 6B 
1A52240 	2D 69 6E 2D 71 68 20 70 
1A52248 	75 73 68 2D 71 68 74 64 
1A52250 	73 20 3B  0 D8 E5 A0  1 
s" : end-bulk-in" eval  ( -- )
1A52258 	9C 53 A0  1  D 3A 20 65 
1A52260 	6E 64 2D 62 75 6C 6B 2D 
1A52268 	69 6E  0  0 D8 E5 A0  1 
 "    debug?  if  ."" end-bulk-in"" cr  then" eval
1A52270 	9C 53 A0  1 27 20 20 20 
1A52278 	64 65 62 75 67 3F 20 20 
1A52280 	69 66 20 20 2E 22 20 65 
1A52288 	6E 64 2D 62 75 6C 6B 2D 
1A52290 	69 6E 22 20 63 72 20 20 
1A52298 	74 68 65 6E  0  0  0  0 
1A522A0 	D8 E5 A0  1 
s"    bulk-in-qh 0=  if  exit  then" eval
1A522A4 	9C 53 A0  1 
1A522A8 	20 20 20 20 62 75 6C 6B 
1A522B0 	2D 69 6E 2D 71 68 20 30 
1A522B8 	3D 20 20 69 66 20 20 65 
1A522C0 	78 69 74 20 20 74 68 65 
1A522C8 	6E  0  0  0 D8 E5 A0  1 

s"    bulk-in-td bulk-in-qh >qh-#tds l@ fixup-bulk-in-data" eval
1A522D0 	9C 53 A0  1 37 20 20 20 
1A522D8 	62 75 6C 6B 2D 69 6E 2D 
1A522E0 	74 64 20 62 75 6C 6B 2D 
1A522E8 	69 6E 2D 71 68 20 3E 71 
1A522F0 	68 2D 23 74 64 73 20 6C 
1A522F8 	40 20 66 69 78 75 70 2D 
1A52300 	62 75 6C 6B 2D 69 6E 2D 
1A52308 	64 61 74 61  0  0  0  0 
1A52310 	D8 E5 A0  1 
s"    bulk-in-td map-out-buf" eval
1A52314 	9C 53 A0  1 
1A52318 	19 20 20 20 62 75 6C 6B 
1A52320 	2D 69 6E 2D 74 64 20 6D 
1A52328 	61 70 2D 6F 75 74 2D 62 
1A52330 	75 66  0  0 D8 E5 A0  1 
s"    bulk-in-qh dup  remove-qh  free-qhtds" eval
1A52338 	9C 53 A0  1 28 20 20 20 
1A52340 	62 75 6C 6B 2D 69 6E 2D 
1A52348 	71 68 20 64 75 70 20 20 
1A52350 	72 65 6D 6F 76 65 2D 71 
1A52358 	68 20 20 66 72 65 65 2D 
1A52360 	71 68 74 64 73  0  0  0 
1A52368 	D8 E5 A0  1 
s"    0 to bulk-in-qh  0 to bulk-in-td ;" eval
1A5236C 	9C 53 A0  1 
1A52370 	25 20 20 20 30 20 74 6F 
1A52378 	20 62 75 6C 6B 2D 69 6E 
1A52380 	2D 71 68 20 20 30 20 74 
1A52388 	6F 20 62 75 6C 6B 2D 69 
1A52390 	6E 2D 74 64 20 3B  0  0 
1A52398 	D8 E5 A0  1 

s" : bulk-in" eval  ( buf len pipe -- actual usberr )
1A5239C 	9C 53 A0  1 
1A523A0 	 9 3A 20 62 75 6C 6B 2D 
1A523A8 	69 6E  0  0 D8 E5 A0  1 
 "    debug?  if  ."" bulk-in"" cr  then" eval
1A523B0 	9C 53 A0  1 23 20 20 20 
1A523B8 	64 65 62 75 67 3F 20 20 
1A523C0 	69 66 20 20 2E 22 20 62 
1A523C8 	75 6C 6B 2D 69 6E 22 20 
1A523D0 	63 72 20 20 74 68 65 6E 
1A523D8 	 0  0  0  0 D8 E5 A0  1 
s"    lock" eval
1A523E0 	9C 53 A0  1  7 20 20 20 
1A523E8 	6C 6F 63 6B  0  0  0  0 
1A523F0 	D8 E5 A0  1 
s"    dup to bulk-in-pipe" eval
1A523F4 	9C 53 A0  1 
1A523F8 	16 20 20 20 64 75 70 20 
1A52400 	74 6F 20 62 75 6C 6B 2D 
1A52408 	69 6E 2D 70 69 70 65  0 
1A52410 	D8 E5 A0  1 
s"    bulk-in-timeout process-bulk-args" eval
1A52414 	9C 53 A0  1 
1A52418 	24 20 20 20 62 75 6C 6B 
1A52420 	2D 69 6E 2D 74 69 6D 65 
1A52428 	6F 75 74 20 70 72 6F 63 
1A52430 	65 73 73 2D 62 75 6C 6B 
1A52438 	2D 61 72 67 73  0  0  0 
1A52440 	D8 E5 A0  1 
s"    alloc-bulk-qhtds  to my-td  to my-qh" eval
1A52444 	9C 53 A0  1 
1A52448 	27 20 20 20 61 6C 6C 6F 
1A52450 	63 2D 62 75 6C 6B 2D 71 
1A52458 	68 74 64 73 20 20 74 6F 
1A52460 	20 6D 79 2D 74 64 20 20 
1A52468 	74 6F 20 6D 79 2D 71 68 
1A52470 	 0  0  0  0 D8 E5 A0  1 

   \ IN TDs
s"   TD_PID_IN my-td fill-bulk-io-tds" eval
1A52478 	9C 53 A0  1 22 20 20 54 
1A52480 	44 5F 50 49 44 5F 49 4E 
1A52488 	20 6D 79 2D 74 64 20 66 
1A52490 	69 6C 6C 2D 62 75 6C 6B 
1A52498 	2D 69 6F 2D 74 64 73  0 
1A524A0 	D8 E5 A0  1 

   \ Start bulk in transaction
s"   my-qh my-speed insert-bulk-qh" eval
1A524A4 	9C 53 A0  1 
1A524A8 	1F 20 20 6D 79 2D 71 68 
1A524B0 	20 6D 79 2D 73 70 65 65 
1A524B8 	64 20 69 6E 73 65 72 74 
1A524C0 	2D 62 75 6C 6B 2D 71 68 
1A524C8 	 0  0  0  0 D8 E5 A0  1 

   \ Process results
s"   my-qh done?  if   0" eval		( actual )	\ System error, timeout
1A524D0 	9C 53 A0  1 15 20 20 6D 
1A524D8 	79 2D 71 68 20 64 6F 6E 
1A524E0 	65 3F 20 20 69 66 20 20 
1A524E8 	20 30  0  0 D8 E5 A0  1 
s"   else" eval
1A524F0 	9C 53 A0  1  6 20 20 65 
1A524F8 	6C 73 65  0 D8 E5 A0  1 
s"      my-td error?  if 0" eval	( actual )	\ USB error
1A52500 	9C 53 A0  1 17 20 20 20 
1A52508 	20 20 6D 79 2D 74 64 20 
1A52510 	65 72 72 6F 72 3F 20 20 
1A52518 	69 66 20 30  0  0  0  0 
1A52520 	D8 E5 A0  1 
s"       else" eval
1A52524 	9C 53 A0  1 
1A52528 	 A 20 20 20 20 20 20 65 
1A52530 	6C 73 65  0 D8 E5 A0  1 
s"          my-td dup my-#tds get-actual" eval		( td actual )
1A52538 	9C 53 A0  1 25 20 20 20 
1A52540 	20 20 20 20 20 20 6D 79 
1A52548 	2D 74 64 20 64 75 70 20 
1A52550 	6D 79 2D 23 74 64 73 20 
1A52558 	67 65 74 2D 61 63 74 75 
1A52560 	61 6C  0  0 D8 E5 A0  1 
s" 	 over >td-buf l@ rot >td-pbuf l@ 2 pick dma-pull" eval	( actual )
1A52568 	9C 53 A0  1 31  9 20 6F 
1A52570 	76 65 72 20 3E 74 64 2D 
1A52578 	62 75 66 20 6C 40 20 72 
1A52580 	6F 74 20 3E 74 64 2D 70 
1A52588 	62 75 66 20 6C 40 20 32 
1A52590 	20 70 69 63 6B 20 64 6D 
1A52598 	61 2D 70 75 6C 6C  0  0 
1A525A0 	D8 E5 A0  1 
s"       then" eval
1A525A4 	9C 53 A0  1 
1A525A8 	 A 20 20 20 20 20 20 74 
1A525B0 	68 65 6E  0 D8 E5 A0  1 
s"    then" eval
1A525B8 	9C 53 A0  1  7 20 20 20 
1A525C0 	74 68 65 6E  0  0  0  0 
1A525C8 	D8 E5 A0  1 

s"    usb-error" eval					( actual usberr )
1A525CC 	9C 53 A0  1 
1A525D0 	 C 20 20 20 75 73 62 2D 
1A525D8 	65 72 72 6F 72  0  0  0 
1A525E0 	D8 E5 A0  1 
s"    my-qh" eval					( actual usberr qh )
1A525E4 	9C 53 A0  1 
1A525E8 	 8 20 20 20 6D 79 2D 71 
1A525F0 	68  0  0  0 D8 E5 A0  1 
s"    my-td dup map-out-buf" eval			( actual usberr qh td )
1A525F8 	9C 53 A0  1 18 20 20 20 
1A52600 	6D 79 2D 74 64 20 64 75 
1A52608 	70 20 6D 61 70 2D 6F 75 
1A52610 	74 2D 62 75 66  0  0  0 
1A52618 	D8 E5 A0  1 
s"    my-#tds fixup-bulk-in-data" eval			( actual usberr qh )
1A5261C 	9C 53 A0  1 
1A52620 	1D 20 20 20 6D 79 2D 23 
1A52628 	74 64 73 20 66 69 78 75 
1A52630 	70 2D 62 75 6C 6B 2D 69 
1A52638 	6E 2D 64 61 74 61  0  0 
1A52640 	D8 E5 A0  1 
s"    dup  remove-qh  free-qhtds" eval			( actual usberr )
1A52644 	9C 53 A0  1 
1A52648 	1D 20 20 20 64 75 70 20 
1A52650 	20 72 65 6D 6F 76 65 2D 
1A52658 	71 68 20 20 66 72 65 65 
1A52660 	2D 71 68 74 64 73  0  0 
1A52668 	D8 E5 A0  1 
s"    unlock ;" eval
1A5266C 	9C 53 A0  1 
1A52670 	 B 20 20 20 75 6E 6C 6F 
1A52678 	63 6B 20 3B  0  0  0  0 
1A52680 	D8 E5 A0  1 

s" : bulk-out" eval  ( buf len pipe -- usberr )
1A52684 	9C 53 A0  1 
1A52688 	 A 3A 20 62 75 6C 6B 2D 
1A52690 	6F 75 74  0 D8 E5 A0  1 
 "    debug?  if  ."" bulk-out"" cr  then" eval
1A52698 	9C 53 A0  1 24 20 20 20 
1A526A0 	64 65 62 75 67 3F 20 20 
1A526A8 	69 66 20 20 2E 22 20 62 
1A526B0 	75 6C 6B 2D 6F 75 74 22 
1A526B8 	20 63 72 20 20 74 68 65 
1A526C0 	6E  0  0  0 D8 E5 A0  1 
s"    lock" eval
1A526C8 	9C 53 A0  1  7 20 20 20 
1A526D0 	6C 6F 63 6B  0  0  0  0 
1A526D8 	D8 E5 A0  1 
s"    dup to bulk-out-pipe" eval
1A526DC 	9C 53 A0  1 
1A526E0 	17 20 20 20 64 75 70 20 
1A526E8 	74 6F 20 62 75 6C 6B 2D 
1A526F0 	6F 75 74 2D 70 69 70 65 
1A526F8 	 0  0  0  0 D8 E5 A0  1 
s"    bulk-out-timeout process-bulk-args" eval
1A52700 	9C 53 A0  1 25 20 20 20 
1A52708 	62 75 6C 6B 2D 6F 75 74 
1A52710 	2D 74 69 6D 65 6F 75 74 
1A52718 	20 70 72 6F 63 65 73 73 
1A52720 	2D 62 75 6C 6B 2D 61 72 
1A52728 	67 73  0  0 D8 E5 A0  1 
s"    alloc-bulk-qhtds  to my-td  to my-qh" eval
1A52730 	9C 53 A0  1 27 20 20 20 
1A52738 	61 6C 6C 6F 63 2D 62 75 
1A52740 	6C 6B 2D 71 68 74 64 73 
1A52748 	20 20 74 6F 20 6D 79 2D 
1A52750 	74 64 20 20 74 6F 20 6D 
1A52758 	79 2D 71 68  0  0  0  0 
1A52760 	D8 E5 A0  1 

   \ OUT TDs
s"   TD_PID_OUT my-td fill-bulk-io-tds" eval
1A52764 	9C 53 A0  1 
1A52768 	23 20 20 54 44 5F 50 49 
1A52770 	44 5F 4F 55 54 20 6D 79 
1A52778 	2D 74 64 20 66 69 6C 6C 
1A52780 	2D 62 75 6C 6B 2D 69 6F 
1A52788 	2D 74 64 73  0  0  0  0 
1A52790 	D8 E5 A0  1 

   \ Start bulk out transaction
s"   my-qh my-speed insert-bulk-qh" eval
1A52794 	9C 53 A0  1 
1A52798 	1F 20 20 6D 79 2D 71 68 
1A527A0 	20 6D 79 2D 73 70 65 65 
1A527A8 	64 20 69 6E 73 65 72 74 
1A527B0 	2D 62 75 6C 6B 2D 71 68 
1A527B8 	 0  0  0  0 D8 E5 A0  1 

   \ Process results
s"   my-qh done? 0=  if  my-td error? drop  then" eval
1A527C0 	9C 53 A0  1 2D 20 20 6D 
1A527C8 	79 2D 71 68 20 64 6F 6E 
1A527D0 	65 3F 20 30 3D 20 20 69 
1A527D8 	66 20 20 6D 79 2D 74 64 
1A527E0 	20 65 72 72 6F 72 3F 20 
1A527E8 	64 72 6F 70 20 20 74 68 
1A527F0 	65 6E  0  0 D8 E5 A0  1 

s"    usb-error" eval					( actual usberr )
1A527F8 	9C 53 A0  1  C 20 20 20 
1A52800 	75 73 62 2D 65 72 72 6F 
1A52808 	72  0  0  0 D8 E5 A0  1 
s"    my-qh" eval					( actual usberr qh )
1A52810 	9C 53 A0  1  8 20 20 20 
1A52818 	6D 79 2D 71 68  0  0  0 
1A52820 	D8 E5 A0  1 
s"    my-td dup map-out-buf" eval			( actual usberr qh td )
1A52824 	9C 53 A0  1 
1A52828 	18 20 20 20 6D 79 2D 74 
1A52830 	64 20 64 75 70 20 6D 61 
1A52838 	70 2D 6F 75 74 2D 62 75 
1A52840 	66  0  0  0 D8 E5 A0  1 
s"    my-#tds fixup-bulk-out-data" eval			( actual usberr qh )
1A52848 	9C 53 A0  1 1E 20 20 20 
1A52850 	6D 79 2D 23 74 64 73 20 
1A52858 	66 69 78 75 70 2D 62 75 
1A52860 	6C 6B 2D 6F 75 74 2D 64 
1A52868 	61 74 61  0 D8 E5 A0  1 
s"    dup  remove-qh  free-qhtds" eval			( actual usberr )
1A52870 	9C 53 A0  1 1D 20 20 20 
1A52878 	64 75 70 20 20 72 65 6D 
1A52880 	6F 76 65 2D 71 68 20 20 
1A52888 	66 72 65 65 2D 71 68 74 
1A52890 	64 73  0  0 D8 E5 A0  1 
s"    unlock ;" eval
1A52898 	9C 53 A0  1  B 20 20 20 
1A528A0 	75 6E 6C 6F 63 6B 20 3B 
1A528A8 	 0  0  0  0 D8 E5 A0  1 

s" : (end-extra)  ( -- )  end-bulk-in  ;" eval
1A528B0 	9C 53 A0  1 25 3A 20 28 
1A528B8 	65 6E 64 2D 65 78 74 72 
1A528C0 	61 29 20 20 28 20 2D 2D 
1A528C8 	20 29 20 20 65 6E 64 2D 
1A528D0 	62 75 6C 6B 2D 69 6E 20 
1A528D8 	20 3B  0  0 D8 E5 A0  1 

;
1A528E0 	58 46 A0  1 

OpenFirmware/dev/usb2/hcd/uhci/bulk.fth_AL	19DC 1A528E4 purpose: UHCI USB Controller probe
\ See license at end of file

hex

: probefth
1A528E4 	 0  0  0 70 
1A528E8 	72 6F 62 65 66 74 68 88 
1A528F0 	14  F A5  1 20 40 A0  1 

s" : probe-root-hub-port" eval  ( port -- )
1A528F8 	9C 53 A0  1 15 3A 20 70 
1A52900 	72 6F 62 65 2D 72 6F 6F 
1A52908 	74 2D 68 75 62 2D 70 6F 
1A52910 	72 74  0  0 D8 E5 A0  1 
   \ Reset the port to perform connection status and speed detection
s"    dup reset-port" eval				( port )
1A52918 	9C 53 A0  1 11 20 20 20 
1A52920 	64 75 70 20 72 65 73 65 
1A52928 	74 2D 70 6F 72 74  0  0 
1A52930 	D8 E5 A0  1 
s"    dup disable-old-nodes" eval			( port )
1A52934 	9C 53 A0  1 
1A52938 	18 20 20 20 64 75 70 20 
1A52940 	64 69 73 61 62 6C 65 2D 
1A52948 	6F 6C 64 2D 6E 6F 64 65 
1A52950 	73  0  0  0 D8 E5 A0  1 
s"    dup portsc@ 1 and 0=  if  drop exit  then" eval	( port )  \ No device-connected
1A52958 	9C 53 A0  1 2C 20 20 20 
1A52960 	64 75 70 20 70 6F 72 74 
1A52968 	73 63 40 20 31 20 61 6E 
1A52970 	64 20 30 3D 20 20 69 66 
1A52978 	20 20 64 72 6F 70 20 65 
1A52980 	78 69 74 20 20 74 68 65 
1A52988 	6E  0  0  0 D8 E5 A0  1 

s"    dup portsc@ 100 and  if  speed-low  else  speed-full  then" eval	( port speed )
1A52990 	9C 53 A0  1 3D 20 20 20 
1A52998 	64 75 70 20 70 6F 72 74 
1A529A0 	73 63 40 20 31 30 30 20 
1A529A8 	61 6E 64 20 20 69 66 20 
1A529B0 	20 73 70 65 65 64 2D 6C 
1A529B8 	6F 77 20 20 65 6C 73 65 
1A529C0 	20 20 73 70 65 65 64 2D 
1A529C8 	66 75 6C 6C 20 20 74 68 
1A529D0 	65 6E  0  0 D8 E5 A0  1 

   \ hub-port and hub-speed are irrelevant for UHCI (USB 1.1)
s"    0 0" eval							( port speed hub-port hub-dev )
1A529D8 	9C 53 A0  1  6 20 20 20 
1A529E0 	30 20 30  0 D8 E5 A0  1 

   \ Execute setup-new-node in root context and make-device-node in hub node context
s"    setup-new-node  if  execute  then	;" eval
1A529E8 	9C 53 A0  1 26 20 20 20 
1A529F0 	73 65 74 75 70 2D 6E 65 
1A529F8 	77 2D 6E 6F 64 65 20 20 
1A52A00 	69 66 20 20 65 78 65 63 
1A52A08 	75 74 65 20 20 74 68 65 
1A52A10 	6E  9 3B  0 D8 E5 A0  1 

s" : power-ports  ( -- )  ;" eval
1A52A18 	9C 53 A0  1 18 3A 20 70 
1A52A20 	6F 77 65 72 2D 70 6F 72 
1A52A28 	74 73 20 20 28 20 2D 2D 
1A52A30 	20 29 20 20 3B  0  0  0 
1A52A38 	D8 E5 A0  1 

s" : probe-root-hub" eval  ( -- )
1A52A3C 	9C 53 A0  1 
1A52A40 	10 3A 20 70 72 6F 62 65 
1A52A48 	2D 72 6F 6F 74 2D 68 75 
1A52A50 	62  0  0  0 D8 E5 A0  1 
   \ Set active-package so device nodes can be added and removed
s"    my-self ihandle>phandle push-package" eval
1A52A58 	9C 53 A0  1 27 20 20 20 
1A52A60 	6D 79 2D 73 65 6C 66 20 
1A52A68 	69 68 61 6E 64 6C 65 3E 
1A52A70 	70 68 61 6E 64 6C 65 20 
1A52A78 	70 75 73 68 2D 70 61 63 
1A52A80 	6B 61 67 65  0  0  0  0 
1A52A88 	D8 E5 A0  1 

s"    alloc-pkt-buf" eval
1A52A8C 	9C 53 A0  1 
1A52A90 	10 20 20 20 61 6C 6C 6F 
1A52A98 	63 2D 70 6B 74 2D 62 75 
1A52AA0 	66  0  0  0 D8 E5 A0  1 
s"    2 0  do" eval
1A52AA8 	9C 53 A0  1  A 20 20 20 
1A52AB0 	32 20 30 20 20 64 6F  0 
1A52AB8 	D8 E5 A0  1 
s"       i portsc@ h# a and  if" eval
1A52ABC 	9C 53 A0  1 
1A52AC0 	1C 20 20 20 20 20 20 69 
1A52AC8 	20 70 6F 72 74 73 63 40 
1A52AD0 	20 68 23 20 61 20 61 6E 
1A52AD8 	64 20 20 69 66  0  0  0 
1A52AE0 	D8 E5 A0  1 
\        i rm-obsolete-children			\ Remove obsolete device nodes
s"         i ['] probe-root-hub-port catch  if" eval
1A52AE4 	9C 53 A0  1 
1A52AE8 	2B 20 20 20 20 20 20 20 
1A52AF0 	20 69 20 5B 27 5D 20 70 
1A52AF8 	72 6F 62 65 2D 72 6F 6F 
1A52B00 	74 2D 68 75 62 2D 70 6F 
1A52B08 	72 74 20 63 61 74 63 68 
1A52B10 	20 20 69 66  0  0  0  0 
1A52B18 	D8 E5 A0  1 
"            drop ."" Failed to probe root port "" i .d cr" eval
1A52B1C 	9C 53 A0  1 
1A52B20 	36 20 20 20 20 20 20 20 
1A52B28 	20 20 20 20 64 72 6F 70 
1A52B30 	20 2E 22 20 46 61 69 6C 
1A52B38 	65 64 20 74 6F 20 70 72 
1A52B40 	6F 62 65 20 72 6F 6F 74 
1A52B48 	20 70 6F 72 74 20 22 20 
1A52B50 	69 20 2E 64 20 63 72  0 
1A52B58 	D8 E5 A0  1 
s"         then" eval
1A52B5C 	9C 53 A0  1 
1A52B60 	 C 20 20 20 20 20 20 20 
1A52B68 	20 74 68 65 6E  0  0  0 
1A52B70 	D8 E5 A0  1 
s"         i portsc@ i portsc!" eval			\ Clear change bits
1A52B74 	9C 53 A0  1 
1A52B78 	1B 20 20 20 20 20 20 20 
1A52B80 	20 69 20 70 6F 72 74 73 
1A52B88 	63 40 20 69 20 70 6F 72 
1A52B90 	74 73 63 21  0  0  0  0 
1A52B98 	D8 E5 A0  1 
s"      else" eval
1A52B9C 	9C 53 A0  1 
1A52BA0 	 9 20 20 20 20 20 65 6C 
1A52BA8 	73 65  0  0 D8 E5 A0  1 
s"         i port-is-hub?  if" eval     ( phandle )     \ Already-connected hub?
1A52BB0 	9C 53 A0  1 1A 20 20 20 
1A52BB8 	20 20 20 20 20 69 20 70 
1A52BC0 	6F 72 74 2D 69 73 2D 68 
1A52BC8 	75 62 3F 20 20 69 66  0 
1A52BD0 	D8 E5 A0  1 
s"            reprobe-hub-node" eval                    \ Check for changes on its ports
1A52BD4 	9C 53 A0  1 
1A52BD8 	1B 20 20 20 20 20 20 20 
1A52BE0 	20 20 20 20 72 65 70 72 
1A52BE8 	6F 62 65 2D 68 75 62 2D 
1A52BF0 	6E 6F 64 65  0  0  0  0 
1A52BF8 	D8 E5 A0  1 
s"         then" eval
1A52BFC 	9C 53 A0  1 
1A52C00 	 C 20 20 20 20 20 20 20 
1A52C08 	20 74 68 65 6E  0  0  0 
1A52C10 	D8 E5 A0  1 
s"      then" eval
1A52C14 	9C 53 A0  1 
1A52C18 	 9 20 20 20 20 20 74 68 
1A52C20 	65 6E  0  0 D8 E5 A0  1 
s"   loop" eval
1A52C28 	9C 53 A0  1  6 20 20 6C 
1A52C30 	6F 6F 70  0 D8 E5 A0  1 
s"   free-pkt-buf" eval
1A52C38 	9C 53 A0  1  E 20 20 66 
1A52C40 	72 65 65 2D 70 6B 74 2D 
1A52C48 	62 75 66  0 D8 E5 A0  1 

s"   pop-package ;" eval
1A52C50 	9C 53 A0  1  F 20 20 70 
1A52C58 	6F 70 2D 70 61 63 6B 61 
1A52C60 	67 65 20 3B  0  0  0  0 
1A52C68 	D8 E5 A0  1 

s" : do-resume   init-struct   start-usb ;" eval
1A52C6C 	9C 53 A0  1 
1A52C70 	27 3A 20 64 6F 2D 72 65 
1A52C78 	73 75 6D 65 20 20 20 69 
1A52C80 	6E 69 74 2D 73 74 72 75 
1A52C88 	63 74 20 20 20 73 74 61 
1A52C90 	72 74 2D 75 73 62 20 3B 
1A52C98 	 0  0  0  0 D8 E5 A0  1 

\ This is a sneaky way to determine if the hardware has been turned off without the software's knowledge
s" : suspended? ( -- flag )  flbaseadd@ 0=  framelist-phys 0<>  and  ;" eval
1A52CA0 	9C 53 A0  1 43 3A 20 73 
1A52CA8 	75 73 70 65 6E 64 65 64 
1A52CB0 	3F 20 28 20 2D 2D 20 66 
1A52CB8 	6C 61 67 20 29 20 20 66 
1A52CC0 	6C 62 61 73 65 61 64 64 
1A52CC8 	40 20 30 3D 20 20 66 72 
1A52CD0 	61 6D 65 6C 69 73 74 2D 
1A52CD8 	70 68 79 73 20 30 3C 3E 
1A52CE0 	20 20 61 6E 64 20 20 3B 
1A52CE8 	 0  0  0  0 D8 E5 A0  1 

s" : open" eval  ( -- flag )
1A52CF0 	9C 53 A0  1  6 3A 20 6F 
1A52CF8 	70 65 6E  0 D8 E5 A0  1 
s"   parse-my-args" eval
1A52D00 	9C 53 A0  1  F 20 20 70 
1A52D08 	61 72 73 65 2D 6D 79 2D 
1A52D10 	61 72 67 73  0  0  0  0 
1A52D18 	D8 E5 A0  1 
s"   open-count 0=  if" eval
1A52D1C 	9C 53 A0  1 
1A52D20 	13 20 20 6F 70 65 6E 2D 
1A52D28 	63 6F 75 6E 74 20 30 3D 
1A52D30 	20 20 69 66  0  0  0  0 
1A52D38 	D8 E5 A0  1 
s"      map-regs" eval
1A52D3C 	9C 53 A0  1 
1A52D40 	 D 20 20 20 20 20 6D 61 
1A52D48 	70 2D 72 65 67 73  0  0 
1A52D50 	D8 E5 A0  1 
s"      first-open?  if" eval
1A52D54 	9C 53 A0  1 
1A52D58 	14 20 20 20 20 20 66 69 
1A52D60 	72 73 74 2D 6F 70 65 6E 
1A52D68 	3F 20 20 69 66  0  0  0 
1A52D70 	D8 E5 A0  1 
s"         false to first-open?" eval
1A52D74 	9C 53 A0  1 
1A52D78 	1C 20 20 20 20 20 20 20 
1A52D80 	20 66 61 6C 73 65 20 74 
1A52D88 	6F 20 66 69 72 73 74 2D 
1A52D90 	6F 70 65 6E 3F  0  0  0 
1A52D98 	D8 E5 A0  1 
s"         ?disable-smis" eval
1A52D9C 	9C 53 A0  1 
1A52DA0 	15 20 20 20 20 20 20 20 
1A52DA8 	20 3F 64 69 73 61 62 6C 
1A52DB0 	65 2D 73 6D 69 73  0  0 
1A52DB8 	D8 E5 A0  1 
s"         reset-usb" eval
1A52DBC 	9C 53 A0  1 
1A52DC0 	11 20 20 20 20 20 20 20 
1A52DC8 	20 72 65 73 65 74 2D 75 
1A52DD0 	73 62  0  0 D8 E5 A0  1 
s"         init-lists" eval
1A52DD8 	9C 53 A0  1 12 20 20 20 
1A52DE0 	20 20 20 20 20 69 6E 69 
1A52DE8 	74 2D 6C 69 73 74 73  0 
1A52DF0 	D8 E5 A0  1 
s"         do-resume" eval
1A52DF4 	9C 53 A0  1 
1A52DF8 	11 20 20 20 20 20 20 20 
1A52E00 	20 64 6F 2D 72 65 73 75 
1A52E08 	6D 65  0  0 D8 E5 A0  1 
s"      then" eval
1A52E10 	9C 53 A0  1  9 20 20 20 
1A52E18 	20 20 74 68 65 6E  0  0 
1A52E20 	D8 E5 A0  1 

s"      suspended?  if  do-resume  then" eval
1A52E24 	9C 53 A0  1 
1A52E28 	24 20 20 20 20 20 73 75 
1A52E30 	73 70 65 6E 64 65 64 3F 
1A52E38 	20 20 69 66 20 20 64 6F 
1A52E40 	2D 72 65 73 75 6D 65 20 
1A52E48 	20 74 68 65 6E  0  0  0 
1A52E50 	D8 E5 A0  1 

s"      alloc-dma-buf" eval
1A52E54 	9C 53 A0  1 
1A52E58 	12 20 20 20 20 20 61 6C 
1A52E60 	6C 6F 63 2D 64 6D 61 2D 
1A52E68 	62 75 66  0 D8 E5 A0  1 
s"   then" eval
1A52E70 	9C 53 A0  1  6 20 20 74 
1A52E78 	68 65 6E  0 D8 E5 A0  1 
s"   probe-root-hub" eval
1A52E80 	9C 53 A0  1 10 20 20 70 
1A52E88 	72 6F 62 65 2D 72 6F 6F 
1A52E90 	74 2D 68 75 62  0  0  0 
1A52E98 	D8 E5 A0  1 
s"   open-count 1+ to open-count" eval
1A52E9C 	9C 53 A0  1 
1A52EA0 	1D 20 20 6F 70 65 6E 2D 
1A52EA8 	63 6F 75 6E 74 20 31 2B 
1A52EB0 	20 74 6F 20 6F 70 65 6E 
1A52EB8 	2D 63 6F 75 6E 74  0  0 
1A52EC0 	D8 E5 A0  1 
s"   true ;" eval
1A52EC4 	9C 53 A0  1 
1A52EC8 	 8 20 20 74 72 75 65 20 
1A52ED0 	3B  0  0  0 D8 E5 A0  1 

s" : close" eval  ( -- )
1A52ED8 	9C 53 A0  1  7 3A 20 63 
1A52EE0 	6C 6F 73 65  0  0  0  0 
1A52EE8 	D8 E5 A0  1 
s"   open-count 1- to open-count" eval
1A52EEC 	9C 53 A0  1 
1A52EF0 	1D 20 20 6F 70 65 6E 2D 
1A52EF8 	63 6F 75 6E 74 20 31 2D 
1A52F00 	20 74 6F 20 6F 70 65 6E 
1A52F08 	2D 63 6F 75 6E 74  0  0 
1A52F10 	D8 E5 A0  1 
s"   end-extra" eval
1A52F14 	9C 53 A0  1 
1A52F18 	 B 20 20 65 6E 64 2D 65 
1A52F20 	78 74 72 61  0  0  0  0 
1A52F28 	D8 E5 A0  1 
s"   open-count 0=  if  free-dma-buf  then ;" eval \ Don't unmap
1A52F2C 	9C 53 A0  1 
1A52F30 	29 20 20 6F 70 65 6E 2D 
1A52F38 	63 6F 75 6E 74 20 30 3D 
1A52F40 	20 20 69 66 20 20 66 72 
1A52F48 	65 65 2D 64 6D 61 2D 62 
1A52F50 	75 66 20 20 74 68 65 6E 
1A52F58 	20 3B  0  0 D8 E5 A0  1 
;
1A52F60 	58 46 A0  1 

OpenFirmware/dev/usb2/hcd/uhci/probe.fth_AL	680 1A52F64 purpose: Data structures and manuipulation routines for OHCI USB Controller

hex
headers

\ XXX Isochronous is not supported in the current version of the OHCI driver

\ ---------------------------------------------------------------------------
\ Data structures for this implementation of the OHCI USB Driver include:
\   - hcca 		256 bytes defined by OCHI Spec for USB HC
\   - ed-control	pointer to the control ED list
\   - ed-bulk		pointer to the bulk ED list
\   - intr		internal array of interrupts (to complement the hcca)
\ ---------------------------------------------------------------------------

\ ---------------------------------------------------------------------------
\ HcHCCA as defined by the OHCI Spec; 256-byte aligned
\ ---------------------------------------------------------------------------

0 value intr			\ Software interrupt buffer
1A52F90 	 0  0  0 69 6E 74 72 84 
1A52F98 	 0  0 A0  1 50 40 A0  1 
1A52FA0 	94  E  0  0 
0 value hcca			\ Virtual address of HcHCCA
1A52FA4 	 0  0  0 68 
1A52FA8 	63 63 61 84 9C 2F A5  1 
1A52FB0 	50 40 A0  1 98  E  0  0 
0 value hcca-unaligned		\ Unaligned virtual address of HcHCCA
1A52FB8 	 0 68 63 63 61 2D 75 6E 
1A52FC0 	61 6C 69 67 6E 65 64 8E 
1A52FC8 	B0 2F A5  1 50 40 A0  1 
1A52FD0 	9C  E  0  0 
0 value hcca-phys		\ Physical address of HcHCCA
1A52FD4 	 0  0 68 63 
1A52FD8 	63 61 2D 70 68 79 73 89 
1A52FE0 	CC 2F A5  1 50 40 A0  1 
1A52FE8 	A0  E  0  0 

\ HCCA
d# 32 constant #intr
1A52FEC 	 0  0 23 69 
1A52FF0 	6E 74 72 85 E4 2F A5  1 
1A52FF8 	68 40 A0  1 20  0  0  0 

struct  ( hcca )
#intr 4 * field >hcca-intr	\ Physical addresses of interrupt EDs
1A53000 	 0 3E 68 63 63 61 2D 69 
1A53008 	6E 74 72 8A F8 2F A5  1 
1A53010 	50 EE A0  1  0  0  0  0 
2 field >hcca-frame
1A53018 	3E 68 63 63 61 2D 66 72 
1A53020 	61 6D 65 8B 10 30 A5  1 
1A53028 	50 EE A0  1 80  0  0  0 
2 field >hcca-pad
1A53030 	 0  0 3E 68 63 63 61 2D 
1A53038 	70 61 64 89 28 30 A5  1 
1A53040 	50 EE A0  1 82  0  0  0 
4 field >hcca-done		\ Physical addresses of done EDs
1A53048 	 0 3E 68 63 63 61 2D 64 
1A53050 	6F 6E 65 8A 40 30 A5  1 
1A53058 	50 EE A0  1 84  0  0  0 
d# 120 field >hcca-reserved
1A53060 	 0 3E 68 63 63 61 2D 72 
1A53068 	65 73 65 72 76 65 64 8E 
1A53070 	58 30 A5  1 50 EE A0  1 
1A53078 	88  0  0  0 
constant /hcca
1A5307C 	 0  0 2F 68 
1A53080 	63 63 61 85 74 30 A5  1 
1A53088 	68 40 A0  1  0  1  0  0 

: hcca!  ( padr idx -- )  4 * hcca + le-l!  ;
1A53090 	 0  0 68 63 63 61 21 85 
1A53098 	88 30 A5  1 20 40 A0  1 
1A530A0 	B0 6F A0  1 1C 5F A0  1 
1A530A8 	B0 2F A5  1  4 45 A0  1 
1A530B0 	50 36 A4  1 58 46 A0  1 

: init-hcca  ( -- )
1A530B8 	 0  0 69 6E 69 74 2D 68 
1A530C0 	63 63 61 89 9C 30 A5  1 
1A530C8 	20 40 A0  1 
   \ Allocate hcca
   /hcca aligned256-alloc
1A530CC 	88 30 A5  1 
1A530D0 	EC 39 A4  1 
   dup to hcca				\ Aligned address
1A530D4 	40 49 A0  1 
1A530D8 	B8 40 A0  1 B0 2F A5  1 
   swap to hcca-unaligned		\ Unaligned address
1A530E0 	68 49 A0  1 B8 40 A0  1 
1A530E8 	CC 2F A5  1 
   /hcca true dma-map-in to hcca-phys	\ Physical address
1A530EC 	88 30 A5  1 
1A530F0 	 4 70 A0  1 AC 37 A4  1 
1A530F8 	B8 40 A0  1 E4 2F A5  1 

   \ Initialize hcca
   hcca /hcca erase
1A53100 	B0 2F A5  1 88 30 A5  1 
1A53108 	F0 72 A0  1 
   hcca hcca-phys /hcca dma-push
1A5310C 	B0 2F A5  1 
1A53110 	E4 2F A5  1 88 30 A5  1 
1A53118 	FC 36 A4  1 
;
1A5311C 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Internal interrupt list per >hcca-intr entry
\
\ XXX I can see how this can be expanded to >intr-head32ms, >intr-tail32ms,
\ XXX and so on, to support the various poll intervals.  See comment on
\ XXX interrupt scheduling below.
\ ---------------------------------------------------------------------------
struct 				\ An entry of intr
   4 field >intr-head		\ Virtual address of interrupt head
1A53120 	 0 3E 69 6E 74 72 2D 68 
1A53128 	65 61 64 8A C8 30 A5  1 
1A53130 	50 EE A0  1  0  0  0  0 
   4 field >intr-tail		\ Virtual address of interrupt tail
1A53138 	 0 3E 69 6E 74 72 2D 74 
1A53140 	61 69 6C 8A 30 31 A5  1 
1A53148 	50 EE A0  1  4  0  0  0 
   4 field >iso-head		\ Virtual address of isochronous head
1A53150 	 0  0 3E 69 73 6F 2D 68 
1A53158 	65 61 64 89 48 31 A5  1 
1A53160 	50 EE A0  1  8  0  0  0 
   4 field >iso-tail		\ Virtual address of isochronous tail
1A53168 	 0  0 3E 69 73 6F 2D 74 
1A53170 	61 69 6C 89 60 31 A5  1 
1A53178 	50 EE A0  1  C  0  0  0 
dup constant /intr-entry
1A53180 	2F 69 6E 74 72 2D 65 6E 
1A53188 	74 72 79 8B 78 31 A5  1 
1A53190 	68 40 A0  1 10  0  0  0 
#intr * constant /intr
1A53198 	 0  0 2F 69 6E 74 72 85 
1A531A0 	90 31 A5  1 68 40 A0  1 
1A531A8 	 0  2  0  0 

: init-intr  ( -- )
1A531AC 	 0  0 69 6E 
1A531B0 	69 74 2D 69 6E 74 72 89 
1A531B8 	A4 31 A5  1 20 40 A0  1 
   /intr alloc-mem dup to intr		\ Allocate intr
1A531C0 	A4 31 A5  1 F0 6C A0  1 
1A531C8 	40 49 A0  1 B8 40 A0  1 
1A531D0 	9C 2F A5  1 
   /intr erase				\ Initialize intr
1A531D4 	A4 31 A5  1 
1A531D8 	F0 72 A0  1 
;
1A531DC 	58 46 A0  1 

: 'intr  ( idx -- adr )   /intr-entry * intr +  ;
1A531E0 	 0  0 27 69 6E 74 72 85 
1A531E8 	BC 31 A5  1 20 40 A0  1 
1A531F0 	90 31 A5  1 1C 5F A0  1 
1A531F8 	9C 2F A5  1  4 45 A0  1 
1A53200 	58 46 A0  1 
: intr-head@  ( idx -- adr )  'intr >intr-head l@  ;
1A53204 	 0 69 6E 74 
1A53208 	72 2D 68 65 61 64 40 8A 
1A53210 	EC 31 A5  1 20 40 A0  1 
1A53218 	EC 31 A5  1 30 31 A5  1 
1A53220 	6C 4C A0  1 58 46 A0  1 
: intr-head!  ( adr idx -- )  'intr >intr-head l!  ;
1A53228 	 0 69 6E 74 72 2D 68 65 
1A53230 	61 64 21 8A 14 32 A5  1 
1A53238 	20 40 A0  1 EC 31 A5  1 
1A53240 	30 31 A5  1 7C 4D A0  1 
1A53248 	58 46 A0  1 
: intr-tail@  ( idx -- adr )  'intr >intr-tail l@  ;
1A5324C 	 0 69 6E 74 
1A53250 	72 2D 74 61 69 6C 40 8A 
1A53258 	38 32 A5  1 20 40 A0  1 
1A53260 	EC 31 A5  1 48 31 A5  1 
1A53268 	6C 4C A0  1 58 46 A0  1 
: intr-tail!  ( adr idx -- )  'intr >intr-tail l!  ;
1A53270 	 0 69 6E 74 72 2D 74 61 
1A53278 	69 6C 21 8A 5C 32 A5  1 
1A53280 	20 40 A0  1 EC 31 A5  1 
1A53288 	48 31 A5  1 7C 4D A0  1 
1A53290 	58 46 A0  1 
: iso-head@   ( idx -- adr )  'intr >iso-head l@   ;
1A53294 	 0  0 69 73 
1A53298 	6F 2D 68 65 61 64 40 89 
1A532A0 	80 32 A5  1 20 40 A0  1 
1A532A8 	EC 31 A5  1 60 31 A5  1 
1A532B0 	6C 4C A0  1 58 46 A0  1 
: iso-head!   ( adr idx -- )  'intr >iso-head l!   ;
1A532B8 	 0  0 69 73 6F 2D 68 65 
1A532C0 	61 64 21 89 A4 32 A5  1 
1A532C8 	20 40 A0  1 EC 31 A5  1 
1A532D0 	60 31 A5  1 7C 4D A0  1 
1A532D8 	58 46 A0  1 
: iso-tail@   ( idx -- adr )  'intr >iso-tail l@   ;
1A532DC 	 0  0 69 73 
1A532E0 	6F 2D 74 61 69 6C 40 89 
1A532E8 	C8 32 A5  1 20 40 A0  1 
1A532F0 	EC 31 A5  1 78 31 A5  1 
1A532F8 	6C 4C A0  1 58 46 A0  1 
: iso-tail!   ( adr idx -- )  'intr >iso-tail l!   ;
1A53300 	 0  0 69 73 6F 2D 74 61 
1A53308 	69 6C 21 89 EC 32 A5  1 
1A53310 	20 40 A0  1 EC 31 A5  1 
1A53318 	78 31 A5  1 7C 4D A0  1 
1A53320 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Endpoint descriptor (ED) as defined by the OHCI Spec; 16-byte aligned
\ ---------------------------------------------------------------------------

\ XXX If we add ed-control-tail & ed-bulk-tail, then insert-* does not have
\ XXX to disable the function, we need to skip tail until insert is done.

0 value ed-control		\ Virtual address of head of control ED list
1A53324 	 0 65 64 2D 
1A53328 	63 6F 6E 74 72 6F 6C 8A 
1A53330 	10 33 A5  1 50 40 A0  1 
1A53338 	A4  E  0  0 
0 value ed-bulk			\ Virtual address of head of bulk ED list
1A5333C 	65 64 2D 62 
1A53340 	75 6C 6B 87 34 33 A5  1 
1A53348 	50 40 A0  1 A8  E  0  0 

struct				\ Beginning of ED
4 field >hced-control		\ ED control info
1A53350 	 0  0 3E 68 63 65 64 2D 
1A53358 	63 6F 6E 74 72 6F 6C 8D 
1A53360 	48 33 A5  1 50 EE A0  1 
1A53368 	 0  0  0  0 
4 field >hced-tdtail		\ Physical address of TD tail
1A5336C 	 0  0  0 3E 
1A53370 	68 63 65 64 2D 74 64 74 
1A53378 	61 69 6C 8C 64 33 A5  1 
1A53380 	50 EE A0  1  4  0  0  0 
4 field >hced-tdhead		\ Physical address of TD head
1A53388 	 0  0  0 3E 68 63 65 64 
1A53390 	2D 74 64 68 65 61 64 8C 
1A53398 	80 33 A5  1 50 EE A0  1 
1A533A0 	 8  0  0  0 
4 field >hced-next		\ Physical address of next ED
1A533A4 	 0 3E 68 63 
1A533A8 	65 64 2D 6E 65 78 74 8A 
1A533B0 	9C 33 A5  1 50 EE A0  1 
1A533B8 	 C  0  0  0 
dup constant /hced
1A533BC 	 0  0 2F 68 
1A533C0 	63 65 64 85 B4 33 A5  1 
1A533C8 	68 40 A0  1 10  0  0  0 
				\ Driver specific fields
4 field >ed-phys		\ Physical address of HC ED
1A533D0 	 0  0  0 3E 65 64 2D 70 
1A533D8 	68 79 73 88 C8 33 A5  1 
1A533E0 	50 EE A0  1 10  0  0  0 
4 field >ed-next		\ Pointer to the next endpoint
1A533E8 	 0  0  0 3E 65 64 2D 6E 
1A533F0 	65 78 74 88 E0 33 A5  1 
1A533F8 	50 EE A0  1 14  0  0  0 
4 field >ed-prev		\ Pointer to the previous endpoint
1A53400 	 0  0  0 3E 65 64 2D 70 
1A53408 	72 65 76 88 F8 33 A5  1 
1A53410 	50 EE A0  1 18  0  0  0 
4 field >ed-unaligned		\ Unaligned virtual address of the ED
1A53418 	 0  0 3E 65 64 2D 75 6E 
1A53420 	61 6C 69 67 6E 65 64 8D 
1A53428 	10 34 A5  1 50 EE A0  1 
1A53430 	1C  0  0  0 
4 field >ed-size		\ Size of EDs+TDs
1A53434 	 0  0  0 3E 
1A53438 	65 64 2D 73 69 7A 65 88 
1A53440 	2C 34 A5  1 50 EE A0  1 
1A53448 	20  0  0  0 
d# 32 round-up			\ Multiple of 32 bytes
				\ 32 bytes because there are cases where
				\ EDs and TDs are allocated together
dup constant /ed		\ Size of each ed
1A5344C 	2F 65 64 83 
1A53450 	44 34 A5  1 68 40 A0  1 
1A53458 	40  0  0  0 
#intr * constant /eds		\ Size of all eds allocated at a time
1A5345C 	 0  0  0 2F 
1A53460 	65 64 73 84 54 34 A5  1 
1A53468 	68 40 A0  1  0  8  0  0 

\ >hced-control constants
0000 constant ED_DIR_TD
1A53470 	 0  0 65 64 5F 64 69 72 
1A53478 	5F 74 64 89 68 34 A5  1 
1A53480 	68 40 A0  1  0  0  0  0 
0800 constant ED_DIR_OUT
1A53488 	 0 65 64 5F 64 69 72 5F 
1A53490 	6F 75 74 8A 80 34 A5  1 
1A53498 	68 40 A0  1  0  8  0  0 
1000 constant ED_DIR_IN
1A534A0 	 0  0 65 64 5F 64 69 72 
1A534A8 	5F 69 6E 89 98 34 A5  1 
1A534B0 	68 40 A0  1  0 10  0  0 
1800 constant ED_DIR_MASK
1A534B8 	65 64 5F 64 69 72 5F 6D 
1A534C0 	61 73 6B 8B B0 34 A5  1 
1A534C8 	68 40 A0  1  0 18  0  0 

0000 constant ED_SPEED_FULL
1A534D0 	 0  0 65 64 5F 73 70 65 
1A534D8 	65 64 5F 66 75 6C 6C 8D 
1A534E0 	C8 34 A5  1 68 40 A0  1 
1A534E8 	 0  0  0  0 
2000 constant ED_SPEED_LO
1A534EC 	65 64 5F 73 
1A534F0 	70 65 65 64 5F 6C 6F 8B 
1A534F8 	E4 34 A5  1 68 40 A0  1 
1A53500 	 0 20  0  0 
2000 constant ED_SPEED_MASK
1A53504 	 0  0 65 64 
1A53508 	5F 73 70 65 65 64 5F 6D 
1A53510 	61 73 6B 8D FC 34 A5  1 
1A53518 	68 40 A0  1  0 20  0  0 

0000 constant ED_SKIP_OFF
1A53520 	65 64 5F 73 6B 69 70 5F 
1A53528 	6F 66 66 8B 18 35 A5  1 
1A53530 	68 40 A0  1  0  0  0  0 
4000 constant ED_SKIP_ON
1A53538 	 0 65 64 5F 73 6B 69 70 
1A53540 	5F 6F 6E 8A 30 35 A5  1 
1A53548 	68 40 A0  1  0 40  0  0 
4000 constant ED_SKIP_MASK
1A53550 	 0  0  0 65 64 5F 73 6B 
1A53558 	69 70 5F 6D 61 73 6B 8C 
1A53560 	48 35 A5  1 68 40 A0  1 
1A53568 	 0 40  0  0 

0000 constant ED_FORMAT_G
1A5356C 	65 64 5F 66 
1A53570 	6F 72 6D 61 74 5F 67 8B 
1A53578 	64 35 A5  1 68 40 A0  1 
1A53580 	 0  0  0  0 
8000 constant ED_FORMAT_I
1A53584 	65 64 5F 66 
1A53588 	6F 72 6D 61 74 5F 69 8B 
1A53590 	7C 35 A5  1 68 40 A0  1 
1A53598 	 0 80  0  0 
8000 constant ED_FORMAT_MASK
1A5359C 	 0 65 64 5F 
1A535A0 	66 6F 72 6D 61 74 5F 6D 
1A535A8 	61 73 6B 8E 94 35 A5  1 
1A535B0 	68 40 A0  1  0 80  0  0 

0000 constant ED_TOGGLE_DATA0
1A535B8 	65 64 5F 74 6F 67 67 6C 
1A535C0 	65 5F 64 61 74 61 30 8F 
1A535C8 	B0 35 A5  1 68 40 A0  1 
1A535D0 	 0  0  0  0 
0002 constant ED_TOGGLE_DATA1
1A535D4 	65 64 5F 74 
1A535D8 	6F 67 67 6C 65 5F 64 61 
1A535E0 	74 61 31 8F CC 35 A5  1 
1A535E8 	68 40 A0  1  2  0  0  0 
0002 constant ED_TOGGLE_MASK
1A535F0 	 0 65 64 5F 74 6F 67 67 
1A535F8 	6C 65 5F 6D 61 73 6B 8E 
1A53600 	E8 35 A5  1 68 40 A0  1 
1A53608 	 2  0  0  0 

0001 constant ED_HALTED
1A5360C 	 0  0 65 64 
1A53610 	5F 68 61 6C 74 65 64 89 
1A53618 	 4 36 A5  1 68 40 A0  1 
1A53620 	 1  0  0  0 

: ed-data>di-data  ( n -- n' )  ED_TOGGLE_MASK and  if  1  else  0  then  ;
1A53624 	65 64 2D 64 
1A53628 	61 74 61 3E 64 69 2D 64 
1A53630 	61 74 61 8F 1C 36 A5  1 
1A53638 	20 40 A0  1  4 36 A5  1 
1A53640 	5C 44 A0  1 DC 41 A0  1 
1A53648 	10  0  0  0 80 6F A0  1 
1A53650 	C8 41 A0  1  8  0  0  0 
1A53658 	70 6F A0  1 58 46 A0  1 
: di-data>ed-data  ( n -- n' )  if  ED_TOGGLE_DATA1  else  ED_TOGGLE_DATA0  then  ;
1A53660 	64 69 2D 64 61 74 61 3E 
1A53668 	65 64 2D 64 61 74 61 8F 
1A53670 	38 36 A5  1 20 40 A0  1 
1A53678 	DC 41 A0  1 10  0  0  0 
1A53680 	E8 35 A5  1 C8 41 A0  1 
1A53688 	 8  0  0  0 CC 35 A5  1 
1A53690 	58 46 A0  1 

: (set-skip)  ( ed skip-bit -- )
1A53694 	 0 28 73 65 
1A53698 	74 2D 73 6B 69 70 29 8A 
1A536A0 	74 36 A5  1 20 40 A0  1 
   >r
1A536A8 	BC 45 A0  1 
   dup >hced-control dup le-l@
1A536AC 	40 49 A0  1 
1A536B0 	64 33 A5  1 40 49 A0  1 
1A536B8 	B8 35 A4  1 
   ED_SKIP_MASK invert and r> or
1A536BC 	64 35 A5  1 
1A536C0 	30 45 A0  1 5C 44 A0  1 
1A536C8 	D0 45 A0  1 70 44 A0  1 
   swap le-l!
1A536D0 	68 49 A0  1 50 36 A4  1 
   dup >ed-phys l@ /hced dma-push
1A536D8 	40 49 A0  1 E0 33 A5  1 
1A536E0 	6C 4C A0  1 C8 33 A5  1 
1A536E8 	FC 36 A4  1 
;
1A536EC 	58 46 A0  1 
: ed-set-skip    ( ed -- )  ED_SKIP_ON  (set-skip)  ;
1A536F0 	65 64 2D 73 65 74 2D 73 
1A536F8 	6B 69 70 8B A4 36 A5  1 
1A53700 	20 40 A0  1 48 35 A5  1 
1A53708 	A4 36 A5  1 58 46 A0  1 
: ed-unset-skip  ( ed -- )  ED_SKIP_OFF (set-skip)  ;
1A53710 	 0  0 65 64 2D 75 6E 73 
1A53718 	65 74 2D 73 6B 69 70 8D 
1A53720 	 0 37 A5  1 20 40 A0  1 
1A53728 	30 35 A5  1 A4 36 A5  1 
1A53730 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Transfer Descriptor (TD) as defined by the OHCI Spec:
\ general TDs are 16-byte aligned; isochronous TDs are 32-byte aligned.
\ ---------------------------------------------------------------------------

struct				\ Beginning of General TD fields
4 field >hctd-control		\ TD control info
1A53734 	 0  0 3E 68 
1A53738 	63 74 64 2D 63 6F 6E 74 
1A53740 	72 6F 6C 8D 24 37 A5  1 
1A53748 	50 EE A0  1  0  0  0  0 
4 field >hctd-cbp		\ Physical address of current buffer pointer
1A53750 	 0  0 3E 68 63 74 64 2D 
1A53758 	63 62 70 89 48 37 A5  1 
1A53760 	50 EE A0  1  4  0  0  0 
4 field >hctd-next		\ physical address of next TD
1A53768 	 0 3E 68 63 74 64 2D 6E 
1A53770 	65 78 74 8A 60 37 A5  1 
1A53778 	50 EE A0  1  8  0  0  0 
4 field >hctd-be		\ physical address of buffer end
1A53780 	 0  0  0 3E 68 63 74 64 
1A53788 	2D 62 65 88 78 37 A5  1 
1A53790 	50 EE A0  1  C  0  0  0 
dup constant /gtd
1A53798 	 0  0  0 2F 67 74 64 84 
1A537A0 	90 37 A5  1 68 40 A0  1 
1A537A8 	10  0  0  0 
				\ Isochronous TD fields
2 field >hctd-offset0		\ Offset 0 / PSW 0
1A537AC 	 0  0 3E 68 
1A537B0 	63 74 64 2D 6F 66 66 73 
1A537B8 	65 74 30 8D A4 37 A5  1 
1A537C0 	50 EE A0  1 10  0  0  0 
2 field >hctd-offset1		\ Offset 1 / PSW 1
1A537C8 	 0  0 3E 68 63 74 64 2D 
1A537D0 	6F 66 66 73 65 74 31 8D 
1A537D8 	C0 37 A5  1 50 EE A0  1 
1A537E0 	12  0  0  0 
2 field >hctd-offset2		\ Offset 2 / PSW 2
1A537E4 	 0  0 3E 68 
1A537E8 	63 74 64 2D 6F 66 66 73 
1A537F0 	65 74 32 8D DC 37 A5  1 
1A537F8 	50 EE A0  1 14  0  0  0 
2 field >hctd-offset3		\ Offset 3 / PSW 3
1A53800 	 0  0 3E 68 63 74 64 2D 
1A53808 	6F 66 66 73 65 74 33 8D 
1A53810 	F8 37 A5  1 50 EE A0  1 
1A53818 	16  0  0  0 
2 field >hctd-offset4		\ Offset 4 / PSW 4
1A5381C 	 0  0 3E 68 
1A53820 	63 74 64 2D 6F 66 66 73 
1A53828 	65 74 34 8D 14 38 A5  1 
1A53830 	50 EE A0  1 18  0  0  0 
2 field >hctd-offset5		\ Offset 5 / PSW 5
1A53838 	 0  0 3E 68 63 74 64 2D 
1A53840 	6F 66 66 73 65 74 35 8D 
1A53848 	30 38 A5  1 50 EE A0  1 
1A53850 	1A  0  0  0 
2 field >hctd-offset6		\ Offset 6 / PSW 6
1A53854 	 0  0 3E 68 
1A53858 	63 74 64 2D 6F 66 66 73 
1A53860 	65 74 36 8D 4C 38 A5  1 
1A53868 	50 EE A0  1 1C  0  0  0 
2 field >hctd-offset7		\ Offset 7 / PSW 7
1A53870 	 0  0 3E 68 63 74 64 2D 
1A53878 	6F 66 66 73 65 74 37 8D 
1A53880 	68 38 A5  1 50 EE A0  1 
1A53888 	1E  0  0  0 
dup constant /itd
1A5388C 	 0  0  0 2F 
1A53890 	69 74 64 84 84 38 A5  1 
1A53898 	68 40 A0  1 20  0  0  0 
				\ Driver specific fields
4 field >td-phys		\ Physical address of HC TD
1A538A0 	 0  0  0 3E 74 64 2D 70 
1A538A8 	68 79 73 88 98 38 A5  1 
1A538B0 	50 EE A0  1 20  0  0  0 
4 field >td-next		\ Virtual address of next TD
1A538B8 	 0  0  0 3E 74 64 2D 6E 
1A538C0 	65 78 74 88 B0 38 A5  1 
1A538C8 	50 EE A0  1 24  0  0  0 
4 field >td-cbp			\ Virtual address of current buffer pointer
1A538D0 	3E 74 64 2D 63 62 70 87 
1A538D8 	C8 38 A5  1 50 EE A0  1 
1A538E0 	28  0  0  0 
4 field >td-pcbp		\ Physical address of current buffer pointer
1A538E4 	 0  0  0 3E 
1A538E8 	74 64 2D 70 63 62 70 88 
1A538F0 	DC 38 A5  1 50 EE A0  1 
1A538F8 	2C  0  0  0 
4 field >td-/cbp-all		\ Buffer length (size of the entire buffer)
1A538FC 	 0  0  0 3E 
1A53900 	74 64 2D 2F 63 62 70 2D 
1A53908 	61 6C 6C 8C F4 38 A5  1 
1A53910 	50 EE A0  1 30  0  0  0 
				\ For bulk and intr TDs
d# 32 round-up			\ Multiple of 32 bytes
constant /td
1A53918 	2F 74 64 83 10 39 A5  1 
1A53920 	68 40 A0  1 40  0  0  0 

\ >hctd-control constants
00040000 constant TD_ROUND_ON
1A53928 	74 64 5F 72 6F 75 6E 64 
1A53930 	5F 6F 6E 8B 20 39 A5  1 
1A53938 	68 40 A0  1  0  0  4  0 
00000000 constant TD_ROUND_ERR
1A53940 	 0  0  0 74 64 5F 72 6F 
1A53948 	75 6E 64 5F 65 72 72 8C 
1A53950 	38 39 A5  1 68 40 A0  1 
1A53958 	 0  0  0  0 
00040000 constant TD_ROUND_MASK
1A5395C 	 0  0 74 64 
1A53960 	5F 72 6F 75 6E 64 5F 6D 
1A53968 	61 73 6B 8D 54 39 A5  1 
1A53970 	68 40 A0  1  0  0  4  0 

00000000 constant TD_DIR_SETUP
1A53978 	 0  0  0 74 64 5F 64 69 
1A53980 	72 5F 73 65 74 75 70 8C 
1A53988 	70 39 A5  1 68 40 A0  1 
1A53990 	 0  0  0  0 
00080000 constant TD_DIR_OUT
1A53994 	 0 74 64 5F 
1A53998 	64 69 72 5F 6F 75 74 8A 
1A539A0 	8C 39 A5  1 68 40 A0  1 
1A539A8 	 0  0  8  0 
00100000 constant TD_DIR_IN
1A539AC 	 0  0 74 64 
1A539B0 	5F 64 69 72 5F 69 6E 89 
1A539B8 	A4 39 A5  1 68 40 A0  1 
1A539C0 	 0  0 10  0 
00180000 constant TD_DIR_MASK
1A539C4 	74 64 5F 64 
1A539C8 	69 72 5F 6D 61 73 6B 8B 
1A539D0 	BC 39 A5  1 68 40 A0  1 
1A539D8 	 0  0 18  0 

00c00000 constant TD_INTR_MIN
1A539DC 	74 64 5F 69 
1A539E0 	6E 74 72 5F 6D 69 6E 8B 
1A539E8 	D4 39 A5  1 68 40 A0  1 
1A539F0 	 0  0 C0  0 
00e00000 constant TD_INTR_OFF
1A539F4 	74 64 5F 69 
1A539F8 	6E 74 72 5F 6F 66 66 8B 
1A53A00 	EC 39 A5  1 68 40 A0  1 
1A53A08 	 0  0 E0  0 
00e00000 constant TD_INTR_MASK
1A53A0C 	 0  0  0 74 
1A53A10 	64 5F 69 6E 74 72 5F 6D 
1A53A18 	61 73 6B 8C  4 3A A5  1 
1A53A20 	68 40 A0  1  0  0 E0  0 

00000000 constant TD_TOGGLE_USE_ED
1A53A28 	 0  0  0 74 64 5F 74 6F 
1A53A30 	67 67 6C 65 5F 75 73 65 
1A53A38 	5F 65 64 90 20 3A A5  1 
1A53A40 	68 40 A0  1  0  0  0  0 
02000000 constant TD_TOGGLE_USE_LSB0
1A53A48 	 0 74 64 5F 74 6F 67 67 
1A53A50 	6C 65 5F 75 73 65 5F 6C 
1A53A58 	73 62 30 92 40 3A A5  1 
1A53A60 	68 40 A0  1  0  0  0  2 
03000000 constant TD_TOGGLE_USE_LSB1
1A53A68 	 0 74 64 5F 74 6F 67 67 
1A53A70 	6C 65 5F 75 73 65 5F 6C 
1A53A78 	73 62 31 92 60 3A A5  1 
1A53A80 	68 40 A0  1  0  0  0  3 
01000000 constant TD_TOGGLE_MASK
1A53A88 	 0 74 64 5F 74 6F 67 67 
1A53A90 	6C 65 5F 6D 61 73 6B 8E 
1A53A98 	80 3A A5  1 68 40 A0  1 
1A53AA0 	 0  0  0  1 
0c000000 constant TD_ERR_CNT_MASK
1A53AA4 	74 64 5F 65 
1A53AA8 	72 72 5F 63 6E 74 5F 6D 
1A53AB0 	61 73 6B 8F 9C 3A A5  1 
1A53AB8 	68 40 A0  1  0  0  0  C 

00000000 constant TD_CC_NOERROR
1A53AC0 	 0  0 74 64 5F 63 63 5F 
1A53AC8 	6E 6F 65 72 72 6F 72 8D 
1A53AD0 	B8 3A A5  1 68 40 A0  1 
1A53AD8 	 0  0  0  0 
10000000 constant TD_CC_CRC
1A53ADC 	 0  0 74 64 
1A53AE0 	5F 63 63 5F 63 72 63 89 
1A53AE8 	D4 3A A5  1 68 40 A0  1 
1A53AF0 	 0  0  0 10 
20000000 constant TD_CC_BITSTUFFING
1A53AF4 	 0  0 74 64 
1A53AF8 	5F 63 63 5F 62 69 74 73 
1A53B00 	74 75 66 66 69 6E 67 91 
1A53B08 	EC 3A A5  1 68 40 A0  1 
1A53B10 	 0  0  0 20 
30000000 constant TD_CC_DATATOGGLEMISMATCH
1A53B14 	 0  0  0 74 
1A53B18 	64 5F 63 63 5F 64 61 74 
1A53B20 	61 74 6F 67 67 6C 65 6D 
1A53B28 	69 73 6D 61 74 63 68 98 
1A53B30 	 C 3B A5  1 68 40 A0  1 
1A53B38 	 0  0  0 30 
40000000 constant TD_CC_STALL
1A53B3C 	74 64 5F 63 
1A53B40 	63 5F 73 74 61 6C 6C 8B 
1A53B48 	34 3B A5  1 68 40 A0  1 
1A53B50 	 0  0  0 40 
50000000 constant TD_CC_DEVICENOTRESPONDING
1A53B54 	 0  0 74 64 
1A53B58 	5F 63 63 5F 64 65 76 69 
1A53B60 	63 65 6E 6F 74 72 65 73 
1A53B68 	70 6F 6E 64 69 6E 67 99 
1A53B70 	4C 3B A5  1 68 40 A0  1 
1A53B78 	 0  0  0 50 
60000000 constant TD_CC_PIDCHECKFAILURE
1A53B7C 	 0  0 74 64 
1A53B80 	5F 63 63 5F 70 69 64 63 
1A53B88 	68 65 63 6B 66 61 69 6C 
1A53B90 	75 72 65 95 74 3B A5  1 
1A53B98 	68 40 A0  1  0  0  0 60 
70000000 constant TD_CC_UNEXPECTEDPID
1A53BA0 	74 64 5F 63 63 5F 75 6E 
1A53BA8 	65 78 70 65 63 74 65 64 
1A53BB0 	70 69 64 93 98 3B A5  1 
1A53BB8 	68 40 A0  1  0  0  0 70 
80000000 constant TD_CC_DATAOVERRUN
1A53BC0 	 0  0 74 64 5F 63 63 5F 
1A53BC8 	64 61 74 61 6F 76 65 72 
1A53BD0 	72 75 6E 91 B8 3B A5  1 
1A53BD8 	68 40 A0  1  0  0  0 80 
90000000 constant TD_CC_DATAUNDERRUN
1A53BE0 	 0 74 64 5F 63 63 5F 64 
1A53BE8 	61 74 61 75 6E 64 65 72 
1A53BF0 	72 75 6E 92 D8 3B A5  1 
1A53BF8 	68 40 A0  1  0  0  0 90 
c0000000 constant TD_CC_BUFFEROVERRUN
1A53C00 	74 64 5F 63 63 5F 62 75 
1A53C08 	66 66 65 72 6F 76 65 72 
1A53C10 	72 75 6E 93 F8 3B A5  1 
1A53C18 	68 40 A0  1  0  0  0 C0 
d0000000 constant TD_CC_BUFFERUNDERRUN
1A53C20 	 0  0  0 74 64 5F 63 63 
1A53C28 	5F 62 75 66 66 65 72 75 
1A53C30 	6E 64 65 72 72 75 6E 94 
1A53C38 	18 3C A5  1 68 40 A0  1 
1A53C40 	 0  0  0 D0 
f0000000 constant TD_CC_NOTACCESSED
1A53C44 	 0  0 74 64 
1A53C48 	5F 63 63 5F 6E 6F 74 61 
1A53C50 	63 63 65 73 73 65 64 91 
1A53C58 	3C 3C A5  1 68 40 A0  1 
1A53C60 	 0  0  0 F0 
f0000000 constant TD_CC_MASK
1A53C64 	 0 74 64 5F 
1A53C68 	63 63 5F 6D 61 73 6B 8A 
1A53C70 	5C 3C A5  1 68 40 A0  1 
1A53C78 	 0  0  0 F0 

: td-data>di-data  ( n -- n' )  TD_TOGGLE_MASK and  if  1  else  0  then  ;
1A53C7C 	74 64 2D 64 
1A53C80 	61 74 61 3E 64 69 2D 64 
1A53C88 	61 74 61 8F 74 3C A5  1 
1A53C90 	20 40 A0  1 9C 3A A5  1 
1A53C98 	5C 44 A0  1 DC 41 A0  1 
1A53CA0 	10  0  0  0 80 6F A0  1 
1A53CA8 	C8 41 A0  1  8  0  0  0 
1A53CB0 	70 6F A0  1 58 46 A0  1 
: di-data>td-data  ( n -- n' )  if  TD_TOGGLE_USE_LSB1  else  TD_TOGGLE_USE_LSB0  then  ;
1A53CB8 	64 69 2D 64 61 74 61 3E 
1A53CC0 	74 64 2D 64 61 74 61 8F 
1A53CC8 	90 3C A5  1 20 40 A0  1 
1A53CD0 	DC 41 A0  1 10  0  0  0 
1A53CD8 	80 3A A5  1 C8 41 A0  1 
1A53CE0 	 8  0  0  0 60 3A A5  1 
1A53CE8 	58 46 A0  1 

\ ---------------------------------------------------------------------------

: init-struct  ( -- )
1A53CEC 	69 6E 69 74 
1A53CF0 	2D 73 74 72 75 63 74 8B 
1A53CF8 	CC 3C A5  1 20 40 A0  1 
   init-struct
1A53D00 	3C 46 A4  1 
   0 to ed-control 0 to ed-bulk
1A53D04 	70 6F A0  1 
1A53D08 	B8 40 A0  1 34 33 A5  1 
1A53D10 	70 6F A0  1 B8 40 A0  1 
1A53D18 	48 33 A5  1 
   init-hcca
1A53D1C 	C8 30 A5  1 
   init-intr
1A53D20 	BC 31 A5  1 
;
1A53D24 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ ED and TDs for bulk, control and interrupt operations.
\ ED and its list of TDs are allocated as needed.
\ ---------------------------------------------------------------------------

: init-ed  ( ed.u,v,p len -- )
1A53D28 	69 6E 69 74 2D 65 64 87 
1A53D30 	FC 3C A5  1 20 40 A0  1 
   2 pick >ed-size l!			( ed.u,v,p )
1A53D38 	90 6F A0  1  C 4A A0  1 
1A53D40 	44 34 A5  1 7C 4D A0  1 
   over >ed-phys l!			( ed,u,v )
1A53D48 	54 49 A0  1 E0 33 A5  1 
1A53D50 	7C 4D A0  1 
   >ed-unaligned l!			( )
1A53D54 	2C 34 A5  1 
1A53D58 	7C 4D A0  1 
;
1A53D5C 	58 46 A0  1 

: link-tds  ( td.v td.p #tds -- )
1A53D60 	 0  0  0 6C 69 6E 6B 2D 
1A53D68 	74 64 73 88 34 3D A5  1 
1A53D70 	20 40 A0  1 
   1- 0  ?do				( td.v td.p )
1A53D74 	54 4B A0  1 
1A53D78 	70 6F A0  1 50 42 A0  1 
1A53D80 	54  0  0  0 
      2dup swap >td-phys l!		( td.v td.p )
1A53D84 	C0 49 A0  1 
1A53D88 	68 49 A0  1 B0 38 A5  1 
1A53D90 	7C 4D A0  1 
      /td + tuck over >hctd-next le-l!	( td.p' td.v )
1A53D94 	20 39 A5  1 
1A53D98 	 4 45 A0  1 E8 46 A0  1 
1A53DA0 	54 49 A0  1 78 37 A5  1 
1A53DA8 	50 36 A4  1 
      dup /td + tuck swap		( td.p td.v' td.v' td.v )
1A53DAC 	40 49 A0  1 
1A53DB0 	20 39 A5  1  4 45 A0  1 
1A53DB8 	E8 46 A0  1 68 49 A0  1 
      >td-next l!			( td.p td.v )
1A53DC0 	C8 38 A5  1 7C 4D A0  1 
      swap				( td.v td.p )
1A53DC8 	68 49 A0  1 
   loop
1A53DCC 	F8 41 A0  1 
1A53DD0 	B4 FF FF FF 
   swap >td-phys l!			( )
1A53DD4 	68 49 A0  1 
1A53DD8 	B0 38 A5  1 7C 4D A0  1 
;
1A53DE0 	58 46 A0  1 
: link-edtd  ( td.p #tds ed -- )
1A53DE4 	 0  0 6C 69 
1A53DE8 	6E 6B 2D 65 64 74 64 89 
1A53DF0 	70 3D A5  1 20 40 A0  1 
   >r					( td.p #tds )  ( R: ed )
1A53DF8 	BC 45 A0  1 
   1- /td * over +			( td.p ptail )  ( R: ed )
1A53DFC 	54 4B A0  1 
1A53E00 	20 39 A5  1 1C 5F A0  1 
1A53E08 	54 49 A0  1  4 45 A0  1 
   r@ >hced-tdtail le-l!		( td.p )  ( R: ed )
1A53E10 	E4 45 A0  1 80 33 A5  1 
1A53E18 	50 36 A4  1 
   r> >hced-tdhead le-l!		( )
1A53E1C 	D0 45 A0  1 
1A53E20 	9C 33 A5  1 50 36 A4  1 
;
1A53E28 	58 46 A0  1 
: link-edtds  ( td.v td.p #tds ed -- )
1A53E2C 	 0 6C 69 6E 
1A53E30 	6B 2D 65 64 74 64 73 8A 
1A53E38 	F4 3D A5  1 20 40 A0  1 
   >r 2dup r> link-edtd			( td.v td.p #tds )	\ Link ED to TD
1A53E40 	BC 45 A0  1 C0 49 A0  1 
1A53E48 	D0 45 A0  1 F4 3D A5  1 
   link-tds				( )			\ Link TDs
1A53E50 	70 3D A5  1 
;
1A53E54 	58 46 A0  1 
: alloc-edtds  ( #tds -- ed td )
1A53E58 	61 6C 6C 6F 63 2D 65 64 
1A53E60 	74 64 73 8B 3C 3E A5  1 
1A53E68 	20 40 A0  1 
   dup >r /td * /ed + dup >r		( len )  ( R: #tds len )
1A53E6C 	40 49 A0  1 
1A53E70 	BC 45 A0  1 20 39 A5  1 
1A53E78 	1C 5F A0  1 54 34 A5  1 
1A53E80 	 4 45 A0  1 40 49 A0  1 
1A53E88 	BC 45 A0  1 
   aligned32-alloc-map-in		( ed.u,v,p )  ( R: #tds len )
1A53E8C 	78 39 A4  1 
   over r@ erase			( ed.u,v,p )  ( R: #tds len )
1A53E90 	54 49 A0  1 E4 45 A0  1 
1A53E98 	F0 72 A0  1 
   3dup r> init-ed			( ed.u,v,p )  ( R: #tds )
1A53E9C 	6C 3F A4  1 
1A53EA0 	D0 45 A0  1 34 3D A5  1 
   rot drop				( ed.v,p )  ( R: #tds )
1A53EA8 	7C 49 A0  1 30 49 A0  1 
   over /ed + dup -rot			( ed td ed.p td.v )  ( R: #tds )
1A53EB0 	54 49 A0  1 54 34 A5  1 
1A53EB8 	 4 45 A0  1 40 49 A0  1 
1A53EC0 	94 49 A0  1 
   swap /ed + 				( ed td td.v td.p )  ( R: #tds )
1A53EC4 	68 49 A0  1 
1A53EC8 	54 34 A5  1  4 45 A0  1 
   r> 4 pick link-edtds			( ed td )
1A53ED0 	D0 45 A0  1 B0 6F A0  1 
1A53ED8 	 C 4A A0  1 3C 3E A5  1 
;
1A53EE0 	58 46 A0  1 
: free-edtds  ( ed -- )
1A53EE4 	 0 66 72 65 
1A53EE8 	65 2D 65 64 74 64 73 8A 
1A53EF0 	68 3E A5  1 20 40 A0  1 
   >r					( R: ed )
1A53EF8 	BC 45 A0  1 
   r@ >ed-unaligned l@			( ed.u )  ( R: ed )
1A53EFC 	E4 45 A0  1 
1A53F00 	2C 34 A5  1 6C 4C A0  1 
   r@ dup >ed-phys l@			( ed.u,v,p )  ( R: ed )
1A53F08 	E4 45 A0  1 40 49 A0  1 
1A53F10 	E0 33 A5  1 6C 4C A0  1 
   r> >ed-size l@			( ed.u,v,p size )
1A53F18 	D0 45 A0  1 44 34 A5  1 
1A53F20 	6C 4C A0  1 
   aligned32-free-map-out		( )
1A53F24 	B8 39 A4  1 
;
1A53F28 	58 46 A0  1 
: push-edtds  ( ed -- )
1A53F2C 	 0 70 75 73 
1A53F30 	68 2D 65 64 74 64 73 8A 
1A53F38 	F4 3E A5  1 20 40 A0  1 
   dup >ed-phys l@			( ed.v,p )
1A53F40 	40 49 A0  1 E0 33 A5  1 
1A53F48 	6C 4C A0  1 
   over >ed-size l@			( ed.v,p len )
1A53F4C 	54 49 A0  1 
1A53F50 	44 34 A5  1 6C 4C A0  1 
   dma-push				( )
1A53F58 	FC 36 A4  1 
;
1A53F5C 	58 46 A0  1 
: pull-edtds  ( ed -- )
1A53F60 	 0 70 75 6C 6C 2D 65 64 
1A53F68 	74 64 73 8A 3C 3F A5  1 
1A53F70 	20 40 A0  1 
   dup >ed-phys l@			( ed.v,p )
1A53F74 	40 49 A0  1 
1A53F78 	E0 33 A5  1 6C 4C A0  1 
   over >ed-size l@			( ed.v,p len )
1A53F80 	54 49 A0  1 44 34 A5  1 
1A53F88 	6C 4C A0  1 
   dma-pull				( )
1A53F8C 	28 37 A4  1 
;
1A53F90 	58 46 A0  1 
: map-out-cbp  ( td -- )
1A53F94 	6D 61 70 2D 
1A53F98 	6F 75 74 2D 63 62 70 8B 
1A53FA0 	70 3F A5  1 20 40 A0  1 
   dup >td-cbp l@ over >td-pcbp l@ rot >td-/cbp-all l@ hcd-map-out
1A53FA8 	40 49 A0  1 DC 38 A5  1 
1A53FB0 	6C 4C A0  1 54 49 A0  1 
1A53FB8 	F4 38 A5  1 6C 4C A0  1 
1A53FC0 	7C 49 A0  1 10 39 A5  1 
1A53FC8 	6C 4C A0  1 8C 3E A4  1 
;
1A53FD0 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Control scheduling
\ ---------------------------------------------------------------------------

: fixup-ed-next-prev  ( ed -- ed )
1A53FD4 	 0 66 69 78 
1A53FD8 	75 70 2D 65 64 2D 6E 65 
1A53FE0 	78 74 2D 70 72 65 76 92 
1A53FE8 	A4 3F A5  1 20 40 A0  1 
   dup >ed-prev l@ ?dup  if  over >ed-next l@ swap >ed-next l!  then
1A53FF0 	40 49 A0  1 10 34 A5  1 
1A53FF8 	6C 4C A0  1 B4 70 A0  1 
1A54000 	DC 41 A0  1 1C  0  0  0 
1A54008 	54 49 A0  1 F8 33 A5  1 
1A54010 	6C 4C A0  1 68 49 A0  1 
1A54018 	F8 33 A5  1 7C 4D A0  1 
   dup >ed-next l@ ?dup  if  over >ed-prev l@ swap >ed-prev l!  then
1A54020 	40 49 A0  1 F8 33 A5  1 
1A54028 	6C 4C A0  1 B4 70 A0  1 
1A54030 	DC 41 A0  1 1C  0  0  0 
1A54038 	54 49 A0  1 10 34 A5  1 
1A54040 	6C 4C A0  1 68 49 A0  1 
1A54048 	10 34 A5  1 7C 4D A0  1 
;
1A54050 	58 46 A0  1 

: insert-ed  ( new-ed old-ed -- )
1A54054 	 0  0 69 6E 
1A54058 	73 65 72 74 2D 65 64 89 
1A54060 	EC 3F A5  1 20 40 A0  1 
   ?dup 0=  if  drop exit  then		\ No old-ed, done
1A54068 	B4 70 A0  1 24 47 A0  1 
1A54070 	DC 41 A0  1  C  0  0  0 
1A54078 	30 49 A0  1 40 46 A0  1 
   2dup >ed-prev l!			\ old-ed's prev is new-ed
1A54080 	C0 49 A0  1 10 34 A5  1 
1A54088 	7C 4D A0  1 
   2dup swap >ed-next l!		\ new-ed's next is old-ed
1A5408C 	C0 49 A0  1 
1A54090 	68 49 A0  1 F8 33 A5  1 
1A54098 	7C 4D A0  1 
   >ed-phys l@ swap >hced-next le-l!	\ new-ed's hced-next is old-ed's phys
1A5409C 	E0 33 A5  1 
1A540A0 	6C 4C A0  1 68 49 A0  1 
1A540A8 	B4 33 A5  1 50 36 A4  1 
;
1A540B0 	58 46 A0  1 

: insert-control-ed  ( ed -- )
1A540B4 	 0  0 69 6E 
1A540B8 	73 65 72 74 2D 63 6F 6E 
1A540C0 	74 72 6F 6C 2D 65 64 91 
1A540C8 	64 40 A5  1 20 40 A0  1 
   dup ed-control insert-ed
1A540D0 	40 49 A0  1 34 33 A5  1 
1A540D8 	64 40 A5  1 
   to ed-control
1A540DC 	B8 40 A0  1 
1A540E0 	34 33 A5  1 
;
1A540E4 	58 46 A0  1 
: remove-control-ed  ( ed -- )
1A540E8 	 0  0 72 65 6D 6F 76 65 
1A540F0 	2D 63 6F 6E 74 72 6F 6C 
1A540F8 	2D 65 64 91 CC 40 A5  1 
1A54100 	20 40 A0  1 
   fixup-ed-next-prev			( ed )
1A54104 	EC 3F A5  1 
   dup ed-control =  if  >ed-next l@ to ed-control  else  drop  then
1A54108 	40 49 A0  1 34 33 A5  1 
1A54110 	24 48 A0  1 DC 41 A0  1 
1A54118 	1C  0  0  0 F8 33 A5  1 
1A54120 	6C 4C A0  1 B8 40 A0  1 
1A54128 	34 33 A5  1 C8 41 A0  1 
1A54130 	 8  0  0  0 30 49 A0  1 
;
1A54138 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Bulk scheduling
\ ---------------------------------------------------------------------------

: insert-bulk-ed  ( ed -- )
1A5413C 	 0 69 6E 73 
1A54140 	65 72 74 2D 62 75 6C 6B 
1A54148 	2D 65 64 8E  0 41 A5  1 
1A54150 	20 40 A0  1 
   dup ed-bulk insert-ed
1A54154 	40 49 A0  1 
1A54158 	48 33 A5  1 64 40 A5  1 
   to ed-bulk
1A54160 	B8 40 A0  1 48 33 A5  1 
;
1A54168 	58 46 A0  1 
: remove-bulk-ed  ( ed -- )
1A5416C 	 0 72 65 6D 
1A54170 	6F 76 65 2D 62 75 6C 6B 
1A54178 	2D 65 64 8E 50 41 A5  1 
1A54180 	20 40 A0  1 
   fixup-ed-next-prev			( ed )
1A54184 	EC 3F A5  1 
   dup ed-bulk =  if  >ed-next l@ to ed-bulk  else  drop  then
1A54188 	40 49 A0  1 48 33 A5  1 
1A54190 	24 48 A0  1 DC 41 A0  1 
1A54198 	1C  0  0  0 F8 33 A5  1 
1A541A0 	6C 4C A0  1 B8 40 A0  1 
1A541A8 	48 33 A5  1 C8 41 A0  1 
1A541B0 	 8  0  0  0 30 49 A0  1 
;
1A541B8 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Interrupt scheduling
\ Schedule interrupt at the rate min(interval,2**x).
\
\ XXX Need to determines which scheduling queue for that rate has the smallest
\ committed bandwidth.
\
\ XXX To really implement the various poll intervals, the simplistic way is
\ XXX to have 32 dummy EDs for 1ms interval; 16 dummy EDs for 2ms interval;
\ XXX 8 dummy EDs for 4ms interval; 4 dummy EDs for 8ms interval; 
\ XXX 2 dummy EDs for 16ms interval; and, 1 dummy ED for 32ms interval.
\ XXX Then you link to the end of the lists of EDs for each interval.  Ughhh!
\
\ XXX For now, just implement fixed poll interval.
\
\ XXX On further thought, since we're polling the intr pipeline from the
\ XXX device driver, the driver driver can poll the intr at the interval
\ XXX specified.  And thus, the need to fully implement poll intervals at
\ XXX the HCD level is redundant.
\ ---------------------------------------------------------------------------

8 constant intr-interval
1A541BC 	 0  0 69 6E 
1A541C0 	74 72 2D 69 6E 74 65 72 
1A541C8 	76 61 6C 8D 80 41 A5  1 
1A541D0 	68 40 A0  1  8  0  0  0 

: (insert-intr-ed)  ( ed idx -- )
1A541D8 	 0  0  0 28 69 6E 73 65 
1A541E0 	72 74 2D 69 6E 74 72 2D 
1A541E8 	65 64 29 90 D0 41 A5  1 
1A541F0 	20 40 A0  1 
   dup >r				( ed idx )  ( R: idx )
1A541F4 	40 49 A0  1 
1A541F8 	BC 45 A0  1 
   intr-tail@ ?dup 0=  if		( ed )  ( R: idx )
1A541FC 	5C 32 A5  1 
1A54200 	B4 70 A0  1 24 47 A0  1 
1A54208 	DC 41 A0  1 2C  0  0  0 
      dup r@ intr-head!			( ed )  ( R: idx )
1A54210 	40 49 A0  1 E4 45 A0  1 
1A54218 	38 32 A5  1 
      dup >ed-phys l@ r@ hcca!		( ed )  ( R: idx )
1A5421C 	40 49 A0  1 
1A54220 	E0 33 A5  1 6C 4C A0  1 
1A54228 	E4 45 A0  1 9C 30 A5  1 
   else					( ed ted )  ( R: idx )
1A54230 	C8 41 A0  1 34  0  0  0 
      2dup >ed-next l!			( ed ted )  ( R: idx )
1A54238 	C0 49 A0  1 F8 33 A5  1 
1A54240 	7C 4D A0  1 
      over >ed-phys l@ over >hced-next le-l!	( ed ted )  ( R: idx )
1A54244 	54 49 A0  1 
1A54248 	E0 33 A5  1 6C 4C A0  1 
1A54250 	54 49 A0  1 B4 33 A5  1 
1A54258 	50 36 A4  1 
      over >ed-prev l!			( ed )  ( R: idx )
1A5425C 	54 49 A0  1 
1A54260 	10 34 A5  1 7C 4D A0  1 
   then
   r@ iso-head@ over >ed-next l!	( ed )  ( R: idx )
1A54268 	E4 45 A0  1 A4 32 A5  1 
1A54270 	54 49 A0  1 F8 33 A5  1 
1A54278 	7C 4D A0  1 
   r> intr-tail!			( )
1A5427C 	D0 45 A0  1 
1A54280 	80 32 A5  1 
;
1A54284 	58 46 A0  1 
: insert-intr-ed  ( ed interval -- )
1A54288 	 0 69 6E 73 65 72 74 2D 
1A54290 	69 6E 74 72 2D 65 64 8E 
1A54298 	F0 41 A5  1 20 40 A0  1 
   drop
1A542A0 	30 49 A0  1 
   #intr 0  do  dup i (insert-intr-ed)  intr-interval +loop  drop
1A542A4 	F8 2F A5  1 
1A542A8 	70 6F A0  1 88 42 A0  1 
1A542B0 	1C  0  0  0 40 49 A0  1 
1A542B8 	B4 42 A0  1 F0 41 A5  1 
1A542C0 	D0 41 A5  1 1C 42 A0  1 
1A542C8 	EC FF FF FF 30 49 A0  1 
;
1A542D0 	58 46 A0  1 

: (remove-intr-ed)  ( ed idx -- )
1A542D4 	 0  0  0 28 
1A542D8 	72 65 6D 6F 76 65 2D 69 
1A542E0 	6E 74 72 2D 65 64 29 90 
1A542E8 	9C 42 A5  1 20 40 A0  1 
   >r					( ed )  ( R: idx )
1A542F0 	BC 45 A0  1 
   fixup-ed-next-prev			( ed )  ( R: idx )
1A542F4 	EC 3F A5  1 
   r@ intr-head@ over =  if		( ed )  ( R: idx )
1A542F8 	E4 45 A0  1 14 32 A5  1 
1A54300 	54 49 A0  1 24 48 A0  1 
1A54308 	DC 41 A0  1 38  0  0  0 
      dup >ed-next l@ dup r@ intr-head!	( ed ped )  ( R: idx )
1A54310 	40 49 A0  1 F8 33 A5  1 
1A54318 	6C 4C A0  1 40 49 A0  1 
1A54320 	E4 45 A0  1 38 32 A5  1 
      dup  if  >ed-phys l@  then  r@ hcca!
1A54328 	40 49 A0  1 DC 41 A0  1 
1A54330 	 C  0  0  0 E0 33 A5  1 
1A54338 	6C 4C A0  1 E4 45 A0  1 
1A54340 	9C 30 A5  1 
      					( ed )  ( R: idx )
   then
   r@ intr-tail@ over =  if		( ed )  ( R: idx )
1A54344 	E4 45 A0  1 
1A54348 	5C 32 A5  1 54 49 A0  1 
1A54350 	24 48 A0  1 DC 41 A0  1 
1A54358 	18  0  0  0 
      dup >ed-prev l@ r@ intr-tail!	( ed )  ( R: idx )
1A5435C 	40 49 A0  1 
1A54360 	10 34 A5  1 6C 4C A0  1 
1A54368 	E4 45 A0  1 80 32 A5  1 
   then
   r> 2drop
1A54370 	D0 45 A0  1 AC 49 A0  1 
;
1A54378 	58 46 A0  1 
: remove-intr-ed  ( ed -- )
1A5437C 	 0 72 65 6D 
1A54380 	6F 76 65 2D 69 6E 74 72 
1A54388 	2D 65 64 8E EC 42 A5  1 
1A54390 	20 40 A0  1 
   #intr 0  do  dup i (remove-intr-ed)  intr-interval +loop  drop
1A54394 	F8 2F A5  1 
1A54398 	70 6F A0  1 88 42 A0  1 
1A543A0 	1C  0  0  0 40 49 A0  1 
1A543A8 	B4 42 A0  1 EC 42 A5  1 
1A543B0 	D0 41 A5  1 1C 42 A0  1 
1A543B8 	EC FF FF FF 30 49 A0  1 
;
1A543C0 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Wait for an ED to be done and process any errors.
\
\ When done? returns no error found yet, the caller should should if errors
\ were found in the TDs.
\ ---------------------------------------------------------------------------

defer process-hc-status
1A543C4 	 0  0 70 72 
1A543C8 	6F 63 65 73 73 2D 68 63 
1A543D0 	2D 73 74 61 74 75 73 91 
1A543D8 	90 43 A5  1 5C 40 A0  1 
1A543E0 	AC  E  0  0 

0 value timeout
1A543E4 	74 69 6D 65 
1A543E8 	6F 75 74 87 DC 43 A5  1 
1A543F0 	50 40 A0  1 B0  E  0  0 

: .td-error  ( cc -- )
1A543F8 	 0  0 2E 74 64 2D 65 72 
1A54400 	72 6F 72 89 F0 43 A5  1 
1A54408 	20 40 A0  1 
   case
      TD_CC_CRC			of  " CRC"			USB_ERR_CRC  endof
1A5440C 	EC 3A A5  1 
1A54410 	48 43 A0  1 1C  0  0  0 
1A54418 	9C 53 A0  1  3 43 52 43 
1A54420 	 0  0  0  0 34 2C A4  1 
1A54428 	6C 43 A0  1 1C  2  0  0 
      TD_CC_BITSTUFFING		of  " Bit Stuffing"		USB_ERR_BITSTUFFING  endof
1A54430 	 C 3B A5  1 48 43 A0  1 
1A54438 	24  0  0  0 9C 53 A0  1 
1A54440 	 C 42 69 74 20 53 74 75 
1A54448 	66 66 69 6E 67  0  0  0 
1A54450 	54 2C A4  1 6C 43 A0  1 
1A54458 	F0  1  0  0 
      TD_CC_DATATOGGLEMISMATCH	of  " Data Toggle Mismatch"	USB_ERR_DATATOGGLEMISMATCH  endof
1A5445C 	34 3B A5  1 
1A54460 	48 43 A0  1 2C  0  0  0 
1A54468 	9C 53 A0  1 14 44 61 74 
1A54470 	61 20 54 6F 67 67 6C 65 
1A54478 	20 4D 69 73 6D 61 74 63 
1A54480 	68  0  0  0 7C 2C A4  1 
1A54488 	6C 43 A0  1 BC  1  0  0 
      TD_CC_STALL		of  " Stall"			USB_ERR_STALL  endof
1A54490 	4C 3B A5  1 48 43 A0  1 
1A54498 	1C  0  0  0 9C 53 A0  1 
1A544A0 	 5 53 74 61 6C 6C  0  0 
1A544A8 	98 2C A4  1 6C 43 A0  1 
1A544B0 	98  1  0  0 
      TD_CC_DEVICENOTRESPONDING	of  " Device Not Responding"	USB_ERR_DEVICENOTRESPONDING  endof
1A544B4 	74 3B A5  1 
1A544B8 	48 43 A0  1 2C  0  0  0 
1A544C0 	9C 53 A0  1 15 44 65 76 
1A544C8 	69 63 65 20 4E 6F 74 20 
1A544D0 	52 65 73 70 6F 6E 64 69 
1A544D8 	6E 67  0  0 C0 2C A4  1 
1A544E0 	6C 43 A0  1 64  1  0  0 
      TD_CC_PIDCHECKFAILURE	of  " PID Check Failure"	USB_ERR_PIDCHECKFAILURE  endof
1A544E8 	98 3B A5  1 48 43 A0  1 
1A544F0 	28  0  0  0 9C 53 A0  1 
1A544F8 	11 50 49 44 20 43 68 65 
1A54500 	63 6B 20 46 61 69 6C 75 
1A54508 	72 65  0  0 E4 2C A4  1 
1A54510 	6C 43 A0  1 34  1  0  0 
      TD_CC_UNEXPECTEDPID	of  " Unexpected PID"		USB_ERR_UNEXPECTEDPIC  endof
1A54518 	B8 3B A5  1 48 43 A0  1 
1A54520 	24  0  0  0 9C 53 A0  1 
1A54528 	 E 55 6E 65 78 70 65 63 
1A54530 	74 65 64 20 50 49 44  0 
1A54538 	 8 2D A4  1 6C 43 A0  1 
1A54540 	 8  1  0  0 
      TD_CC_DATAOVERRUN		of  " Data Overrun"		USB_ERR_DATAOVERRUN  endof
1A54544 	D8 3B A5  1 
1A54548 	48 43 A0  1 24  0  0  0 
1A54550 	9C 53 A0  1  C 44 61 74 
1A54558 	61 20 4F 76 65 72 72 75 
1A54560 	6E  0  0  0 28 2D A4  1 
1A54568 	6C 43 A0  1 DC  0  0  0 
      TD_CC_DATAUNDERRUN	of  " Data Underrun"		USB_ERR_DATAUNDERRUN  endof
1A54570 	F8 3B A5  1 48 43 A0  1 
1A54578 	24  0  0  0 9C 53 A0  1 
1A54580 	 D 44 61 74 61 20 55 6E 
1A54588 	64 65 72 72 75 6E  0  0 
1A54590 	4C 2D A4  1 6C 43 A0  1 
1A54598 	B0  0  0  0 
      TD_CC_BUFFEROVERRUN	of  " Buffer Overrun"		USB_ERR_BUFFEROVERRUN  endof
1A5459C 	18 3C A5  1 
1A545A0 	48 43 A0  1 24  0  0  0 
1A545A8 	9C 53 A0  1  E 42 75 66 
1A545B0 	66 65 72 20 4F 76 65 72 
1A545B8 	72 75 6E  0 70 2D A4  1 
1A545C0 	6C 43 A0  1 84  0  0  0 
      TD_CC_BUFFERUNDERRUN	of  " Buffer Underrun"		USB_ERR_BUFFERUNDERRUN  endof
1A545C8 	3C 3C A5  1 48 43 A0  1 
1A545D0 	28  0  0  0 9C 53 A0  1 
1A545D8 	 F 42 75 66 66 65 72 20 
1A545E0 	55 6E 64 65 72 72 75 6E 
1A545E8 	 0  0  0  0 94 2D A4  1 
1A545F0 	6C 43 A0  1 54  0  0  0 
      TD_CC_NOTACCESSED		of  " Not Accessed"		USB_ERR_NOTACCESSED  endof
1A545F8 	5C 3C A5  1 48 43 A0  1 
1A54600 	24  0  0  0 9C 53 A0  1 
1A54608 	 C 4E 6F 74 20 41 63 63 
1A54610 	65 73 73 65 64  0  0  0 
1A54618 	B4 2D A4  1 6C 43 A0  1 
1A54620 	28  0  0  0 
      ( default )  " Unknown Error" rot USB_ERR_UNKNOWN swap
1A54624 	9C 53 A0  1 
1A54628 	 D 55 6E 6B 6E 6F 77 6E 
1A54630 	20 45 72 72 6F 72  0  0 
1A54638 	7C 49 A0  1 10 2F A4  1 
1A54640 	68 49 A0  1 
   endcase
1A54644 	84 43 A0  1 
   set-usb-error
1A54648 	14 41 A4  1 
;
1A5464C 	58 46 A0  1 

: error?  ( td -- usberr )
1A54650 	 0 65 72 72 6F 72 3F 86 
1A54658 	 8 44 A5  1 20 40 A0  1 
   begin
      dup >td-next l@  if		\ Process a real TD
1A54660 	40 49 A0  1 C8 38 A5  1 
1A54668 	6C 4C A0  1 DC 41 A0  1 
1A54670 	48  0  0  0 
         dup >hctd-control le-l@ TD_CC_MASK and  ?dup  if
1A54674 	40 49 A0  1 
1A54678 	48 37 A5  1 B8 35 A4  1 
1A54680 	74 3C A5  1 5C 44 A0  1 
1A54688 	B4 70 A0  1 DC 41 A0  1 
1A54690 	18  0  0  0 
            .td-error  drop 0		\ Error found in TD
1A54694 	 8 44 A5  1 
1A54698 	30 49 A0  1 70 6F A0  1 
         else
1A546A0 	C8 41 A0  1  C  0  0  0 
            >td-next l@			\ TD's ok, examine the next TD
1A546A8 	C8 38 A5  1 6C 4C A0  1 
         then
      else				\ Don't need to process last dummy TD
1A546B0 	C8 41 A0  1  C  0  0  0 
         drop 0
1A546B8 	30 49 A0  1 70 6F A0  1 
      then
   ?dup 0=  until
1A546C0 	B4 70 A0  1 24 47 A0  1 
1A546C8 	DC 41 A0  1 94 FF FF FF 
   usb-error
1A546D0 	D0 40 A4  1 
;
1A546D4 	58 46 A0  1 

: ed-done?  ( ed -- done? )
1A546D8 	 0  0  0 65 64 2D 64 6F 
1A546E0 	6E 65 3F 88 5C 46 A5  1 
1A546E8 	20 40 A0  1 
   dup  >hced-tdhead le-l@ dup ED_HALTED and	( ed head halted? )
1A546EC 	40 49 A0  1 
1A546F0 	9C 33 A5  1 B8 35 A4  1 
1A546F8 	40 49 A0  1 1C 36 A5  1 
1A54700 	5C 44 A0  1 
   swap h# fffffff0 and			( ed halted? head )
1A54704 	68 49 A0  1 
1A54708 	58 41 A0  1 F0 FF FF FF 
1A54710 	5C 44 A0  1 
   rot >hced-tdtail le-l@ h# fffffff0 and =	( halted? head=tail? )
1A54714 	7C 49 A0  1 
1A54718 	80 33 A5  1 B8 35 A4  1 
1A54720 	58 41 A0  1 F0 FF FF FF 
1A54728 	5C 44 A0  1 24 48 A0  1 
   or						( done? )
1A54730 	70 44 A0  1 
;
1A54734 	58 46 A0  1 

: done?  ( ed -- error? )
1A54738 	 0  0 64 6F 6E 65 3F 85 
1A54740 	E8 46 A5  1 20 40 A0  1 
   begin
      process-hc-status
1A54748 	DC 43 A5  1 
      dup pull-edtds
1A5474C 	40 49 A0  1 
1A54750 	70 3F A5  1 
      dup ed-done? ?dup 0=  if
1A54754 	40 49 A0  1 
1A54758 	E8 46 A5  1 B4 70 A0  1 
1A54760 	24 47 A0  1 DC 41 A0  1 
1A54768 	24  0  0  0 
         1 ms
1A5476C 	80 6F A0  1 
1A54770 	60 E0 A1  1 
	 timeout 1- dup to timeout 0=
1A54774 	F0 43 A5  1 
1A54778 	54 4B A0  1 40 49 A0  1 
1A54780 	B8 40 A0  1 F0 43 A5  1 
1A54788 	24 47 A0  1 
      then
   until
1A5478C 	DC 41 A0  1 
1A54790 	B8 FF FF FF 
   ed-done? 0=  if  " Timeout" USB_ERR_TIMEOUT set-usb-error  then
1A54794 	E8 46 A5  1 
1A54798 	24 47 A0  1 DC 41 A0  1 
1A547A0 	1C  0  0  0 9C 53 A0  1 
1A547A8 	 7 54 69 6D 65 6F 75 74 
1A547B0 	 0  0  0  0 B8 2E A4  1 
1A547B8 	14 41 A4  1 
   usb-error
1A547BC 	D0 40 A4  1 
;
1A547C0 	58 46 A0  1 

: get-actual  ( td -- actual )
1A547C4 	 0 67 65 74 
1A547C8 	2D 61 63 74 75 61 6C 8A 
1A547D0 	44 47 A5  1 20 40 A0  1 
   dup >hctd-cbp le-l@ ?dup  if
1A547D8 	40 49 A0  1 60 37 A5  1 
1A547E0 	B8 35 A4  1 B4 70 A0  1 
1A547E8 	DC 41 A0  1 1C  0  0  0 
      swap >td-pcbp l@ -
1A547F0 	68 49 A0  1 F4 38 A5  1 
1A547F8 	6C 4C A0  1 18 45 A0  1 
   else
1A54800 	C8 41 A0  1 24  0  0  0 
      dup >hctd-be le-l@ swap >td-pcbp l@ - 1+
1A54808 	40 49 A0  1 90 37 A5  1 
1A54810 	B8 35 A4  1 68 49 A0  1 
1A54818 	F4 38 A5  1 6C 4C A0  1 
1A54820 	18 45 A0  1 30 4B A0  1 
   then
;
1A54828 	58 46 A0  1 

headers

OpenFirmware/dev/usb2/hcd/ohci/edtd.fth_AL	189C 1A5482C purpose: Driver for OHCI USB Controller

hex
headers

defer end-extra				' noop to end-extra
1A5482C 	 0  0 65 6E 
1A54830 	64 2D 65 78 74 72 61 89 
1A54838 	D4 47 A5  1 5C 40 A0  1 
1A54840 	B4  E  0  0 

1 constant potpgt			\ PowerONToPowerGoodTime
1A54844 	 0 70 6F 74 
1A54848 	70 67 74 86 3C 48 A5  1 
1A54850 	68 40 A0  1  1  0  0  0 

true value first-open?
1A54858 	66 69 72 73 74 2D 6F 70 
1A54860 	65 6E 3F 8B 50 48 A5  1 
1A54868 	50 40 A0  1 B8  E  0  0 
0 value open-count
1A54870 	 0 6F 70 65 6E 2D 63 6F 
1A54878 	75 6E 74 8A 68 48 A5  1 
1A54880 	50 40 A0  1 BC  E  0  0 
0 value ohci-reg
1A54888 	 0  0  0 6F 68 63 69 2D 
1A54890 	72 65 67 88 80 48 A5  1 
1A54898 	50 40 A0  1 C0  E  0  0 

: my-w@  ( offset -- w )  my-space +  " config-w@" $call-parent  ;
1A548A0 	 0  0 6D 79 2D 77 40 85 
1A548A8 	98 48 A5  1 20 40 A0  1 
1A548B0 	AC  3 A2  1  4 45 A0  1 
1A548B8 	9C 53 A0  1  9 63 6F 6E 
1A548C0 	66 69 67 2D 77 40  0  0 
1A548C8 	DC 31 A2  1 58 46 A0  1 
: my-w!  ( w offset -- )  my-space +  " config-w!" $call-parent  ;
1A548D0 	 0  0 6D 79 2D 77 21 85 
1A548D8 	AC 48 A5  1 20 40 A0  1 
1A548E0 	AC  3 A2  1  4 45 A0  1 
1A548E8 	9C 53 A0  1  9 63 6F 6E 
1A548F0 	66 69 67 2D 77 21  0  0 
1A548F8 	DC 31 A2  1 58 46 A0  1 

: map-regs  ( -- )
1A54900 	 0  0  0 6D 61 70 2D 72 
1A54908 	65 67 73 88 DC 48 A5  1 
1A54910 	20 40 A0  1 
   4 my-w@  h# 16 or  4 my-w!
1A54914 	B0 6F A0  1 
1A54918 	AC 48 A5  1 58 41 A0  1 
1A54920 	16  0  0  0 70 44 A0  1 
1A54928 	B0 6F A0  1 DC 48 A5  1 
   0 0 my-space h# 02000010 + 1000  " map-in" $call-parent to ohci-reg
1A54930 	70 6F A0  1 70 6F A0  1 
1A54938 	AC  3 A2  1 58 41 A0  1 
1A54940 	10  0  0  2  4 45 A0  1 
1A54948 	58 41 A0  1  0 10  0  0 
1A54950 	9C 53 A0  1  6 6D 61 70 
1A54958 	2D 69 6E  0 DC 31 A2  1 
1A54960 	B8 40 A0  1 98 48 A5  1 
;
1A54968 	58 46 A0  1 

: unmap-regs  ( -- )
1A5496C 	 0 75 6E 6D 
1A54970 	61 70 2D 72 65 67 73 8A 
1A54978 	10 49 A5  1 20 40 A0  1 
   ohci-reg  1000  " map-out" $call-parent  0 to ohci-reg
1A54980 	98 48 A5  1 58 41 A0  1 
1A54988 	 0 10  0  0 9C 53 A0  1 
1A54990 	 7 6D 61 70 2D 6F 75 74 
1A54998 	 0  0  0  0 DC 31 A2  1 
1A549A0 	70 6F A0  1 B8 40 A0  1 
1A549A8 	98 48 A5  1 
;
1A549AC 	58 46 A0  1 

: ohci-reg@  ( idx -- data )  ohci-reg + rl@  ;
1A549B0 	 0  0 6F 68 63 69 2D 72 
1A549B8 	65 67 40 89 7C 49 A5  1 
1A549C0 	20 40 A0  1 98 48 A5  1 
1A549C8 	 4 45 A0  1 F8 B1 A2  1 
1A549D0 	58 46 A0  1 
: ohci-reg!  ( data idx -- )  ohci-reg + rl!  ;
1A549D4 	 0  0 6F 68 
1A549D8 	63 69 2D 72 65 67 21 89 
1A549E0 	C0 49 A5  1 20 40 A0  1 
1A549E8 	98 48 A5  1  4 45 A0  1 
1A549F0 	68 B2 A2  1 58 46 A0  1 

: hc-cntl@  ( -- data )   4 ohci-reg@  ;
1A549F8 	 0  0  0 68 63 2D 63 6E 
1A54A00 	74 6C 40 88 E4 49 A5  1 
1A54A08 	20 40 A0  1 B0 6F A0  1 
1A54A10 	C0 49 A5  1 58 46 A0  1 
: hc-cntl!  ( data -- )   4 ohci-reg!  ;
1A54A18 	 0  0  0 68 63 2D 63 6E 
1A54A20 	74 6C 21 88  8 4A A5  1 
1A54A28 	20 40 A0  1 B0 6F A0  1 
1A54A30 	E4 49 A5  1 58 46 A0  1 
: hc-stat@  ( -- data )   8 ohci-reg@  ;
1A54A38 	 0  0  0 68 63 2D 73 74 
1A54A40 	61 74 40 88 28 4A A5  1 
1A54A48 	20 40 A0  1 F0 6F A0  1 
1A54A50 	C0 49 A5  1 58 46 A0  1 
: hc-cmd!   ( data -- )   8 ohci-reg!  ;
1A54A58 	68 63 2D 63 6D 64 21 87 
1A54A60 	48 4A A5  1 20 40 A0  1 
1A54A68 	F0 6F A0  1 E4 49 A5  1 
1A54A70 	58 46 A0  1 
: hc-intr@  ( -- data )   c ohci-reg@  ;
1A54A74 	 0  0  0 68 
1A54A78 	63 2D 69 6E 74 72 40 88 
1A54A80 	64 4A A5  1 20 40 A0  1 
1A54A88 	58 41 A0  1  C  0  0  0 
1A54A90 	C0 49 A5  1 58 46 A0  1 
: hc-intr!  ( data -- )   c ohci-reg!  ;
1A54A98 	 0  0  0 68 63 2D 69 6E 
1A54AA0 	74 72 21 88 84 4A A5  1 
1A54AA8 	20 40 A0  1 58 41 A0  1 
1A54AB0 	 C  0  0  0 E4 49 A5  1 
1A54AB8 	58 46 A0  1 
: hc-hcca@  ( -- data )  18 ohci-reg@  ;
1A54ABC 	 0  0  0 68 
1A54AC0 	63 2D 68 63 63 61 40 88 
1A54AC8 	A8 4A A5  1 20 40 A0  1 
1A54AD0 	58 41 A0  1 18  0  0  0 
1A54AD8 	C0 49 A5  1 58 46 A0  1 
: hc-hcca!  ( data -- )  18 ohci-reg!  ;
1A54AE0 	 0  0  0 68 63 2D 68 63 
1A54AE8 	63 61 21 88 CC 4A A5  1 
1A54AF0 	20 40 A0  1 58 41 A0  1 
1A54AF8 	18  0  0  0 E4 49 A5  1 
1A54B00 	58 46 A0  1 

: hc-rh-desA@  ( -- data )  48 ohci-reg@  ;
1A54B04 	68 63 2D 72 
1A54B08 	68 2D 64 65 73 61 40 8B 
1A54B10 	F0 4A A5  1 20 40 A0  1 
1A54B18 	58 41 A0  1 48  0  0  0 
1A54B20 	C0 49 A5  1 58 46 A0  1 
: hc-rh-desA!  ( data -- )  48 ohci-reg!  ;
1A54B28 	68 63 2D 72 68 2D 64 65 
1A54B30 	73 61 21 8B 14 4B A5  1 
1A54B38 	20 40 A0  1 58 41 A0  1 
1A54B40 	48  0  0  0 E4 49 A5  1 
1A54B48 	58 46 A0  1 
: hc-rh-desB@  ( -- data )  4c ohci-reg@  ;
1A54B4C 	68 63 2D 72 
1A54B50 	68 2D 64 65 73 62 40 8B 
1A54B58 	38 4B A5  1 20 40 A0  1 
1A54B60 	58 41 A0  1 4C  0  0  0 
1A54B68 	C0 49 A5  1 58 46 A0  1 
: hc-rh-desB!  ( data -- )  4c ohci-reg!  ;
1A54B70 	68 63 2D 72 68 2D 64 65 
1A54B78 	73 62 21 8B 5C 4B A5  1 
1A54B80 	20 40 A0  1 58 41 A0  1 
1A54B88 	4C  0  0  0 E4 49 A5  1 
1A54B90 	58 46 A0  1 
: hc-rh-stat@  ( -- data )  50 ohci-reg@  ;
1A54B94 	68 63 2D 72 
1A54B98 	68 2D 73 74 61 74 40 8B 
1A54BA0 	80 4B A5  1 20 40 A0  1 
1A54BA8 	58 41 A0  1 50  0  0  0 
1A54BB0 	C0 49 A5  1 58 46 A0  1 
: hc-rh-stat!  ( data -- )  50 ohci-reg!  ;
1A54BB8 	68 63 2D 72 68 2D 73 74 
1A54BC0 	61 74 21 8B A4 4B A5  1 
1A54BC8 	20 40 A0  1 58 41 A0  1 
1A54BD0 	50  0  0  0 E4 49 A5  1 
1A54BD8 	58 46 A0  1 

: hc-rh-psta@  ( port -- data )  4 * 54 + ohci-reg@  ;
1A54BDC 	68 63 2D 72 
1A54BE0 	68 2D 70 73 74 61 40 8B 
1A54BE8 	C8 4B A5  1 20 40 A0  1 
1A54BF0 	B0 6F A0  1 1C 5F A0  1 
1A54BF8 	58 41 A0  1 54  0  0  0 
1A54C00 	 4 45 A0  1 C0 49 A5  1 
1A54C08 	58 46 A0  1 
: hc-rh-psta!  ( data port -- )  4 * 54 + ohci-reg!  ;
1A54C0C 	68 63 2D 72 
1A54C10 	68 2D 70 73 74 61 21 8B 
1A54C18 	EC 4B A5  1 20 40 A0  1 
1A54C20 	B0 6F A0  1 1C 5F A0  1 
1A54C28 	58 41 A0  1 54  0  0  0 
1A54C30 	 4 45 A0  1 E4 49 A5  1 
1A54C38 	58 46 A0  1 

: hc-cntl-clr  ( bit-mask -- )  hc-cntl@ swap invert and hc-cntl!  ;
1A54C3C 	68 63 2D 63 
1A54C40 	6E 74 6C 2D 63 6C 72 8B 
1A54C48 	1C 4C A5  1 20 40 A0  1 
1A54C50 	 8 4A A5  1 68 49 A0  1 
1A54C58 	30 45 A0  1 5C 44 A0  1 
1A54C60 	28 4A A5  1 58 46 A0  1 
: hc-cntl-set  ( bit-mask -- )  hc-cntl@ swap or hc-cntl!  ;
1A54C68 	68 63 2D 63 6E 74 6C 2D 
1A54C70 	73 65 74 8B 4C 4C A5  1 
1A54C78 	20 40 A0  1  8 4A A5  1 
1A54C80 	68 49 A0  1 70 44 A0  1 
1A54C88 	28 4A A5  1 58 46 A0  1 

: reset-port  ( port -- )
1A54C90 	 0 72 65 73 65 74 2D 70 
1A54C98 	6F 72 74 8A 78 4C A5  1 
1A54CA0 	20 40 A0  1 
   >r
1A54CA4 	BC 45 A0  1 
   h# 10002 r@ hc-rh-psta!		\ enable port
1A54CA8 	58 41 A0  1  2  0  1  0 
1A54CB0 	E4 45 A0  1 1C 4C A5  1 
   h# 10 r@ hc-rh-psta!			\ reset port
1A54CB8 	58 41 A0  1 10  0  0  0 
1A54CC0 	E4 45 A0  1 1C 4C A5  1 
   r@ d# 10 0  do
1A54CC8 	E4 45 A0  1 58 41 A0  1 
1A54CD0 	 A  0  0  0 70 6F A0  1 
1A54CD8 	88 42 A0  1 30  0  0  0 
      d# 10 ms
1A54CE0 	58 41 A0  1  A  0  0  0 
1A54CE8 	60 E0 A1  1 
      dup hc-rh-psta@ 100000 and  ?leave
1A54CEC 	40 49 A0  1 
1A54CF0 	EC 4B A5  1 58 41 A0  1 
1A54CF8 	 0  0 10  0 5C 44 A0  1 
1A54D00 	34 43 A0  1 
   loop  drop
1A54D04 	F8 41 A0  1 
1A54D08 	D8 FF FF FF 30 49 A0  1 
   r@ hc-rh-psta@ 100000 and 0=  if  abort  then
1A54D10 	E4 45 A0  1 EC 4B A5  1 
1A54D18 	58 41 A0  1  0  0 10  0 
1A54D20 	5C 44 A0  1 24 47 A0  1 
1A54D28 	DC 41 A0  1  8  0  0  0 
1A54D30 	28 91 A0  1 
   h# 1f0000 r> hc-rh-psta!		\ clear status change bits
1A54D34 	58 41 A0  1 
1A54D38 	 0  0 1F  0 D0 45 A0  1 
1A54D40 	1C 4C A5  1 
   d# 256 ms
1A54D44 	58 41 A0  1 
1A54D48 	 0  1  0  0 60 E0 A1  1 
;
1A54D50 	58 46 A0  1 

: reset-usb  ( -- )
1A54D54 	 0  0 72 65 
1A54D58 	73 65 74 2D 75 73 62 89 
1A54D60 	A0 4C A5  1 20 40 A0  1 
   ohci-reg dup 0=  if  map-regs  then
1A54D68 	98 48 A5  1 40 49 A0  1 
1A54D70 	24 47 A0  1 DC 41 A0  1 
1A54D78 	 8  0  0  0 10 49 A5  1 
   1 hc-rh-stat!		\ power-off root hub
1A54D80 	80 6F A0  1 C8 4B A5  1 
   1 hc-cmd!			\ reset usb host controller
1A54D88 	80 6F A0  1 64 4A A5  1 
   d# 10 ms
1A54D90 	58 41 A0  1  A  0  0  0 
1A54D98 	60 E0 A1  1 
   0= if  unmap-regs  then
1A54D9C 	24 47 A0  1 
1A54DA0 	DC 41 A0  1  8  0  0  0 
1A54DA8 	7C 49 A5  1 
;
1A54DAC 	58 46 A0  1 

: init-ohci-regs  ( -- )
1A54DB0 	 0 69 6E 69 74 2D 6F 68 
1A54DB8 	63 69 2D 72 65 67 73 8E 
1A54DC0 	64 4D A5  1 20 40 A0  1 
   hcca-phys hc-hcca!		\ physical address of hcca
1A54DC8 	E4 2F A5  1 F0 4A A5  1 

   81 hc-cntl!			\ USB operational, 2:1 ControlBulkServiceRatio
1A54DD0 	58 41 A0  1 81  0  0  0 
1A54DD8 	28 4A A5  1 
   d# 10 ms
1A54DDC 	58 41 A0  1 
1A54DE0 	 A  0  0  0 60 E0 A1  1 

   a668.2edf 34 ohci-reg!	\ HcFmInterval
1A54DE8 	80 41 A0  1 DF 2E 68 A6 
1A54DF0 	 0  0  0  0 58 41 A0  1 
1A54DF8 	34  0  0  0 E4 49 A5  1 
   2580 40 ohci-reg!		\ HcPeriodicStart
1A54E00 	58 41 A0  1 80 25  0  0 
1A54E08 	58 41 A0  1 40  0  0  0 
1A54E10 	E4 49 A5  1 
;
1A54E14 	58 46 A0  1 

: (process-hc-status)  ( -- )
1A54E18 	28 70 72 6F 63 65 73 73 
1A54E20 	2D 68 63 2D 73 74 61 74 
1A54E28 	75 73 29 93 C4 4D A5  1 
1A54E30 	20 40 A0  1 
   hc-intr@ dup hc-intr!
1A54E34 	84 4A A5  1 
1A54E38 	40 49 A0  1 A8 4A A5  1 
   h# 10 and  if  " Unrecoverable error" USB_ERR_HCHALTED set-usb-error  then
1A54E40 	58 41 A0  1 10  0  0  0 
1A54E48 	5C 44 A0  1 DC 41 A0  1 
1A54E50 	28  0  0  0 9C 53 A0  1 
1A54E58 	13 55 6E 72 65 63 6F 76 
1A54E60 	65 72 61 62 6C 65 20 65 
1A54E68 	72 72 6F 72  0  0  0  0 
1A54E70 	D4 2D A4  1 14 41 A4  1 
;
1A54E78 	58 46 A0  1 
' (process-hc-status) to process-hc-status

: wait-for-frame  ( -- )  begin  hc-intr@ 4 and  until  ;
1A54E7C 	 0 77 61 69 
1A54E80 	74 2D 66 6F 72 2D 66 72 
1A54E88 	61 6D 65 8E 30 4E A5  1 
1A54E90 	20 40 A0  1 84 4A A5  1 
1A54E98 	B0 6F A0  1 5C 44 A0  1 
1A54EA0 	DC 41 A0  1 F0 FF FF FF 
1A54EA8 	58 46 A0  1 
: next-frame      ( -- )  4 hc-intr!  wait-for-frame    ;
1A54EAC 	 0 6E 65 78 
1A54EB0 	74 2D 66 72 61 6D 65 8A 
1A54EB8 	90 4E A5  1 20 40 A0  1 
1A54EC0 	B0 6F A0  1 A8 4A A5  1 
1A54EC8 	90 4E A5  1 58 46 A0  1 

external
\ Kick the USB controller into operation mode.
: start-usb     ( -- )  c0 hc-cntl-clr 80 hc-cntl-set  ;
1A54ED0 	 0  0 73 74 61 72 74 2D 
1A54ED8 	75 73 62 89 BC 4E A5  1 
1A54EE0 	20 40 A0  1 58 41 A0  1 
1A54EE8 	C0  0  0  0 4C 4C A5  1 
1A54EF0 	58 41 A0  1 80  0  0  0 
1A54EF8 	78 4C A5  1 58 46 A0  1 
: suspend-usb   ( -- )  c0 hc-cntl-set  ;
1A54F00 	73 75 73 70 65 6E 64 2D 
1A54F08 	75 73 62 8B E0 4E A5  1 
1A54F10 	20 40 A0  1 58 41 A0  1 
1A54F18 	C0  0  0  0 78 4C A5  1 
1A54F20 	58 46 A0  1 

headers

OpenFirmware/dev/usb2/hcd/ohci/ohci.fth_AL	6F8 1A54F24 purpose: OHCI USB Controller transaction processing

hex
headers

: disable-control  ( -- )  10 hc-cntl-clr  next-frame  0 20 ohci-reg!  ;
1A54F24 	64 69 73 61 
1A54F28 	62 6C 65 2D 63 6F 6E 74 
1A54F30 	72 6F 6C 8F 10 4F A5  1 
1A54F38 	20 40 A0  1 58 41 A0  1 
1A54F40 	10  0  0  0 4C 4C A5  1 
1A54F48 	BC 4E A5  1 70 6F A0  1 
1A54F50 	58 41 A0  1 20  0  0  0 
1A54F58 	E4 49 A5  1 58 46 A0  1 
: enable-control   ( -- )
1A54F60 	 0 65 6E 61 62 6C 65 2D 
1A54F68 	63 6F 6E 74 72 6F 6C 8E 
1A54F70 	38 4F A5  1 20 40 A0  1 
   ed-control >ed-phys l@ 20 ohci-reg!	\ set HcControlHeadED
1A54F78 	34 33 A5  1 E0 33 A5  1 
1A54F80 	6C 4C A0  1 58 41 A0  1 
1A54F88 	20  0  0  0 E4 49 A5  1 
   2 hc-cmd!				\ mark TD added in control list
1A54F90 	90 6F A0  1 64 4A A5  1 
   10 hc-cntl-set  			\ enable control list processing
1A54F98 	58 41 A0  1 10  0  0  0 
1A54FA0 	78 4C A5  1 
;
1A54FA4 	58 46 A0  1 

: insert-control  ( ed -- )
1A54FA8 	 0 69 6E 73 65 72 74 2D 
1A54FB0 	63 6F 6E 74 72 6F 6C 8E 
1A54FB8 	74 4F A5  1 20 40 A0  1 
   ed-control  if  disable-control  then
1A54FC0 	34 33 A5  1 DC 41 A0  1 
1A54FC8 	 8  0  0  0 38 4F A5  1 
   ( ed ) insert-control-ed
1A54FD0 	CC 40 A5  1 
   enable-control
1A54FD4 	74 4F A5  1 
;
1A54FD8 	58 46 A0  1 
: remove-control  ( ed -- )
1A54FDC 	 0 72 65 6D 
1A54FE0 	6F 76 65 2D 63 6F 6E 74 
1A54FE8 	72 6F 6C 8E BC 4F A5  1 
1A54FF0 	20 40 A0  1 
   disable-control
1A54FF4 	38 4F A5  1 
   ( ed ) remove-control-ed
1A54FF8 	 0 41 A5  1 
   ed-control  if  enable-control  then
1A54FFC 	34 33 A5  1 
1A55000 	DC 41 A0  1  8  0  0  0 
1A55008 	74 4F A5  1 
;
1A5500C 	58 46 A0  1 

\ Local temporary variables (common for control, bulk & interrupt)

\ my-dev and my-real-dev are created here to deal with set-address.
\ Normally my-dev and my-real-dev are both of the value of target.
\ However, during set-address, target=my-dev=0, my-real-dev is the
\ address to be assigned to my-real-dev.  The correct path to get
\ a device's characteristics is via my-real-dev.

0 value my-dev					\ Equals to target
1A55010 	 0 6D 79 2D 64 65 76 86 
1A55018 	F0 4F A5  1 50 40 A0  1 
1A55020 	C4  E  0  0 
0 value my-real-dev				\ Path to device's characteristics
1A55024 	6D 79 2D 72 
1A55028 	65 61 6C 2D 64 65 76 8B 
1A55030 	1C 50 A5  1 50 40 A0  1 
1A55038 	C8  E  0  0 
0 value my-dev/pipe				\ Device/pipe for ED
1A5503C 	6D 79 2D 64 
1A55040 	65 76 2F 70 69 70 65 8B 
1A55048 	34 50 A5  1 50 40 A0  1 
1A55050 	CC  E  0  0 

0 value my-speed				\ Speed of my-real-dev
1A55054 	 0  0  0 6D 
1A55058 	79 2D 73 70 65 65 64 88 
1A55060 	4C 50 A5  1 50 40 A0  1 
1A55068 	D0  E  0  0 
0 value my-maxpayload				\ Pipe's max payload
1A5506C 	 0  0 6D 79 
1A55070 	2D 6D 61 78 70 61 79 6C 
1A55078 	6F 61 64 8D 64 50 A5  1 
1A55080 	50 40 A0  1 D4  E  0  0 

0 value my-buf					\ Virtual address of data buffer
1A55088 	 0 6D 79 2D 62 75 66 86 
1A55090 	80 50 A5  1 50 40 A0  1 
1A55098 	D8  E  0  0 
0 value my-buf-phys				\ Physical address of data buffer
1A5509C 	6D 79 2D 62 
1A550A0 	75 66 2D 70 68 79 73 8B 
1A550A8 	94 50 A5  1 50 40 A0  1 
1A550B0 	DC  E  0  0 
0 value /my-buf					\ Size of data buffer
1A550B4 	2F 6D 79 2D 
1A550B8 	62 75 66 87 AC 50 A5  1 
1A550C0 	50 40 A0  1 E0  E  0  0 

0 value my-td					\ Current TD head
1A550C8 	 0  0 6D 79 2D 74 64 85 
1A550D0 	C0 50 A5  1 50 40 A0  1 
1A550D8 	E4  E  0  0 
0 value my-ed					\ Current ED
1A550DC 	 0  0 6D 79 
1A550E0 	2D 65 64 85 D4 50 A5  1 
1A550E8 	50 40 A0  1 E8  E  0  0 

: set-real-dev  ( real-dev target -- )		\ For set-address only
1A550F0 	 0  0  0 73 65 74 2D 72 
1A550F8 	65 61 6C 2D 64 65 76 8C 
1A55100 	E8 50 A5  1 20 40 A0  1 
   to my-dev to my-real-dev
1A55108 	B8 40 A0  1 1C 50 A5  1 
1A55110 	B8 40 A0  1 34 50 A5  1 
;
1A55118 	58 46 A0  1 

\- set-my-dev defer set-my-dev

: set-my-char  ( pipe -- )			\ Set device's characteristics
1A5511C 	73 65 74 2D 
1A55120 	6D 79 2D 63 68 61 72 8B 
1A55128 	 4 51 A5  1 20 40 A0  1 
   dup 7 << my-dev or to my-dev/pipe		( pipe )
1A55130 	40 49 A0  1 E0 6F A0  1 
1A55138 	C8 44 A0  1 1C 50 A5  1 
1A55140 	70 44 A0  1 B8 40 A0  1 
1A55148 	4C 50 A5  1 
   my-real-dev dup di-speed@			( pipe dev speed )
1A5514C 	34 50 A5  1 
1A55150 	40 49 A0  1  4 43 A4  1 
   speed-full =  if  ED_SPEED_FULL  else  ED_SPEED_LO  then  to my-speed
1A55158 	5C 2F A4  1 24 48 A0  1 
1A55160 	DC 41 A0  1 10  0  0  0 
1A55168 	E4 34 A5  1 C8 41 A0  1 
1A55170 	 8  0  0  0 FC 34 A5  1 
1A55178 	B8 40 A0  1 64 50 A5  1 
						( pipe dev )
   di-maxpayload@  to my-maxpayload		( )
1A55180 	60 44 A4  1 B8 40 A0  1 
1A55188 	80 50 A5  1 
;
1A5518C 	58 46 A0  1 
: process-control-args  ( buf phy len -- )
1A55190 	 0  0  0 70 72 6F 63 65 
1A55198 	73 73 2D 63 6F 6E 74 72 
1A551A0 	6F 6C 2D 61 72 67 73 94 
1A551A8 	2C 51 A5  1 20 40 A0  1 
   to /my-buf to my-buf-phys to my-buf
1A551B0 	B8 40 A0  1 C0 50 A5  1 
1A551B8 	B8 40 A0  1 AC 50 A5  1 
1A551C0 	B8 40 A0  1 94 50 A5  1 
   clear-usb-error
1A551C8 	EC 40 A4  1 
   set-my-dev
1A551CC 	14 52 A4  1 
   0 set-my-char
1A551D0 	70 6F A0  1 2C 51 A5  1 
;
1A551D8 	58 46 A0  1 

: alloc-control-edtds  ( extra-tds -- )
1A551DC 	61 6C 6C 6F 
1A551E0 	63 2D 63 6F 6E 74 72 6F 
1A551E8 	6C 2D 65 64 74 64 73 93 
1A551F0 	AC 51 A5  1 20 40 A0  1 
   /my-buf  if  1+ data-timeout  else  nodata-timeout  then  to timeout
1A551F8 	C0 50 A5  1 DC 41 A0  1 
1A55200 	14  0  0  0 30 4B A0  1 
1A55208 	 8 3C A4  1 C8 41 A0  1 
1A55210 	 8  0  0  0 EC 3B A4  1 
1A55218 	B8 40 A0  1 F0 43 A5  1 
   alloc-edtds to my-td to my-ed
1A55220 	68 3E A5  1 B8 40 A0  1 
1A55228 	D4 50 A5  1 B8 40 A0  1 
1A55230 	E8 50 A5  1 
;
1A55234 	58 46 A0  1 

: fill-setup-td  ( sbuf sphy slen control -- )
1A55238 	 0  0 66 69 6C 6C 2D 73 
1A55240 	65 74 75 70 2D 74 64 8D 
1A55248 	F4 51 A5  1 20 40 A0  1 
   TD_CC_NOTACCESSED or TD_DIR_SETUP or TD_INTR_OFF or TD_TOGGLE_USE_LSB0 or
1A55250 	5C 3C A5  1 70 44 A0  1 
1A55258 	8C 39 A5  1 70 44 A0  1 
1A55260 	 4 3A A5  1 70 44 A0  1 
1A55268 	60 3A A5  1 70 44 A0  1 
   my-td >hctd-control le-l!
1A55270 	D4 50 A5  1 48 37 A5  1 
1A55278 	50 36 A4  1 
   over + 1-  my-td >hctd-be le-l!
1A5527C 	54 49 A0  1 
1A55280 	 4 45 A0  1 54 4B A0  1 
1A55288 	D4 50 A5  1 90 37 A5  1 
1A55290 	50 36 A4  1 
   ( sphy ) my-td 2dup >hctd-cbp le-l!
1A55294 	D4 50 A5  1 
1A55298 	C0 49 A0  1 60 37 A5  1 
1A552A0 	50 36 A4  1 
   ( sphy ) >td-pcbp l!
1A552A4 	F4 38 A5  1 
1A552A8 	7C 4D A0  1 
   ( sbuf ) my-td >td-cbp l!
1A552AC 	D4 50 A5  1 
1A552B0 	DC 38 A5  1 7C 4D A0  1 
;
1A552B8 	58 46 A0  1 

: fill-io-tds  ( td control -- )
1A552BC 	66 69 6C 6C 
1A552C0 	2D 69 6F 2D 74 64 73 8B 
1A552C8 	4C 52 A5  1 20 40 A0  1 
   over >hctd-control le-l!
1A552D0 	54 49 A0  1 48 37 A5  1 
1A552D8 	50 36 A4  1 
   my-buf over >td-cbp l!
1A552DC 	94 50 A5  1 
1A552E0 	54 49 A0  1 DC 38 A5  1 
1A552E8 	7C 4D A0  1 
   my-buf-phys over 2dup >hctd-cbp le-l!
1A552EC 	AC 50 A5  1 
1A552F0 	54 49 A0  1 C0 49 A0  1 
1A552F8 	60 37 A5  1 50 36 A4  1 
   >td-pcbp l!
1A55300 	F4 38 A5  1 7C 4D A0  1 
   my-buf-phys /my-buf + 1- swap >hctd-be le-l!
1A55308 	AC 50 A5  1 C0 50 A5  1 
1A55310 	 4 45 A0  1 54 4B A0  1 
1A55318 	68 49 A0  1 90 37 A5  1 
1A55320 	50 36 A4  1 
;
1A55324 	58 46 A0  1 
: fill-control-io-tds  ( dir -- std )
1A55328 	66 69 6C 6C 2D 63 6F 6E 
1A55330 	74 72 6F 6C 2D 69 6F 2D 
1A55338 	74 64 73 93 CC 52 A5  1 
1A55340 	20 40 A0  1 
   my-td >td-next l@				( dir td )
1A55344 	D4 50 A5  1 
1A55348 	C8 38 A5  1 6C 4C A0  1 
   /my-buf 0=  if  nip exit  then		( dir td )
1A55350 	C0 50 A5  1 24 47 A0  1 
1A55358 	DC 41 A0  1  C  0  0  0 
1A55360 	FC 46 A0  1 40 46 A0  1 
   dup rot					( td td dir )
1A55368 	40 49 A0  1 7C 49 A0  1 
   TD_CC_NOTACCESSED or TD_INTR_OFF or TD_TOGGLE_USE_LSB1 or
1A55370 	5C 3C A5  1 70 44 A0  1 
1A55378 	 4 3A A5  1 70 44 A0  1 
1A55380 	80 3A A5  1 70 44 A0  1 
						( td td control )
   fill-io-tds					( td )
1A55388 	CC 52 A5  1 
   >td-next l@					( std )
1A5538C 	C8 38 A5  1 
1A55390 	6C 4C A0  1 
;
1A55394 	58 46 A0  1 

: fill-control-ed  ( ed -- )
1A55398 	66 69 6C 6C 2D 63 6F 6E 
1A553A0 	74 72 6F 6C 2D 65 64 8F 
1A553A8 	40 53 A5  1 20 40 A0  1 
   my-dev my-speed or ED_DIR_TD or ED_SKIP_OFF or ED_FORMAT_G or
1A553B0 	1C 50 A5  1 64 50 A5  1 
1A553B8 	70 44 A0  1 80 34 A5  1 
1A553C0 	70 44 A0  1 30 35 A5  1 
1A553C8 	70 44 A0  1 7C 35 A5  1 
1A553D0 	70 44 A0  1 
   my-maxpayload d# 16 << or
1A553D4 	80 50 A5  1 
1A553D8 	58 41 A0  1 10  0  0  0 
1A553E0 	C8 44 A0  1 70 44 A0  1 
   swap >hced-control le-l!
1A553E8 	68 49 A0  1 64 33 A5  1 
1A553F0 	50 36 A4  1 
;
1A553F4 	58 46 A0  1 

: insert-my-control  ( -- )
1A553F8 	 0  0 69 6E 73 65 72 74 
1A55400 	2D 6D 79 2D 63 6F 6E 74 
1A55408 	72 6F 6C 91 AC 53 A5  1 
1A55410 	20 40 A0  1 
   my-ed dup fill-control-ed
1A55414 	E8 50 A5  1 
1A55418 	40 49 A0  1 AC 53 A5  1 
   dup push-edtds
1A55420 	40 49 A0  1 3C 3F A5  1 
   insert-control
1A55428 	BC 4F A5  1 
;
1A5542C 	58 46 A0  1 

: remove-my-control  ( -- )
1A55430 	 0  0 72 65 6D 6F 76 65 
1A55438 	2D 6D 79 2D 63 6F 6E 74 
1A55440 	72 6F 6C 91 10 54 A5  1 
1A55448 	20 40 A0  1 
   my-ed dup remove-control
1A5544C 	E8 50 A5  1 
1A55450 	40 49 A0  1 F0 4F A5  1 
   free-edtds
1A55458 	F4 3E A5  1 
;
1A5545C 	58 46 A0  1 


\ ---------------------------------------------------------------------------
\ CONTROL pipe operations
\ ---------------------------------------------------------------------------

: (control-get)  ( sbuf sphy slen buf phy len -- actual usberr )
1A55460 	 0  0 28 63 6F 6E 74 72 
1A55468 	6F 6C 2D 67 65 74 29 8D 
1A55470 	48 54 A5  1 20 40 A0  1 
   process-control-args				( sbuf sphy slen )
1A55478 	AC 51 A5  1 
   /my-buf 0=  if  3drop 0 USB_ERR_INV_OP exit  then
1A5547C 	C0 50 A5  1 
1A55480 	24 47 A0  1 DC 41 A0  1 
1A55488 	14  0  0  0 98 3F A4  1 
1A55490 	70 6F A0  1 D4 2E A4  1 
1A55498 	40 46 A0  1 
   3 alloc-control-edtds			( sbuf sphy slen )
1A5549C 	A0 6F A0  1 
1A554A0 	F4 51 A5  1 

   \ SETUP TD
   TD_ROUND_ON fill-setup-td			( )
1A554A4 	38 39 A5  1 
1A554A8 	4C 52 A5  1 

   \ IN TD
   TD_DIR_IN TD_ROUND_ON or fill-control-io-tds	( std )
1A554AC 	BC 39 A5  1 
1A554B0 	38 39 A5  1 70 44 A0  1 
1A554B8 	40 53 A5  1 

   \ Status TD (OUT)
   TD_CC_NOTACCESSED TD_DIR_OUT or TD_INTR_MIN or TD_TOGGLE_USE_LSB1 or
1A554BC 	5C 3C A5  1 
1A554C0 	A4 39 A5  1 70 44 A0  1 
1A554C8 	EC 39 A5  1 70 44 A0  1 
1A554D0 	80 3A A5  1 70 44 A0  1 
   TD_ROUND_ON or
1A554D8 	38 39 A5  1 70 44 A0  1 
   swap >hctd-control le-l!			( )
1A554E0 	68 49 A0  1 48 37 A5  1 
1A554E8 	50 36 A4  1 

   \ Start control transaction
   insert-my-control				( )
1A554EC 	10 54 A5  1 

   \ Process results
   my-ed done?  if				( )
1A554F0 	E8 50 A5  1 44 47 A5  1 
1A554F8 	DC 41 A0  1 10  0  0  0 
      0						( actual )	\ System error, timeout
1A55500 	70 6F A0  1 
   else
1A55504 	C8 41 A0  1 
1A55508 	58  0  0  0 
      my-td error?  if				( )
1A5550C 	D4 50 A5  1 
1A55510 	5C 46 A5  1 DC 41 A0  1 
1A55518 	10  0  0  0 
	 0					( actual )	\ USB error
1A5551C 	70 6F A0  1 
      else
1A55520 	C8 41 A0  1 3C  0  0  0 
         my-td >td-next l@ dup get-actual	( td actual )
1A55528 	D4 50 A5  1 C8 38 A5  1 
1A55530 	6C 4C A0  1 40 49 A0  1 
1A55538 	D4 47 A5  1 
         over >td-cbp l@ rot >td-pcbp l@ 2 pick dma-pull	( actual )
1A5553C 	54 49 A0  1 
1A55540 	DC 38 A5  1 6C 4C A0  1 
1A55548 	7C 49 A0  1 F4 38 A5  1 
1A55550 	6C 4C A0  1 90 6F A0  1 
1A55558 	 C 4A A0  1 28 37 A4  1 
      then
   then

   remove-my-control				( actual )
1A55560 	48 54 A5  1 
   usb-error					( actual usberr )
1A55564 	D0 40 A4  1 
;
1A55568 	58 46 A0  1 

: (control-set)  ( sbuf sphy slen buf phy len -- usberr )
1A5556C 	 0  0 28 63 
1A55570 	6F 6E 74 72 6F 6C 2D 73 
1A55578 	65 74 29 8D 74 54 A5  1 
1A55580 	20 40 A0  1 
   process-control-args				( sbuf sphy slen )
1A55584 	AC 51 A5  1 
   3 alloc-control-edtds			( sbuf sphy slen )
1A55588 	A0 6F A0  1 F4 51 A5  1 

   \ SETUP TD
   0 fill-setup-td				( )
1A55590 	70 6F A0  1 4C 52 A5  1 

   \ OUT TD
   TD_DIR_OUT fill-control-io-tds		( std )
1A55598 	A4 39 A5  1 40 53 A5  1 

   \ Status TD (IN) 	   			( std )
   TD_CC_NOTACCESSED TD_DIR_IN or TD_INTR_MIN or TD_TOGGLE_USE_LSB1 or
1A555A0 	5C 3C A5  1 BC 39 A5  1 
1A555A8 	70 44 A0  1 EC 39 A5  1 
1A555B0 	70 44 A0  1 80 3A A5  1 
1A555B8 	70 44 A0  1 
   ( TD_ROUND_ON or )
   swap >hctd-control le-l!			( )
1A555BC 	68 49 A0  1 
1A555C0 	48 37 A5  1 50 36 A4  1 

   \ Start control transaction
   insert-my-control
1A555C8 	10 54 A5  1 

   \ Process results
   my-ed done? 0=  if  my-td error? drop  then
1A555CC 	E8 50 A5  1 
1A555D0 	44 47 A5  1 24 47 A0  1 
1A555D8 	DC 41 A0  1 10  0  0  0 
1A555E0 	D4 50 A5  1 5C 46 A5  1 
1A555E8 	30 49 A0  1 

   remove-my-control				( )
1A555EC 	48 54 A5  1 
   usb-error					( usberr )
1A555F0 	D0 40 A4  1 
;
1A555F4 	58 46 A0  1 

: (control-set-nostat)  ( sbuf sphy slen buf phy len -- usberr )
1A555F8 	 0  0  0 28 63 6F 6E 74 
1A55600 	72 6F 6C 2D 73 65 74 2D 
1A55608 	6E 6F 73 74 61 74 29 94 
1A55610 	80 55 A5  1 20 40 A0  1 
   process-control-args				( sbuf sphy slen )
1A55618 	AC 51 A5  1 
   2 alloc-control-edtds			( sbuf sphy slen )
1A5561C 	90 6F A0  1 
1A55620 	F4 51 A5  1 

   \ SETUP TD
   0 fill-setup-td				( )
1A55624 	70 6F A0  1 
1A55628 	4C 52 A5  1 

   \ OUT TD
   TD_DIR_OUT fill-control-io-tds drop		( )
1A5562C 	A4 39 A5  1 
1A55630 	40 53 A5  1 30 49 A0  1 

   \ Start control transaction
   insert-my-control				( )
1A55638 	10 54 A5  1 

   \ Process results
   my-ed done? 0=  if  my-td error? drop then
1A5563C 	E8 50 A5  1 
1A55640 	44 47 A5  1 24 47 A0  1 
1A55648 	DC 41 A0  1 10  0  0  0 
1A55650 	D4 50 A5  1 5C 46 A5  1 
1A55658 	30 49 A0  1 

   remove-my-control				( )
1A5565C 	48 54 A5  1 
   usb-error					( usberr )
1A55660 	D0 40 A4  1 
;
1A55664 	58 46 A0  1 

headers

OpenFirmware/dev/usb2/hcd/ohci/control.fth_AL	744 1A55668 h# 100 constant /regs
1A5568C 	 0  0 2F 72 
1A55690 	65 67 73 85  0  0 A0  1 
1A55698 	68 40 A0  1  0  1  0  0 

: my-b@  ( offset -- b )  my-space +  " config-b@" $call-parent  ;
1A556A0 	 0  0 6D 79 2D 62 40 85 
1A556A8 	98 56 A5  1 20 40 A0  1 
1A556B0 	AC  3 A2  1  4 45 A0  1 
1A556B8 	9C 53 A0  1  9 63 6F 6E 
1A556C0 	66 69 67 2D 62 40  0  0 
1A556C8 	DC 31 A2  1 58 46 A0  1 
: my-b!  ( b offset -- )  my-space +  " config-b!" $call-parent  ;
1A556D0 	 0  0 6D 79 2D 62 21 85 
1A556D8 	AC 56 A5  1 20 40 A0  1 
1A556E0 	AC  3 A2  1  4 45 A0  1 
1A556E8 	9C 53 A0  1  9 63 6F 6E 
1A556F0 	66 69 67 2D 62 21  0  0 
1A556F8 	DC 31 A2  1 58 46 A0  1 

: my-w@  ( offset -- w )  my-space +  " config-w@" $call-parent  ;
1A55700 	 0  0 6D 79 2D 77 40 85 
1A55708 	DC 56 A5  1 20 40 A0  1 
1A55710 	AC  3 A2  1  4 45 A0  1 
1A55718 	9C 53 A0  1  9 63 6F 6E 
1A55720 	66 69 67 2D 77 40  0  0 
1A55728 	DC 31 A2  1 58 46 A0  1 
: my-w!  ( w offset -- )  my-space +  " config-w!" $call-parent  ;
1A55730 	 0  0 6D 79 2D 77 21 85 
1A55738 	 C 57 A5  1 20 40 A0  1 
1A55740 	AC  3 A2  1  4 45 A0  1 
1A55748 	9C 53 A0  1  9 63 6F 6E 
1A55750 	66 69 67 2D 77 21  0  0 
1A55758 	DC 31 A2  1 58 46 A0  1 

: my-l@  ( offset -- l )  my-space +  " config-l@" $call-parent  ;
1A55760 	 0  0 6D 79 2D 6C 40 85 
1A55768 	3C 57 A5  1 20 40 A0  1 
1A55770 	AC  3 A2  1  4 45 A0  1 
1A55778 	9C 53 A0  1  9 63 6F 6E 
1A55780 	66 69 67 2D 6C 40  0  0 
1A55788 	DC 31 A2  1 58 46 A0  1 
: my-l!  ( l offset -- )  my-space +  " config-l!" $call-parent  ;
1A55790 	 0  0 6D 79 2D 6C 21 85 
1A55798 	6C 57 A5  1 20 40 A0  1 
1A557A0 	AC  3 A2  1  4 45 A0  1 
1A557A8 	9C 53 A0  1  9 63 6F 6E 
1A557B0 	66 69 67 2D 6C 21  0  0 
1A557B8 	DC 31 A2  1 58 46 A0  1 

: my-map-in  ( len -- adr )
1A557C0 	 0  0 6D 79 2D 6D 61 70 
1A557C8 	2D 69 6E 89 9C 57 A5  1 
1A557D0 	20 40 A0  1 
   >r  0 0 my-space h# 02000010 +  r>  " map-in" $call-parent
1A557D4 	BC 45 A0  1 
1A557D8 	70 6F A0  1 70 6F A0  1 
1A557E0 	AC  3 A2  1 58 41 A0  1 
1A557E8 	10  0  0  2  4 45 A0  1 
1A557F0 	D0 45 A0  1 9C 53 A0  1 
1A557F8 	 6 6D 61 70 2D 69 6E  0 
1A55800 	DC 31 A2  1 
   4 my-w@  h# 16 or  4 my-w!  \ Set MWI, bus mastering, and mem enable
1A55804 	B0 6F A0  1 
1A55808 	 C 57 A5  1 58 41 A0  1 
1A55810 	16  0  0  0 70 44 A0  1 
1A55818 	B0 6F A0  1 3C 57 A5  1 
;
1A55820 	58 46 A0  1 
: my-map-out  ( adr len -- )
1A55824 	 0 6D 79 2D 
1A55828 	6D 61 70 2D 6F 75 74 8A 
1A55830 	D0 57 A5  1 20 40 A0  1 
   \ Don't disable because somebody else might be using the controller.
   \ 4 my-w@  7 invert and  4 my-w!
   " map-out" $call-parent
1A55838 	9C 53 A0  1  7 6D 61 70 
1A55840 	2D 6F 75 74  0  0  0  0 
1A55848 	DC 31 A2  1 
;
1A5584C 	58 46 A0  1 

: has-dbgp-regs?  ( -- false | offset bar true)
1A55850 	 0 68 61 73 2D 64 62 67 
1A55858 	70 2D 72 65 67 73 3F 8E 
1A55860 	34 58 A5  1 20 40 A0  1 
   h# 34 my-l@                   ( capability-ptr )
1A55868 	58 41 A0  1 34  0  0  0 
1A55870 	6C 57 A5  1 
   begin  dup  while             ( cap-offset )
1A55874 	40 49 A0  1 
1A55878 	DC 41 A0  1 78  0  0  0 
      dup my-b@ h# 0a =  if      ( cfg-adr )
1A55880 	40 49 A0  1 AC 56 A5  1 
1A55888 	58 41 A0  1  A  0  0  0 
1A55890 	24 48 A0  1 DC 41 A0  1 
1A55898 	4C  0  0  0 
         2+ my-w@                ( dbgp-ptr )
1A5589C 	40 4B A0  1 
1A558A0 	 C 57 A5  1 
         dup h# 1fff and         ( offset )
1A558A4 	40 49 A0  1 
1A558A8 	58 41 A0  1 FF 1F  0  0 
1A558B0 	5C 44 A0  1 
         d# 13 rshift  7 and  1- /l* h# 10 +  ( offset bar )
1A558B4 	58 41 A0  1 
1A558B8 	 D  0  0  0 B4 44 A0  1 
1A558C0 	E0 6F A0  1 5C 44 A0  1 
1A558C8 	54 4B A0  1 84 51 A0  1 
1A558D0 	58 41 A0  1 10  0  0  0 
1A558D8 	 4 45 A0  1 
         true                    ( offset bar true )
1A558DC 	 4 70 A0  1 
         exit
1A558E0 	40 46 A0  1 
      then                       ( cfg-adr )
      1+ my-b@                   ( cap-offset' )
1A558E4 	30 4B A0  1 
1A558E8 	AC 56 A5  1 
   repeat                        ( cap-offset )
1A558EC 	C8 41 A0  1 
1A558F0 	84 FF FF FF 
   drop  false                   ( false )
1A558F4 	30 49 A0  1 
1A558F8 	18 70 A0  1 
;
1A558FC 	58 46 A0  1 
: needs-dummy-qh?  ( -- flag )  0 my-w@ h# 1106 ( VIA ) =  ;
1A55900 	6E 65 65 64 73 2D 64 75 
1A55908 	6D 6D 79 2D 71 68 3F 8F 
1A55910 	64 58 A5  1 20 40 A0  1 
1A55918 	70 6F A0  1  C 57 A5  1 
1A55920 	58 41 A0  1  6 11  0  0 
1A55928 	24 48 A0  1 58 46 A0  1 
: grab-controller  ( config-adr -- error? )
1A55930 	67 72 61 62 2D 63 6F 6E 
1A55938 	74 72 6F 6C 6C 65 72 8F 
1A55940 	14 59 A5  1 20 40 A0  1 
   dup my-l@  h# 10001 =  if              ( config-adr )
1A55948 	40 49 A0  1 6C 57 A5  1 
1A55950 	58 41 A0  1  1  0  1  0 
1A55958 	24 48 A0  1 DC 41 A0  1 
1A55960 	BC  0  0  0 
      h# 1000000 over my-l!              ( config-adr )  \ Ask for it
1A55964 	58 41 A0  1 
1A55968 	 0  0  0  1 54 49 A0  1 
1A55970 	9C 57 A5  1 
      true                                ( config-adr error? )
1A55974 	 4 70 A0  1 
      d# 100 0  do                        ( config-adr error? )
1A55978 	58 41 A0  1 64  0  0  0 
1A55980 	70 6F A0  1 88 42 A0  1 
1A55988 	8C  0  0  0 
         over my-l@ h# 1010000 and  h# 1000000 =  if
1A5598C 	54 49 A0  1 
1A55990 	6C 57 A5  1 58 41 A0  1 
1A55998 	 0  0  1  1 5C 44 A0  1 
1A559A0 	58 41 A0  1  0  0  0  1 
1A559A8 	24 48 A0  1 DC 41 A0  1 
1A559B0 	50  0  0  0 
            \ Turn off SMIs in Legacy Support Extended CSR
            h# e0000000 h# 6c my-l!      ( config-adr error? )
1A559B4 	58 41 A0  1 
1A559B8 	 0  0  0 E0 58 41 A0  1 
1A559C0 	6C  0  0  0 9C 57 A5  1 
            0 my-l@ h# 27cc8086 =  if
1A559C8 	70 6F A0  1 6C 57 A5  1 
1A559D0 	58 41 A0  1 86 80 CC 27 
1A559D8 	24 48 A0  1 DC 41 A0  1 
1A559E0 	18  0  0  0 
               h# ffff0000  h# 70  my-l!  \ Clear EHCI Intel special SMIs
1A559E4 	58 41 A0  1 
1A559E8 	 0  0 FF FF 58 41 A0  1 
1A559F0 	70  0  0  0 9C 57 A5  1 
            then
            0= leave                      ( config-adr error?' )
1A559F8 	24 47 A0  1 18 43 A0  1 
         then                             ( config-adr error? )
         d# 10 ms                         ( config-adr error? )
1A55A00 	58 41 A0  1  A  0  0  0 
1A55A08 	60 E0 A1  1 
      loop                                ( config-adr error? )
1A55A0C 	F8 41 A0  1 
1A55A10 	7C FF FF FF 
      nip exit
1A55A14 	FC 46 A0  1 
1A55A18 	40 46 A0  1 
   then                                   ( config-adr )
   drop false                             ( false )
1A55A1C 	30 49 A0  1 
1A55A20 	18 70 A0  1 
;
1A55A24 	58 46 A0  1 

OpenFirmware/dev/usb2/hcd/ehci/pci.fth_AL	39C 1A55A28 1A55B2C 1A55B50 purpose: Driver for EHCI USB Controller

" ehci" encode-string " device_type" property
1A55B14 	65 68 63 69 
1A55B18 	 0  0  0  0 64 65 76 69 
1A55B20 	63 65 5F 74 79 70 65 8B 
1A55B28 	F0 50 A2  1 BC 13 A2  1 
1A55B30 	1C  0  0  0  5  0  0  0 

" usb-ehci" " compatible" string-property
1A55B38 	75 73 62 2D 65 68 63 69 
1A55B40 	 0 63 6F 6D 70 61 74 69 
1A55B48 	62 6C 65 8A 2C 5B A5  1 
1A55B50 	BC 13 A2  1 1C  0  0  0 
1A55B58 	 9  0  0  0 

hex
headers

defer init-extra	' noop to init-extra
1A55B5C 	 0 69 6E 69 
1A55B60 	74 2D 65 78 74 72 61 8A 
1A55B68 	38 5A A5  1 5C 40 A0  1 
1A55B70 	EC  E  0  0 
defer end-extra		' noop to end-extra
1A55B74 	 0  0 65 6E 
1A55B78 	64 2D 65 78 74 72 61 89 
1A55B80 	6C 5B A5  1 5C 40 A0  1 
1A55B88 	F0  E  0  0 

true value first-open?
1A55B8C 	66 69 72 73 
1A55B90 	74 2D 6F 70 65 6E 3F 8B 
1A55B98 	84 5B A5  1 50 40 A0  1 
1A55BA0 	F4  E  0  0 
0 value open-count
1A55BA4 	 0 6F 70 65 
1A55BA8 	6E 2D 63 6F 75 6E 74 8A 
1A55BB0 	9C 5B A5  1 50 40 A0  1 
1A55BB8 	F8  E  0  0 
0 value ehci-reg
1A55BBC 	 0  0  0 65 
1A55BC0 	68 63 69 2D 72 65 67 88 
1A55BC8 	B4 5B A5  1 50 40 A0  1 
1A55BD0 	FC  E  0  0 
0 value op-reg-offset
1A55BD4 	 0  0 6F 70 
1A55BD8 	2D 72 65 67 2D 6F 66 66 
1A55BE0 	73 65 74 8D CC 5B A5  1 
1A55BE8 	50 40 A0  1  0  F  0  0 

: map-regs  ( -- )
1A55BF0 	 0  0  0 6D 61 70 2D 72 
1A55BF8 	65 67 73 88 E8 5B A5  1 
1A55C00 	20 40 A0  1 
   /regs my-map-in to ehci-reg
1A55C04 	98 56 A5  1 
1A55C08 	D0 57 A5  1 B8 40 A0  1 
1A55C10 	CC 5B A5  1 
;
1A55C14 	58 46 A0  1 
: unmap-regs  ( -- )
1A55C18 	 0 75 6E 6D 61 70 2D 72 
1A55C20 	65 67 73 8A  0 5C A5  1 
1A55C28 	20 40 A0  1 
   ehci-reg  /regs  my-map-out  0 to ehci-reg
1A55C2C 	CC 5B A5  1 
1A55C30 	98 56 A5  1 34 58 A5  1 
1A55C38 	70 6F A0  1 B8 40 A0  1 
1A55C40 	CC 5B A5  1 
;
1A55C44 	58 46 A0  1 

: ehci-reg@  ( idx -- data )  ehci-reg + rl@  ;
1A55C48 	 0  0 65 68 63 69 2D 72 
1A55C50 	65 67 40 89 28 5C A5  1 
1A55C58 	20 40 A0  1 CC 5B A5  1 
1A55C60 	 4 45 A0  1 F8 B1 A2  1 
1A55C68 	58 46 A0  1 
: ehci-reg!  ( data idx -- )  ehci-reg + rl!  ;
1A55C6C 	 0  0 65 68 
1A55C70 	63 69 2D 72 65 67 21 89 
1A55C78 	58 5C A5  1 20 40 A0  1 
1A55C80 	CC 5B A5  1  4 45 A0  1 
1A55C88 	68 B2 A2  1 58 46 A0  1 

: ll ( idx -- )  dup h# f and 0=  if  cr 2 u.r ."   "  else  drop  then  ;
1A55C90 	 0 6C 6C 82 7C 5C A5  1 
1A55C98 	20 40 A0  1 40 49 A0  1 
1A55CA0 	58 41 A0  1  F  0  0  0 
1A55CA8 	5C 44 A0  1 24 47 A0  1 
1A55CB0 	DC 41 A0  1 20  0  0  0 
1A55CB8 	80 6D A0  1 90 6F A0  1 
1A55CC0 	E4 77 A0  1 20 7C A0  1 
1A55CC8 	 2 20 20  0 C8 41 A0  1 
1A55CD0 	 8  0  0  0 30 49 A0  1 
1A55CD8 	58 46 A0  1 
: dump-ehci  ( -- )  100 0 do  i ll i ehci-reg@ 8 u.r space 4  +loop  ;
1A55CDC 	 0  0 64 75 
1A55CE0 	6D 70 2D 65 68 63 69 89 
1A55CE8 	98 5C A5  1 20 40 A0  1 
1A55CF0 	58 41 A0  1  0  1  0  0 
1A55CF8 	70 6F A0  1 88 42 A0  1 
1A55D00 	2C  0  0  0 B4 42 A0  1 
1A55D08 	98 5C A5  1 B4 42 A0  1 
1A55D10 	58 5C A5  1 F0 6F A0  1 
1A55D18 	E4 77 A0  1 CC 71 A0  1 
1A55D20 	B0 6F A0  1 1C 42 A0  1 
1A55D28 	DC FF FF FF 58 46 A0  1 

\ Host controller capability registers
: hcsparams@  ( -- data )  4 ehci-reg@  ;
1A55D30 	 0 68 63 73 70 61 72 61 
1A55D38 	6D 73 40 8A EC 5C A5  1 
1A55D40 	20 40 A0  1 B0 6F A0  1 
1A55D48 	58 5C A5  1 58 46 A0  1 
: hccparams@  ( -- data )  8 ehci-reg@  ;
1A55D50 	 0 68 63 63 70 61 72 61 
1A55D58 	6D 73 40 8A 40 5D A5  1 
1A55D60 	20 40 A0  1 F0 6F A0  1 
1A55D68 	58 5C A5  1 58 46 A0  1 
: (hcsp-portroute@)  ( -- d.lo,hi )  h# c ehci-reg@  h# 10 ehci-reg@  ;
1A55D70 	 0  0 28 68 63 73 70 2D 
1A55D78 	70 6F 72 74 72 6F 75 74 
1A55D80 	65 40 29 91 60 5D A5  1 
1A55D88 	20 40 A0  1 58 41 A0  1 
1A55D90 	 C  0  0  0 58 5C A5  1 
1A55D98 	58 41 A0  1 10  0  0  0 
1A55DA0 	58 5C A5  1 58 46 A0  1 
: hcsp-portroute@  ( port -- data )
1A55DA8 	68 63 73 70 2D 70 6F 72 
1A55DB0 	74 72 6F 75 74 65 40 8F 
1A55DB8 	88 5D A5  1 20 40 A0  1 
   (hcsp-portroute@) rot
1A55DC0 	88 5D A5  1 7C 49 A0  1 
   dup >r 7 >  if  8 - nip  else  drop  then r>
1A55DC8 	40 49 A0  1 BC 45 A0  1 
1A55DD0 	E0 6F A0  1  4 48 A0  1 
1A55DD8 	DC 41 A0  1 18  0  0  0 
1A55DE0 	F0 6F A0  1 18 45 A0  1 
1A55DE8 	FC 46 A0  1 C8 41 A0  1 
1A55DF0 	 8  0  0  0 30 49 A0  1 
1A55DF8 	D0 45 A0  1 
   4 * >> h# f and
1A55DFC 	B0 6F A0  1 
1A55E00 	1C 5F A0  1 DC 44 A0  1 
1A55E08 	58 41 A0  1  F  0  0  0 
1A55E10 	5C 44 A0  1 
;
1A55E14 	58 46 A0  1 

\ Host Controller operational registers
: op-reg@    ( idx -- data )  op-reg-offset + ehci-reg@  ;
1A55E18 	6F 70 2D 72 65 67 40 87 
1A55E20 	BC 5D A5  1 20 40 A0  1 
1A55E28 	E8 5B A5  1  4 45 A0  1 
1A55E30 	58 5C A5  1 58 46 A0  1 
: op-reg!    ( data idx -- )  op-reg-offset + ehci-reg!  ;
1A55E38 	6F 70 2D 72 65 67 21 87 
1A55E40 	24 5E A5  1 20 40 A0  1 
1A55E48 	E8 5B A5  1  4 45 A0  1 
1A55E50 	7C 5C A5  1 58 46 A0  1 

: usbcmd@    ( -- data )  0 op-reg@  ;
1A55E58 	75 73 62 63 6D 64 40 87 
1A55E60 	44 5E A5  1 20 40 A0  1 
1A55E68 	70 6F A0  1 24 5E A5  1 
1A55E70 	58 46 A0  1 
: usbcmd!    ( data -- )  0 op-reg!  ;
1A55E74 	75 73 62 63 
1A55E78 	6D 64 21 87 64 5E A5  1 
1A55E80 	20 40 A0  1 70 6F A0  1 
1A55E88 	44 5E A5  1 58 46 A0  1 
: flush-reg  ( -- )       usbcmd@ drop  ;
1A55E90 	 0  0 66 6C 75 73 68 2D 
1A55E98 	72 65 67 89 80 5E A5  1 
1A55EA0 	20 40 A0  1 64 5E A5  1 
1A55EA8 	30 49 A0  1 58 46 A0  1 
: usbsts@    ( -- data )  4 op-reg@  ;
1A55EB0 	75 73 62 73 74 73 40 87 
1A55EB8 	A0 5E A5  1 20 40 A0  1 
1A55EC0 	B0 6F A0  1 24 5E A5  1 
1A55EC8 	58 46 A0  1 
: usbsts!    ( data -- )  4 op-reg! flush-reg  ;
1A55ECC 	75 73 62 73 
1A55ED0 	74 73 21 87 BC 5E A5  1 
1A55ED8 	20 40 A0  1 B0 6F A0  1 
1A55EE0 	44 5E A5  1 A0 5E A5  1 
1A55EE8 	58 46 A0  1 
: usbintr@   ( -- data )  8 op-reg@  ;
1A55EEC 	 0  0  0 75 
1A55EF0 	73 62 69 6E 74 72 40 88 
1A55EF8 	D8 5E A5  1 20 40 A0  1 
1A55F00 	F0 6F A0  1 24 5E A5  1 
1A55F08 	58 46 A0  1 
: usbintr!   ( data -- )  8 op-reg!  ;
1A55F0C 	 0  0  0 75 
1A55F10 	73 62 69 6E 74 72 21 88 
1A55F18 	FC 5E A5  1 20 40 A0  1 
1A55F20 	F0 6F A0  1 44 5E A5  1 
1A55F28 	58 46 A0  1 
: frindex@   ( -- data )  h# c op-reg@  ;
1A55F2C 	 0  0  0 66 
1A55F30 	72 69 6E 64 65 78 40 88 
1A55F38 	1C 5F A5  1 20 40 A0  1 
1A55F40 	58 41 A0  1  C  0  0  0 
1A55F48 	24 5E A5  1 58 46 A0  1 
: frindex!   ( data -- )  h# c op-reg!  ;
1A55F50 	 0  0  0 66 72 69 6E 64 
1A55F58 	65 78 21 88 3C 5F A5  1 
1A55F60 	20 40 A0  1 58 41 A0  1 
1A55F68 	 C  0  0  0 44 5E A5  1 
1A55F70 	58 46 A0  1 
: ctrldsseg@ ( -- data )  h# 10 op-reg@  ;
1A55F74 	 0 63 74 72 
1A55F78 	6C 64 73 73 65 67 40 8A 
1A55F80 	60 5F A5  1 20 40 A0  1 
1A55F88 	58 41 A0  1 10  0  0  0 
1A55F90 	24 5E A5  1 58 46 A0  1 
: ctrldsseg! ( data -- )  h# 10 op-reg!  ;
1A55F98 	 0 63 74 72 6C 64 73 73 
1A55FA0 	65 67 21 8A 84 5F A5  1 
1A55FA8 	20 40 A0  1 58 41 A0  1 
1A55FB0 	10  0  0  0 44 5E A5  1 
1A55FB8 	58 46 A0  1 
: periodic@  ( -- data )  h# 14 op-reg@  ;
1A55FBC 	 0  0 70 65 
1A55FC0 	72 69 6F 64 69 63 40 89 
1A55FC8 	A8 5F A5  1 20 40 A0  1 
1A55FD0 	58 41 A0  1 14  0  0  0 
1A55FD8 	24 5E A5  1 58 46 A0  1 
: periodic!  ( data -- )  h# 14 op-reg!  ;
1A55FE0 	 0  0 70 65 72 69 6F 64 
1A55FE8 	69 63 21 89 CC 5F A5  1 
1A55FF0 	20 40 A0  1 58 41 A0  1 
1A55FF8 	14  0  0  0 44 5E A5  1 
1A56000 	58 46 A0  1 
: asynclist@ ( -- data )  h# 18 op-reg@  ;
1A56004 	 0 61 73 79 
1A56008 	6E 63 6C 69 73 74 40 8A 
1A56010 	F0 5F A5  1 20 40 A0  1 
1A56018 	58 41 A0  1 18  0  0  0 
1A56020 	24 5E A5  1 58 46 A0  1 
: asynclist! ( data -- )  h# 18 op-reg!  ;
1A56028 	 0 61 73 79 6E 63 6C 69 
1A56030 	73 74 21 8A 14 60 A5  1 
1A56038 	20 40 A0  1 58 41 A0  1 
1A56040 	18  0  0  0 44 5E A5  1 
1A56048 	58 46 A0  1 

: cfgflag@   ( -- data )  h# 40 op-reg@  ;
1A5604C 	 0  0  0 63 
1A56050 	66 67 66 6C 61 67 40 88 
1A56058 	38 60 A5  1 20 40 A0  1 
1A56060 	58 41 A0  1 40  0  0  0 
1A56068 	24 5E A5  1 58 46 A0  1 
: cfgflag!   ( data -- )  h# 40 op-reg! flush-reg  ;
1A56070 	 0  0  0 63 66 67 66 6C 
1A56078 	61 67 21 88 5C 60 A5  1 
1A56080 	20 40 A0  1 58 41 A0  1 
1A56088 	40  0  0  0 44 5E A5  1 
1A56090 	A0 5E A5  1 58 46 A0  1 
: portsc@    ( port -- data )  4 * h# 44 + op-reg@  ;
1A56098 	70 6F 72 74 73 63 40 87 
1A560A0 	80 60 A5  1 20 40 A0  1 
1A560A8 	B0 6F A0  1 1C 5F A0  1 
1A560B0 	58 41 A0  1 44  0  0  0 
1A560B8 	 4 45 A0  1 24 5E A5  1 
1A560C0 	58 46 A0  1 
: portsc!    ( data port -- )  4 * h# 44 + op-reg!  flush-reg  ;
1A560C4 	70 6F 72 74 
1A560C8 	73 63 21 87 A4 60 A5  1 
1A560D0 	20 40 A0  1 B0 6F A0  1 
1A560D8 	1C 5F A0  1 58 41 A0  1 
1A560E0 	44  0  0  0  4 45 A0  1 
1A560E8 	44 5E A5  1 A0 5E A5  1 
1A560F0 	58 46 A0  1 

: halted?    ( -- flag )  usbsts@ h# 1000 and  ;
1A560F4 	68 61 6C 74 
1A560F8 	65 64 3F 87 D0 60 A5  1 
1A56100 	20 40 A0  1 BC 5E A5  1 
1A56108 	58 41 A0  1  0 10  0  0 
1A56110 	5C 44 A0  1 58 46 A0  1 
: halt-wait  ( -- )       begin  halted?  until  ;
1A56118 	 0  0 68 61 6C 74 2D 77 
1A56120 	61 69 74 89  0 61 A5  1 
1A56128 	20 40 A0  1  0 61 A5  1 
1A56130 	DC 41 A0  1 F8 FF FF FF 
1A56138 	58 46 A0  1 

: process-hc-status  ( -- )
1A5613C 	 0  0 70 72 
1A56140 	6F 63 65 73 73 2D 68 63 
1A56148 	2D 73 74 61 74 75 73 91 
1A56150 	28 61 A5  1 20 40 A0  1 
   usbsts@ dup usbsts!		\ Clear interrupts and errors
1A56158 	BC 5E A5  1 40 49 A0  1 
1A56160 	D8 5E A5  1 
   h# 10  and  if  " Host system error" USB_ERR_HCHALTED set-usb-error  then
1A56164 	58 41 A0  1 
1A56168 	10  0  0  0 5C 44 A0  1 
1A56170 	DC 41 A0  1 24  0  0  0 
1A56178 	9C 53 A0  1 11 48 6F 73 
1A56180 	74 20 73 79 73 74 65 6D 
1A56188 	20 65 72 72 6F 72  0  0 
1A56190 	D4 2D A4  1 14 41 A4  1 
;
1A56198 	58 46 A0  1 
: hc-interrupt?  ( -- interrupt? )
1A5619C 	 0  0 68 63 
1A561A0 	2D 69 6E 74 65 72 72 75 
1A561A8 	70 74 3F 8D 54 61 A5  1 
1A561B0 	20 40 A0  1 
   usbsts@ h# 13 and  dup  if   ( status )
1A561B4 	BC 5E A5  1 
1A561B8 	58 41 A0  1 13  0  0  0 
1A561C0 	5C 44 A0  1 40 49 A0  1 
1A561C8 	DC 41 A0  1 4C  0  0  0 
      dup usbsts!               ( status )  \ Clear interrupts, frame rollover, errors
1A561D0 	40 49 A0  1 D8 5E A5  1 
      dup h# 10  and  if        ( status )
1A561D8 	40 49 A0  1 58 41 A0  1 
1A561E0 	10  0  0  0 5C 44 A0  1 
1A561E8 	DC 41 A0  1 2C  0  0  0 
         " USB host controller halted" USB_ERR_HCHALTED set-usb-error
1A561F0 	9C 53 A0  1 1A 55 53 42 
1A561F8 	20 68 6F 73 74 20 63 6F 
1A56200 	6E 74 72 6F 6C 6C 65 72 
1A56208 	20 68 61 6C 74 65 64  0 
1A56210 	D4 2D A4  1 14 41 A4  1 
      then                      ( status )
   then                         ( status )
   0<>                          ( interrupt? )
1A56218 	44 47 A0  1 
;
1A5621C 	58 46 A0  1 

: get-hc-status  ( -- status )
1A56220 	 0  0 67 65 74 2D 68 63 
1A56228 	2D 73 74 61 74 75 73 8D 
1A56230 	B0 61 A5  1 20 40 A0  1 
   usbsts@ dup usbsts!		\ Clear interrupts and errors
1A56238 	BC 5E A5  1 40 49 A0  1 
1A56240 	D8 5E A5  1 
   dup h# 10  and  if  " Host system error" USB_ERR_HCHALTED set-usb-error  then
1A56244 	40 49 A0  1 
1A56248 	58 41 A0  1 10  0  0  0 
1A56250 	5C 44 A0  1 DC 41 A0  1 
1A56258 	24  0  0  0 9C 53 A0  1 
1A56260 	11 48 6F 73 74 20 73 79 
1A56268 	73 74 65 6D 20 65 72 72 
1A56270 	6F 72  0  0 D4 2D A4  1 
1A56278 	14 41 A4  1 
;
1A5627C 	58 46 A0  1 

: doorbell-wait  ( -- )
1A56280 	 0  0 64 6F 6F 72 62 65 
1A56288 	6C 6C 2D 77 61 69 74 8D 
1A56290 	34 62 A5  1 20 40 A0  1 
   \ Wait until interrupt on async advance bit is set.
   \ But, some HCs fail to set the async advance bit sometimes.  Therefore,
   \ we add a timeout and clear the status all the same.
   h# 100 0  do  usbsts@ h# 20 and  if  leave  then  loop
1A56298 	58 41 A0  1  0  1  0  0 
1A562A0 	70 6F A0  1 88 42 A0  1 
1A562A8 	28  0  0  0 BC 5E A5  1 
1A562B0 	58 41 A0  1 20  0  0  0 
1A562B8 	5C 44 A0  1 DC 41 A0  1 
1A562C0 	 8  0  0  0 18 43 A0  1 
1A562C8 	F8 41 A0  1 E0 FF FF FF 
   h# 20 usbsts!			\ Clear status
1A562D0 	58 41 A0  1 20  0  0  0 
1A562D8 	D8 5E A5  1 
;
1A562DC 	58 46 A0  1 
: ring-doorbell  ( -- )
1A562E0 	 0  0 72 69 6E 67 2D 64 
1A562E8 	6F 6F 72 62 65 6C 6C 8D 
1A562F0 	94 62 A5  1 20 40 A0  1 
   usbcmd@ h# 40 or usbcmd!		\ Interrupt on async advance doorbell
1A562F8 	64 5E A5  1 58 41 A0  1 
1A56300 	40  0  0  0 70 44 A0  1 
1A56308 	80 5E A5  1 
   usbcmd@ drop
1A5630C 	64 5E A5  1 
1A56310 	30 49 A0  1 
   doorbell-wait
1A56314 	94 62 A5  1 
;
1A56318 	58 46 A0  1 

0 value dbgp-offset
1A5631C 	64 62 67 70 
1A56320 	2D 6F 66 66 73 65 74 8B 
1A56328 	F4 62 A5  1 50 40 A0  1 
1A56330 	 4  F  0  0 
0 value dbgp-bar
1A56334 	 0  0  0 64 
1A56338 	62 67 70 2D 62 61 72 88 
1A56340 	2C 63 A5  1 50 40 A0  1 
1A56348 	 8  F  0  0 

: debug-port-active?  ( -- flag )
1A5634C 	 0 64 65 62 
1A56350 	75 67 2D 70 6F 72 74 2D 
1A56358 	61 63 74 69 76 65 3F 92 
1A56360 	44 63 A5  1 20 40 A0  1 
   hcsparams@  h# f00000 and  0=  if  false exit  then
1A56368 	40 5D A5  1 58 41 A0  1 
1A56370 	 0  0 F0  0 5C 44 A0  1 
1A56378 	24 47 A0  1 DC 41 A0  1 
1A56380 	 C  0  0  0 18 70 A0  1 
1A56388 	40 46 A0  1 
   has-dbgp-regs?  if   ( offset bar )
1A5638C 	64 58 A5  1 
1A56390 	DC 41 A0  1 1C  0  0  0 
      to dbgp-bar  to dbgp-offset
1A56398 	B8 40 A0  1 44 63 A5  1 
1A563A0 	B8 40 A0  1 2C 63 A5  1 
   else                 ( )
1A563A8 	C8 41 A0  1  C  0  0  0 
      false exit
1A563B0 	18 70 A0  1 40 46 A0  1 
   then

   \ We should take dbgp-bar into account, but for now we
   \ just assume it's the same BAR as for the main registers.
   dbgp-offset ehci-reg@
1A563B8 	2C 63 A5  1 58 5C A5  1 
   h# 10000000 and 0<>
1A563C0 	58 41 A0  1  0  0  0 10 
1A563C8 	5C 44 A0  1 44 47 A0  1 
;
1A563D0 	58 46 A0  1 

external

: start-usb  ( -- )
1A563D4 	 0  0 73 74 
1A563D8 	61 72 74 2D 75 73 62 89 
1A563E0 	64 63 A5  1 20 40 A0  1 
   ehci-reg dup 0=  if  map-regs  then
1A563E8 	CC 5B A5  1 40 49 A0  1 
1A563F0 	24 47 A0  1 DC 41 A0  1 
1A563F8 	 8  0  0  0  0 5C A5  1 
   halted?  if  usbcmd@ 1 or usbcmd!  then
1A56400 	 0 61 A5  1 DC 41 A0  1 
1A56408 	14  0  0  0 64 5E A5  1 
1A56410 	80 6F A0  1 70 44 A0  1 
1A56418 	80 5E A5  1 
   0=  if  unmap-regs  then
1A5641C 	24 47 A0  1 
1A56420 	DC 41 A0  1  8  0  0  0 
1A56428 	28 5C A5  1 
;
1A5642C 	58 46 A0  1 

: stop-usb   ( -- )
1A56430 	 0  0  0 73 74 6F 70 2D 
1A56438 	75 73 62 88 E4 63 A5  1 
1A56440 	20 40 A0  1 
   ehci-reg dup 0=  if  map-regs  then
1A56444 	CC 5B A5  1 
1A56448 	40 49 A0  1 24 47 A0  1 
1A56450 	DC 41 A0  1  8  0  0  0 
1A56458 	 0 5C A5  1 
   usbcmd@ 31 invert and usbcmd!
1A5645C 	64 5E A5  1 
1A56460 	58 41 A0  1 31  0  0  0 
1A56468 	30 45 A0  1 5C 44 A0  1 
1A56470 	80 5E A5  1 
   halt-wait
1A56474 	28 61 A5  1 
   0=  if  unmap-regs  then
1A56478 	24 47 A0  1 DC 41 A0  1 
1A56480 	 8  0  0  0 28 5C A5  1 
;
1A56488 	58 46 A0  1 

: reset-usb  ( -- )
1A5648C 	 0  0 72 65 
1A56490 	73 65 74 2D 75 73 62 89 
1A56498 	40 64 A5  1 20 40 A0  1 
   ehci-reg dup 0=  if  map-regs  then  ( reg )
1A564A0 	CC 5B A5  1 40 49 A0  1 
1A564A8 	24 47 A0  1 DC 41 A0  1 
1A564B0 	 8  0  0  0  0 5C A5  1 
   debug-port-active?  if  drop exit  then   \ Don't kill the debug port!
1A564B8 	64 63 A5  1 DC 41 A0  1 
1A564C0 	 C  0  0  0 30 49 A0  1 
1A564C8 	40 46 A0  1 
   usbcmd@ 2 or 1 invert and usbcmd!	\ HCReset
1A564CC 	64 5E A5  1 
1A564D0 	90 6F A0  1 70 44 A0  1 
1A564D8 	80 6F A0  1 30 45 A0  1 
1A564E0 	5C 44 A0  1 80 5E A5  1 
   d# 10 0  do
1A564E8 	58 41 A0  1  A  0  0  0 
1A564F0 	70 6F A0  1 88 42 A0  1 
1A564F8 	28  0  0  0 
      usbcmd@ 2 and  0=  ?leave
1A564FC 	64 5E A5  1 
1A56500 	90 6F A0  1 5C 44 A0  1 
1A56508 	24 47 A0  1 34 43 A0  1 
      1 ms
1A56510 	80 6F A0  1 60 E0 A1  1 
   loop
1A56518 	F8 41 A0  1 E0 FF FF FF 
   0=  if  unmap-regs  then
1A56520 	24 47 A0  1 DC 41 A0  1 
1A56528 	 8  0  0  0 28 5C A5  1 
;
1A56530 	58 46 A0  1 

: test-port-begin  ( port -- )
1A56534 	74 65 73 74 
1A56538 	2D 70 6F 72 74 2D 62 65 
1A56540 	67 69 6E 8F 9C 64 A5  1 
1A56548 	20 40 A0  1 
   ehci-reg dup 0=  if  map-regs  then
1A5654C 	CC 5B A5  1 
1A56550 	40 49 A0  1 24 47 A0  1 
1A56558 	DC 41 A0  1  8  0  0  0 
1A56560 	 0 5C A5  1 
   swap dup portsc@ h# 40000 or swap portsc!
1A56564 	68 49 A0  1 
1A56568 	40 49 A0  1 A4 60 A5  1 
1A56570 	58 41 A0  1  0  0  4  0 
1A56578 	70 44 A0  1 68 49 A0  1 
1A56580 	D0 60 A5  1 
   0=  if  unmap-regs  then
1A56584 	24 47 A0  1 
1A56588 	DC 41 A0  1  8  0  0  0 
1A56590 	28 5C A5  1 
;
1A56594 	58 46 A0  1 

: test-port-end  ( port -- )
1A56598 	 0  0 74 65 73 74 2D 70 
1A565A0 	6F 72 74 2D 65 6E 64 8D 
1A565A8 	48 65 A5  1 20 40 A0  1 
   ehci-reg dup 0=  if  map-regs  then
1A565B0 	CC 5B A5  1 40 49 A0  1 
1A565B8 	24 47 A0  1 DC 41 A0  1 
1A565C0 	 8  0  0  0  0 5C A5  1 
   swap dup portsc@ h# 70000 invert and swap portsc!
1A565C8 	68 49 A0  1 40 49 A0  1 
1A565D0 	A4 60 A5  1 58 41 A0  1 
1A565D8 	 0  0  7  0 30 45 A0  1 
1A565E0 	5C 44 A0  1 68 49 A0  1 
1A565E8 	D0 60 A5  1 
   0=  if  unmap-regs  then
1A565EC 	24 47 A0  1 
1A565F0 	DC 41 A0  1  8  0  0  0 
1A565F8 	28 5C A5  1 
;
1A565FC 	58 46 A0  1 

headers

: init-ehci-regs  ( -- )
1A56600 	 0 69 6E 69 74 2D 65 68 
1A56608 	63 69 2D 72 65 67 73 8E 
1A56610 	AC 65 A5  1 20 40 A0  1 
   0 ctrldsseg!
1A56618 	70 6F A0  1 A8 5F A5  1 
   0 periodic!
1A56620 	70 6F A0  1 F0 5F A5  1 
   0 asynclist!
1A56628 	70 6F A0  1 38 60 A5  1 
   0 usbintr!
1A56630 	70 6F A0  1 1C 5F A5  1 
;
1A56638 	58 46 A0  1 

: reset-port  ( port -- )
1A5663C 	 0 72 65 73 
1A56640 	65 74 2D 70 6F 72 74 8A 
1A56648 	14 66 A5  1 20 40 A0  1 
   dup portsc@ h# 100 or 4 invert and over portsc!	\ Reset port
1A56650 	40 49 A0  1 A4 60 A5  1 
1A56658 	58 41 A0  1  0  1  0  0 
1A56660 	70 44 A0  1 B0 6F A0  1 
1A56668 	30 45 A0  1 5C 44 A0  1 
1A56670 	54 49 A0  1 D0 60 A5  1 
   d# 50 ms
1A56678 	58 41 A0  1 32  0  0  0 
1A56680 	60 E0 A1  1 
   dup portsc@ h# 100 invert and swap portsc!
1A56684 	40 49 A0  1 
1A56688 	A4 60 A5  1 58 41 A0  1 
1A56690 	 0  1  0  0 30 45 A0  1 
1A56698 	5C 44 A0  1 68 49 A0  1 
1A566A0 	D0 60 A5  1 
   d# 10 ms
1A566A4 	58 41 A0  1 
1A566A8 	 A  0  0  0 60 E0 A1  1 
;
1A566B0 	58 46 A0  1 

: power-port   ( port -- )  dup portsc@ h# 1000 or swap portsc!  2 ms  ;
1A566B4 	 0 70 6F 77 
1A566B8 	65 72 2D 70 6F 72 74 8A 
1A566C0 	4C 66 A5  1 20 40 A0  1 
1A566C8 	40 49 A0  1 A4 60 A5  1 
1A566D0 	58 41 A0  1  0 10  0  0 
1A566D8 	70 44 A0  1 68 49 A0  1 
1A566E0 	D0 60 A5  1 90 6F A0  1 
1A566E8 	60 E0 A1  1 58 46 A0  1 

: disown-port  ( port -- )  dup portsc@ h# 2000 or swap portsc!  ;
1A566F0 	64 69 73 6F 77 6E 2D 70 
1A566F8 	6F 72 74 8B C4 66 A5  1 
1A56700 	20 40 A0  1 40 49 A0  1 
1A56708 	A4 60 A5  1 58 41 A0  1 
1A56710 	 0 20  0  0 70 44 A0  1 
1A56718 	68 49 A0  1 D0 60 A5  1 
1A56720 	58 46 A0  1 

: #ports  ( -- n )  hcsparams@ h# f and  ;
1A56724 	 0 23 70 6F 
1A56728 	72 74 73 86  0 67 A5  1 
1A56730 	20 40 A0  1 40 5D A5  1 
1A56738 	58 41 A0  1  F  0  0  0 
1A56740 	5C 44 A0  1 58 46 A0  1 

: claim-ownership  ( -- )
1A56748 	63 6C 61 69 6D 2D 6F 77 
1A56750 	6E 65 72 73 68 69 70 8F 
1A56758 	30 67 A5  1 20 40 A0  1 
   1 cfgflag!				\ Claim ownership to all ports
1A56760 	80 6F A0  1 80 60 A5  1 
   3 ms					\ Give devices time to settle
1A56768 	A0 6F A0  1 60 E0 A1  1 

   \ Power on ports if necessary
   hcsparams@ h# 10 and  if
1A56770 	40 5D A5  1 58 41 A0  1 
1A56778 	10  0  0  0 5C 44 A0  1 
1A56780 	DC 41 A0  1 24  0  0  0 
      #ports 0  ?do
1A56788 	30 67 A5  1 70 6F A0  1 
1A56790 	50 42 A0  1 14  0  0  0 
         i power-port
1A56798 	B4 42 A0  1 C4 66 A5  1 
      loop
1A567A0 	F8 41 A0  1 F4 FF FF FF 
   then
;
1A567A8 	58 46 A0  1 

OpenFirmware/dev/usb2/hcd/ehci/ehci.fth_AL	C98 1A567AC purpose: Data structures and manuipulation routines for EHCI USB Controller

hex
headers

\ XXX Isochronous is not supported in the current version of the EHCI driver

\ ---------------------------------------------------------------------------
\ Data structures for this implementation of the EHCI USB Driver include:
\   - qh-ptr	pointer to the asynchronous list of QHs
\   - framelist	pointer to the Periodic Frame List
\   - intr      internal array of interrupts
\ ---------------------------------------------------------------------------

\ Constants common to most EHCI data structures
1 constant TERMINATE
1A567AC 	 0  0 74 65 
1A567B0 	72 6D 69 6E 61 74 65 89 
1A567B8 	5C 67 A5  1 68 40 A0  1 
1A567C0 	 1  0  0  0 

0 constant TYP_ITD
1A567C4 	74 79 70 5F 
1A567C8 	69 74 64 87 BC 67 A5  1 
1A567D0 	68 40 A0  1  0  0  0  0 
2 constant TYP_QH
1A567D8 	 0 74 79 70 5F 71 68 86 
1A567E0 	D0 67 A5  1 68 40 A0  1 
1A567E8 	 2  0  0  0 
4 constant TYP_SITD
1A567EC 	 0  0  0 74 
1A567F0 	79 70 5F 73 69 74 64 88 
1A567F8 	E4 67 A5  1 68 40 A0  1 
1A56800 	 4  0  0  0 
6 constant TYP_FSTN
1A56804 	 0  0  0 74 
1A56808 	79 70 5F 66 73 74 6E 88 
1A56810 	FC 67 A5  1 68 40 A0  1 
1A56818 	 6  0  0  0 

\ Pipe type
0 constant pt-ctrl
1A5681C 	70 74 2D 63 
1A56820 	74 72 6C 87 14 68 A5  1 
1A56828 	68 40 A0  1  0  0  0  0 
1 constant pt-bulk
1A56830 	70 74 2D 62 75 6C 6B 87 
1A56838 	28 68 A5  1 68 40 A0  1 
1A56840 	 1  0  0  0 
2 constant pt-intr
1A56844 	70 74 2D 69 
1A56848 	6E 74 72 87 3C 68 A5  1 
1A56850 	68 40 A0  1  2  0  0  0 
3 constant pt-iso
1A56858 	 0 70 74 2D 69 73 6F 86 
1A56860 	50 68 A5  1 68 40 A0  1 
1A56868 	 3  0  0  0 

\ ---------------------------------------------------------------------------
\ Periodic Frame List as defined by the EHCI Spec; 4-KB aligned
\
\ Each entry is composed of:  bit  0    TERMINATE
\                             bits 2:1  Pipe type
\                             bits 31:5 Frame List Link Pointer
\ ---------------------------------------------------------------------------

h# 1000 constant /align4kb
1A5686C 	 0  0 2F 61 
1A56870 	6C 69 67 6E 34 6B 62 89 
1A56878 	64 68 A5  1 68 40 A0  1 
1A56880 	 0 10  0  0 

d# 1024 dup constant #framelist		\ # of entries in framelist
1A56884 	 0 23 66 72 
1A56888 	61 6D 65 6C 69 73 74 8A 
1A56890 	7C 68 A5  1 68 40 A0  1 
1A56898 	 0  4  0  0 
4 *         constant /framelist		\ Size of framelist
1A5689C 	 0 2F 66 72 
1A568A0 	61 6D 65 6C 69 73 74 8A 
1A568A8 	94 68 A5  1 68 40 A0  1 
1A568B0 	 0 10  0  0 

0 value framelist
1A568B4 	 0  0 66 72 
1A568B8 	61 6D 65 6C 69 73 74 89 
1A568C0 	AC 68 A5  1 50 40 A0  1 
1A568C8 	 C  F  0  0 
0 value framelist-unaligned
1A568CC 	66 72 61 6D 
1A568D0 	65 6C 69 73 74 2D 75 6E 
1A568D8 	61 6C 69 67 6E 65 64 93 
1A568E0 	C4 68 A5  1 50 40 A0  1 
1A568E8 	10  F  0  0 
0 value framelist-phys
1A568EC 	 0 66 72 61 
1A568F0 	6D 65 6C 69 73 74 2D 70 
1A568F8 	68 79 73 8E E4 68 A5  1 
1A56900 	50 40 A0  1 14  F  0  0 

: framelist!  ( n idx -- )  4 * framelist + le-l!  ;
1A56908 	 0 66 72 61 6D 65 6C 69 
1A56910 	73 74 21 8A  0 69 A5  1 
1A56918 	20 40 A0  1 B0 6F A0  1 
1A56920 	1C 5F A0  1 C4 68 A5  1 
1A56928 	 4 45 A0  1 50 36 A4  1 
1A56930 	58 46 A0  1 

: init-framelist  ( -- )
1A56934 	 0 69 6E 69 
1A56938 	74 2D 66 72 61 6D 65 6C 
1A56940 	69 73 74 8E 18 69 A5  1 
1A56948 	20 40 A0  1 
   framelist 0=  if
1A5694C 	C4 68 A5  1 
1A56950 	24 47 A0  1 DC 41 A0  1 
1A56958 	60  0  0  0 
      \ Allocate framelist
      /framelist /align4kb aligned-alloc	    ( unaligned virt )
1A5695C 	AC 68 A5  1 
1A56960 	7C 68 A5  1  C 38 A4  1 
      swap to framelist-unaligned		    ( virt )
1A56968 	68 49 A0  1 B8 40 A0  1 
1A56970 	E4 68 A5  1 
      dup to framelist			            ( virt )
1A56974 	40 49 A0  1 
1A56978 	B8 40 A0  1 C4 68 A5  1 
      /framelist true dma-map-in to framelist-phys  ( )
1A56980 	AC 68 A5  1  4 70 A0  1 
1A56988 	AC 37 A4  1 B8 40 A0  1 
1A56990 	 0 69 A5  1 

      \ Initialize framelist
      #framelist 0  do  TERMINATE i framelist!  loop
1A56994 	94 68 A5  1 
1A56998 	70 6F A0  1 88 42 A0  1 
1A569A0 	18  0  0  0 BC 67 A5  1 
1A569A8 	B4 42 A0  1 18 69 A5  1 
1A569B0 	F8 41 A0  1 F0 FF FF FF 
   then
   framelist-phys periodic!
1A569B8 	 0 69 A5  1 F0 5F A5  1 
;
1A569C0 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Internal interrupt list corresponding with the Frame List
\ ---------------------------------------------------------------------------

struct
   4 field >intr-head
1A569C4 	 0 3E 69 6E 
1A569C8 	74 72 2D 68 65 61 64 8A 
1A569D0 	48 69 A5  1 50 EE A0  1 
1A569D8 	 0  0  0  0 
   4 field >intr-tail
1A569DC 	 0 3E 69 6E 
1A569E0 	74 72 2D 74 61 69 6C 8A 
1A569E8 	D4 69 A5  1 50 EE A0  1 
1A569F0 	 4  0  0  0 
dup constant /intr-entry
1A569F4 	2F 69 6E 74 
1A569F8 	72 2D 65 6E 74 72 79 8B 
1A56A00 	EC 69 A5  1 68 40 A0  1 
1A56A08 	 8  0  0  0 
#framelist * constant /intr		\ Size of intr
1A56A0C 	 0  0 2F 69 
1A56A10 	6E 74 72 85  4 6A A5  1 
1A56A18 	68 40 A0  1  0 20  0  0 

0 value intr				\ Internal array of interrupts
1A56A20 	 0  0  0 69 6E 74 72 84 
1A56A28 	18 6A A5  1 50 40 A0  1 
1A56A30 	18  F  0  0 

: 'intr  ( idx -- adr )  /intr-entry * intr +  ;
1A56A34 	 0  0 27 69 
1A56A38 	6E 74 72 85 2C 6A A5  1 
1A56A40 	20 40 A0  1  4 6A A5  1 
1A56A48 	1C 5F A0  1 2C 6A A5  1 
1A56A50 	 4 45 A0  1 58 46 A0  1 
: intr-head@  ( idx -- adr )  'intr >intr-head l@  ;
1A56A58 	 0 69 6E 74 72 2D 68 65 
1A56A60 	61 64 40 8A 40 6A A5  1 
1A56A68 	20 40 A0  1 40 6A A5  1 
1A56A70 	D4 69 A5  1 6C 4C A0  1 
1A56A78 	58 46 A0  1 
: intr-head!  ( adr idx -- )  'intr >intr-head l!  ;
1A56A7C 	 0 69 6E 74 
1A56A80 	72 2D 68 65 61 64 21 8A 
1A56A88 	68 6A A5  1 20 40 A0  1 
1A56A90 	40 6A A5  1 D4 69 A5  1 
1A56A98 	7C 4D A0  1 58 46 A0  1 
: intr-tail@  ( idx -- adr )  'intr >intr-tail l@  ;
1A56AA0 	 0 69 6E 74 72 2D 74 61 
1A56AA8 	69 6C 40 8A 8C 6A A5  1 
1A56AB0 	20 40 A0  1 40 6A A5  1 
1A56AB8 	EC 69 A5  1 6C 4C A0  1 
1A56AC0 	58 46 A0  1 
: intr-tail!  ( adr idx -- )  'intr >intr-tail l!  ;
1A56AC4 	 0 69 6E 74 
1A56AC8 	72 2D 74 61 69 6C 21 8A 
1A56AD0 	B0 6A A5  1 20 40 A0  1 
1A56AD8 	40 6A A5  1 EC 69 A5  1 
1A56AE0 	7C 4D A0  1 58 46 A0  1 

: init-intr  ( -- )
1A56AE8 	 0  0 69 6E 69 74 2D 69 
1A56AF0 	6E 74 72 89 D4 6A A5  1 
1A56AF8 	20 40 A0  1 
   intr 0=  if
1A56AFC 	2C 6A A5  1 
1A56B00 	24 47 A0  1 DC 41 A0  1 
1A56B08 	20  0  0  0 
      /intr alloc-mem dup to intr		\ Allocate intr
1A56B0C 	18 6A A5  1 
1A56B10 	F0 6C A0  1 40 49 A0  1 
1A56B18 	B8 40 A0  1 2C 6A A5  1 
      /intr erase				\ Initialize intr
1A56B20 	18 6A A5  1 F0 72 A0  1 
   then
;
1A56B28 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Queue Element Transfer Descriptor (qTD) as defined by the EHCI Spec; 32-byte aligned
\ ---------------------------------------------------------------------------

struct					\ Beginning of qTD
   4 field >hcqtd-next			\ Next qTD pointer
1A56B2C 	3E 68 63 71 
1A56B30 	74 64 2D 6E 65 78 74 8B 
1A56B38 	F8 6A A5  1 50 EE A0  1 
1A56B40 	 0  0  0  0 
   4 field >hcqtd-next-alt		\ Alternate next qTD pointer
1A56B44 	3E 68 63 71 
1A56B48 	74 64 2D 6E 65 78 74 2D 
1A56B50 	61 6C 74 8F 3C 6B A5  1 
1A56B58 	50 EE A0  1  4  0  0  0 
   4 field >hcqtd-token			\ qTD token
1A56B60 	 0  0  0 3E 68 63 71 74 
1A56B68 	64 2D 74 6F 6B 65 6E 8C 
1A56B70 	58 6B A5  1 50 EE A0  1 
1A56B78 	 8  0  0  0 
   4 field >hcqtd-bptr0			\ Buffer pointer 0 (4KB aligned)
1A56B7C 	 0  0  0 3E 
1A56B80 	68 63 71 74 64 2D 62 70 
1A56B88 	74 72 30 8C 74 6B A5  1 
1A56B90 	50 EE A0  1  C  0  0  0 
   4 field >hcqtd-bptr1			\ Buffer pointer 1
1A56B98 	 0  0  0 3E 68 63 71 74 
1A56BA0 	64 2D 62 70 74 72 31 8C 
1A56BA8 	90 6B A5  1 50 EE A0  1 
1A56BB0 	10  0  0  0 
   4 field >hcqtd-bptr2			\ Buffer pointer 2
1A56BB4 	 0  0  0 3E 
1A56BB8 	68 63 71 74 64 2D 62 70 
1A56BC0 	74 72 32 8C AC 6B A5  1 
1A56BC8 	50 EE A0  1 14  0  0  0 
   4 field >hcqtd-bptr3			\ Buffer pointer 3
1A56BD0 	 0  0  0 3E 68 63 71 74 
1A56BD8 	64 2D 62 70 74 72 33 8C 
1A56BE0 	C8 6B A5  1 50 EE A0  1 
1A56BE8 	18  0  0  0 
   4 field >hcqtd-bptr4			\ Buffer pointer 4
1A56BEC 	 0  0  0 3E 
1A56BF0 	68 63 71 74 64 2D 62 70 
1A56BF8 	74 72 34 8C E4 6B A5  1 
1A56C00 	50 EE A0  1 1C  0  0  0 
   4 5 * field >hcqtd-xbptrs		\ 64-bit buffer pointer extensions
1A56C08 	 0  0 3E 68 63 71 74 64 
1A56C10 	2D 78 62 70 74 72 73 8D 
1A56C18 	 0 6C A5  1 50 EE A0  1 
1A56C20 	20  0  0  0 
dup constant /hcqtd
1A56C24 	 0 2F 68 63 
1A56C28 	71 74 64 86 1C 6C A5  1 
1A56C30 	68 40 A0  1 34  0  0  0 
					\ Driver specific fields
   4 field >qtd-phys			\ Physical address of qTD
1A56C38 	 0  0 3E 71 74 64 2D 70 
1A56C40 	68 79 73 89 30 6C A5  1 
1A56C48 	50 EE A0  1 34  0  0  0 
   4 field >qtd-next			\ Next qTD virtual address
1A56C50 	 0  0 3E 71 74 64 2D 6E 
1A56C58 	65 78 74 89 48 6C A5  1 
1A56C60 	50 EE A0  1 38  0  0  0 
   4 field >qtd-buf			\ Buffer virtual address
1A56C68 	 0  0  0 3E 71 74 64 2D 
1A56C70 	62 75 66 88 60 6C A5  1 
1A56C78 	50 EE A0  1 3C  0  0  0 
   4 field >qtd-pbuf			\ Buffer physical address
1A56C80 	 0  0 3E 71 74 64 2D 70 
1A56C88 	62 75 66 89 78 6C A5  1 
1A56C90 	50 EE A0  1 40  0  0  0 
   4 field >qtd-/buf			\ Buffer length (per qTD)
1A56C98 	 0  0 3E 71 74 64 2D 2F 
1A56CA0 	62 75 66 89 90 6C A5  1 
1A56CA8 	50 EE A0  1 44  0  0  0 
   4 field >qtd-/buf-all		\ Buffer length (size of the entire buffer)
1A56CB0 	 0  0 3E 71 74 64 2D 2F 
1A56CB8 	62 75 66 2D 61 6C 6C 8D 
1A56CC0 	A8 6C A5  1 50 EE A0  1 
1A56CC8 	48  0  0  0 
					\ Only the first qTD has the entire size of buffer
					\ For bulk and intr qTDs
   4 field >qtd-unaligned		\ Unaligned buffer address
1A56CCC 	 0 3E 71 74 
1A56CD0 	64 2D 75 6E 61 6C 69 67 
1A56CD8 	6E 65 64 8E C4 6C A5  1 
1A56CE0 	50 EE A0  1 4C  0  0  0 
   4 field >qtd-size		        \ Unaligned buffer size
1A56CE8 	 0  0 3E 71 74 64 2D 73 
1A56CF0 	69 7A 65 89 E0 6C A5  1 
1A56CF8 	50 EE A0  1 50  0  0  0 
d# 32 round-up
constant /qtd
1A56D00 	 0  0  0 2F 71 74 64 84 
1A56D08 	F8 6C A5  1 68 40 A0  1 
1A56D10 	60  0  0  0 

\ >hcqtd-token constants
h# 00000000 constant TD_TOGGLE_DATA0
1A56D14 	74 64 5F 74 
1A56D18 	6F 67 67 6C 65 5F 64 61 
1A56D20 	74 61 30 8F  C 6D A5  1 
1A56D28 	68 40 A0  1  0  0  0  0 
h# 80000000 constant TD_TOGGLE_DATA1
1A56D30 	74 64 5F 74 6F 67 67 6C 
1A56D38 	65 5F 64 61 74 61 31 8F 
1A56D40 	28 6D A5  1 68 40 A0  1 
1A56D48 	 0  0  0 80 
h# 80000000 constant TD_TOGGLE_MASK
1A56D4C 	 0 74 64 5F 
1A56D50 	74 6F 67 67 6C 65 5F 6D 
1A56D58 	61 73 6B 8E 44 6D A5  1 
1A56D60 	68 40 A0  1  0  0  0 80 
h# 00008000 constant TD_IOC
1A56D68 	 0 74 64 5F 69 6F 63 86 
1A56D70 	60 6D A5  1 68 40 A0  1 
1A56D78 	 0 80  0  0 
h# 00000c00 constant TD_C_ERR_MASK
1A56D7C 	 0  0 74 64 
1A56D80 	5F 63 5F 65 72 72 5F 6D 
1A56D88 	61 73 6B 8D 74 6D A5  1 
1A56D90 	68 40 A0  1  0  C  0  0 
h# 00000400 constant TD_C_ERR1
1A56D98 	 0  0 74 64 5F 63 5F 65 
1A56DA0 	72 72 31 89 90 6D A5  1 
1A56DA8 	68 40 A0  1  0  4  0  0 
h# 00000800 constant TD_C_ERR2
1A56DB0 	 0  0 74 64 5F 63 5F 65 
1A56DB8 	72 72 32 89 A8 6D A5  1 
1A56DC0 	68 40 A0  1  0  8  0  0 
h# 00000c00 constant TD_C_ERR3
1A56DC8 	 0  0 74 64 5F 63 5F 65 
1A56DD0 	72 72 33 89 C0 6D A5  1 
1A56DD8 	68 40 A0  1  0  C  0  0 
h# 00000000 constant TD_PID_OUT
1A56DE0 	 0 74 64 5F 70 69 64 5F 
1A56DE8 	6F 75 74 8A D8 6D A5  1 
1A56DF0 	68 40 A0  1  0  0  0  0 
h# 00000100 constant TD_PID_IN
1A56DF8 	 0  0 74 64 5F 70 69 64 
1A56E00 	5F 69 6E 89 F0 6D A5  1 
1A56E08 	68 40 A0  1  0  1  0  0 
h# 00000200 constant TD_PID_SETUP
1A56E10 	 0  0  0 74 64 5F 70 69 
1A56E18 	64 5F 73 65 74 75 70 8C 
1A56E20 	 8 6E A5  1 68 40 A0  1 
1A56E28 	 0  2  0  0 
h# 000000ff constant TD_STAT_MASK
1A56E2C 	 0  0  0 74 
1A56E30 	64 5F 73 74 61 74 5F 6D 
1A56E38 	61 73 6B 8C 24 6E A5  1 
1A56E40 	68 40 A0  1 FF  0  0  0 
h# 00000080 constant TD_STAT_ACTIVE
1A56E48 	 0 74 64 5F 73 74 61 74 
1A56E50 	5F 61 63 74 69 76 65 8E 
1A56E58 	40 6E A5  1 68 40 A0  1 
1A56E60 	80  0  0  0 
h# 00000040 constant TD_STAT_HALTED	\ Babble, error count=0, STALL
1A56E64 	 0 74 64 5F 
1A56E68 	73 74 61 74 5F 68 61 6C 
1A56E70 	74 65 64 8E 5C 6E A5  1 
1A56E78 	68 40 A0  1 40  0  0  0 
h# 00000020 constant TD_STAT_DBUFF	\ Data buffer error
1A56E80 	 0  0 74 64 5F 73 74 61 
1A56E88 	74 5F 64 62 75 66 66 8D 
1A56E90 	78 6E A5  1 68 40 A0  1 
1A56E98 	20  0  0  0 
h# 00000010 constant TD_STAT_BABBLE	\ Babble
1A56E9C 	 0 74 64 5F 
1A56EA0 	73 74 61 74 5F 62 61 62 
1A56EA8 	62 6C 65 8E 94 6E A5  1 
1A56EB0 	68 40 A0  1 10  0  0  0 
h# 00000008 constant TD_STAT_XERR	\ Timeout, CRC, bad pid, etc
1A56EB8 	 0  0  0 74 64 5F 73 74 
1A56EC0 	61 74 5F 78 65 72 72 8C 
1A56EC8 	B0 6E A5  1 68 40 A0  1 
1A56ED0 	 8  0  0  0 
h# 00000004 constant TD_STAT_MISS_MF	\ Missed micro-frame
1A56ED4 	74 64 5F 73 
1A56ED8 	74 61 74 5F 6D 69 73 73 
1A56EE0 	5F 6D 66 8F CC 6E A5  1 
1A56EE8 	68 40 A0  1  4  0  0  0 
h# 00000000 constant TD_STAT_S_SPLIT	\ Start split transaction
1A56EF0 	74 64 5F 73 74 61 74 5F 
1A56EF8 	73 5F 73 70 6C 69 74 8F 
1A56F00 	E8 6E A5  1 68 40 A0  1 
1A56F08 	 0  0  0  0 
h# 00000002 constant TD_STAT_C_SPLIT	\ Complete split transaction
1A56F0C 	74 64 5F 73 
1A56F10 	74 61 74 5F 63 5F 73 70 
1A56F18 	6C 69 74 8F  4 6F A5  1 
1A56F20 	68 40 A0  1  2  0  0  0 
h# 00000000 constant TD_STAT_OUT	\ Do OUT
1A56F28 	74 64 5F 73 74 61 74 5F 
1A56F30 	6F 75 74 8B 20 6F A5  1 
1A56F38 	68 40 A0  1  0  0  0  0 
h# 00000001 constant TD_STAT_PING	\ Do ping
1A56F40 	 0  0  0 74 64 5F 73 74 
1A56F48 	61 74 5F 70 69 6E 67 8C 
1A56F50 	38 6F A5  1 68 40 A0  1 
1A56F58 	 1  0  0  0 
h# 00000001 constant TD_STAT_SPLIT_ERR	\ Periodic split transaction ERR
1A56F5C 	 0  0 74 64 
1A56F60 	5F 73 74 61 74 5F 73 70 
1A56F68 	6C 69 74 5F 65 72 72 91 
1A56F70 	54 6F A5  1 68 40 A0  1 
1A56F78 	 1  0  0  0 

: td-data>di-data  ( n -- n' )  TD_TOGGLE_MASK and  if  1  else  0  then  ;
1A56F7C 	74 64 2D 64 
1A56F80 	61 74 61 3E 64 69 2D 64 
1A56F88 	61 74 61 8F 74 6F A5  1 
1A56F90 	20 40 A0  1 60 6D A5  1 
1A56F98 	5C 44 A0  1 DC 41 A0  1 
1A56FA0 	10  0  0  0 80 6F A0  1 
1A56FA8 	C8 41 A0  1  8  0  0  0 
1A56FB0 	70 6F A0  1 58 46 A0  1 
: di-data>td-data  ( n -- n' )  if  TD_TOGGLE_DATA1  else  TD_TOGGLE_DATA0  then  ;
1A56FB8 	64 69 2D 64 61 74 61 3E 
1A56FC0 	74 64 2D 64 61 74 61 8F 
1A56FC8 	90 6F A5  1 20 40 A0  1 
1A56FD0 	DC 41 A0  1 10  0  0  0 
1A56FD8 	44 6D A5  1 C8 41 A0  1 
1A56FE0 	 8  0  0  0 28 6D A5  1 
1A56FE8 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Queue Head (QH) as defined by the EHCI Spec; 32-byte aligned
\ ---------------------------------------------------------------------------

struct					\ Beginning of QH fields
   4 field >hcqh-next			\ QH horizontal link pointer
1A56FEC 	 0 3E 68 63 
1A56FF0 	71 68 2D 6E 65 78 74 8A 
1A56FF8 	CC 6F A5  1 50 EE A0  1 
1A57000 	 0  0  0  0 
   4 field >hcqh-endp-char		\ Endpoint characteristics
1A57004 	3E 68 63 71 
1A57008 	68 2D 65 6E 64 70 2D 63 
1A57010 	68 61 72 8F FC 6F A5  1 
1A57018 	50 EE A0  1  4  0  0  0 
   4 field >hcqh-endp-cap		\ Endpoint capabilities
1A57020 	 0 3E 68 63 71 68 2D 65 
1A57028 	6E 64 70 2D 63 61 70 8E 
1A57030 	18 70 A5  1 50 EE A0  1 
1A57038 	 8  0  0  0 
   4 field >hcqh-cur-pqtd		\ Current transaction descriptor pointer
1A5703C 	 0 3E 68 63 
1A57040 	71 68 2D 63 75 72 2D 70 
1A57048 	71 74 64 8E 34 70 A5  1 
1A57050 	50 EE A0  1  C  0  0  0 
/hcqtd field >hcqh-overlay		\ Transfer overlay area
1A57058 	 0  0 3E 68 63 71 68 2D 
1A57060 	6F 76 65 72 6C 61 79 8D 
1A57068 	50 70 A5  1 50 EE A0  1 
1A57070 	10  0  0  0 
dup constant /hcqh
1A57074 	 0  0 2F 68 
1A57078 	63 71 68 85 6C 70 A5  1 
1A57080 	68 40 A0  1 44  0  0  0 
					\ Driver specific fields
   4 field >qh-phys			\ QH's physical address
1A57088 	 0  0  0 3E 71 68 2D 70 
1A57090 	68 79 73 88 80 70 A5  1 
1A57098 	50 EE A0  1 44  0  0  0 
   4 field >qh-next			\ Next QH's virtual address
1A570A0 	 0  0  0 3E 71 68 2D 6E 
1A570A8 	65 78 74 88 98 70 A5  1 
1A570B0 	50 EE A0  1 48  0  0  0 
   4 field >qh-prev			\ Previous QH's virtual address
1A570B8 	 0  0  0 3E 71 68 2D 70 
1A570C0 	72 65 76 88 B0 70 A5  1 
1A570C8 	50 EE A0  1 4C  0  0  0 
   4 field >qh-unaligned		\ QH's unaligned address
1A570D0 	 0  0 3E 71 68 2D 75 6E 
1A570D8 	61 6C 69 67 6E 65 64 8D 
1A570E0 	C8 70 A5  1 50 EE A0  1 
1A570E8 	50  0  0  0 
   4 field >qh-size			\ Size of QH+qTDs 
1A570EC 	 0  0  0 3E 
1A570F0 	71 68 2D 73 69 7A 65 88 
1A570F8 	E4 70 A5  1 50 EE A0  1 
1A57100 	54  0  0  0 
   4 field >qh-#qtds			\ # of qTDs in the list
1A57104 	 0  0 3E 71 
1A57108 	68 2D 23 71 74 64 73 89 
1A57110 	FC 70 A5  1 50 EE A0  1 
1A57118 	58  0  0  0 
   4 field >qh-#bufs			\ # of bufs
1A5711C 	 0  0 3E 71 
1A57120 	68 2D 23 62 75 66 73 89 
1A57128 	14 71 A5  1 50 EE A0  1 
1A57130 	5C  0  0  0 
   4 field >qh-/buf			\ size of each buf
1A57134 	 0  0  0 3E 
1A57138 	71 68 2D 2F 62 75 66 88 
1A57140 	2C 71 A5  1 50 EE A0  1 
1A57148 	60  0  0  0 
   4 field >qh-buf			\ buf start va
1A5714C 	3E 71 68 2D 
1A57150 	62 75 66 87 44 71 A5  1 
1A57158 	50 EE A0  1 64  0  0  0 
   4 field >qh-buf-pa			\ buf start pa
1A57160 	 0 3E 71 68 2D 62 75 66 
1A57168 	2D 70 61 8A 58 71 A5  1 
1A57170 	50 EE A0  1 68  0  0  0 
   4 field >qh-timeout			\ Timeout
1A57178 	3E 71 68 2D 74 69 6D 65 
1A57180 	6F 75 74 8B 70 71 A5  1 
1A57188 	50 EE A0  1 6C  0  0  0 
d# 32 round-up
constant /qh
1A57190 	2F 71 68 83 88 71 A5  1 
1A57198 	68 40 A0  1 80  0  0  0 

\ >hcqh-endp-char constants
h# 08000000 constant QH_CTRL_ENDP
1A571A0 	 0  0  0 71 68 5F 63 74 
1A571A8 	72 6C 5F 65 6E 64 70 8C 
1A571B0 	98 71 A5  1 68 40 A0  1 
1A571B8 	 0  0  0  8 
h# 00008000 constant QH_HEAD
1A571BC 	71 68 5F 68 
1A571C0 	65 61 64 87 B4 71 A5  1 
1A571C8 	68 40 A0  1  0 80  0  0 
h# 00004000 constant QH_TD_TOGGLE
1A571D0 	 0  0  0 71 68 5F 74 64 
1A571D8 	5F 74 6F 67 67 6C 65 8C 
1A571E0 	C8 71 A5  1 68 40 A0  1 
1A571E8 	 0 40  0  0 
h# 00000080 constant QH_INACTIVE_NEXT
1A571EC 	 0  0  0 71 
1A571F0 	68 5F 69 6E 61 63 74 69 
1A571F8 	76 65 5F 6E 65 78 74 90 
1A57200 	E4 71 A5  1 68 40 A0  1 
1A57208 	80  0  0  0 
h# 00000000 constant QH_TUNE_RL_HS
1A5720C 	 0  0 71 68 
1A57210 	5F 74 75 6E 65 5F 72 6C 
1A57218 	5F 68 73 8D  4 72 A5  1 
1A57220 	68 40 A0  1  0  0  0  0 
h# 00000000 constant QH_TUNE_RL_TT
1A57228 	 0  0 71 68 5F 74 75 6E 
1A57230 	65 5F 72 6C 5F 74 74 8D 
1A57238 	20 72 A5  1 68 40 A0  1 
1A57240 	 0  0  0  0 

\ >hcqh-endp-cap constants
h# 40000000 constant QH_MULT1
1A57244 	 0  0  0 71 
1A57248 	68 5F 6D 75 6C 74 31 88 
1A57250 	3C 72 A5  1 68 40 A0  1 
1A57258 	 0  0  0 40 
h# 80000000 constant QH_MULT2
1A5725C 	 0  0  0 71 
1A57260 	68 5F 6D 75 6C 74 32 88 
1A57268 	54 72 A5  1 68 40 A0  1 
1A57270 	 0  0  0 80 
h# c0000000 constant QH_MULT3
1A57274 	 0  0  0 71 
1A57278 	68 5F 6D 75 6C 74 33 88 
1A57280 	6C 72 A5  1 68 40 A0  1 
1A57288 	 0  0  0 C0 


0 value qh-ptr				\ Head of all QHs
1A5728C 	 0 71 68 2D 
1A57290 	70 74 72 86 84 72 A5  1 
1A57298 	50 40 A0  1 1C  F  0  0 

\ ---------------------------------------------------------------------------
\ QH and TDs for bulk, control and interrupt operations.
\ QH and its list of TDs are allocated as needed.
\ ---------------------------------------------------------------------------

: push-qh      ( qh  -- )  dup >qh-phys  l@ /hcqh  dma-push  ;
1A572A0 	70 75 73 68 2D 71 68 87 
1A572A8 	98 72 A5  1 20 40 A0  1 
1A572B0 	40 49 A0  1 98 70 A5  1 
1A572B8 	6C 4C A0  1 80 70 A5  1 
1A572C0 	FC 36 A4  1 58 46 A0  1 
: pull-qh      ( qh  -- )  dup >qh-phys  l@ /hcqh  dma-pull  ;
1A572C8 	70 75 6C 6C 2D 71 68 87 
1A572D0 	AC 72 A5  1 20 40 A0  1 
1A572D8 	40 49 A0  1 98 70 A5  1 
1A572E0 	6C 4C A0  1 80 70 A5  1 
1A572E8 	28 37 A4  1 58 46 A0  1 
: push-qtd     ( qtd -- )  dup >qtd-phys l@ /hcqtd dma-push  ;
1A572F0 	 0  0  0 70 75 73 68 2D 
1A572F8 	71 74 64 88 D4 72 A5  1 
1A57300 	20 40 A0  1 40 49 A0  1 
1A57308 	48 6C A5  1 6C 4C A0  1 
1A57310 	30 6C A5  1 FC 36 A4  1 
1A57318 	58 46 A0  1 
: pull-qtd     ( qtd -- )  dup >qtd-phys l@ /hcqtd dma-pull  ;
1A5731C 	 0  0  0 70 
1A57320 	75 6C 6C 2D 71 74 64 88 
1A57328 	 0 73 A5  1 20 40 A0  1 
1A57330 	40 49 A0  1 48 6C A5  1 
1A57338 	6C 4C A0  1 30 6C A5  1 
1A57340 	28 37 A4  1 58 46 A0  1 
: push-qtds    ( qtd -- )  dup >qtd-phys l@ over >qtd-size l@  dma-push  ;
1A57348 	 0  0 70 75 73 68 2D 71 
1A57350 	74 64 73 89 2C 73 A5  1 
1A57358 	20 40 A0  1 40 49 A0  1 
1A57360 	48 6C A5  1 6C 4C A0  1 
1A57368 	54 49 A0  1 F8 6C A5  1 
1A57370 	6C 4C A0  1 FC 36 A4  1 
1A57378 	58 46 A0  1 
: pull-qtds    ( qtd -- )  dup >qtd-phys l@ over >qtd-size l@  dma-pull  ;
1A5737C 	 0  0 70 75 
1A57380 	6C 6C 2D 71 74 64 73 89 
1A57388 	58 73 A5  1 20 40 A0  1 
1A57390 	40 49 A0  1 48 6C A5  1 
1A57398 	6C 4C A0  1 54 49 A0  1 
1A573A0 	F8 6C A5  1 6C 4C A0  1 
1A573A8 	28 37 A4  1 58 46 A0  1 
: push-qhqtds  ( qh  -- )  dup >qh-phys  l@ over >qh-size  l@  dma-push  ;
1A573B0 	70 75 73 68 2D 71 68 71 
1A573B8 	74 64 73 8B 8C 73 A5  1 
1A573C0 	20 40 A0  1 40 49 A0  1 
1A573C8 	98 70 A5  1 6C 4C A0  1 
1A573D0 	54 49 A0  1 FC 70 A5  1 
1A573D8 	6C 4C A0  1 FC 36 A4  1 
1A573E0 	58 46 A0  1 
: pull-qhqtds  ( qh  -- )  dup >qh-phys  l@ over >qh-size  l@  dma-pull  ;
1A573E4 	70 75 6C 6C 
1A573E8 	2D 71 68 71 74 64 73 8B 
1A573F0 	C0 73 A5  1 20 40 A0  1 
1A573F8 	40 49 A0  1 98 70 A5  1 
1A57400 	6C 4C A0  1 54 49 A0  1 
1A57408 	FC 70 A5  1 6C 4C A0  1 
1A57410 	28 37 A4  1 58 46 A0  1 

: map-out-bptrs  ( qtd -- )
1A57418 	 0  0 6D 61 70 2D 6F 75 
1A57420 	74 2D 62 70 74 72 73 8D 
1A57428 	F4 73 A5  1 20 40 A0  1 
   dup >qtd-buf l@ over >qtd-pbuf l@ rot >qtd-/buf-all l@ hcd-map-out
1A57430 	40 49 A0  1 78 6C A5  1 
1A57438 	6C 4C A0  1 54 49 A0  1 
1A57440 	90 6C A5  1 6C 4C A0  1 
1A57448 	7C 49 A0  1 C4 6C A5  1 
1A57450 	6C 4C A0  1 8C 3E A4  1 
;
1A57458 	58 46 A0  1 

: link-qtds  ( qtd.v qtd.p #qtds -- )
1A5745C 	 0  0 6C 69 
1A57460 	6E 6B 2D 71 74 64 73 89 
1A57468 	2C 74 A5  1 20 40 A0  1 
   1- 0  ?do					( v p )
1A57470 	54 4B A0  1 70 6F A0  1 
1A57478 	50 42 A0  1 6C  0  0  0 
      TERMINATE 2 pick >hcqtd-next-alt le-l!	( v p )
1A57480 	BC 67 A5  1 90 6F A0  1 
1A57488 	 C 4A A0  1 58 6B A5  1 
1A57490 	50 36 A4  1 
      2dup swap >qtd-phys l!			( v p )
1A57494 	C0 49 A0  1 
1A57498 	68 49 A0  1 48 6C A5  1 
1A574A0 	7C 4D A0  1 
      /qtd +					( v p' )
1A574A4 	 C 6D A5  1 
1A574A8 	 4 45 A0  1 
      2dup swap >hcqtd-next le-l!		( v p )
1A574AC 	C0 49 A0  1 
1A574B0 	68 49 A0  1 3C 6B A5  1 
1A574B8 	50 36 A4  1 
      swap dup /qtd + tuck swap >qtd-next l!	( p v' )
1A574BC 	68 49 A0  1 
1A574C0 	40 49 A0  1  C 6D A5  1 
1A574C8 	 4 45 A0  1 E8 46 A0  1 
1A574D0 	68 49 A0  1 60 6C A5  1 
1A574D8 	7C 4D A0  1 
      swap					( v p )
1A574DC 	68 49 A0  1 
   loop
1A574E0 	F8 41 A0  1 9C FF FF FF 

   \ Fix up the last qTD
   over >qtd-phys l!				( v )
1A574E8 	54 49 A0  1 48 6C A5  1 
1A574F0 	7C 4D A0  1 
   TERMINATE over >hcqtd-next le-l!		( v )
1A574F4 	BC 67 A5  1 
1A574F8 	54 49 A0  1 3C 6B A5  1 
1A57500 	50 36 A4  1 
   TERMINATE swap >hcqtd-next-alt le-l!		( )
1A57504 	BC 67 A5  1 
1A57508 	68 49 A0  1 58 6B A5  1 
1A57510 	50 36 A4  1 
;
1A57514 	58 46 A0  1 

: link-qhqtd  ( qtd.p qh -- )
1A57518 	 0 6C 69 6E 6B 2D 71 68 
1A57520 	71 74 64 8A 6C 74 A5  1 
1A57528 	20 40 A0  1 
   >hcqh-overlay tuck			( qh.overlay qtd.p qh.overlay )
1A5752C 	6C 70 A5  1 
1A57530 	E8 46 A0  1 
   >hcqtd-next le-l!			( qh.overlay )
1A57534 	3C 6B A5  1 
1A57538 	50 36 A4  1 
   TERMINATE over >hcqtd-next-alt le-l!	( qh.overlay)
1A5753C 	BC 67 A5  1 
1A57540 	54 49 A0  1 58 6B A5  1 
1A57548 	50 36 A4  1 
   \ We start with OUT instead of PING here because some broken USB keys don't
   \ support PING.  In bulk.fth, we add back the PING flag for bulk-out
   \ operations, where ping transactions can help significantly.
   \ (I'm not sure this matters, as the overlay will overwrite it).

   \ The data toggle will be set later
   TD_STAT_OUT swap >hcqtd-token le-l!	( )
1A5754C 	38 6F A5  1 
1A57550 	68 49 A0  1 74 6B A5  1 
1A57558 	50 36 A4  1 
;
1A5755C 	58 46 A0  1 

: link-qhqtds  ( qtd.v qtd.p #qtds qh -- )
1A57560 	6C 69 6E 6B 2D 71 68 71 
1A57568 	74 64 73 8B 28 75 A5  1 
1A57570 	20 40 A0  1 
   2 pick swap link-qhqtd		( qtd.v qtd.p #qtds )	\ Link QH to qTD
1A57574 	90 6F A0  1 
1A57578 	 C 4A A0  1 68 49 A0  1 
1A57580 	28 75 A5  1 
   link-qtds				( )			\ Link qTDs
1A57584 	6C 74 A5  1 
;
1A57588 	58 46 A0  1 

: init-qh  ( qh.u,v,p len #qtds -- )
1A5758C 	69 6E 69 74 
1A57590 	2D 71 68 87 70 75 A5  1 
1A57598 	20 40 A0  1 
   3 pick >qh-#qtds l!			( qh.u,v,p len )
1A5759C 	A0 6F A0  1 
1A575A0 	 C 4A A0  1 14 71 A5  1 
1A575A8 	7C 4D A0  1 
   2 pick >qh-size l!			( qh.u,v,p )
1A575AC 	90 6F A0  1 
1A575B0 	 C 4A A0  1 FC 70 A5  1 
1A575B8 	7C 4D A0  1 
   over >qh-phys l!			( qh.u,v )
1A575BC 	54 49 A0  1 
1A575C0 	98 70 A5  1 7C 4D A0  1 
   TERMINATE 2 pick >hcqh-next le-l!	( qh.u,v )
1A575C8 	BC 67 A5  1 90 6F A0  1 
1A575D0 	 C 4A A0  1 FC 6F A5  1 
1A575D8 	50 36 A4  1 
   >qh-unaligned l!			( )
1A575DC 	E4 70 A5  1 
1A575E0 	7C 4D A0  1 
;
1A575E4 	58 46 A0  1 

: free-qh  ( qh -- )
1A575E8 	66 72 65 65 2D 71 68 87 
1A575F0 	98 75 A5  1 20 40 A0  1 
   >r					( R: qh )
1A575F8 	BC 45 A0  1 
   r@ >qh-unaligned l@			( qh.u )  ( R: qh )
1A575FC 	E4 45 A0  1 
1A57600 	E4 70 A5  1 6C 4C A0  1 
   r@ dup >qh-phys l@			( qh.u,v,p )  ( R: qh )
1A57608 	E4 45 A0  1 40 49 A0  1 
1A57610 	98 70 A5  1 6C 4C A0  1 
   r> >qh-size l@			( qh.u,v,p size )
1A57618 	D0 45 A0  1 FC 70 A5  1 
1A57620 	6C 4C A0  1 
   aligned32-free-map-out		( )
1A57624 	B8 39 A4  1 
;
1A57628 	58 46 A0  1 

: alloc-qhqtds  ( #qtds -- qh qtd )
1A5762C 	 0  0  0 61 
1A57630 	6C 6C 6F 63 2D 71 68 71 
1A57638 	74 64 73 8C F4 75 A5  1 
1A57640 	20 40 A0  1 
   dup >r  /qtd * /qh + dup >r		( len )  ( R: #qtds len )
1A57644 	40 49 A0  1 
1A57648 	BC 45 A0  1  C 6D A5  1 
1A57650 	1C 5F A0  1 98 71 A5  1 
1A57658 	 4 45 A0  1 40 49 A0  1 
1A57660 	BC 45 A0  1 
   aligned32-alloc-map-in		( qh.u,v,p )  ( R: #qtds len )
1A57664 	78 39 A4  1 
   over r@ erase			( qh.u,v,p )  ( R: #qtds )
1A57668 	54 49 A0  1 E4 45 A0  1 
1A57670 	F0 72 A0  1 
   3dup r> r@ init-qh			( qh.u,v,p )  ( R: #qtds )
1A57674 	6C 3F A4  1 
1A57678 	D0 45 A0  1 E4 45 A0  1 
1A57680 	98 75 A5  1 
   rot drop				( qh.v,p )  ( R: #qtds )
1A57684 	7C 49 A0  1 
1A57688 	30 49 A0  1 
   over /qh + dup -rot			( qh qtd qh.p qtd )  ( R: #qtds )
1A5768C 	54 49 A0  1 
1A57690 	98 71 A5  1  4 45 A0  1 
1A57698 	40 49 A0  1 94 49 A0  1 
   swap /qh +				( qh qtd qtd.v,p )  ( R: #qtds )
1A576A0 	68 49 A0  1 98 71 A5  1 
1A576A8 	 4 45 A0  1 
   r> 4 pick link-qhqtds		( qh qtd )
1A576AC 	D0 45 A0  1 
1A576B0 	B0 6F A0  1  C 4A A0  1 
1A576B8 	70 75 A5  1 
;
1A576BC 	58 46 A0  1 

\ Qtds will be freed automatically when the qh is freed

: reuse-qhqtds  ( #qtds qh -- qh qtd )
1A576C0 	 0  0  0 72 65 75 73 65 
1A576C8 	2D 71 68 71 74 64 73 8C 
1A576D0 	40 76 A5  1 20 40 A0  1 
   swap dup >r  /qtd * /qh + >r		( qh )  ( R: #qtds len )
1A576D8 	68 49 A0  1 40 49 A0  1 
1A576E0 	BC 45 A0  1  C 6D A5  1 
1A576E8 	1C 5F A0  1 98 71 A5  1 
1A576F0 	 4 45 A0  1 BC 45 A0  1 
   dup >qh-unaligned l@ swap		( qh.u,v )  ( R: #qtds len )
1A576F8 	40 49 A0  1 E4 70 A5  1 
1A57700 	6C 4C A0  1 68 49 A0  1 
   dup >qh-phys l@			( qh,u,v,p )  ( R: #qtds len )
1A57708 	40 49 A0  1 98 70 A5  1 
1A57710 	6C 4C A0  1 
   over r@ erase			( qh.u,v,p )  ( R: #qtds )
1A57714 	54 49 A0  1 
1A57718 	E4 45 A0  1 F0 72 A0  1 
   3dup r> r@ init-qh			( qh.u,v,p )  ( R: #qtds )
1A57720 	6C 3F A4  1 D0 45 A0  1 
1A57728 	E4 45 A0  1 98 75 A5  1 
   rot drop				( qh.v,p )  ( R: #qtds )
1A57730 	7C 49 A0  1 30 49 A0  1 
   over /qh + dup -rot			( qh qtd qh.p qtd )  ( R: #qtds )
1A57738 	54 49 A0  1 98 71 A5  1 
1A57740 	 4 45 A0  1 40 49 A0  1 
1A57748 	94 49 A0  1 
   swap /qh +				( qh qtd qtd.v,p )  ( R: #qtds )
1A5774C 	68 49 A0  1 
1A57750 	98 71 A5  1  4 45 A0  1 
   r> 4 pick link-qhqtds		( qh qtd )
1A57758 	D0 45 A0  1 B0 6F A0  1 
1A57760 	 C 4A A0  1 70 75 A5  1 
;
1A57768 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ qTD Buffer Pointers management
\ ---------------------------------------------------------------------------

5                    constant #bptr		\ There are 5 Buffer Pointers in qTD
1A5776C 	 0  0 23 62 
1A57770 	70 74 72 85 D4 76 A5  1 
1A57778 	68 40 A0  1  5  0  0  0 
h# 1000              constant /bptr		\ Size of buffer at each Buffer Pointer[i]
1A57780 	 0  0 2F 62 70 74 72 85 
1A57788 	78 77 A5  1 68 40 A0  1 
1A57790 	 0 10  0  0 
/bptr 1-	     constant bptr-ofs-mask	\ Current Offset mask
1A57794 	 0  0 62 70 
1A57798 	74 72 2D 6F 66 73 2D 6D 
1A577A0 	61 73 6B 8D 8C 77 A5  1 
1A577A8 	68 40 A0  1 FF  F  0  0 
bptr-ofs-mask invert constant bptr-mask		\ Buffer Pointer mask
1A577B0 	 0  0 62 70 74 72 2D 6D 
1A577B8 	61 73 6B 89 A8 77 A5  1 
1A577C0 	68 40 A0  1  0 F0 FF FF 
/bptr #bptr    *     constant /maxbptrs		\ Maximum size of transfer for a qTD
1A577C8 	 0  0 2F 6D 61 78 62 70 
1A577D0 	74 72 73 89 C0 77 A5  1 
1A577D8 	68 40 A0  1  0 50  0  0 
/bptr #bptr 1- *     constant /maxbptrs-1	\ Maximum size of 4 Buffer Pointers
1A577E0 	2F 6D 61 78 62 70 74 72 
1A577E8 	73 2D 31 8B D8 77 A5  1 
1A577F0 	68 40 A0  1  0 40  0  0 

\ Determine the size of transfer for a qTD
: cal-/bptr  ( phys len -- /xfer )
1A577F8 	 0  0 63 61 6C 2D 2F 62 
1A57800 	70 74 72 89 F0 77 A5  1 
1A57808 	20 40 A0  1 
   over dup /bptr round-up =  if	( phys len )
1A5780C 	54 49 A0  1 
1A57810 	40 49 A0  1 8C 77 A5  1 
1A57818 	CC 36 A4  1 24 48 A0  1 
1A57820 	DC 41 A0  1 18  0  0  0 
      nip /maxbptrs min			( /xfer )
1A57828 	FC 46 A0  1 D8 77 A5  1 
1A57830 	74 4A A0  1 
   else
1A57834 	C8 41 A0  1 
1A57838 	24  0  0  0 
      swap bptr-ofs-mask and		( len len0 )
1A5783C 	68 49 A0  1 
1A57840 	A8 77 A5  1 5C 44 A0  1 
      tuck - /maxbptrs-1 min +		( /xfer )
1A57848 	E8 46 A0  1 18 45 A0  1 
1A57850 	F0 77 A5  1 74 4A A0  1 
1A57858 	 4 45 A0  1 
   then
;
1A5785C 	58 46 A0  1 

\ Determine the number of Buffer Pointers necessary
: cal-#bptr  ( phys len -- #bptr )
1A57860 	 0  0 63 61 6C 2D 23 62 
1A57868 	70 74 72 89  8 78 A5  1 
1A57870 	20 40 A0  1 
   dup  0=  if  nip exit  then
1A57874 	40 49 A0  1 
1A57878 	24 47 A0  1 DC 41 A0  1 
1A57880 	 C  0  0  0 FC 46 A0  1 
1A57888 	40 46 A0  1 
   swap dup /bptr round-up swap -  ?dup  if
1A5788C 	68 49 A0  1 
1A57890 	40 49 A0  1 8C 77 A5  1 
1A57898 	CC 36 A4  1 68 49 A0  1 
1A578A0 	18 45 A0  1 B4 70 A0  1 
1A578A8 	DC 41 A0  1 24  0  0  0 
					( len len0 )
      -					( len-len0 )
1A578B0 	18 45 A0  1 
      /bptr round-up /bptr / 1+		( #bptr )
1A578B4 	8C 77 A5  1 
1A578B8 	CC 36 A4  1 8C 77 A5  1 
1A578C0 	98 5F A0  1 30 4B A0  1 
   else					( len )
1A578C8 	C8 41 A0  1 14  0  0  0 
      /bptr round-up /bptr /		( #bptr )
1A578D0 	8C 77 A5  1 CC 36 A4  1 
1A578D8 	8C 77 A5  1 98 5F A0  1 
   then
;
1A578E0 	58 46 A0  1 

\ Determine the number of qTDs necessary for the entire transfer
: cal-#qtd  ( phys len -- #qtds )
1A578E4 	 0  0  0 63 
1A578E8 	61 6C 2D 23 71 74 64 88 
1A578F0 	70 78 A5  1 20 40 A0  1 
   dup  0=  if  nip exit  then
1A578F8 	40 49 A0  1 24 47 A0  1 
1A57900 	DC 41 A0  1  C  0  0  0 
1A57908 	FC 46 A0  1 40 46 A0  1 
   cal-#bptr #bptr /mod swap  if  1+  then
1A57910 	70 78 A5  1 78 77 A5  1 
1A57918 	50 5F A0  1 68 49 A0  1 
1A57920 	DC 41 A0  1  8  0  0  0 
1A57928 	30 4B A0  1 
;
1A5792C 	58 46 A0  1 

: fill-qtd-bptrs  ( buf phys len qtd -- actual )
1A57930 	 0 66 69 6C 6C 2D 71 74 
1A57938 	64 2D 62 70 74 72 73 8E 
1A57940 	F4 78 A5  1 20 40 A0  1 
   >r rot r@ >qtd-buf l!		( phys len )  ( R: qtd )
1A57948 	BC 45 A0  1 7C 49 A0  1 
1A57950 	E4 45 A0  1 78 6C A5  1 
1A57958 	7C 4D A0  1 
   dup r@ >qtd-/buf-all l!		( phys len )  ( R: qtd )
1A5795C 	40 49 A0  1 
1A57960 	E4 45 A0  1 C4 6C A5  1 
1A57968 	7C 4D A0  1 
   over r@ >qtd-pbuf l!			( phys len )  ( R: qtd )
1A5796C 	54 49 A0  1 
1A57970 	E4 45 A0  1 90 6C A5  1 
1A57978 	7C 4D A0  1 
   over swap cal-/bptr tuck  		( actual phys actual )  ( R: qtd )
1A5797C 	54 49 A0  1 
1A57980 	68 49 A0  1  8 78 A5  1 
1A57988 	E8 46 A0  1 
   dup r@ >qtd-/buf l!			( actual phys actual )  ( R: qtd )
1A5798C 	40 49 A0  1 
1A57990 	E4 45 A0  1 A8 6C A5  1 
1A57998 	7C 4D A0  1 
   over swap cal-#bptr			( actual phys #bptr )  ( R: qtd )
1A5799C 	54 49 A0  1 
1A579A0 	68 49 A0  1 70 78 A5  1 
   r> swap 0  ?do			( actual phys qtd )
1A579A8 	D0 45 A0  1 68 49 A0  1 
1A579B0 	70 6F A0  1 50 42 A0  1 
1A579B8 	40  0  0  0 
      2dup >hcqtd-bptr0 i 4 * + le-l!	( actual phys qtd )
1A579BC 	C0 49 A0  1 
1A579C0 	90 6B A5  1 B4 42 A0  1 
1A579C8 	B0 6F A0  1 1C 5F A0  1 
1A579D0 	 4 45 A0  1 50 36 A4  1 
      swap /bptr + bptr-mask and swap	( actual phys' qtd )
1A579D8 	68 49 A0  1 8C 77 A5  1 
1A579E0 	 4 45 A0  1 C0 77 A5  1 
1A579E8 	5C 44 A0  1 68 49 A0  1 
   loop  2drop				( actual )
1A579F0 	F8 41 A0  1 C8 FF FF FF 
1A579F8 	AC 49 A0  1 
;
1A579FC 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Async scheduling
\ ---------------------------------------------------------------------------

: async-wait  ( -- )
1A57A00 	 0 61 73 79 6E 63 2D 77 
1A57A08 	61 69 74 8A 44 79 A5  1 
1A57A10 	20 40 A0  1 
   begin
      usbcmd@ h# 20 and  5 >>  usbsts@ h# 8000 and d# 15 >> 
1A57A14 	64 5E A5  1 
1A57A18 	58 41 A0  1 20  0  0  0 
1A57A20 	5C 44 A0  1 C0 6F A0  1 
1A57A28 	DC 44 A0  1 BC 5E A5  1 
1A57A30 	58 41 A0  1  0 80  0  0 
1A57A38 	5C 44 A0  1 58 41 A0  1 
1A57A40 	 F  0  0  0 DC 44 A0  1 
   = until
1A57A48 	24 48 A0  1 DC 41 A0  1 
1A57A50 	C4 FF FF FF 
;
1A57A54 	58 46 A0  1 
: enable-async  ( qh -- )
1A57A58 	 0  0  0 65 6E 61 62 6C 
1A57A60 	65 2D 61 73 79 6E 63 8C 
1A57A68 	10 7A A5  1 20 40 A0  1 
   >qh-phys l@  asynclist!   async-wait
1A57A70 	98 70 A5  1 6C 4C A0  1 
1A57A78 	38 60 A5  1 10 7A A5  1 
   usbcmd@ h# 20 or usbcmd!  async-wait
1A57A80 	64 5E A5  1 58 41 A0  1 
1A57A88 	20  0  0  0 70 44 A0  1 
1A57A90 	80 5E A5  1 10 7A A5  1 
;
1A57A98 	58 46 A0  1 
: disable-async  ( -- )
1A57A9C 	 0  0 64 69 
1A57AA0 	73 61 62 6C 65 2D 61 73 
1A57AA8 	79 6E 63 8D 6C 7A A5  1 
1A57AB0 	20 40 A0  1 
   async-wait  usbcmd@ h# 20 invert and usbcmd!  async-wait
1A57AB4 	10 7A A5  1 
1A57AB8 	64 5E A5  1 58 41 A0  1 
1A57AC0 	20  0  0  0 30 45 A0  1 
1A57AC8 	5C 44 A0  1 80 5E A5  1 
1A57AD0 	10 7A A5  1 
   0 to qh-ptr
1A57AD4 	70 6F A0  1 
1A57AD8 	B8 40 A0  1 98 72 A5  1 
;
1A57AE0 	58 46 A0  1 

: link-to-qh-ptr  ( qh -- )
1A57AE4 	 0 6C 69 6E 
1A57AE8 	6B 2D 74 6F 2D 71 68 2D 
1A57AF0 	70 74 72 8E B0 7A A5  1 
1A57AF8 	20 40 A0  1 
   dup  qh-ptr >qh-next  l!                               ( qh )
1A57AFC 	40 49 A0  1 
1A57B00 	98 72 A5  1 B0 70 A5  1 
1A57B08 	7C 4D A0  1 
   dup  >qh-phys l@  TYP_QH or  qh-ptr >hcqh-next  le-l!  ( qh )
1A57B0C 	40 49 A0  1 
1A57B10 	98 70 A5  1 6C 4C A0  1 
1A57B18 	E4 67 A5  1 70 44 A0  1 
1A57B20 	98 72 A5  1 FC 6F A5  1 
1A57B28 	50 36 A4  1 
   push-qhqtds                                            ( )
1A57B2C 	C0 73 A5  1 
;
1A57B30 	58 46 A0  1 
: interrupt-on-last-td  ( qh -- )
1A57B34 	 0  0  0 69 
1A57B38 	6E 74 65 72 72 75 70 74 
1A57B40 	2D 6F 6E 2D 6C 61 73 74 
1A57B48 	2D 74 64 94 F8 7A A5  1 
1A57B50 	20 40 A0  1 
   /qh +                                   ( qtd )
1A57B54 	98 71 A5  1 
1A57B58 	 4 45 A0  1 
   begin                                   ( qtd )
      dup >hcqtd-next le-l@ TERMINATE <>   ( qtd flag )
1A57B5C 	40 49 A0  1 
1A57B60 	3C 6B A5  1 B8 35 A4  1 
1A57B68 	BC 67 A5  1 44 48 A0  1 
   while                                   ( qtd )
1A57B70 	DC 41 A0  1 14  0  0  0 
      >qtd-next l@                         ( qtd' )
1A57B78 	60 6C A5  1 6C 4C A0  1 
   repeat                                  ( qtd )
1A57B80 	C8 41 A0  1 D8 FF FF FF 
   >hcqtd-token                            ( 'token )
1A57B88 	74 6B A5  1 
   dup le-l@  TD_IOC or  swap le-l!        ( )
1A57B8C 	40 49 A0  1 
1A57B90 	B8 35 A4  1 74 6D A5  1 
1A57B98 	70 44 A0  1 68 49 A0  1 
1A57BA0 	50 36 A4  1 
;
1A57BA4 	58 46 A0  1 

: insert-qh  ( qh -- )
1A57BA8 	 0  0 69 6E 73 65 72 74 
1A57BB0 	2D 71 68 89 50 7B A5  1 
1A57BB8 	20 40 A0  1 
   hc-interrupt? drop      \ Clear any pending transfer-complete interrupts
1A57BBC 	B0 61 A5  1 
1A57BC0 	30 49 A0  1 
   0 >hcqh-cur-pqtd off
1A57BC4 	70 6F A0  1 
1A57BC8 	50 70 A5  1 F8 4B A0  1 
   qh-ptr  if                                                 ( qh )
1A57BD0 	98 72 A5  1 DC 41 A0  1 
1A57BD8 	58  0  0  0 
      \ If there is another qh, link the new qh to the existing qh head.
      qh-ptr                    over >qh-prev      l!         ( qh )
1A57BDC 	98 72 A5  1 
1A57BE0 	54 49 A0  1 C8 70 A5  1 
1A57BE8 	7C 4D A0  1 
      qh-ptr >qh-next      l@   over >qh-next      l!         ( qh )
1A57BEC 	98 72 A5  1 
1A57BF0 	B0 70 A5  1 6C 4C A0  1 
1A57BF8 	54 49 A0  1 B0 70 A5  1 
1A57C00 	7C 4D A0  1 
      qh-ptr >hcqh-next le-l@   over >hcqh-next le-l!         ( qh )
1A57C04 	98 72 A5  1 
1A57C08 	FC 6F A5  1 B8 35 A4  1 
1A57C10 	54 49 A0  1 FC 6F A5  1 
1A57C18 	50 36 A4  1 

      link-to-qh-ptr                                          ( )
1A57C1C 	F8 7A A5  1 

      qh-ptr push-qh                                          ( )
1A57C20 	98 72 A5  1 AC 72 A5  1 
   else                                                       ( )
1A57C28 	C8 41 A0  1 3C  0  0  0 
      \ If there is no other qh, make it the head, link it to itself, 
      \ and start the asynch schedule.

      to qh-ptr                                                  ( )
1A57C30 	B8 40 A0  1 98 72 A5  1 

      qh-ptr >hcqh-endp-char  dup le-l@  QH_HEAD or  swap le-l!  ( )
1A57C38 	98 72 A5  1 18 70 A5  1 
1A57C40 	40 49 A0  1 B8 35 A4  1 
1A57C48 	C8 71 A5  1 70 44 A0  1 
1A57C50 	68 49 A0  1 50 36 A4  1 

      qh-ptr link-to-qh-ptr                                      ( )
1A57C58 	98 72 A5  1 F8 7A A5  1 

      qh-ptr enable-async                                        ( )
1A57C60 	98 72 A5  1 6C 7A A5  1 
   then
;
1A57C68 	58 46 A0  1 
: fix-wraparound-qh  ( qh -- )
1A57C6C 	 0  0 66 69 
1A57C70 	78 2D 77 72 61 70 61 72 
1A57C78 	6F 75 6E 64 2D 71 68 91 
1A57C80 	B8 7B A5  1 20 40 A0  1 
   \ Find the end of the list, the node that points back to the beginning
   dup >r                ( thisqh r: qh0 )
1A57C88 	40 49 A0  1 BC 45 A0  1 
   begin                 ( thisqh r: qh0 )
      dup >qh-next l@    ( thisqh nextqh r: qh0 )
1A57C90 	40 49 A0  1 B0 70 A5  1 
1A57C98 	6C 4C A0  1 
   dup r@ <>  while      ( thisqh nextqh r: qh0 )
1A57C9C 	40 49 A0  1 
1A57CA0 	E4 45 A0  1 44 48 A0  1 
1A57CA8 	DC 41 A0  1 10  0  0  0 
      nip                ( thisqh' r: qh0 )
1A57CB0 	FC 46 A0  1 
   repeat                ( thisqh nextqh r: qh0 )
1A57CB4 	C8 41 A0  1 
1A57CB8 	D8 FF FF FF 

   drop
1A57CBC 	30 49 A0  1 
   \ Change that node's next pointers to skip the removed qh
   r> >qh-next l@        ( lastqh nextqh )
1A57CC0 	D0 45 A0  1 B0 70 A5  1 
1A57CC8 	6C 4C A0  1 
   swap                  ( nextqh lastqh )
1A57CCC 	68 49 A0  1 
   over >qh-phys l@      ( nextqh lastqh next-phys )
1A57CD0 	54 49 A0  1 98 70 A5  1 
1A57CD8 	6C 4C A0  1 
   over >hcqh-next le-l@ ( nextqh lastqh next-phys last-phys )
1A57CDC 	54 49 A0  1 
1A57CE0 	FC 6F A5  1 B8 35 A4  1 
   TYP_QH and or         ( nextqh lastqh next-phys' )
1A57CE8 	E4 67 A5  1 5C 44 A0  1 
1A57CF0 	70 44 A0  1 
   over >hcqh-next le-l! ( nextqh lastqh next-phys' )
1A57CF4 	54 49 A0  1 
1A57CF8 	FC 6F A5  1 50 36 A4  1 
   >qh-next l!           ( )
1A57D00 	B0 70 A5  1 7C 4D A0  1 
;
1A57D08 	58 46 A0  1 

: remove-qh  ( qh -- )
1A57D0C 	 0  0 72 65 
1A57D10 	6D 6F 76 65 2D 71 68 89 
1A57D18 	84 7C A5  1 20 40 A0  1 
   dup >qh-next l@ over =  if
1A57D20 	40 49 A0  1 B0 70 A5  1 
1A57D28 	6C 4C A0  1 54 49 A0  1 
1A57D30 	24 48 A0  1 DC 41 A0  1 
1A57D38 	14  0  0  0 
      \ If qh is the only qh in the system, disable-async and exit
      drop disable-async
1A57D3C 	30 49 A0  1 
1A57D40 	B0 7A A5  1 
   else
1A57D44 	C8 41 A0  1 
1A57D48 	F8  0  0  0 
      \ Otherwise, qh.prev points to qh.next, fix up reclamation bits.
      \ Ring doorbell, wait for answer.
      \ Free qh, make sure the qh-ptr is up-to-date.
      dup >qh-prev l@ ?dup if		( qh prev.qh )
1A57D4C 	40 49 A0  1 
1A57D50 	C8 70 A5  1 6C 4C A0  1 
1A57D58 	B4 70 A0  1 DC 41 A0  1 
1A57D60 	8C  0  0  0 
         over >hcqh-next le-l@ over >hcqh-next le-l!
1A57D64 	54 49 A0  1 
1A57D68 	FC 6F A5  1 B8 35 A4  1 
1A57D70 	54 49 A0  1 FC 6F A5  1 
1A57D78 	50 36 A4  1 
         over >qh-next l@ swap >qh-next l!
1A57D7C 	54 49 A0  1 
1A57D80 	B0 70 A5  1 6C 4C A0  1 
1A57D88 	68 49 A0  1 B0 70 A5  1 
1A57D90 	7C 4D A0  1 
         dup push-qh
1A57D94 	40 49 A0  1 
1A57D98 	AC 72 A5  1 
         dup >qh-next l@ qh-ptr <>  if
1A57D9C 	40 49 A0  1 
1A57DA0 	B0 70 A5  1 6C 4C A0  1 
1A57DA8 	98 72 A5  1 44 48 A0  1 
1A57DB0 	DC 41 A0  1 2C  0  0  0 
            dup >qh-prev l@ swap >qh-next l@ >qh-prev l!
1A57DB8 	40 49 A0  1 C8 70 A5  1 
1A57DC0 	6C 4C A0  1 68 49 A0  1 
1A57DC8 	B0 70 A5  1 6C 4C A0  1 
1A57DD0 	C8 70 A5  1 7C 4D A0  1 
         else
1A57DD8 	C8 41 A0  1  8  0  0  0 
            drop
1A57DE0 	30 49 A0  1 
         then
      else                          ( qh )
1A57DE4 	C8 41 A0  1 
1A57DE8 	54  0  0  0 
         dup >qh-next l@ to qh-ptr  ( qh )
1A57DEC 	40 49 A0  1 
1A57DF0 	B0 70 A5  1 6C 4C A0  1 
1A57DF8 	B8 40 A0  1 98 72 A5  1 
         qh-ptr >hcqh-endp-char dup le-l@ QH_HEAD or swap le-l!  ( qh )
1A57E00 	98 72 A5  1 18 70 A5  1 
1A57E08 	40 49 A0  1 B8 35 A4  1 
1A57E10 	C8 71 A5  1 70 44 A0  1 
1A57E18 	68 49 A0  1 50 36 A4  1 
         fix-wraparound-qh          ( )
1A57E20 	84 7C A5  1 
         0 qh-ptr >qh-prev l!       ( )
1A57E24 	70 6F A0  1 
1A57E28 	98 72 A5  1 C8 70 A5  1 
1A57E30 	7C 4D A0  1 
	 qh-ptr push-qh
1A57E34 	98 72 A5  1 
1A57E38 	AC 72 A5  1 
      then
      ring-doorbell
1A57E3C 	F4 62 A5  1 
   then
;
1A57E40 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Interrupt scheduling
\ XXX Make it simple for now and igore interval and make it a fixed poll
\ XXX interval.
\
\ Empirically, the 4 ms poll interval works optimally with the usb keyboard.
\ ---------------------------------------------------------------------------

\ Isochronous count
0 value #iso
1A57E44 	 0  0  0 23 
1A57E48 	69 73 6F 84 1C 7D A5  1 
1A57E50 	50 40 A0  1 20  F  0  0 
: #iso++  ( -- )  #iso 1+ to #iso  ;
1A57E58 	 0 23 69 73 6F 2B 2B 86 
1A57E60 	50 7E A5  1 20 40 A0  1 
1A57E68 	50 7E A5  1 30 4B A0  1 
1A57E70 	B8 40 A0  1 50 7E A5  1 
1A57E78 	58 46 A0  1 
: #iso--  ( -- )  #iso 1- to #iso  ;
1A57E7C 	 0 23 69 73 
1A57E80 	6F 2D 2D 86 64 7E A5  1 
1A57E88 	20 40 A0  1 50 7E A5  1 
1A57E90 	54 4B A0  1 B8 40 A0  1 
1A57E98 	50 7E A5  1 58 46 A0  1 

\ Interrupt count
0 value #intr
1A57EA0 	 0  0 23 69 6E 74 72 85 
1A57EA8 	88 7E A5  1 50 40 A0  1 
1A57EB0 	24  F  0  0 
d# 32 constant intr-interval		\ 4 ms poll interval
1A57EB4 	 0  0 69 6E 
1A57EB8 	74 72 2D 69 6E 74 65 72 
1A57EC0 	76 61 6C 8D AC 7E A5  1 
1A57EC8 	68 40 A0  1 20  0  0  0 

: #intr++  ( -- )  #intr 1+ to #intr  ;
1A57ED0 	23 69 6E 74 72 2B 2B 87 
1A57ED8 	C8 7E A5  1 20 40 A0  1 
1A57EE0 	AC 7E A5  1 30 4B A0  1 
1A57EE8 	B8 40 A0  1 AC 7E A5  1 
1A57EF0 	58 46 A0  1 
: #intr--  ( -- )  #intr 1- to #intr  ;
1A57EF4 	23 69 6E 74 
1A57EF8 	72 2D 2D 87 DC 7E A5  1 
1A57F00 	20 40 A0  1 AC 7E A5  1 
1A57F08 	54 4B A0  1 B8 40 A0  1 
1A57F10 	AC 7E A5  1 58 46 A0  1 

: periodic-wait  ( -- )
1A57F18 	 0  0 70 65 72 69 6F 64 
1A57F20 	69 63 2D 77 61 69 74 8D 
1A57F28 	 0 7F A5  1 20 40 A0  1 
   begin
      usbcmd@ h# 10 and  4 >>  usbsts@ h# 4000 and d# 14 >> 
1A57F30 	64 5E A5  1 58 41 A0  1 
1A57F38 	10  0  0  0 5C 44 A0  1 
1A57F40 	B0 6F A0  1 DC 44 A0  1 
1A57F48 	BC 5E A5  1 58 41 A0  1 
1A57F50 	 0 40  0  0 5C 44 A0  1 
1A57F58 	58 41 A0  1  E  0  0  0 
1A57F60 	DC 44 A0  1 
   = until
1A57F64 	24 48 A0  1 
1A57F68 	DC 41 A0  1 C4 FF FF FF 
;
1A57F70 	58 46 A0  1 
: enable-periodic  ( -- )
1A57F74 	65 6E 61 62 
1A57F78 	6C 65 2D 70 65 72 69 6F 
1A57F80 	64 69 63 8F 2C 7F A5  1 
1A57F88 	20 40 A0  1 
   periodic-wait  usbcmd@ h# 10 or usbcmd!  periodic-wait
1A57F8C 	2C 7F A5  1 
1A57F90 	64 5E A5  1 58 41 A0  1 
1A57F98 	10  0  0  0 70 44 A0  1 
1A57FA0 	80 5E A5  1 2C 7F A5  1 
;
1A57FA8 	58 46 A0  1 
: disable-periodic  ( -- )
1A57FAC 	 0  0  0 64 
1A57FB0 	69 73 61 62 6C 65 2D 70 
1A57FB8 	65 72 69 6F 64 69 63 90 
1A57FC0 	88 7F A5  1 20 40 A0  1 
   periodic-wait  usbcmd@ h# 10 invert and usbcmd!  periodic-wait
1A57FC8 	2C 7F A5  1 64 5E A5  1 
1A57FD0 	58 41 A0  1 10  0  0  0 
1A57FD8 	30 45 A0  1 5C 44 A0  1 
1A57FE0 	80 5E A5  1 2C 7F A5  1 
;
1A57FE8 	58 46 A0  1 

: (insert-intr-qh)  ( qh idx -- )
1A57FEC 	 0  0  0 28 
1A57FF0 	69 6E 73 65 72 74 2D 69 
1A57FF8 	6E 74 72 2D 71 68 29 90 
1A58000 	C4 7F A5  1 20 40 A0  1 
   dup >r				( qh idx )  ( R: idx )
1A58008 	40 49 A0  1 BC 45 A0  1 
   intr-tail@ ?dup 0=  if		( qh )  ( R: idx )
1A58010 	B0 6A A5  1 B4 70 A0  1 
1A58018 	24 47 A0  1 DC 41 A0  1 
1A58020 	34  0  0  0 
      dup r@ intr-head!			( qh )  ( R: idx )
1A58024 	40 49 A0  1 
1A58028 	E4 45 A0  1 8C 6A A5  1 
      dup >qh-phys l@ TYP_QH or r@ framelist!
1A58030 	40 49 A0  1 98 70 A5  1 
1A58038 	6C 4C A0  1 E4 67 A5  1 
1A58040 	70 44 A0  1 E4 45 A0  1 
1A58048 	18 69 A5  1 
					( qh )  ( R: idx )
   else					( qh tail )  ( R: idx )
1A5804C 	C8 41 A0  1 
1A58050 	3C  0  0  0 
      2dup >qh-next l!			( qh tail )  ( R: idx )
1A58054 	C0 49 A0  1 
1A58058 	B0 70 A5  1 7C 4D A0  1 
      over >qh-phys l@ TYP_QH or over >hcqh-next le-l!
1A58060 	54 49 A0  1 98 70 A5  1 
1A58068 	6C 4C A0  1 E4 67 A5  1 
1A58070 	70 44 A0  1 54 49 A0  1 
1A58078 	FC 6F A5  1 50 36 A4  1 
					(  qh tail )  ( R: idx )
      over >qh-prev l!			( qh )  ( R: idx )
1A58080 	54 49 A0  1 C8 70 A5  1 
1A58088 	7C 4D A0  1 
   then
   r> intr-tail!			( )
1A5808C 	D0 45 A0  1 
1A58090 	D4 6A A5  1 
;
1A58094 	58 46 A0  1 
: insert-intr-qh  ( qh speed interval -- )
1A58098 	 0 69 6E 73 65 72 74 2D 
1A580A0 	69 6E 74 72 2D 71 68 8E 
1A580A8 	 4 80 A5  1 20 40 A0  1 
   drop					( qh speed )
1A580B0 	30 49 A0  1 
   speed-high =  if  h# 0020  else  h# 1c01  then
1A580B4 	8C 2F A4  1 
1A580B8 	24 48 A0  1 DC 41 A0  1 
1A580C0 	14  0  0  0 58 41 A0  1 
1A580C8 	20  0  0  0 C8 41 A0  1 
1A580D0 	 C  0  0  0 58 41 A0  1 
1A580D8 	 1 1C  0  0 
   over >hcqh-endp-cap dup le-l@ rot or swap le-l!
1A580DC 	54 49 A0  1 
1A580E0 	34 70 A5  1 40 49 A0  1 
1A580E8 	B8 35 A4  1 7C 49 A0  1 
1A580F0 	70 44 A0  1 68 49 A0  1 
1A580F8 	50 36 A4  1 
   ( qh ) #framelist 0 do  dup i (insert-intr-qh)  intr-interval +loop  drop
1A580FC 	94 68 A5  1 
1A58100 	70 6F A0  1 88 42 A0  1 
1A58108 	1C  0  0  0 40 49 A0  1 
1A58110 	B4 42 A0  1  4 80 A5  1 
1A58118 	C8 7E A5  1 1C 42 A0  1 
1A58120 	EC FF FF FF 30 49 A0  1 
   #intr #iso or  0=  if  enable-periodic  then
1A58128 	AC 7E A5  1 50 7E A5  1 
1A58130 	70 44 A0  1 24 47 A0  1 
1A58138 	DC 41 A0  1  8  0  0  0 
1A58140 	88 7F A5  1 
   #intr++
1A58144 	DC 7E A5  1 
;
1A58148 	58 46 A0  1 

: (remove-intr-qh)  ( qh idx -- )
1A5814C 	 0  0  0 28 
1A58150 	72 65 6D 6F 76 65 2D 69 
1A58158 	6E 74 72 2D 71 68 29 90 
1A58160 	AC 80 A5  1 20 40 A0  1 
   >r					( qh )  ( R: idx )
1A58168 	BC 45 A0  1 
   dup >qh-prev l@ ?dup  if  over >qh-next l@ swap >qh-next l!  then
1A5816C 	40 49 A0  1 
1A58170 	C8 70 A5  1 6C 4C A0  1 
1A58178 	B4 70 A0  1 DC 41 A0  1 
1A58180 	1C  0  0  0 54 49 A0  1 
1A58188 	B0 70 A5  1 6C 4C A0  1 
1A58190 	68 49 A0  1 B0 70 A5  1 
1A58198 	7C 4D A0  1 
   dup >qh-next l@ ?dup  if  over >qh-prev l@ swap >qh-prev l!  then
1A5819C 	40 49 A0  1 
1A581A0 	B0 70 A5  1 6C 4C A0  1 
1A581A8 	B4 70 A0  1 DC 41 A0  1 
1A581B0 	1C  0  0  0 54 49 A0  1 
1A581B8 	C8 70 A5  1 6C 4C A0  1 
1A581C0 	68 49 A0  1 C8 70 A5  1 
1A581C8 	7C 4D A0  1 
   r@ intr-head@ over =  if		( qh )  ( R: idx )
1A581CC 	E4 45 A0  1 
1A581D0 	68 6A A5  1 54 49 A0  1 
1A581D8 	24 48 A0  1 DC 41 A0  1 
1A581E0 	4C  0  0  0 
      dup >qh-next l@ dup r@ intr-head!	( qh nqh )  ( R: idx )
1A581E4 	40 49 A0  1 
1A581E8 	B0 70 A5  1 6C 4C A0  1 
1A581F0 	40 49 A0  1 E4 45 A0  1 
1A581F8 	8C 6A A5  1 
      ?dup  if  >qh-phys l@ TYP_QH or  else  TERMINATE  then  r@ framelist!
1A581FC 	B4 70 A0  1 
1A58200 	DC 41 A0  1 1C  0  0  0 
1A58208 	98 70 A5  1 6C 4C A0  1 
1A58210 	E4 67 A5  1 70 44 A0  1 
1A58218 	C8 41 A0  1  8  0  0  0 
1A58220 	BC 67 A5  1 E4 45 A0  1 
1A58228 	18 69 A5  1 
					( qh )  ( R: idx )
   then
   r@ intr-tail@ over =  if		( qh )  ( R: idx )
1A5822C 	E4 45 A0  1 
1A58230 	B0 6A A5  1 54 49 A0  1 
1A58238 	24 48 A0  1 DC 41 A0  1 
1A58240 	18  0  0  0 
      dup >qh-prev l@ r@ intr-tail!	( qh )  ( R: idx )
1A58244 	40 49 A0  1 
1A58248 	C8 70 A5  1 6C 4C A0  1 
1A58250 	E4 45 A0  1 D4 6A A5  1 
   then
   r> 2drop
1A58258 	D0 45 A0  1 AC 49 A0  1 
;
1A58260 	58 46 A0  1 
: remove-intr-qh  ( qh -- )
1A58264 	 0 72 65 6D 
1A58268 	6F 76 65 2D 69 6E 74 72 
1A58270 	2D 71 68 8E 64 81 A5  1 
1A58278 	20 40 A0  1 
   #intr--
1A5827C 	 0 7F A5  1 
   ( qh ) #framelist 0  do  dup i (remove-intr-qh)  intr-interval +loop  drop
1A58280 	94 68 A5  1 70 6F A0  1 
1A58288 	88 42 A0  1 1C  0  0  0 
1A58290 	40 49 A0  1 B4 42 A0  1 
1A58298 	64 81 A5  1 C8 7E A5  1 
1A582A0 	1C 42 A0  1 EC FF FF FF 
1A582A8 	30 49 A0  1 
   #intr #iso or  0=  if  disable-periodic  then
1A582AC 	AC 7E A5  1 
1A582B0 	50 7E A5  1 70 44 A0  1 
1A582B8 	24 47 A0  1 DC 41 A0  1 
1A582C0 	 8  0  0  0 C4 7F A5  1 
;
1A582C8 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Wait for a QH to be done and process any errors.
\
\ When done? returns no error found yet, the caller should check if errors
\ were found in the TDs.
\ ---------------------------------------------------------------------------

: .qtd-error  ( cc -- )
1A582CC 	 0 2E 71 74 
1A582D0 	64 2D 65 72 72 6F 72 8A 
1A582D8 	78 82 A5  1 20 40 A0  1 
   dup TD_STAT_HALTED  and  if  " Stalled; "                USB_ERR_STALL       set-usb-error  then
1A582E0 	40 49 A0  1 78 6E A5  1 
1A582E8 	5C 44 A0  1 DC 41 A0  1 
1A582F0 	1C  0  0  0 9C 53 A0  1 
1A582F8 	 9 53 74 61 6C 6C 65 64 
1A58300 	3B 20  0  0 98 2C A4  1 
1A58308 	14 41 A4  1 
   dup TD_STAT_DBUFF   and  if  " Data Buffer Error; "      USB_ERR_DBUFERR     set-usb-error  then
1A5830C 	40 49 A0  1 
1A58310 	94 6E A5  1 5C 44 A0  1 
1A58318 	DC 41 A0  1 28  0  0  0 
1A58320 	9C 53 A0  1 13 44 61 74 
1A58328 	61 20 42 75 66 66 65 72 
1A58330 	20 45 72 72 6F 72 3B 20 
1A58338 	 0  0  0  0 F0 2D A4  1 
1A58340 	14 41 A4  1 
   dup TD_STAT_BABBLE  and  if  " Babble Detected; "        USB_ERR_BABBLE      set-usb-error  then
1A58344 	40 49 A0  1 
1A58348 	B0 6E A5  1 5C 44 A0  1 
1A58350 	DC 41 A0  1 24  0  0  0 
1A58358 	9C 53 A0  1 11 42 61 62 
1A58360 	62 6C 65 20 44 65 74 65 
1A58368 	63 74 65 64 3B 20  0  0 
1A58370 	 C 2E A4  1 14 41 A4  1 
   dup TD_STAT_XERR    and  if  " CRC/Timeout/Bad PID; "    USB_ERR_CRC         set-usb-error  then
1A58378 	40 49 A0  1 CC 6E A5  1 
1A58380 	5C 44 A0  1 DC 41 A0  1 
1A58388 	28  0  0  0 9C 53 A0  1 
1A58390 	15 43 52 43 2F 54 69 6D 
1A58398 	65 6F 75 74 2F 42 61 64 
1A583A0 	20 50 49 44 3B 20  0  0 
1A583A8 	34 2C A4  1 14 41 A4  1 
   dup TD_STAT_MISS_MF and  if  " Missed Micro-frame; "     USB_ERR_MICRO_FRAME set-usb-error  then
1A583B0 	40 49 A0  1 E8 6E A5  1 
1A583B8 	5C 44 A0  1 DC 41 A0  1 
1A583C0 	28  0  0  0 9C 53 A0  1 
1A583C8 	14 4D 69 73 73 65 64 20 
1A583D0 	4D 69 63 72 6F 2D 66 72 
1A583D8 	61 6D 65 3B 20  0  0  0 
1A583E0 	44 2E A4  1 14 41 A4  1 
   TD_STAT_SPLIT_ERR   and  if  " Periodic split-x error; " USB_ERR_SPLIT       set-usb-error  then
1A583E8 	74 6F A5  1 5C 44 A0  1 
1A583F0 	DC 41 A0  1 2C  0  0  0 
1A583F8 	9C 53 A0  1 18 50 65 72 
1A58400 	69 6F 64 69 63 20 73 70 
1A58408 	6C 69 74 2D 78 20 65 72 
1A58410 	72 6F 72 3B 20  0  0  0 
1A58418 	60 2E A4  1 14 41 A4  1 
;
1A58420 	58 46 A0  1 

: qtd-done?  ( qtd -- done? )
1A58424 	 0  0 71 74 
1A58428 	64 2D 64 6F 6E 65 3F 89 
1A58430 	DC 82 A5  1 20 40 A0  1 
   >hcqtd-token le-l@  TD_STAT_ACTIVE and  0=
1A58438 	74 6B A5  1 B8 35 A4  1 
1A58440 	5C 6E A5  1 5C 44 A0  1 
1A58448 	24 47 A0  1 
;
1A5844C 	58 46 A0  1 

[ifdef] notdef
\ This version looks for the ending condition in the transfer overlay
: qh-done?  ( qh -- done? )
   hc-interrupt? 0=  if  drop false exit  then   ( qh )
   dup pull-qh                    ( qh )
   dup >hcqh-cur-pqtd l@  0=  if  ( qh )
      drop false exit             ( -- done? )
   then                           ( qh )
   >hcqh-overlay               ( qtd )
   dup >hcqtd-token le-l@      ( qtd token )
   dup TD_STAT_ACTIVE and  if  ( qtd token )
      2drop false              ( done? )
   else                        ( qtd token )
      TD_STAT_HALTED and  if   ( qtd )
         drop true             ( done? )
      else                     ( qtd )
         >hcqtd-next le-l@     ( next )
	 TERMINATE =           ( done? )
      then                     ( done? )
   then                        ( done? )
;
[then]

\ This version traverses the list of QTDs, looking for an ending condition
: qh-done?  ( qh -- done? )
1A58450 	 0  0  0 71 68 2D 64 6F 
1A58458 	6E 65 3F 88 34 84 A5  1 
1A58460 	20 40 A0  1 
   dup pull-qh      ( qh )
1A58464 	40 49 A0  1 
1A58468 	D4 72 A5  1 
\   d# 30 us         ( qh )
   /qh +                                      ( qtd )
1A5846C 	98 71 A5  1 
1A58470 	 4 45 A0  1 
   begin                                      ( qtd )
      dup >hcqtd-token le-l@                  ( qtd token )
1A58474 	40 49 A0  1 
1A58478 	74 6B A5  1 B8 35 A4  1 
      dup TD_STAT_ACTIVE and  0=              ( qtd token qtd-complete? )
1A58480 	40 49 A0  1 5C 6E A5  1 
1A58488 	5C 44 A0  1 24 47 A0  1 
   while                                      ( qtd token )
1A58490 	DC 41 A0  1 58  0  0  0 
      \ This QTD is complete - it is the end of the list if either
      \ the next field is TERMINATE or if the HALTED bit is set
      TD_STAT_HALTED and  if                  ( qtd )
1A58498 	78 6E A5  1 5C 44 A0  1 
1A584A0 	DC 41 A0  1 10  0  0  0 
         drop true exit                       ( -- done? )
1A584A8 	30 49 A0  1  4 70 A0  1 
1A584B0 	40 46 A0  1 
      then                                    ( qtd )
      dup >hcqtd-next le-l@ TERMINATE =  if   ( qtd )
1A584B4 	40 49 A0  1 
1A584B8 	3C 6B A5  1 B8 35 A4  1 
1A584C0 	BC 67 A5  1 24 48 A0  1 
1A584C8 	DC 41 A0  1 10  0  0  0 
         drop true exit                       ( -- done? )
1A584D0 	30 49 A0  1  4 70 A0  1 
1A584D8 	40 46 A0  1 
      then                                    ( qtd )
      /qtd +                                  ( qtd' )
1A584DC 	 C 6D A5  1 
1A584E0 	 4 45 A0  1 
   repeat                                     ( qtd token )
1A584E4 	C8 41 A0  1 
1A584E8 	8C FF FF FF 
   \ If we get here, we hit a QTD that is still active
   2drop false                                ( done? )
1A584EC 	AC 49 A0  1 
1A584F0 	18 70 A0  1 
;
1A584F4 	58 46 A0  1 

: intr-qh-done?  ( qh -- done? )
1A584F8 	 0  0 69 6E 74 72 2D 71 
1A58500 	68 2D 64 6F 6E 65 3F 8D 
1A58508 	60 84 A5  1 20 40 A0  1 
   hc-interrupt?  if   ( qh )
1A58510 	B0 61 A5  1 DC 41 A0  1 
1A58518 	10  0  0  0 
      qh-done?         ( done? )
1A5851C 	60 84 A5  1 
   else                ( qh )
1A58520 	C8 41 A0  1  C  0  0  0 
      drop false       ( done? )
1A58528 	30 49 A0  1 18 70 A0  1 
   then                ( done? )
;
1A58530 	58 46 A0  1 

: qtd-error?  ( qtd qh -- usberr )
1A58534 	 0 71 74 64 
1A58538 	2D 65 72 72 6F 72 3F 8A 
1A58540 	 C 85 A5  1 20 40 A0  1 
   >hcqh-endp-char le-l@ d# 12 >> 3 and         ( qtd speed )
1A58548 	18 70 A5  1 B8 35 A4  1 
1A58550 	58 41 A0  1  C  0  0  0 
1A58558 	DC 44 A0  1 A0 6F A0  1 
1A58560 	5C 44 A0  1 
   speed-high =  if  h# fc  else  h# fd  then   ( qtd error-mask )
1A58564 	8C 2F A4  1 
1A58568 	24 48 A0  1 DC 41 A0  1 
1A58570 	14  0  0  0 58 41 A0  1 
1A58578 	FC  0  0  0 C8 41 A0  1 
1A58580 	 C  0  0  0 58 41 A0  1 
1A58588 	FD  0  0  0 
   swap >hcqtd-token le-l@  and ?dup  if  .qtd-error  then
1A5858C 	68 49 A0  1 
1A58590 	74 6B A5  1 B8 35 A4  1 
1A58598 	5C 44 A0  1 B4 70 A0  1 
1A585A0 	DC 41 A0  1  8  0  0  0 
1A585A8 	DC 82 A5  1 
   usb-error
1A585AC 	D0 40 A4  1 
;
1A585B0 	58 46 A0  1 

: qh-error?  ( qh -- usberr )  dup >hcqh-overlay  swap  qtd-error?   ;
1A585B4 	 0  0 71 68 
1A585B8 	2D 65 72 72 6F 72 3F 89 
1A585C0 	44 85 A5  1 20 40 A0  1 
1A585C8 	40 49 A0  1 6C 70 A5  1 
1A585D0 	68 49 A0  1 44 85 A5  1 
1A585D8 	58 46 A0  1 

: done-error?  ( qh -- usberr )
1A585DC 	64 6F 6E 65 
1A585E0 	2D 65 72 72 6F 72 3F 8B 
1A585E8 	C4 85 A5  1 20 40 A0  1 
   dup >qh-timeout l@  get-msecs +   ( qh timeout )
1A585F0 	40 49 A0  1 88 71 A5  1 
1A585F8 	6C 4C A0  1 50 E0 A1  1 
1A58600 	 4 45 A0  1 
   begin  over intr-qh-done?  0=  while   ( qh timeout )
1A58604 	54 49 A0  1 
1A58608 	 C 85 A5  1 24 47 A0  1 
1A58610 	DC 41 A0  1 70  0  0  0 
      usb-error ?dup if  ." USB ERROR " . cr  then
1A58618 	D0 40 A4  1 B4 70 A0  1 
1A58620 	DC 41 A0  1 1C  0  0  0 
1A58628 	20 7C A0  1  A 55 53 42 
1A58630 	20 45 52 52 4F 52 20  0 
1A58638 	94 7A A0  1 80 6D A0  1 
      dup get-msecs - 0<  if         ( qh timeout )
1A58640 	40 49 A0  1 50 E0 A1  1 
1A58648 	18 45 A0  1 64 47 A0  1 
1A58650 	DC 41 A0  1 28  0  0  0 
         " Timeout" USB_ERR_TIMEOUT set-usb-error ( qh timeout )
1A58658 	9C 53 A0  1  7 54 69 6D 
1A58660 	65 6F 75 74  0  0  0  0 
1A58668 	B8 2E A4  1 14 41 A4  1 
         2drop                       ( )
1A58670 	AC 49 A0  1 
         usb-error                   ( usberr )
1A58674 	D0 40 A4  1 
         exit
1A58678 	40 46 A0  1 
      then                           ( qh timeout )
   repeat                            ( qh timeout )
1A5867C 	C8 41 A0  1 
1A58680 	84 FF FF FF 
   drop                              ( qh )
1A58684 	30 49 A0  1 

   qh-error?	                     ( usberr )
1A58688 	C4 85 A5  1 
;
1A5868C 	58 46 A0  1 

: get-actual  ( qtd #qtd -- actual )
1A58690 	 0 67 65 74 2D 61 63 74 
1A58698 	75 61 6C 8A EC 85 A5  1 
1A586A0 	20 40 A0  1 
   0 -rot 0  ?do			( actual qtd )
1A586A4 	70 6F A0  1 
1A586A8 	94 49 A0  1 70 6F A0  1 
1A586B0 	50 42 A0  1 84  0  0  0 
      dup pull-qtd			( actual qtd )
1A586B8 	40 49 A0  1 2C 73 A5  1 
      dup >hcqtd-token le-l@ dup TD_STAT_ACTIVE and 0=  if
1A586C0 	40 49 A0  1 74 6B A5  1 
1A586C8 	B8 35 A4  1 40 49 A0  1 
1A586D0 	5C 6E A5  1 5C 44 A0  1 
1A586D8 	24 47 A0  1 DC 41 A0  1 
1A586E0 	44  0  0  0 
         over >qtd-/buf l@		( actual qtd token len )
1A586E4 	54 49 A0  1 
1A586E8 	A8 6C A5  1 6C 4C A0  1 
         swap d# 16 >> h# 7fff and -	( actual qtd len' )
1A586F0 	68 49 A0  1 58 41 A0  1 
1A586F8 	10  0  0  0 DC 44 A0  1 
1A58700 	58 41 A0  1 FF 7F  0  0 
1A58708 	5C 44 A0  1 18 45 A0  1 
         rot + swap			( actual' qtd )
1A58710 	7C 49 A0  1  4 45 A0  1 
1A58718 	68 49 A0  1 
      else
1A5871C 	C8 41 A0  1 
1A58720 	 8  0  0  0 
         drop				( actual qtd )
1A58724 	30 49 A0  1 
      then
      >qtd-next l@			( actual qtd )
1A58728 	60 6C A5  1 6C 4C A0  1 
   loop  drop				( qtd )
1A58730 	F8 41 A0  1 84 FF FF FF 
1A58738 	30 49 A0  1 
;
1A5873C 	58 46 A0  1 

: qtd-get-actual  ( qtd -- actual )
1A58740 	 0 71 74 64 2D 67 65 74 
1A58748 	2D 61 63 74 75 61 6C 8E 
1A58750 	A0 86 A5  1 20 40 A0  1 
   0 swap  begin			( actual qtd )
1A58758 	70 6F A0  1 68 49 A0  1 
      dup pull-qtd			( actual qtd )
1A58760 	40 49 A0  1 2C 73 A5  1 
      dup >hcqtd-token le-l@ dup TD_STAT_ACTIVE and 0=  if
1A58768 	40 49 A0  1 74 6B A5  1 
1A58770 	B8 35 A4  1 40 49 A0  1 
1A58778 	5C 6E A5  1 5C 44 A0  1 
1A58780 	24 47 A0  1 DC 41 A0  1 
1A58788 	44  0  0  0 
         over >qtd-/buf l@		( actual qtd token len )
1A5878C 	54 49 A0  1 
1A58790 	A8 6C A5  1 6C 4C A0  1 
         swap d# 16 >> h# 7fff and -	( actual qtd len' )
1A58798 	68 49 A0  1 58 41 A0  1 
1A587A0 	10  0  0  0 DC 44 A0  1 
1A587A8 	58 41 A0  1 FF 7F  0  0 
1A587B0 	5C 44 A0  1 18 45 A0  1 
         rot + swap			( actual' qtd )
1A587B8 	7C 49 A0  1  4 45 A0  1 
1A587C0 	68 49 A0  1 
      else
1A587C4 	C8 41 A0  1 
1A587C8 	 8  0  0  0 
         drop				( actual qtd )
1A587CC 	30 49 A0  1 
      then
      dup >hcqtd-next l@		( actual qtd next )
1A587D0 	40 49 A0  1 3C 6B A5  1 
1A587D8 	6C 4C A0  1 
      over >hcqtd-next-alt l@		( actual qtd next alt-next )
1A587DC 	54 49 A0  1 
1A587E0 	58 6B A5  1 6C 4C A0  1 
   <> while
1A587E8 	44 48 A0  1 DC 41 A0  1 
1A587F0 	14  0  0  0 
      \ If next and alt differ, the next one is part of the same transaction.
      \ If they are the same, it's a different transaction
      >qtd-next l@			( actual qtd' )
1A587F4 	60 6C A5  1 
1A587F8 	6C 4C A0  1 
   repeat  drop				( actual )
1A587FC 	C8 41 A0  1 
1A58800 	60 FF FF FF 30 49 A0  1 
;
1A58808 	58 46 A0  1 

\ ---------------------------------------------------------------------------
\ Allocate a dummy qh to be head of the queue to get around the fact that
\ the VIA 2.0 controller does not stop async when told to.
\ ---------------------------------------------------------------------------

0 value dummy-qh
1A5880C 	 0  0  0 64 
1A58810 	75 6D 6D 79 2D 71 68 88 
1A58818 	54 87 A5  1 50 40 A0  1 
1A58820 	28  F  0  0 

: alloc-dummy-qh  ( -- )
1A58824 	 0 61 6C 6C 
1A58828 	6F 63 2D 64 75 6D 6D 79 
1A58830 	2D 71 68 8E 1C 88 A5  1 
1A58838 	20 40 A0  1 
   dummy-qh 0=  if
1A5883C 	1C 88 A5  1 
1A58840 	24 47 A0  1 DC 41 A0  1 
1A58848 	2C  0  0  0 
      1 alloc-qhqtds			( qh qtd )
1A5884C 	80 6F A0  1 
1A58850 	40 76 A5  1 
      drop to dummy-qh
1A58854 	30 49 A0  1 
1A58858 	B8 40 A0  1 1C 88 A5  1 
      TERMINATE dummy-qh >hcqh-overlay >hcqtd-next le-l!
1A58860 	BC 67 A5  1 1C 88 A5  1 
1A58868 	6C 70 A5  1 3C 6B A5  1 
1A58870 	50 36 A4  1 
   then
   0 to qh-ptr
1A58874 	70 6F A0  1 
1A58878 	B8 40 A0  1 98 72 A5  1 
   dummy-qh insert-qh
1A58880 	1C 88 A5  1 B8 7B A5  1 
;
1A58888 	58 46 A0  1 

: free-dummy-qh  ( -- )
1A5888C 	 0  0 66 72 
1A58890 	65 65 2D 64 75 6D 6D 79 
1A58898 	2D 71 68 8D 38 88 A5  1 
1A588A0 	20 40 A0  1 
   dummy-qh ?dup  if  free-qh  0 to dummy-qh  then
1A588A4 	1C 88 A5  1 
1A588A8 	B4 70 A0  1 DC 41 A0  1 
1A588B0 	14  0  0  0 F4 75 A5  1 
1A588B8 	70 6F A0  1 B8 40 A0  1 
1A588C0 	1C 88 A5  1 
;
1A588C4 	58 46 A0  1 


: ?alloc-dummy-qh  ( -- )
1A588C8 	3F 61 6C 6C 6F 63 2D 64 
1A588D0 	75 6D 6D 79 2D 71 68 8F 
1A588D8 	A0 88 A5  1 20 40 A0  1 
   needs-dummy-qh?  if  alloc-dummy-qh  then
1A588E0 	14 59 A5  1 DC 41 A0  1 
1A588E8 	 8  0  0  0 38 88 A5  1 
;
1A588F0 	58 46 A0  1 

\ The words this calls are written so they can be called again
\ on resume from S3 state without causing redundant memory allocation.
: (init-extra)  ( -- )
1A588F4 	 0  0  0 28 
1A588F8 	69 6E 69 74 2D 65 78 74 
1A58900 	72 61 29 8C DC 88 A5  1 
1A58908 	20 40 A0  1 
   ?alloc-dummy-qh
1A5890C 	DC 88 A5  1 
   init-intr
1A58910 	F8 6A A5  1 
   init-framelist
1A58914 	48 69 A5  1 
;
1A58918 	58 46 A0  1 

' (init-extra) to init-extra

headers

OpenFirmware/dev/usb2/hcd/ehci/qhtd.fth_AL	2170 1A5891C purpose: EHCI USB Controller control pipe transaction processing

hex
headers

\ Local temporary variables (common for control, bulk & interrupt)

\ my-dev and my-real-dev are created here to deal with set-address.
\ Normally my-dev and my-real-dev are both of the value of target.
\ However, during set-address, target=my-dev=0, my-real-dev is the
\ address to be assigned to my-real-dev.  The correct path to get
\ a device's characteristics is via my-real-dev.

0 value my-dev					\ Equals to target
1A5891C 	 0 6D 79 2D 
1A58920 	64 65 76 86  8 89 A5  1 
1A58928 	50 40 A0  1 2C  F  0  0 
0 value my-real-dev				\ Path to dev's characteristics
1A58930 	6D 79 2D 72 65 61 6C 2D 
1A58938 	64 65 76 8B 28 89 A5  1 
1A58940 	50 40 A0  1 30  F  0  0 
0 value my-dev/pipe				\ Device/pipe for ED
1A58948 	6D 79 2D 64 65 76 2F 70 
1A58950 	69 70 65 8B 40 89 A5  1 
1A58958 	50 40 A0  1 34  F  0  0 

0 value my-speed				\ Speed of my-real-dev
1A58960 	 0  0  0 6D 79 2D 73 70 
1A58968 	65 65 64 88 58 89 A5  1 
1A58970 	50 40 A0  1 38  F  0  0 
0 value my-maxpayload				\ Pipe's max payload
1A58978 	 0  0 6D 79 2D 6D 61 78 
1A58980 	70 61 79 6C 6F 61 64 8D 
1A58988 	70 89 A5  1 50 40 A0  1 
1A58990 	3C  F  0  0 

0 value my-#qtds				\ # of input or output qTDs
1A58994 	 0  0  0 6D 
1A58998 	79 2D 23 71 74 64 73 88 
1A589A0 	8C 89 A5  1 50 40 A0  1 
1A589A8 	40  F  0  0 

0 value my-buf					\ Virtual address of data buffer
1A589AC 	 0 6D 79 2D 
1A589B0 	62 75 66 86 A4 89 A5  1 
1A589B8 	50 40 A0  1 44  F  0  0 
0 value my-buf-phys				\ Physical address of data buffer
1A589C0 	6D 79 2D 62 75 66 2D 70 
1A589C8 	68 79 73 8B B8 89 A5  1 
1A589D0 	50 40 A0  1 48  F  0  0 
0 value /my-buf					\ Size of data buffer
1A589D8 	2F 6D 79 2D 62 75 66 87 
1A589E0 	D0 89 A5  1 50 40 A0  1 
1A589E8 	4C  F  0  0 
0 value my-dir					\ Direction (in or out)
1A589EC 	 0 6D 79 2D 
1A589F0 	64 69 72 86 E4 89 A5  1 
1A589F8 	50 40 A0  1 50  F  0  0 

0 value my-qtd					\ Current TD head
1A58A00 	 0 6D 79 2D 71 74 64 86 
1A58A08 	F8 89 A5  1 50 40 A0  1 
1A58A10 	54  F  0  0 
0 value my-qh					\ Current QH
1A58A14 	 0  0 6D 79 
1A58A18 	2D 71 68 85  C 8A A5  1 
1A58A20 	50 40 A0  1 58  F  0  0 

: set-real-dev  ( real-dev target -- )		\ For set-address only
1A58A28 	 0  0  0 73 65 74 2D 72 
1A58A30 	65 61 6C 2D 64 65 76 8C 
1A58A38 	20 8A A5  1 20 40 A0  1 
   to my-dev to my-real-dev
1A58A40 	B8 40 A0  1 28 89 A5  1 
1A58A48 	B8 40 A0  1 40 89 A5  1 
;
1A58A50 	58 46 A0  1 
\- set-my-dev defer set-my-dev

: set-my-char  ( pipe -- )
1A58A54 	73 65 74 2D 
1A58A58 	6D 79 2D 63 68 61 72 8B 
1A58A60 	3C 8A A5  1 20 40 A0  1 
   dup 8 << my-dev or to my-dev/pipe		( pipe )
1A58A68 	40 49 A0  1 F0 6F A0  1 
1A58A70 	C8 44 A0  1 28 89 A5  1 
1A58A78 	70 44 A0  1 B8 40 A0  1 
1A58A80 	58 89 A5  1 
   my-real-dev dup di-speed@  to my-speed	( pipe dev )
1A58A84 	40 89 A5  1 
1A58A88 	40 49 A0  1  4 43 A4  1 
1A58A90 	B8 40 A0  1 70 89 A5  1 
   di-maxpayload@  to my-maxpayload		( )
1A58A98 	60 44 A4  1 B8 40 A0  1 
1A58AA0 	8C 89 A5  1 
;
1A58AA4 	58 46 A0  1 
: process-control-args  ( buf phy len -- )
1A58AA8 	 0  0  0 70 72 6F 63 65 
1A58AB0 	73 73 2D 63 6F 6E 74 72 
1A58AB8 	6F 6C 2D 61 72 67 73 94 
1A58AC0 	64 8A A5  1 20 40 A0  1 
   to /my-buf to my-buf-phys to my-buf
1A58AC8 	B8 40 A0  1 E4 89 A5  1 
1A58AD0 	B8 40 A0  1 D0 89 A5  1 
1A58AD8 	B8 40 A0  1 B8 89 A5  1 
   clear-usb-error
1A58AE0 	EC 40 A4  1 
   set-my-dev
1A58AE4 	14 52 A4  1 
   0 set-my-char
1A58AE8 	70 6F A0  1 64 8A A5  1 
;
1A58AF0 	58 46 A0  1 

: alloc-control-qhqtds  ( extra-qtds -- )
1A58AF4 	 0  0  0 61 
1A58AF8 	6C 6C 6F 63 2D 63 6F 6E 
1A58B00 	74 72 6F 6C 2D 71 68 71 
1A58B08 	74 64 73 94 C4 8A A5  1 
1A58B10 	20 40 A0  1 
   >r						( r: extra-qtds )
1A58B14 	BC 45 A0  1 
   my-buf-phys /my-buf cal-#qtd dup to my-#qtds	( #data-qtds r: extra-qtds )
1A58B18 	D0 89 A5  1 E4 89 A5  1 
1A58B20 	F4 78 A5  1 40 49 A0  1 
1A58B28 	B8 40 A0  1 A4 89 A5  1 
   dup r> + alloc-qhqtds  to my-qtd  to my-qh	( #data-qtds )
1A58B30 	40 49 A0  1 D0 45 A0  1 
1A58B38 	 4 45 A0  1 40 76 A5  1 
1A58B40 	B8 40 A0  1  C 8A A5  1 
1A58B48 	B8 40 A0  1 20 8A A5  1 
   if  data-timeout  else  nodata-timeout  then	( timeout )
1A58B50 	DC 41 A0  1 10  0  0  0 
1A58B58 	 8 3C A4  1 C8 41 A0  1 
1A58B60 	 8  0  0  0 EC 3B A4  1 
   my-qh >qh-timeout l!				( )
1A58B68 	20 8A A5  1 88 71 A5  1 
1A58B70 	7C 4D A0  1 
;
1A58B74 	58 46 A0  1 

: fill-qh  ( qh pipetype -- )
1A58B78 	66 69 6C 6C 2D 71 68 87 
1A58B80 	10 8B A5  1 20 40 A0  1 
   my-speed  dup d# 12 <<			( qh pipetype speed endp-char )
1A58B88 	70 89 A5  1 40 49 A0  1 
1A58B90 	58 41 A0  1  C  0  0  0 
1A58B98 	C8 44 A0  1 
   QH_TD_TOGGLE or my-dev/pipe or		( qh pipetype speed endp-char' )
1A58B9C 	E4 71 A5  1 
1A58BA0 	70 44 A0  1 58 89 A5  1 
1A58BA8 	70 44 A0  1 
   swap speed-high =  if			( qh pipetype endp-char' )
1A58BAC 	68 49 A0  1 
1A58BB0 	8C 2F A4  1 24 48 A0  1 
1A58BB8 	DC 41 A0  1 84  0  0  0 
      QH_TUNE_RL_HS or				( qh pipetype endp-char' )
1A58BC0 	20 72 A5  1 70 44 A0  1 
      swap  case				( qh endp-char pipetype )
1A58BC8 	68 49 A0  1 
         pt-ctrl  of  QH_MULT1  d#  64  endof	( qh endp-char endp-cap /max )
1A58BCC 	28 68 A5  1 
1A58BD0 	48 43 A0  1 18  0  0  0 
1A58BD8 	54 72 A5  1 58 41 A0  1 
1A58BE0 	40  0  0  0 6C 43 A0  1 
1A58BE8 	38  0  0  0 
         pt-bulk  of  QH_MULT1  d# 512  endof	( qh endp-char endp-cap /max )
1A58BEC 	3C 68 A5  1 
1A58BF0 	48 43 A0  1 18  0  0  0 
1A58BF8 	54 72 A5  1 58 41 A0  1 
1A58C00 	 0  2  0  0 6C 43 A0  1 
1A58C08 	18  0  0  0 
         ( default )  >r QH_MULT1  my-maxpayload r>
1A58C0C 	BC 45 A0  1 
1A58C10 	54 72 A5  1 8C 89 A5  1 
1A58C18 	D0 45 A0  1 
						( qh endp-char endp-cap /max )
      endcase
1A58C1C 	84 43 A0  1 
      d# 16 << rot or swap			( qh endp-char endp-cap )
1A58C20 	58 41 A0  1 10  0  0  0 
1A58C28 	C8 44 A0  1 7C 49 A0  1 
1A58C30 	70 44 A0  1 68 49 A0  1 
   else						( qh pipetype endp-char )
1A58C38 	C8 41 A0  1 70  0  0  0 
      swap pt-ctrl =  if  QH_CTRL_ENDP or  then	( qh endp-char' )
1A58C40 	68 49 A0  1 28 68 A5  1 
1A58C48 	24 48 A0  1 DC 41 A0  1 
1A58C50 	 C  0  0  0 B4 71 A5  1 
1A58C58 	70 44 A0  1 
      my-maxpayload d# 16 << or			( qh endp-char' )
1A58C5C 	8C 89 A5  1 
1A58C60 	58 41 A0  1 10  0  0  0 
1A58C68 	C8 44 A0  1 70 44 A0  1 
      QH_TUNE_RL_TT or				( qh endp-char' )
1A58C70 	3C 72 A5  1 70 44 A0  1 
      QH_MULT1					( qh endp-char endp-cap )
1A58C78 	54 72 A5  1 
      my-real-dev di-port@ d# 23 << or		( qh endp-char endp-cap' )
1A58C7C 	40 89 A5  1 
1A58C80 	8C 43 A4  1 58 41 A0  1 
1A58C88 	17  0  0  0 C8 44 A0  1 
1A58C90 	70 44 A0  1 
      my-real-dev di-hub@ d# 16 << or		( qh endp-char endp-cap' )
1A58C94 	40 89 A5  1 
1A58C98 	44 43 A4  1 58 41 A0  1 
1A58CA0 	10  0  0  0 C8 44 A0  1 
1A58CA8 	70 44 A0  1 
   then						( qh endp-char endp-cap )
   2 pick >hcqh-endp-cap le-l!			( qh endp-char )
1A58CAC 	90 6F A0  1 
1A58CB0 	 C 4A A0  1 34 70 A5  1 
1A58CB8 	50 36 A4  1 
   swap >hcqh-endp-char le-l!			( )
1A58CBC 	68 49 A0  1 
1A58CC0 	18 70 A5  1 50 36 A4  1 
;
1A58CC8 	58 46 A0  1 

: fill-setup-qtd  ( sbuf sphys slen -- )
1A58CCC 	 0 66 69 6C 
1A58CD0 	6C 2D 73 65 74 75 70 2D 
1A58CD8 	71 74 64 8E 84 8B A5  1 
1A58CE0 	20 40 A0  1 
   dup d# 16 << TD_TOGGLE_DATA0 or TD_C_ERR3 or TD_PID_SETUP or TD_STAT_ACTIVE or
1A58CE4 	40 49 A0  1 
1A58CE8 	58 41 A0  1 10  0  0  0 
1A58CF0 	C8 44 A0  1 28 6D A5  1 
1A58CF8 	70 44 A0  1 D8 6D A5  1 
1A58D00 	70 44 A0  1 24 6E A5  1 
1A58D08 	70 44 A0  1 5C 6E A5  1 
1A58D10 	70 44 A0  1 
   my-qtd tuck >hcqtd-token le-l!
1A58D14 	 C 8A A5  1 
1A58D18 	E8 46 A0  1 74 6B A5  1 
1A58D20 	50 36 A4  1 
   fill-qtd-bptrs  drop
1A58D24 	44 79 A5  1 
1A58D28 	30 49 A0  1 
;
1A58D2C 	58 46 A0  1 

: my-buf++  ( len -- )
1A58D30 	 0  0  0 6D 79 2D 62 75 
1A58D38 	66 2B 2B 88 E0 8C A5  1 
1A58D40 	20 40 A0  1 
   /my-buf min				( len' )
1A58D44 	E4 89 A5  1 
1A58D48 	74 4A A0  1 
   /my-buf     over - to /my-buf	( len )
1A58D4C 	E4 89 A5  1 
1A58D50 	54 49 A0  1 18 45 A0  1 
1A58D58 	B8 40 A0  1 E4 89 A5  1 
   my-buf-phys over + to my-buf-phys	( len )
1A58D60 	D0 89 A5  1 54 49 A0  1 
1A58D68 	 4 45 A0  1 B8 40 A0  1 
1A58D70 	D0 89 A5  1 
   my-buf      swap + to my-buf		( )
1A58D74 	B8 89 A5  1 
1A58D78 	68 49 A0  1  4 45 A0  1 
1A58D80 	B8 40 A0  1 B8 89 A5  1 
;
1A58D88 	58 46 A0  1 
: fixup-last-qtd  ( td -- )
1A58D8C 	 0 66 69 78 
1A58D90 	75 70 2D 6C 61 73 74 2D 
1A58D98 	71 74 64 8E 40 8D A5  1 
1A58DA0 	20 40 A0  1 
   /my-buf  if  drop exit  then
1A58DA4 	E4 89 A5  1 
1A58DA8 	DC 41 A0  1  C  0  0  0 
1A58DB0 	30 49 A0  1 40 46 A0  1 
   dup >hcqtd-next le-l@ swap >hcqtd-next-alt le-l!
1A58DB8 	40 49 A0  1 3C 6B A5  1 
1A58DC0 	B8 35 A4  1 68 49 A0  1 
1A58DC8 	58 6B A5  1 50 36 A4  1 
;
1A58DD0 	58 46 A0  1 
: fill-control-io-qtds  ( dir -- std )
1A58DD4 	 0  0  0 66 
1A58DD8 	69 6C 6C 2D 63 6F 6E 74 
1A58DE0 	72 6F 6C 2D 69 6F 2D 71 
1A58DE8 	74 64 73 94 A0 8D A5  1 
1A58DF0 	20 40 A0  1 
   my-qtd >qtd-next l@				( dir qtd' )
1A58DF4 	 C 8A A5  1 
1A58DF8 	60 6C A5  1 6C 4C A0  1 
   my-#qtds 0  ?do				( dir qtd )
1A58E00 	A4 89 A5  1 70 6F A0  1 
1A58E08 	50 42 A0  1 9C  0  0  0 
      my-buf my-buf-phys /my-buf 3 pick fill-qtd-bptrs
1A58E10 	B8 89 A5  1 D0 89 A5  1 
1A58E18 	E4 89 A5  1 A0 6F A0  1 
1A58E20 	 C 4A A0  1 44 79 A5  1 
						( dir qtd /bptr )
      2 pick over d# 16 << or TD_C_ERR3 or TD_STAT_ACTIVE or
1A58E28 	90 6F A0  1  C 4A A0  1 
1A58E30 	54 49 A0  1 58 41 A0  1 
1A58E38 	10  0  0  0 C8 44 A0  1 
1A58E40 	70 44 A0  1 D8 6D A5  1 
1A58E48 	70 44 A0  1 5C 6E A5  1 
1A58E50 	70 44 A0  1 
						( dir qtd /bptr token )
      i 1 and  if  TD_TOGGLE_DATA0  else TD_TOGGLE_DATA1  then  or
1A58E54 	B4 42 A0  1 
1A58E58 	80 6F A0  1 5C 44 A0  1 
1A58E60 	DC 41 A0  1 10  0  0  0 
1A58E68 	28 6D A5  1 C8 41 A0  1 
1A58E70 	 8  0  0  0 44 6D A5  1 
1A58E78 	70 44 A0  1 
						( dir qtd /bptr token' )
      2 pick >hcqtd-token le-l!			( dir qtd /bptr )
1A58E7C 	90 6F A0  1 
1A58E80 	 C 4A A0  1 74 6B A5  1 
1A58E88 	50 36 A4  1 
      my-buf++					( dir qtd )
1A58E8C 	40 8D A5  1 
      dup fixup-last-qtd			( dir qtd )
1A58E90 	40 49 A0  1 A0 8D A5  1 
      >qtd-next l@				( dir qtd' )
1A58E98 	60 6C A5  1 6C 4C A0  1 
   loop  nip					( std )
1A58EA0 	F8 41 A0  1 6C FF FF FF 
1A58EA8 	FC 46 A0  1 
;
1A58EAC 	58 46 A0  1 


\ ---------------------------------------------------------------------------
\ CONTROL pipe operations
\ ---------------------------------------------------------------------------

: (control-get)  ( sbuf sphy slen buf phy len -- actual usberr )
1A58EB0 	 0  0 28 63 6F 6E 74 72 
1A58EB8 	6F 6C 2D 67 65 74 29 8D 
1A58EC0 	F0 8D A5  1 20 40 A0  1 
   process-control-args				( sbuf sphy slen )
1A58EC8 	C4 8A A5  1 
   /my-buf 0=  if  3drop 0 USB_ERR_INV_OP exit  then
1A58ECC 	E4 89 A5  1 
1A58ED0 	24 47 A0  1 DC 41 A0  1 
1A58ED8 	14  0  0  0 98 3F A4  1 
1A58EE0 	70 6F A0  1 D4 2E A4  1 
1A58EE8 	40 46 A0  1 
   2 alloc-control-qhqtds			( sbuf sphy slen )
1A58EEC 	90 6F A0  1 
1A58EF0 	10 8B A5  1 

   \ SETUP TD
   fill-setup-qtd				( )
1A58EF4 	E0 8C A5  1 

   \ IN TD
   TD_PID_IN fill-control-io-qtds		( std )
1A58EF8 	 8 6E A5  1 F0 8D A5  1 

   \ Status TD (OUT)
   TD_TOGGLE_DATA1 TD_C_ERR3 or TD_PID_OUT or TD_STAT_ACTIVE or
1A58F00 	44 6D A5  1 D8 6D A5  1 
1A58F08 	70 44 A0  1 F0 6D A5  1 
1A58F10 	70 44 A0  1 5C 6E A5  1 
1A58F18 	70 44 A0  1 
   swap >hcqtd-token le-l!			( )
1A58F1C 	68 49 A0  1 
1A58F20 	74 6B A5  1 50 36 A4  1 

   \ Start control transaction
   my-qh pt-ctrl fill-qh
1A58F28 	20 8A A5  1 28 68 A5  1 
1A58F30 	84 8B A5  1 
   my-qh interrupt-on-last-td
1A58F34 	20 8A A5  1 
1A58F38 	50 7B A5  1 
   my-qh insert-qh
1A58F3C 	20 8A A5  1 
1A58F40 	B8 7B A5  1 

   \ Process results
   my-qh done-error?  if			( )
1A58F44 	20 8A A5  1 
1A58F48 	EC 85 A5  1 DC 41 A0  1 
1A58F50 	10  0  0  0 
      0						( actual )	\ System error, timeout, or USB error
1A58F54 	70 6F A0  1 
   else						( )
1A58F58 	C8 41 A0  1 40  0  0  0 
      my-qtd >qtd-next l@ dup my-#qtds get-actual	( qtd actual )
1A58F60 	 C 8A A5  1 60 6C A5  1 
1A58F68 	6C 4C A0  1 40 49 A0  1 
1A58F70 	A4 89 A5  1 A0 86 A5  1 
      over >qtd-buf l@ rot >qtd-pbuf l@ 2 pick dma-pull	( actual )
1A58F78 	54 49 A0  1 78 6C A5  1 
1A58F80 	6C 4C A0  1 7C 49 A0  1 
1A58F88 	90 6C A5  1 6C 4C A0  1 
1A58F90 	90 6F A0  1  C 4A A0  1 
1A58F98 	28 37 A4  1 
   then						( actual )

   my-qh dup remove-qh  free-qh			( actual )
1A58F9C 	20 8A A5  1 
1A58FA0 	40 49 A0  1 1C 7D A5  1 
1A58FA8 	F4 75 A5  1 
   usb-error					( actual usberr )
1A58FAC 	D0 40 A4  1 
;
1A58FB0 	58 46 A0  1 

: run-control  ( -- usberr )
1A58FB4 	72 75 6E 2D 
1A58FB8 	63 6F 6E 74 72 6F 6C 8B 
1A58FC0 	C4 8E A5  1 20 40 A0  1 
   \ Start control transaction
   my-qh pt-ctrl fill-qh
1A58FC8 	20 8A A5  1 28 68 A5  1 
1A58FD0 	84 8B A5  1 
   my-qh interrupt-on-last-td
1A58FD4 	20 8A A5  1 
1A58FD8 	50 7B A5  1 
   my-qh insert-qh
1A58FDC 	20 8A A5  1 
1A58FE0 	B8 7B A5  1 

   \ Process results
   my-qh done-error?                ( usberr )
1A58FE4 	20 8A A5  1 
1A58FE8 	EC 85 A5  1 
   my-qh dup remove-qh  free-qh     ( usberr )
1A58FEC 	20 8A A5  1 
1A58FF0 	40 49 A0  1 1C 7D A5  1 
1A58FF8 	F4 75 A5  1 
;
1A58FFC 	58 46 A0  1 

: (control-set)  ( sbuf sphy slen buf phy len -- usberr )
1A59000 	 0  0 28 63 6F 6E 74 72 
1A59008 	6F 6C 2D 73 65 74 29 8D 
1A59010 	C4 8F A5  1 20 40 A0  1 
   process-control-args				( sbuf sphy slen )
1A59018 	C4 8A A5  1 
   2 alloc-control-qhqtds			( sbuf sphy slen )
1A5901C 	90 6F A0  1 
1A59020 	10 8B A5  1 

   \ SETUP TD
   fill-setup-qtd				( )
1A59024 	E0 8C A5  1 

   \ OUT TD
   TD_PID_OUT fill-control-io-qtds		( std )
1A59028 	F0 6D A5  1 F0 8D A5  1 

   \ Status TD (IN)
   TD_TOGGLE_DATA1 TD_C_ERR3 or TD_PID_IN or TD_STAT_ACTIVE or
1A59030 	44 6D A5  1 D8 6D A5  1 
1A59038 	70 44 A0  1  8 6E A5  1 
1A59040 	70 44 A0  1 5C 6E A5  1 
1A59048 	70 44 A0  1 
   swap >hcqtd-token le-l!			( )
1A5904C 	68 49 A0  1 
1A59050 	74 6B A5  1 50 36 A4  1 

   run-control
1A59058 	C4 8F A5  1 
;
1A5905C 	58 46 A0  1 

: (control-set-nostat)  ( sbuf sphy slen buf phy len -- usberr )
1A59060 	 0  0  0 28 63 6F 6E 74 
1A59068 	72 6F 6C 2D 73 65 74 2D 
1A59070 	6E 6F 73 74 61 74 29 94 
1A59078 	14 90 A5  1 20 40 A0  1 
   process-control-args				( sbuf sphy slen )
1A59080 	C4 8A A5  1 
   1 alloc-control-qhqtds			( sbuf sphy slen )
1A59084 	80 6F A0  1 
1A59088 	10 8B A5  1 

   \ SETUP TD
   fill-setup-qtd				( )
1A5908C 	E0 8C A5  1 

   \ OUT TD
   TD_PID_OUT fill-control-io-qtds drop		( )
1A59090 	F0 6D A5  1 F0 8D A5  1 
1A59098 	30 49 A0  1 

   run-control                                  ( usberr )
1A5909C 	C4 8F A5  1 
;
1A590A0 	58 46 A0  1 

headers

OpenFirmware/dev/usb2/hcd/ehci/control.fth_AL	788 1A590A4 purpose: EHCI USB Controller bulk pipes transaction processing

hex
: bulkfth
1A590A4 	62 75 6C 6B 
1A590A8 	66 74 68 87 7C 90 A5  1 
1A590B0 	20 40 A0  1 
s" d# 500 instance value bulk-in-timeout" eval
1A590B4 	9C 53 A0  1 
1A590B8 	25 64 23 20 35 30 30 20 
1A590C0 	69 6E 73 74 61 6E 63 65 
1A590C8 	20 76 61 6C 75 65 20 62 
1A590D0 	75 6C 6B 2D 69 6E 2D 74 
1A590D8 	69 6D 65 6F 75 74  0  0 
1A590E0 	D8 E5 A0  1 
s" d# 500 constant bulk-out-timeout" eval
1A590E4 	9C 53 A0  1 
1A590E8 	20 64 23 20 35 30 30 20 
1A590F0 	63 6F 6E 73 74 61 6E 74 
1A590F8 	20 62 75 6C 6B 2D 6F 75 
1A59100 	74 2D 74 69 6D 65 6F 75 
1A59108 	74  0  0  0 D8 E5 A0  1 

s" 0 instance value bulk-in-pipe" eval
1A59110 	9C 53 A0  1 1D 30 20 69 
1A59118 	6E 73 74 61 6E 63 65 20 
1A59120 	76 61 6C 75 65 20 62 75 
1A59128 	6C 6B 2D 69 6E 2D 70 69 
1A59130 	70 65  0  0 D8 E5 A0  1 
s" 0 instance value bulk-out-pipe" eval
1A59138 	9C 53 A0  1 1E 30 20 69 
1A59140 	6E 73 74 61 6E 63 65 20 
1A59148 	76 61 6C 75 65 20 62 75 
1A59150 	6C 6B 2D 6F 75 74 2D 70 
1A59158 	69 70 65  0 D8 E5 A0  1 

s" 8 constant #bulk-qtd-max" eval		\ Preallocated qtds for bulk-qh
1A59160 	9C 53 A0  1 18 38 20 63 
1A59168 	6F 6E 73 74 61 6E 74 20 
1A59170 	23 62 75 6C 6B 2D 71 74 
1A59178 	64 2D 6D 61 78  0  0  0 
1A59180 	D8 E5 A0  1 
					\ Each qtd can transfer upto 0x5000 bytes
s" 0 instance value bulk-qh" eval		\ For bulk-in and bulk-out
1A59184 	9C 53 A0  1 
1A59188 	18 30 20 69 6E 73 74 61 
1A59190 	6E 63 65 20 76 61 6C 75 
1A59198 	65 20 62 75 6C 6B 2D 71 
1A591A0 	68  0  0  0 D8 E5 A0  1 

s" 0 instance value bulk-in-qh" eval		\ For begin-bulk-in, bulk-in?,...
1A591A8 	9C 53 A0  1 1B 30 20 69 
1A591B0 	6E 73 74 61 6E 63 65 20 
1A591B8 	76 61 6C 75 65 20 62 75 
1A591C0 	6C 6B 2D 69 6E 2D 71 68 
1A591C8 	 0  0  0  0 D8 E5 A0  1 
s" 0 instance value bulk-in-qtd" eval		\ For begin-bulk-in, bulk-in?,...
1A591D0 	9C 53 A0  1 1C 30 20 69 
1A591D8 	6E 73 74 61 6E 63 65 20 
1A591E0 	76 61 6C 75 65 20 62 75 
1A591E8 	6C 6B 2D 69 6E 2D 71 74 
1A591F0 	64  0  0  0 D8 E5 A0  1 

s" 0 instance value bulk-out-qh" eval		\ For begin-bulk-out-ring ...
1A591F8 	9C 53 A0  1 1C 30 20 69 
1A59200 	6E 73 74 61 6E 63 65 20 
1A59208 	76 61 6C 75 65 20 62 75 
1A59210 	6C 6B 2D 6F 75 74 2D 71 
1A59218 	68  0  0  0 D8 E5 A0  1 
s" 0 instance value bulk-out-qtd" eval		\ For begin-bulk-out-ring ...
1A59220 	9C 53 A0  1 1D 30 20 69 
1A59228 	6E 73 74 61 6E 63 65 20 
1A59230 	76 61 6C 75 65 20 62 75 
1A59238 	6C 6B 2D 6F 75 74 2D 71 
1A59240 	74 64  0  0 D8 E5 A0  1 

s" 0 instance value my-bulk-qh" eval             \ Cannot use my-qh because unstall-pipe kills it
1A59248 	9C 53 A0  1 1B 30 20 69 
1A59250 	6E 73 74 61 6E 63 65 20 
1A59258 	76 61 6C 75 65 20 6D 79 
1A59260 	2D 62 75 6C 6B 2D 71 68 
1A59268 	 0  0  0  0 D8 E5 A0  1 
s" 0 instance value my-bulk-qtd" eval
1A59270 	9C 53 A0  1 1C 30 20 69 
1A59278 	6E 73 74 61 6E 63 65 20 
1A59280 	76 61 6C 75 65 20 6D 79 
1A59288 	2D 62 75 6C 6B 2D 71 74 
1A59290 	64  0  0  0 D8 E5 A0  1 

s" : bulk-in-data@         ( -- n )  bulk-in-pipe  target di-in-data@   di-data>td-data  ;" eval
1A59298 	9C 53 A0  1 57 3A 20 62 
1A592A0 	75 6C 6B 2D 69 6E 2D 64 
1A592A8 	61 74 61 40 20 20 20 20 
1A592B0 	20 20 20 20 20 28 20 2D 
1A592B8 	2D 20 6E 20 29 20 20 62 
1A592C0 	75 6C 6B 2D 69 6E 2D 70 
1A592C8 	69 70 65 20 20 74 61 72 
1A592D0 	67 65 74 20 64 69 2D 69 
1A592D8 	6E 2D 64 61 74 61 40 20 
1A592E0 	20 20 64 69 2D 64 61 74 
1A592E8 	61 3E 74 64 2D 64 61 74 
1A592F0 	61 20 20 3B  0  0  0  0 
1A592F8 	D8 E5 A0  1 
s" : bulk-out-data@        ( -- n )  bulk-out-pipe target di-out-data@  di-data>td-data  ;" eval
1A592FC 	9C 53 A0  1 
1A59300 	57 3A 20 62 75 6C 6B 2D 
1A59308 	6F 75 74 2D 64 61 74 61 
1A59310 	40 20 20 20 20 20 20 20 
1A59318 	20 28 20 2D 2D 20 6E 20 
1A59320 	29 20 20 62 75 6C 6B 2D 
1A59328 	6F 75 74 2D 70 69 70 65 
1A59330 	20 74 61 72 67 65 74 20 
1A59338 	64 69 2D 6F 75 74 2D 64 
1A59340 	61 74 61 40 20 20 64 69 
1A59348 	2D 64 61 74 61 3E 74 64 
1A59350 	2D 64 61 74 61 20 20 3B 
1A59358 	 0  0  0  0 D8 E5 A0  1 
s" : bulk-in-data!         ( n -- )  td-data>di-data bulk-in-pipe  target di-in-data!   ;" eval
1A59360 	9C 53 A0  1 56 3A 20 62 
1A59368 	75 6C 6B 2D 69 6E 2D 64 
1A59370 	61 74 61 21 20 20 20 20 
1A59378 	20 20 20 20 20 28 20 6E 
1A59380 	20 2D 2D 20 29 20 20 74 
1A59388 	64 2D 64 61 74 61 3E 64 
1A59390 	69 2D 64 61 74 61 20 62 
1A59398 	75 6C 6B 2D 69 6E 2D 70 
1A593A0 	69 70 65 20 20 74 61 72 
1A593A8 	67 65 74 20 64 69 2D 69 
1A593B0 	6E 2D 64 61 74 61 21 20 
1A593B8 	20 20 3B  0 D8 E5 A0  1 
s" : bulk-out-data!        ( n -- )  td-data>di-data bulk-out-pipe target di-out-data!  ;" eval
1A593C0 	9C 53 A0  1 56 3A 20 62 
1A593C8 	75 6C 6B 2D 6F 75 74 2D 
1A593D0 	64 61 74 61 21 20 20 20 
1A593D8 	20 20 20 20 20 28 20 6E 
1A593E0 	20 2D 2D 20 29 20 20 74 
1A593E8 	64 2D 64 61 74 61 3E 64 
1A593F0 	69 2D 64 61 74 61 20 62 
1A593F8 	75 6C 6B 2D 6F 75 74 2D 
1A59400 	70 69 70 65 20 74 61 72 
1A59408 	67 65 74 20 64 69 2D 6F 
1A59410 	75 74 2D 64 61 74 61 21 
1A59418 	20 20 3B  0 D8 E5 A0  1 
s" : toggle-bulk-in-data   ( -- )    bulk-in-pipe  target di-in-data-toggle   ;" eval
1A59420 	9C 53 A0  1 4C 3A 20 74 
1A59428 	6F 67 67 6C 65 2D 62 75 
1A59430 	6C 6B 2D 69 6E 2D 64 61 
1A59438 	74 61 20 20 20 28 20 2D 
1A59440 	2D 20 29 20 20 20 20 62 
1A59448 	75 6C 6B 2D 69 6E 2D 70 
1A59450 	69 70 65 20 20 74 61 72 
1A59458 	67 65 74 20 64 69 2D 69 
1A59460 	6E 2D 64 61 74 61 2D 74 
1A59468 	6F 67 67 6C 65 20 20 20 
1A59470 	3B  0  0  0 D8 E5 A0  1 
s" : toggle-bulk-out-data  ( -- )    bulk-out-pipe target di-out-data-toggle  ;" eval
1A59478 	9C 53 A0  1 4C 3A 20 74 
1A59480 	6F 67 67 6C 65 2D 62 75 
1A59488 	6C 6B 2D 6F 75 74 2D 64 
1A59490 	61 74 61 20 20 28 20 2D 
1A59498 	2D 20 29 20 20 20 20 62 
1A594A0 	75 6C 6B 2D 6F 75 74 2D 
1A594A8 	70 69 70 65 20 74 61 72 
1A594B0 	67 65 74 20 64 69 2D 6F 
1A594B8 	75 74 2D 64 61 74 61 2D 
1A594C0 	74 6F 67 67 6C 65 20 20 
1A594C8 	3B  0  0  0 D8 E5 A0  1 

s" : qtd-fixup-bulk-in-data" eval  ( qtd -- )
1A594D0 	9C 53 A0  1 18 3A 20 71 
1A594D8 	74 64 2D 66 69 78 75 70 
1A594E0 	2D 62 75 6C 6B 2D 69 6E 
1A594E8 	2D 64 61 74 61  0  0  0 
1A594F0 	D8 E5 A0  1 
s"    usb-error USB_ERR_STALL and  if" eval
1A594F4 	9C 53 A0  1 
1A594F8 	22 20 20 20 75 73 62 2D 
1A59500 	65 72 72 6F 72 20 55 53 
1A59508 	42 5F 45 52 52 5F 53 54 
1A59510 	41 4C 4C 20 61 6E 64 20 
1A59518 	20 69 66  0 D8 E5 A0  1 
s"       drop bulk-in-pipe h# 80 or unstall-pipe" eval
1A59520 	9C 53 A0  1 2D 20 20 20 
1A59528 	20 20 20 64 72 6F 70 20 
1A59530 	62 75 6C 6B 2D 69 6E 2D 
1A59538 	70 69 70 65 20 68 23 20 
1A59540 	38 30 20 6F 72 20 75 6E 
1A59548 	73 74 61 6C 6C 2D 70 69 
1A59550 	70 65  0  0 D8 E5 A0  1 
s"       TD_TOGGLE_DATA0" eval
1A59558 	9C 53 A0  1 15 20 20 20 
1A59560 	20 20 20 54 44 5F 54 4F 
1A59568 	47 47 4C 45 5F 44 41 54 
1A59570 	41 30  0  0 D8 E5 A0  1 
s"    else" eval
1A59578 	9C 53 A0  1  7 20 20 20 
1A59580 	65 6C 73 65  0  0  0  0 
1A59588 	D8 E5 A0  1 
s"       >hcqtd-token le-l@" eval
1A5958C 	9C 53 A0  1 
1A59590 	18 20 20 20 20 20 20 3E 
1A59598 	68 63 71 74 64 2D 74 6F 
1A595A0 	6B 65 6E 20 6C 65 2D 6C 
1A595A8 	40  0  0  0 D8 E5 A0  1 
s"    then" eval
1A595B0 	9C 53 A0  1  7 20 20 20 
1A595B8 	74 68 65 6E  0  0  0  0 
1A595C0 	D8 E5 A0  1 
s"    bulk-in-data! ;" eval
1A595C4 	9C 53 A0  1 
1A595C8 	12 20 20 20 62 75 6C 6B 
1A595D0 	2D 69 6E 2D 64 61 74 61 
1A595D8 	21 20 3B  0 D8 E5 A0  1 

s" : fixup-bulk-in-data    ( qh -- )  >hcqh-overlay qtd-fixup-bulk-in-data  ;" eval
1A595E0 	9C 53 A0  1 4A 3A 20 66 
1A595E8 	69 78 75 70 2D 62 75 6C 
1A595F0 	6B 2D 69 6E 2D 64 61 74 
1A595F8 	61 20 20 20 20 28 20 71 
1A59600 	68 20 2D 2D 20 29 20 20 
1A59608 	3E 68 63 71 68 2D 6F 76 
1A59610 	65 72 6C 61 79 20 71 74 
1A59618 	64 2D 66 69 78 75 70 2D 
1A59620 	62 75 6C 6B 2D 69 6E 2D 
1A59628 	64 61 74 61 20 20 3B  0 
1A59630 	D8 E5 A0  1 
s" : fixup-bulk-out-data" eval   ( qh -- )
1A59634 	9C 53 A0  1 
1A59638 	15 3A 20 66 69 78 75 70 
1A59640 	2D 62 75 6C 6B 2D 6F 75 
1A59648 	74 2D 64 61 74 61  0  0 
1A59650 	D8 E5 A0  1 
s"    usb-error USB_ERR_STALL and  if" eval
1A59654 	9C 53 A0  1 
1A59658 	22 20 20 20 75 73 62 2D 
1A59660 	65 72 72 6F 72 20 55 53 
1A59668 	42 5F 45 52 52 5F 53 54 
1A59670 	41 4C 4C 20 61 6E 64 20 
1A59678 	20 69 66  0 D8 E5 A0  1 
s"       drop bulk-out-pipe unstall-pipe" eval
1A59680 	9C 53 A0  1 25 20 20 20 
1A59688 	20 20 20 64 72 6F 70 20 
1A59690 	62 75 6C 6B 2D 6F 75 74 
1A59698 	2D 70 69 70 65 20 75 6E 
1A596A0 	73 74 61 6C 6C 2D 70 69 
1A596A8 	70 65  0  0 D8 E5 A0  1 
s"       TD_TOGGLE_DATA0" eval
1A596B0 	9C 53 A0  1 15 20 20 20 
1A596B8 	20 20 20 54 44 5F 54 4F 
1A596C0 	47 47 4C 45 5F 44 41 54 
1A596C8 	41 30  0  0 D8 E5 A0  1 
s"    else" eval
1A596D0 	9C 53 A0  1  7 20 20 20 
1A596D8 	65 6C 73 65  0  0  0  0 
1A596E0 	D8 E5 A0  1 
s"       >hcqh-overlay >hcqtd-token le-l@" eval
1A596E4 	9C 53 A0  1 
1A596E8 	26 20 20 20 20 20 20 3E 
1A596F0 	68 63 71 68 2D 6F 76 65 
1A596F8 	72 6C 61 79 20 3E 68 63 
1A59700 	71 74 64 2D 74 6F 6B 65 
1A59708 	6E 20 6C 65 2D 6C 40  0 
1A59710 	D8 E5 A0  1 
s"    then" eval
1A59714 	9C 53 A0  1 
1A59718 	 7 20 20 20 74 68 65 6E 
1A59720 	 0  0  0  0 D8 E5 A0  1 
s"    bulk-out-data! ;" eval
1A59728 	9C 53 A0  1 13 20 20 20 
1A59730 	62 75 6C 6B 2D 6F 75 74 
1A59738 	2D 64 61 74 61 21 20 3B 
1A59740 	 0  0  0  0 D8 E5 A0  1 
s" : set-bulk-vars" eval  ( pipe -- )
1A59748 	9C 53 A0  1  F 3A 20 73 
1A59750 	65 74 2D 62 75 6C 6B 2D 
1A59758 	76 61 72 73  0  0  0  0 
1A59760 	D8 E5 A0  1 
s"    clear-usb-error" eval      ( pipe )
1A59764 	9C 53 A0  1 
1A59768 	12 20 20 20 63 6C 65 61 
1A59770 	72 2D 75 73 62 2D 65 72 
1A59778 	72 6F 72  0 D8 E5 A0  1 
s"    set-my-dev" eval           ( pipe )
1A59780 	9C 53 A0  1  D 20 20 20 
1A59788 	73 65 74 2D 6D 79 2D 64 
1A59790 	65 76  0  0 D8 E5 A0  1 
s"    set-my-char ;" eval
1A59798 	9C 53 A0  1 10 20 20 20 
1A597A0 	73 65 74 2D 6D 79 2D 63 
1A597A8 	68 61 72 20 3B  0  0  0 
1A597B0 	D8 E5 A0  1 
 
s" : process-bulk-args" eval  ( buf len pipe -- )
1A597B4 	9C 53 A0  1 
1A597B8 	13 3A 20 70 72 6F 63 65 
1A597C0 	73 73 2D 62 75 6C 6B 2D 
1A597C8 	61 72 67 73  0  0  0  0 
1A597D0 	D8 E5 A0  1 
s"    set-bulk-vars" eval	( buf len )
1A597D4 	9C 53 A0  1 
1A597D8 	10 20 20 20 73 65 74 2D 
1A597E0 	62 75 6C 6B 2D 76 61 72 
1A597E8 	73  0  0  0 D8 E5 A0  1 
s"    2dup hcd-map-in  to my-buf-phys to /my-buf to my-buf ;" eval
1A597F0 	9C 53 A0  1 39 20 20 20 
1A597F8 	32 64 75 70 20 68 63 64 
1A59800 	2D 6D 61 70 2D 69 6E 20 
1A59808 	20 74 6F 20 6D 79 2D 62 
1A59810 	75 66 2D 70 68 79 73 20 
1A59818 	74 6F 20 2F 6D 79 2D 62 
1A59820 	75 66 20 74 6F 20 6D 79 
1A59828 	2D 62 75 66 20 3B  0  0 
1A59830 	D8 E5 A0  1 
s" : alloc-bulk-qhqtds" eval  ( -- qh qtd )
1A59834 	9C 53 A0  1 
1A59838 	13 3A 20 61 6C 6C 6F 63 
1A59840 	2D 62 75 6C 6B 2D 71 68 
1A59848 	71 74 64 73  0  0  0  0 
1A59850 	D8 E5 A0  1 
s"    my-buf-phys /my-buf cal-#qtd dup to my-#qtds" eval   ( #qtds )
1A59854 	9C 53 A0  1 
1A59858 	2F 20 20 20 6D 79 2D 62 
1A59860 	75 66 2D 70 68 79 73 20 
1A59868 	2F 6D 79 2D 62 75 66 20 
1A59870 	63 61 6C 2D 23 71 74 64 
1A59878 	20 64 75 70 20 74 6F 20 
1A59880 	6D 79 2D 23 71 74 64 73 
1A59888 	 0  0  0  0 D8 E5 A0  1 
s"    alloc-qhqtds ;" eval     ( qh qtd )
1A59890 	9C 53 A0  1 11 20 20 20 
1A59898 	61 6C 6C 6F 63 2D 71 68 
1A598A0 	71 74 64 73 20 3B  0  0 
1A598A8 	D8 E5 A0  1 
s" : ?alloc-bulk-qhqtds" eval  ( -- qh qtd )
1A598AC 	9C 53 A0  1 
1A598B0 	14 3A 20 3F 61 6C 6C 6F 
1A598B8 	63 2D 62 75 6C 6B 2D 71 
1A598C0 	68 71 74 64 73  0  0  0 
1A598C8 	D8 E5 A0  1 
s"    my-buf-phys /my-buf cal-#qtd dup to my-#qtds" eval   ( #qtds )
1A598CC 	9C 53 A0  1 
1A598D0 	2F 20 20 20 6D 79 2D 62 
1A598D8 	75 66 2D 70 68 79 73 20 
1A598E0 	2F 6D 79 2D 62 75 66 20 
1A598E8 	63 61 6C 2D 23 71 74 64 
1A598F0 	20 64 75 70 20 74 6F 20 
1A598F8 	6D 79 2D 23 71 74 64 73 
1A59900 	 0  0  0  0 D8 E5 A0  1 
 "    dup #bulk-qtd-max >  if  ."" Requested bulk transfer is too big."" cr abort  then" eval  ( #qtds )
1A59908 	9C 53 A0  1 52 20 20 20 
1A59910 	64 75 70 20 23 62 75 6C 
1A59918 	6B 2D 71 74 64 2D 6D 61 
1A59920 	78 20 3E 20 20 69 66 20 
1A59928 	20 2E 22 20 52 65 71 75 
1A59930 	65 73 74 65 64 20 62 75 
1A59938 	6C 6B 20 74 72 61 6E 73 
1A59940 	66 65 72 20 69 73 20 74 
1A59948 	6F 6F 20 62 69 67 2E 22 
1A59950 	20 63 72 20 61 62 6F 72 
1A59958 	74 20 20 74 68 65 6E  0 
1A59960 	D8 E5 A0  1 

s"    bulk-qh 0=  if" eval                                 ( #qtds )
1A59964 	9C 53 A0  1 
1A59968 	11 20 20 20 62 75 6C 6B 
1A59970 	2D 71 68 20 30 3D 20 20 
1A59978 	69 66  0  0 D8 E5 A0  1 
s"       #bulk-qtd-max alloc-qhqtds drop to bulk-qh" eval
1A59980 	9C 53 A0  1 30 20 20 20 
1A59988 	20 20 20 23 62 75 6C 6B 
1A59990 	2D 71 74 64 2D 6D 61 78 
1A59998 	20 61 6C 6C 6F 63 2D 71 
1A599A0 	68 71 74 64 73 20 64 72 
1A599A8 	6F 70 20 74 6F 20 62 75 
1A599B0 	6C 6B 2D 71 68  0  0  0 
1A599B8 	D8 E5 A0  1 
s"    then" eval                                           ( #qtds )
1A599BC 	9C 53 A0  1 
1A599C0 	 7 20 20 20 74 68 65 6E 
1A599C8 	 0  0  0  0 D8 E5 A0  1 
s"    bulk-qh reuse-qhqtds ;" eval
1A599D0 	9C 53 A0  1 19 20 20 20 
1A599D8 	62 75 6C 6B 2D 71 68 20 
1A599E0 	72 65 75 73 65 2D 71 68 
1A599E8 	71 74 64 73 20 3B  0  0 
1A599F0 	D8 E5 A0  1 

s" : free-bulk-qh" eval  ( -- )
1A599F4 	9C 53 A0  1 
1A599F8 	 E 3A 20 66 72 65 65 2D 
1A59A00 	62 75 6C 6B 2D 71 68  0 
1A59A08 	D8 E5 A0  1 
s"    bulk-qh ?dup  if" eval                     ( qh )
1A59A0C 	9C 53 A0  1 
1A59A10 	13 20 20 20 62 75 6C 6B 
1A59A18 	2D 71 68 20 3F 64 75 70 
1A59A20 	20 20 69 66  0  0  0  0 
1A59A28 	D8 E5 A0  1 
s"       free-qh" eval
1A59A2C 	9C 53 A0  1 
1A59A30 	 D 20 20 20 20 20 20 66 
1A59A38 	72 65 65 2D 71 68  0  0 
1A59A40 	D8 E5 A0  1 
s"       0 to bulk-qh" eval
1A59A44 	9C 53 A0  1 
1A59A48 	12 20 20 20 20 20 20 30 
1A59A50 	20 74 6F 20 62 75 6C 6B 
1A59A58 	2D 71 68  0 D8 E5 A0  1 
s"    then ;" eval
1A59A60 	9C 53 A0  1  9 20 20 20 
1A59A68 	74 68 65 6E 20 3B  0  0 
1A59A70 	D8 E5 A0  1 

s" : fill-bulk-io-qtds" eval  ( dir qtd -- )
1A59A74 	9C 53 A0  1 
1A59A78 	13 3A 20 66 69 6C 6C 2D 
1A59A80 	62 75 6C 6B 2D 69 6F 2D 
1A59A88 	71 74 64 73  0  0  0  0 
1A59A90 	D8 E5 A0  1 
s"    my-#qtds 0  do" eval				( dir qtd )
1A59A94 	9C 53 A0  1 
1A59A98 	11 20 20 20 6D 79 2D 23 
1A59AA0 	71 74 64 73 20 30 20 20 
1A59AA8 	64 6F  0  0 D8 E5 A0  1 
s"       my-buf my-buf-phys /my-buf 3 pick fill-qtd-bptrs" eval
1A59AB0 	9C 53 A0  1 36 20 20 20 
1A59AB8 	20 20 20 6D 79 2D 62 75 
1A59AC0 	66 20 6D 79 2D 62 75 66 
1A59AC8 	2D 70 68 79 73 20 2F 6D 
1A59AD0 	79 2D 62 75 66 20 33 20 
1A59AD8 	70 69 63 6B 20 66 69 6C 
1A59AE0 	6C 2D 71 74 64 2D 62 70 
1A59AE8 	74 72 73  0 D8 E5 A0  1 
						( dir qtd /bptr )
      \ Setup the token word
s"       2 pick over d# 16 << or" eval			( dir qtd /bptr token )
1A59AF0 	9C 53 A0  1 1D 20 20 20 
1A59AF8 	20 20 20 32 20 70 69 63 
1A59B00 	6B 20 6F 76 65 72 20 64 
1A59B08 	23 20 31 36 20 3C 3C 20 
1A59B10 	6F 72  0  0 D8 E5 A0  1 
s"       TD_C_ERR3 or TD_STAT_ACTIVE or" eval		( dir qtd /bptr token' )
1A59B18 	9C 53 A0  1 24 20 20 20 
1A59B20 	20 20 20 54 44 5F 43 5F 
1A59B28 	45 52 52 33 20 6F 72 20 
1A59B30 	54 44 5F 53 54 41 54 5F 
1A59B38 	41 43 54 49 56 45 20 6F 
1A59B40 	72  0  0  0 D8 E5 A0  1 
s"       3 pick TD_PID_IN =  if" eval			( dir qtd /bptr token' )
1A59B48 	9C 53 A0  1 1C 20 20 20 
1A59B50 	20 20 20 33 20 70 69 63 
1A59B58 	6B 20 54 44 5F 50 49 44 
1A59B60 	5F 49 4E 20 3D 20 20 69 
1A59B68 	66  0  0  0 D8 E5 A0  1 
s"          bulk-in-data@  toggle-bulk-in-data" eval
1A59B70 	9C 53 A0  1 2B 20 20 20 
1A59B78 	20 20 20 20 20 20 62 75 
1A59B80 	6C 6B 2D 69 6E 2D 64 61 
1A59B88 	74 61 40 20 20 74 6F 67 
1A59B90 	67 6C 65 2D 62 75 6C 6B 
1A59B98 	2D 69 6E 2D 64 61 74 61 
1A59BA0 	 0  0  0  0 D8 E5 A0  1 
s"       else" eval
1A59BA8 	9C 53 A0  1  A 20 20 20 
1A59BB0 	20 20 20 65 6C 73 65  0 
1A59BB8 	D8 E5 A0  1 
s"          bulk-out-data@ toggle-bulk-out-data" eval
1A59BBC 	9C 53 A0  1 
1A59BC0 	2C 20 20 20 20 20 20 20 
1A59BC8 	20 20 62 75 6C 6B 2D 6F 
1A59BD0 	75 74 2D 64 61 74 61 40 
1A59BD8 	20 74 6F 67 67 6C 65 2D 
1A59BE0 	62 75 6C 6B 2D 6F 75 74 
1A59BE8 	2D 64 61 74 61  0  0  0 
1A59BF0 	D8 E5 A0  1 
s"       then  or" eval					( dir qtd /bptr token' )
1A59BF4 	9C 53 A0  1 
1A59BF8 	 E 20 20 20 20 20 20 74 
1A59C00 	68 65 6E 20 20 6F 72  0 
1A59C08 	D8 E5 A0  1 
s"       2 pick >hcqtd-token le-l!" eval			( dir qtd /bptr )
1A59C0C 	9C 53 A0  1 
1A59C10 	1F 20 20 20 20 20 20 32 
1A59C18 	20 70 69 63 6B 20 3E 68 
1A59C20 	63 71 74 64 2D 74 6F 6B 
1A59C28 	65 6E 20 6C 65 2D 6C 21 
1A59C30 	 0  0  0  0 D8 E5 A0  1 

s"       my-buf++" eval					( dir qtd )
1A59C38 	9C 53 A0  1  E 20 20 20 
1A59C40 	20 20 20 6D 79 2D 62 75 
1A59C48 	66 2B 2B  0 D8 E5 A0  1 
s"       dup fixup-last-qtd" eval			( dir qtd )
1A59C50 	9C 53 A0  1 18 20 20 20 
1A59C58 	20 20 20 64 75 70 20 66 
1A59C60 	69 78 75 70 2D 6C 61 73 
1A59C68 	74 2D 71 74 64  0  0  0 
1A59C70 	D8 E5 A0  1 
s"       >qtd-next l@" eval				( dir qtd' )
1A59C74 	9C 53 A0  1 
1A59C78 	12 20 20 20 20 20 20 3E 
1A59C80 	71 74 64 2D 6E 65 78 74 
1A59C88 	20 6C 40  0 D8 E5 A0  1 
s"    loop  2drop ;" eval
1A59C90 	9C 53 A0  1 10 20 20 20 
1A59C98 	6C 6F 6F 70 20 20 32 64 
1A59CA0 	72 6F 70 20 3B  0  0  0 
1A59CA8 	D8 E5 A0  1 

s" : more-qtds?" eval  ( qtd -- qtd flag )
1A59CAC 	9C 53 A0  1 
1A59CB0 	 C 3A 20 6D 6F 72 65 2D 
1A59CB8 	71 74 64 73 3F  0  0  0 
1A59CC0 	D8 E5 A0  1 
s"    dup >hcqtd-next le-l@" eval		( qtd next )
1A59CC4 	9C 53 A0  1 
1A59CC8 	18 20 20 20 64 75 70 20 
1A59CD0 	3E 68 63 71 74 64 2D 6E 
1A59CD8 	65 78 74 20 6C 65 2D 6C 
1A59CE0 	40  0  0  0 D8 E5 A0  1 
s"    over >hcqtd-next-alt le-l@  <> ;" eval	( qtd more? )
1A59CE8 	9C 53 A0  1 23 20 20 20 
1A59CF0 	6F 76 65 72 20 3E 68 63 
1A59CF8 	71 74 64 2D 6E 65 78 74 
1A59D00 	2D 61 6C 74 20 6C 65 2D 
1A59D08 	6C 40 20 20 3C 3E 20 3B 
1A59D10 	 0  0  0  0 D8 E5 A0  1 
s" : activate-in-ring" eval  ( qtd -- )
1A59D18 	9C 53 A0  1 12 3A 20 61 
1A59D20 	63 74 69 76 61 74 65 2D 
1A59D28 	69 6E 2D 72 69 6E 67  0 
1A59D30 	D8 E5 A0  1 
   \ Start with the second entry in the ring so the first entry
   \ is the last to be activated, thus deferring host controller
   \ activity until all qtds are active.
s"    >qtd-next l@  dup" eval				( qtd0 qtd )
1A59D34 	9C 53 A0  1 
1A59D38 	14 20 20 20 3E 71 74 64 
1A59D40 	2D 6E 65 78 74 20 6C 40 
1A59D48 	20 20 64 75 70  0  0  0 
1A59D50 	D8 E5 A0  1 
s"    begin" eval					( qtd0 qtd )
1A59D54 	9C 53 A0  1 
1A59D58 	 8 20 20 20 62 65 67 69 
1A59D60 	6E  0  0  0 D8 E5 A0  1 
s"       TD_C_ERR3 TD_PID_IN or TD_STAT_ACTIVE or" eval	( qtd0 qtd token )
1A59D68 	9C 53 A0  1 2E 20 20 20 
1A59D70 	20 20 20 54 44 5F 43 5F 
1A59D78 	45 52 52 33 20 54 44 5F 
1A59D80 	50 49 44 5F 49 4E 20 6F 
1A59D88 	72 20 54 44 5F 53 54 41 
1A59D90 	54 5F 41 43 54 49 56 45 
1A59D98 	20 6F 72  0 D8 E5 A0  1 
s"       over >hcqtd-token le-w!" eval			( qtd0 qtd )
1A59DA0 	9C 53 A0  1 1D 20 20 20 
1A59DA8 	20 20 20 6F 76 65 72 20 
1A59DB0 	3E 68 63 71 74 64 2D 74 
1A59DB8 	6F 6B 65 6E 20 6C 65 2D 
1A59DC0 	77 21  0  0 D8 E5 A0  1 
s"       >qtd-next l@" eval				( qtd0 qtd' )
1A59DC8 	9C 53 A0  1 12 20 20 20 
1A59DD0 	20 20 20 3E 71 74 64 2D 
1A59DD8 	6E 65 78 74 20 6C 40  0 
1A59DE0 	D8 E5 A0  1 
s"    2dup = until" eval					( qtd0 qtd' )
1A59DE4 	9C 53 A0  1 
1A59DE8 	 F 20 20 20 32 64 75 70 
1A59DF0 	20 3D 20 75 6E 74 69 6C 
1A59DF8 	 0  0  0  0 D8 E5 A0  1 
s"    2drop ;" eval
1A59E00 	9C 53 A0  1  A 20 20 20 
1A59E08 	32 64 72 6F 70 20 3B  0 
1A59E10 	D8 E5 A0  1 

s" : new-fill-bulk-io-qtds" eval  ( /buf qtd -- )
1A59E14 	9C 53 A0  1 
1A59E18 	17 3A 20 6E 65 77 2D 66 
1A59E20 	69 6C 6C 2D 62 75 6C 6B 
1A59E28 	2D 69 6F 2D 71 74 64 73 
1A59E30 	 0  0  0  0 D8 E5 A0  1 
s"    swap to /my-buf" eval					( qtd )
1A59E38 	9C 53 A0  1 12 20 20 20 
1A59E40 	73 77 61 70 20 74 6F 20 
1A59E48 	2F 6D 79 2D 62 75 66  0 
1A59E50 	D8 E5 A0  1 
s"    my-buf-phys /my-buf cal-#qtd to my-#qtds" eval		( /buf qtd )
1A59E54 	9C 53 A0  1 
1A59E58 	2B 20 20 20 6D 79 2D 62 
1A59E60 	75 66 2D 70 68 79 73 20 
1A59E68 	2F 6D 79 2D 62 75 66 20 
1A59E70 	63 61 6C 2D 23 71 74 64 
1A59E78 	20 74 6F 20 6D 79 2D 23 
1A59E80 	71 74 64 73  0  0  0  0 
1A59E88 	D8 E5 A0  1 
s"    my-#qtds 0  do" eval					( qtd )
1A59E8C 	9C 53 A0  1 
1A59E90 	11 20 20 20 6D 79 2D 23 
1A59E98 	71 74 64 73 20 30 20 20 
1A59EA0 	64 6F  0  0 D8 E5 A0  1 
s"       >r" eval						( r: qtd )
1A59EA8 	9C 53 A0  1  8 20 20 20 
1A59EB0 	20 20 20 3E 72  0  0  0 
1A59EB8 	D8 E5 A0  1 
s"       my-buf my-buf-phys /my-buf r@ fill-qtd-bptrs" eval	( /bptr r: qtd )
1A59EBC 	9C 53 A0  1 
1A59EC0 	32 20 20 20 20 20 20 6D 
1A59EC8 	79 2D 62 75 66 20 6D 79 
1A59ED0 	2D 62 75 66 2D 70 68 79 
1A59ED8 	73 20 2F 6D 79 2D 62 75 
1A59EE0 	66 20 72 40 20 66 69 6C 
1A59EE8 	6C 2D 71 74 64 2D 62 70 
1A59EF0 	74 72 73  0 D8 E5 A0  1 
s"       dup r@ >hcqtd-token 2+ le-w!" eval			( /bptr r: qtd )
1A59EF8 	9C 53 A0  1 22 20 20 20 
1A59F00 	20 20 20 64 75 70 20 72 
1A59F08 	40 20 3E 68 63 71 74 64 
1A59F10 	2D 74 6F 6B 65 6E 20 32 
1A59F18 	2B 20 6C 65 2D 77 21  0 
1A59F20 	D8 E5 A0  1 
s"       my-buf++" eval						( r: qtd )
1A59F24 	9C 53 A0  1 
1A59F28 	 E 20 20 20 20 20 20 6D 
1A59F30 	79 2D 62 75 66 2B 2B  0 
1A59F38 	D8 E5 A0  1 
s"       r> >qtd-next l@" eval					( qtd' )
1A59F3C 	9C 53 A0  1 
1A59F40 	15 20 20 20 20 20 20 72 
1A59F48 	3E 20 3E 71 74 64 2D 6E 
1A59F50 	65 78 74 20 6C 40  0  0 
1A59F58 	D8 E5 A0  1 
s"   loop  drop ;" eval
1A59F5C 	9C 53 A0  1 
1A59F60 	 E 20 20 6C 6F 6F 70 20 
1A59F68 	20 64 72 6F 70 20 3B  0 
1A59F70 	D8 E5 A0  1 

\ Attach the qtd transaction chain beginning at "qtd" to "successor-qtd".
s" : attach-qtds" eval  ( successor-qtd qtd -- )
1A59F74 	9C 53 A0  1 
1A59F78 	 D 3A 20 61 74 74 61 63 
1A59F80 	68 2D 71 74 64 73  0  0 
1A59F88 	D8 E5 A0  1 
s"    begin" eval				( succ qtd )
1A59F8C 	9C 53 A0  1 
1A59F90 	 8 20 20 20 62 65 67 69 
1A59F98 	6E  0  0  0 D8 E5 A0  1 
      \ Test before setting "next-alt"
s"       more-qtds? >r" eval			( succ qtd r: flag )
1A59FA0 	9C 53 A0  1 13 20 20 20 
1A59FA8 	20 20 20 6D 6F 72 65 2D 
1A59FB0 	71 74 64 73 3F 20 3E 72 
1A59FB8 	 0  0  0  0 D8 E5 A0  1 

      \ Point each next-alt field to the successor
s"       over >qtd-phys l@" eval			( succ qtd succ-phys )
1A59FC0 	9C 53 A0  1 17 20 20 20 
1A59FC8 	20 20 20 6F 76 65 72 20 
1A59FD0 	3E 71 74 64 2D 70 68 79 
1A59FD8 	73 20 6C 40  0  0  0  0 
1A59FE0 	D8 E5 A0  1 
s"       over >hcqtd-next-alt le-l!" eval	( succ qtd r: flag )
1A59FE4 	9C 53 A0  1 
1A59FE8 	20 20 20 20 20 20 20 6F 
1A59FF0 	76 65 72 20 3E 68 63 71 
1A59FF8 	74 64 2D 6E 65 78 74 2D 
1A5A000 	61 6C 74 20 6C 65 2D 6C 
1A5A008 	21  0  0  0 D8 E5 A0  1 
s"    r>  while" eval				( succ qtd )
1A5A010 	9C 53 A0  1  C 20 20 20 
1A5A018 	72 3E 20 20 77 68 69 6C 
1A5A020 	65  0  0  0 D8 E5 A0  1 
s"       >qtd-next l@" eval			( succ qtd' )
1A5A028 	9C 53 A0  1 12 20 20 20 
1A5A030 	20 20 20 3E 71 74 64 2D 
1A5A038 	6E 65 78 74 20 6C 40  0 
1A5A040 	D8 E5 A0  1 
s"   repeat" eval				( succ last-qtd )
1A5A044 	9C 53 A0  1 
1A5A048 	 8 20 20 72 65 70 65 61 
1A5A050 	74  0  0  0 D8 E5 A0  1 

   \ Only the final qtd's next field points to the successor
s"   over >qtd-phys l@  over  >hcqtd-next le-l!" eval	( succ last-qtd )
1A5A058 	9C 53 A0  1 2C 20 20 6F 
1A5A060 	76 65 72 20 3E 71 74 64 
1A5A068 	2D 70 68 79 73 20 6C 40 
1A5A070 	20 20 6F 76 65 72 20 20 
1A5A078 	3E 68 63 71 74 64 2D 6E 
1A5A080 	65 78 74 20 6C 65 2D 6C 
1A5A088 	21  0  0  0 D8 E5 A0  1 
s"   >qtd-next l! ;" eval
1A5A090 	9C 53 A0  1 10 20 20 3E 
1A5A098 	71 74 64 2D 6E 65 78 74 
1A5A0A0 	20 6C 21 20 3B  0  0  0 
1A5A0A8 	D8 E5 A0  1 

s" : alloc-ring-qhqtds" eval  ( buf-pa /buf #bufs -- qh qtd )
1A5A0AC 	9C 53 A0  1 
1A5A0B0 	13 3A 20 61 6C 6C 6F 63 
1A5A0B8 	2D 72 69 6E 67 2D 71 68 
1A5A0C0 	71 74 64 73  0  0  0  0 
1A5A0C8 	D8 E5 A0  1 
s"    0 swap  0 ?do" eval		( pa /buf #qtds )
1A5A0CC 	9C 53 A0  1 
1A5A0D0 	10 20 20 20 30 20 73 77 
1A5A0D8 	61 70 20 20 30 20 3F 64 
1A5A0E0 	6F  0  0  0 D8 E5 A0  1 
s"       >r 2dup cal-#qtd >r" eval 	( pa /buf r: #qtds this-#qtds )
1A5A0E8 	9C 53 A0  1 19 20 20 20 
1A5A0F0 	20 20 20 3E 72 20 32 64 
1A5A0F8 	75 70 20 63 61 6C 2D 23 
1A5A100 	71 74 64 20 3E 72  0  0 
1A5A108 	D8 E5 A0  1 
s"       tuck + swap" eval		( pa' /buf r: #qtds this-#qtds )
1A5A10C 	9C 53 A0  1 
1A5A110 	11 20 20 20 20 20 20 74 
1A5A118 	75 63 6B 20 2B 20 73 77 
1A5A120 	61 70  0  0 D8 E5 A0  1 
s"       r> r> +" eval			( pa' /buf #qtds' )
1A5A128 	9C 53 A0  1  D 20 20 20 
1A5A130 	20 20 20 72 3E 20 72 3E 
1A5A138 	20 2B  0  0 D8 E5 A0  1 
s"    loop" eval				( pa' /buf #qtds' )
1A5A140 	9C 53 A0  1  7 20 20 20 
1A5A148 	6C 6F 6F 70  0  0  0  0 
1A5A150 	D8 E5 A0  1 
s"    nip nip  alloc-qhqtds ;" eval	( qh qtd0 )
1A5A154 	9C 53 A0  1 
1A5A158 	1A 20 20 20 6E 69 70 20 
1A5A160 	6E 69 70 20 20 61 6C 6C 
1A5A168 	6F 63 2D 71 68 71 74 64 
1A5A170 	73 20 3B  0 D8 E5 A0  1 


s" : unmap&free" eval  ( va pa len -- )
1A5A178 	9C 53 A0  1  C 3A 20 75 
1A5A180 	6E 6D 61 70 26 66 72 65 
1A5A188 	65  0  0  0 D8 E5 A0  1 
s"    >r" eval			( va pa r: len )
1A5A190 	9C 53 A0  1  5 20 20 20 
1A5A198 	3E 72  0  0 D8 E5 A0  1 
s"    over swap" eval		( va va pa r: len )
1A5A1A0 	9C 53 A0  1  C 20 20 20 
1A5A1A8 	6F 76 65 72 20 73 77 61 
1A5A1B0 	70  0  0  0 D8 E5 A0  1 
s"    r@ hcd-map-out" eval	( va r: len )
1A5A1B8 	9C 53 A0  1 11 20 20 20 
1A5A1C0 	72 40 20 68 63 64 2D 6D 
1A5A1C8 	61 70 2D 6F 75 74  0  0 
1A5A1D0 	D8 E5 A0  1 
s"    r> dma-free ;" eval
1A5A1D4 	9C 53 A0  1 
1A5A1D8 	10 20 20 20 72 3E 20 64 
1A5A1E0 	6D 61 2D 66 72 65 65 20 
1A5A1E8 	3B  0  0  0 D8 E5 A0  1 
s" : alloc&map" eval  ( len -- va pa )
1A5A1F0 	9C 53 A0  1  B 3A 20 61 
1A5A1F8 	6C 6C 6F 63 26 6D 61 70 
1A5A200 	 0  0  0  0 D8 E5 A0  1 
s"    dup dma-alloc" eval	( totlen va )
1A5A208 	9C 53 A0  1 10 20 20 20 
1A5A210 	64 75 70 20 64 6D 61 2D 
1A5A218 	61 6C 6C 6F 63  0  0  0 
1A5A220 	D8 E5 A0  1 
s"    dup rot hcd-map-in ;" eval 	( va pa )
1A5A224 	9C 53 A0  1 
1A5A228 	17 20 20 20 64 75 70 20 
1A5A230 	72 6F 74 20 68 63 64 2D 
1A5A238 	6D 61 70 2D 69 6E 20 3B 
1A5A240 	 0  0  0  0 D8 E5 A0  1 
\ It would be better to put these fields in the qh extension
\ so we don't need separate ones for in and out.

s" : free-ring" eval  ( qh -- )
1A5A248 	9C 53 A0  1  B 3A 20 66 
1A5A250 	72 65 65 2D 72 69 6E 67 
1A5A258 	 0  0  0  0 D8 E5 A0  1 
s"    >r  r@ >qh-buf l@  r@ >qh-buf-pa l@" eval
1A5A260 	9C 53 A0  1 26 20 20 20 
1A5A268 	3E 72 20 20 72 40 20 3E 
1A5A270 	71 68 2D 62 75 66 20 6C 
1A5A278 	40 20 20 72 40 20 3E 71 
1A5A280 	68 2D 62 75 66 2D 70 61 
1A5A288 	20 6C 40  0 D8 E5 A0  1 
s"    r@ >qh-#bufs l@  r> >qh-/buf l@ *" eval
1A5A290 	9C 53 A0  1 24 20 20 20 
1A5A298 	72 40 20 3E 71 68 2D 23 
1A5A2A0 	62 75 66 73 20 6C 40 20 
1A5A2A8 	20 72 3E 20 3E 71 68 2D 
1A5A2B0 	2F 62 75 66 20 6C 40 20 
1A5A2B8 	2A  0  0  0 D8 E5 A0  1 
s"    unmap&free ;" eval
1A5A2C0 	9C 53 A0  1  F 20 20 20 
1A5A2C8 	75 6E 6D 61 70 26 66 72 
1A5A2D0 	65 65 20 3B  0  0  0  0 
1A5A2D8 	D8 E5 A0  1 

s" : set-bulk-in-timeout  ( ms -- )   to bulk-in-timeout  ;" eval
1A5A2DC 	9C 53 A0  1 
1A5A2E0 	38 3A 20 73 65 74 2D 62 
1A5A2E8 	75 6C 6B 2D 69 6E 2D 74 
1A5A2F0 	69 6D 65 6F 75 74 20 20 
1A5A2F8 	28 20 6D 73 20 2D 2D 20 
1A5A300 	29 20 20 20 74 6F 20 62 
1A5A308 	75 6C 6B 2D 69 6E 2D 74 
1A5A310 	69 6D 65 6F 75 74 20 20 
1A5A318 	3B  0  0  0 D8 E5 A0  1 

s" : alloc-ring-bufs" eval  ( /buf #bufs qh -- )
1A5A320 	9C 53 A0  1 11 3A 20 61 
1A5A328 	6C 6C 6F 63 2D 72 69 6E 
1A5A330 	67 2D 62 75 66 73  0  0 
1A5A338 	D8 E5 A0  1 
s"    >r" eval
1A5A33C 	9C 53 A0  1 
1A5A340 	 5 20 20 20 3E 72  0  0 
1A5A348 	D8 E5 A0  1 
s"    2dup  r@ >qh-#bufs l!  r@ >qh-/buf l!" eval	( /buf #bufs )
1A5A34C 	9C 53 A0  1 
1A5A350 	28 20 20 20 32 64 75 70 
1A5A358 	20 20 72 40 20 3E 71 68 
1A5A360 	2D 23 62 75 66 73 20 6C 
1A5A368 	21 20 20 72 40 20 3E 71 
1A5A370 	68 2D 2F 62 75 66 20 6C 
1A5A378 	21  0  0  0 D8 E5 A0  1 
s"    * alloc&map  r@ >qh-buf-pa l!  r> >qh-buf l! ;" eval
1A5A380 	9C 53 A0  1 31 20 20 20 
1A5A388 	2A 20 61 6C 6C 6F 63 26 
1A5A390 	6D 61 70 20 20 72 40 20 
1A5A398 	3E 71 68 2D 62 75 66 2D 
1A5A3A0 	70 61 20 6C 21 20 20 72 
1A5A3A8 	3E 20 3E 71 68 2D 62 75 
1A5A3B0 	66 20 6C 21 20 3B  0  0 
1A5A3B8 	D8 E5 A0  1 

s" : link-ring" eval  ( qh qtd -- )
1A5A3BC 	9C 53 A0  1 
1A5A3C0 	 B 3A 20 6C 69 6E 6B 2D 
1A5A3C8 	72 69 6E 67  0  0  0  0 
1A5A3D0 	D8 E5 A0  1 
s"    swap >r" eval				( qtd r: qh )
1A5A3D4 	9C 53 A0  1 
1A5A3D8 	 A 20 20 20 73 77 61 70 
1A5A3E0 	20 3E 72  0 D8 E5 A0  1 
s"    r@ >qh-buf-pa l@ to my-buf-phys" eval      ( qtd r: qh )
1A5A3E8 	9C 53 A0  1 22 20 20 20 
1A5A3F0 	72 40 20 3E 71 68 2D 62 
1A5A3F8 	75 66 2D 70 61 20 6C 40 
1A5A400 	20 74 6F 20 6D 79 2D 62 
1A5A408 	75 66 2D 70 68 79 73  0 
1A5A410 	D8 E5 A0  1 
s"    r@ >qh-buf    l@ to my-buf" eval		( qtd r: qh )
1A5A414 	9C 53 A0  1 
1A5A418 	1D 20 20 20 72 40 20 3E 
1A5A420 	71 68 2D 62 75 66 20 20 
1A5A428 	20 20 6C 40 20 74 6F 20 
1A5A430 	6D 79 2D 62 75 66  0  0 
1A5A438 	D8 E5 A0  1 
s"    r@ >qh-/buf   l@ swap" eval		( /buf qtd r: qh )
1A5A43C 	9C 53 A0  1 
1A5A440 	18 20 20 20 72 40 20 3E 
1A5A448 	71 68 2D 2F 62 75 66 20 
1A5A450 	20 20 6C 40 20 73 77 61 
1A5A458 	70  0  0  0 D8 E5 A0  1 
s"    r> >qh-#bufs  l@" eval			( /buf qtd #bufs )
1A5A460 	9C 53 A0  1 13 20 20 20 
1A5A468 	72 3E 20 3E 71 68 2D 23 
1A5A470 	62 75 66 73 20 20 6C 40 
1A5A478 	 0  0  0  0 D8 E5 A0  1 
s"    over >r" eval				( /buf qtd #bufs r: qtd0 )
1A5A480 	9C 53 A0  1  A 20 20 20 
1A5A488 	6F 76 65 72 20 3E 72  0 
1A5A490 	D8 E5 A0  1 
s"    1-  0  ?do" eval				( /buf qtd )
1A5A494 	9C 53 A0  1 
1A5A498 	 D 20 20 20 31 2D 20 20 
1A5A4A0 	30 20 20 3F 64 6F  0  0 
1A5A4A8 	D8 E5 A0  1 
s"       2dup new-fill-bulk-io-qtds" eval	( /buf qtd )
1A5A4AC 	9C 53 A0  1 
1A5A4B0 	20 20 20 20 20 20 20 32 
1A5A4B8 	64 75 70 20 6E 65 77 2D 
1A5A4C0 	66 69 6C 6C 2D 62 75 6C 
1A5A4C8 	6B 2D 69 6F 2D 71 74 64 
1A5A4D0 	73  0  0  0 D8 E5 A0  1 
s"       dup  my-#qtds /qtd * +" eval		( /buf qtd next-qtd )
1A5A4D8 	9C 53 A0  1 1C 20 20 20 
1A5A4E0 	20 20 20 64 75 70 20 20 
1A5A4E8 	6D 79 2D 23 71 74 64 73 
1A5A4F0 	20 2F 71 74 64 20 2A 20 
1A5A4F8 	2B  0  0  0 D8 E5 A0  1 
s"       dup rot attach-qtds" eval		( /buf next-qtd )
1A5A500 	9C 53 A0  1 19 20 20 20 
1A5A508 	20 20 20 64 75 70 20 72 
1A5A510 	6F 74 20 61 74 74 61 63 
1A5A518 	68 2D 71 74 64 73  0  0 
1A5A520 	D8 E5 A0  1 
s"    loop" eval				( /buf qtd r: qtd0 )
1A5A524 	9C 53 A0  1 
1A5A528 	 7 20 20 20 6C 6F 6F 70 
1A5A530 	 0  0  0  0 D8 E5 A0  1 
s"    tuck new-fill-bulk-io-qtds" eval		( qtd  r: qtd0 )
1A5A538 	9C 53 A0  1 1D 20 20 20 
1A5A540 	74 75 63 6B 20 6E 65 77 
1A5A548 	2D 66 69 6C 6C 2D 62 75 
1A5A550 	6C 6B 2D 69 6F 2D 71 74 
1A5A558 	64 73  0  0 D8 E5 A0  1 
s"    r> swap attach-qtds ;" eval
1A5A560 	9C 53 A0  1 18 20 20 20 
1A5A568 	72 3E 20 73 77 61 70 20 
1A5A570 	61 74 74 61 63 68 2D 71 
1A5A578 	74 64 73 20 3B  0  0  0 
1A5A580 	D8 E5 A0  1 
s" : make-ring" eval  ( /buf #bufs in? -- qh qtd )
1A5A584 	9C 53 A0  1 
1A5A588 	 B 3A 20 6D 61 6B 65 2D 
1A5A590 	72 69 6E 67  0  0  0  0 
1A5A598 	D8 E5 A0  1 
s"    -rot" eval                                ( in? /buf #bufs )
1A5A59C 	9C 53 A0  1 
1A5A5A0 	 7 20 20 20 2D 72 6F 74 
1A5A5A8 	 0  0  0  0 D8 E5 A0  1 
s"    2dup * alloc&map" eval				( in? /buf #bufs va pa )
1A5A5B0 	9C 53 A0  1 13 20 20 20 
1A5A5B8 	32 64 75 70 20 2A 20 61 
1A5A5C0 	6C 6C 6F 63 26 6D 61 70 
1A5A5C8 	 0  0  0  0 D8 E5 A0  1 
s"    dup  4 pick 4 pick  alloc-ring-qhqtds" eval	( in? /buf #bufs va pa qh qtd )
1A5A5D0 	9C 53 A0  1 28 20 20 20 
1A5A5D8 	64 75 70 20 20 34 20 70 
1A5A5E0 	69 63 6B 20 34 20 70 69 
1A5A5E8 	63 6B 20 20 61 6C 6C 6F 
1A5A5F0 	63 2D 72 69 6E 67 2D 71 
1A5A5F8 	68 71 74 64 73  0  0  0 
1A5A600 	D8 E5 A0  1 
s"    >r >r" eval					( in? /buf #bufs va pa r: qtd qh )
1A5A604 	9C 53 A0  1 
1A5A608 	 8 20 20 20 3E 72 20 3E 
1A5A610 	72  0  0  0 D8 E5 A0  1 
s"    r@ >qh-buf-pa l!  r@ >qh-buf  l!" eval		( in? /buf #bufs )
1A5A618 	9C 53 A0  1 23 20 20 20 
1A5A620 	72 40 20 3E 71 68 2D 62 
1A5A628 	75 66 2D 70 61 20 6C 21 
1A5A630 	20 20 72 40 20 3E 71 68 
1A5A638 	2D 62 75 66 20 20 6C 21 
1A5A640 	 0  0  0  0 D8 E5 A0  1 
s"    r@ >qh-#bufs  l!  r@ >qh-/buf l!" eval		( in? r: qtd qh )
1A5A648 	9C 53 A0  1 23 20 20 20 
1A5A650 	72 40 20 3E 71 68 2D 23 
1A5A658 	62 75 66 73 20 20 6C 21 
1A5A660 	20 20 72 40 20 3E 71 68 
1A5A668 	2D 2F 62 75 66 20 6C 21 
1A5A670 	 0  0  0  0 D8 E5 A0  1 
s"    r@ pt-bulk fill-qh" eval				( in? r: qtd qh )
1A5A678 	9C 53 A0  1 15 20 20 20 
1A5A680 	72 40 20 70 74 2D 62 75 
1A5A688 	6C 6B 20 66 69 6C 6C 2D 
1A5A690 	71 68  0  0 D8 E5 A0  1 
   \ Let the QH keep track of the data toggle on an ongoing basis ...
s"   r@ >hcqh-endp-char dup le-l@ QH_TD_TOGGLE invert and swap le-l!" eval
1A5A698 	9C 53 A0  1 41 20 20 72 
1A5A6A0 	40 20 3E 68 63 71 68 2D 
1A5A6A8 	65 6E 64 70 2D 63 68 61 
1A5A6B0 	72 20 64 75 70 20 6C 65 
1A5A6B8 	2D 6C 40 20 51 48 5F 54 
1A5A6C0 	44 5F 54 4F 47 47 4C 45 
1A5A6C8 	20 69 6E 76 65 72 74 20 
1A5A6D0 	61 6E 64 20 73 77 61 70 
1A5A6D8 	20 6C 65 2D 6C 21  0  0 
1A5A6E0 	D8 E5 A0  1 

   \ But we have to initialize it here based on the last state
s"    r@ >hcqh-overlay >hcqtd-token" eval                ( in? token-adr r: qtd qh )
1A5A6E4 	9C 53 A0  1 
1A5A6E8 	20 20 20 20 72 40 20 3E 
1A5A6F0 	68 63 71 68 2D 6F 76 65 
1A5A6F8 	72 6C 61 79 20 3E 68 63 
1A5A700 	71 74 64 2D 74 6F 6B 65 
1A5A708 	6E  0  0  0 D8 E5 A0  1 
s"    dup le-l@" eval                                    ( in? token-adr token-val r: qtd qh )
1A5A710 	9C 53 A0  1  C 20 20 20 
1A5A718 	64 75 70 20 6C 65 2D 6C 
1A5A720 	40  0  0  0 D8 E5 A0  1 
s"    rot  if  bulk-in-data@  else  bulk-out-data@  then" eval   ( token-adr token-val toggle r: qtd qh )
1A5A728 	9C 53 A0  1 35 20 20 20 
1A5A730 	72 6F 74 20 20 69 66 20 
1A5A738 	20 62 75 6C 6B 2D 69 6E 
1A5A740 	2D 64 61 74 61 40 20 20 
1A5A748 	65 6C 73 65 20 20 62 75 
1A5A750 	6C 6B 2D 6F 75 74 2D 64 
1A5A758 	61 74 61 40 20 20 74 68 
1A5A760 	65 6E  0  0 D8 E5 A0  1 
s"    or" eval                                           ( token-adr token-val' r: qtd qh )
1A5A768 	9C 53 A0  1  5 20 20 20 
1A5A770 	6F 72  0  0 D8 E5 A0  1 
s"    TD_IOC or" eval                                    ( token-adr token-val' r: qtd qh )
1A5A778 	9C 53 A0  1  C 20 20 20 
1A5A780 	54 44 5F 49 4F 43 20 6F 
1A5A788 	72  0  0  0 D8 E5 A0  1 
s"    swap le-l!" eval                                   ( r: qtd qh )
1A5A790 	9C 53 A0  1  D 20 20 20 
1A5A798 	73 77 61 70 20 6C 65 2D 
1A5A7A0 	6C 21  0  0 D8 E5 A0  1 

s"    r> r>" eval					( qh qtd )
1A5A7A8 	9C 53 A0  1  8 20 20 20 
1A5A7B0 	72 3E 20 72 3E  0  0  0 
1A5A7B8 	D8 E5 A0  1 
s"    2dup link-ring" eval				( qh qtd )
1A5A7BC 	9C 53 A0  1 
1A5A7C0 	11 20 20 20 32 64 75 70 
1A5A7C8 	20 6C 69 6E 6B 2D 72 69 
1A5A7D0 	6E 67  0  0 D8 E5 A0  1 
s"    over insert-qh ;" eval				( qh qtd )
1A5A7D8 	9C 53 A0  1 13 20 20 20 
1A5A7E0 	6F 76 65 72 20 69 6E 73 
1A5A7E8 	65 72 74 2D 71 68 20 3B 
1A5A7F0 	 0  0  0  0 D8 E5 A0  1 
\ Find the last qtd in a chain of qtds for the same transaction.
s" : transaction-last-qtd" eval  ( qtd -- qtd' )
1A5A7F8 	9C 53 A0  1 16 3A 20 74 
1A5A800 	72 61 6E 73 61 63 74 69 
1A5A808 	6F 6E 2D 6C 61 73 74 2D 
1A5A810 	71 74 64  0 D8 E5 A0  1 
s"    begin  more-qtds?  while  >qtd-next l@  repeat ;" eval	( qtd' )
1A5A818 	9C 53 A0  1 33 20 20 20 
1A5A820 	62 65 67 69 6E 20 20 6D 
1A5A828 	6F 72 65 2D 71 74 64 73 
1A5A830 	3F 20 20 77 68 69 6C 65 
1A5A838 	20 20 3E 71 74 64 2D 6E 
1A5A840 	65 78 74 20 6C 40 20 20 
1A5A848 	72 65 70 65 61 74 20 3B 
1A5A850 	 0  0  0  0 D8 E5 A0  1 


s" : qtd-successor  ( qtd -- qtd' )  transaction-last-qtd >qtd-next l@  ;" eval
1A5A858 	9C 53 A0  1 46 3A 20 71 
1A5A860 	74 64 2D 73 75 63 63 65 
1A5A868 	73 73 6F 72 20 20 28 20 
1A5A870 	71 74 64 20 2D 2D 20 71 
1A5A878 	74 64 27 20 29 20 20 74 
1A5A880 	72 61 6E 73 61 63 74 69 
1A5A888 	6F 6E 2D 6C 61 73 74 2D 
1A5A890 	71 74 64 20 3E 71 74 64 
1A5A898 	2D 6E 65 78 74 20 6C 40 
1A5A8A0 	20 20 3B  0 D8 E5 A0  1 

\ Insert the qtd transaction chain "new-qtd" in the circular list
\ after "qtd".  This is safe only if qtd is inactive.
s" : qtd-insert-after" eval  ( new-qtd qtd -- )
1A5A8A8 	9C 53 A0  1 12 3A 20 71 
1A5A8B0 	74 64 2D 69 6E 73 65 72 
1A5A8B8 	74 2D 61 66 74 65 72  0 
1A5A8C0 	D8 E5 A0  1 
   \ First make qtd's successor new-qtd's successor
s"    2dup qtd-successor swap attach-qtds" eval	( new-qtd qtd )
1A5A8C4 	9C 53 A0  1 
1A5A8C8 	26 20 20 20 32 64 75 70 
1A5A8D0 	20 71 74 64 2D 73 75 63 
1A5A8D8 	63 65 73 73 6F 72 20 73 
1A5A8E0 	77 61 70 20 61 74 74 61 
1A5A8E8 	63 68 2D 71 74 64 73  0 
1A5A8F0 	D8 E5 A0  1 
   \ Then make new-qtd qtd's successor
s"    attach-qtds ;" eval
1A5A8F4 	9C 53 A0  1 
1A5A8F8 	10 20 20 20 61 74 74 61 
1A5A900 	63 68 2D 71 74 64 73 20 
1A5A908 	3B  0  0  0 D8 E5 A0  1 

s" 0 value bulk-out-pending" eval
1A5A910 	9C 53 A0  1 18 30 20 76 
1A5A918 	61 6C 75 65 20 62 75 6C 
1A5A920 	6B 2D 6F 75 74 2D 70 65 
1A5A928 	6E 64 69 6E 67  0  0  0 
1A5A930 	D8 E5 A0  1 
s" : activate-out" eval  ( qtd len -- )
1A5A934 	9C 53 A0  1 
1A5A938 	 E 3A 20 61 63 74 69 76 
1A5A940 	61 74 65 2D 6F 75 74  0 
1A5A948 	D8 E5 A0  1 
s"    over to bulk-out-pending" eval	( qtd len )
1A5A94C 	9C 53 A0  1 
1A5A950 	1B 20 20 20 6F 76 65 72 
1A5A958 	20 74 6F 20 62 75 6C 6B 
1A5A960 	2D 6F 75 74 2D 70 65 6E 
1A5A968 	64 69 6E 67  0  0  0  0 
1A5A970 	D8 E5 A0  1 
s"    over >hcqtd-token" eval		( qtd len token-adr )
1A5A974 	9C 53 A0  1 
1A5A978 	14 20 20 20 6F 76 65 72 
1A5A980 	20 3E 68 63 71 74 64 2D 
1A5A988 	74 6F 6B 65 6E  0  0  0 
1A5A990 	D8 E5 A0  1 
s"    tuck 2+ le-w!" eval		( qtd token-adr )
1A5A994 	9C 53 A0  1 
1A5A998 	10 20 20 20 74 75 63 6B 
1A5A9A0 	20 32 2B 20 6C 65 2D 77 
1A5A9A8 	21  0  0  0 D8 E5 A0  1 
s"    TD_C_ERR3  TD_PID_OUT or  TD_STAT_PING or  TD_STAT_ACTIVE or   swap le-w!" eval  ( qtd )
1A5A9B0 	9C 53 A0  1 4C 20 20 20 
1A5A9B8 	54 44 5F 43 5F 45 52 52 
1A5A9C0 	33 20 20 54 44 5F 50 49 
1A5A9C8 	44 5F 4F 55 54 20 6F 72 
1A5A9D0 	20 20 54 44 5F 53 54 41 
1A5A9D8 	54 5F 50 49 4E 47 20 6F 
1A5A9E0 	72 20 20 54 44 5F 53 54 
1A5A9E8 	41 54 5F 41 43 54 49 56 
1A5A9F0 	45 20 6F 72 20 20 20 73 
1A5A9F8 	77 61 70 20 6C 65 2D 77 
1A5AA00 	21  0  0  0 D8 E5 A0  1 
s"   push-qtd ;" eval
1A5AA08 	9C 53 A0  1  C 20 20 70 
1A5AA10 	75 73 68 2D 71 74 64 20 
1A5AA18 	3B  0  0  0 D8 E5 A0  1 

s" : wait-out" eval  ( qtd -- error? )
1A5AA20 	9C 53 A0  1  A 3A 20 77 
1A5AA28 	61 69 74 2D 6F 75 74  0 
1A5AA30 	D8 E5 A0  1 
s"    begin  dup qtd-done?  until" eval	( qtd )
1A5AA34 	9C 53 A0  1 
1A5AA38 	1E 20 20 20 62 65 67 69 
1A5AA40 	6E 20 20 64 75 70 20 71 
1A5AA48 	74 64 2D 64 6F 6E 65 3F 
1A5AA50 	20 20 75 6E 74 69 6C  0 
1A5AA58 	D8 E5 A0  1 
s"    >hcqtd-token c@ h# fc and ;" eval
1A5AA5C 	9C 53 A0  1 
1A5AA60 	1E 20 20 20 3E 68 63 71 
1A5AA68 	74 64 2D 74 6F 6B 65 6E 
1A5AA70 	20 63 40 20 68 23 20 66 
1A5AA78 	63 20 61 6E 64 20 3B  0 
1A5AA80 	D8 E5 A0  1 

\ Possible enhancement: pass in a size argument so that a chain of qtds can be
\ allocated, with more total buffer space than can be represented by one qtd.
\ That can get complicated though - if the chain wraps around the ring, the
\ buffer space would be discontiguous.

s" : get-out-buffer" eval  ( -- qtd buf )
1A5AA84 	9C 53 A0  1 
1A5AA88 	10 3A 20 67 65 74 2D 6F 
1A5AA90 	75 74 2D 62 75 66 66 65 
1A5AA98 	72  0  0  0 D8 E5 A0  1 
s"    bulk-out-qtd begin  dup qtd-done?  until" eval	( qtd )
1A5AAA0 	9C 53 A0  1 2B 20 20 20 
1A5AAA8 	62 75 6C 6B 2D 6F 75 74 
1A5AAB0 	2D 71 74 64 20 62 65 67 
1A5AAB8 	69 6E 20 20 64 75 70 20 
1A5AAC0 	71 74 64 2D 64 6F 6E 65 
1A5AAC8 	3F 20 20 75 6E 74 69 6C 
1A5AAD0 	 0  0  0  0 D8 E5 A0  1 
s"    dup >qtd-next l@ to bulk-out-qtd" eval		( qtd )
1A5AAD8 	9C 53 A0  1 23 20 20 20 
1A5AAE0 	64 75 70 20 3E 71 74 64 
1A5AAE8 	2D 6E 65 78 74 20 6C 40 
1A5AAF0 	20 74 6F 20 62 75 6C 6B 
1A5AAF8 	2D 6F 75 74 2D 71 74 64 
1A5AB00 	 0  0  0  0 D8 E5 A0  1 
s"   dup >qtd-buf	l@ ;" eval				( qtd buf )
1A5AB08 	9C 53 A0  1 13 20 20 64 
1A5AB10 	75 70 20 3E 71 74 64 2D 
1A5AB18 	62 75 66  9 6C 40 20 3B 
1A5AB20 	 0  0  0  0 D8 E5 A0  1 


s" : send-out" eval  ( adr len -- qtd )
1A5AB28 	9C 53 A0  1  A 3A 20 73 
1A5AB30 	65 6E 64 2D 6F 75 74  0 
1A5AB38 	D8 E5 A0  1 
s"    >r  get-out-buffer" eval				( adr qtd buf r: len )
1A5AB3C 	9C 53 A0  1 
1A5AB40 	15 20 20 20 3E 72 20 20 
1A5AB48 	67 65 74 2D 6F 75 74 2D 
1A5AB50 	62 75 66 66 65 72  0  0 
1A5AB58 	D8 E5 A0  1 
s"    rot swap r@ move" eval				( qtd r: len )
1A5AB5C 	9C 53 A0  1 
1A5AB60 	13 20 20 20 72 6F 74 20 
1A5AB68 	73 77 61 70 20 72 40 20 
1A5AB70 	6D 6F 76 65  0  0  0  0 
1A5AB78 	D8 E5 A0  1 
s"    dup r> activate-out ;" eval
1A5AB7C 	9C 53 A0  1 
1A5AB80 	18 20 20 20 64 75 70 20 
1A5AB88 	72 3E 20 61 63 74 69 76 
1A5AB90 	61 74 65 2D 6F 75 74 20 
1A5AB98 	3B  0  0  0 D8 E5 A0  1 

s" : begin-out-ring" eval  ( /buf #bufs pipe -- )
1A5ABA0 	9C 53 A0  1 10 3A 20 62 
1A5ABA8 	65 67 69 6E 2D 6F 75 74 
1A5ABB0 	2D 72 69 6E 67  0  0  0 
1A5ABB8 	D8 E5 A0  1 
 "    debug?  if  ."" begin-out-ring"" cr  then" eval
1A5ABBC 	9C 53 A0  1 
1A5ABC0 	2A 20 20 20 64 65 62 75 
1A5ABC8 	67 3F 20 20 69 66 20 20 
1A5ABD0 	2E 22 20 62 65 67 69 6E 
1A5ABD8 	2D 6F 75 74 2D 72 69 6E 
1A5ABE0 	67 22 20 63 72 20 20 74 
1A5ABE8 	68 65 6E  0 D8 E5 A0  1 
s"   bulk-out-qh  if  3drop exit  then" eval		\ Already started
1A5ABF0 	9C 53 A0  1 23 20 20 62 
1A5ABF8 	75 6C 6B 2D 6F 75 74 2D 
1A5AC00 	71 68 20 20 69 66 20 20 
1A5AC08 	33 64 72 6F 70 20 65 78 
1A5AC10 	69 74 20 20 74 68 65 6E 
1A5AC18 	 0  0  0  0 D8 E5 A0  1 

s"    dup to bulk-out-pipe" eval				( /buf #bufs pipe )
1A5AC20 	9C 53 A0  1 17 20 20 20 
1A5AC28 	64 75 70 20 74 6F 20 62 
1A5AC30 	75 6C 6B 2D 6F 75 74 2D 
1A5AC38 	70 69 70 65  0  0  0  0 
1A5AC40 	D8 E5 A0  1 
s"    set-bulk-vars" eval				( /buf #bufs )
1A5AC44 	9C 53 A0  1 
1A5AC48 	10 20 20 20 73 65 74 2D 
1A5AC50 	62 75 6C 6B 2D 76 61 72 
1A5AC58 	73  0  0  0 D8 E5 A0  1 

s"    false make-ring" eval				( qh qtd )
1A5AC60 	9C 53 A0  1 12 20 20 20 
1A5AC68 	66 61 6C 73 65 20 6D 61 
1A5AC70 	6B 65 2D 72 69 6E 67  0 
1A5AC78 	D8 E5 A0  1 
s"    to bulk-out-qtd  to bulk-out-qh" eval
1A5AC7C 	9C 53 A0  1 
1A5AC80 	22 20 20 20 74 6F 20 62 
1A5AC88 	75 6C 6B 2D 6F 75 74 2D 
1A5AC90 	71 74 64 20 20 74 6F 20 
1A5AC98 	62 75 6C 6B 2D 6F 75 74 
1A5ACA0 	2D 71 68  0 D8 E5 A0  1 
s"    bulk-out-timeout bulk-out-qh >qh-timeout l! ;" eval
1A5ACA8 	9C 53 A0  1 30 20 20 20 
1A5ACB0 	62 75 6C 6B 2D 6F 75 74 
1A5ACB8 	2D 74 69 6D 65 6F 75 74 
1A5ACC0 	20 62 75 6C 6B 2D 6F 75 
1A5ACC8 	74 2D 71 68 20 3E 71 68 
1A5ACD0 	2D 74 69 6D 65 6F 75 74 
1A5ACD8 	20 6C 21 20 3B  0  0  0 
1A5ACE0 	D8 E5 A0  1 

s" : begin-in-ring" eval  ( /buf #bufs pipe -- )
1A5ACE4 	9C 53 A0  1 
1A5ACE8 	 F 3A 20 62 65 67 69 6E 
1A5ACF0 	2D 69 6E 2D 72 69 6E 67 
1A5ACF8 	 0  0  0  0 D8 E5 A0  1 
 "    debug?  if  ."" begin-bulk-in-ring"" cr  then" eval
1A5AD00 	9C 53 A0  1 2E 20 20 20 
1A5AD08 	64 65 62 75 67 3F 20 20 
1A5AD10 	69 66 20 20 2E 22 20 62 
1A5AD18 	65 67 69 6E 2D 62 75 6C 
1A5AD20 	6B 2D 69 6E 2D 72 69 6E 
1A5AD28 	67 22 20 63 72 20 20 74 
1A5AD30 	68 65 6E  0 D8 E5 A0  1 
s"    bulk-in-qh  if  3drop exit  then" eval		\ Already started
1A5AD38 	9C 53 A0  1 23 20 20 20 
1A5AD40 	62 75 6C 6B 2D 69 6E 2D 
1A5AD48 	71 68 20 20 69 66 20 20 
1A5AD50 	33 64 72 6F 70 20 65 78 
1A5AD58 	69 74 20 20 74 68 65 6E 
1A5AD60 	 0  0  0  0 D8 E5 A0  1 

s"    dup to bulk-in-pipe" eval				( /buf #bufs pipe )
1A5AD68 	9C 53 A0  1 16 20 20 20 
1A5AD70 	64 75 70 20 74 6F 20 62 
1A5AD78 	75 6C 6B 2D 69 6E 2D 70 
1A5AD80 	69 70 65  0 D8 E5 A0  1 
s"    set-bulk-vars" eval				( /buf #bufs )
1A5AD88 	9C 53 A0  1 10 20 20 20 
1A5AD90 	73 65 74 2D 62 75 6C 6B 
1A5AD98 	2D 76 61 72 73  0  0  0 
1A5ADA0 	D8 E5 A0  1 

s"    true make-ring" eval				( qh qtd )
1A5ADA4 	9C 53 A0  1 
1A5ADA8 	11 20 20 20 74 72 75 65 
1A5ADB0 	20 6D 61 6B 65 2D 72 69 
1A5ADB8 	6E 67  0  0 D8 E5 A0  1 
s"    dup activate-in-ring" eval				( qh qtd )
1A5ADC0 	9C 53 A0  1 17 20 20 20 
1A5ADC8 	64 75 70 20 61 63 74 69 
1A5ADD0 	76 61 74 65 2D 69 6E 2D 
1A5ADD8 	72 69 6E 67  0  0  0  0 
1A5ADE0 	D8 E5 A0  1 
s"    to bulk-in-qtd  to bulk-in-qh" eval
1A5ADE4 	9C 53 A0  1 
1A5ADE8 	20 20 20 20 74 6F 20 62 
1A5ADF0 	75 6C 6B 2D 69 6E 2D 71 
1A5ADF8 	74 64 20 20 74 6F 20 62 
1A5AE00 	75 6C 6B 2D 69 6E 2D 71 
1A5AE08 	68  0  0  0 D8 E5 A0  1 
s"    bulk-in-timeout bulk-in-qh >qh-timeout l!	;" eval
1A5AE10 	9C 53 A0  1 2E 20 20 20 
1A5AE18 	62 75 6C 6B 2D 69 6E 2D 
1A5AE20 	74 69 6D 65 6F 75 74 20 
1A5AE28 	62 75 6C 6B 2D 69 6E 2D 
1A5AE30 	71 68 20 3E 71 68 2D 74 
1A5AE38 	69 6D 65 6F 75 74 20 6C 
1A5AE40 	21  9 3B  0 D8 E5 A0  1 

s" : bulk-in-ready?" eval  ( -- false | error true |  buf actual 0 true )
1A5AE48 	9C 53 A0  1 10 3A 20 62 
1A5AE50 	75 6C 6B 2D 69 6E 2D 72 
1A5AE58 	65 61 64 79 3F  0  0  0 
1A5AE60 	D8 E5 A0  1 
s"    clear-usb-error" eval
1A5AE64 	9C 53 A0  1 
1A5AE68 	12 20 20 20 63 6C 65 61 
1A5AE70 	72 2D 75 73 62 2D 65 72 
1A5AE78 	72 6F 72  0 D8 E5 A0  1 
s"    bulk-in-qtd >r" eval
1A5AE80 	9C 53 A0  1 11 20 20 20 
1A5AE88 	62 75 6C 6B 2D 69 6E 2D 
1A5AE90 	71 74 64 20 3E 72  0  0 
1A5AE98 	D8 E5 A0  1 
s"    r@ pull-qtd" eval
1A5AE9C 	9C 53 A0  1 
1A5AEA0 	 E 20 20 20 72 40 20 70 
1A5AEA8 	75 6C 6C 2D 71 74 64  0 
1A5AEB0 	D8 E5 A0  1 
s"    r@ qtd-done?  if" eval
1A5AEB4 	9C 53 A0  1 
1A5AEB8 	13 20 20 20 72 40 20 71 
1A5AEC0 	74 64 2D 64 6F 6E 65 3F 
1A5AEC8 	20 20 69 66  0  0  0  0 
1A5AED0 	D8 E5 A0  1 
s"       r@  bulk-in-qh qtd-error? ?dup  0=  if" eval
1A5AED4 	9C 53 A0  1 
1A5AED8 	2C 20 20 20 20 20 20 72 
1A5AEE0 	40 20 20 62 75 6C 6B 2D 
1A5AEE8 	69 6E 2D 71 68 20 71 74 
1A5AEF0 	64 2D 65 72 72 6F 72 3F 
1A5AEF8 	20 3F 64 75 70 20 20 30 
1A5AF00 	3D 20 20 69 66  0  0  0 
1A5AF08 	D8 E5 A0  1 
s"          r@ >qtd-buf l@" eval				( buf actual )
1A5AF0C 	9C 53 A0  1 
1A5AF10 	17 20 20 20 20 20 20 20 
1A5AF18 	20 20 72 40 20 3E 71 74 
1A5AF20 	64 2D 62 75 66 20 6C 40 
1A5AF28 	 0  0  0  0 D8 E5 A0  1 
s"          r@ qtd-get-actual" eval			( buf actual )
1A5AF30 	9C 53 A0  1 1A 20 20 20 
1A5AF38 	20 20 20 20 20 20 72 40 
1A5AF40 	20 71 74 64 2D 67 65 74 
1A5AF48 	2D 61 63 74 75 61 6C  0 
1A5AF50 	D8 E5 A0  1 
s"          2dup  r@ >qtd-pbuf l@  swap  dma-pull" eval	( buf actual )
1A5AF54 	9C 53 A0  1 
1A5AF58 	2E 20 20 20 20 20 20 20 
1A5AF60 	20 20 32 64 75 70 20 20 
1A5AF68 	72 40 20 3E 71 74 64 2D 
1A5AF70 	70 62 75 66 20 6C 40 20 
1A5AF78 	20 73 77 61 70 20 20 64 
1A5AF80 	6D 61 2D 70 75 6C 6C  0 
1A5AF88 	D8 E5 A0  1 
s"          0" eval					( buf actual 0 )
1A5AF8C 	9C 53 A0  1 
1A5AF90 	 A 20 20 20 20 20 20 20 
1A5AF98 	20 20 30  0 D8 E5 A0  1 
s"       then" eval					( error | buf actual 0 )
1A5AFA0 	9C 53 A0  1  A 20 20 20 
1A5AFA8 	20 20 20 74 68 65 6E  0 
1A5AFB0 	D8 E5 A0  1 
s"       true" eval					( ... )
1A5AFB4 	9C 53 A0  1 
1A5AFB8 	 A 20 20 20 20 20 20 74 
1A5AFC0 	72 75 65  0 D8 E5 A0  1 
      \ Possibly unnecessary 
s"      r@ qtd-fixup-bulk-in-data" eval			( ... )
1A5AFC8 	9C 53 A0  1 1E 20 20 20 
1A5AFD0 	20 20 72 40 20 71 74 64 
1A5AFD8 	2D 66 69 78 75 70 2D 62 
1A5AFE0 	75 6C 6B 2D 69 6E 2D 64 
1A5AFE8 	61 74 61  0 D8 E5 A0  1 

\ XXX Ethernet does not like process-hc-status!
\      process-hc-status
s"    else" eval
1A5AFF0 	9C 53 A0  1  7 20 20 20 
1A5AFF8 	65 6C 73 65  0  0  0  0 
1A5B000 	D8 E5 A0  1 
s"       false" eval				        ( false )
1A5B004 	9C 53 A0  1 
1A5B008 	 B 20 20 20 20 20 20 66 
1A5B010 	61 6C 73 65  0  0  0  0 
1A5B018 	D8 E5 A0  1 
s"    then" eval						( ... )
1A5B01C 	9C 53 A0  1 
1A5B020 	 7 20 20 20 74 68 65 6E 
1A5B028 	 0  0  0  0 D8 E5 A0  1 
s"    r> drop ;" eval
1A5B030 	9C 53 A0  1  C 20 20 20 
1A5B038 	72 3E 20 64 72 6F 70 20 
1A5B040 	3B  0  0  0 D8 E5 A0  1 

s" : recycle-one-qtd" eval  ( qtd -- )
1A5B048 	9C 53 A0  1 11 3A 20 72 
1A5B050 	65 63 79 63 6C 65 2D 6F 
1A5B058 	6E 65 2D 71 74 64  0  0 
1A5B060 	D8 E5 A0  1 
   \ Clear "Current Offset" field in first buffer pointer
s"    dup >qtd-pbuf l@  over >hcqtd-bptr0 le-l!" eval  ( qtd )
1A5B064 	9C 53 A0  1 
1A5B068 	2C 20 20 20 64 75 70 20 
1A5B070 	3E 71 74 64 2D 70 62 75 
1A5B078 	66 20 6C 40 20 20 6F 76 
1A5B080 	65 72 20 3E 68 63 71 74 
1A5B088 	64 2D 62 70 74 72 30 20 
1A5B090 	6C 65 2D 6C 21  0  0  0 
1A5B098 	D8 E5 A0  1 

   \ Reset the "token" word which contains various transfer control bits
s"    dup >qtd-/buf l@ d# 16 <<" eval                  ( qtd token_word )
1A5B09C 	9C 53 A0  1 
1A5B0A0 	1C 20 20 20 64 75 70 20 
1A5B0A8 	3E 71 74 64 2D 2F 62 75 
1A5B0B0 	66 20 6C 40 20 64 23 20 
1A5B0B8 	31 36 20 3C 3C  0  0  0 
1A5B0C0 	D8 E5 A0  1 
s"    TD_STAT_ACTIVE or TD_C_ERR3 or TD_PID_IN or" eval     ( qtd token_word' )
1A5B0C4 	9C 53 A0  1 
1A5B0C8 	2E 20 20 20 54 44 5F 53 
1A5B0D0 	54 41 54 5F 41 43 54 49 
1A5B0D8 	56 45 20 6F 72 20 54 44 
1A5B0E0 	5F 43 5F 45 52 52 33 20 
1A5B0E8 	6F 72 20 54 44 5F 50 49 
1A5B0F0 	44 5F 49 4E 20 6F 72  0 
1A5B0F8 	D8 E5 A0  1 

   \ Not doing data toggles here!

s"    swap >hcqtd-token le-l! ;" eval
1A5B0FC 	9C 53 A0  1 
1A5B100 	1C 20 20 20 73 77 61 70 
1A5B108 	20 3E 68 63 71 74 64 2D 
1A5B110 	74 6F 6B 65 6E 20 6C 65 
1A5B118 	2D 6C 21 20 3B  0  0  0 
1A5B120 	D8 E5 A0  1 

s" : recycle-bulk-in-qtd" eval  ( qtd -- )
1A5B124 	9C 53 A0  1 
1A5B128 	15 3A 20 72 65 63 79 63 
1A5B130 	6C 65 2D 62 75 6C 6B 2D 
1A5B138 	69 6E 2D 71 74 64  0  0 
1A5B140 	D8 E5 A0  1 
s"    dup" eval
1A5B144 	9C 53 A0  1 
1A5B148 	 6 20 20 20 64 75 70  0 
1A5B150 	D8 E5 A0  1 
s"    begin  more-qtds?  while" eval	( qtd0 qtd )
1A5B154 	9C 53 A0  1 
1A5B158 	1B 20 20 20 62 65 67 69 
1A5B160 	6E 20 20 6D 6F 72 65 2D 
1A5B168 	71 74 64 73 3F 20 20 77 
1A5B170 	68 69 6C 65  0  0  0  0 
1A5B178 	D8 E5 A0  1 
s"       >qtd-next l@" eval		( qtd0 qtd' )
1A5B17C 	9C 53 A0  1 
1A5B180 	12 20 20 20 20 20 20 3E 
1A5B188 	71 74 64 2D 6E 65 78 74 
1A5B190 	20 6C 40  0 D8 E5 A0  1 
s"       dup recycle-one-qtd" eval	( qtd0 qtd )
1A5B198 	9C 53 A0  1 19 20 20 20 
1A5B1A0 	20 20 20 64 75 70 20 72 
1A5B1A8 	65 63 79 63 6C 65 2D 6F 
1A5B1B0 	6E 65 2D 71 74 64  0  0 
1A5B1B8 	D8 E5 A0  1 
s"    repeat" eval			( qtd0 qtd )
1A5B1BC 	9C 53 A0  1 
1A5B1C0 	 9 20 20 20 72 65 70 65 
1A5B1C8 	61 74  0  0 D8 E5 A0  1 

   \ Recycle the first qtd last so the transaction is atomic WRT the HC
s"    drop dup recycle-one-qtd" eval	( qtd0 )
1A5B1D0 	9C 53 A0  1 1B 20 20 20 
1A5B1D8 	64 72 6F 70 20 64 75 70 
1A5B1E0 	20 72 65 63 79 63 6C 65 
1A5B1E8 	2D 6F 6E 65 2D 71 74 64 
1A5B1F0 	 0  0  0  0 D8 E5 A0  1 
s"    push-qtds ;" eval
1A5B1F8 	9C 53 A0  1  E 20 20 20 
1A5B200 	70 75 73 68 2D 71 74 64 
1A5B208 	73 20 3B  0 D8 E5 A0  1 

\ Fixup the host-controller-writable fields in the chain of qTDs -
\ current offset, bytes_to_transfer, and status
s" : restart-bulk-in-qtd" eval  ( qtd -- )
1A5B210 	9C 53 A0  1 15 3A 20 72 
1A5B218 	65 73 74 61 72 74 2D 62 
1A5B220 	75 6C 6B 2D 69 6E 2D 71 
1A5B228 	74 64  0  0 D8 E5 A0  1 
s"    begin" eval					   ( qtd )
1A5B230 	9C 53 A0  1  8 20 20 20 
1A5B238 	62 65 67 69 6E  0  0  0 
1A5B240 	D8 E5 A0  1 
      \ Clear "Current Offset" field in first buffer pointer
s"       dup >hcqtd-bptr0 dup le-l@ h# fffff000 and swap le-l!" eval  ( qtd )
1A5B244 	9C 53 A0  1 
1A5B248 	3B 20 20 20 20 20 20 64 
1A5B250 	75 70 20 3E 68 63 71 74 
1A5B258 	64 2D 62 70 74 72 30 20 
1A5B260 	64 75 70 20 6C 65 2D 6C 
1A5B268 	40 20 68 23 20 66 66 66 
1A5B270 	66 66 30 30 30 20 61 6E 
1A5B278 	64 20 73 77 61 70 20 6C 
1A5B280 	65 2D 6C 21  0  0  0  0 
1A5B288 	D8 E5 A0  1 

      \ Reset the "token" word which contains various transfer control bits
s"       dup >qtd-/buf l@ d# 16 <<" eval                    ( qtd token_word )
1A5B28C 	9C 53 A0  1 
1A5B290 	1F 20 20 20 20 20 20 64 
1A5B298 	75 70 20 3E 71 74 64 2D 
1A5B2A0 	2F 62 75 66 20 6C 40 20 
1A5B2A8 	64 23 20 31 36 20 3C 3C 
1A5B2B0 	 0  0  0  0 D8 E5 A0  1 
s"       TD_STAT_ACTIVE or TD_C_ERR3 or TD_PID_IN or" eval  ( qtd token_word' )
1A5B2B8 	9C 53 A0  1 31 20 20 20 
1A5B2C0 	20 20 20 54 44 5F 53 54 
1A5B2C8 	41 54 5F 41 43 54 49 56 
1A5B2D0 	45 20 6F 72 20 54 44 5F 
1A5B2D8 	43 5F 45 52 52 33 20 6F 
1A5B2E0 	72 20 54 44 5F 50 49 44 
1A5B2E8 	5F 49 4E 20 6F 72  0  0 
1A5B2F0 	D8 E5 A0  1 

      \ We need not adjust the data toggle here, as the controller handles
      \ it automatically while the queue is active.  We set it initially
      \ when creating the the queue head, and save it for later after
      \ detaching the queue head.

s"       over >hcqtd-token le-l!" eval                      ( qtd )
1A5B2F4 	9C 53 A0  1 
1A5B2F8 	1D 20 20 20 20 20 20 6F 
1A5B300 	76 65 72 20 3E 68 63 71 
1A5B308 	74 64 2D 74 6F 6B 65 6E 
1A5B310 	20 6C 65 2D 6C 21  0  0 
1A5B318 	D8 E5 A0  1 
s"    more-qtds?   while" eval				   ( qtd )
1A5B31C 	9C 53 A0  1 
1A5B320 	15 20 20 20 6D 6F 72 65 
1A5B328 	2D 71 74 64 73 3F 20 20 
1A5B330 	20 77 68 69 6C 65  0  0 
1A5B338 	D8 E5 A0  1 
s"       >qtd-next l@" eval                              ( qtd' )
1A5B33C 	9C 53 A0  1 
1A5B340 	12 20 20 20 20 20 20 3E 
1A5B348 	71 74 64 2D 6E 65 78 74 
1A5B350 	20 6C 40  0 D8 E5 A0  1 
s"    repeat" eval					   ( qtd )
1A5B358 	9C 53 A0  1  9 20 20 20 
1A5B360 	72 65 70 65 61 74  0  0 
1A5B368 	D8 E5 A0  1 
s"   drop ;" eval
1A5B36C 	9C 53 A0  1 
1A5B370 	 8 20 20 64 72 6F 70 20 
1A5B378 	3B  0  0  0 D8 E5 A0  1 

\ Wait for the hardware next pointer to catch up with the software pointer.
s" : drain-bulk-out" eval  ( -- )
1A5B380 	9C 53 A0  1 10 3A 20 64 
1A5B388 	72 61 69 6E 2D 62 75 6C 
1A5B390 	6B 2D 6F 75 74  0  0  0 
1A5B398 	D8 E5 A0  1 
 "    debug?  if  ."" drain-bulk-out"" cr  then" eval
1A5B39C 	9C 53 A0  1 
1A5B3A0 	2A 20 20 20 64 65 62 75 
1A5B3A8 	67 3F 20 20 69 66 20 20 
1A5B3B0 	2E 22 20 64 72 61 69 6E 
1A5B3B8 	2D 62 75 6C 6B 2D 6F 75 
1A5B3C0 	74 22 20 63 72 20 20 74 
1A5B3C8 	68 65 6E  0 D8 E5 A0  1 
s"    bulk-out-qtd >qtd-phys l@" eval	( qtd-pa )
1A5B3D0 	9C 53 A0  1 1C 20 20 20 
1A5B3D8 	62 75 6C 6B 2D 6F 75 74 
1A5B3E0 	2D 71 74 64 20 3E 71 74 
1A5B3E8 	64 2D 70 68 79 73 20 6C 
1A5B3F0 	40  0  0  0 D8 E5 A0  1 
s"    bulk-out-qh >hcqh-overlay >hcqtd-next" eval	( qtd-pa 'qh-next )
1A5B3F8 	9C 53 A0  1 28 20 20 20 
1A5B400 	62 75 6C 6B 2D 6F 75 74 
1A5B408 	2D 71 68 20 3E 68 63 71 
1A5B410 	68 2D 6F 76 65 72 6C 61 
1A5B418 	79 20 3E 68 63 71 74 64 
1A5B420 	2D 6E 65 78 74  0  0  0 
1A5B428 	D8 E5 A0  1 
s"    begin  2dup le-l@ =  until" eval   ( qtd-pa 'qh-next )
1A5B42C 	9C 53 A0  1 
1A5B430 	1D 20 20 20 62 65 67 69 
1A5B438 	6E 20 20 32 64 75 70 20 
1A5B440 	6C 65 2D 6C 40 20 3D 20 
1A5B448 	20 75 6E 74 69 6C  0  0 
1A5B450 	D8 E5 A0  1 
s"    2drop ;" eval
1A5B454 	9C 53 A0  1 
1A5B458 	 A 20 20 20 32 64 72 6F 
1A5B460 	70 20 3B  0 D8 E5 A0  1 

s" : end-out-ring" eval  ( -- )
1A5B468 	9C 53 A0  1  E 3A 20 65 
1A5B470 	6E 64 2D 6F 75 74 2D 72 
1A5B478 	69 6E 67  0 D8 E5 A0  1 
 "    debug?  if  ."" end-out-ring"" cr  then" eval
1A5B480 	9C 53 A0  1 28 20 20 20 
1A5B488 	64 65 62 75 67 3F 20 20 
1A5B490 	69 66 20 20 2E 22 20 65 
1A5B498 	6E 64 2D 6F 75 74 2D 72 
1A5B4A0 	69 6E 67 22 20 63 72 20 
1A5B4A8 	20 74 68 65 6E  0  0  0 
1A5B4B0 	D8 E5 A0  1 
s"    bulk-out-qh 0=  if  exit  then" eval
1A5B4B4 	9C 53 A0  1 
1A5B4B8 	21 20 20 20 62 75 6C 6B 
1A5B4C0 	2D 6F 75 74 2D 71 68 20 
1A5B4C8 	30 3D 20 20 69 66 20 20 
1A5B4D0 	65 78 69 74 20 20 74 68 
1A5B4D8 	65 6E  0  0 D8 E5 A0  1 
s"    drain-bulk-out" eval
1A5B4E0 	9C 53 A0  1 11 20 20 20 
1A5B4E8 	64 72 61 69 6E 2D 62 75 
1A5B4F0 	6C 6B 2D 6F 75 74  0  0 
1A5B4F8 	D8 E5 A0  1 

s"    bulk-out-qh remove-qh" eval
1A5B4FC 	9C 53 A0  1 
1A5B500 	18 20 20 20 62 75 6C 6B 
1A5B508 	2D 6F 75 74 2D 71 68 20 
1A5B510 	72 65 6D 6F 76 65 2D 71 
1A5B518 	68  0  0  0 D8 E5 A0  1 
s"    bulk-out-qh free-ring" eval
1A5B520 	9C 53 A0  1 18 20 20 20 
1A5B528 	62 75 6C 6B 2D 6F 75 74 
1A5B530 	2D 71 68 20 66 72 65 65 
1A5B538 	2D 72 69 6E 67  0  0  0 
1A5B540 	D8 E5 A0  1 
s"    bulk-out-qh free-qh" eval
1A5B544 	9C 53 A0  1 
1A5B548 	16 20 20 20 62 75 6C 6B 
1A5B550 	2D 6F 75 74 2D 71 68 20 
1A5B558 	66 72 65 65 2D 71 68  0 
1A5B560 	D8 E5 A0  1 
s"    0 to bulk-out-qh  0 to bulk-out-qtd ;" eval
1A5B564 	9C 53 A0  1 
1A5B568 	28 20 20 20 30 20 74 6F 
1A5B570 	20 62 75 6C 6B 2D 6F 75 
1A5B578 	74 2D 71 68 20 20 30 20 
1A5B580 	74 6F 20 62 75 6C 6B 2D 
1A5B588 	6F 75 74 2D 71 74 64 20 
1A5B590 	3B  0  0  0 D8 E5 A0  1 

s" : end-bulk-in" eval  ( -- )
1A5B598 	9C 53 A0  1  D 3A 20 65 
1A5B5A0 	6E 64 2D 62 75 6C 6B 2D 
1A5B5A8 	69 6E  0  0 D8 E5 A0  1 
 "    debug?  if  ."" end-bulk-in"" cr  then" eval
1A5B5B0 	9C 53 A0  1 27 20 20 20 
1A5B5B8 	64 65 62 75 67 3F 20 20 
1A5B5C0 	69 66 20 20 2E 22 20 65 
1A5B5C8 	6E 64 2D 62 75 6C 6B 2D 
1A5B5D0 	69 6E 22 20 63 72 20 20 
1A5B5D8 	74 68 65 6E  0  0  0  0 
1A5B5E0 	D8 E5 A0  1 
s"    bulk-in-qh 0=  if  exit  then" eval
1A5B5E4 	9C 53 A0  1 
1A5B5E8 	20 20 20 20 62 75 6C 6B 
1A5B5F0 	2D 69 6E 2D 71 68 20 30 
1A5B5F8 	3D 20 20 69 66 20 20 65 
1A5B600 	78 69 74 20 20 74 68 65 
1A5B608 	6E  0  0  0 D8 E5 A0  1 
s"    bulk-in-qh remove-qh" eval
1A5B610 	9C 53 A0  1 17 20 20 20 
1A5B618 	62 75 6C 6B 2D 69 6E 2D 
1A5B620 	71 68 20 72 65 6D 6F 76 
1A5B628 	65 2D 71 68  0  0  0  0 
1A5B630 	D8 E5 A0  1 
s"    bulk-in-qh fixup-bulk-in-data" eval
1A5B634 	9C 53 A0  1 
1A5B638 	20 20 20 20 62 75 6C 6B 
1A5B640 	2D 69 6E 2D 71 68 20 66 
1A5B648 	69 78 75 70 2D 62 75 6C 
1A5B650 	6B 2D 69 6E 2D 64 61 74 
1A5B658 	61  0  0  0 D8 E5 A0  1 
s"    bulk-in-qh free-ring" eval
1A5B660 	9C 53 A0  1 17 20 20 20 
1A5B668 	62 75 6C 6B 2D 69 6E 2D 
1A5B670 	71 68 20 66 72 65 65 2D 
1A5B678 	72 69 6E 67  0  0  0  0 
1A5B680 	D8 E5 A0  1 
s"    bulk-in-qh free-qh" eval
1A5B684 	9C 53 A0  1 
1A5B688 	15 20 20 20 62 75 6C 6B 
1A5B690 	2D 69 6E 2D 71 68 20 66 
1A5B698 	72 65 65 2D 71 68  0  0 
1A5B6A0 	D8 E5 A0  1 
s"    0 to bulk-in-qh  0 to bulk-in-qtd ;" eval
1A5B6A4 	9C 53 A0  1 
1A5B6A8 	26 20 20 20 30 20 74 6F 
1A5B6B0 	20 62 75 6C 6B 2D 69 6E 
1A5B6B8 	2D 71 68 20 20 30 20 74 
1A5B6C0 	6F 20 62 75 6C 6B 2D 69 
1A5B6C8 	6E 2D 71 74 64 20 3B  0 
1A5B6D0 	D8 E5 A0  1 
s" 0 instance value app-buf" eval
1A5B6D4 	9C 53 A0  1 
1A5B6D8 	18 30 20 69 6E 73 74 61 
1A5B6E0 	6E 63 65 20 76 61 6C 75 
1A5B6E8 	65 20 61 70 70 2D 62 75 
1A5B6F0 	66  0  0  0 D8 E5 A0  1 
s" : begin-bulk-in" eval  ( buf len pipe -- )
1A5B6F8 	9C 53 A0  1  F 3A 20 62 
1A5B700 	65 67 69 6E 2D 62 75 6C 
1A5B708 	6B 2D 69 6E  0  0  0  0 
1A5B710 	D8 E5 A0  1 
s"    rot to app-buf" eval
1A5B714 	9C 53 A0  1 
1A5B718 	11 20 20 20 72 6F 74 20 
1A5B720 	74 6F 20 61 70 70 2D 62 
1A5B728 	75 66  0  0 D8 E5 A0  1 
s"    h# 20 swap begin-in-ring ;" eval
1A5B730 	9C 53 A0  1 1D 20 20 20 
1A5B738 	68 23 20 32 30 20 73 77 
1A5B740 	61 70 20 62 65 67 69 6E 
1A5B748 	2D 69 6E 2D 72 69 6E 67 
1A5B750 	20 3B  0  0 D8 E5 A0  1 

s" : bulk-in?" eval  ( -- actual usberr )
1A5B758 	9C 53 A0  1  A 3A 20 62 
1A5B760 	75 6C 6B 2D 69 6E 3F  0 
1A5B768 	D8 E5 A0  1 
s"    lock" eval
1A5B76C 	9C 53 A0  1 
1A5B770 	 7 20 20 20 6C 6F 63 6B 
1A5B778 	 0  0  0  0 D8 E5 A0  1 
s"    bulk-in-ready?  if" eval		( usberr | buf actual 0 )
1A5B780 	9C 53 A0  1 15 20 20 20 
1A5B788 	62 75 6C 6B 2D 69 6E 2D 
1A5B790 	72 65 61 64 79 3F 20 20 
1A5B798 	69 66  0  0 D8 E5 A0  1 
s"       ?dup  if" eval			( usberr )
1A5B7A0 	9C 53 A0  1  E 20 20 20 
1A5B7A8 	20 20 20 3F 64 75 70 20 
1A5B7B0 	20 69 66  0 D8 E5 A0  1 
s"          0 swap" eval			( actual usberr )
1A5B7B8 	9C 53 A0  1  F 20 20 20 
1A5B7C0 	20 20 20 20 20 20 30 20 
1A5B7C8 	73 77 61 70  0  0  0  0 
1A5B7D0 	D8 E5 A0  1 
s"       else" eval			( buf actual )
1A5B7D4 	9C 53 A0  1 
1A5B7D8 	 A 20 20 20 20 20 20 65 
1A5B7E0 	6C 73 65  0 D8 E5 A0  1 
s"          tuck" eval			( actual buf actual )
1A5B7E8 	9C 53 A0  1  D 20 20 20 
1A5B7F0 	20 20 20 20 20 20 74 75 
1A5B7F8 	63 6B  0  0 D8 E5 A0  1 
s"          app-buf swap move" eval	( actual )
1A5B800 	9C 53 A0  1 1A 20 20 20 
1A5B808 	20 20 20 20 20 20 61 70 
1A5B810 	70 2D 62 75 66 20 73 77 
1A5B818 	61 70 20 6D 6F 76 65  0 
1A5B820 	D8 E5 A0  1 
s"          0" eval			( actual usberr )
1A5B824 	9C 53 A0  1 
1A5B828 	 A 20 20 20 20 20 20 20 
1A5B830 	20 20 30  0 D8 E5 A0  1 
s"       then" eval                      ( actual usberr )
1A5B838 	9C 53 A0  1  A 20 20 20 
1A5B840 	20 20 20 74 68 65 6E  0 
1A5B848 	D8 E5 A0  1 
s"    else" eval
1A5B84C 	9C 53 A0  1 
1A5B850 	 7 20 20 20 65 6C 73 65 
1A5B858 	 0  0  0  0 D8 E5 A0  1 
s"       0 0" eval			( actual usberr )
1A5B860 	9C 53 A0  1  9 20 20 20 
1A5B868 	20 20 20 30 20 30  0  0 
1A5B870 	D8 E5 A0  1 
s"    then" eval
1A5B874 	9C 53 A0  1 
1A5B878 	 7 20 20 20 74 68 65 6E 
1A5B880 	 0  0  0  0 D8 E5 A0  1 
s"    unlock ;" eval
1A5B888 	9C 53 A0  1  B 20 20 20 
1A5B890 	75 6E 6C 6F 63 6B 20 3B 
1A5B898 	 0  0  0  0 D8 E5 A0  1 

s" : restart-bulk-in" eval  ( -- )
1A5B8A0 	9C 53 A0  1 11 3A 20 72 
1A5B8A8 	65 73 74 61 72 74 2D 62 
1A5B8B0 	75 6C 6B 2D 69 6E  0  0 
1A5B8B8 	D8 E5 A0  1 
 "    debug?  if  ."" recycle buffer"" cr  then" eval
1A5B8BC 	9C 53 A0  1 
1A5B8C0 	2A 20 20 20 64 65 62 75 
1A5B8C8 	67 3F 20 20 69 66 20 20 
1A5B8D0 	2E 22 20 72 65 63 79 63 
1A5B8D8 	6C 65 20 62 75 66 66 65 
1A5B8E0 	72 22 20 63 72 20 20 74 
1A5B8E8 	68 65 6E  0 D8 E5 A0  1 
s"    bulk-in-qh 0=  if  exit  then" eval
1A5B8F0 	9C 53 A0  1 20 20 20 20 
1A5B8F8 	62 75 6C 6B 2D 69 6E 2D 
1A5B900 	71 68 20 30 3D 20 20 69 
1A5B908 	66 20 20 65 78 69 74 20 
1A5B910 	20 74 68 65 6E  0  0  0 
1A5B918 	D8 E5 A0  1 

   \ Setup qTD again
s"    bulk-in-qtd recycle-bulk-in-qtd" eval
1A5B91C 	9C 53 A0  1 
1A5B920 	22 20 20 20 62 75 6C 6B 
1A5B928 	2D 69 6E 2D 71 74 64 20 
1A5B930 	72 65 63 79 63 6C 65 2D 
1A5B938 	62 75 6C 6B 2D 69 6E 2D 
1A5B940 	71 74 64  0 D8 E5 A0  1 
s"    bulk-in-qtd qtd-successor to bulk-in-qtd ;" eval
1A5B948 	9C 53 A0  1 2D 20 20 20 
1A5B950 	62 75 6C 6B 2D 69 6E 2D 
1A5B958 	71 74 64 20 71 74 64 2D 
1A5B960 	73 75 63 63 65 73 73 6F 
1A5B968 	72 20 74 6F 20 62 75 6C 
1A5B970 	6B 2D 69 6E 2D 71 74 64 
1A5B978 	20 3B  0  0 D8 E5 A0  1 
s" : bulk-read?" eval  ( -- [ buf ] actual )
1A5B980 	9C 53 A0  1  C 3A 20 62 
1A5B988 	75 6C 6B 2D 72 65 61 64 
1A5B990 	3F  0  0  0 D8 E5 A0  1 
s"    bulk-in?  if  restart-bulk-in  -1 exit  then" eval    ( actual )
1A5B998 	9C 53 A0  1 2F 20 20 20 
1A5B9A0 	62 75 6C 6B 2D 69 6E 3F 
1A5B9A8 	20 20 69 66 20 20 72 65 
1A5B9B0 	73 74 61 72 74 2D 62 75 
1A5B9B8 	6C 6B 2D 69 6E 20 20 2D 
1A5B9C0 	31 20 65 78 69 74 20 20 
1A5B9C8 	74 68 65 6E  0  0  0  0 
1A5B9D0 	D8 E5 A0  1 
s"    dup 0=  if  drop -2 exit  then" eval                  ( actual )
1A5B9D4 	9C 53 A0  1 
1A5B9D8 	21 20 20 20 64 75 70 20 
1A5B9E0 	30 3D 20 20 69 66 20 20 
1A5B9E8 	64 72 6F 70 20 2D 32 20 
1A5B9F0 	65 78 69 74 20 20 74 68 
1A5B9F8 	65 6E  0  0 D8 E5 A0  1 
s"    bulk-in-qtd >qtd-buf l@ swap ;" eval                  ( buf actual )
1A5BA00 	9C 53 A0  1 21 20 20 20 
1A5BA08 	62 75 6C 6B 2D 69 6E 2D 
1A5BA10 	71 74 64 20 3E 71 74 64 
1A5BA18 	2D 62 75 66 20 6C 40 20 
1A5BA20 	73 77 61 70 20 3B  0  0 
1A5BA28 	D8 E5 A0  1 


s" : recycle-buffer restart-bulk-in ;" eval
1A5BA2C 	9C 53 A0  1 
1A5BA30 	22 3A 20 72 65 63 79 63 
1A5BA38 	6C 65 2D 62 75 66 66 65 
1A5BA40 	72 20 72 65 73 74 61 72 
1A5BA48 	74 2D 62 75 6C 6B 2D 69 
1A5BA50 	6E 20 3B  0 D8 E5 A0  1 

s" : start-bulk-transaction" eval  ( pid -- )
1A5BA58 	9C 53 A0  1 18 3A 20 73 
1A5BA60 	74 61 72 74 2D 62 75 6C 
1A5BA68 	6B 2D 74 72 61 6E 73 61 
1A5BA70 	63 74 69 6F 6E  0  0  0 
1A5BA78 	D8 E5 A0  1 
s"    my-bulk-qtd fill-bulk-io-qtds" eval
1A5BA7C 	9C 53 A0  1 
1A5BA80 	20 20 20 20 6D 79 2D 62 
1A5BA88 	75 6C 6B 2D 71 74 64 20 
1A5BA90 	66 69 6C 6C 2D 62 75 6C 
1A5BA98 	6B 2D 69 6F 2D 71 74 64 
1A5BAA0 	73  0  0  0 D8 E5 A0  1 
s"    my-bulk-qh pt-bulk fill-qh" eval
1A5BAA8 	9C 53 A0  1 1D 20 20 20 
1A5BAB0 	6D 79 2D 62 75 6C 6B 2D 
1A5BAB8 	71 68 20 70 74 2D 62 75 
1A5BAC0 	6C 6B 20 66 69 6C 6C 2D 
1A5BAC8 	71 68  0  0 D8 E5 A0  1 
s"    my-bulk-qh interrupt-on-last-td" eval
1A5BAD0 	9C 53 A0  1 22 20 20 20 
1A5BAD8 	6D 79 2D 62 75 6C 6B 2D 
1A5BAE0 	71 68 20 69 6E 74 65 72 
1A5BAE8 	72 75 70 74 2D 6F 6E 2D 
1A5BAF0 	6C 61 73 74 2D 74 64  0 
1A5BAF8 	D8 E5 A0  1 
s"    my-bulk-qh insert-qh ;" eval
1A5BAFC 	9C 53 A0  1 
1A5BB00 	19 20 20 20 6D 79 2D 62 
1A5BB08 	75 6C 6B 2D 71 68 20 69 
1A5BB10 	6E 73 65 72 74 2D 71 68 
1A5BB18 	20 3B  0  0 D8 E5 A0  1 
s" : bulk-in" eval  ( buf len pipe -- actual usberr )
1A5BB20 	9C 53 A0  1  9 3A 20 62 
1A5BB28 	75 6C 6B 2D 69 6E  0  0 
1A5BB30 	D8 E5 A0  1 
 "    debug?  if  ."" bulk-in"" cr  then" eval
1A5BB34 	9C 53 A0  1 
1A5BB38 	23 20 20 20 64 65 62 75 
1A5BB40 	67 3F 20 20 69 66 20 20 
1A5BB48 	2E 22 20 62 75 6C 6B 2D 
1A5BB50 	69 6E 22 20 63 72 20 20 
1A5BB58 	74 68 65 6E  0  0  0  0 
1A5BB60 	D8 E5 A0  1 
s"    lock" eval
1A5BB64 	9C 53 A0  1 
1A5BB68 	 7 20 20 20 6C 6F 63 6B 
1A5BB70 	 0  0  0  0 D8 E5 A0  1 
s"    dup to bulk-in-pipe" eval
1A5BB78 	9C 53 A0  1 16 20 20 20 
1A5BB80 	64 75 70 20 74 6F 20 62 
1A5BB88 	75 6C 6B 2D 69 6E 2D 70 
1A5BB90 	69 70 65  0 D8 E5 A0  1 
s"    process-bulk-args" eval
1A5BB98 	9C 53 A0  1 14 20 20 20 
1A5BBA0 	70 72 6F 63 65 73 73 2D 
1A5BBA8 	62 75 6C 6B 2D 61 72 67 
1A5BBB0 	73  0  0  0 D8 E5 A0  1 
s"    ?alloc-bulk-qhqtds  to my-bulk-qtd  to  my-bulk-qh" eval
1A5BBB8 	9C 53 A0  1 35 20 20 20 
1A5BBC0 	3F 61 6C 6C 6F 63 2D 62 
1A5BBC8 	75 6C 6B 2D 71 68 71 74 
1A5BBD0 	64 73 20 20 74 6F 20 6D 
1A5BBD8 	79 2D 62 75 6C 6B 2D 71 
1A5BBE0 	74 64 20 20 74 6F 20 20 
1A5BBE8 	6D 79 2D 62 75 6C 6B 2D 
1A5BBF0 	71 68  0  0 D8 E5 A0  1 
s"    bulk-in-timeout my-bulk-qh >qh-timeout l!" eval
1A5BBF8 	9C 53 A0  1 2C 20 20 20 
1A5BC00 	62 75 6C 6B 2D 69 6E 2D 
1A5BC08 	74 69 6D 65 6F 75 74 20 
1A5BC10 	6D 79 2D 62 75 6C 6B 2D 
1A5BC18 	71 68 20 3E 71 68 2D 74 
1A5BC20 	69 6D 65 6F 75 74 20 6C 
1A5BC28 	21  0  0  0 D8 E5 A0  1 

   \ IN qTDs
s"    TD_PID_IN start-bulk-transaction" eval
1A5BC30 	9C 53 A0  1 23 20 20 20 
1A5BC38 	54 44 5F 50 49 44 5F 49 
1A5BC40 	4E 20 73 74 61 72 74 2D 
1A5BC48 	62 75 6C 6B 2D 74 72 61 
1A5BC50 	6E 73 61 63 74 69 6F 6E 
1A5BC58 	 0  0  0  0 D8 E5 A0  1 

   \ Process results
s"    my-bulk-qh done-error?  if" eval			( )		\ System error, timeout, or USB error
1A5BC60 	9C 53 A0  1 1D 20 20 20 
1A5BC68 	6D 79 2D 62 75 6C 6B 2D 
1A5BC70 	71 68 20 64 6F 6E 65 2D 
1A5BC78 	65 72 72 6F 72 3F 20 20 
1A5BC80 	69 66  0  0 D8 E5 A0  1 
s"       0" eval						( actual )	
1A5BC88 	9C 53 A0  1  7 20 20 20 
1A5BC90 	20 20 20 30  0  0  0  0 
1A5BC98 	D8 E5 A0  1 
s"    else" eval						( )
1A5BC9C 	9C 53 A0  1 
1A5BCA0 	 7 20 20 20 65 6C 73 65 
1A5BCA8 	 0  0  0  0 D8 E5 A0  1 
s"       my-bulk-qtd dup my-#qtds get-actual" eval	( qtd actual )
1A5BCB0 	9C 53 A0  1 29 20 20 20 
1A5BCB8 	20 20 20 6D 79 2D 62 75 
1A5BCC0 	6C 6B 2D 71 74 64 20 64 
1A5BCC8 	75 70 20 6D 79 2D 23 71 
1A5BCD0 	74 64 73 20 67 65 74 2D 
1A5BCD8 	61 63 74 75 61 6C  0  0 
1A5BCE0 	D8 E5 A0  1 
s"       over >qtd-buf l@ rot >qtd-pbuf l@ 2 pick dma-pull" eval	( actual )
1A5BCE4 	9C 53 A0  1 
1A5BCE8 	37 20 20 20 20 20 20 6F 
1A5BCF0 	76 65 72 20 3E 71 74 64 
1A5BCF8 	2D 62 75 66 20 6C 40 20 
1A5BD00 	72 6F 74 20 3E 71 74 64 
1A5BD08 	2D 70 62 75 66 20 6C 40 
1A5BD10 	20 32 20 70 69 63 6B 20 
1A5BD18 	64 6D 61 2D 70 75 6C 6C 
1A5BD20 	 0  0  0  0 D8 E5 A0  1 
s"    then" eval						( actual )
1A5BD28 	9C 53 A0  1  7 20 20 20 
1A5BD30 	74 68 65 6E  0  0  0  0 
1A5BD38 	D8 E5 A0  1 

s"    usb-error" eval					( actual usberr )
1A5BD3C 	9C 53 A0  1 
1A5BD40 	 C 20 20 20 75 73 62 2D 
1A5BD48 	65 72 72 6F 72  0  0  0 
1A5BD50 	D8 E5 A0  1 
s"    my-bulk-qtd map-out-bptrs" eval			( actual usberr )
1A5BD54 	9C 53 A0  1 
1A5BD58 	1C 20 20 20 6D 79 2D 62 
1A5BD60 	75 6C 6B 2D 71 74 64 20 
1A5BD68 	6D 61 70 2D 6F 75 74 2D 
1A5BD70 	62 70 74 72 73  0  0  0 
1A5BD78 	D8 E5 A0  1 
s"    my-bulk-qh dup fixup-bulk-in-data" eval		( actual usberr qh )
1A5BD7C 	9C 53 A0  1 
1A5BD80 	24 20 20 20 6D 79 2D 62 
1A5BD88 	75 6C 6B 2D 71 68 20 64 
1A5BD90 	75 70 20 66 69 78 75 70 
1A5BD98 	2D 62 75 6C 6B 2D 69 6E 
1A5BDA0 	2D 64 61 74 61  0  0  0 
1A5BDA8 	D8 E5 A0  1 
s"    remove-qh" eval					( actual usberr )
1A5BDAC 	9C 53 A0  1 
1A5BDB0 	 C 20 20 20 72 65 6D 6F 
1A5BDB8 	76 65 2D 71 68  0  0  0 
1A5BDC0 	D8 E5 A0  1 
s"    unlock ;" eval
1A5BDC4 	9C 53 A0  1 
1A5BDC8 	 B 20 20 20 75 6E 6C 6F 
1A5BDD0 	63 6B 20 3B  0  0  0  0 
1A5BDD8 	D8 E5 A0  1 

s" 0 instance value bulk-out-busy?" eval
1A5BDDC 	9C 53 A0  1 
1A5BDE0 	1F 30 20 69 6E 73 74 61 
1A5BDE8 	6E 63 65 20 76 61 6C 75 
1A5BDF0 	65 20 62 75 6C 6B 2D 6F 
1A5BDF8 	75 74 2D 62 75 73 79 3F 
1A5BE00 	 0  0  0  0 D8 E5 A0  1 
s" : done-bulk-out" eval  ( -- error? )
1A5BE08 	9C 53 A0  1  F 3A 20 64 
1A5BE10 	6F 6E 65 2D 62 75 6C 6B 
1A5BE18 	2D 6F 75 74  0  0  0  0 
1A5BE20 	D8 E5 A0  1 
s"    lock" eval
1A5BE24 	9C 53 A0  1 
1A5BE28 	 7 20 20 20 6C 6F 63 6B 
1A5BE30 	 0  0  0  0 D8 E5 A0  1 
    \ Process results
s"    my-bulk-qh done-error?" eval		( usberr )
1A5BE38 	9C 53 A0  1 19 20 20 20 
1A5BE40 	6D 79 2D 62 75 6C 6B 2D 
1A5BE48 	71 68 20 64 6F 6E 65 2D 
1A5BE50 	65 72 72 6F 72 3F  0  0 
1A5BE58 	D8 E5 A0  1 
s"    my-bulk-qtd map-out-bptrs" eval		( usberr )
1A5BE5C 	9C 53 A0  1 
1A5BE60 	1C 20 20 20 6D 79 2D 62 
1A5BE68 	75 6C 6B 2D 71 74 64 20 
1A5BE70 	6D 61 70 2D 6F 75 74 2D 
1A5BE78 	62 70 74 72 73  0  0  0 
1A5BE80 	D8 E5 A0  1 
s"    my-bulk-qh fixup-bulk-out-data" eval	( usberr )
1A5BE84 	9C 53 A0  1 
1A5BE88 	21 20 20 20 6D 79 2D 62 
1A5BE90 	75 6C 6B 2D 71 68 20 66 
1A5BE98 	69 78 75 70 2D 62 75 6C 
1A5BEA0 	6B 2D 6F 75 74 2D 64 61 
1A5BEA8 	74 61  0  0 D8 E5 A0  1 
s"    my-bulk-qh remove-qh" eval			( usberr )
1A5BEB0 	9C 53 A0  1 17 20 20 20 
1A5BEB8 	6D 79 2D 62 75 6C 6B 2D 
1A5BEC0 	71 68 20 72 65 6D 6F 76 
1A5BEC8 	65 2D 71 68  0  0  0  0 
1A5BED0 	D8 E5 A0  1 
s"    false to bulk-out-busy?" eval		( usberr )
1A5BED4 	9C 53 A0  1 
1A5BED8 	1A 20 20 20 66 61 6C 73 
1A5BEE0 	65 20 74 6F 20 62 75 6C 
1A5BEE8 	6B 2D 6F 75 74 2D 62 75 
1A5BEF0 	73 79 3F  0 D8 E5 A0  1 
s"    unlock ;" eval
1A5BEF8 	9C 53 A0  1  B 20 20 20 
1A5BF00 	75 6E 6C 6F 63 6B 20 3B 
1A5BF08 	 0  0  0  0 D8 E5 A0  1 

s" : start-bulk-out" eval  ( buf len pipe -- usberr )
1A5BF10 	9C 53 A0  1 10 3A 20 73 
1A5BF18 	74 61 72 74 2D 62 75 6C 
1A5BF20 	6B 2D 6F 75 74  0  0  0 
1A5BF28 	D8 E5 A0  1 
s"    bulk-out-busy?  if" eval			( buf len pipe )
1A5BF2C 	9C 53 A0  1 
1A5BF30 	15 20 20 20 62 75 6C 6B 
1A5BF38 	2D 6F 75 74 2D 62 75 73 
1A5BF40 	79 3F 20 20 69 66  0  0 
1A5BF48 	D8 E5 A0  1 
s"       done-bulk-out  ?dup  if   nip nip nip exit  then" eval
1A5BF4C 	9C 53 A0  1 
1A5BF50 	36 20 20 20 20 20 20 64 
1A5BF58 	6F 6E 65 2D 62 75 6C 6B 
1A5BF60 	2D 6F 75 74 20 20 3F 64 
1A5BF68 	75 70 20 20 69 66 20 20 
1A5BF70 	20 6E 69 70 20 6E 69 70 
1A5BF78 	20 6E 69 70 20 65 78 69 
1A5BF80 	74 20 20 74 68 65 6E  0 
1A5BF88 	D8 E5 A0  1 
s"    then" eval					( buf len pipe )
1A5BF8C 	9C 53 A0  1 
1A5BF90 	 7 20 20 20 74 68 65 6E 
1A5BF98 	 0  0  0  0 D8 E5 A0  1 

 "    debug?  if  ."" bulk-out"" cr  then" eval
1A5BFA0 	9C 53 A0  1 24 20 20 20 
1A5BFA8 	64 65 62 75 67 3F 20 20 
1A5BFB0 	69 66 20 20 2E 22 20 62 
1A5BFB8 	75 6C 6B 2D 6F 75 74 22 
1A5BFC0 	20 63 72 20 20 74 68 65 
1A5BFC8 	6E  0  0  0 D8 E5 A0  1 
s"    lock" eval
1A5BFD0 	9C 53 A0  1  7 20 20 20 
1A5BFD8 	6C 6F 63 6B  0  0  0  0 
1A5BFE0 	D8 E5 A0  1 
s"    dup to bulk-out-pipe" eval			( buf len pipe )
1A5BFE4 	9C 53 A0  1 
1A5BFE8 	17 20 20 20 64 75 70 20 
1A5BFF0 	74 6F 20 62 75 6C 6B 2D 
1A5BFF8 	6F 75 74 2D 70 69 70 65 
1A5C000 	 0  0  0  0 D8 E5 A0  1 
s"    process-bulk-args" eval
1A5C008 	9C 53 A0  1 14 20 20 20 
1A5C010 	70 72 6F 63 65 73 73 2D 
1A5C018 	62 75 6C 6B 2D 61 72 67 
1A5C020 	73  0  0  0 D8 E5 A0  1 
s"    ?alloc-bulk-qhqtds  to my-bulk-qtd  to my-bulk-qh" eval
1A5C028 	9C 53 A0  1 34 20 20 20 
1A5C030 	3F 61 6C 6C 6F 63 2D 62 
1A5C038 	75 6C 6B 2D 71 68 71 74 
1A5C040 	64 73 20 20 74 6F 20 6D 
1A5C048 	79 2D 62 75 6C 6B 2D 71 
1A5C050 	74 64 20 20 74 6F 20 6D 
1A5C058 	79 2D 62 75 6C 6B 2D 71 
1A5C060 	68  0  0  0 D8 E5 A0  1 
s"    bulk-out-timeout my-bulk-qh >qh-timeout l!" eval
1A5C068 	9C 53 A0  1 2D 20 20 20 
1A5C070 	62 75 6C 6B 2D 6F 75 74 
1A5C078 	2D 74 69 6D 65 6F 75 74 
1A5C080 	20 6D 79 2D 62 75 6C 6B 
1A5C088 	2D 71 68 20 3E 71 68 2D 
1A5C090 	74 69 6D 65 6F 75 74 20 
1A5C098 	6C 21  0  0 D8 E5 A0  1 
s"    my-bulk-qh >hcqh-overlay >hcqtd-token dup le-l@ TD_STAT_PING or swap le-l!" eval
1A5C0A0 	9C 53 A0  1 4D 20 20 20 
1A5C0A8 	6D 79 2D 62 75 6C 6B 2D 
1A5C0B0 	71 68 20 3E 68 63 71 68 
1A5C0B8 	2D 6F 76 65 72 6C 61 79 
1A5C0C0 	20 3E 68 63 71 74 64 2D 
1A5C0C8 	74 6F 6B 65 6E 20 64 75 
1A5C0D0 	70 20 6C 65 2D 6C 40 20 
1A5C0D8 	54 44 5F 53 54 41 54 5F 
1A5C0E0 	50 49 4E 47 20 6F 72 20 
1A5C0E8 	73 77 61 70 20 6C 65 2D 
1A5C0F0 	6C 21  0  0 D8 E5 A0  1 

   \ OUT qTDs
s"    TD_PID_OUT start-bulk-transaction" eval
1A5C0F8 	9C 53 A0  1 24 20 20 20 
1A5C100 	54 44 5F 50 49 44 5F 4F 
1A5C108 	55 54 20 73 74 61 72 74 
1A5C110 	2D 62 75 6C 6B 2D 74 72 
1A5C118 	61 6E 73 61 63 74 69 6F 
1A5C120 	6E  0  0  0 D8 E5 A0  1 
s"    true to bulk-out-busy?" eval
1A5C128 	9C 53 A0  1 19 20 20 20 
1A5C130 	74 72 75 65 20 74 6F 20 
1A5C138 	62 75 6C 6B 2D 6F 75 74 
1A5C140 	2D 62 75 73 79 3F  0  0 
1A5C148 	D8 E5 A0  1 
s"    0" eval					( usberr )
1A5C14C 	9C 53 A0  1 
1A5C150 	 4 20 20 20 30  0  0  0 
1A5C158 	D8 E5 A0  1 
s"    unlock ;" eval
1A5C15C 	9C 53 A0  1 
1A5C160 	 B 20 20 20 75 6E 6C 6F 
1A5C168 	63 6B 20 3B  0  0  0  0 
1A5C170 	D8 E5 A0  1 

s" : bulk-out" eval  ( buf len pipe -- usberr )
1A5C174 	9C 53 A0  1 
1A5C178 	 A 3A 20 62 75 6C 6B 2D 
1A5C180 	6F 75 74  0 D8 E5 A0  1 
s"    start-bulk-out drop done-bulk-out ;" eval
1A5C188 	9C 53 A0  1 26 20 20 20 
1A5C190 	73 74 61 72 74 2D 62 75 
1A5C198 	6C 6B 2D 6F 75 74 20 64 
1A5C1A0 	72 6F 70 20 64 6F 6E 65 
1A5C1A8 	2D 62 75 6C 6B 2D 6F 75 
1A5C1B0 	74 20 3B  0 D8 E5 A0  1 

s" : (end-extra)  ( -- )  end-bulk-in free-bulk-qh  ;" eval
1A5C1B8 	9C 53 A0  1 32 3A 20 28 
1A5C1C0 	65 6E 64 2D 65 78 74 72 
1A5C1C8 	61 29 20 20 28 20 2D 2D 
1A5C1D0 	20 29 20 20 65 6E 64 2D 
1A5C1D8 	62 75 6C 6B 2D 69 6E 20 
1A5C1E0 	66 72 65 65 2D 62 75 6C 
1A5C1E8 	6B 2D 71 68 20 20 3B  0 
1A5C1F0 	D8 E5 A0  1 
;
1A5C1F4 	58 46 A0  1 

OpenFirmware/dev/usb2/hcd/ehci/bulk.fth_AL	3154 1A5C1F8 purpose: EHCI USB Controller probe

hex
headers

: probefth
1A5C1F8 	 0  0  0 70 72 6F 62 65 
1A5C200 	66 74 68 88 B0 90 A5  1 
1A5C208 	20 40 A0  1 

s" 0 value port-speed" eval
1A5C20C 	9C 53 A0  1 
1A5C210 	12 30 20 76 61 6C 75 65 
1A5C218 	20 70 6F 72 74 2D 73 70 
1A5C220 	65 65 64  0 D8 E5 A0  1 

s" : make-root-hub-node" eval  ( port -- )
1A5C228 	9C 53 A0  1 14 3A 20 6D 
1A5C230 	61 6B 65 2D 72 6F 6F 74 
1A5C238 	2D 68 75 62 2D 6E 6F 64 
1A5C240 	65  0  0  0 D8 E5 A0  1 
s"    0 set-target" eval	\ First address it as device 0	( port )
1A5C248 	9C 53 A0  1  F 20 20 20 
1A5C250 	30 20 73 65 74 2D 74 61 
1A5C258 	72 67 65 74  0  0  0  0 
1A5C260 	D8 E5 A0  1 
s"    port-speed 0 di-speed!" eval     \ Use high speed for getting the device descriptor
1A5C264 	9C 53 A0  1 
1A5C268 	19 20 20 20 70 6F 72 74 
1A5C270 	2D 73 70 65 65 64 20 30 
1A5C278 	20 64 69 2D 73 70 65 65 
1A5C280 	64 21  0  0 D8 E5 A0  1 

s"    dup reset-port" eval		( port )
1A5C288 	9C 53 A0  1 11 20 20 20 
1A5C290 	64 75 70 20 72 65 73 65 
1A5C298 	74 2D 70 6F 72 74  0  0 
1A5C2A0 	D8 E5 A0  1 

s"    port-speed" eval			( port speed )
1A5C2A4 	9C 53 A0  1 
1A5C2A8 	 D 20 20 20 70 6F 72 74 
1A5C2B0 	2D 73 70 65 65 64  0  0 
1A5C2B8 	D8 E5 A0  1 

   \ hub-port and hub-dev route USB 1.1 transactions through USB 2.0 hubs
s"    over get-hub20-port  get-hub20-dev" eval		( port speed hub-port hub-dev )
1A5C2BC 	9C 53 A0  1 
1A5C2C0 	25 20 20 20 6F 76 65 72 
1A5C2C8 	20 67 65 74 2D 68 75 62 
1A5C2D0 	32 30 2D 70 6F 72 74 20 
1A5C2D8 	20 67 65 74 2D 68 75 62 
1A5C2E0 	32 30 2D 64 65 76  0  0 
1A5C2E8 	D8 E5 A0  1 

   \ Execute setup-new-node in root context and make-device-node in hub node context
s"  setup-new-node  if  execute  then ;" eval
1A5C2EC 	9C 53 A0  1 
1A5C2F0 	24 20 73 65 74 75 70 2D 
1A5C2F8 	6E 65 77 2D 6E 6F 64 65 
1A5C300 	20 20 69 66 20 20 65 78 
1A5C308 	65 63 75 74 65 20 20 74 
1A5C310 	68 65 6E 20 3B  0  0  0 
1A5C318 	D8 E5 A0  1 

s" 0 instance value probe-error?" eval  \ Back channel to selftest
1A5C31C 	9C 53 A0  1 
1A5C320 	1D 30 20 69 6E 73 74 61 
1A5C328 	6E 63 65 20 76 61 6C 75 
1A5C330 	65 20 70 72 6F 62 65 2D 
1A5C338 	65 72 72 6F 72 3F  0  0 
1A5C340 	D8 E5 A0  1 

s" : make-port-node" eval  ( port -- )
1A5C344 	9C 53 A0  1 
1A5C348 	10 3A 20 6D 61 6B 65 2D 
1A5C350 	70 6F 72 74 2D 6E 6F 64 
1A5C358 	65  0  0  0 D8 E5 A0  1 
s"    ['] make-root-hub-node catch  if" eval
1A5C360 	9C 53 A0  1 23 20 20 20 
1A5C368 	5B 27 5D 20 6D 61 6B 65 
1A5C370 	2D 72 6F 6F 74 2D 68 75 
1A5C378 	62 2D 6E 6F 64 65 20 63 
1A5C380 	61 74 63 68 20 20 69 66 
1A5C388 	 0  0  0  0 D8 E5 A0  1 
 "       drop ."" Failed to make root hub node for port "" dup .d cr" eval
1A5C390 	9C 53 A0  1 3F 20 20 20 
1A5C398 	20 20 20 64 72 6F 70 20 
1A5C3A0 	2E 22 20 46 61 69 6C 65 
1A5C3A8 	64 20 74 6F 20 6D 61 6B 
1A5C3B0 	65 20 72 6F 6F 74 20 68 
1A5C3B8 	75 62 20 6E 6F 64 65 20 
1A5C3C0 	66 6F 72 20 70 6F 72 74 
1A5C3C8 	20 22 20 64 75 70 20 2E 
1A5C3D0 	64 20 63 72  0  0  0  0 
1A5C3D8 	D8 E5 A0  1 
s"       true to probe-error?" eval
1A5C3DC 	9C 53 A0  1 
1A5C3E0 	1A 20 20 20 20 20 20 74 
1A5C3E8 	72 75 65 20 74 6F 20 70 
1A5C3F0 	72 6F 62 65 2D 65 72 72 
1A5C3F8 	6F 72 3F  0 D8 E5 A0  1 
s"    then ;" eval
1A5C400 	9C 53 A0  1  9 20 20 20 
1A5C408 	74 68 65 6E 20 3B  0  0 
1A5C410 	D8 E5 A0  1 

s" defer handle-ls-device  ' disown-port to handle-ls-device" eval
1A5C414 	9C 53 A0  1 
1A5C418 	39 64 65 66 65 72 20 68 
1A5C420 	61 6E 64 6C 65 2D 6C 73 
1A5C428 	2D 64 65 76 69 63 65 20 
1A5C430 	20 27 20 64 69 73 6F 77 
1A5C438 	6E 2D 70 6F 72 74 20 74 
1A5C440 	6F 20 68 61 6E 64 6C 65 
1A5C448 	2D 6C 73 2D 64 65 76 69 
1A5C450 	63 65  0  0 D8 E5 A0  1 
s" defer handle-fs-device  ' disown-port to handle-fs-device" eval
1A5C458 	9C 53 A0  1 39 64 65 66 
1A5C460 	65 72 20 68 61 6E 64 6C 
1A5C468 	65 2D 66 73 2D 64 65 76 
1A5C470 	69 63 65 20 20 27 20 64 
1A5C478 	69 73 6F 77 6E 2D 70 6F 
1A5C480 	72 74 20 74 6F 20 68 61 
1A5C488 	6E 64 6C 65 2D 66 73 2D 
1A5C490 	64 65 76 69 63 65  0  0 
1A5C498 	D8 E5 A0  1 

s" : probe-root-hub-port" eval  ( port -- )
1A5C49C 	9C 53 A0  1 
1A5C4A0 	15 3A 20 70 72 6F 62 65 
1A5C4A8 	2D 72 6F 6F 74 2D 68 75 
1A5C4B0 	62 2D 70 6F 72 74  0  0 
1A5C4B8 	D8 E5 A0  1 
s"    false to probe-error?" eval			( port )
1A5C4BC 	9C 53 A0  1 
1A5C4C0 	18 20 20 20 66 61 6C 73 
1A5C4C8 	65 20 74 6F 20 70 72 6F 
1A5C4D0 	62 65 2D 65 72 72 6F 72 
1A5C4D8 	3F  0  0  0 D8 E5 A0  1 
s"    dup disable-old-nodes" eval			( port )
1A5C4E0 	9C 53 A0  1 18 20 20 20 
1A5C4E8 	64 75 70 20 64 69 73 61 
1A5C4F0 	62 6C 65 2D 6F 6C 64 2D 
1A5C4F8 	6E 6F 64 65 73  0  0  0 
1A5C500 	D8 E5 A0  1 
s"    dup portsc@ 1 and 0=  if  drop exit  then" eval	( port ) \ No device detected
1A5C504 	9C 53 A0  1 
1A5C508 	2C 20 20 20 64 75 70 20 
1A5C510 	70 6F 72 74 73 63 40 20 
1A5C518 	31 20 61 6E 64 20 30 3D 
1A5C520 	20 20 69 66 20 20 64 72 
1A5C528 	6F 70 20 65 78 69 74 20 
1A5C530 	20 74 68 65 6E  0  0  0 
1A5C538 	D8 E5 A0  1 

s"    dup portsc@ h# c00 and h# 400 =  if" eval		\ A low speed device detected
1A5C53C 	9C 53 A0  1 
1A5C540 	26 20 20 20 64 75 70 20 
1A5C548 	70 6F 72 74 73 63 40 20 
1A5C550 	68 23 20 63 30 30 20 61 
1A5C558 	6E 64 20 68 23 20 34 30 
1A5C560 	30 20 3D 20 20 69 66  0 
1A5C568 	D8 E5 A0  1 
s"       speed-low to port-speed" eval
1A5C56C 	9C 53 A0  1 
1A5C570 	1D 20 20 20 20 20 20 73 
1A5C578 	70 65 65 64 2D 6C 6F 77 
1A5C580 	20 74 6F 20 70 6F 72 74 
1A5C588 	2D 73 70 65 65 64  0  0 
1A5C590 	D8 E5 A0  1 
s"       dup handle-ls-device" eval			\ Process low-speed device
1A5C594 	9C 53 A0  1 
1A5C598 	1A 20 20 20 20 20 20 64 
1A5C5A0 	75 70 20 68 61 6E 64 6C 
1A5C5A8 	65 2D 6C 73 2D 64 65 76 
1A5C5B0 	69 63 65  0 D8 E5 A0  1 
s"    else" eval						\ Don't know what it is
1A5C5B8 	9C 53 A0  1  7 20 20 20 
1A5C5C0 	65 6C 73 65  0  0  0  0 
1A5C5C8 	D8 E5 A0  1 
s"       dup reset-port" eval				\ Reset to find out
1A5C5CC 	9C 53 A0  1 
1A5C5D0 	14 20 20 20 20 20 20 64 
1A5C5D8 	75 70 20 72 65 73 65 74 
1A5C5E0 	2D 70 6F 72 74  0  0  0 
1A5C5E8 	D8 E5 A0  1 
s"       dup portsc@ 4 and  0=  if" eval			\ A full speed device detected
1A5C5EC 	9C 53 A0  1 
1A5C5F0 	1F 20 20 20 20 20 20 64 
1A5C5F8 	75 70 20 70 6F 72 74 73 
1A5C600 	63 40 20 34 20 61 6E 64 
1A5C608 	20 20 30 3D 20 20 69 66 
1A5C610 	 0  0  0  0 D8 E5 A0  1 
s"          speed-full to port-speed" eval
1A5C618 	9C 53 A0  1 21 20 20 20 
1A5C620 	20 20 20 20 20 20 73 70 
1A5C628 	65 65 64 2D 66 75 6C 6C 
1A5C630 	20 74 6F 20 70 6F 72 74 
1A5C638 	2D 73 70 65 65 64  0  0 
1A5C640 	D8 E5 A0  1 
s" 	 dup handle-fs-device" eval			\ Process full-speed device
1A5C644 	9C 53 A0  1 
1A5C648 	16  9 20 64 75 70 20 68 
1A5C650 	61 6E 64 6C 65 2D 66 73 
1A5C658 	2D 64 65 76 69 63 65  0 
1A5C660 	D8 E5 A0  1 
s"       else" eval					\ A high speed device detected
1A5C664 	9C 53 A0  1 
1A5C668 	 A 20 20 20 20 20 20 65 
1A5C670 	6C 73 65  0 D8 E5 A0  1 
s"          speed-high to port-speed" eval
1A5C678 	9C 53 A0  1 21 20 20 20 
1A5C680 	20 20 20 20 20 20 73 70 
1A5C688 	65 65 64 2D 68 69 67 68 
1A5C690 	20 74 6F 20 70 6F 72 74 
1A5C698 	2D 73 70 65 65 64  0  0 
1A5C6A0 	D8 E5 A0  1 
s"          dup make-port-node" eval			\ Process high-speed device
1A5C6A4 	9C 53 A0  1 
1A5C6A8 	1B 20 20 20 20 20 20 20 
1A5C6B0 	20 20 64 75 70 20 6D 61 
1A5C6B8 	6B 65 2D 70 6F 72 74 2D 
1A5C6C0 	6E 6F 64 65  0  0  0  0 
1A5C6C8 	D8 E5 A0  1 
s"       then" eval
1A5C6CC 	9C 53 A0  1 
1A5C6D0 	 A 20 20 20 20 20 20 74 
1A5C6D8 	68 65 6E  0 D8 E5 A0  1 
s"    then" eval                           ( port# )
1A5C6E0 	9C 53 A0  1  7 20 20 20 
1A5C6E8 	74 68 65 6E  0  0  0  0 
1A5C6F0 	D8 E5 A0  1 
s"    dup portsc@ swap portsc! ;" eval     ( )		\ Clear connection change bit
1A5C6F4 	9C 53 A0  1 
1A5C6F8 	1D 20 20 20 64 75 70 20 
1A5C700 	70 6F 72 74 73 63 40 20 
1A5C708 	73 77 61 70 20 70 6F 72 
1A5C710 	74 73 63 21 20 3B  0  0 
1A5C718 	D8 E5 A0  1 


s" : #testable-ports" eval  ( -- n )
1A5C71C 	9C 53 A0  1 
1A5C720 	11 3A 20 23 74 65 73 74 
1A5C728 	61 62 6C 65 2D 70 6F 72 
1A5C730 	74 73  0  0 D8 E5 A0  1 
s"    #ports" eval                                            ( #hardware-ports )
1A5C738 	9C 53 A0  1  9 20 20 20 
1A5C740 	23 70 6F 72 74 73  0  0 
1A5C748 	D8 E5 A0  1 
 "    "" usb-test-ports"" get-inherited-property  0=  if" eval  ( #hardware-ports adr len )
1A5C74C 	9C 53 A0  1 
1A5C750 	33 20 20 20 22 20 75 73 
1A5C758 	62 2D 74 65 73 74 2D 70 
1A5C760 	6F 72 74 73 22 20 67 65 
1A5C768 	74 2D 69 6E 68 65 72 69 
1A5C770 	74 65 64 2D 70 72 6F 70 
1A5C778 	65 72 74 79 20 20 30 3D 
1A5C780 	20 20 69 66  0  0  0  0 
1A5C788 	D8 E5 A0  1 
s"       decode-int  nip nip  min" eval                       ( #testable-ports )
1A5C78C 	9C 53 A0  1 
1A5C790 	1E 20 20 20 20 20 20 64 
1A5C798 	65 63 6F 64 65 2D 69 6E 
1A5C7A0 	74 20 20 6E 69 70 20 6E 
1A5C7A8 	69 70 20 20 6D 69 6E  0 
1A5C7B0 	D8 E5 A0  1 
s"    then ; " eval                                              ( #testable-ports )
1A5C7B4 	9C 53 A0  1 
1A5C7B8 	 A 20 20 20 74 68 65 6E 
1A5C7C0 	20 3B 20  0 D8 E5 A0  1 


\ Port owned by usb 1.1 controller (2000) or device is present (1)
s" : port-connected?  ( port# -- flag )  portsc@ h# 2001 and  ;" eval
1A5C7C8 	9C 53 A0  1 3C 3A 20 70 
1A5C7D0 	6F 72 74 2D 63 6F 6E 6E 
1A5C7D8 	65 63 74 65 64 3F 20 20 
1A5C7E0 	28 20 70 6F 72 74 23 20 
1A5C7E8 	2D 2D 20 66 6C 61 67 20 
1A5C7F0 	29 20 20 70 6F 72 74 73 
1A5C7F8 	63 40 20 68 23 20 32 30 
1A5C800 	30 31 20 61 6E 64 20 20 
1A5C808 	3B  0  0  0 D8 E5 A0  1 
s" : wait-connect" eval  ( port# -- error? )
1A5C810 	9C 53 A0  1  E 3A 20 77 
1A5C818 	61 69 74 2D 63 6F 6E 6E 
1A5C820 	65 63 74  0 D8 E5 A0  1 
s"    begin" eval                            ( port# )
1A5C828 	9C 53 A0  1  8 20 20 20 
1A5C830 	62 65 67 69 6E  0  0  0 
1A5C838 	D8 E5 A0  1 
s"       dup port-connected?  0=" eval       ( port# unconnected? )
1A5C83C 	9C 53 A0  1 
1A5C840 	1D 20 20 20 20 20 20 64 
1A5C848 	75 70 20 70 6F 72 74 2D 
1A5C850 	63 6F 6E 6E 65 63 74 65 
1A5C858 	64 3F 20 20 30 3D  0  0 
1A5C860 	D8 E5 A0  1 
s"    while" eval                            ( port# )
1A5C864 	9C 53 A0  1 
1A5C868 	 8 20 20 20 77 68 69 6C 
1A5C870 	65  0  0  0 D8 E5 A0  1 
s"       key?  if" eval                      ( port# )
1A5C878 	9C 53 A0  1  E 20 20 20 
1A5C880 	20 20 20 6B 65 79 3F 20 
1A5C888 	20 69 66  0 D8 E5 A0  1 
s"          key h# 1b =  if" eval            ( port# )   \ ESC aborts
1A5C890 	9C 53 A0  1 18 20 20 20 
1A5C898 	20 20 20 20 20 20 6B 65 
1A5C8A0 	79 20 68 23 20 31 62 20 
1A5C8A8 	3D 20 20 69 66  0  0  0 
1A5C8B0 	D8 E5 A0  1 
s"             drop true exit" eval          ( -- true )
1A5C8B4 	9C 53 A0  1 
1A5C8B8 	1A 20 20 20 20 20 20 20 
1A5C8C0 	20 20 20 20 20 64 72 6F 
1A5C8C8 	70 20 74 72 75 65 20 65 
1A5C8D0 	78 69 74  0 D8 E5 A0  1 
s"          then" eval                       ( port# )
1A5C8D8 	9C 53 A0  1  D 20 20 20 
1A5C8E0 	20 20 20 20 20 20 74 68 
1A5C8E8 	65 6E  0  0 D8 E5 A0  1 
s"       then" eval                          ( port# )
1A5C8F0 	9C 53 A0  1  A 20 20 20 
1A5C8F8 	20 20 20 74 68 65 6E  0 
1A5C900 	D8 E5 A0  1 
s"    repeat" eval                           ( port# )
1A5C904 	9C 53 A0  1 
1A5C908 	 9 20 20 20 72 65 70 65 
1A5C910 	61 74  0  0 D8 E5 A0  1 
 "    ."" Device connected - probing ... "" " eval
1A5C918 	9C 53 A0  1 27 20 20 20 
1A5C920 	2E 22 20 44 65 76 69 63 
1A5C928 	65 20 63 6F 6E 6E 65 63 
1A5C930 	74 65 64 20 2D 20 70 72 
1A5C938 	6F 62 69 6E 67 20 2E 2E 
1A5C940 	2E 20 22 20  0  0  0  0 
1A5C948 	D8 E5 A0  1 
s"    probe-setup" eval                      ( port# )
1A5C94C 	9C 53 A0  1 
1A5C950 	 E 20 20 20 70 72 6F 62 
1A5C958 	65 2D 73 65 74 75 70  0 
1A5C960 	D8 E5 A0  1 
s"    probe-root-hub-port" eval              ( )
1A5C964 	9C 53 A0  1 
1A5C968 	16 20 20 20 70 72 6F 62 
1A5C970 	65 2D 72 6F 6F 74 2D 68 
1A5C978 	75 62 2D 70 6F 72 74  0 
1A5C980 	D8 E5 A0  1 
s"    probe-teardown" eval                   ( )
1A5C984 	9C 53 A0  1 
1A5C988 	11 20 20 20 70 72 6F 62 
1A5C990 	65 2D 74 65 61 72 64 6F 
1A5C998 	77 6E  0  0 D8 E5 A0  1 
s"    probe-error?" eval                     ( error? )
1A5C9A0 	9C 53 A0  1  F 20 20 20 
1A5C9A8 	70 72 6F 62 65 2D 65 72 
1A5C9B0 	72 6F 72 3F  0  0  0  0 
1A5C9B8 	D8 E5 A0  1 
 "    dup  if  ."" Failed"" else  ."" Done""  then  cr ;" eval ( error? )
1A5C9BC 	9C 53 A0  1 
1A5C9C0 	31 20 20 20 64 75 70 20 
1A5C9C8 	20 69 66 20 20 2E 22 20 
1A5C9D0 	46 61 69 6C 65 64 22 20 
1A5C9D8 	65 6C 73 65 20 20 2E 22 
1A5C9E0 	20 44 6F 6E 65 22 20 20 
1A5C9E8 	74 68 65 6E 20 20 63 72 
1A5C9F0 	20 3B  0  0 D8 E5 A0  1 

s" : power-usb-ports  ( -- )  ;" eval
1A5C9F8 	9C 53 A0  1 1C 3A 20 70 
1A5CA00 	6F 77 65 72 2D 75 73 62 
1A5CA08 	2D 70 6F 72 74 73 20 20 
1A5CA10 	28 20 2D 2D 20 29 20 20 
1A5CA18 	3B  0  0  0 D8 E5 A0  1 

s" : port-changed?  ( port# -- flag )  portsc@ 2 and 0<>  ;" eval
1A5CA20 	9C 53 A0  1 38 3A 20 70 
1A5CA28 	6F 72 74 2D 63 68 61 6E 
1A5CA30 	67 65 64 3F 20 20 28 20 
1A5CA38 	70 6F 72 74 23 20 2D 2D 
1A5CA40 	20 66 6C 61 67 20 29 20 
1A5CA48 	20 70 6F 72 74 73 63 40 
1A5CA50 	20 32 20 61 6E 64 20 30 
1A5CA58 	3C 3E 20 20 3B  0  0  0 
1A5CA60 	D8 E5 A0  1 
s" : ports-changed?" eval  ( -- flag )
1A5CA64 	9C 53 A0  1 
1A5CA68 	10 3A 20 70 6F 72 74 73 
1A5CA70 	2D 63 68 61 6E 67 65 64 
1A5CA78 	3F  0  0  0 D8 E5 A0  1 
s"    #ports 0  ?do" eval
1A5CA80 	9C 53 A0  1 10 20 20 20 
1A5CA88 	23 70 6F 72 74 73 20 30 
1A5CA90 	20 20 3F 64 6F  0  0  0 
1A5CA98 	D8 E5 A0  1 
s"       i port-changed?  if  true unloop exit  then" eval
1A5CA9C 	9C 53 A0  1 
1A5CAA0 	31 20 20 20 20 20 20 69 
1A5CAA8 	20 70 6F 72 74 2D 63 68 
1A5CAB0 	61 6E 67 65 64 3F 20 20 
1A5CAB8 	69 66 20 20 74 72 75 65 
1A5CAC0 	20 75 6E 6C 6F 6F 70 20 
1A5CAC8 	65 78 69 74 20 20 74 68 
1A5CAD0 	65 6E  0  0 D8 E5 A0  1 
s"    loop" eval
1A5CAD8 	9C 53 A0  1  7 20 20 20 
1A5CAE0 	6C 6F 6F 70  0  0  0  0 
1A5CAE8 	D8 E5 A0  1 
s"    false ;" eval
1A5CAEC 	9C 53 A0  1 
1A5CAF0 	 A 20 20 20 66 61 6C 73 
1A5CAF8 	65 20 3B  0 D8 E5 A0  1 

s" : probe-root-hub" eval  ( -- )
1A5CB00 	9C 53 A0  1 10 3A 20 70 
1A5CB08 	72 6F 62 65 2D 72 6F 6F 
1A5CB10 	74 2D 68 75 62  0  0  0 
1A5CB18 	D8 E5 A0  1 
s"    probe-setup" eval
1A5CB1C 	9C 53 A0  1 
1A5CB20 	 E 20 20 20 70 72 6F 62 
1A5CB28 	65 2D 73 65 74 75 70  0 
1A5CB30 	D8 E5 A0  1 

s"    #ports 0  ?do" eval			        \ For each port
1A5CB34 	9C 53 A0  1 
1A5CB38 	10 20 20 20 23 70 6F 72 
1A5CB40 	74 73 20 30 20 20 3F 64 
1A5CB48 	6F  0  0  0 D8 E5 A0  1 
s"       i port-changed?  if" eval			\ Connection changed
1A5CB50 	9C 53 A0  1 19 20 20 20 
1A5CB58 	20 20 20 69 20 70 6F 72 
1A5CB60 	74 2D 63 68 61 6E 67 65 
1A5CB68 	64 3F 20 20 69 66  0  0 
1A5CB70 	D8 E5 A0  1 
\         i rm-obsolete-children			\ Remove obsolete device nodes
s"          i probe-root-hub-port" eval			\ Probe it
1A5CB74 	9C 53 A0  1 
1A5CB78 	1E 20 20 20 20 20 20 20 
1A5CB80 	20 20 69 20 70 72 6F 62 
1A5CB88 	65 2D 72 6F 6F 74 2D 68 
1A5CB90 	75 62 2D 70 6F 72 74  0 
1A5CB98 	D8 E5 A0  1 
s"       else" eval
1A5CB9C 	9C 53 A0  1 
1A5CBA0 	 A 20 20 20 20 20 20 65 
1A5CBA8 	6C 73 65  0 D8 E5 A0  1 
s"          i port-is-hub?  if" eval     ( phandle )     \ Already-connected hub?
1A5CBB0 	9C 53 A0  1 1B 20 20 20 
1A5CBB8 	20 20 20 20 20 20 69 20 
1A5CBC0 	70 6F 72 74 2D 69 73 2D 
1A5CBC8 	68 75 62 3F 20 20 69 66 
1A5CBD0 	 0  0  0  0 D8 E5 A0  1 
s"             reprobe-hub-node" eval                    \ Check for changes on its ports
1A5CBD8 	9C 53 A0  1 1C 20 20 20 
1A5CBE0 	20 20 20 20 20 20 20 20 
1A5CBE8 	20 72 65 70 72 6F 62 65 
1A5CBF0 	2D 68 75 62 2D 6E 6F 64 
1A5CBF8 	65  0  0  0 D8 E5 A0  1 
s"          then" eval
1A5CC00 	9C 53 A0  1  D 20 20 20 
1A5CC08 	20 20 20 20 20 20 74 68 
1A5CC10 	65 6E  0  0 D8 E5 A0  1 
s"       then" eval
1A5CC18 	9C 53 A0  1  A 20 20 20 
1A5CC20 	20 20 20 74 68 65 6E  0 
1A5CC28 	D8 E5 A0  1 
s"    loop" eval
1A5CC2C 	9C 53 A0  1 
1A5CC30 	 7 20 20 20 6C 6F 6F 70 
1A5CC38 	 0  0  0  0 D8 E5 A0  1 

s"    probe-teardown ;" eval
1A5CC40 	9C 53 A0  1 13 20 20 20 
1A5CC48 	70 72 6F 62 65 2D 74 65 
1A5CC50 	61 72 64 6F 77 6E 20 3B 
1A5CC58 	 0  0  0  0 D8 E5 A0  1 

s" : do-resume" eval  ( -- )
1A5CC60 	9C 53 A0  1  B 3A 20 64 
1A5CC68 	6F 2D 72 65 73 75 6D 65 
1A5CC70 	 0  0  0  0 D8 E5 A0  1 
s"    init-ehci-regs" eval
1A5CC78 	9C 53 A0  1 11 20 20 20 
1A5CC80 	69 6E 69 74 2D 65 68 63 
1A5CC88 	69 2D 72 65 67 73  0  0 
1A5CC90 	D8 E5 A0  1 
s"    start-usb" eval
1A5CC94 	9C 53 A0  1 
1A5CC98 	 C 20 20 20 73 74 61 72 
1A5CCA0 	74 2D 75 73 62  0  0  0 
1A5CCA8 	D8 E5 A0  1 
s"    claim-ownership" eval
1A5CCAC 	9C 53 A0  1 
1A5CCB0 	12 20 20 20 63 6C 61 69 
1A5CCB8 	6D 2D 6F 77 6E 65 72 73 
1A5CCC0 	68 69 70  0 D8 E5 A0  1 
s"    init-struct" eval
1A5CCC8 	9C 53 A0  1  E 20 20 20 
1A5CCD0 	69 6E 69 74 2D 73 74 72 
1A5CCD8 	75 63 74  0 D8 E5 A0  1 
s"    init-extra ;" eval
1A5CCE0 	9C 53 A0  1  F 20 20 20 
1A5CCE8 	69 6E 69 74 2D 65 78 74 
1A5CCF0 	72 61 20 3B  0  0  0  0 
1A5CCF8 	D8 E5 A0  1 

\ Some OTG controllers need to do something after reset-usb to go into host mode
s" defer set-host-mode  ' noop to set-host-mode" eval
1A5CCFC 	9C 53 A0  1 
1A5CD00 	2C 64 65 66 65 72 20 73 
1A5CD08 	65 74 2D 68 6F 73 74 2D 
1A5CD10 	6D 6F 64 65 20 20 27 20 
1A5CD18 	6E 6F 6F 70 20 74 6F 20 
1A5CD20 	73 65 74 2D 68 6F 73 74 
1A5CD28 	2D 6D 6F 64 65  0  0  0 
1A5CD30 	D8 E5 A0  1 

\ This is a sneaky way to determine if the hardware has been turned off without the software's knowledge
s" : suspended?  ( -- flag )  asynclist@ 0=  qh-ptr 0<>  and  ;" eval
1A5CD34 	9C 53 A0  1 
1A5CD38 	3C 3A 20 73 75 73 70 65 
1A5CD40 	6E 64 65 64 3F 20 20 28 
1A5CD48 	20 2D 2D 20 66 6C 61 67 
1A5CD50 	20 29 20 20 61 73 79 6E 
1A5CD58 	63 6C 69 73 74 40 20 30 
1A5CD60 	3D 20 20 71 68 2D 70 74 
1A5CD68 	72 20 30 3C 3E 20 20 61 
1A5CD70 	6E 64 20 20 3B  0  0  0 
1A5CD78 	D8 E5 A0  1 

s" : open" eval  ( -- flag )
1A5CD7C 	9C 53 A0  1 
1A5CD80 	 6 3A 20 6F 70 65 6E  0 
1A5CD88 	D8 E5 A0  1 
s"    parse-my-args" eval
1A5CD8C 	9C 53 A0  1 
1A5CD90 	10 20 20 20 70 61 72 73 
1A5CD98 	65 2D 6D 79 2D 61 72 67 
1A5CDA0 	73  0  0  0 D8 E5 A0  1 
s"    open-count 0=  if" eval
1A5CDA8 	9C 53 A0  1 14 20 20 20 
1A5CDB0 	6F 70 65 6E 2D 63 6F 75 
1A5CDB8 	6E 74 20 30 3D 20 20 69 
1A5CDC0 	66  0  0  0 D8 E5 A0  1 
s"       map-regs" eval
1A5CDC8 	9C 53 A0  1  E 20 20 20 
1A5CDD0 	20 20 20 6D 61 70 2D 72 
1A5CDD8 	65 67 73  0 D8 E5 A0  1 
s"       alloc-dma-buf" eval
1A5CDE0 	9C 53 A0  1 13 20 20 20 
1A5CDE8 	20 20 20 61 6C 6C 6F 63 
1A5CDF0 	2D 64 6D 61 2D 62 75 66 
1A5CDF8 	 0  0  0  0 D8 E5 A0  1 
s"       first-open?  if" eval
1A5CE00 	9C 53 A0  1 15 20 20 20 
1A5CE08 	20 20 20 66 69 72 73 74 
1A5CE10 	2D 6F 70 65 6E 3F 20 20 
1A5CE18 	69 66  0  0 D8 E5 A0  1 
s"          false to first-open?" eval
1A5CE20 	9C 53 A0  1 1D 20 20 20 
1A5CE28 	20 20 20 20 20 20 66 61 
1A5CE30 	6C 73 65 20 74 6F 20 66 
1A5CE38 	69 72 73 74 2D 6F 70 65 
1A5CE40 	6E 3F  0  0 D8 E5 A0  1 
s"          hccparams@ 8 rshift h# ff and  ?dup  if" eval  ( config-adr )
1A5CE48 	9C 53 A0  1 30 20 20 20 
1A5CE50 	20 20 20 20 20 20 68 63 
1A5CE58 	63 70 61 72 61 6D 73 40 
1A5CE60 	20 38 20 72 73 68 69 66 
1A5CE68 	74 20 68 23 20 66 66 20 
1A5CE70 	61 6E 64 20 20 3F 64 75 
1A5CE78 	70 20 20 69 66  0  0  0 
1A5CE80 	D8 E5 A0  1 
s"             grab-controller  if" eval
1A5CE84 	9C 53 A0  1 
1A5CE88 	1F 20 20 20 20 20 20 20 
1A5CE90 	20 20 20 20 20 67 72 61 
1A5CE98 	62 2D 63 6F 6E 74 72 6F 
1A5CEA0 	6C 6C 65 72 20 20 69 66 
1A5CEA8 	 0  0  0  0 D8 E5 A0  1 
 "                ."" Can't take control of EHCI from underlying BIOS"" cr" eval
1A5CEB0 	9C 53 A0  1 45 20 20 20 
1A5CEB8 	20 20 20 20 20 20 20 20 
1A5CEC0 	20 20 20 20 2E 22 20 43 
1A5CEC8 	61 6E 27 74 20 74 61 6B 
1A5CED0 	65 20 63 6F 6E 74 72 6F 
1A5CED8 	6C 20 6F 66 20 45 48 43 
1A5CEE0 	49 20 66 72 6F 6D 20 75 
1A5CEE8 	6E 64 65 72 6C 79 69 6E 
1A5CEF0 	67 20 42 49 4F 53 22 20 
1A5CEF8 	63 72  0  0 D8 E5 A0  1 
s"                free-dma-buf unmap-regs" eval
1A5CF00 	9C 53 A0  1 26 20 20 20 
1A5CF08 	20 20 20 20 20 20 20 20 
1A5CF10 	20 20 20 20 66 72 65 65 
1A5CF18 	2D 64 6D 61 2D 62 75 66 
1A5CF20 	20 75 6E 6D 61 70 2D 72 
1A5CF28 	65 67 73  0 D8 E5 A0  1 
s"                false exit" eval
1A5CF30 	9C 53 A0  1 19 20 20 20 
1A5CF38 	20 20 20 20 20 20 20 20 
1A5CF40 	20 20 20 20 66 61 6C 73 
1A5CF48 	65 20 65 78 69 74  0  0 
1A5CF50 	D8 E5 A0  1 
s"             then" eval
1A5CF54 	9C 53 A0  1 
1A5CF58 	10 20 20 20 20 20 20 20 
1A5CF60 	20 20 20 20 20 74 68 65 
1A5CF68 	6E  0  0  0 D8 E5 A0  1 
s"          then" eval
1A5CF70 	9C 53 A0  1  D 20 20 20 
1A5CF78 	20 20 20 20 20 20 74 68 
1A5CF80 	65 6E  0  0 D8 E5 A0  1 
s"          0 ehci-reg@  h# ff and to op-reg-offset" eval
1A5CF88 	9C 53 A0  1 30 20 20 20 
1A5CF90 	20 20 20 20 20 20 30 20 
1A5CF98 	65 68 63 69 2D 72 65 67 
1A5CFA0 	40 20 20 68 23 20 66 66 
1A5CFA8 	20 61 6E 64 20 74 6F 20 
1A5CFB0 	6F 70 2D 72 65 67 2D 6F 
1A5CFB8 	66 66 73 65 74  0  0  0 
1A5CFC0 	D8 E5 A0  1 
s"          reset-usb" eval
1A5CFC4 	9C 53 A0  1 
1A5CFC8 	12 20 20 20 20 20 20 20 
1A5CFD0 	20 20 72 65 73 65 74 2D 
1A5CFD8 	75 73 62  0 D8 E5 A0  1 
s"          set-host-mode" eval
1A5CFE0 	9C 53 A0  1 16 20 20 20 
1A5CFE8 	20 20 20 20 20 20 73 65 
1A5CFF0 	74 2D 68 6F 73 74 2D 6D 
1A5CFF8 	6F 64 65  0 D8 E5 A0  1 
s"          do-resume" eval
1A5D000 	9C 53 A0  1 12 20 20 20 
1A5D008 	20 20 20 20 20 20 64 6F 
1A5D010 	2D 72 65 73 75 6D 65  0 
1A5D018 	D8 E5 A0  1 
s"       then" eval
1A5D01C 	9C 53 A0  1 
1A5D020 	 A 20 20 20 20 20 20 74 
1A5D028 	68 65 6E  0 D8 E5 A0  1 
s"       suspended?  if  do-resume  then" eval
1A5D030 	9C 53 A0  1 25 20 20 20 
1A5D038 	20 20 20 73 75 73 70 65 
1A5D040 	6E 64 65 64 3F 20 20 69 
1A5D048 	66 20 20 64 6F 2D 72 65 
1A5D050 	73 75 6D 65 20 20 74 68 
1A5D058 	65 6E  0  0 D8 E5 A0  1 
s"    then" eval
1A5D060 	9C 53 A0  1  7 20 20 20 
1A5D068 	74 68 65 6E  0  0  0  0 
1A5D070 	D8 E5 A0  1 
s"    probe-root-hub" eval
1A5D074 	9C 53 A0  1 
1A5D078 	11 20 20 20 70 72 6F 62 
1A5D080 	65 2D 72 6F 6F 74 2D 68 
1A5D088 	75 62  0  0 D8 E5 A0  1 
s"    open-count 1+ to open-count" eval
1A5D090 	9C 53 A0  1 1E 20 20 20 
1A5D098 	6F 70 65 6E 2D 63 6F 75 
1A5D0A0 	6E 74 20 31 2B 20 74 6F 
1A5D0A8 	20 6F 70 65 6E 2D 63 6F 
1A5D0B0 	75 6E 74  0 D8 E5 A0  1 
s"    true ;" eval
1A5D0B8 	9C 53 A0  1  9 20 20 20 
1A5D0C0 	74 72 75 65 20 3B  0  0 
1A5D0C8 	D8 E5 A0  1 

s" : close" eval  ( -- )
1A5D0CC 	9C 53 A0  1 
1A5D0D0 	 7 3A 20 63 6C 6F 73 65 
1A5D0D8 	 0  0  0  0 D8 E5 A0  1 
s"    open-count 1- to open-count" eval
1A5D0E0 	9C 53 A0  1 1E 20 20 20 
1A5D0E8 	6F 70 65 6E 2D 63 6F 75 
1A5D0F0 	6E 74 20 31 2D 20 74 6F 
1A5D0F8 	20 6F 70 65 6E 2D 63 6F 
1A5D100 	75 6E 74  0 D8 E5 A0  1 
s"    end-extra" eval
1A5D108 	9C 53 A0  1  C 20 20 20 
1A5D110 	65 6E 64 2D 65 78 74 72 
1A5D118 	61  0  0  0 D8 E5 A0  1 
s"    open-count 0=  if  free-dma-buf unmap-regs  then ;" eval
1A5D120 	9C 53 A0  1 35 20 20 20 
1A5D128 	6F 70 65 6E 2D 63 6F 75 
1A5D130 	6E 74 20 30 3D 20 20 69 
1A5D138 	66 20 20 66 72 65 65 2D 
1A5D140 	64 6D 61 2D 62 75 66 20 
1A5D148 	75 6E 6D 61 70 2D 72 65 
1A5D150 	67 73 20 20 74 68 65 6E 
1A5D158 	20 3B  0  0 D8 E5 A0  1 

s" : regs{  ( -- prev )  ehci-reg dup 0=  if  map-regs  then  ;" eval
1A5D160 	9C 53 A0  1 3C 3A 20 72 
1A5D168 	65 67 73 7B 20 20 28 20 
1A5D170 	2D 2D 20 70 72 65 76 20 
1A5D178 	29 20 20 65 68 63 69 2D 
1A5D180 	72 65 67 20 64 75 70 20 
1A5D188 	30 3D 20 20 69 66 20 20 
1A5D190 	6D 61 70 2D 72 65 67 73 
1A5D198 	20 20 74 68 65 6E 20 20 
1A5D1A0 	3B  0  0  0 D8 E5 A0  1 
s" : }regs  ( prev -- )  0=  if  unmap-regs  then  ;" eval
1A5D1A8 	9C 53 A0  1 31 3A 20 7D 
1A5D1B0 	72 65 67 73 20 20 28 20 
1A5D1B8 	70 72 65 76 20 2D 2D 20 
1A5D1C0 	29 20 20 30 3D 20 20 69 
1A5D1C8 	66 20 20 75 6E 6D 61 70 
1A5D1D0 	2D 72 65 67 73 20 20 74 
1A5D1D8 	68 65 6E 20 20 3B  0  0 
1A5D1E0 	D8 E5 A0  1 

s" : selftest" eval  ( -- error? )
1A5D1E4 	9C 53 A0  1 
1A5D1E8 	 A 3A 20 73 65 6C 66 74 
1A5D1F0 	65 73 74  0 D8 E5 A0  1 
s"   open 0=  if  true exit  then" eval
1A5D1F8 	9C 53 A0  1 1E 20 20 6F 
1A5D200 	70 65 6E 20 30 3D 20 20 
1A5D208 	69 66 20 20 74 72 75 65 
1A5D210 	20 65 78 69 74 20 20 74 
1A5D218 	68 65 6E  0 D8 E5 A0  1 
s"   #testable-ports  0  ?do" eval
1A5D220 	9C 53 A0  1 19 20 20 23 
1A5D228 	74 65 73 74 61 62 6C 65 
1A5D230 	2D 70 6F 72 74 73 20 20 
1A5D238 	30 20 20 3F 64 6F  0  0 
1A5D240 	D8 E5 A0  1 
 "      ."" USB port "" i u. ."" : "" " eval
1A5D244 	9C 53 A0  1 
1A5D248 	1F 20 20 20 20 20 2E 22 
1A5D250 	20 55 53 42 20 70 6F 72 
1A5D258 	74 20 22 20 69 20 75 2E 
1A5D260 	20 2E 22 20 3A 20 22 20 
1A5D268 	 0  0  0  0 D8 E5 A0  1 
s"      i port-connected?  if" eval
1A5D270 	9C 53 A0  1 1A 20 20 20 
1A5D278 	20 20 69 20 70 6F 72 74 
1A5D280 	2D 63 6F 6E 6E 65 63 74 
1A5D288 	65 64 3F 20 20 69 66  0 
1A5D290 	D8 E5 A0  1 
"         ."" In use - "" " eval
1A5D294 	9C 53 A0  1 
1A5D298 	16 20 20 20 20 20 20 20 
1A5D2A0 	20 2E 22 20 49 6E 20 75 
1A5D2A8 	73 65 20 2D 20 22 20  0 
1A5D2B0 	D8 E5 A0  1 
s"         i .usb-device cr" eval
1A5D2B4 	9C 53 A0  1 
1A5D2B8 	18 20 20 20 20 20 20 20 
1A5D2C0 	20 69 20 2E 75 73 62 2D 
1A5D2C8 	64 65 76 69 63 65 20 63 
1A5D2D0 	72  0  0  0 D8 E5 A0  1 
s"      else" eval
1A5D2D8 	9C 53 A0  1  9 20 20 20 
1A5D2E0 	20 20 65 6C 73 65  0  0 
1A5D2E8 	D8 E5 A0  1 
s"         diagnostic-mode?  if" eval
1A5D2EC 	9C 53 A0  1 
1A5D2F0 	1C 20 20 20 20 20 20 20 
1A5D2F8 	20 64 69 61 67 6E 6F 73 
1A5D300 	74 69 63 2D 6D 6F 64 65 
1A5D308 	3F 20 20 69 66  0  0  0 
1A5D310 	D8 E5 A0  1 
 "            ."" Please connect a device"" cr" eval
1A5D314 	9C 53 A0  1 
1A5D318 	29 20 20 20 20 20 20 20 
1A5D320 	20 20 20 20 2E 22 20 50 
1A5D328 	6C 65 61 73 65 20 63 6F 
1A5D330 	6E 6E 65 63 74 20 61 20 
1A5D338 	64 65 76 69 63 65 22 20 
1A5D340 	63 72  0  0 D8 E5 A0  1 
s"            i wait-connect  if  true unloop exit  then" eval
1A5D348 	9C 53 A0  1 35 20 20 20 
1A5D350 	20 20 20 20 20 20 20 20 
1A5D358 	69 20 77 61 69 74 2D 63 
1A5D360 	6F 6E 6E 65 63 74 20 20 
1A5D368 	69 66 20 20 74 72 75 65 
1A5D370 	20 75 6E 6C 6F 6F 70 20 
1A5D378 	65 78 69 74 20 20 74 68 
1A5D380 	65 6E  0  0 D8 E5 A0  1 
s"            i .usb-device cr" eval
1A5D388 	9C 53 A0  1 1B 20 20 20 
1A5D390 	20 20 20 20 20 20 20 20 
1A5D398 	69 20 2E 75 73 62 2D 64 
1A5D3A0 	65 76 69 63 65 20 63 72 
1A5D3A8 	 0  0  0  0 D8 E5 A0  1 
s"         else" eval
1A5D3B0 	9C 53 A0  1  C 20 20 20 
1A5D3B8 	20 20 20 20 20 65 6C 73 
1A5D3C0 	65  0  0  0 D8 E5 A0  1 
s"            fisheye?  if" eval
1A5D3C8 	9C 53 A0  1 17 20 20 20 
1A5D3D0 	20 20 20 20 20 20 20 20 
1A5D3D8 	66 69 73 68 65 79 65 3F 
1A5D3E0 	20 20 69 66  0  0  0  0 
1A5D3E8 	D8 E5 A0  1 
 "               ."" Fisheye pattern"" cr" eval
1A5D3EC 	9C 53 A0  1 
1A5D3F0 	24 20 20 20 20 20 20 20 
1A5D3F8 	20 20 20 20 20 20 20 2E 
1A5D400 	22 20 46 69 73 68 65 79 
1A5D408 	65 20 70 61 74 74 65 72 
1A5D410 	6E 22 20 63 72  0  0  0 
1A5D418 	D8 E5 A0  1 
s"               i test-port-begin" eval
1A5D41C 	9C 53 A0  1 
1A5D420 	1F 20 20 20 20 20 20 20 
1A5D428 	20 20 20 20 20 20 20 69 
1A5D430 	20 74 65 73 74 2D 70 6F 
1A5D438 	72 74 2D 62 65 67 69 6E 
1A5D440 	 0  0  0  0 D8 E5 A0  1 
s"               d# 2,000 ms" eval
1A5D448 	9C 53 A0  1 19 20 20 20 
1A5D450 	20 20 20 20 20 20 20 20 
1A5D458 	20 20 20 64 23 20 32 2C 
1A5D460 	30 30 30 20 6D 73  0  0 
1A5D468 	D8 E5 A0  1 
s"               i test-port-end" eval
1A5D46C 	9C 53 A0  1 
1A5D470 	1D 20 20 20 20 20 20 20 
1A5D478 	20 20 20 20 20 20 20 69 
1A5D480 	20 74 65 73 74 2D 70 6F 
1A5D488 	72 74 2D 65 6E 64  0  0 
1A5D490 	D8 E5 A0  1 
s"               0 i portsc!  i reset-port  i power-port" eval
1A5D494 	9C 53 A0  1 
1A5D498 	35 20 20 20 20 20 20 20 
1A5D4A0 	20 20 20 20 20 20 20 30 
1A5D4A8 	20 69 20 70 6F 72 74 73 
1A5D4B0 	63 21 20 20 69 20 72 65 
1A5D4B8 	73 65 74 2D 70 6F 72 74 
1A5D4C0 	20 20 69 20 70 6F 77 65 
1A5D4C8 	72 2D 70 6F 72 74  0  0 
1A5D4D0 	D8 E5 A0  1 
s"            else" eval
1A5D4D4 	9C 53 A0  1 
1A5D4D8 	 F 20 20 20 20 20 20 20 
1A5D4E0 	20 20 20 20 65 6C 73 65 
1A5D4E8 	 0  0  0  0 D8 E5 A0  1 
 "               ."" Empty"" cr" eval
1A5D4F0 	9C 53 A0  1 1A 20 20 20 
1A5D4F8 	20 20 20 20 20 20 20 20 
1A5D500 	20 20 20 2E 22 20 45 6D 
1A5D508 	70 74 79 22 20 63 72  0 
1A5D510 	D8 E5 A0  1 
s"            then" eval
1A5D514 	9C 53 A0  1 
1A5D518 	 F 20 20 20 20 20 20 20 
1A5D520 	20 20 20 20 74 68 65 6E 
1A5D528 	 0  0  0  0 D8 E5 A0  1 
s"         then" eval
1A5D530 	9C 53 A0  1  C 20 20 20 
1A5D538 	20 20 20 20 20 74 68 65 
1A5D540 	6E  0  0  0 D8 E5 A0  1 
s"      then" eval
1A5D548 	9C 53 A0  1  9 20 20 20 
1A5D550 	20 20 74 68 65 6E  0  0 
1A5D558 	D8 E5 A0  1 
s"   loop" eval
1A5D55C 	9C 53 A0  1 
1A5D560 	 6 20 20 6C 6F 6F 70  0 
1A5D568 	D8 E5 A0  1 
s"   false" eval
1A5D56C 	9C 53 A0  1 
1A5D570 	 7 20 20 66 61 6C 73 65 
1A5D578 	 0  0  0  0 D8 E5 A0  1 
s"   close ;" eval
1A5D580 	9C 53 A0  1  9 20 20 63 
1A5D588 	6C 6F 73 65 20 3B  0  0 
1A5D590 	D8 E5 A0  1 
;
1A5D594 	58 46 A0  1 

OpenFirmware/dev/usb2/hcd/ehci/probe.fth_AL	13A0 1A5D598 purpose: USB hub probing code to support USB 1.1 devices downstream

hex

\ There are two properties to support 1.1 hubs and devices:
\      hub20-dev
\      hub20-port
\
\ hub20-dev   is an integer property containing the assigned-address of
\             a USB 2.0 hub.
\ hub20-port  is an integer property containing the downstream port# (based 1)
\             of a USB 2.0 hub if the device attached to it is a 1.1 device.
\
\ For example, if we have the following physical topology:
\     USB 2.0 hub:   port 1:  2.0 disk
\                    port 2:  1.1 hub       port 1: disk
\                                           port 2: disk
\                    port 3:  1.1 mouse
\                    port 4:  none
\
\ Then /usb/hub has the "hub20-dev" property.
\      /usb/hub/hub has the "hub20-port" property of value 2.
\      /usb/hub/mouse has the "hub20-port" property of value 3.
\
\ In order to correctly communicate with the 1.1 hub and all the devices behind
\ it, the /usb/hub hub20-dev value and the /usb/hub/hub hub20-port value are
\ used in the Transaction Descriptor (qTD).
\
\ Likewise, to correctly communicate with the mouse, the /usb/hub hub20-dev
\ value and the /usb/hub/mouse hub20-port value are used in the qTD.
: probehubfthe
1A5D598 	 0  0  0 70 72 6F 62 65 
1A5D5A0 	68 75 62 66 74 68 65 8C 
1A5D5A8 	 8 C2 A5  1 20 40 A0  1 
s" : ?set-hub20-port" eval  ( speed dev port -- )
1A5D5B0 	9C 53 A0  1 11 3A 20 3F 
1A5D5B8 	73 65 74 2D 68 75 62 32 
1A5D5C0 	30 2D 70 6F 72 74  0  0 
1A5D5C8 	D8 E5 A0  1 
 "    "" hub20-dev"" my-parent ihandle>phandle get-package-property 0=  if" eval  ( speed dev port value$ )
1A5D5CC 	9C 53 A0  1 
1A5D5D0 	45 20 20 20 22 20 68 75 
1A5D5D8 	62 32 30 2D 64 65 76 22 
1A5D5E0 	20 6D 79 2D 70 61 72 65 
1A5D5E8 	6E 74 20 69 68 61 6E 64 
1A5D5F0 	6C 65 3E 70 68 61 6E 64 
1A5D5F8 	6C 65 20 67 65 74 2D 70 
1A5D600 	61 63 6B 61 67 65 2D 70 
1A5D608 	72 6F 70 65 72 74 79 20 
1A5D610 	30 3D 20 20 69 66  0  0 
1A5D618 	D8 E5 A0  1 
s"       2drop" eval                                     ( speed dev port )
1A5D61C 	9C 53 A0  1 
1A5D620 	 B 20 20 20 20 20 20 32 
1A5D628 	64 72 6F 70  0  0  0  0 
1A5D630 	D8 E5 A0  1 
s"       nip swap speed-high <>  if" eval                ( port )
1A5D634 	9C 53 A0  1 
1A5D638 	20 20 20 20 20 20 20 6E 
1A5D640 	69 70 20 73 77 61 70 20 
1A5D648 	73 70 65 65 64 2D 68 69 
1A5D650 	67 68 20 3C 3E 20 20 69 
1A5D658 	66  0  0  0 D8 E5 A0  1 
 "          encode-int "" hub20-port"" property" eval      ( )
1A5D660 	9C 53 A0  1 2A 20 20 20 
1A5D668 	20 20 20 20 20 20 65 6E 
1A5D670 	63 6F 64 65 2D 69 6E 74 
1A5D678 	20 22 20 68 75 62 32 30 
1A5D680 	2D 70 6F 72 74 22 20 70 
1A5D688 	72 6F 70 65 72 74 79  0 
1A5D690 	D8 E5 A0  1 
s"       else" eval                                      ( speed )
1A5D694 	9C 53 A0  1 
1A5D698 	 A 20 20 20 20 20 20 65 
1A5D6A0 	6C 73 65  0 D8 E5 A0  1 
s"          drop" eval                                   ( )
1A5D6A8 	9C 53 A0  1  D 20 20 20 
1A5D6B0 	20 20 20 20 20 20 64 72 
1A5D6B8 	6F 70  0  0 D8 E5 A0  1 
s"       then" eval                                      ( )
1A5D6C0 	9C 53 A0  1  A 20 20 20 
1A5D6C8 	20 20 20 74 68 65 6E  0 
1A5D6D0 	D8 E5 A0  1 
s"    else" eval                                         ( speed dev port )
1A5D6D4 	9C 53 A0  1 
1A5D6D8 	 7 20 20 20 65 6C 73 65 
1A5D6E0 	 0  0  0  0 D8 E5 A0  1 
s"       3drop" eval                                     ( )
1A5D6E8 	9C 53 A0  1  B 20 20 20 
1A5D6F0 	20 20 20 33 64 72 6F 70 
1A5D6F8 	 0  0  0  0 D8 E5 A0  1 
s"    then ;" eval                                        ( )
1A5D700 	9C 53 A0  1  9 20 20 20 
1A5D708 	74 68 65 6E 20 3B  0  0 
1A5D710 	D8 E5 A0  1 

s" ' ?set-hub20-port to make-dev-property-hook" eval
1A5D714 	9C 53 A0  1 
1A5D718 	2B 27 20 3F 73 65 74 2D 
1A5D720 	68 75 62 32 30 2D 70 6F 
1A5D728 	72 74 20 74 6F 20 6D 61 
1A5D730 	6B 65 2D 64 65 76 2D 70 
1A5D738 	72 6F 70 65 72 74 79 2D 
1A5D740 	68 6F 6F 6B  0  0  0  0 
1A5D748 	D8 E5 A0  1 
;
1A5D74C 	58 46 A0  1 
headers

OpenFirmware/dev/usb2/hcd/ehci/probehub.fth_AL	1B8 1A5D750 true to stand-init-debug?

hex
\ stand-init-debug?  [if]
warning @  warning off 
: init
1A5D780 	 0  0  0 69 6E 69 74 84 
1A5D788 	84 DA A4  1 20 40 A0  1 
\ initial-heap add-memory
   init
1A5D790 	CC 65 A1  1 

\  cr0@ h# 9fff.ffff and cr0!	\ enable L1 and L2 caches
;
1A5D794 	58 46 A0  1 
warning !
\ [then]

: (.firmware)  ( -- )
1A5D798 	28 2E 66 69 72 6D 77 61 
1A5D7A0 	72 65 29 8B 8C D7 A5  1 
1A5D7A8 	20 40 A0  1 
   ." Open Firmware  "  .built  cr
1A5D7AC 	20 7C A0  1 
1A5D7B0 	 F 4F 70 65 6E 20 46 69 
1A5D7B8 	72 6D 77 61 72 65 20 20 
1A5D7C0 	 0  0  0  0 F4 B0 A2  1 
1A5D7C8 	80 6D A0  1 
   ." Copyright 1999 FirmWorks  All Rights Reserved" cr
1A5D7CC 	20 7C A0  1 
1A5D7D0 	2D 43 6F 70 79 72 69 67 
1A5D7D8 	68 74 20 31 39 39 39 20 
1A5D7E0 	46 69 72 6D 57 6F 72 6B 
1A5D7E8 	73 20 20 41 6C 6C 20 52 
1A5D7F0 	69 67 68 74 73 20 52 65 
1A5D7F8 	73 65 72 76 65 64  0  0 
1A5D800 	80 6D A0  1 
;
1A5D804 	58 46 A0  1 
' (.firmware) to .firmware


: probe-all  ( -- )
1A5D808 	 0  0 70 72 6F 62 65 2D 
1A5D810 	61 6C 6C 89 A8 D7 A5  1 
1A5D818 	20 40 A0  1 
   ." report-disk" HERE .H  cr   report-disk
1A5D81C 	20 7C A0  1 
1A5D820 	 B 72 65 70 6F 72 74 2D 
1A5D828 	64 69 73 6B  0  0  0  0 
1A5D830 	70 54 A0  1 10  E A1  1 
1A5D838 	80 6D A0  1 28 10 A4  1 
   ." probe-pci"  HERE .H cr   probe-pci
1A5D840 	20 7C A0  1  9 70 72 6F 
1A5D848 	62 65 2D 70 63 69  0  0 
1A5D850 	70 54 A0  1 10  E A1  1 
1A5D858 	80 6D A0  1 7C 84 A3  1 

;
1A5D860 	58 46 A0  1 

\ This reduces processor use when waiting for a key.  It helps
\ a lot when running on an emulator.
\ mmo : c1-idle  ( -- )  interrupts-enabled?  if  halt  then  ;
\ mmo ' c1-idle to stdin-idle

: startup  ( -- )
1A5D864 	73 74 61 72 
1A5D868 	74 75 70 87 18 D8 A5  1 
1A5D870 	20 40 A0  1 
   standalone?  0=  if  exit  then
1A5D874 	F4 DE A1  1 
1A5D878 	24 47 A0  1 DC 41 A0  1 
1A5D880 	 8  0  0  0 40 46 A0  1 
   ." calibrate-ms"  cr
1A5D888 	20 7C A0  1  C 63 61 6C 
1A5D890 	69 62 72 61 74 65 2D 6D 
1A5D898 	73  0  0  0 80 6D A0  1 
   calibrate-ms
1A5D8A0 	 4 E7 A3  1 

    ." nvramrc"  HERE .H cr
1A5D8A4 	20 7C A0  1 
1A5D8A8 	 7 6E 76 72 61 6D 72 63 
1A5D8B0 	 0  0  0  0 70 54 A0  1 
1A5D8B8 	10  E A1  1 80 6D A0  1 

      install-mux-io
1A5D8C0 	14 1F A4  1 

   auto-banner?  if
1A5D8C4 	F4 AD A2  1 
1A5D8C8 	DC 41 A0  1 40  0  0  0 
      " Probing" type  HERE .H  probe-all
1A5D8D0 	9C 53 A0  1  7 50 72 6F 
1A5D8D8 	62 69 6E 67  0  0  0  0 
1A5D8E0 	 4 6C A0  1 70 54 A0  1 
1A5D8E8 	10  E A1  1 18 D8 A5  1 
   ." install-mux-io"  cr
1A5D8F0 	20 7C A0  1  E 69 6E 73 
1A5D8F8 	74 61 6C 6C 2D 6D 75 78 
1A5D900 	2D 69 6F  0 80 6D A0  1 

      ?usb-keyboard
1A5D908 	F0 2A A4  1 
   then

   hex
1A5D90C 	C0 8D A0  1 
   warning on
1A5D910 	E4 9A A0  1 E0 4B A0  1 
   only forth also definitions
1A5D918 	88 C3 A0  1  8 C5 A0  1 
1A5D920 	C8 C1 A0  1 2C C4 A0  1 

   ." Installing alarms" cr
1A5D928 	20 7C A0  1 11 49 6E 73 
1A5D930 	74 61 6C 6C 69 6E 67 20 
1A5D938 	61 6C 61 72 6D 73  0  0 
1A5D940 	80 6D A0  1 
\ mmo   install-alarm

   #line off
1A5D944 	70 6D A0  1 
1A5D948 	F8 4B A0  1 

   ." Open Firmware demonstration version by FirmWorks (info@firmworks.com)" cr
1A5D94C 	20 7C A0  1 
1A5D950 	45 4F 70 65 6E 20 46 69 
1A5D958 	72 6D 77 61 72 65 20 64 
1A5D960 	65 6D 6F 6E 73 74 72 61 
1A5D968 	74 69 6F 6E 20 76 65 72 
1A5D970 	73 69 6F 6E 20 62 79 20 
1A5D978 	46 69 72 6D 57 6F 72 6B 
1A5D980 	73 20 28 69 6E 66 6F 40 
1A5D988 	66 69 72 6D 77 6F 72 6B 
1A5D990 	73 2E 63 6F 6D 29  0  0 
1A5D998 	80 6D A0  1 

s" c:autoexec.4" included
1A5D99C 	9C 53 A0  1 
1A5D9A0 	 C 63 3A 61 75 74 6F 65 
1A5D9A8 	78 65 63 2E 34  0  0  0 
1A5D9B0 	C8 E8 A0  1 
   quit
1A5D9B4 	FC D0 A0  1 
;
1A5D9B8 	58 46 A0  1 
\ : zz s" u:autoexec.4" included ;

alias crcgen drop  ( crc byte -- crc' )
1A5D9BC 	 0 63 72 63 
1A5D9C0 	67 65 6E A6 70 D8 A5  1 
1A5D9C8 	30 49 A0  1 

OpenFirmware/cpu/x86/pc/biosload/fw.fth_AL	24C 1A5D9CC HEE=1A5D9CC 
HEE=1A5D9CC 0 Saving fw.img ...--- Saving as uuu.elf - GRUB multiboot format
>
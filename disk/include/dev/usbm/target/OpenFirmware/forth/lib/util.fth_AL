
hex

alias (s (
1A10D3C 	 0 28 73 E2 
1A10D40 	34  D A1  1 A4 ED A0  1 

: >user#  ( acf -- user# )   >body @user#  ;
1A10D48 	 0 3E 75 73 65 72 23 86 
1A10D50 	44  D A1  1 20 40 A0  1 
1A10D58 	E4 59 A0  1 B0 74 A0  1 
1A10D60 	58 46 A0  1 
: 'user#  \ name  ( -- user# )
1A10D64 	 0 27 75 73 
1A10D68 	65 72 23 86 54  D A1  1 
1A10D70 	20 40 A0  1 
   '  ( acf-of-user-variable )   >user#
1A10D74 	F8 95 A0  1 
1A10D78 	54  D A1  1 
;
1A10D7C 	58 46 A0  1 
headers
: tr  ( token-bits -- adr )      \ Token relocate
1A10D80 	 0 74 72 82 70  D A1  1 
1A10D88 	20 40 A0  1 
\t16   tshift <<
   origin+
1A10D8C 	64 55 A0  1 
;
1A10D90 	58 46 A0  1 
: x  ( adr -- )  execute  ;             \ Convenience word
1A10D94 	 0  0 78 81 
1A10D98 	88  D A1  1 20 40 A0  1 
1A10DA0 	98 41 A0  1 58 46 A0  1 
: .cstr  ( adr -- )             \ Display C string
1A10DA8 	 0  0 2E 63 73 74 72 85 
1A10DB0 	9C  D A1  1 20 40 A0  1 
   begin  dup c@ dup  while
1A10DB8 	40 49 A0  1 C4 4C A0  1 
1A10DC0 	40 49 A0  1 DC 41 A0  1 
1A10DC8 	38  0  0  0 
      dup newline =  if  drop cr  else  emit  then
1A10DCC 	40 49 A0  1 
1A10DD0 	A8 71 A0  1 24 48 A0  1 
1A10DD8 	DC 41 A0  1 14  0  0  0 
1A10DE0 	30 49 A0  1 80 6D A0  1 
1A10DE8 	C8 41 A0  1  8  0  0  0 
1A10DF0 	2C 6C A0  1 
      1+
1A10DF4 	30 4B A0  1 
   repeat
1A10DF8 	C8 41 A0  1 BC FF FF FF 
   2drop
1A10E00 	AC 49 A0  1 
;
1A10E04 	58 46 A0  1 

: .h  ( n -- )   push-hex     .  pop-base  ;
1A10E08 	 0 2E 68 82 B4  D A1  1 
1A10E10 	20 40 A0  1 5C F4 A0  1 
1A10E18 	94 7A A0  1 9C F4 A0  1 
1A10E20 	58 46 A0  1 
: .x  ( u -- )   push-hex    u.  pop-base  ;
1A10E24 	 0 2E 78 82 
1A10E28 	10  E A1  1 20 40 A0  1 
1A10E30 	5C F4 A0  1 C8 77 A0  1 
1A10E38 	9C F4 A0  1 58 46 A0  1 
: .d  ( n -- )   push-decimal .  pop-base  ;
1A10E40 	 0 2E 64 82 2C  E A1  1 
1A10E48 	20 40 A0  1 48 F4 A0  1 
1A10E50 	94 7A A0  1 9C F4 A0  1 
1A10E58 	58 46 A0  1 

headerless
defer lo-segment-base	' origin  is  lo-segment-base
1A10E5C 	6C 6F 2D 73 
1A10E60 	65 67 6D 65 6E 74 2D 62 
1A10E68 	61 73 65 8F 48  E A1  1 
1A10E70 	5C 40 A0  1 40  3  0  0 
defer lo-segment-limit	' origin  is  lo-segment-limit
1A10E78 	 0  0  0 6C 6F 2D 73 65 
1A10E80 	67 6D 65 6E 74 2D 6C 69 
1A10E88 	6D 69 74 90 70  E A1  1 
1A10E90 	5C 40 A0  1 44  3  0  0 
defer hi-segment-base	' origin  is  hi-segment-base
1A10E98 	68 69 2D 73 65 67 6D 65 
1A10EA0 	6E 74 2D 62 61 73 65 8F 
1A10EA8 	90  E A1  1 5C 40 A0  1 
1A10EB0 	48  3  0  0 
defer hi-segment-limit	' here    is  hi-segment-limit
1A10EB4 	 0  0  0 68 
1A10EB8 	69 2D 73 65 67 6D 65 6E 
1A10EC0 	74 2D 6C 69 6D 69 74 90 
1A10EC8 	AC  E A1  1 5C 40 A0  1 
1A10ED0 	4C  3  0  0 

: dictionary-size  ( -- n )  here origin-  ;
1A10ED4 	64 69 63 74 
1A10ED8 	69 6F 6E 61 72 79 2D 73 
1A10EE0 	69 7A 65 8F CC  E A1  1 
1A10EE8 	20 40 A0  1 70 54 A0  1 
1A10EF0 	80 55 A0  1 58 46 A0  1 

headerless

: #!  ( -- )  [compile] \  ; immediate  \ For use with script files
1A10EF8 	 0 23 21 C2 E8  E A1  1 
1A10F00 	20 40 A0  1 74 8A A0  1 
1A10F08 	58 46 A0  1 
alias >is >data		\ Backwards compatibility
1A10F0C 	3E 69 73 A3 
1A10F10 	 0  F A1  1 6C C7 A0  1 

: strip-blanks ( adr,len -- adr',len' )  -leading -trailing  ;
1A10F18 	 0  0  0 73 74 72 69 70 
1A10F20 	2D 62 6C 61 6E 6B 73 8C 
1A10F28 	14  F A1  1 20 40 A0  1 
1A10F30 	2C 8C A0  1 84 8C A0  1 
1A10F38 	58 46 A0  1 
: optional-arg$  ( -- adr len )  0 parse  strip-blanks  ;
1A10F3C 	 0  0 6F 70 
1A10F40 	74 69 6F 6E 61 6C 2D 61 
1A10F48 	72 67 24 8D 2C  F A1  1 
1A10F50 	20 40 A0  1 70 6F A0  1 
1A10F58 	E4 85 A0  1 2C  F A1  1 
1A10F60 	58 46 A0  1 

headers

alias not invert
1A10F64 	6E 6F 74 A3 
1A10F68 	50  F A1  1 30 45 A0  1 
alias eval evaluate
1A10F70 	 0  0  0 65 76 61 6C A4 
1A10F78 	6C  F A1  1 D8 E5 A0  1 

: c?  ( adr -- )  c@  u.  ;
1A10F80 	 0 63 3F 82 7C  F A1  1 
1A10F88 	20 40 A0  1 C4 4C A0  1 
1A10F90 	C8 77 A0  1 58 46 A0  1 
: w?  ( adr -- )  w@  u.  ;
1A10F98 	 0 77 3F 82 88  F A1  1 
1A10FA0 	20 40 A0  1 94 4C A0  1 
1A10FA8 	C8 77 A0  1 58 46 A0  1 
: l?  ( adr -- )  l@  u.  ;
1A10FB0 	 0 6C 3F 82 A0  F A1  1 
1A10FB8 	20 40 A0  1 6C 4C A0  1 
1A10FC0 	C8 77 A0  1 58 46 A0  1 
64\ : x?  ( adr -- )  x@  u.  ;
: d?  ( adr -- )  d@ swap u. u.  ;
1A10FC8 	 0 64 3F 82 B8  F A1  1 
1A10FD0 	20 40 A0  1 20 4C A0  1 
1A10FD8 	68 49 A0  1 C8 77 A0  1 
1A10FE0 	C8 77 A0  1 58 46 A0  1 

\ : behavior  ( xt1 -- xt2 )  >body >user token@  ;

: showstack    ( -- )  ['] (.s  is status  ;
1A10FE8 	 0  0 73 68 6F 77 73 74 
1A10FF0 	61 63 6B 89 D0  F A1  1 
1A10FF8 	20 40 A0  1 60 53 A0  1 
1A11000 	DC 7B A0  1 98 40 A0  1 
1A11008 	38 A1 A0  1 58 46 A0  1 
: noshowstack  ( -- )  ['] noop is status  ;
1A11010 	6E 6F 73 68 6F 77 73 74 
1A11018 	61 63 6B 8B F8  F A1  1 
1A11020 	20 40 A0  1 60 53 A0  1 
1A11028 	64 4F A0  1 98 40 A0  1 
1A11030 	38 A1 A0  1 58 46 A0  1 

: (confirmed?)  ( adr len -- char )
1A11038 	 0  0  0 28 63 6F 6E 66 
1A11040 	69 72 6D 65 64 3F 29 8C 
1A11048 	20 10 A1  1 20 40 A0  1 
   type  ."  [y/n]? "  key dup emit cr  upc
1A11050 	 4 6C A0  1 20 7C A0  1 
1A11058 	 8 20 5B 79 2F 6E 5D 3F 
1A11060 	20  0  0  0 50 6C A0  1 
1A11068 	40 49 A0  1 2C 6C A0  1 
1A11070 	80 6D A0  1 D0 51 A0  1 
;
1A11078 	58 46 A0  1 
\ Default value is yes
: confirmed?  ( adr len -- yes? )  (confirmed?) [char] N  <>  ;
1A1107C 	 0 63 6F 6E 
1A11080 	66 69 72 6D 65 64 3F 8A 
1A11088 	4C 10 A1  1 20 40 A0  1 
1A11090 	4C 10 A1  1 58 41 A0  1 
1A11098 	4E  0  0  0 44 48 A0  1 
1A110A0 	58 46 A0  1 
\ Default value is no
: confirmedn?  ( adr len -- yes? )  (confirmed?) [char] Y  =  ;
1A110A4 	63 6F 6E 66 
1A110A8 	69 72 6D 65 64 6E 3F 8B 
1A110B0 	8C 10 A1  1 20 40 A0  1 
1A110B8 	4C 10 A1  1 58 41 A0  1 
1A110C0 	59  0  0  0 24 48 A0  1 
1A110C8 	58 46 A0  1 

: lowmask  ( #bits -- mask )  1 swap lshift 1-  ;
1A110CC 	6C 6F 77 6D 
1A110D0 	61 73 6B 87 B4 10 A1  1 
1A110D8 	20 40 A0  1 80 6F A0  1 
1A110E0 	68 49 A0  1 9C 44 A0  1 
1A110E8 	54 4B A0  1 58 46 A0  1 
: lowbits  ( n #bits -- bits )  lowmask and  ;
1A110F0 	6C 6F 77 62 69 74 73 87 
1A110F8 	D8 10 A1  1 20 40 A0  1 
1A11100 	D8 10 A1  1 5C 44 A0  1 
1A11108 	58 46 A0  1 
: bits  ( n bit# #bits -- bits )  -rot rshift  swap lowbits  ;
1A1110C 	 0  0  0 62 
1A11110 	69 74 73 84 FC 10 A1  1 
1A11118 	20 40 A0  1 94 49 A0  1 
1A11120 	B4 44 A0  1 68 49 A0  1 
1A11128 	FC 10 A1  1 58 46 A0  1 
: bit  ( n bit# -- )  1 bits  ;
1A11130 	62 69 74 83 18 11 A1  1 
1A11138 	20 40 A0  1 80 6F A0  1 
1A11140 	18 11 A1  1 58 46 A0  1 

: kib  ( n -- nkib )  d# 10 lshift  ;  \ Convert to kilobytes
1A11148 	6B 69 62 83 38 11 A1  1 
1A11150 	20 40 A0  1 58 41 A0  1 
1A11158 	 A  0  0  0 9C 44 A0  1 
1A11160 	58 46 A0  1 
: mib  ( n -- nmib )  d# 20 lshift  ;  \ Convert to megabytes
1A11164 	6D 69 62 83 
1A11168 	50 11 A1  1 20 40 A0  1 
1A11170 	58 41 A0  1 14  0  0  0 
1A11178 	9C 44 A0  1 58 46 A0  1 

: log2  ( n -- log2-of-n )
1A11180 	 0  0  0 6C 6F 67 32 84 
1A11188 	6C 11 A1  1 20 40 A0  1 
   0  begin        ( n log )
1A11190 	70 6F A0  1 
      swap  2/     ( log n' )
1A11194 	68 49 A0  1 
1A11198 	78 4B A0  1 
   ?dup  while     ( log n' )
1A1119C 	B4 70 A0  1 
1A111A0 	DC 41 A0  1 14  0  0  0 
      swap 1+      ( n' log' )
1A111A8 	68 49 A0  1 30 4B A0  1 
   repeat          ( log )
1A111B0 	C8 41 A0  1 E0 FF FF FF 
;
1A111B8 	58 46 A0  1 

: many   ( -- )   key? 0=  if  0 >in !  then  ;
1A111BC 	 0  0  0 6D 
1A111C0 	61 6E 79 84 8C 11 A1  1 
1A111C8 	20 40 A0  1 64 6C A0  1 
1A111D0 	24 47 A0  1 DC 41 A0  1 
1A111D8 	10  0  0  0 70 6F A0  1 
1A111E0 	28 85 A0  1 54 4D A0  1 
1A111E8 	58 46 A0  1 

\ Display the bits in the number "x" according to the format string adr,len
\ The characters in the format string correspond to the bits in "x".
\ The last character in the string corresponds to the least-significant
\ bit in "x" (i.e. the bit whose binary weight is "1", the second-from-
\ last character corresponds to the "x" bit whose binary weight is "2",
\ and so on.  If there are fewer characters in the string than the number
\ of bits in a cell, the excess high-order bits in "x" are ignored.
\
\ The characters in the string are processed from left to right (i.e.
\ starting at the beginning of the string).  Each character in the string
\ is interpreted as follows:

\ If the character is "~":
\	The corresponding bit in "x" is ignored and nothing is displayed
\
\ If the character is alphabetic:
\	If the corresponding bit in "x" is clear (i.e. 0), the character is
\	displayed as-is.  If the bit is set (i.e. 1), the character is
\	displayed with its case inverted (upper-case changed to lower case,
\	and vice versa).
\
\ Otherwise:
\	The character is displayed as-is.

: show-bits  ( x adr len -- )
1A111EC 	 0  0 73 68 
1A111F0 	6F 77 2D 62 69 74 73 89 
1A111F8 	C8 11 A1  1 20 40 A0  1 
   1-  0  swap  do             ( mask adr )
1A11200 	54 4B A0  1 70 6F A0  1 
1A11208 	68 49 A0  1 88 42 A0  1 
1A11210 	8C  0  0  0 
      2dup c@                  ( mask adr mask char )
1A11214 	C0 49 A0  1 
1A11218 	C4 4C A0  1 
      dup [char] ~  =  if      ( mask adr mask char )
1A1121C 	40 49 A0  1 
1A11220 	58 41 A0  1 7E  0  0  0 
1A11228 	24 48 A0  1 DC 41 A0  1 
1A11230 	10  0  0  0 
         2drop                 ( mask adr )
1A11234 	AC 49 A0  1 
      else                     ( mask adr mask char )
1A11238 	C8 41 A0  1 4C  0  0  0 
         swap  1 i lshift and  ( mask adr char bit-set? )
1A11240 	68 49 A0  1 80 6F A0  1 
1A11248 	B4 42 A0  1 9C 44 A0  1 
1A11250 	5C 44 A0  1 
         if  dup [char] a <  if  lcc  else  upc  then  then
1A11254 	DC 41 A0  1 
1A11258 	2C  0  0  0 40 49 A0  1 
1A11260 	58 41 A0  1 61  0  0  0 
1A11268 	E4 47 A0  1 DC 41 A0  1 
1A11270 	10  0  0  0 F0 51 A0  1 
1A11278 	C8 41 A0  1  8  0  0  0 
1A11280 	D0 51 A0  1 
	 emit   ( mask adr )
1A11284 	2C 6C A0  1 
      then                     ( mask adr )
      1+                       ( mask adr' )
1A11288 	30 4B A0  1 
   -1 +loop                    ( mask adr )
1A1128C 	58 41 A0  1 
1A11290 	FF FF FF FF 1C 42 A0  1 
1A11298 	7C FF FF FF 
   2drop
1A1129C 	AC 49 A0  1 
;
1A112A0 	58 46 A0  1 

: .buffers ( -- )
1A112A4 	 0  0  0 2E 
1A112A8 	62 75 66 66 65 72 73 88 
1A112B0 	FC 11 A1  1 20 40 A0  1 
   buffer-link                    ( next-buffer-word )
1A112B8 	D0 A8 A0  1 
   begin  another-link?  while    ( acf )
1A112BC 	90 59 A0  1 
1A112C0 	DC 41 A0  1 58  0  0  0 
      dup .name                   ( acf )
1A112C8 	40 49 A0  1 C8 9A A0  1 
      dup >body dup >user @       ( acf apf addr )
1A112D0 	40 49 A0  1 E4 59 A0  1 
1A112D8 	40 49 A0  1 C8 74 A0  1 
1A112E0 	5C 4C A0  1 
      .x  /user# + @ .x  cr       ( acf )
1A112E4 	2C  E A1  1 
1A112E8 	40 5A A0  1  4 45 A0  1 
1A112F0 	5C 4C A0  1 2C  E A1  1 
1A112F8 	80 6D A0  1 
      exit?  if  drop exit  then  ( acf )
1A112FC 	34  D A1  1 
1A11300 	DC 41 A0  1  C  0  0  0 
1A11308 	30 49 A0  1 40 46 A0  1 
      >buffer-link                ( prev-buffer:-acf )
1A11310 	F4 A9 A0  1 
   repeat                         (  )
1A11314 	C8 41 A0  1 
1A11318 	A4 FF FF FF 
;
1A1131C 	58 46 A0  1 
defer showaddr  ( adr -- )	\ For disassemblers
1A11320 	 0  0  0 73 68 6F 77 61 
1A11328 	64 64 72 88 B4 12 A1  1 
1A11330 	5C 40 A0  1 50  3  0  0 
' u. is showaddr
\ : ux.  ( adr -- )  base @ >r  hex  (u.) type  r> base !  ;
\ ' ux. is showaddr

\ Integer division which rounds to nearest instead of truncating
: rounded-/  ( dividend divisor -- rounded-result )
1A11338 	 0  0 72 6F 75 6E 64 65 
1A11340 	64 2D 2F 89 30 13 A1  1 
1A11348 	20 40 A0  1 
   swap 2*  swap /  ( result*2 )
1A1134C 	68 49 A0  1 
1A11350 	A0 4B A0  1 68 49 A0  1 
1A11358 	98 5F A0  1 
   dup 1 and +      \ add 1 to the result if it is odd
1A1135C 	40 49 A0  1 
1A11360 	80 6F A0  1 5C 44 A0  1 
1A11368 	 4 45 A0  1 
   2/               ( rounded-result )
1A1136C 	78 4B A0  1 
;
1A11370 	58 46 A0  1 


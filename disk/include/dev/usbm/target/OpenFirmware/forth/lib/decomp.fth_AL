
\ The decompiler.
\ This program is based on the F83 decompiler by Perry and Laxen,
\ but it has been heavily modified:
\   Structured decompilation of conditionals
\   Largely machine independent
\   Prints the name of the definer for child words instead of the
\     definer's DOES> clause.
\   "Smart" decompilation of literals.

\ A Forth decompiler is a utility program that translates
\ executable forth code back into source code.  For many compiled languages,
\ decompilation is very hard or impossible.  Decompilation of threaded
\ code is relatively easy.
\ It was written with modifiability in mind, so if you add your
\ own special compiling words, it will be easy to change the
\ decompiler to include them.  This code is implementation
\ dependant, and will not necessarily work on other Forth system.
\ To invoke the decompiler, use the word SEE <name> where <name> is the
\ name of a Forth word.  Alternatively,  (SEE) will decompile the word
\ whose acf is on the stack.

: (in-dictionary?)  ( adr -- flag )  origin here within  ;
1A11F94 	 0  0  0 28 
1A11F98 	69 6E 2D 64 69 63 74 69 
1A11FA0 	6F 6E 61 72 79 3F 29 90 
1A11FA8 	64 1F A1  1 20 40 A0  1 
1A11FB0 	50 55 A0  1 70 54 A0  1 
1A11FB8 	 8 71 A0  1 58 46 A0  1 
\ defer in-dictionary?
' (in-dictionary?) is in-dictionary?

: probably-cfa?  ( possible-acf -- flag )
1A11FC0 	 0  0 70 72 6F 62 61 62 
1A11FC8 	6C 79 2D 63 66 61 3F 8D 
1A11FD0 	AC 1F A1  1 20 40 A0  1 
   dup dup acf-aligned =  over in-dictionary?  and  if
1A11FD8 	40 49 A0  1 40 49 A0  1 
1A11FE0 	 C 5D A0  1 24 48 A0  1 
1A11FE8 	54 49 A0  1 24 CF A0  1 
1A11FF0 	5C 44 A0  1 DC 41 A0  1 
1A11FF8 	10  0  0  0 
      colon-cf?
1A11FFC 	9C 5B A0  1 
   else
1A12000 	C8 41 A0  1  C  0  0  0 
      drop false
1A12008 	30 49 A0  1 18 70 A0  1 
   then
;
1A12010 	58 46 A0  1 

\ Given an ip, scan backwards until you find the acf.  This assumes
\ that the ip is within a colon definition, and it is not absolutely
\ guaranteed to work, but in practice it usually does.

: find-cfa  ( ip -- acf )
1A12014 	 0  0  0 66 
1A12018 	69 6E 64 2D 63 66 61 88 
1A12020 	D4 1F A1  1 20 40 A0  1 
   begin
      dup in-dictionary?  0=  if  drop ['] lose  exit  then
1A12028 	40 49 A0  1 24 CF A0  1 
1A12030 	24 47 A0  1 DC 41 A0  1 
1A12038 	14  0  0  0 30 49 A0  1 
1A12040 	60 53 A0  1 90 9B A0  1 
1A12048 	40 46 A0  1 
      #talign -  dup  probably-cfa?
1A1204C 	68 5A A0  1 
1A12050 	18 45 A0  1 40 49 A0  1 
1A12058 	D4 1F A1  1 
   until
1A1205C 	DC 41 A0  1 
1A12060 	C8 FF FF FF 
;
1A12064 	58 46 A0  1 

\needs iscreate  create iscreate
1A12068 	 0  0  0 69 73 63 72 65 
1A12070 	61 74 65 88 24 20 A1  1 
1A12078 	30 40 A0  1 
\needs (wlit)    create (wlit)
1A1207C 	 0 28 77 6C 
1A12080 	69 74 29 86 78 20 A1  1 
1A12088 	30 40 A0  1 

start-module
decimal

only forth also hidden also forth definitions
defer (see)
1A1208C 	 0  0 28 73 
1A12090 	65 65 29 85 88 20 A1  1 
1A12098 	5C 40 A0  1 64  3  0  0 

hidden definitions
d# 300 2* /n* constant /positions
1A120A0 	 0 2F 70 6F 73 69 74 69 
1A120A8 	6F 6E 73 8A A0 1C A1  1 
1A120B0 	68 40 A0  1 60  9  0  0 
/positions buffer: positions
1A120B8 	 0  0 70 6F 73 69 74 69 
1A120C0 	6F 6E 73 89 B0 20 A1  1 
1A120C8 	B4 A9 A0  1 68  3  0  0 
1A120D0 	60  9  0  0 24 FE A0  1 
0 value end-positions
1A120D8 	 0  0 65 6E 64 2D 70 6F 
1A120E0 	73 69 74 69 6F 6E 73 8D 
1A120E8 	C8 20 A1  1 50 40 A0  1 
1A120F0 	6C  3  0  0 
\ 0 value line-after-;

: init-positions  ( -- )  positions is end-positions  ;
1A120F4 	 0 69 6E 69 
1A120F8 	74 2D 70 6F 73 69 74 69 
1A12100 	6F 6E 73 8E EC 20 A1  1 
1A12108 	20 40 A0  1 C8 20 A1  1 
1A12110 	B8 40 A0  1 EC 20 A1  1 
1A12118 	58 46 A0  1 
: find-position  ( ip -- true | adr false )
1A1211C 	 0  0 66 69 
1A12120 	6E 64 2D 70 6F 73 69 74 
1A12128 	69 6F 6E 8D  8 21 A1  1 
1A12130 	20 40 A0  1 
   end-positions positions  ?do   ( ip )
1A12134 	EC 20 A1  1 
1A12138 	C8 20 A1  1 50 42 A0  1 
1A12140 	44  0  0  0 
      i 2@ nip                    ( ip that-ip )
1A12144 	B4 42 A0  1 
1A12148 	CC 4D A0  1 FC 46 A0  1 
      over =  if                  ( ip )
1A12150 	54 49 A0  1 24 48 A0  1 
1A12158 	DC 41 A0  1 18  0  0  0 
         drop i false             ( adr false )
1A12160 	30 49 A0  1 B4 42 A0  1 
1A12168 	18 70 A0  1 
         unloop exit              ( adr false -- )
1A1216C 	3C 42 A0  1 
1A12170 	40 46 A0  1 
      then                        ( ip )
   2 /n* +loop                    ( ip )
1A12174 	90 6F A0  1 
1A12178 	98 51 A0  1 1C 42 A0  1 
1A12180 	C4 FF FF FF 
   drop true                      ( true )
1A12184 	30 49 A0  1 
1A12188 	 4 70 A0  1 
;
1A1218C 	58 46 A0  1 
0 value decompiler-ip
1A12190 	 0  0 64 65 63 6F 6D 70 
1A12198 	69 6C 65 72 2D 69 70 8D 
1A121A0 	30 21 A1  1 50 40 A0  1 
1A121A8 	70  3  0  0 
: add-position  ( ip -- )
1A121AC 	 0  0  0 61 
1A121B0 	64 64 2D 70 6F 73 69 74 
1A121B8 	69 6F 6E 8C A4 21 A1  1 
1A121C0 	20 40 A0  1 
   decompiler-ip find-position  if                 ( )
1A121C4 	A4 21 A1  1 
1A121C8 	30 21 A1  1 DC 41 A0  1 
1A121D0 	58  0  0  0 
      end-positions  positions /positions +  >=    ( flag )
1A121D4 	EC 20 A1  1 
1A121D8 	C8 20 A1  1 B0 20 A1  1 
1A121E0 	 4 45 A0  1 EC 48 A0  1 
      abort" Decompiler position table overflow"   ( )
1A121E8 	 8 81 A0  1 22 44 65 63 
1A121F0 	6F 6D 70 69 6C 65 72 20 
1A121F8 	70 6F 73 69 74 69 6F 6E 
1A12200 	20 74 61 62 6C 65 20 6F 
1A12208 	76 65 72 66 6C 6F 77  0 
      end-positions  dup 2 na+  is end-positions   ( adr )
1A12210 	EC 20 A1  1 40 49 A0  1 
1A12218 	90 6F A0  1 48 50 A0  1 
1A12220 	B8 40 A0  1 EC 20 A1  1 
   then                                            ( adr )
   #out @ #line @ wljoin  decompiler-ip  rot 2!    ( )
1A12228 	5C 6D A0  1 5C 4C A0  1 
1A12230 	70 6D A0  1 5C 4C A0  1 
1A12238 	D4 4F A0  1 A4 21 A1  1 
1A12240 	7C 49 A0  1 E4 4D A0  1 
;
1A12248 	58 46 A0  1 
: ip>position  ( ip -- true | #out #line false )
1A1224C 	69 70 3E 70 
1A12250 	6F 73 69 74 69 6F 6E 8B 
1A12258 	C0 21 A1  1 20 40 A0  1 
   find-position  if    ( )
1A12260 	30 21 A1  1 DC 41 A0  1 
1A12268 	10  0  0  0 
      true              ( true )
1A1226C 	 4 70 A0  1 
   else                 ( adr )
1A12270 	C8 41 A0  1 14  0  0  0 
      2@ drop lwsplit   ( #out #line )
1A12278 	CC 4D A0  1 30 49 A0  1 
1A12280 	A0 4F A0  1 
      false             ( #out #line false )
1A12284 	18 70 A0  1 
   then                 ( true | #out #line false )
;
1A12288 	58 46 A0  1 
: ip-set-cursor  ( ip -- )
1A1228C 	 0  0 69 70 
1A12290 	2D 73 65 74 2D 63 75 72 
1A12298 	73 6F 72 8D 5C 22 A1  1 
1A122A0 	20 40 A0  1 
   ip>position 0=  if  at-xy  then
1A122A4 	5C 22 A1  1 
1A122A8 	24 47 A0  1 DC 41 A0  1 
1A122B0 	 8  0  0  0 40 F8 A0  1 
;
1A122B8 	58 46 A0  1 

headers
defer indent
1A122BC 	 0 69 6E 64 
1A122C0 	65 6E 74 86 A0 22 A1  1 
1A122C8 	5C 40 A0  1 74  3  0  0 
: (indent)  ( -- )  lmargin @ #out @ - 0 max spaces  ;
1A122D0 	 0  0  0 28 69 6E 64 65 
1A122D8 	6E 74 29 88 C8 22 A1  1 
1A122E0 	20 40 A0  1 80 13 A1  1 
1A122E8 	5C 4C A0  1 5C 6D A0  1 
1A122F0 	5C 4C A0  1 18 45 A0  1 
1A122F8 	70 6F A0  1 9C 4A A0  1 
1A12300 	E8 71 A0  1 58 46 A0  1 
' (indent) is indent
headerless

: +indent  ( -- )   3 lmargin +!  cr  ;
1A12308 	2B 69 6E 64 65 6E 74 87 
1A12310 	E0 22 A1  1 20 40 A0  1 
1A12318 	A0 6F A0  1 80 13 A1  1 
1A12320 	 C 4C A0  1 80 6D A0  1 
1A12328 	58 46 A0  1 
: -indent  ( -- )  ??cr -3 lmargin +!  ;
1A1232C 	2D 69 6E 64 
1A12330 	65 6E 74 87 14 23 A1  1 
1A12338 	20 40 A0  1  0 A1 A0  1 
1A12340 	58 41 A0  1 FD FF FF FF 
1A12348 	80 13 A1  1  C 4C A0  1 
1A12350 	58 46 A0  1 
\ : <indent  ( -- )  ??cr -3 lmargin +!  indent  3 lmargin +!   ;

headerless
\ Like ." but goes to a new line if needed.
: cr".  ( adr len -- )
1A12354 	 0  0  0 63 
1A12358 	72 22 2E 84 38 23 A1  1 
1A12360 	20 40 A0  1 
   dup ?line  indent            ( adr len )
1A12364 	40 49 A0  1 
1A12368 	A8 13 A1  1 C8 22 A1  1 
   add-position                 ( adr len )
1A12370 	C0 21 A1  1 
   magenta-letters type cancel  ( )
1A12374 	14 FA A0  1 
1A12378 	 4 6C A0  1 BC F7 A0  1 
;
1A12380 	58 46 A0  1 
: .."   ( -- )  [compile] " compile cr".  ; immediate
1A12384 	2E 2E 22 C3 
1A12388 	60 23 A1  1 20 40 A0  1 
1A12390 	5C 8A A0  1 8C 75 A0  1 
1A12398 	60 23 A1  1 58 46 A0  1 

\ Positional case defining word
\ Subscripts start from 0
: out   ( # apf -- )  \ report out of range error
1A123A0 	6F 75 74 83 8C 23 A1  1 
1A123A8 	20 40 A0  1 
   cr  ." subscript out of range on "  dup body> .name
1A123AC 	80 6D A0  1 
1A123B0 	20 7C A0  1 1A 73 75 62 
1A123B8 	73 63 72 69 70 74 20 6F 
1A123C0 	75 74 20 6F 66 20 72 61 
1A123C8 	6E 67 65 20 6F 6E 20  0 
1A123D0 	40 49 A0  1 C8 59 A0  1 
1A123D8 	C8 9A A0  1 
   ."    max is " ?   ."    tried " .  quit
1A123DC 	20 7C A0  1 
1A123E0 	 A 20 20 20 6D 61 78 20 
1A123E8 	69 73 20  0 C4 7B A0  1 
1A123F0 	20 7C A0  1  9 20 20 20 
1A123F8 	74 72 69 65 64 20  0  0 
1A12400 	94 7A A0  1 FC D0 A0  1 
;
1A12408 	58 46 A0  1 
: map  ( # apf -- a ) \ convert subscript # to address a
1A1240C 	6D 61 70 83 
1A12410 	A8 23 A1  1 20 40 A0  1 
   2dup @  u<  if  na1+ swap na+   else   out  then
1A12418 	C0 49 A0  1 5C 4C A0  1 
1A12420 	A8 48 A0  1 DC 41 A0  1 
1A12428 	18  0  0  0 CC 50 A0  1 
1A12430 	68 49 A0  1 48 50 A0  1 
1A12438 	C8 41 A0  1  8  0  0  0 
1A12440 	A8 23 A1  1 
;
1A12444 	58 46 A0  1 
: maptoken  ( # apf -- a ) \ convert subscript # to address a
1A12448 	 0  0  0 6D 61 70 74 6F 
1A12450 	6B 65 6E 88 14 24 A1  1 
1A12458 	20 40 A0  1 
   2dup @  u<  if  na1+ swap /token * +   else   out  then
1A1245C 	C0 49 A0  1 
1A12460 	5C 4C A0  1 A8 48 A0  1 
1A12468 	DC 41 A0  1 20  0  0  0 
1A12470 	CC 50 A0  1 68 49 A0  1 
1A12478 	B4 46 A0  1 1C 5F A0  1 
1A12480 	 4 45 A0  1 C8 41 A0  1 
1A12488 	 8  0  0  0 A8 23 A1  1 
;
1A12490 	58 46 A0  1 

forth definitions

headers
: case:   (s n --  ) \ define positional case defining word
1A12494 	 0  0 63 61 
1A12498 	73 65 3A 85 98 20 A1  1 
1A124A0 	20 40 A0  1 
   create ,  hide    ]
1A124A4 	A8 A2 A0  1 
1A124A8 	98 55 A0  1 54 A5 A0  1 
1A124B0 	A0 6D A0  1 
   does>   ( #subscript -- ) \ executes #'th word
1A124B4 	50 A3 A0  1 
1A124B8 	90 90 90 E8 BC 1B FF FF 
      maptoken  token@  execute
1A124C0 	58 24 A1  1  C 54 A0  1 
1A124C8 	98 41 A0  1 
;
1A124CC 	58 46 A0  1 

doestarget @ to do_case:

: tassociative:
1A124D0 	 0  0 74 61 73 73 6F 63 
1A124D8 	69 61 74 69 76 65 3A 8D 
1A124E0 	A0 24 A1  1 20 40 A0  1 
   create ,
1A124E8 	A8 A2 A0  1 98 55 A0  1 
   does>         (s n -- index )
1A124F0 	50 A3 A0  1 90 90 90 E8 
1A124F8 	80 1B FF FF 
      dup @              ( n pfa cnt )
1A124FC 	40 49 A0  1 
1A12500 	5C 4C A0  1 
      dup >r -rot na1+        ( cnt n table-addr )
1A12504 	40 49 A0  1 
1A12508 	BC 45 A0  1 94 49 A0  1 
1A12510 	CC 50 A0  1 
      r> 0  do                ( cnt n table-addr )
1A12514 	D0 45 A0  1 
1A12518 	70 6F A0  1 88 42 A0  1 
1A12520 	3C  0  0  0 
         2dup token@ =  if    ( cnt n pfa' )
1A12524 	C0 49 A0  1 
1A12528 	 C 54 A0  1 24 48 A0  1 
1A12530 	DC 41 A0  1 1C  0  0  0 
            2drop drop   i 0 0   leave
1A12538 	AC 49 A0  1 30 49 A0  1 
1A12540 	B4 42 A0  1 70 6F A0  1 
1A12548 	70 6F A0  1 18 43 A0  1 
         then
         \ clear stack and return index that matched
         ta1+
1A12550 	FC 50 A0  1 
      loop
1A12554 	F8 41 A0  1 
1A12558 	CC FF FF FF 
      2drop
1A1255C 	AC 49 A0  1 
;
1A12560 	58 46 A0  1 

hidden definitions
: #entries  ( associative-acf -- n )  >body @  ;
1A12564 	 0  0  0 23 
1A12568 	65 6E 74 72 69 65 73 88 
1A12570 	58 24 A1  1 20 40 A0  1 
1A12578 	E4 59 A0  1 5C 4C A0  1 
1A12580 	58 46 A0  1 

: nulldis  ( apf -- )  drop ." <no disassembler>"  ;
1A12584 	6E 75 6C 6C 
1A12588 	64 69 73 87 74 25 A1  1 
1A12590 	20 40 A0  1 30 49 A0  1 
1A12598 	20 7C A0  1 11 3C 6E 6F 
1A125A0 	20 64 69 73 61 73 73 65 
1A125A8 	6D 62 6C 65 72 3E  0  0 
1A125B0 	58 46 A0  1 
defer disassemble  ' nulldis is disassemble
1A125B4 	64 69 73 61 
1A125B8 	73 73 65 6D 62 6C 65 8B 
1A125C0 	90 25 A1  1 5C 40 A0  1 
1A125C8 	78  3  0  0 

headerless

\ Breaks is a list of places in a colon definition where control
\ is transferred without there being a branch nearby.
\ Each entry has two items: the address and a number which indicates
\ what kind of branch target it is (either a begin, for backward branches,
\ a then, for forward branches, or an exit.

d# 40 2* /n* constant /breaks
1A125CC 	2F 62 72 65 
1A125D0 	61 6B 73 87 C4 25 A1  1 
1A125D8 	68 40 A0  1 40  1  0  0 
/breaks buffer: breaks
1A125E0 	 0 62 72 65 61 6B 73 86 
1A125E8 	D8 25 A1  1 B4 A9 A0  1 
1A125F0 	7C  3  0  0 40  1  0  0 
1A125F8 	C8 20 A1  1 
variable end-breaks
1A125FC 	 0 65 6E 64 
1A12600 	2D 62 72 65 61 6B 73 8A 
1A12608 	EC 25 A1  1 48 40 A0  1 
1A12610 	80  3  0  0 

variable break-type  variable break-addr   variable where-break
1A12614 	 0 62 72 65 
1A12618 	61 6B 2D 74 79 70 65 8A 
1A12620 	 C 26 A1  1 48 40 A0  1 
1A12628 	84  3  0  0  0 62 72 65 
1A12630 	61 6B 2D 61 64 64 72 8A 
1A12638 	24 26 A1  1 48 40 A0  1 
1A12640 	88  3  0  0 77 68 65 72 
1A12648 	65 2D 62 72 65 61 6B 8B 
1A12650 	3C 26 A1  1 48 40 A0  1 
1A12658 	8C  3  0  0 
: next-break  ( -- break-address break-type )
1A1265C 	 0 6E 65 78 
1A12660 	74 2D 62 72 65 61 6B 8A 
1A12668 	54 26 A1  1 20 40 A0  1 
   -1 break-addr !   ( prime stack)
1A12670 	58 41 A0  1 FF FF FF FF 
1A12678 	3C 26 A1  1 54 4D A0  1 
   end-breaks @  breaks  ?do
1A12680 	 C 26 A1  1 5C 4C A0  1 
1A12688 	EC 25 A1  1 50 42 A0  1 
1A12690 	5C  0  0  0 
      i  2@ over   break-addr @ u<  if
1A12694 	B4 42 A0  1 
1A12698 	CC 4D A0  1 54 49 A0  1 
1A126A0 	3C 26 A1  1 5C 4C A0  1 
1A126A8 	A8 48 A0  1 DC 41 A0  1 
1A126B0 	28  0  0  0 
         break-type !  break-addr !  i where-break !
1A126B4 	24 26 A1  1 
1A126B8 	54 4D A0  1 3C 26 A1  1 
1A126C0 	54 4D A0  1 B4 42 A0  1 
1A126C8 	54 26 A1  1 54 4D A0  1 
      else
1A126D0 	C8 41 A0  1  8  0  0  0 
         2drop
1A126D8 	AC 49 A0  1 
      then
   /n 2* +loop
1A126DC 	40 51 A0  1 
1A126E0 	A0 4B A0  1 1C 42 A0  1 
1A126E8 	AC FF FF FF 
   break-addr @  -1  <>  if  -1 -1 where-break @ 2!  then
1A126EC 	3C 26 A1  1 
1A126F0 	5C 4C A0  1 58 41 A0  1 
1A126F8 	FF FF FF FF 44 48 A0  1 
1A12700 	DC 41 A0  1 20  0  0  0 
1A12708 	58 41 A0  1 FF FF FF FF 
1A12710 	58 41 A0  1 FF FF FF FF 
1A12718 	54 26 A1  1 5C 4C A0  1 
1A12720 	E4 4D A0  1 
;
1A12724 	58 46 A0  1 
: forward-branch?  ( ip-of-branch-token -- f )
1A12728 	66 6F 72 77 61 72 64 2D 
1A12730 	62 72 61 6E 63 68 3F 8F 
1A12738 	6C 26 A1  1 20 40 A0  1 
   dup >target u<
1A12740 	40 49 A0  1 58 58 A0  1 
1A12748 	A8 48 A0  1 
;
1A1274C 	58 46 A0  1 

\ Bare-if? checks to see if the target address on the stack was
\ produced by an IF with no ELSE.  This is used to decide whether
\ to put a THEN at that target address.  If the conditional branch
\ to this target is part of an IF ELSE THEN, the target address
\ for the THEN is found from the ELSE.  If the conditional branch
\ to this target was produced by a WHILE, there is no THEN.
: bare-if? ( ip-of-branch-target -- f )
1A12750 	 0  0  0 62 61 72 65 2D 
1A12758 	69 66 3F 88 3C 27 A1  1 
1A12760 	20 40 A0  1 
   /branch - /token - dup token@  ( ip' possible-branch-acf )
1A12764 	FC 57 A0  1 
1A12768 	18 45 A0  1 B4 46 A0  1 
1A12770 	18 45 A0  1 40 49 A0  1 
1A12778 	 C 54 A0  1 
   dup ['] branch  =    \ unconditional branch means else or repeat
1A1277C 	40 49 A0  1 
1A12780 	60 53 A0  1 C8 41 A0  1 
1A12788 	24 48 A0  1 
   if  drop drop false exit then  ( ip' acf )
1A1278C 	DC 41 A0  1 
1A12790 	14  0  0  0 30 49 A0  1 
1A12798 	30 49 A0  1 18 70 A0  1 
1A127A0 	40 46 A0  1 
   ['] ?branch =        \ cond. forw. branch is for an IF THEN with null body
1A127A4 	60 53 A0  1 
1A127A8 	DC 41 A0  1 24 48 A0  1 
   if   forward-branch?  else  drop true  then
1A127B0 	DC 41 A0  1 10  0  0  0 
1A127B8 	3C 27 A1  1 C8 41 A0  1 
1A127C0 	 C  0  0  0 30 49 A0  1 
1A127C8 	 4 70 A0  1 
;
1A127CC 	58 46 A0  1 

\ While? decides if the conditional branch at the current ip is
\ for a WHILE as opposed to an IF.  It finds out by looking at the
\ target for the conditional branch;  if there is a backward branch
\ just before the target, it is a WHILE.
: while?  ( ip-of-?branch -- f )
1A127D0 	 0 77 68 69 6C 65 3F 86 
1A127D8 	60 27 A1  1 20 40 A0  1 
  >target  /branch - /token - dup token@  ( ip' possible-branch-acf )
1A127E0 	58 58 A0  1 FC 57 A0  1 
1A127E8 	18 45 A0  1 B4 46 A0  1 
1A127F0 	18 45 A0  1 40 49 A0  1 
1A127F8 	 C 54 A0  1 
  ['] branch =  if          \ looking for the uncond. branch from the REPEAT
1A127FC 	60 53 A0  1 
1A12800 	C8 41 A0  1 24 48 A0  1 
1A12808 	DC 41 A0  1 14  0  0  0 
     forward-branch? 0=     \ if the branch is forward, it's an IF .. ELSE
1A12810 	3C 27 A1  1 24 47 A0  1 
  else
1A12818 	C8 41 A0  1  C  0  0  0 
     drop false
1A12820 	30 49 A0  1 18 70 A0  1 
  then

;
1A12828 	58 46 A0  1 

: .begin  ( -- )  .." begin " +indent  ;
1A1282C 	 0 2E 62 65 
1A12830 	67 69 6E 86 DC 27 A1  1 
1A12838 	20 40 A0  1 9C 53 A0  1 
1A12840 	 6 62 65 67 69 6E 20  0 
1A12848 	60 23 A1  1 14 23 A1  1 
1A12850 	58 46 A0  1 
: .then   ( -- )  -indent .." then"  cr  ;
1A12854 	 0  0 2E 74 
1A12858 	68 65 6E 85 38 28 A1  1 
1A12860 	20 40 A0  1 38 23 A1  1 
1A12868 	9C 53 A0  1  4 74 68 65 
1A12870 	6E  0  0  0 60 23 A1  1 
1A12878 	80 6D A0  1 58 46 A0  1 

\ Extent holds the largest known extent of the current word, as determined
\ by branch targets seen so far.  This is used to decide if an exit should
\ terminate the decompilation, or whether it is "protected" by a conditional.
variable extent  extent off
1A12880 	 0 65 78 74 65 6E 74 86 
1A12888 	60 28 A1  1 48 40 A0  1 
1A12890 	90  3  0  0 
: +extent  ( possible-new-extent -- )  extent @ umax extent !  ;
1A12894 	2B 65 78 74 
1A12898 	65 6E 74 87 8C 28 A1  1 
1A128A0 	20 40 A0  1 8C 28 A1  1 
1A128A8 	5C 4C A0  1 C8 4A A0  1 
1A128B0 	8C 28 A1  1 54 4D A0  1 
1A128B8 	58 46 A0  1 
: +branch  ( ip-of-branch -- next-ip )  ta1+ /branch +  ;
1A128BC 	2B 62 72 61 
1A128C0 	6E 63 68 87 A0 28 A1  1 
1A128C8 	20 40 A0  1 FC 50 A0  1 
1A128D0 	FC 57 A0  1  4 45 A0  1 
1A128D8 	58 46 A0  1 
: .endof  ( ip -- ip' )  .." endof" cr +branch  ;
1A128DC 	 0 2E 65 6E 
1A128E0 	64 6F 66 86 C8 28 A1  1 
1A128E8 	20 40 A0  1 9C 53 A0  1 
1A128F0 	 5 65 6E 64 6F 66  0  0 
1A128F8 	60 23 A1  1 80 6D A0  1 
1A12900 	C8 28 A1  1 58 46 A0  1 
: .endcase  ( ip -- ip' )  .." endcase" cr ta1+  ;
1A12908 	 0  0  0 2E 65 6E 64 63 
1A12910 	61 73 65 88 E8 28 A1  1 
1A12918 	20 40 A0  1 9C 53 A0  1 
1A12920 	 7 65 6E 64 63 61 73 65 
1A12928 	 0  0  0  0 60 23 A1  1 
1A12930 	80 6D A0  1 FC 50 A0  1 
1A12938 	58 46 A0  1 
: .$endof  ( ip -- ip' )  .." $endof" cr +branch  ;
1A1293C 	2E 24 65 6E 
1A12940 	64 6F 66 87 18 29 A1  1 
1A12948 	20 40 A0  1 9C 53 A0  1 
1A12950 	 6 24 65 6E 64 6F 66  0 
1A12958 	60 23 A1  1 80 6D A0  1 
1A12960 	C8 28 A1  1 58 46 A0  1 
: .$endcase  ( ip -- ip' )  .." $endcase" cr ta1+  ;
1A12968 	 0  0 2E 24 65 6E 64 63 
1A12970 	61 73 65 89 48 29 A1  1 
1A12978 	20 40 A0  1 9C 53 A0  1 
1A12980 	 8 24 65 6E 64 63 61 73 
1A12988 	65  0  0  0 60 23 A1  1 
1A12990 	80 6D A0  1 FC 50 A0  1 
1A12998 	58 46 A0  1 

: add-break  ( break-address break-type -- )
1A1299C 	 0  0 61 64 
1A129A0 	64 2D 62 72 65 61 6B 89 
1A129A8 	78 29 A1  1 20 40 A0  1 
   end-breaks @  breaks /breaks +  >=        ( adr,type full? )
1A129B0 	 C 26 A1  1 5C 4C A0  1 
1A129B8 	EC 25 A1  1 D8 25 A1  1 
1A129C0 	 4 45 A0  1 EC 48 A0  1 
   abort" Decompiler table overflow"         ( adr,type )
1A129C8 	 8 81 A0  1 19 44 65 63 
1A129D0 	6F 6D 70 69 6C 65 72 20 
1A129D8 	74 61 62 6C 65 20 6F 76 
1A129E0 	65 72 66 6C 6F 77  0  0 
   end-breaks @ breaks >  if                 ( adr,type )
1A129E8 	 C 26 A1  1 5C 4C A0  1 
1A129F0 	EC 25 A1  1  4 48 A0  1 
1A129F8 	DC 41 A0  1 6C  0  0  0 
      over end-breaks @ /n 2* - >r r@ 2@     ( adr,type  adr prev-adr,type )
1A12A00 	54 49 A0  1  C 26 A1  1 
1A12A08 	5C 4C A0  1 40 51 A0  1 
1A12A10 	A0 4B A0  1 18 45 A0  1 
1A12A18 	BC 45 A0  1 E4 45 A0  1 
1A12A20 	CC 4D A0  1 
      ['] .endof  =  -rot  =  and  if        ( adr,type )
1A12A24 	60 53 A0  1 
1A12A28 	E8 28 A1  1 24 48 A0  1 
1A12A30 	94 49 A0  1 24 48 A0  1 
1A12A38 	5C 44 A0  1 DC 41 A0  1 
1A12A40 	20  0  0  0 
	 r@ 2@  2swap  r> 2!                 ( prev-adr,type )
1A12A44 	E4 45 A0  1 
1A12A48 	CC 4D A0  1 F4 49 A0  1 
1A12A50 	D0 45 A0  1 E4 4D A0  1 
      else                                   ( adr,type )
1A12A58 	C8 41 A0  1  C  0  0  0 
	 r> drop                             ( adr,type )
1A12A60 	D0 45 A0  1 30 49 A0  1 
      then                                   ( adr,type )
   then                                      ( adr,type )
   end-breaks @ 2!  /n 2*  end-breaks +!     (  )
1A12A68 	 C 26 A1  1 5C 4C A0  1 
1A12A70 	E4 4D A0  1 40 51 A0  1 
1A12A78 	A0 4B A0  1  C 26 A1  1 
1A12A80 	 C 4C A0  1 
;
1A12A84 	58 46 A0  1 
: ?add-break  ( break-address break-type -- )
1A12A88 	 0 3F 61 64 64 2D 62 72 
1A12A90 	65 61 6B 8A AC 29 A1  1 
1A12A98 	20 40 A0  1 
   over             ( break-address break-type break-address )
1A12A9C 	54 49 A0  1 
   end-breaks @ breaks  ?do
1A12AA0 	 C 26 A1  1 5C 4C A0  1 
1A12AA8 	EC 25 A1  1 50 42 A0  1 
1A12AB0 	3C  0  0  0 
      dup  i 2@ drop   =  ( found? )  if
1A12AB4 	40 49 A0  1 
1A12AB8 	B4 42 A0  1 CC 4D A0  1 
1A12AC0 	30 49 A0  1 24 48 A0  1 
1A12AC8 	DC 41 A0  1 10  0  0  0 
         drop 0  leave
1A12AD0 	30 49 A0  1 70 6F A0  1 
1A12AD8 	18 43 A0  1 
      then
   /n 2*  +loop     ( break-address break-type not-found? )
1A12ADC 	40 51 A0  1 
1A12AE0 	A0 4B A0  1 1C 42 A0  1 
1A12AE8 	CC FF FF FF 

   if  add-break  else  2drop  then
1A12AEC 	DC 41 A0  1 
1A12AF0 	10  0  0  0 AC 29 A1  1 
1A12AF8 	C8 41 A0  1  8  0  0  0 
1A12B00 	AC 49 A0  1 
;
1A12B04 	58 46 A0  1 

: scan-of  ( ip-of-(of -- ip' )
1A12B08 	73 63 61 6E 2D 6F 66 87 
1A12B10 	98 2A A1  1 20 40 A0  1 
   dup >target dup +extent   ( ip next-of )
1A12B18 	40 49 A0  1 58 58 A0  1 
1A12B20 	40 49 A0  1 A0 28 A1  1 
   /branch - /token -        ( ip endof-addr )
1A12B28 	FC 57 A0  1 18 45 A0  1 
1A12B30 	B4 46 A0  1 18 45 A0  1 
   dup ['] .endof add-break  ( ip endof-addr )
1A12B38 	40 49 A0  1 60 53 A0  1 
1A12B40 	E8 28 A1  1 AC 29 A1  1 
   ['] .endcase ?add-break
1A12B48 	60 53 A0  1 18 29 A1  1 
1A12B50 	98 2A A1  1 
   +branch
1A12B54 	C8 28 A1  1 
;
1A12B58 	58 46 A0  1 
: scan-$of  ( ip-of-($of -- ip' )
1A12B5C 	 0  0  0 73 
1A12B60 	63 61 6E 2D 24 6F 66 88 
1A12B68 	14 2B A1  1 20 40 A0  1 
   dup >target dup +extent   ( ip next-$of )
1A12B70 	40 49 A0  1 58 58 A0  1 
1A12B78 	40 49 A0  1 A0 28 A1  1 
   /branch - /token -        ( ip $endof-addr )
1A12B80 	FC 57 A0  1 18 45 A0  1 
1A12B88 	B4 46 A0  1 18 45 A0  1 
   dup ['] .$endof add-break  ( ip $endof-addr )
1A12B90 	40 49 A0  1 60 53 A0  1 
1A12B98 	48 29 A1  1 AC 29 A1  1 
   ['] .$endcase ?add-break
1A12BA0 	60 53 A0  1 78 29 A1  1 
1A12BA8 	98 2A A1  1 
   +branch
1A12BAC 	C8 28 A1  1 
;
1A12BB0 	58 46 A0  1 
: scan-branch  ( ip-of-?branch -- ip' )
1A12BB4 	73 63 61 6E 
1A12BB8 	2D 62 72 61 6E 63 68 8B 
1A12BC0 	6C 2B A1  1 20 40 A0  1 
   dup dup forward-branch?  if
1A12BC8 	40 49 A0  1 40 49 A0  1 
1A12BD0 	3C 27 A1  1 DC 41 A0  1 
1A12BD8 	40  0  0  0 
      >target dup +extent   ( branch-target-address)
1A12BDC 	58 58 A0  1 
1A12BE0 	40 49 A0  1 A0 28 A1  1 
      dup bare-if?  if  ( ip ) \ is this an IF branch?
1A12BE8 	40 49 A0  1 60 27 A1  1 
1A12BF0 	DC 41 A0  1 18  0  0  0 
         ['] .then add-break
1A12BF8 	60 53 A0  1 60 28 A1  1 
1A12C00 	AC 29 A1  1 
      else
1A12C04 	C8 41 A0  1 
1A12C08 	 8  0  0  0 
         drop
1A12C0C 	30 49 A0  1 
      then
   else
1A12C10 	C8 41 A0  1 14  0  0  0 
      >target  ['] .begin add-break
1A12C18 	58 58 A0  1 60 53 A0  1 
1A12C20 	38 28 A1  1 AC 29 A1  1 
   then
   +branch
1A12C28 	C8 28 A1  1 
;
1A12C2C 	58 46 A0  1 

: scan-unnest  ( ip -- ip' | 0 )
1A12C30 	73 63 61 6E 2D 75 6E 6E 
1A12C38 	65 73 74 8B C4 2B A1  1 
1A12C40 	20 40 A0  1 
   dup extent @ u>=  if  drop 0  else  ta1+  then
1A12C44 	40 49 A0  1 
1A12C48 	8C 28 A1  1 5C 4C A0  1 
1A12C50 	CC 48 A0  1 DC 41 A0  1 
1A12C58 	14  0  0  0 30 49 A0  1 
1A12C60 	70 6F A0  1 C8 41 A0  1 
1A12C68 	 8  0  0  0 FC 50 A0  1 
;
1A12C70 	58 46 A0  1 
: scan-;code ( ip -- ip' | 0 )  does-ip?  0=  if  drop 0  then  ;
1A12C74 	 0 73 63 61 
1A12C78 	6E 2D 3B 63 6F 64 65 8A 
1A12C80 	40 2C A1  1 20 40 A0  1 
1A12C88 	F8 56 A0  1 24 47 A0  1 
1A12C90 	DC 41 A0  1  C  0  0  0 
1A12C98 	30 49 A0  1 70 6F A0  1 
1A12CA0 	58 46 A0  1 
: .;code    (s ip -- ip' )
1A12CA4 	 0 2E 3B 63 
1A12CA8 	6F 64 65 86 84 2C A1  1 
1A12CB0 	20 40 A0  1 
   does-ip?  if
1A12CB4 	F8 56 A0  1 
1A12CB8 	DC 41 A0  1 20  0  0  0 
      ??cr .." does> "
1A12CC0 	 0 A1 A0  1 9C 53 A0  1 
1A12CC8 	 6 64 6F 65 73 3E 20  0 
1A12CD0 	60 23 A1  1 
   else
1A12CD4 	C8 41 A0  1 
1A12CD8 	30  0  0  0 
      ??cr 0 lmargin ! .." ;code "  cr disassemble     0
1A12CDC 	 0 A1 A0  1 
1A12CE0 	70 6F A0  1 80 13 A1  1 
1A12CE8 	54 4D A0  1 9C 53 A0  1 
1A12CF0 	 6 3B 63 6F 64 65 20  0 
1A12CF8 	60 23 A1  1 80 6D A0  1 
1A12D00 	C4 25 A1  1 70 6F A0  1 
   then
;
1A12D08 	58 46 A0  1 
: .branch  ( ip -- ip' )
1A12D0C 	2E 62 72 61 
1A12D10 	6E 63 68 87 B0 2C A1  1 
1A12D18 	20 40 A0  1 
   dup forward-branch?  if
1A12D1C 	40 49 A0  1 
1A12D20 	3C 27 A1  1 DC 41 A0  1 
1A12D28 	24  0  0  0 
      -indent .." else" +indent
1A12D2C 	38 23 A1  1 
1A12D30 	9C 53 A0  1  4 65 6C 73 
1A12D38 	65  0  0  0 60 23 A1  1 
1A12D40 	14 23 A1  1 
   else
1A12D44 	C8 41 A0  1 
1A12D48 	1C  0  0  0 
      -indent .." repeat" cr
1A12D4C 	38 23 A1  1 
1A12D50 	9C 53 A0  1  6 72 65 70 
1A12D58 	65 61 74  0 60 23 A1  1 
1A12D60 	80 6D A0  1 
   then
   +branch
1A12D64 	C8 28 A1  1 
;
1A12D68 	58 46 A0  1 
: .?branch  ( ip -- ip' )
1A12D6C 	 0  0  0 2E 
1A12D70 	3F 62 72 61 6E 63 68 88 
1A12D78 	18 2D A1  1 20 40 A0  1 
  dup forward-branch?  if
1A12D80 	40 49 A0  1 3C 27 A1  1 
1A12D88 	DC 41 A0  1 4C  0  0  0 
     dup while?  if
1A12D90 	40 49 A0  1 DC 27 A1  1 
1A12D98 	DC 41 A0  1 24  0  0  0 
        -indent .." while" +indent
1A12DA0 	38 23 A1  1 9C 53 A0  1 
1A12DA8 	 5 77 68 69 6C 65  0  0 
1A12DB0 	60 23 A1  1 14 23 A1  1 
     else
1A12DB8 	C8 41 A0  1 14  0  0  0 
        .." if"  +indent
1A12DC0 	9C 53 A0  1  2 69 66  0 
1A12DC8 	60 23 A1  1 14 23 A1  1 
     then
  else
1A12DD0 	C8 41 A0  1 1C  0  0  0 
     -indent .." until " cr
1A12DD8 	38 23 A1  1 9C 53 A0  1 
1A12DE0 	 6 75 6E 74 69 6C 20  0 
1A12DE8 	60 23 A1  1 80 6D A0  1 
  then
  +branch
1A12DF0 	C8 28 A1  1 
;
1A12DF4 	58 46 A0  1 

: .do     ( ip -- ip' )  .." do    " +indent  +branch  ;
1A12DF8 	2E 64 6F 83 7C 2D A1  1 
1A12E00 	20 40 A0  1 9C 53 A0  1 
1A12E08 	 6 64 6F 20 20 20 20  0 
1A12E10 	60 23 A1  1 14 23 A1  1 
1A12E18 	C8 28 A1  1 58 46 A0  1 
: .?do    ( ip -- ip' )  .." ?do   " +indent  +branch  ;
1A12E20 	 0  0  0 2E 3F 64 6F 84 
1A12E28 	 0 2E A1  1 20 40 A0  1 
1A12E30 	9C 53 A0  1  6 3F 64 6F 
1A12E38 	20 20 20  0 60 23 A1  1 
1A12E40 	14 23 A1  1 C8 28 A1  1 
1A12E48 	58 46 A0  1 
: .loop   ( ip -- ip' )  -indent .." loop  " cr +branch  ;
1A12E4C 	 0  0 2E 6C 
1A12E50 	6F 6F 70 85 2C 2E A1  1 
1A12E58 	20 40 A0  1 38 23 A1  1 
1A12E60 	9C 53 A0  1  6 6C 6F 6F 
1A12E68 	70 20 20  0 60 23 A1  1 
1A12E70 	80 6D A0  1 C8 28 A1  1 
1A12E78 	58 46 A0  1 
: .+loop  ( ip -- ip' )  -indent .." +loop " cr +branch  ;
1A12E7C 	 0 2E 2B 6C 
1A12E80 	6F 6F 70 86 58 2E A1  1 
1A12E88 	20 40 A0  1 38 23 A1  1 
1A12E90 	9C 53 A0  1  6 2B 6C 6F 
1A12E98 	6F 70 20  0 60 23 A1  1 
1A12EA0 	80 6D A0  1 C8 28 A1  1 
1A12EA8 	58 46 A0  1 
: .of     ( ip -- ip' )  .." of   " +branch  ;
1A12EAC 	2E 6F 66 83 
1A12EB0 	88 2E A1  1 20 40 A0  1 
1A12EB8 	9C 53 A0  1  5 6F 66 20 
1A12EC0 	20 20  0  0 60 23 A1  1 
1A12EC8 	C8 28 A1  1 58 46 A0  1 
: .$of    ( ip -- ip' )  .." $of  " +branch  ;
1A12ED0 	 0  0  0 2E 24 6F 66 84 
1A12ED8 	B4 2E A1  1 20 40 A0  1 
1A12EE0 	9C 53 A0  1  5 24 6F 66 
1A12EE8 	20 20  0  0 60 23 A1  1 
1A12EF0 	C8 28 A1  1 58 46 A0  1 

\ first check for word being immediate so that it may be preceded
\ by [compile] if necessary
: check-[compile]  ( acf -- acf )
1A12EF8 	63 68 65 63 6B 2D 5B 63 
1A12F00 	6F 6D 70 69 6C 65 5D 8F 
1A12F08 	DC 2E A1  1 20 40 A0  1 
   dup immediate?  if  .." [compile] "  then
1A12F10 	40 49 A0  1 FC B8 A0  1 
1A12F18 	DC 41 A0  1 18  0  0  0 
1A12F20 	9C 53 A0  1  A 5B 63 6F 
1A12F28 	6D 70 69 6C 65 5D 20  0 
1A12F30 	60 23 A1  1 
;
1A12F34 	58 46 A0  1 

: put"  (s -- )  ascii " emit  space  ;
1A12F38 	 0  0  0 70 75 74 22 84 
1A12F40 	 C 2F A1  1 20 40 A0  1 
1A12F48 	58 41 A0  1 22  0  0  0 
1A12F50 	2C 6C A0  1 CC 71 A0  1 
1A12F58 	58 46 A0  1 

: cword-name  (s ip -- ip' $ name$ )
1A12F5C 	 0 63 77 6F 
1A12F60 	72 64 2D 6E 61 6D 65 8A 
1A12F68 	44 2F A1  1 20 40 A0  1 
   dup token@          ( ip acf )
1A12F70 	40 49 A0  1  C 54 A0  1 
   >name name>string   ( ip name$ )
1A12F78 	24 74 A0  1 58 74 A0  1 
   swap 1+ swap 2 -    ( ip name$' )  \ Remove parentheses
1A12F80 	68 49 A0  1 30 4B A0  1 
1A12F88 	68 49 A0  1 90 6F A0  1 
1A12F90 	18 45 A0  1 
   rot ta1+ -rot       ( ip' name$ )
1A12F94 	7C 49 A0  1 
1A12F98 	FC 50 A0  1 94 49 A0  1 
   2 pick count        ( ip name$ $ )
1A12FA0 	90 6F A0  1  C 4A A0  1 
1A12FA8 	BC 53 A0  1 
   2swap               ( ip $ name$ )
1A12FAC 	F4 49 A0  1 
;
1A12FB0 	58 46 A0  1 

: type#  ( $ -- )  \ render control characters as green #
1A12FB4 	 0  0 74 79 
1A12FB8 	70 65 23 85 6C 2F A1  1 
1A12FC0 	20 40 A0  1 
   bounds ?do
1A12FC4 	F0 6D A0  1 
1A12FC8 	50 42 A0  1 4C  0  0  0 
      i c@ dup h# 20 < if
1A12FD0 	B4 42 A0  1 C4 4C A0  1 
1A12FD8 	40 49 A0  1 58 41 A0  1 
1A12FE0 	20  0  0  0 E4 47 A0  1 
1A12FE8 	DC 41 A0  1 20  0  0  0 
	 drop green-letters ." #" red-letters
1A12FF0 	30 49 A0  1 C0 F9 A0  1 
1A12FF8 	20 7C A0  1  1 23  0  0 
1A13000 	A4 F9 A0  1 
      else
1A13004 	C8 41 A0  1 
1A13008 	 8  0  0  0 
	 emit
1A1300C 	2C 6C A0  1 
      then
   loop
1A13010 	F8 41 A0  1 BC FF FF FF 
;
1A13018 	58 46 A0  1 

: .string-tail  ( $ name$ -- )
1A1301C 	 0  0  0 2E 
1A13020 	73 74 72 69 6E 67 2D 74 
1A13028 	61 69 6C 8C C0 2F A1  1 
1A13030 	20 40 A0  1 
   2 pick over +  3 + ?line    ( $ name$ )  \ Keep word and string on the same line
1A13034 	90 6F A0  1 
1A13038 	 C 4A A0  1 54 49 A0  1 
1A13040 	 4 45 A0  1 A0 6F A0  1 
1A13048 	 4 45 A0  1 A8 13 A1  1 
   cr".  space                 ( $ )
1A13050 	60 23 A1  1 CC 71 A0  1 
   red-letters type#           ( )
1A13058 	A4 F9 A0  1 C0 2F A1  1 
   magenta-letters             ( )
1A13060 	14 FA A0  1 
   ." "" "                     ( )
1A13064 	20 7C A0  1 
1A13068 	 2 22 20  0 
   cancel                      ( )
1A1306C 	BC F7 A0  1 
;
1A13070 	58 46 A0  1 

: pretty-. ( n -- )
1A13074 	 0  0  0 70 
1A13078 	72 65 74 74 79 2D 2E 88 
1A13080 	30 30 A1  1 20 40 A0  1 
   base @ d# 10 =  if  (.)  else  (u.)  then   ( adr len )
1A13088 	B8 75 A0  1 5C 4C A0  1 
1A13090 	58 41 A0  1  A  0  0  0 
1A13098 	24 48 A0  1 DC 41 A0  1 
1A130A0 	10  0  0  0 10 78 A0  1 
1A130A8 	C8 41 A0  1  8  0  0  0 
1A130B0 	AC 77 A0  1 
   dup 3 + ?line  indent  add-position
1A130B4 	40 49 A0  1 
1A130B8 	A0 6F A0  1  4 45 A0  1 
1A130C0 	A8 13 A1  1 C8 22 A1  1 
1A130C8 	C0 21 A1  1 
   green-letters 
1A130CC 	C0 F9 A0  1 
   base @ case
1A130D0 	B8 75 A0  1 5C 4C A0  1 
      d# 10 of  ." d# "  endof
1A130D8 	58 41 A0  1  A  0  0  0 
1A130E0 	48 43 A0  1 18  0  0  0 
1A130E8 	20 7C A0  1  3 64 23 20 
1A130F0 	 0  0  0  0 6C 43 A0  1 
1A130F8 	74  0  0  0 
      d# 16 of  ." h# "  endof
1A130FC 	58 41 A0  1 
1A13100 	10  0  0  0 48 43 A0  1 
1A13108 	18  0  0  0 20 7C A0  1 
1A13110 	 3 68 23 20  0  0  0  0 
1A13118 	6C 43 A0  1 50  0  0  0 
      d#  8 of  ." o# "  endof
1A13120 	58 41 A0  1  8  0  0  0 
1A13128 	48 43 A0  1 18  0  0  0 
1A13130 	20 7C A0  1  3 6F 23 20 
1A13138 	 0  0  0  0 6C 43 A0  1 
1A13140 	2C  0  0  0 
      d#  2 of  ." b# "  endof
1A13144 	58 41 A0  1 
1A13148 	 2  0  0  0 48 43 A0  1 
1A13150 	18  0  0  0 20 7C A0  1 
1A13158 	 3 62 23 20  0  0  0  0 
1A13160 	6C 43 A0  1  8  0  0  0 
   endcase
1A13168 	84 43 A0  1 
   type cancel  space
1A1316C 	 4 6C A0  1 
1A13170 	BC F7 A0  1 CC 71 A0  1 
;
1A13178 	58 46 A0  1 

: .compiled  ( ip -- ip' )
1A1317C 	 0  0 2E 63 
1A13180 	6F 6D 70 69 6C 65 64 89 
1A13188 	84 30 A1  1 20 40 A0  1 
   dup token@ check-[compile]   ( ip xt )
1A13190 	40 49 A0  1  C 54 A0  1 
1A13198 	 C 2F A1  1 
   >name name>string            ( ip adr len )
1A1319C 	24 74 A0  1 
1A131A0 	58 74 A0  1 
   type space                   ( ip )
1A131A4 	 4 6C A0  1 
1A131A8 	CC 71 A0  1 
   ta1+                         ( ip' )
1A131AC 	FC 50 A0  1 
;
1A131B0 	58 46 A0  1 
: .word         ( ip -- ip' )
1A131B4 	 0  0 2E 77 
1A131B8 	6F 72 64 85 8C 31 A1  1 
1A131C0 	20 40 A0  1 
   indent
1A131C4 	C8 22 A1  1 
   dup token@ check-[compile]   ( ip xt )
1A131C8 	40 49 A0  1  C 54 A0  1 
1A131D0 	 C 2F A1  1 
   >name name>string            ( ip adr len )
1A131D4 	24 74 A0  1 
1A131D8 	58 74 A0  1 
   dup ?line  add-position      ( ip adr len )
1A131DC 	40 49 A0  1 
1A131E0 	A8 13 A1  1 C0 21 A1  1 
   type space                   ( ip )
1A131E8 	 4 6C A0  1 CC 71 A0  1 
   ta1+                         ( ip' )
1A131F0 	FC 50 A0  1 
;
1A131F4 	58 46 A0  1 
: skip-word     ( ip -- ip' )  ta1+  ;
1A131F8 	 0  0 73 6B 69 70 2D 77 
1A13200 	6F 72 64 89 C0 31 A1  1 
1A13208 	20 40 A0  1 FC 50 A0  1 
1A13210 	58 46 A0  1 
: .inline       ( ip -- ip' )  ta1+ dup unaligned-@  pretty-.  na1+   ;
1A13214 	2E 69 6E 6C 
1A13218 	69 6E 65 87  8 32 A1  1 
1A13220 	20 40 A0  1 FC 50 A0  1 
1A13228 	40 49 A0  1 E0 4C A0  1 
1A13230 	84 30 A1  1 CC 50 A0  1 
1A13238 	58 46 A0  1 
: skip-inline   ( ip -- ip' )  ta1+ na1+  ;
1A1323C 	73 6B 69 70 
1A13240 	2D 69 6E 6C 69 6E 65 8B 
1A13248 	20 32 A1  1 20 40 A0  1 
1A13250 	FC 50 A0  1 CC 50 A0  1 
1A13258 	58 46 A0  1 
: .wlit         ( ip -- ip' )  ta1+ dup unaligned-w@ 1- pretty-. wa1+  ;
1A1325C 	 0  0 2E 77 
1A13260 	6C 69 74 85 4C 32 A1  1 
1A13268 	20 40 A0  1 FC 50 A0  1 
1A13270 	40 49 A0  1 18 4D A0  1 
1A13278 	54 4B A0  1 84 30 A1  1 
1A13280 	A0 50 A0  1 58 46 A0  1 
: skip-wlit     ( ip -- ip' )  ta1+ wa1+  ;
1A13288 	 0  0 73 6B 69 70 2D 77 
1A13290 	6C 69 74 89 68 32 A1  1 
1A13298 	20 40 A0  1 FC 50 A0  1 
1A132A0 	A0 50 A0  1 58 46 A0  1 
: .llit         ( ip -- ip' )  ta1+ dup unaligned-l@ 1- pretty-. la1+  ;
1A132A8 	 0  0 2E 6C 6C 69 74 85 
1A132B0 	98 32 A1  1 20 40 A0  1 
1A132B8 	FC 50 A0  1 40 49 A0  1 
1A132C0 	FC 4C A0  1 54 4B A0  1 
1A132C8 	84 30 A1  1 B4 50 A0  1 
1A132D0 	58 46 A0  1 
: skip-llit     ( ip -- ip' )  ta1+ la1+  ;
1A132D4 	 0  0 73 6B 
1A132D8 	69 70 2D 6C 6C 69 74 89 
1A132E0 	B4 32 A1  1 20 40 A0  1 
1A132E8 	FC 50 A0  1 B4 50 A0  1 
1A132F0 	58 46 A0  1 
: .dlit         ( ip -- ip' )  ta1+ dup d@ (d.) add-position green-letters type ." . " cancel  2 na+  ;
1A132F4 	 0  0 2E 64 
1A132F8 	6C 69 74 85 E4 32 A1  1 
1A13300 	20 40 A0  1 FC 50 A0  1 
1A13308 	40 49 A0  1 20 4C A0  1 
1A13310 	10 7B A0  1 C0 21 A1  1 
1A13318 	C0 F9 A0  1  4 6C A0  1 
1A13320 	20 7C A0  1  2 2E 20  0 
1A13328 	BC F7 A0  1 90 6F A0  1 
1A13330 	48 50 A0  1 58 46 A0  1 
: skip-dlit     ( ip -- ip' )  ta1+ 2 na+  ;
1A13338 	 0  0 73 6B 69 70 2D 64 
1A13340 	6C 69 74 89  0 33 A1  1 
1A13348 	20 40 A0  1 FC 50 A0  1 
1A13350 	90 6F A0  1 48 50 A0  1 
1A13358 	58 46 A0  1 
: skip-branch   ( ip -- ip' )  +branch  ;
1A1335C 	73 6B 69 70 
1A13360 	2D 62 72 61 6E 63 68 8B 
1A13368 	48 33 A1  1 20 40 A0  1 
1A13370 	C8 28 A1  1 58 46 A0  1 
: .compile      ( ip -- ip' )  .." compile " ta1+ .compiled   ;
1A13378 	 0  0  0 2E 63 6F 6D 70 
1A13380 	69 6C 65 88 6C 33 A1  1 
1A13388 	20 40 A0  1 9C 53 A0  1 
1A13390 	 8 63 6F 6D 70 69 6C 65 
1A13398 	20  0  0  0 60 23 A1  1 
1A133A0 	FC 50 A0  1 8C 31 A1  1 
1A133A8 	58 46 A0  1 
: skip-compile  ( ip -- ip' )  ta1+ ta1+  ;
1A133AC 	 0  0  0 73 
1A133B0 	6B 69 70 2D 63 6F 6D 70 
1A133B8 	69 6C 65 8C 88 33 A1  1 
1A133C0 	20 40 A0  1 FC 50 A0  1 
1A133C8 	FC 50 A0  1 58 46 A0  1 
: skip-string   ( ip -- ip' )  ta1+ +str  ;
1A133D0 	73 6B 69 70 2D 73 74 72 
1A133D8 	69 6E 67 8B C0 33 A1  1 
1A133E0 	20 40 A0  1 FC 50 A0  1 
1A133E8 	18 8B A0  1 58 46 A0  1 
: skip-nstring  ( ip -- ip' )  ta1+ +nstr  ;
1A133F0 	 0  0  0 73 6B 69 70 2D 
1A133F8 	6E 73 74 72 69 6E 67 8C 
1A13400 	E0 33 A1  1 20 40 A0  1 
1A13408 	FC 50 A0  1 3C 8B A0  1 
1A13410 	58 46 A0  1 
: .(')          ( ip -- ip' )  ta1+  .." ['] " dup token@ .name  ta1+ ;
1A13414 	 0  0  0 2E 
1A13418 	28 27 29 84  4 34 A1  1 
1A13420 	20 40 A0  1 FC 50 A0  1 
1A13428 	9C 53 A0  1  4 5B 27 5D 
1A13430 	20  0  0  0 60 23 A1  1 
1A13438 	40 49 A0  1  C 54 A0  1 
1A13440 	C8 9A A0  1 FC 50 A0  1 
1A13448 	58 46 A0  1 
headers
: skip-(')      ( ip -- ip' )  ta1+ ta1+  ;
1A1344C 	 0  0  0 73 
1A13450 	6B 69 70 2D 28 27 29 88 
1A13458 	20 34 A1  1 20 40 A0  1 
1A13460 	FC 50 A0  1 FC 50 A0  1 
1A13468 	58 46 A0  1 
headerless
: .is           ( ip -- ip' )  .." to "  ta1+ dup token@ .name  ta1+  ;
1A1346C 	2E 69 73 83 
1A13470 	5C 34 A1  1 20 40 A0  1 
1A13478 	9C 53 A0  1  3 74 6F 20 
1A13480 	 0  0  0  0 60 23 A1  1 
1A13488 	FC 50 A0  1 40 49 A0  1 
1A13490 	 C 54 A0  1 C8 9A A0  1 
1A13498 	FC 50 A0  1 58 46 A0  1 
: .string       ( ip -- ip' )  cword-name              .string-tail +str   ;
1A134A0 	2E 73 74 72 69 6E 67 87 
1A134A8 	74 34 A1  1 20 40 A0  1 
1A134B0 	6C 2F A1  1 30 30 A1  1 
1A134B8 	18 8B A0  1 58 46 A0  1 
: .nstring      ( ip -- ip' )  ta1+  dup ncount " n""" .string-tail +nstr  ;
1A134C0 	 0  0  0 2E 6E 73 74 72 
1A134C8 	69 6E 67 88 AC 34 A1  1 
1A134D0 	20 40 A0  1 FC 50 A0  1 
1A134D8 	40 49 A0  1 F0 53 A0  1 
1A134E0 	9C 53 A0  1  2 6E 22  0 
1A134E8 	30 30 A1  1 3C 8B A0  1 
1A134F0 	58 46 A0  1 

\ Use this version of .branch if the structured conditional code is not used
\ : .branch     ( ip -- ip' )  .word   dup <w@ .   /branch +   ;

: .unnest     ( ip -- ip' )
1A134F4 	2E 75 6E 6E 
1A134F8 	65 73 74 87 D0 34 A1  1 
1A13500 	20 40 A0  1 
   dup extent @ u>=  if
1A13504 	40 49 A0  1 
1A13508 	8C 28 A1  1 5C 4C A0  1 
1A13510 	CC 48 A0  1 DC 41 A0  1 
1A13518 	30  0  0  0 
      ??cr 0 lmargin ! .." ;" drop   0
1A1351C 	 0 A1 A0  1 
1A13520 	70 6F A0  1 80 13 A1  1 
1A13528 	54 4D A0  1 9C 53 A0  1 
1A13530 	 1 3B  0  0 60 23 A1  1 
1A13538 	30 49 A0  1 70 6F A0  1 
   else
1A13540 	C8 41 A0  1 18  0  0  0 
      .." exit " ta1+
1A13548 	9C 53 A0  1  5 65 78 69 
1A13550 	74 20  0  0 60 23 A1  1 
1A13558 	FC 50 A0  1 
   then
;
1A1355C 	58 46 A0  1 
: dummy ;
1A13560 	 0  0 64 75 6D 6D 79 85 
1A13568 	 0 35 A1  1 20 40 A0  1 
1A13570 	58 46 A0  1 

\ classify each word in a definition

\  Common constant for sizing the three classes:
d# 36 constant #decomp-classes
1A13574 	23 64 65 63 
1A13578 	6F 6D 70 2D 63 6C 61 73 
1A13580 	73 65 73 8F 6C 35 A1  1 
1A13588 	68 40 A0  1 24  0  0  0 

#decomp-classes tassociative: execution-class  ( token -- index )
1A13590 	65 78 65 63 75 74 69 6F 
1A13598 	6E 2D 63 6C 61 73 73 8F 
1A135A0 	88 35 A1  1 F4 24 A1  1 
1A135A8 	24  0  0  0 
   (  0 ) [compile]  (lit)           (  1 ) [compile]  ?branch
1A135AC 	58 41 A0  1 
1A135B0 	DC 41 A0  1 
   (  2 ) [compile]  branch          (  3 ) [compile]  (loop)
1A135B4 	C8 41 A0  1 
1A135B8 	F8 41 A0  1 
   (  4 ) [compile]  (+loop)         (  5 ) [compile]  (do)
1A135BC 	1C 42 A0  1 
1A135C0 	88 42 A0  1 
   (  6 ) [compile]  compile         (  7 ) [compile]  (.")
1A135C4 	8C 75 A0  1 
1A135C8 	20 7C A0  1 
   (  8 ) [compile]  (abort")        (  9 ) [compile]  (;code)
1A135CC 	 8 81 A0  1 
1A135D0 	2C A3 A0  1 
   ( 10 ) [compile]  unnest          ( 11 ) [compile]  (")
1A135D4 	58 46 A0  1 
1A135D8 	9C 53 A0  1 
   ( 12 ) [compile]  (?do)           ( 13 ) [compile]  (does>)
1A135DC 	50 42 A0  1 
1A135E0 	50 A3 A0  1 
   ( 14 ) [compile]  exit            ( 15 ) [compile]  (wlit)
1A135E4 	40 46 A0  1 
1A135E8 	88 20 A1  1 
   ( 16 ) [compile]  (')             ( 17 ) [compile]  (of)
1A135EC 	60 53 A0  1 
1A135F0 	48 43 A0  1 
   ( 18 ) [compile]  (endof)         ( 19 ) [compile]  (endcase)
1A135F4 	6C 43 A0  1 
1A135F8 	84 43 A0  1 
   ( 20 ) [compile]  dummy	     ( 21 ) [compile]  (is)
1A135FC 	6C 35 A1  1 
1A13600 	B8 65 A0  1 
   ( 22 ) [compile]  (dlit)          ( 23 ) [compile]  (llit)
1A13604 	80 41 A0  1 
1A13608 	6C 41 A0  1 
   ( 24 ) [compile]  (n")            ( 25 ) [compile]  isdefer
1A1360C 	D4 53 A0  1 
1A13610 	98 40 A0  1 
   ( 26 ) [compile]  isuser          ( 27 ) [compile]  isvalue
1A13614 	D8 40 A0  1 
1A13618 	B8 40 A0  1 
   ( 28 ) [compile]  isconstant      ( 29 ) [compile]  isvariable
1A1361C 	FC 40 A0  1 
1A13620 	1C 41 A0  1 
   ( 30 ) [compile]  ($of)           ( 31 ) [compile]  ($endof)
1A13624 	20 18 A1  1 
1A13628 	98 43 A0  1 
   ( 32 ) [compile]  ($endcase)      ( 33 ) [compile]  dummy
1A1362C 	B0 43 A0  1 
1A13630 	6C 35 A1  1 
   ( 34 ) [compile]  dummy           ( 35 ) [compile]  dummy
1A13634 	6C 35 A1  1 
1A13638 	6C 35 A1  1 

\ Print a word which has been classified by  execution-class
#decomp-classes 1+ case: .execution-class  ( ip index -- ip' )
1A1363C 	 0  0  0 2E 
1A13640 	65 78 65 63 75 74 69 6F 
1A13648 	6E 2D 63 6C 61 73 73 90 
1A13650 	A4 35 A1  1 B8 24 A1  1 
1A13658 	25  0  0  0 
   (  0 )     .inline                (  1 )     .?branch
1A1365C 	20 32 A1  1 
1A13660 	7C 2D A1  1 
   (  2 )     .branch                (  3 )     .loop
1A13664 	18 2D A1  1 
1A13668 	58 2E A1  1 
   (  4 )     .+loop                 (  5 )     .do
1A1366C 	88 2E A1  1 
1A13670 	 0 2E A1  1 
   (  6 )     .compile               (  7 )     .string
1A13674 	88 33 A1  1 
1A13678 	AC 34 A1  1 
   (  8 )     .string                (  9 )     .;code
1A1367C 	AC 34 A1  1 
1A13680 	B0 2C A1  1 
   ( 10 )     .unnest                ( 11 )     .string
1A13684 	 0 35 A1  1 
1A13688 	AC 34 A1  1 
   ( 12 )     .?do                   ( 13 )     .;code
1A1368C 	2C 2E A1  1 
1A13690 	B0 2C A1  1 
   ( 14 )     .unnest                ( 15 )     .wlit
1A13694 	 0 35 A1  1 
1A13698 	68 32 A1  1 
   ( 16 )     .(')                   ( 17 )     .of
1A1369C 	20 34 A1  1 
1A136A0 	B4 2E A1  1 
   ( 18 )     .endof                 ( 19 )     .endcase
1A136A4 	E8 28 A1  1 
1A136A8 	18 29 A1  1 
   ( 20 )     dummy                  ( 21 )     .is
1A136AC 	6C 35 A1  1 
1A136B0 	74 34 A1  1 
   ( 22 )     .dlit                  ( 23 )     .llit
1A136B4 	 0 33 A1  1 
1A136B8 	B4 32 A1  1 
   ( 24 )     .nstring               ( 25 )     .is
1A136BC 	D0 34 A1  1 
1A136C0 	74 34 A1  1 
   ( 26 )     .is                    ( 27 )     .is
1A136C4 	74 34 A1  1 
1A136C8 	74 34 A1  1 
   ( 28 )     .is                    ( 29 )     .is
1A136CC 	74 34 A1  1 
1A136D0 	74 34 A1  1 
   ( 30 )     .$of                   ( 31 )     .$endof
1A136D4 	DC 2E A1  1 
1A136D8 	48 29 A1  1 
   ( 32 )     .$endcase              ( 33 )     dummy
1A136DC 	78 29 A1  1 
1A136E0 	6C 35 A1  1 
   ( 34 )     dummy                  ( 35 )     dummy
1A136E4 	6C 35 A1  1 
1A136E8 	6C 35 A1  1 
   ( default ) .word
1A136EC 	C0 31 A1  1 
;
1A136F0 	58 46 A0  1 

\ Determine the control structure implications of a word
\ which has been classified by  execution-class
#decomp-classes 1+ case: do-scan
1A136F4 	64 6F 2D 73 
1A136F8 	63 61 6E 87 54 36 A1  1 
1A13700 	B8 24 A1  1 25  0  0  0 
   (  0 )     skip-inline            (  1 )     scan-branch
1A13708 	4C 32 A1  1 C4 2B A1  1 
   (  2 )     scan-branch            (  3 )     skip-branch
1A13710 	C4 2B A1  1 6C 33 A1  1 
   (  4 )     skip-branch            (  6 )     skip-branch
1A13718 	6C 33 A1  1 6C 33 A1  1 
   (  6 )     skip-compile           (  7 )     skip-string
1A13720 	C0 33 A1  1 E0 33 A1  1 
   (  8 )     skip-string            (  9 )     scan-;code
1A13728 	E0 33 A1  1 84 2C A1  1 
   ( 10 )     scan-unnest            ( 11 )     skip-string
1A13730 	40 2C A1  1 E0 33 A1  1 
   ( 12 )     skip-branch            ( 13 )     scan-;code
1A13738 	6C 33 A1  1 84 2C A1  1 
   ( 14 )     scan-unnest            ( 15 )     skip-wlit
1A13740 	40 2C A1  1 98 32 A1  1 
   ( 16 )     skip-(')		     ( 17 )     scan-of
1A13748 	5C 34 A1  1 14 2B A1  1 
   ( 18 )     skip-branch            ( 19 )     skip-word
1A13750 	6C 33 A1  1  8 32 A1  1 
   ( 20 )     skip-string            ( 21 )     skip-word
1A13758 	E0 33 A1  1  8 32 A1  1 
   ( 22 )     skip-dlit              ( 23 )     skip-llit
1A13760 	48 33 A1  1 E4 32 A1  1 
   ( 24 )     skip-nstring           ( 25 )     skip-word
1A13768 	 4 34 A1  1  8 32 A1  1 
   ( 26 )     skip-word              ( 27 )     skip-word
1A13770 	 8 32 A1  1  8 32 A1  1 
   ( 28 )     skip-word              ( 29 )     skip-word
1A13778 	 8 32 A1  1  8 32 A1  1 
   ( 30 )     scan-$of               ( 31 )     skip-branch
1A13780 	6C 2B A1  1 6C 33 A1  1 
   ( 32 )     skip-word              ( 33 )     dummy
1A13788 	 8 32 A1  1 6C 35 A1  1 
   ( 34 )     dummy                  ( 35 )     dummy
1A13790 	6C 35 A1  1 6C 35 A1  1 
  ( default ) skip-word
1A13798 	 8 32 A1  1 
;
1A1379C 	58 46 A0  1 

headers
also forth definitions
: install-decomp  ( literal-acf display-acf skip-acf -- )
1A137A0 	 0 69 6E 73 74 61 6C 6C 
1A137A8 	2D 64 65 63 6F 6D 70 8E 
1A137B0 	E4 24 A1  1 20 40 A0  1 
   ['] dummy ['] do-scan          (patch
1A137B8 	60 53 A0  1 6C 35 A1  1 
1A137C0 	60 53 A0  1  0 37 A1  1 
1A137C8 	6C  5 A1  1 
   ['] dummy ['] .execution-class (patch
1A137CC 	60 53 A0  1 
1A137D0 	6C 35 A1  1 60 53 A0  1 
1A137D8 	54 36 A1  1 6C  5 A1  1 
   ['] dummy ['] execution-class >body na1+
1A137E0 	60 53 A0  1 6C 35 A1  1 
1A137E8 	60 53 A0  1 A4 35 A1  1 
1A137F0 	E4 59 A0  1 CC 50 A0  1 
	       dup [ #decomp-classes ] literal ta+ tsearch
1A137F8 	40 49 A0  1 58 41 A0  1 
1A13800 	24  0  0  0 60 50 A0  1 
1A13808 	A4  0 A1  1 
   drop token!
1A1380C 	30 49 A0  1 
1A13810 	20 54 A0  1 
;
1A13814 	58 46 A0  1 
previous definitions
headerless

\ Scan the parameter field of a colon definition and determine the
\ places where control is transferred.
: scan-pf   ( apf -- )
1A13818 	73 63 61 6E 2D 70 66 87 
1A13820 	 0 37 A1  1 20 40 A0  1 
   dup extent !                           ( apf )
1A13828 	40 49 A0  1 8C 28 A1  1 
1A13830 	54 4D A0  1 
   breaks end-breaks !                    ( apf )
1A13834 	EC 25 A1  1 
1A13838 	 C 26 A1  1 54 4D A0  1 
   begin                                  ( adr )
      dup token@ execution-class do-scan  ( adr' )
1A13840 	40 49 A0  1  C 54 A0  1 
1A13848 	A4 35 A1  1  0 37 A1  1 
      dup 0=                              ( adr' flag )
1A13850 	40 49 A0  1 24 47 A0  1 
   until                                  ( adr )
1A13858 	DC 41 A0  1 E4 FF FF FF 
   drop
1A13860 	30 49 A0  1 
;
1A13864 	58 46 A0  1 

forth definitions
headers
: .token  ( ip -- ip' )  dup token@ execution-class .execution-class  ;
1A13868 	 0 2E 74 6F 6B 65 6E 86 
1A13870 	B4 37 A1  1 20 40 A0  1 
1A13878 	40 49 A0  1  C 54 A0  1 
1A13880 	A4 35 A1  1 54 36 A1  1 
1A13888 	58 46 A0  1 
\ Decompile the parameter field of colon definition
: .pf   ( apf -- )
1A1388C 	2E 70 66 83 
1A13890 	74 38 A1  1 20 40 A0  1 
   init-positions                                     ( apf )
1A13898 	 8 21 A1  1 
   dup scan-pf next-break 3 lmargin ! indent          ( apf )
1A1389C 	40 49 A0  1 
1A138A0 	24 38 A1  1 6C 26 A1  1 
1A138A8 	A0 6F A0  1 80 13 A1  1 
1A138B0 	54 4D A0  1 C8 22 A1  1 
   begin                                              ( adr )
      dup is decompiler-ip                            ( adr )
1A138B8 	40 49 A0  1 B8 40 A0  1 
1A138C0 	A4 21 A1  1 
      ?cr                                             ( adr )
1A138C4 	E8 13 A1  1 
      break-addr @ over =  if                         ( adr )
1A138C8 	3C 26 A1  1 5C 4C A0  1 
1A138D0 	54 49 A0  1 24 48 A0  1 
1A138D8 	DC 41 A0  1 34  0  0  0 
	 begin                                        ( adr )
	    break-type @ execute                      ( adr )
1A138E0 	24 26 A1  1 5C 4C A0  1 
1A138E8 	98 41 A0  1 
	    next-break  break-addr @ over <>          ( adr done? )
1A138EC 	6C 26 A1  1 
1A138F0 	3C 26 A1  1 5C 4C A0  1 
1A138F8 	54 49 A0  1 44 48 A0  1 
	 until                                        ( adr )
1A13900 	DC 41 A0  1 DC FF FF FF 
      else                                            ( adr )
1A13908 	C8 41 A0  1  8  0  0  0 
         .token                                       ( adr' )
1A13910 	74 38 A1  1 
      then                                            ( adr' )
      dup 0=  exit?  if  nullstring throw  then       ( adr' )
1A13914 	40 49 A0  1 
1A13918 	24 47 A0  1 34  D A1  1 
1A13920 	DC 41 A0  1  C  0  0  0 
1A13928 	9C 8A A0  1 74 7F A0  1 
   until  drop                                        (  )
1A13930 	DC 41 A0  1 84 FF FF FF 
1A13938 	30 49 A0  1 
;
1A1393C 	58 46 A0  1 
headerless
hidden definitions

: .immediate  ( acf -- )   immediate? if   .." immediate"   then   ;
1A13940 	 0 2E 69 6D 6D 65 64 69 
1A13948 	61 74 65 8A 24 38 A1  1 
1A13950 	20 40 A0  1 FC B8 A0  1 
1A13958 	DC 41 A0  1 18  0  0  0 
1A13960 	9C 53 A0  1  9 69 6D 6D 
1A13968 	65 64 69 61 74 65  0  0 
1A13970 	60 23 A1  1 58 46 A0  1 

: .definer    ( acf definer-acf -- acf )
1A13978 	 0  0  0 2E 64 65 66 69 
1A13980 	6E 65 72 88 50 39 A1  1 
1A13988 	20 40 A0  1 
   magenta-letters .name  dup blue-letters  .name  cancel
1A1398C 	14 FA A0  1 
1A13990 	C8 9A A0  1 40 49 A0  1 
1A13998 	F8 F9 A0  1 C8 9A A0  1 
1A139A0 	BC F7 A0  1 
;
1A139A4 	58 46 A0  1 

: dump-body  ( pfa -- )
1A139A8 	 0  0 64 75 6D 70 2D 62 
1A139B0 	6F 64 79 89 88 39 A1  1 
1A139B8 	20 40 A0  1 
   push-hex
1A139BC 	5C F4 A0  1 
   dup @ pretty-. 2 spaces  8 emit.ln
1A139C0 	40 49 A0  1 5C 4C A0  1 
1A139C8 	84 30 A1  1 90 6F A0  1 
1A139D0 	E8 71 A0  1 F0 6F A0  1 
1A139D8 	D8 1A A1  1 
   pop-base
1A139DC 	9C F4 A0  1 
;
1A139E0 	58 46 A0  1 
\ Display category of word
: .:           ( acf definer -- )  .definer cr ( space space ) >body  .pf   ;
1A139E4 	 0 2E 3A 82 
1A139E8 	B8 39 A1  1 20 40 A0  1 
1A139F0 	88 39 A1  1 80 6D A0  1 
1A139F8 	E4 59 A0  1 94 38 A1  1 
1A13A00 	58 46 A0  1 
: debug-see    ( apf -- )
1A13A04 	 0  0 64 65 
1A13A08 	62 75 67 2D 73 65 65 89 
1A13A10 	EC 39 A1  1 20 40 A0  1 
   page-mode? >r  no-page
1A13A18 	 8  8 A1  1 BC 45 A0  1 
1A13A20 	1C  8 A1  1 
   find-cfa ['] :  .:
1A13A24 	24 20 A1  1 
1A13A28 	60 53 A0  1 90 A6 A0  1 
1A13A30 	EC 39 A1  1 
   r> is page-mode?
1A13A34 	D0 45 A0  1 
1A13A38 	B8 40 A0  1  8  8 A1  1 
;
1A13A40 	58 46 A0  1 
: .constant    ( acf definer -- )  over >data @ pretty-.  .definer drop  ;
1A13A44 	 0  0 2E 63 
1A13A48 	6F 6E 73 74 61 6E 74 89 
1A13A50 	14 3A A1  1 20 40 A0  1 
1A13A58 	54 49 A0  1 6C C7 A0  1 
1A13A60 	5C 4C A0  1 84 30 A1  1 
1A13A68 	88 39 A1  1 30 49 A0  1 
1A13A70 	58 46 A0  1 
: .2constant   ( acf definer -- )  over >data dup @ pretty-.  na1+ @ pretty-. .definer drop  ;
1A13A74 	 0 2E 32 63 
1A13A78 	6F 6E 73 74 61 6E 74 8A 
1A13A80 	54 3A A1  1 20 40 A0  1 
1A13A88 	54 49 A0  1 6C C7 A0  1 
1A13A90 	40 49 A0  1 5C 4C A0  1 
1A13A98 	84 30 A1  1 CC 50 A0  1 
1A13AA0 	5C 4C A0  1 84 30 A1  1 
1A13AA8 	88 39 A1  1 30 49 A0  1 
1A13AB0 	58 46 A0  1 
: .vocabulary  ( acf definer -- )  .definer drop  ;
1A13AB4 	2E 76 6F 63 
1A13AB8 	61 62 75 6C 61 72 79 8B 
1A13AC0 	84 3A A1  1 20 40 A0  1 
1A13AC8 	88 39 A1  1 30 49 A0  1 
1A13AD0 	58 46 A0  1 
: .code        ( acf definer -- )  .definer >code disassemble  ;
1A13AD4 	 0  0 2E 63 
1A13AD8 	6F 64 65 85 C4 3A A1  1 
1A13AE0 	20 40 A0  1 88 39 A1  1 
1A13AE8 	 0 5A A0  1 C4 25 A1  1 
1A13AF0 	58 46 A0  1 
: .variable    ( acf definer -- )
1A13AF4 	 0  0 2E 76 
1A13AF8 	61 72 69 61 62 6C 65 89 
1A13B00 	E0 3A A1  1 20 40 A0  1 
   over >data n.   .definer   ." value = " >data @ pretty-.
1A13B08 	54 49 A0  1 6C C7 A0  1 
1A13B10 	D0 7A A0  1 88 39 A1  1 
1A13B18 	20 7C A0  1  8 76 61 6C 
1A13B20 	75 65 20 3D 20  0  0  0 
1A13B28 	6C C7 A0  1 5C 4C A0  1 
1A13B30 	84 30 A1  1 
;
1A13B34 	58 46 A0  1 
: .create     ( acf definer -- )
1A13B38 	2E 63 72 65 61 74 65 87 
1A13B40 	 4 3B A1  1 20 40 A0  1 
   over >body n.   .definer   ." value = " >body dump-body
1A13B48 	54 49 A0  1 E4 59 A0  1 
1A13B50 	D0 7A A0  1 88 39 A1  1 
1A13B58 	20 7C A0  1  8 76 61 6C 
1A13B60 	75 65 20 3D 20  0  0  0 
1A13B68 	E4 59 A0  1 B8 39 A1  1 
;
1A13B70 	58 46 A0  1 
: .user        ( acf definer -- )
1A13B74 	 0  0 2E 75 
1A13B78 	73 65 72 85 44 3B A1  1 
1A13B80 	20 40 A0  1 
   over >body @ n.   .definer   ."  value = "   >data @ pretty-.
1A13B84 	54 49 A0  1 
1A13B88 	E4 59 A0  1 5C 4C A0  1 
1A13B90 	D0 7A A0  1 88 39 A1  1 
1A13B98 	20 7C A0  1  9 20 76 61 
1A13BA0 	6C 75 65 20 3D 20  0  0 
1A13BA8 	6C C7 A0  1 5C 4C A0  1 
1A13BB0 	84 30 A1  1 
;
1A13BB4 	58 46 A0  1 
: .defer       ( acf definer -- )
1A13BB8 	 0 2E 64 65 66 65 72 86 
1A13BC0 	80 3B A1  1 20 40 A0  1 
   .definer  ." is " cr  >data token@ (see)
1A13BC8 	88 39 A1  1 20 7C A0  1 
1A13BD0 	 3 69 73 20  0  0  0  0 
1A13BD8 	80 6D A0  1 6C C7 A0  1 
1A13BE0 	 C 54 A0  1 98 20 A1  1 
;
1A13BE8 	58 46 A0  1 
: .alias       ( acf definer -- )
1A13BEC 	 0 2E 61 6C 
1A13BF0 	69 61 73 86 C4 3B A1  1 
1A13BF8 	20 40 A0  1 
   .definer >body token@ .name
1A13BFC 	88 39 A1  1 
1A13C00 	E4 59 A0  1  C 54 A0  1 
1A13C08 	C8 9A A0  1 
;
1A13C0C 	58 46 A0  1 
: .value      ( acf definer -- )
1A13C10 	 0 2E 76 61 6C 75 65 86 
1A13C18 	F8 3B A1  1 20 40 A0  1 
   swap >data @ pretty-. .definer
1A13C20 	68 49 A0  1 6C C7 A0  1 
1A13C28 	5C 4C A0  1 84 30 A1  1 
1A13C30 	88 39 A1  1 
;
1A13C34 	58 46 A0  1 


\ Decompile a word whose type is not one of those listed in
\ definition-class.  These include does> and ;code words which
\ are not explicitly recognized in definition-class.
: .other   ( acf definer -- )
1A13C38 	 0 2E 6F 74 68 65 72 86 
1A13C40 	1C 3C A1  1 20 40 A0  1 
   .definer   >body ."    (Body: " dump-body ."  ) " cr
1A13C48 	88 39 A1  1 E4 59 A0  1 
1A13C50 	20 7C A0  1  A 20 20 20 
1A13C58 	28 42 6F 64 79 3A 20  0 
1A13C60 	B8 39 A1  1 20 7C A0  1 
1A13C68 	 3 20 29 20  0  0  0  0 
1A13C70 	80 6D A0  1 
;
1A13C74 	58 46 A0  1 

\ Classify a word based on its acf
alias  isalias  noop
1A13C78 	69 73 61 6C 69 61 73 A7 
1A13C80 	44 3C A1  1 64 4F A0  1 
create iscreate
1A13C88 	 0  0  0 69 73 63 72 65 
1A13C90 	61 74 65 88 84 3C A1  1 
1A13C98 	30 40 A0  1 
0 0 2constant is2cons
1A13C9C 	69 73 32 63 
1A13CA0 	6F 6E 73 87 98 3C A1  1 
1A13CA8 	70 40 A0  1  0  0  0  0 
1A13CB0 	 0  0  0  0 

: wt,  \ name  ( -- )  \ Compile name's word type
1A13CB4 	77 74 2C 83 
1A13CB8 	A8 3C A1  1 20 40 A0  1 
   ' word-type token,
1A13CC0 	F8 95 A0  1 B0 59 A0  1 
1A13CC8 	2C 55 A0  1 
;
1A13CCC 	58 46 A0  1 

d# 10 tassociative: word-types
1A13CD0 	 0 77 6F 72 64 2D 74 79 
1A13CD8 	70 65 73 8A BC 3C A1  1 
1A13CE0 	F4 24 A1  1  A  0  0  0 
   ( 0 )   wt, here        ( 1 )   wt, bl
1A13CE8 	20 40 A0  1 68 40 A0  1 
   ( 2 )   wt, isvar       ( 3 )   wt, base
1A13CF0 	48 40 A0  1 48 40 A0  1 
   ( 4 )   wt, emit        ( 5 )   wt, iscreate
1A13CF8 	5C 40 A0  1 30 40 A0  1 
   ( 6 )   wt, forth       ( 7 )   wt, isalias
1A13D00 	E0 B6 A0  1 68 4F A0  1 
   ( 8 )   wt, isval       ( 9 )   wt, is2cons
1A13D08 	50 40 A0  1 70 40 A0  1 

: cf,  \ name  ( -- )  \ Compile name's code field
1A13D10 	63 66 2C 83 E0 3C A1  1 
1A13D18 	20 40 A0  1 
   ' token,
1A13D1C 	F8 95 A0  1 
1A13D20 	2C 55 A0  1 
;
1A13D24 	58 46 A0  1 
d# 12 constant #definition-classes
1A13D28 	23 64 65 66 69 6E 69 74 
1A13D30 	69 6F 6E 2D 63 6C 61 73 
1A13D38 	73 65 73 93 18 3D A1  1 
1A13D40 	68 40 A0  1  C  0  0  0 
#definition-classes tassociative: definition-class
1A13D48 	 0  0  0 64 65 66 69 6E 
1A13D50 	69 74 69 6F 6E 2D 63 6C 
1A13D58 	61 73 73 90 40 3D A1  1 
1A13D60 	F4 24 A1  1  C  0  0  0 
   ( 0 )   cf,  :          ( 1 )   cf,  constant
1A13D68 	90 A6 A0  1 30 A7 A0  1 
   ( 2 )   cf,  variable   ( 3 )   cf,  user
1A13D70 	94 F2 A0  1  4 9A A0  1 
   ( 4 )   cf,  defer      ( 5 )   cf,  create
1A13D78 	44 A8 A0  1 A8 A2 A0  1 
   ( 6 )   cf,  vocabulary ( 7 )   cf,  alias
1A13D80 	28 B7 A0  1  8 E0 A0  1 
   ( 8 )   cf,  value      ( 9 )   cf,  2constant
1A13D88 	50 A7 A0  1 78 A8 A0  1 
   ( 10)   cf,  code       ( 11 )  cf,  dummy
1A13D90 	8C A3 A0  1 6C 35 A1  1 

#definition-classes 1+ case: .definition-class
1A13D98 	 0  0 2E 64 65 66 69 6E 
1A13DA0 	69 74 69 6F 6E 2D 63 6C 
1A13DA8 	61 73 73 91 60 3D A1  1 
1A13DB0 	B8 24 A1  1  D  0  0  0 
   ( 0 )   .:              ( 1 )   .constant
1A13DB8 	EC 39 A1  1 54 3A A1  1 
   ( 2 )   .variable       ( 3 )   .user
1A13DC0 	 4 3B A1  1 80 3B A1  1 
   ( 4 )   .defer          ( 5 )   .create
1A13DC8 	C4 3B A1  1 44 3B A1  1 
   ( 6 )   .vocabulary     ( 7 )   .alias
1A13DD0 	C4 3A A1  1 F8 3B A1  1 
   ( 8 )   .value          ( 9 )   .2constant
1A13DD8 	1C 3C A1  1 84 3A A1  1 
   ( 10)   .code           ( 11)   dummy
1A13DE0 	E0 3A A1  1 6C 35 A1  1 
   ( 12)   .other
1A13DE8 	44 3C A1  1 
;
1A13DEC 	58 46 A0  1 

headers
also forth definitions
: install-decomp-definer  ( definer-acf display-acf -- )
1A13DF0 	 0 69 6E 73 74 61 6C 6C 
1A13DF8 	2D 64 65 63 6F 6D 70 2D 
1A13E00 	64 65 66 69 6E 65 72 96 
1A13E08 	94 38 A1  1 20 40 A0  1 
   ['] dummy ['] .definition-class (patch
1A13E10 	60 53 A0  1 6C 35 A1  1 
1A13E18 	60 53 A0  1 B0 3D A1  1 
1A13E20 	6C  5 A1  1 
   ['] dummy ['] definition-class >body na1+
1A13E24 	60 53 A0  1 
1A13E28 	6C 35 A1  1 60 53 A0  1 
1A13E30 	60 3D A1  1 E4 59 A0  1 
1A13E38 	CC 50 A0  1 
	       dup [ #definition-classes ] literal ta+ tsearch
1A13E3C 	40 49 A0  1 
1A13E40 	58 41 A0  1  C  0  0  0 
1A13E48 	60 50 A0  1 A4  0 A1  1 
   drop token!
1A13E50 	30 49 A0  1 20 54 A0  1 
;
1A13E58 	58 46 A0  1 
previous definitions
headerless


: does/;code-xt?  ( xt -- flag )
1A13E5C 	 0 64 6F 65 
1A13E60 	73 2F 3B 63 6F 64 65 2D 
1A13E68 	78 74 3F 8E B0 3D A1  1 
1A13E70 	20 40 A0  1 
   dup  ['] (does>) =  swap  ['] (;code) =  or
1A13E74 	40 49 A0  1 
1A13E78 	60 53 A0  1 50 A3 A0  1 
1A13E80 	24 48 A0  1 68 49 A0  1 
1A13E88 	60 53 A0  1 2C A3 A0  1 
1A13E90 	24 48 A0  1 70 44 A0  1 
;
1A13E98 	58 46 A0  1 
: does/;code-action?  ( action-acf -- flag )
1A13E9C 	 0 64 6F 65 
1A13EA0 	73 2F 3B 63 6F 64 65 2D 
1A13EA8 	61 63 74 69 6F 6E 3F 92 
1A13EB0 	70 3E A1  1 20 40 A0  1 
   dup -1 ta+ token@ does/;code-xt?  if  drop true exit  then
1A13EB8 	40 49 A0  1 58 41 A0  1 
1A13EC0 	FF FF FF FF 60 50 A0  1 
1A13EC8 	 C 54 A0  1 70 3E A1  1 
1A13ED0 	DC 41 A0  1 10  0  0  0 
1A13ED8 	30 49 A0  1  4 70 A0  1 
1A13EE0 	40 46 A0  1 
   -2 ta+ token@ does/;code-xt?
1A13EE4 	58 41 A0  1 
1A13EE8 	FE FF FF FF 60 50 A0  1 
1A13EF0 	 C 54 A0  1 70 3E A1  1 
;
1A13EF8 	58 46 A0  1 
: no-objects  ( action-acf -- 'lose )  drop  ['] lose  ;
1A13EFC 	 0 6E 6F 2D 
1A13F00 	6F 62 6A 65 63 74 73 8A 
1A13F08 	B4 3E A1  1 20 40 A0  1 
1A13F10 	30 49 A0  1 60 53 A0  1 
1A13F18 	90 9B A0  1 58 46 A0  1 
headers
defer object-definer  ' no-objects is object-definer
1A13F20 	 0 6F 62 6A 65 63 74 2D 
1A13F28 	64 65 66 69 6E 65 72 8E 
1A13F30 	 C 3F A1  1 5C 40 A0  1 
1A13F38 	94  3  0  0 
: definer  ( acf-of-child -- acf-of-defining-word )
1A13F3C 	64 65 66 69 
1A13F40 	6E 65 72 87 34 3F A1  1 
1A13F48 	20 40 A0  1 
   dup code?  if  drop ['] code   exit then            ( acf )
1A13F4C 	40 49 A0  1 
1A13F50 	18 5A A0  1 DC 41 A0  1 
1A13F58 	14  0  0  0 30 49 A0  1 
1A13F60 	60 53 A0  1 8C A3 A0  1 
1A13F68 	40 46 A0  1 
   dup word-type word-types                            ( acf index )
1A13F6C 	40 49 A0  1 
1A13F70 	B0 59 A0  1 E0 3C A1  1 
   dup ['] word-types #entries  =  if                  ( acf index )
1A13F78 	40 49 A0  1 60 53 A0  1 
1A13F80 	E0 3C A1  1 74 25 A1  1 
1A13F88 	24 48 A0  1 DC 41 A0  1 
1A13F90 	34  0  0  0 
      drop word-type                                   ( action-acf )
1A13F94 	30 49 A0  1 
1A13F98 	B0 59 A0  1 
      dup does/;code-action?  if                       ( action-acf )
1A13F9C 	40 49 A0  1 
1A13FA0 	B4 3E A1  1 DC 41 A0  1 
1A13FA8 	10  0  0  0 
         find-cfa                                      ( definer )
1A13FAC 	24 20 A1  1 
      else                                             ( action-acf )
1A13FB0 	C8 41 A0  1  8  0  0  0 
         object-definer                                ( definer )
1A13FB8 	34 3F A1  1 
      then                                             ( definer )
   else                                                ( acf index )
1A13FBC 	C8 41 A0  1 
1A13FC0 	1C  0  0  0 
      nip  ['] definition-class >body maptoken token@  ( definer )
1A13FC4 	FC 46 A0  1 
1A13FC8 	60 53 A0  1 60 3D A1  1 
1A13FD0 	E4 59 A0  1 58 24 A1  1 
1A13FD8 	 C 54 A0  1 
   then
;
1A13FDC 	58 46 A0  1 
headerless

\ top level of the decompiler SEE
: ((see   ( acf -- )
1A13FE0 	 0  0 28 28 73 65 65 85 
1A13FE8 	48 3F A1  1 20 40 A0  1 
   d# 48 rmargin !
1A13FF0 	58 41 A0  1 30  0  0  0 
1A13FF8 	94 13 A1  1 54 4D A0  1 
   dup dup definer dup   definition-class .definition-class
1A14000 	40 49 A0  1 40 49 A0  1 
1A14008 	48 3F A1  1 40 49 A0  1 
1A14010 	60 3D A1  1 B0 3D A1  1 
   .immediate
1A14018 	50 39 A1  1 
   ??cr
1A1401C 	 0 A1 A0  1 
;
1A14020 	58 46 A0  1 
headers
' ((see  is (see)

forth definitions

: see  \ name  ( -- )
1A14024 	73 65 65 83 
1A14028 	 C 3E A1  1 20 40 A0  1 
   '  ['] (see) catch  if  drop  then
1A14030 	F8 95 A0  1 60 53 A0  1 
1A14038 	98 20 A1  1 14 7F A0  1 
1A14040 	DC 41 A0  1  8  0  0  0 
1A14048 	30 49 A0  1 
;
1A1404C 	58 46 A0  1 
only forth also definitions
end-module

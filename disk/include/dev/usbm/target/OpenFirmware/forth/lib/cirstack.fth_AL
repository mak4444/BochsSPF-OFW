id: @(#)cirstack.fth 1.6 03/12/08 13:22:21
purpose: 

\ Circular stack defining words
\
\ 10 cirstack: foo    Create a new stack named foo with space for 10 numbers
\ 123 foo push        Push the number 123 on the stack foo
\ foo pop             Pop the top element from the stack foo onto the data stack
\
\ Advantages of a circular stack:
\    does not have to be cleared
\    cannot overflow or underflow
\
\ Disadvantages:
\    can silently lose data
\    implementation is cumbersome
\
\ Applications:
\    Useful for implementing user interfaces where you want to remember a
\    limited amount of "history", such as the last n commands, or the
\    last n directories "visited", but it is not necessary to guarantee
\    unlimited backtracking.

\ Implementation notes:
\    The circular stack data structure contains the following elements:
\        stack data   Space to store the stacked numbers
\        current      Offset into stack data of the next element to pop
\        limit        Size of stack data plus 1 cell
\
\    The elements are located as follows:
\        pfa:   user#   limit
\
\    user# is the offset of a user area location containing the address of
\    an allocated memory buffer.  That buffer contains "current" and "stack
\    data".
\
\    Note that this parameter field is intentionally the same as the parameter
\    field of word defined by "buffer:".  This allows us to automatically
\    allocate the necessary storage space using the buffer: mechanism.
\
\        user area location:  buffer-address
\        buffer-address:      current   stack-data ...

headerless
\ Implementation factor
: stack-params  ( stack -- adr limit current )
1A105D0 	 0  0  0 73 74 61 63 6B 
1A105D8 	2D 70 61 72 61 6D 73 8C 
1A105E0 	B8  5 A1  1 20 40 A0  1 
   dup  /user# + unaligned-@  /n -  ( stack limit )
1A105E8 	40 49 A0  1 40 5A A0  1 
1A105F0 	 4 45 A0  1 E0 4C A0  1 
1A105F8 	40 51 A0  1 18 45 A0  1 
   swap do-buffer                   ( limit adr )
1A10600 	68 49 A0  1 34 A9 A0  1 
   tuck @                           ( adr limit current )
1A10608 	E8 46 A0  1 5C 4C A0  1 
;
1A10610 	58 46 A0  1 
headers

\ Creates a new stack
: circular-stack:  \ name  ( #entries -- )
1A10614 	63 69 72 63 
1A10618 	75 6C 61 72 2D 73 74 61 
1A10620 	63 6B 3A 8F E4  5 A1  1 
1A10628 	20 40 A0  1 
   create
1A1062C 	A8 A2 A0  1 
   here body> swap    ( acf #entries )
1A10630 	70 54 A0  1 C8 59 A0  1 
1A10638 	68 49 A0  1 
   1+ /n*             ( acf size )
1A1063C 	30 4B A0  1 
1A10640 	98 51 A0  1 
   0 /n user#,  !     ( acf size )  ,   ( acf )
1A10644 	70 6F A0  1 
1A10648 	40 51 A0  1 84 9A A0  1 
1A10650 	54 4D A0  1 98 55 A0  1 
   buffer-link a@  a,  buffer-link a!
1A10658 	D0 A8 A0  1 88 58 A0  1 
1A10660 	AC 58 A0  1 D0 A8 A0  1 
1A10668 	98 58 A0  1 
;
1A1066C 	58 46 A0  1 

\ Adds a number to the stack
: push  ( n stack -- )
1A10670 	 0  0  0 70 75 73 68 84 
1A10678 	28  6 A1  1 20 40 A0  1 
   stack-params  na1+       ( n adr limit next )
1A10680 	E4  5 A1  1 CC 50 A0  1 
   tuck  <=  if             ( n adr next )
1A10688 	E8 46 A0  1  C 49 A0  1 
1A10690 	DC 41 A0  1  C  0  0  0 
      drop 0                ( n adr next' )     \ Wrap around
1A10698 	30 49 A0  1 70 6F A0  1 
   then                     ( n adr next' )
   2dup swap !              ( n adr next' )
1A106A0 	C0 49 A0  1 68 49 A0  1 
1A106A8 	54 4D A0  1 
   + na1+ !
1A106AC 	 4 45 A0  1 
1A106B0 	CC 50 A0  1 54 4D A0  1 
;
1A106B8 	58 46 A0  1 

\ Removes a number from the stack
: pop  ( stack -- n )
1A106BC 	70 6F 70 83 
1A106C0 	7C  6 A1  1 20 40 A0  1 
   stack-params             ( adr limit current )
1A106C8 	E4  5 A1  1 
   ?dup  if                 ( adr limit current )
1A106CC 	B4 70 A0  1 
1A106D0 	DC 41 A0  1 28  0  0  0 
      nip 2dup /n - swap !  ( adr current )     \ Decrement current
1A106D8 	FC 46 A0  1 C0 49 A0  1 
1A106E0 	40 51 A0  1 18 45 A0  1 
1A106E8 	68 49 A0  1 54 4D A0  1 
      +                     ( data-adr- )
1A106F0 	 4 45 A0  1 
   else                     ( adr limit )
1A106F4 	C8 41 A0  1 
1A106F8 	14  0  0  0 
      /n - over !           ( data-adr- )       \ Wrap around
1A106FC 	40 51 A0  1 
1A10700 	18 45 A0  1 54 49 A0  1 
1A10708 	54 4D A0  1 
   then
   na1+ @
1A1070C 	CC 50 A0  1 
1A10710 	5C 4C A0  1 
;
1A10714 	58 46 A0  1 

\ Returns, without popping, the number on top of the stack
: top@  ( stack -- n )
1A10718 	 0  0  0 74 6F 70 40 84 
1A10720 	C4  6 A1  1 20 40 A0  1 
   stack-params             ( adr limit current )
1A10728 	E4  5 A1  1 
   dup  if                  ( adr limit current )
1A1072C 	40 49 A0  1 
1A10730 	DC 41 A0  1 14  0  0  0 
      nip  +                ( data-adr- )
1A10738 	FC 46 A0  1  4 45 A0  1 
   else                     ( adr limit current )
1A10740 	C8 41 A0  1  8  0  0  0 
      2drop                 ( data-adr- )       \ Wrap around
1A10748 	AC 49 A0  1 
   then
   na1+ @
1A1074C 	CC 50 A0  1 
1A10750 	5C 4C A0  1 
;
1A10754 	58 46 A0  1 

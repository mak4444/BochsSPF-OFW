\ From io.fth

decimal

\ Emit is a two-level vector.
\ The low level is (emit and the high level is emit.
\ The low-level vector just selects the output device.
\ The high-level vector performs other processing such as keeping
\ track of the current position on the line, pausing, etc.
\ Terminal control with escape sequences should use the low-level vector
\ to prevent a pause from garbling the escape sequence.
\ Key is a two-level vector.
\ The low level is (key and the high level is key.
\ The low-level vector just selects the output device.
\ The high-level vector performs other processing such as switching
\ the input stream between different windows.

defer (type  ( adr len -- ) \ Low-level type; just outputs characters
1A06BE4 	 0  0 28 74 
1A06BE8 	79 70 65 85 CC 6B A0  1 
1A06BF0 	5C 40 A0  1 60  0  0  0 
defer type   ( adr len -- ) \ High-level type
1A06BF8 	 0  0  0 74 79 70 65 84 
1A06C00 	F0 6B A0  1 5C 40 A0  1 
1A06C08 	64  0  0  0 
defer (emit ( c -- )   \ Low level emit; just puts out the character
1A06C0C 	 0  0 28 65 
1A06C10 	6D 69 74 85  4 6C A0  1 
1A06C18 	5C 40 A0  1 68  0  0  0 
defer emit  ( c -- )   \ Higher level; keeps track of position on the line, etc
1A06C20 	 0  0  0 65 6D 69 74 84 
1A06C28 	18 6C A0  1 5C 40 A0  1 
1A06C30 	6C  0  0  0 
defer (key  ( -- c )   \ Low level key; just gets key
1A06C34 	 0  0  0 28 
1A06C38 	6B 65 79 84 2C 6C A0  1 
1A06C40 	5C 40 A0  1 70  0  0  0 
defer key   ( -- c )   \ Higher level; may do other nonsense
1A06C48 	6B 65 79 83 40 6C A0  1 
1A06C50 	5C 40 A0  1 74  0  0  0 
defer key?   ( -- f )   \ Is a character waiting?
1A06C58 	 0  0  0 6B 65 79 3F 84 
1A06C60 	50 6C A0  1 5C 40 A0  1 
1A06C68 	78  0  0  0 
defer bye    ( -- )     \ Exit to the operating system, if any
1A06C6C 	62 79 65 83 
1A06C70 	64 6C A0  1 5C 40 A0  1 
1A06C78 	7C  0  0  0 
defer error-exit  ( -- )  \ Error exit to the operating system
1A06C7C 	 0 65 72 72 
1A06C80 	6F 72 2D 65 78 69 74 8A 
1A06C88 	74 6C A0  1 5C 40 A0  1 
1A06C90 	80  0  0  0 
defer (interactive? ( -- f ) \ Is input coming from the keyboard?
1A06C94 	 0  0 28 69 
1A06C98 	6E 74 65 72 61 63 74 69 
1A06CA0 	76 65 3F 8D 8C 6C A0  1 
1A06CA8 	5C 40 A0  1 84  0  0  0 
defer interactive? ( -- f ) \ Is input coming from the keyboard?
1A06CB0 	 0  0  0 69 6E 74 65 72 
1A06CB8 	61 63 74 69 76 65 3F 8C 
1A06CC0 	A8 6C A0  1 5C 40 A0  1 
1A06CC8 	88  0  0  0 
' (interactive? is interactive?

defer accept  ( adr len -- )	\ Read up to len characters from keyboard
1A06CCC 	 0 61 63 63 
1A06CD0 	65 70 74 86 C4 6C A0  1 
1A06CD8 	5C 40 A0  1 8C  0  0  0 

defer alloc-mem  ( #bytes -- address )
1A06CE0 	 0  0 61 6C 6C 6F 63 2D 
1A06CE8 	6D 65 6D 89 D8 6C A0  1 
1A06CF0 	5C 40 A0  1 90  0  0  0 
defer free-mem   ( adr #bytes -- )
1A06CF8 	 0  0  0 66 72 65 65 2D 
1A06D00 	6D 65 6D 88 F0 6C A0  1 
1A06D08 	5C 40 A0  1 94  0  0  0 
defer resize     ( adr #bytes -- adr' ior )
1A06D10 	 0 72 65 73 69 7A 65 86 
1A06D18 	 8 6D A0  1 5C 40 A0  1 
1A06D20 	98  0  0  0 

defer sync-cache  ( adr len -- )  ' 2drop is sync-cache
1A06D24 	 0 73 79 6E 
1A06D28 	63 2D 63 61 63 68 65 8A 
1A06D30 	1C 6D A0  1 5C 40 A0  1 
1A06D38 	9C  0  0  0 
defer $getenv     ( adr len -- false | adr' len' true )
1A06D3C 	24 67 65 74 
1A06D40 	65 6E 76 87 34 6D A0  1 
1A06D48 	5C 40 A0  1 A0  0  0  0 

defer #out   ( -- adr )
1A06D50 	 0  0  0 23 6F 75 74 84 
1A06D58 	48 6D A0  1 5C 40 A0  1 
1A06D60 	A4  0  0  0 
defer #line  ( -- adr )
1A06D64 	 0  0 23 6C 
1A06D68 	69 6E 65 85 5C 6D A0  1 
1A06D70 	5C 40 A0  1 A8  0  0  0 
defer cr     ( -- )
1A06D78 	 0 63 72 82 70 6D A0  1 
1A06D80 	5C 40 A0  1 AC  0  0  0 

defer [ immediate
1A06D88 	 0  0 5B C1 80 6D A0  1 
1A06D90 	5C 40 A0  1 B0  0  0  0 
defer ]
1A06D98 	 0  0 5D 81 90 6D A0  1 
1A06DA0 	5C 40 A0  1 B4  0  0  0 

defer pause  \ for multitasking
1A06DA8 	 0  0 70 61 75 73 65 85 
1A06DB0 	A0 6D A0  1 5C 40 A0  1 
1A06DB8 	B8  0  0  0 

defer $header
1A06DBC 	24 68 65 61 
1A06DC0 	64 65 72 87 B4 6D A0  1 
1A06DC8 	5C 40 A0  1 BC  0  0  0 

defer header		\ Create a new word
1A06DD0 	 0 68 65 61 64 65 72 86 
1A06DD8 	C8 6D A0  1 5C 40 A0  1 
1A06DE0 	C0  0  0  0 

: bounds  (s adr len -- adr+len adr )  over + swap  ;
1A06DE4 	 0 62 6F 75 
1A06DE8 	6E 64 73 86 DC 6D A0  1 
1A06DF0 	20 40 A0  1 54 49 A0  1 
1A06DF8 	 4 45 A0  1 68 49 A0  1 
1A06E00 	58 46 A0  1 

\ Default actions
: key1  ( -- char )  begin  pause key?  until  (key  ;
1A06E04 	 0  0  0 6B 
1A06E08 	65 79 31 84 F0 6D A0  1 
1A06E10 	20 40 A0  1 B4 6D A0  1 
1A06E18 	64 6C A0  1 DC 41 A0  1 
1A06E20 	F4 FF FF FF 40 6C A0  1 
1A06E28 	58 46 A0  1 
: emit1  ( char -- )  pause (emit 1 #out +!  ;
1A06E2C 	 0  0 65 6D 
1A06E30 	69 74 31 85 10 6E A0  1 
1A06E38 	20 40 A0  1 B4 6D A0  1 
1A06E40 	18 6C A0  1 58 41 A0  1 
1A06E48 	 1  0  0  0 5C 6D A0  1 
1A06E50 	 C 4C A0  1 58 46 A0  1 
: type1  ( adr len -- )  pause  dup #out +!  (type  ;
1A06E58 	 0  0 74 79 70 65 31 85 
1A06E60 	38 6E A0  1 20 40 A0  1 
1A06E68 	B4 6D A0  1 40 49 A0  1 
1A06E70 	5C 6D A0  1  C 4C A0  1 
1A06E78 	F0 6B A0  1 58 46 A0  1 
: default-type  ( adr len -- )
1A06E80 	 0  0  0 64 65 66 61 75 
1A06E88 	6C 74 2D 74 79 70 65 8C 
1A06E90 	64 6E A0  1 20 40 A0  1 
   0 max  bounds ?do  pause  i c@ (emit  loop
1A06E98 	58 41 A0  1  0  0  0  0 
1A06EA0 	9C 4A A0  1 F0 6D A0  1 
1A06EA8 	50 42 A0  1 1C  0  0  0 
1A06EB0 	B4 6D A0  1 B4 42 A0  1 
1A06EB8 	C4 4C A0  1 18 6C A0  1 
1A06EC0 	F8 41 A0  1 EC FF FF FF 
;
1A06EC8 	58 46 A0  1 
: null-$getenv  ( adr len -- true )  2drop true  ;
1A06ECC 	 0  0  0 6E 
1A06ED0 	75 6C 6C 2D 24 67 65 74 
1A06ED8 	65 6E 76 8C 94 6E A0  1 
1A06EE0 	20 40 A0  1 AC 49 A0  1 
1A06EE8 	CC 56 A0  1 58 46 A0  1 

\ headerless		\ from campus version
nuser (#out        \ number of characters emitted
1A06EF0 	 0  0 28 23 6F 75 74 85 
1A06EF8 	E0 6E A0  1 48 40 A0  1 
1A06F00 	C4  0  0  0 
\ headers		\ from campus version
nuser (#line       \ the number of lines sent so far
1A06F04 	 0 28 23 6C 
1A06F08 	69 6E 65 86 FC 6E A0  1 
1A06F10 	48 40 A0  1 C8  0  0  0 


\ Install defaults
' emit1       is emit
' type1       is type
' key1        is key
' (#out       is #out
' (#line      is #line
' null-$getenv  is $getenv

decimal

 7 constant bell
1A06F18 	 0  0  0 62 65 6C 6C 84 
1A06F20 	10 6F A0  1 68 40 A0  1 
1A06F28 	 7  0  0  0 
 8 constant bs
1A06F2C 	 0 62 73 82 
1A06F30 	24 6F A0  1 68 40 A0  1 
1A06F38 	 8  0  0  0 
10 constant linefeed
1A06F3C 	 0  0  0 6C 
1A06F40 	69 6E 65 66 65 65 64 88 
1A06F48 	34 6F A0  1 68 40 A0  1 
1A06F50 	 A  0  0  0 
13 constant carret
1A06F54 	 0 63 61 72 
1A06F58 	72 65 74 86 4C 6F A0  1 
1A06F60 	68 40 A0  1  D  0  0  0 


\ Kernel colon definitions
decimal
 0 constant 0     1 constant 1      2 constant 2      3 constant 3
1A06F68 	 0  0 30 81 60 6F A0  1 
1A06F70 	68 40 A0  1  0  0  0  0 
1A06F78 	 0  0 31 81 70 6F A0  1 
1A06F80 	68 40 A0  1  1  0  0  0 
1A06F88 	 0  0 32 81 80 6F A0  1 
1A06F90 	68 40 A0  1  2  0  0  0 
1A06F98 	 0  0 33 81 90 6F A0  1 
1A06FA0 	68 40 A0  1  3  0  0  0 
 4 constant 4     5 constant 5      6 constant 6      7 constant 7
1A06FA8 	 0  0 34 81 A0 6F A0  1 
1A06FB0 	68 40 A0  1  4  0  0  0 
1A06FB8 	 0  0 35 81 B0 6F A0  1 
1A06FC0 	68 40 A0  1  5  0  0  0 
1A06FC8 	 0  0 36 81 C0 6F A0  1 
1A06FD0 	68 40 A0  1  6  0  0  0 
1A06FD8 	 0  0 37 81 D0 6F A0  1 
1A06FE0 	68 40 A0  1  7  0  0  0 
 8 constant 8
1A06FE8 	 0  0 38 81 E0 6F A0  1 
1A06FF0 	68 40 A0  1  8  0  0  0 
-1 constant true  0 constant false \ mmo
1A06FF8 	 0  0  0 74 72 75 65 84 
1A07000 	F0 6F A0  1 68 40 A0  1 
1A07008 	FF FF FF FF  0  0 66 61 
1A07010 	6C 73 65 85  4 70 A0  1 
1A07018 	68 40 A0  1  0  0  0  0 
32 constant bl
1A07020 	 0 62 6C 82 18 70 A0  1 
1A07028 	68 40 A0  1 20  0  0  0 
\ 64 constant c/l

d# 1024 constant /tib
1A07030 	 0  0  0 2F 74 69 62 84 
1A07038 	28 70 A0  1 68 40 A0  1 
1A07040 	 0  4  0  0 

: roll    (s nk nk-1 ... n1 n0 k -- nk-1 ... n1 n0 nk )
1A07044 	 0  0  0 72 
1A07048 	6F 6C 6C 84 3C 70 A0  1 
1A07050 	20 40 A0  1 
   >r  r@ pick   sp@ dup  na1+
1A07054 	BC 45 A0  1 
1A07058 	E4 45 A0  1  C 4A A0  1 
1A07060 	6C 45 A0  1 40 49 A0  1 
1A07068 	CC 50 A0  1 
   r> 1+ /n*
1A0706C 	D0 45 A0  1 
1A07070 	30 4B A0  1 98 51 A0  1 
   cmove> drop
1A07078 	34 44 A0  1 30 49 A0  1 
;
1A07080 	58 46 A0  1 

: 2rot  (s a b c d e f -- c d e f a b )  5 roll  5 roll  ;
1A07084 	 0  0  0 32 
1A07088 	72 6F 74 84 50 70 A0  1 
1A07090 	20 40 A0  1 C0 6F A0  1 
1A07098 	50 70 A0  1 C0 6F A0  1 
1A070A0 	50 70 A0  1 58 46 A0  1 

: ?dup   (s n -- [n] n )  dup if   dup   then   ;
1A070A8 	 0  0  0 3F 64 75 70 84 
1A070B0 	90 70 A0  1 20 40 A0  1 
1A070B8 	40 49 A0  1 DC 41 A0  1 
1A070C0 	 8  0  0  0 40 49 A0  1 
1A070C8 	58 46 A0  1 
: between (s n min max -- f )  >r over <= swap r> <= and  ;
1A070CC 	62 65 74 77 
1A070D0 	65 65 6E 87 B4 70 A0  1 
1A070D8 	20 40 A0  1 BC 45 A0  1 
1A070E0 	54 49 A0  1  C 49 A0  1 
1A070E8 	68 49 A0  1 D0 45 A0  1 
1A070F0 	 C 49 A0  1 5C 44 A0  1 
1A070F8 	58 46 A0  1 
: within  (s n1 min max+1 -- f )  over -  >r - r> u<  ;
1A070FC 	 0 77 69 74 
1A07100 	68 69 6E 86 D8 70 A0  1 
1A07108 	20 40 A0  1 54 49 A0  1 
1A07110 	18 45 A0  1 BC 45 A0  1 
1A07118 	18 45 A0  1 D0 45 A0  1 
1A07120 	A8 48 A0  1 58 46 A0  1 

\ Obsolescent, but required by the IEEE 1275 device interface
nuser span			\ number of characters received by expect
1A07128 	 0  0  0 73 70 61 6E 84 
1A07130 	 8 71 A0  1 48 40 A0  1 
1A07138 	CC  0  0  0 
: expect  ( adr len -- )  accept span !  ;
1A0713C 	 0 65 78 70 
1A07140 	65 63 74 86 34 71 A0  1 
1A07148 	20 40 A0  1 D8 6C A0  1 
1A07150 	34 71 A0  1 54 4D A0  1 
1A07158 	58 46 A0  1 

defer newline-pstring
1A0715C 	6E 65 77 6C 
1A07160 	69 6E 65 2D 70 73 74 72 
1A07168 	69 6E 67 8F 48 71 A0  1 
1A07170 	5C 40 A0  1 D0  0  0  0 
: newline-string  ( -- adr len )  newline-pstring count  ;
1A07178 	 0 6E 65 77 6C 69 6E 65 
1A07180 	2D 73 74 72 69 6E 67 8E 
1A07188 	70 71 A0  1 20 40 A0  1 
1A07190 	70 71 A0  1 BC 53 A0  1 
1A07198 	58 46 A0  1 
: newline  ( -- char )  newline-string + 1-  c@  ; \ Last character
1A0719C 	6E 65 77 6C 
1A071A0 	69 6E 65 87 8C 71 A0  1 
1A071A8 	20 40 A0  1 8C 71 A0  1 
1A071B0 	 4 45 A0  1 54 4B A0  1 
1A071B8 	C4 4C A0  1 58 46 A0  1 

: space  (s -- )   bl emit   ;
1A071C0 	 0  0 73 70 61 63 65 85 
1A071C8 	A8 71 A0  1 20 40 A0  1 
1A071D0 	28 70 A0  1 2C 6C A0  1 
1A071D8 	58 46 A0  1 
: spaces   (s n -- )   0  max  0 ?do  space  loop  ;
1A071DC 	 0 73 70 61 
1A071E0 	63 65 73 86 CC 71 A0  1 
1A071E8 	20 40 A0  1 70 6F A0  1 
1A071F0 	9C 4A A0  1 70 6F A0  1 
1A071F8 	50 42 A0  1 10  0  0  0 
1A07200 	CC 71 A0  1 F8 41 A0  1 
1A07208 	F8 FF FF FF 58 46 A0  1 
: backspaces  (s n -- )  dup negate #out +!  0 ?do bs (emit loop  ;
1A07210 	 0 62 61 63 6B 73 70 61 
1A07218 	63 65 73 8A E8 71 A0  1 
1A07220 	20 40 A0  1 40 49 A0  1 
1A07228 	48 45 A0  1 5C 6D A0  1 
1A07230 	 C 4C A0  1 70 6F A0  1 
1A07238 	50 42 A0  1 14  0  0  0 
1A07240 	34 6F A0  1 18 6C A0  1 
1A07248 	F8 41 A0  1 F4 FF FF FF 
1A07250 	58 46 A0  1 
: beep  (s -- )  bell (emit  ;
1A07254 	 0  0  0 62 
1A07258 	65 65 70 84 20 72 A0  1 
1A07260 	20 40 A0  1 24 6F A0  1 
1A07268 	18 6C A0  1 58 46 A0  1 
: (lf  (s -- )  1 #line +!  linefeed (emit  ;
1A07270 	28 6C 66 83 60 72 A0  1 
1A07278 	20 40 A0  1 80 6F A0  1 
1A07280 	70 6D A0  1  C 4C A0  1 
1A07288 	4C 6F A0  1 18 6C A0  1 
1A07290 	58 46 A0  1 
: (cr  (s -- )  carret (emit  ;
1A07294 	28 63 72 83 
1A07298 	78 72 A0  1 20 40 A0  1 
1A072A0 	60 6F A0  1 18 6C A0  1 
1A072A8 	58 46 A0  1 
: lf   (s -- )  #out off  (lf  ;
1A072AC 	 0 6C 66 82 
1A072B0 	9C 72 A0  1 20 40 A0  1 
1A072B8 	5C 6D A0  1 F8 4B A0  1 
1A072C0 	78 72 A0  1 58 46 A0  1 
: crlf   (s -- )  (cr lf  ;
1A072C8 	 0  0  0 63 72 6C 66 84 
1A072D0 	B4 72 A0  1 20 40 A0  1 
1A072D8 	9C 72 A0  1 B4 72 A0  1 
1A072E0 	58 46 A0  1 


: erase      (s adr len -- )   0 fill   ;
1A072E4 	 0  0 65 72 
1A072E8 	61 73 65 85 D4 72 A0  1 
1A072F0 	20 40 A0  1 70 6F A0  1 
1A072F8 	8C 4E A0  1 58 46 A0  1 
: blank      (s adr len -- )   bl fill   ;
1A07300 	 0  0 62 6C 61 6E 6B 85 
1A07308 	F0 72 A0  1 20 40 A0  1 
1A07310 	28 70 A0  1 8C 4E A0  1 
1A07318 	58 46 A0  1 
: depth      (s -- n )         sp@ sp0 @ swap - /n /   ;
1A0731C 	 0  0 64 65 
1A07320 	70 74 68 85  C 73 A0  1 
1A07328 	20 40 A0  1 6C 45 A0  1 
1A07330 	8C 66 A0  1 5C 4C A0  1 
1A07338 	68 49 A0  1 18 45 A0  1 
1A07340 	40 51 A0  1 98 5F A0  1 
1A07348 	58 46 A0  1 
: clear      (s ?? -- Empty )  sp0 @ sp!  ;
1A0734C 	 0  0 63 6C 
1A07350 	65 61 72 85 28 73 A0  1 
1A07358 	20 40 A0  1 8C 66 A0  1 
1A07360 	5C 4C A0  1 9C 45 A0  1 
1A07368 	58 46 A0  1 

/a constant /link
1A0736C 	 0  0 2F 6C 
1A07370 	69 6E 6B 85 58 73 A0  1 
1A07378 	68 40 A0  1  4  0  0  0 

\ Address conversion operators
: n>link   ( anf -- alf )  1+  ;
1A07380 	 0 6E 3E 6C 69 6E 6B 86 
1A07388 	78 73 A0  1 20 40 A0  1 
1A07390 	30 4B A0  1 58 46 A0  1 
: l>name   ( alf -- anf )  1- ;
1A07398 	 0 6C 3E 6E 61 6D 65 86 
1A073A0 	8C 73 A0  1 20 40 A0  1 
1A073A8 	54 4B A0  1 58 46 A0  1 
: n>flags  ( anf -- aff )  ;
1A073B0 	6E 3E 66 6C 61 67 73 87 
1A073B8 	A4 73 A0  1 20 40 A0  1 
1A073C0 	58 46 A0  1 
: link>    ( alf -- acf )  /link +  ;
1A073C4 	 0  0 6C 69 
1A073C8 	6E 6B 3E 85 BC 73 A0  1 
1A073D0 	20 40 A0  1 78 73 A0  1 
1A073D8 	 4 45 A0  1 58 46 A0  1 
: >link    ( acf -- alf )  /link -  ;
1A073E0 	 0  0 3E 6C 69 6E 6B 85 
1A073E8 	D0 73 A0  1 20 40 A0  1 
1A073F0 	78 73 A0  1 18 45 A0  1 
1A073F8 	58 46 A0  1 
: name>    ( anf -- acf )  n>link link>  ;
1A073FC 	 0  0 6E 61 
1A07400 	6D 65 3E 85 EC 73 A0  1 
1A07408 	20 40 A0  1 8C 73 A0  1 
1A07410 	D0 73 A0  1 58 46 A0  1 
defer >name
1A07418 	 0  0 3E 6E 61 6D 65 85 
1A07420 	 8 74 A0  1 5C 40 A0  1 
1A07428 	D4  0  0  0 
: >flags   ( acf -- aff )  >name n>flags  ;
1A0742C 	 0 3E 66 6C 
1A07430 	61 67 73 86 24 74 A0  1 
1A07438 	20 40 A0  1 24 74 A0  1 
1A07440 	BC 73 A0  1 58 46 A0  1 
: name>string  ( anf -- adr len )  dup c@ h# 1f and  tuck - swap  ;
1A07448 	6E 61 6D 65 3E 73 74 72 
1A07450 	69 6E 67 8B 38 74 A0  1 
1A07458 	20 40 A0  1 40 49 A0  1 
1A07460 	C4 4C A0  1 58 41 A0  1 
1A07468 	1F  0  0  0 5C 44 A0  1 
1A07470 	E8 46 A0  1 18 45 A0  1 
1A07478 	68 49 A0  1 58 46 A0  1 
: l>beginning  ( alf -- adr )  l>name name>string drop  ;
1A07480 	6C 3E 62 65 67 69 6E 6E 
1A07488 	69 6E 67 8B 58 74 A0  1 
1A07490 	20 40 A0  1 A4 73 A0  1 
1A07498 	58 74 A0  1 30 49 A0  1 
1A074A0 	58 46 A0  1 
: @user#  (s apf -- user# )
1A074A4 	 0 40 75 73 
1A074A8 	65 72 23 86 90 74 A0  1 
1A074B0 	20 40 A0  1 
\t32  l@
1A074B4 	6C 4C A0  1 
\t16  w@
;
1A074B8 	58 46 A0  1 
: >user  (s pfa -- addr-of-user-var )  @user# up@ +  ;
1A074BC 	 0  0 3E 75 
1A074C0 	73 65 72 85 B0 74 A0  1 
1A074C8 	20 40 A0  1 B0 74 A0  1 
1A074D0 	5C 45 A0  1  4 45 A0  1 
1A074D8 	58 46 A0  1 
: >threads  ( acf -- ath )  >body >user  ;
1A074DC 	 0  0  0 3E 
1A074E0 	74 68 72 65 61 64 73 88 
1A074E8 	C8 74 A0  1 20 40 A0  1 
1A074F0 	E4 59 A0  1 C8 74 A0  1 
1A074F8 	58 46 A0  1 

0 value tib
1A074FC 	74 69 62 83 
1A07500 	EC 74 A0  1 50 40 A0  1 
1A07508 	D8  0  0  0 

0 value #-buf
1A0750C 	 0  0 23 2D 
1A07510 	62 75 66 85  4 75 A0  1 
1A07518 	50 40 A0  1 DC  0  0  0 
headerless
: init  ( -- )  init
1A07520 	 0  0  0 69 6E 69 74 84 
1A07528 	18 75 A0  1 20 40 A0  1 
1A07530 	B0 66 A0  1 
   [ /n h# 10 * 8 + ] literal dup alloc-mem + is #-buf
1A07534 	58 41 A0  1 
1A07538 	48  0  0  0 40 49 A0  1 
1A07540 	F0 6C A0  1  4 45 A0  1 
1A07548 	B8 65 A0  1 18 75 A0  1 
   /tib    alloc-mem   is tib
1A07550 	3C 70 A0  1 F0 6C A0  1 
1A07558 	B8 65 A0  1  4 75 A0  1 
;
1A07560 	58 46 A0  1 
headers

: compile,  (s cfa -- )  token, ;
1A07564 	 0  0  0 63 
1A07568 	6F 6D 70 69 6C 65 2C 88 
1A07570 	2C 75 A0  1 20 40 A0  1 
1A07578 	2C 55 A0  1 58 46 A0  1 
: compile  (s -- )   ip> dup ta1+ >ip   token@ compile,  ;
1A07580 	63 6F 6D 70 69 6C 65 87 
1A07588 	74 75 A0  1 20 40 A0  1 
1A07590 	84 46 A0  1 40 49 A0  1 
1A07598 	FC 50 A0  1 6C 46 A0  1 
1A075A0 	 C 54 A0  1 74 75 A0  1 
1A075A8 	58 46 A0  1 

nuser base         \ for numeric input and output
1A075AC 	 0  0  0 62 
1A075B0 	61 73 65 84 8C 75 A0  1 
1A075B8 	48 40 A0  1 E0  0  0  0 

nuser hld          \ points to last character held in #-buf
1A075C0 	68 6C 64 83 B8 75 A0  1 
1A075C8 	48 40 A0  1 E4  0  0  0 
: hold   (s char -- )   -1 hld +!   hld @ c!   ;
1A075D0 	 0  0  0 68 6F 6C 64 84 
1A075D8 	C8 75 A0  1 20 40 A0  1 
1A075E0 	58 41 A0  1 FF FF FF FF 
1A075E8 	C8 75 A0  1  C 4C A0  1 
1A075F0 	C8 75 A0  1 5C 4C A0  1 
1A075F8 	B8 4D A0  1 58 46 A0  1 
: <#     (s -- )     #-buf  hld  !  ;
1A07600 	 0 3C 23 82 DC 75 A0  1 
1A07608 	20 40 A0  1 18 75 A0  1 
1A07610 	C8 75 A0  1 54 4D A0  1 
1A07618 	58 46 A0  1 
: sign   (s n -- )  0< if  ascii -  hold  then  ;
1A0761C 	 0  0  0 73 
1A07620 	69 67 6E 84  8 76 A0  1 
1A07628 	20 40 A0  1 64 47 A0  1 
1A07630 	DC 41 A0  1 10  0  0  0 
1A07638 	58 41 A0  1 2D  0  0  0 
1A07640 	DC 75 A0  1 58 46 A0  1 
\ for upper case hex output, change 39 to 7
: >digit (s n -- char )  dup 9 >  if  39 +  then  48 +  ;
1A07648 	 0 3E 64 69 67 69 74 86 
1A07650 	28 76 A0  1 20 40 A0  1 
1A07658 	40 49 A0  1 58 41 A0  1 
1A07660 	 9  0  0  0  4 48 A0  1 
1A07668 	DC 41 A0  1 10  0  0  0 
1A07670 	58 41 A0  1 27  0  0  0 
1A07678 	 4 45 A0  1 58 41 A0  1 
1A07680 	30  0  0  0  4 45 A0  1 
1A07688 	58 46 A0  1 
: u#     (s u1 -- u2 )
1A0768C 	 0 75 23 82 
1A07690 	54 76 A0  1 20 40 A0  1 
   base @ u/mod  ( nrem u2 )   swap  >digit  hold    ( u2 )
1A07698 	B8 75 A0  1 5C 4C A0  1 
1A076A0 	74 5F A0  1 68 49 A0  1 
1A076A8 	54 76 A0  1 DC 75 A0  1 
;
1A076B0 	58 46 A0  1 
: u#s    (s u -- 0 )     begin  u#  dup   0=  until  ;
1A076B4 	75 23 73 83 
1A076B8 	94 76 A0  1 20 40 A0  1 
1A076C0 	94 76 A0  1 40 49 A0  1 
1A076C8 	24 47 A0  1 DC 41 A0  1 
1A076D0 	F0 FF FF FF 58 46 A0  1 
: u#>    (s u -- addr len )    drop  hld  @  #-buf  over  -  ;
1A076D8 	75 23 3E 83 BC 76 A0  1 
1A076E0 	20 40 A0  1 30 49 A0  1 
1A076E8 	C8 75 A0  1 5C 4C A0  1 
1A076F0 	18 75 A0  1 54 49 A0  1 
1A076F8 	18 45 A0  1 58 46 A0  1 

: mu/mod (s d n1 -- rem d.quot )
1A07700 	 0 6D 75 2F 6D 6F 64 86 
1A07708 	E0 76 A0  1 20 40 A0  1 
   >r  0  r@  um/mod  r>  swap  >r  um/mod  r>
1A07710 	BC 45 A0  1 70 6F A0  1 
1A07718 	E4 45 A0  1 7C 5D A0  1 
1A07720 	D0 45 A0  1 68 49 A0  1 
1A07728 	BC 45 A0  1 7C 5D A0  1 
1A07730 	D0 45 A0  1 
;
1A07734 	58 46 A0  1 

: #      (s ud1 -- ud2 )
1A07738 	 0  0 23 81  C 77 A0  1 
1A07740 	20 40 A0  1 
   base @ mu/mod ( nrem ud2 )  rot     >digit  hold    ( ud2 )
1A07744 	B8 75 A0  1 
1A07748 	5C 4C A0  1  C 77 A0  1 
1A07750 	7C 49 A0  1 54 76 A0  1 
1A07758 	DC 75 A0  1 
;
1A0775C 	58 46 A0  1 
: #s     (s ud -- 0 0 )  begin   #  2dup or  0=  until  ;
1A07760 	 0 23 73 82 40 77 A0  1 
1A07768 	20 40 A0  1 40 77 A0  1 
1A07770 	C0 49 A0  1 70 44 A0  1 
1A07778 	24 47 A0  1 DC 41 A0  1 
1A07780 	EC FF FF FF 58 46 A0  1 
: #>     (s ud -- addr len )     drop  u#>  ;
1A07788 	 0 23 3E 82 68 77 A0  1 
1A07790 	20 40 A0  1 30 49 A0  1 
1A07798 	E0 76 A0  1 58 46 A0  1 

: (u.)  (s u -- a len )  <# u#s u#>   ;
1A077A0 	 0  0  0 28 75 2E 29 84 
1A077A8 	90 77 A0  1 20 40 A0  1 
1A077B0 	 8 76 A0  1 BC 76 A0  1 
1A077B8 	E0 76 A0  1 58 46 A0  1 
: u.    (s u -- )       (u.)   type space   ;
1A077C0 	 0 75 2E 82 AC 77 A0  1 
1A077C8 	20 40 A0  1 AC 77 A0  1 
1A077D0 	 4 6C A0  1 CC 71 A0  1 
1A077D8 	58 46 A0  1 
: u.r   (s u len -- )     >r   (u.)   r> over - spaces   type   ;
1A077DC 	75 2E 72 83 
1A077E0 	C8 77 A0  1 20 40 A0  1 
1A077E8 	BC 45 A0  1 AC 77 A0  1 
1A077F0 	D0 45 A0  1 54 49 A0  1 
1A077F8 	18 45 A0  1 E8 71 A0  1 
1A07800 	 4 6C A0  1 58 46 A0  1 
: (.)   (s n -- a len )   dup abs  <# u#s   swap sign   u#>   ;
1A07808 	28 2E 29 83 E4 77 A0  1 
1A07810 	20 40 A0  1 40 49 A0  1 
1A07818 	24 4A A0  1  8 76 A0  1 
1A07820 	BC 76 A0  1 68 49 A0  1 
1A07828 	28 76 A0  1 E0 76 A0  1 
1A07830 	58 46 A0  1 
: s.    (s n -- )       (.)   type space   ;
1A07834 	 0 73 2E 82 
1A07838 	10 78 A0  1 20 40 A0  1 
1A07840 	10 78 A0  1  4 6C A0  1 
1A07848 	CC 71 A0  1 58 46 A0  1 
: .r    (s n l -- )     >r   (.)   r> over - spaces   type   ;
1A07850 	 0 2E 72 82 3C 78 A0  1 
1A07858 	20 40 A0  1 BC 45 A0  1 
1A07860 	10 78 A0  1 D0 45 A0  1 
1A07868 	54 49 A0  1 18 45 A0  1 
1A07870 	E8 71 A0  1  4 6C A0  1 
1A07878 	58 46 A0  1 
: 0.r   (s n l -- )     >r (u.) r> over - 0 max  0  ?do  ascii 0 emit  loop  type ;
1A0787C 	30 2E 72 83 
1A07880 	58 78 A0  1 20 40 A0  1 
1A07888 	BC 45 A0  1 AC 77 A0  1 
1A07890 	D0 45 A0  1 54 49 A0  1 
1A07898 	18 45 A0  1 70 6F A0  1 
1A078A0 	9C 4A A0  1 70 6F A0  1 
1A078A8 	50 42 A0  1 18  0  0  0 
1A078B0 	58 41 A0  1 30  0  0  0 
1A078B8 	2C 6C A0  1 F8 41 A0  1 
1A078C0 	F0 FF FF FF  4 6C A0  1 
1A078C8 	58 46 A0  1 

: (.2)  (s u -- a len )  <# u# u# u#>   ;
1A078CC 	 0  0  0 28 
1A078D0 	2E 32 29 84 84 78 A0  1 
1A078D8 	20 40 A0  1  8 76 A0  1 
1A078E0 	94 76 A0  1 94 76 A0  1 
1A078E8 	E0 76 A0  1 58 46 A0  1 
: (.4)  (s u -- a len )  <# u# u# u# u# u#>   ;
1A078F0 	 0  0  0 28 2E 34 29 84 
1A078F8 	D8 78 A0  1 20 40 A0  1 
1A07900 	 8 76 A0  1 94 76 A0  1 
1A07908 	94 76 A0  1 94 76 A0  1 
1A07910 	94 76 A0  1 E0 76 A0  1 
1A07918 	58 46 A0  1 
: (.8)  (s u -- a len )  <# u# u# u# u# u# u# u# u# u#>   ;
1A0791C 	 0  0  0 28 
1A07920 	2E 38 29 84 FC 78 A0  1 
1A07928 	20 40 A0  1  8 76 A0  1 
1A07930 	94 76 A0  1 94 76 A0  1 
1A07938 	94 76 A0  1 94 76 A0  1 
1A07940 	94 76 A0  1 94 76 A0  1 
1A07948 	94 76 A0  1 94 76 A0  1 
1A07950 	E0 76 A0  1 58 46 A0  1 
: .2   (s n -- )   (.2)  type space  ;
1A07958 	 0 2E 32 82 28 79 A0  1 
1A07960 	20 40 A0  1 D8 78 A0  1 
1A07968 	 4 6C A0  1 CC 71 A0  1 
1A07970 	58 46 A0  1 

[ifndef] run-time
headerless
: (ul.) (s ul -- a l )  n->l  <# u#s u#>   ;
1A07974 	 0  0 28 75 
1A07978 	6C 2E 29 85 60 79 A0  1 
1A07980 	20 40 A0  1 74 4F A0  1 
1A07988 	 8 76 A0  1 BC 76 A0  1 
1A07990 	E0 76 A0  1 58 46 A0  1 
headers
: ul.   (s ul -- )      (ul.)   type space   ;
1A07998 	75 6C 2E 83 80 79 A0  1 
1A079A0 	20 40 A0  1 80 79 A0  1 
1A079A8 	 4 6C A0  1 CC 71 A0  1 
1A079B0 	58 46 A0  1 
headerless
: ul.r  (s ul l -- )    >r   (ul.)   r> over - spaces   type  ;
1A079B4 	 0  0  0 75 
1A079B8 	6C 2E 72 84 A0 79 A0  1 
1A079C0 	20 40 A0  1 BC 45 A0  1 
1A079C8 	80 79 A0  1 D0 45 A0  1 
1A079D0 	54 49 A0  1 18 45 A0  1 
1A079D8 	E8 71 A0  1  4 6C A0  1 
1A079E0 	58 46 A0  1 

: (l.)  (s l -- a l )   dup l->n swap  abs   <# u#s   swap sign  u#>   ;
1A079E4 	 0  0  0 28 
1A079E8 	6C 2E 29 84 C0 79 A0  1 
1A079F0 	20 40 A0  1 40 49 A0  1 
1A079F8 	88 61 A0  1 68 49 A0  1 
1A07A00 	24 4A A0  1  8 76 A0  1 
1A07A08 	BC 76 A0  1 68 49 A0  1 
1A07A10 	28 76 A0  1 E0 76 A0  1 
1A07A18 	58 46 A0  1 
headers
: l.    (s l -- )       base @ d# 10 = if (l.) else (ul.) then type space   ;
1A07A1C 	 0 6C 2E 82 
1A07A20 	F0 79 A0  1 20 40 A0  1 
1A07A28 	B8 75 A0  1 5C 4C A0  1 
1A07A30 	58 41 A0  1  A  0  0  0 
1A07A38 	24 48 A0  1 DC 41 A0  1 
1A07A40 	10  0  0  0 F0 79 A0  1 
1A07A48 	C8 41 A0  1  8  0  0  0 
1A07A50 	80 79 A0  1  4 6C A0  1 
1A07A58 	CC 71 A0  1 58 46 A0  1 
headerless
: l.r   (s l l -- )     >r   (l.)   r> over - spaces   type   ;
1A07A60 	6C 2E 72 83 24 7A A0  1 
1A07A68 	20 40 A0  1 BC 45 A0  1 
1A07A70 	F0 79 A0  1 D0 45 A0  1 
1A07A78 	54 49 A0  1 18 45 A0  1 
1A07A80 	E8 71 A0  1  4 6C A0  1 
1A07A88 	58 46 A0  1 
headers
[then]

\ smart print that knows that signed hex numbers are uninteresting
: .    (s n -- ) base @ 10 = if s. else u. then  ;
1A07A8C 	 0  0 2E 81 
1A07A90 	68 7A A0  1 20 40 A0  1 
1A07A98 	B8 75 A0  1 5C 4C A0  1 
1A07AA0 	58 41 A0  1  A  0  0  0 
1A07AA8 	24 48 A0  1 DC 41 A0  1 
1A07AB0 	10  0  0  0 3C 78 A0  1 
1A07AB8 	C8 41 A0  1  8  0  0  0 
1A07AC0 	C8 77 A0  1 58 46 A0  1 
: n.   (s n -- ) base @ 10 = if s. else u. then  ;
1A07AC8 	 0 6E 2E 82 94 7A A0  1 
1A07AD0 	20 40 A0  1 B8 75 A0  1 
1A07AD8 	5C 4C A0  1 58 41 A0  1 
1A07AE0 	 A  0  0  0 24 48 A0  1 
1A07AE8 	DC 41 A0  1 10  0  0  0 
1A07AF0 	3C 78 A0  1 C8 41 A0  1 
1A07AF8 	 8  0  0  0 C8 77 A0  1 
1A07B00 	58 46 A0  1 
\ : .     (s n -- )       (.)   type space   ;

: (d.)  (  d -- adr len )  tuck dabs <# #s rot sign #>  ;
1A07B04 	 0  0  0 28 
1A07B08 	64 2E 29 84 D0 7A A0  1 
1A07B10 	20 40 A0  1 E8 46 A0  1 
1A07B18 	78 68 A0  1  8 76 A0  1 
1A07B20 	68 77 A0  1 7C 49 A0  1 
1A07B28 	28 76 A0  1 90 77 A0  1 
1A07B30 	58 46 A0  1 
: (ud.) ( ud -- adr len )  <# #s #>  ;
1A07B34 	 0  0 28 75 
1A07B38 	64 2E 29 85 10 7B A0  1 
1A07B40 	20 40 A0  1  8 76 A0  1 
1A07B48 	68 77 A0  1 90 77 A0  1 
1A07B50 	58 46 A0  1 

: d.    (  d -- )     (d.) type space  ;
1A07B54 	 0 64 2E 82 
1A07B58 	40 7B A0  1 20 40 A0  1 
1A07B60 	10 7B A0  1  4 6C A0  1 
1A07B68 	CC 71 A0  1 58 46 A0  1 
: ud.   ( ud -- )    (ud.) type space  ;
1A07B70 	75 64 2E 83 5C 7B A0  1 
1A07B78 	20 40 A0  1 40 7B A0  1 
1A07B80 	 4 6C A0  1 CC 71 A0  1 
1A07B88 	58 46 A0  1 
: ud.r  ( ud n -- )  >r (ud.) r> over - spaces type  ;
1A07B8C 	 0  0  0 75 
1A07B90 	64 2E 72 84 78 7B A0  1 
1A07B98 	20 40 A0  1 BC 45 A0  1 
1A07BA0 	40 7B A0  1 D0 45 A0  1 
1A07BA8 	54 49 A0  1 18 45 A0  1 
1A07BB0 	E8 71 A0  1  4 6C A0  1 
1A07BB8 	58 46 A0  1 


: ?     (s addr -- )    @  n.  ;
1A07BBC 	 0  0 3F 81 
1A07BC0 	98 7B A0  1 20 40 A0  1 
1A07BC8 	5C 4C A0  1 D0 7A A0  1 
1A07BD0 	58 46 A0  1 

: (.s        (s -- )
1A07BD4 	28 2E 73 83 
1A07BD8 	C4 7B A0  1 20 40 A0  1 
   depth 0 ?do  depth i - 1- pick n.  loop
1A07BE0 	28 73 A0  1 70 6F A0  1 
1A07BE8 	50 42 A0  1 24  0  0  0 
1A07BF0 	28 73 A0  1 B4 42 A0  1 
1A07BF8 	18 45 A0  1 54 4B A0  1 
1A07C00 	 C 4A A0  1 D0 7A A0  1 
1A07C08 	F8 41 A0  1 E4 FF FF FF 
;
1A07C10 	58 46 A0  1 

: (.")  (s -- )           skipstr type  ;
1A07C14 	 0  0  0 28 
1A07C18 	2E 22 29 84 DC 7B A0  1 
1A07C20 	20 40 A0  1 74 53 A0  1 
1A07C28 	 4 6C A0  1 58 46 A0  1 

: .s         (s -- )
1A07C30 	 0 2E 73 82 20 7C A0  1 
1A07C38 	20 40 A0  1 
   depth 0<
1A07C3C 	28 73 A0  1 
1A07C40 	64 47 A0  1 
   if   ." Stack Underflow "  sp0 @ sp!
1A07C44 	DC 41 A0  1 
1A07C48 	30  0  0  0 20 7C A0  1 
1A07C50 	10 53 74 61 63 6B 20 55 
1A07C58 	6E 64 65 72 66 6C 6F 77 
1A07C60 	20  0  0  0 8C 66 A0  1 
1A07C68 	5C 4C A0  1 9C 45 A0  1 
   else depth
1A07C70 	C8 41 A0  1 28  0  0  0 
1A07C78 	28 73 A0  1 
        if (.s else ." Empty " then
1A07C7C 	DC 41 A0  1 
1A07C80 	10  0  0  0 DC 7B A0  1 
1A07C88 	C8 41 A0  1 10  0  0  0 
1A07C90 	20 7C A0  1  6 45 6D 70 
1A07C98 	74 79 20  0 
   then
;
1A07C9C 	58 46 A0  1 
: ".  (s pstr -- )  count type  ;
1A07CA0 	 0 22 2E 82 38 7C A0  1 
1A07CA8 	20 40 A0  1 BC 53 A0  1 
1A07CB0 	 4 6C A0  1 58 46 A0  1 

\ From stresc.fth

\ These words use the string-scanning routines to get strings out of
\ the input stream.

\ ",  --> given string, emplace the string at here and allot space
\ ,"  --> accept a "-terminated string and emplace it.
\ "   --> accept a "-terminated string and leave addr len on the stack
\ ""  --> accept a blank delimited string and leave it's address on the stac

\  The improvements allow control characters and 8-bit binary numbers to
\  be embedded into string literals.  This is similar in principle to the
\  "\n" convention in C, but syntactically tuned for Forth.
\
\  The escape character is '"'.  Here is the list of escapes:
\
\     ""	"
\     "n	newline
\     "r	carret
\     "t	tab
\     "f	formfeed
\     "l	linefeed
\     "b	backspace
\     "!	bell
\     "^x	control x, where x is any printable character
\     "(HhHh)   Sequence of bytes, one byte for each pair of hex digits Hh
\               Non-hex characters will be ignored
\
\     "<whitespace> terminates the string, as usual
\
\     " followed by any other printable character not mentioned above is
\          equivalent to that character.
\
\  This new syntax is completely backwards compatible with old code, since
\  the only legal previous usage was "<whitespace>
\
\  Contrived example:
\
\  	" This is "(01,328e)"nA test xyzzy "!"! abcdefg""hijk"^bl"
\
\                   ^^^^^^  ^              ^ ^         ^     ^
\                  3 bytes  newline      2 bells       "     control b
\
\  The "(HhHhHhHh) should come in particularly handy.
\
\  Note: "n (newline) happens to be the same as "l (linefeed) under Unix,
\  but this is not true for all operating systems.


[ifndef] run-time
0 value "temp
1A07CB8 	 0  0 22 74 65 6D 70 85 
1A07CC0 	A8 7C A0  1 50 40 A0  1 
1A07CC8 	E8  0  0  0 
headerless
d# 1024 1+ /n-t +  aligned-t  constant /stringbuf  \ 1024 bytes + /n for length + 1 for null
1A07CCC 	 0 2F 73 74 
1A07CD0 	72 69 6E 67 62 75 66 8A 
1A07CD8 	C4 7C A0  1 68 40 A0  1 
1A07CE0 	 8  4  0  0 
0 value stringbuf
1A07CE4 	 0  0 73 74 
1A07CE8 	72 69 6E 67 62 75 66 89 
1A07CF0 	DC 7C A0  1 50 40 A0  1 
1A07CF8 	EC  0  0  0 
0 value $buf
1A07CFC 	 0  0  0 24 
1A07D00 	62 75 66 84 F4 7C A0  1 
1A07D08 	50 40 A0  1 F0  0  0  0 
: init  ( -- )
1A07D10 	 0  0  0 69 6E 69 74 84 
1A07D18 	 8 7D A0  1 20 40 A0  1 
   init
1A07D20 	2C 75 A0  1 
   /stringbuf 2* alloc-mem dup is stringbuf  is "temp
1A07D24 	DC 7C A0  1 
1A07D28 	A0 4B A0  1 F0 6C A0  1 
1A07D30 	40 49 A0  1 B8 65 A0  1 
1A07D38 	F4 7C A0  1 B8 65 A0  1 
1A07D40 	C4 7C A0  1 
   /stringbuf alloc-mem is $buf
1A07D44 	DC 7C A0  1 
1A07D48 	F0 6C A0  1 B8 65 A0  1 
1A07D50 	 8 7D A0  1 
;
1A07D54 	58 46 A0  1 

headers
: switch-string  ( -- )
1A07D58 	 0  0 73 77 69 74 63 68 
1A07D60 	2D 73 74 72 69 6E 67 8D 
1A07D68 	1C 7D A0  1 20 40 A0  1 
   stringbuf  dup "temp =  if  /stringbuf +  then  is "temp
1A07D70 	F4 7C A0  1 40 49 A0  1 
1A07D78 	C4 7C A0  1 24 48 A0  1 
1A07D80 	DC 41 A0  1  C  0  0  0 
1A07D88 	DC 7C A0  1  4 45 A0  1 
1A07D90 	B8 65 A0  1 C4 7C A0  1 
;
1A07D98 	58 46 A0  1 

: npack  (s str-addr len to -- to )
1A07D9C 	 0  0 6E 70 
1A07DA0 	61 63 6B 85 6C 7D A0  1 
1A07DA8 	20 40 A0  1 
   tuck !                  ( str-adr to )
1A07DAC 	E8 46 A0  1 
1A07DB0 	54 4D A0  1 
   tuck ncount move        ( to )
1A07DB4 	E8 46 A0  1 
1A07DB8 	F0 53 A0  1 F4 4A A0  1 
   0  over ncount +  c!    ( to )
1A07DC0 	70 6F A0  1 54 49 A0  1 
1A07DC8 	F0 53 A0  1  4 45 A0  1 
1A07DD0 	B8 4D A0  1 
;
1A07DD4 	58 46 A0  1 

: $nsave  ( adr1 len1 adr2 -- adr2 len1 )  npack ncount  ;
1A07DD8 	 0 24 6E 73 61 76 65 86 
1A07DE0 	A8 7D A0  1 20 40 A0  1 
1A07DE8 	A8 7D A0  1 F0 53 A0  1 
1A07DF0 	58 46 A0  1 

: $ncat  ( adr len  npstr -- )  \ Append adr len to the end of npstr
1A07DF4 	 0  0 24 6E 
1A07DF8 	63 61 74 85 E4 7D A0  1 
1A07E00 	20 40 A0  1 
   >r  r@ ncount +     ( adr len end-adr )  ( r: npstr )
1A07E04 	BC 45 A0  1 
1A07E08 	E4 45 A0  1 F0 53 A0  1 
1A07E10 	 4 45 A0  1 
   swap dup >r         ( adr endadr len )  ( r: npstr len )
1A07E14 	68 49 A0  1 
1A07E18 	40 49 A0  1 BC 45 A0  1 
   cmove  r> r>        ( len npstr )
1A07E20 	10 44 A0  1 D0 45 A0  1 
1A07E28 	D0 45 A0  1 
   dup @ rot + over !  ( npstr )
1A07E2C 	40 49 A0  1 
1A07E30 	5C 4C A0  1 7C 49 A0  1 
1A07E38 	 4 45 A0  1 54 49 A0  1 
1A07E40 	54 4D A0  1 
   ncount +  0 swap c! \ Null-terminate the end for later convenience
1A07E44 	F0 53 A0  1 
1A07E48 	 4 45 A0  1 70 6F A0  1 
1A07E50 	68 49 A0  1 B8 4D A0  1 
;
1A07E58 	58 46 A0  1 


: $save  ( adr1 len1 adr2 -- adr2 len1 )  pack count  ;
1A07E5C 	 0  0 24 73 
1A07E60 	61 76 65 85  0 7E A0  1 
1A07E68 	20 40 A0  1 DC 52 A0  1 
1A07E70 	BC 53 A0  1 58 46 A0  1 

: $cat  ( adr len  pstr -- )  \ Append adr len to the end of pstr
1A07E78 	 0  0  0 24 63 61 74 84 
1A07E80 	68 7E A0  1 20 40 A0  1 
   >r  r@ count +   ( adr len end-adr )  ( r: pstr )
1A07E88 	BC 45 A0  1 E4 45 A0  1 
1A07E90 	BC 53 A0  1  4 45 A0  1 
   swap dup >r      ( adr endadr len )  ( r: pstr len )
1A07E98 	68 49 A0  1 40 49 A0  1 
1A07EA0 	BC 45 A0  1 
   cmove  r> r>     ( len pstr )
1A07EA4 	10 44 A0  1 
1A07EA8 	D0 45 A0  1 D0 45 A0  1 
   dup c@ rot + over c!  ( pstr )
1A07EB0 	40 49 A0  1 C4 4C A0  1 
1A07EB8 	7C 49 A0  1  4 45 A0  1 
1A07EC0 	54 49 A0  1 B8 4D A0  1 
   count +  0 swap c!     \ Always keep a null terminator at the end
1A07EC8 	BC 53 A0  1  4 45 A0  1 
1A07ED0 	70 6F A0  1 68 49 A0  1 
1A07ED8 	B8 4D A0  1 
;
1A07EDC 	58 46 A0  1 

\ From catchsel.fth

\ Special version of catch and throw for Open Firmware.  This version
\ saves and restores the "my-self" current package instance variable.

0 value my-self
1A07EE0 	6D 79 2D 73 65 6C 66 87 
1A07EE8 	84 7E A0  1 50 40 A0  1 
1A07EF0 	F4  0  0  0 

nuser handler   \ Most recent exception handler
1A07EF4 	68 61 6E 64 
1A07EF8 	6C 65 72 87 EC 7E A0  1 
1A07F00 	48 40 A0  1 F8  0  0  0 

: catch  ( execution-token -- error# | 0 )
1A07F08 	 0  0 63 61 74 63 68 85 
1A07F10 	 0 7F A0  1 20 40 A0  1 
                        ( token )  \ Return address is already on the stack
   sp@ >r               ( token )  \ Save data stack pointer
1A07F18 	6C 45 A0  1 BC 45 A0  1 
   my-self >r           ( token )  \ Save current package instance handle
1A07F20 	EC 7E A0  1 BC 45 A0  1 
   handler @ >r         ( token )  \ Previous handler
1A07F28 	 0 7F A0  1 5C 4C A0  1 
1A07F30 	BC 45 A0  1 
   rp@ handler !        ( token )  \ Set current handler to this one
1A07F34 	7C 45 A0  1 
1A07F38 	 0 7F A0  1 54 4D A0  1 
   execute              ( )        \ Execute the word passed in on the stack
1A07F40 	98 41 A0  1 
   r> handler ! ( )                \ Restore previous handler
1A07F44 	D0 45 A0  1 
1A07F48 	 0 7F A0  1 54 4D A0  1 
   r> drop              ( )        \ Discard saved package instance handle
1A07F50 	D0 45 A0  1 30 49 A0  1 
   r> drop              ( )        \ Discard saved stack pointer
1A07F58 	D0 45 A0  1 30 49 A0  1 
   0                    ( 0 )      \ Signify normal completion
1A07F60 	70 6F A0  1 
;
1A07F64 	58 46 A0  1 

: throw  ( ??? error# -- ??? error# )  \ Returns in saved context
1A07F68 	 0  0 74 68 72 6F 77 85 
1A07F70 	14 7F A0  1 20 40 A0  1 
   dup  0=  if  drop exit  then        \ Don't throw 0
1A07F78 	40 49 A0  1 24 47 A0  1 
1A07F80 	DC 41 A0  1  C  0  0  0 
1A07F88 	30 49 A0  1 40 46 A0  1 
   handler @ rp!        ( err# )       \ Return to saved return stack context
1A07F90 	 0 7F A0  1 5C 4C A0  1 
1A07F98 	AC 45 A0  1 
   r> handler !         ( err# )       \ Restore previous handler
1A07F9C 	D0 45 A0  1 
1A07FA0 	 0 7F A0  1 54 4D A0  1 
   r> is my-self        ( err# )       \ Restore package instance handle
1A07FA8 	D0 45 A0  1 B8 65 A0  1 
1A07FB0 	EC 7E A0  1 
                        ( err# )       \ Remember error# on return stack
                        ( err# )       \ before changing data stack pointer
   r> swap >r           ( saved-sp )   \ err# is on return stack
1A07FB4 	D0 45 A0  1 
1A07FB8 	68 49 A0  1 BC 45 A0  1 
   sp! drop r>          ( err# )       \ Change stack pointer
1A07FC0 	9C 45 A0  1 30 49 A0  1 
1A07FC8 	D0 45 A0  1 
   \ This return will return to the caller of catch, because the return
   \ stack has been restored to the state that existed when CATCH began
   \ execution .
;
1A07FCC 	58 46 A0  1 

defer mark-error
1A07FD0 	 0 6D 61 72 6B 2D 65 72 
1A07FD8 	72 6F 72 8A 74 7F A0  1 
1A07FE0 	5C 40 A0  1 FC  0  0  0 
defer show-error
1A07FE8 	 0 73 68 6F 77 2D 65 72 
1A07FF0 	72 6F 72 8A E0 7F A0  1 
1A07FF8 	5C 40 A0  1  0  1  0  0 


nuser abort"-adr
1A08000 	 0 61 62 6F 72 74 22 2D 
1A08008 	61 64 72 8A F8 7F A0  1 
1A08010 	48 40 A0  1  4  1  0  0 
nuser abort"-len
1A08018 	 0 61 62 6F 72 74 22 2D 
1A08020 	6C 65 6E 8A 10 80 A0  1 
1A08028 	48 40 A0  1  8  1  0  0 
nuser show-aborts
1A08030 	73 68 6F 77 2D 61 62 6F 
1A08038 	72 74 73 8B 28 80 A0  1 
1A08040 	48 40 A0  1  C  1  0  0 
: set-abort-message  ( adr len -- )
1A08048 	 0  0 73 65 74 2D 61 62 
1A08050 	6F 72 74 2D 6D 65 73 73 
1A08058 	61 67 65 91 40 80 A0  1 
1A08060 	20 40 A0  1 
   show-aborts @  if  ." Abort: " 2dup type cr  then
1A08064 	40 80 A0  1 
1A08068 	5C 4C A0  1 DC 41 A0  1 
1A08070 	20  0  0  0 20 7C A0  1 
1A08078 	 7 41 62 6F 72 74 3A 20 
1A08080 	 0  0  0  0 C0 49 A0  1 
1A08088 	 4 6C A0  1 80 6D A0  1 
   abort"-len !  abort"-adr !  mark-error
1A08090 	28 80 A0  1 54 4D A0  1 
1A08098 	10 80 A0  1 54 4D A0  1 
1A080A0 	E0 7F A0  1 
;
1A080A4 	58 46 A0  1 
: abort-message  ( -- adr len )  abort"-adr @  abort"-len @  ;
1A080A8 	 0  0 61 62 6F 72 74 2D 
1A080B0 	6D 65 73 73 61 67 65 8D 
1A080B8 	60 80 A0  1 20 40 A0  1 
1A080C0 	10 80 A0  1 5C 4C A0  1 
1A080C8 	28 80 A0  1 5C 4C A0  1 
1A080D0 	58 46 A0  1 
: $abort  ( adr len -- )  set-abort-message  -2 throw  ;
1A080D4 	 0 24 61 62 
1A080D8 	6F 72 74 86 BC 80 A0  1 
1A080E0 	20 40 A0  1 60 80 A0  1 
1A080E8 	58 41 A0  1 FE FF FF FF 
1A080F0 	74 7F A0  1 58 46 A0  1 
: (abort")   (s f -- )
1A080F8 	 0  0  0 28 61 62 6F 72 
1A08100 	74 22 29 88 E0 80 A0  1 
1A08108 	20 40 A0  1 
   if  skipstr $abort  else  skipstr 2drop  then
1A0810C 	DC 41 A0  1 
1A08110 	14  0  0  0 74 53 A0  1 
1A08118 	E0 80 A0  1 C8 41 A0  1 
1A08120 	 C  0  0  0 74 53 A0  1 
1A08128 	AC 49 A0  1 
;
1A0812C 	58 46 A0  1 


nuser 'source
1A08130 	27 73 6F 75 72 63 65 87 
1A08138 	 8 81 A0  1 48 40 A0  1 
1A08140 	10  1  0  0 
nuser #source
1A08144 	23 73 6F 75 
1A08148 	72 63 65 87 3C 81 A0  1 
1A08150 	48 40 A0  1 14  1  0  0 
: source-adr  ( -- adr )  'source @  ;
1A08158 	 0 73 6F 75 72 63 65 2D 
1A08160 	61 64 72 8A 50 81 A0  1 
1A08168 	20 40 A0  1 3C 81 A0  1 
1A08170 	5C 4C A0  1 58 46 A0  1 
: source      ( -- adr len )  source-adr  #source @  ;
1A08178 	 0 73 6F 75 72 63 65 86 
1A08180 	68 81 A0  1 20 40 A0  1 
1A08188 	68 81 A0  1 50 81 A0  1 
1A08190 	5C 4C A0  1 58 46 A0  1 
: set-source  ( adr len -- )  #source !  'source !  ;
1A08198 	 0 73 65 74 2D 73 6F 75 
1A081A0 	72 63 65 8A 84 81 A0  1 
1A081A8 	20 40 A0  1 50 81 A0  1 
1A081B0 	54 4D A0  1 3C 81 A0  1 
1A081B8 	54 4D A0  1 58 46 A0  1 

\ Control Structures

decimal
headerless
nuser saved-dp
1A081C0 	 0  0  0 73 61 76 65 64 
1A081C8 	2D 64 70 88 A8 81 A0  1 
1A081D0 	48 40 A0  1 18  1  0  0 
nuser saved-limit
1A081D8 	73 61 76 65 64 2D 6C 69 
1A081E0 	6D 69 74 8B D0 81 A0  1 
1A081E8 	48 40 A0  1 1C  1  0  0 
nuser level
1A081F0 	 0  0 6C 65 76 65 6C 85 
1A081F8 	E8 81 A0  1 48 40 A0  1 
1A08200 	20  1  0  0 
headers
[ifdef] run-time
: +level  ( -- )  ;
: -level  ( -- )  ;
[else]
headerless
h# 400 /token-t * constant /compile-buffer
1A08204 	2F 63 6F 6D 
1A08208 	70 69 6C 65 2D 62 75 66 
1A08210 	66 65 72 8F FC 81 A0  1 
1A08218 	68 40 A0  1  0 10  0  0 
nuser 'compile-buffer
1A08220 	27 63 6F 6D 70 69 6C 65 
1A08228 	2D 62 75 66 66 65 72 8F 
1A08230 	18 82 A0  1 48 40 A0  1 
1A08238 	24  1  0  0 
: compile-buffer  ( -- adr )  'compile-buffer @  ;
1A0823C 	 0 63 6F 6D 
1A08240 	70 69 6C 65 2D 62 75 66 
1A08248 	66 65 72 8E 34 82 A0  1 
1A08250 	20 40 A0  1 34 82 A0  1 
1A08258 	5C 4C A0  1 58 46 A0  1 
: init  ( -- )
1A08260 	 0  0  0 69 6E 69 74 84 
1A08268 	50 82 A0  1 20 40 A0  1 
   init
1A08270 	1C 7D A0  1 
   level off   /compile-buffer alloc-mem 'compile-buffer !
1A08274 	FC 81 A0  1 
1A08278 	F8 4B A0  1 18 82 A0  1 
1A08280 	F0 6C A0  1 34 82 A0  1 
1A08288 	54 4D A0  1 
;
1A0828C 	58 46 A0  1 
: reset-dp  ( -- )  saved-dp @ dp !  saved-limit @ is limit  ;
1A08290 	 0  0  0 72 65 73 65 74 
1A08298 	2D 64 70 88 6C 82 A0  1 
1A082A0 	20 40 A0  1 D0 81 A0  1 
1A082A8 	5C 4C A0  1 48 54 A0  1 
1A082B0 	54 4D A0  1 E8 81 A0  1 
1A082B8 	5C 4C A0  1 B8 65 A0  1 
1A082C0 	5C 54 A0  1 58 46 A0  1 

headers
: 0level  ( -- )  level @  if  level off  reset-dp  then  ;
1A082C8 	 0 30 6C 65 76 65 6C 86 
1A082D0 	A0 82 A0  1 20 40 A0  1 
1A082D8 	FC 81 A0  1 5C 4C A0  1 
1A082E0 	DC 41 A0  1 10  0  0  0 
1A082E8 	FC 81 A0  1 F8 4B A0  1 
1A082F0 	A0 82 A0  1 58 46 A0  1 

: +level  ( -- )
1A082F8 	 0 2B 6C 65 76 65 6C 86 
1A08300 	D4 82 A0  1 20 40 A0  1 
   level @  if
1A08308 	FC 81 A0  1 5C 4C A0  1 
1A08310 	DC 41 A0  1 18  0  0  0 
      1 level +!
1A08318 	80 6F A0  1 FC 81 A0  1 
1A08320 	 C 4C A0  1 
   else
1A08324 	C8 41 A0  1 
1A08328 	60  0  0  0 
      state @ 0=  if	\ If interpreting, begin temporary compilation
1A0832C 	38 54 A0  1 
1A08330 	5C 4C A0  1 24 47 A0  1 
1A08338 	DC 41 A0  1 4C  0  0  0 
         1 level !  here saved-dp !  limit saved-limit !
1A08340 	80 6F A0  1 FC 81 A0  1 
1A08348 	54 4D A0  1 70 54 A0  1 
1A08350 	D0 81 A0  1 54 4D A0  1 
1A08358 	5C 54 A0  1 E8 81 A0  1 
1A08360 	54 4D A0  1 
	 compile-buffer dp !  compile-buffer /compile-buffer +  is limit
1A08364 	50 82 A0  1 
1A08368 	48 54 A0  1 54 4D A0  1 
1A08370 	50 82 A0  1 18 82 A0  1 
1A08378 	 4 45 A0  1 B8 65 A0  1 
1A08380 	5C 54 A0  1 
	 ]
1A08384 	A0 6D A0  1 
      then
   then
;
1A08388 	58 46 A0  1 
: -level  ( -- )
1A0838C 	 0 2D 6C 65 
1A08390 	76 65 6C 86  4 83 A0  1 
1A08398 	20 40 A0  1 
   state @ 0= ( -22 ) abort" Control structure mismatch"
1A0839C 	38 54 A0  1 
1A083A0 	5C 4C A0  1 24 47 A0  1 
1A083A8 	 8 81 A0  1 1A 43 6F 6E 
1A083B0 	74 72 6F 6C 20 73 74 72 
1A083B8 	75 63 74 75 72 65 20 6D 
1A083C0 	69 73 6D 61 74 63 68  0 
   level @  if
1A083C8 	FC 81 A0  1 5C 4C A0  1 
1A083D0 	DC 41 A0  1 40  0  0  0 
      -1 level +!
1A083D8 	58 41 A0  1 FF FF FF FF 
1A083E0 	FC 81 A0  1  C 4C A0  1 
      level @ 0=  if
1A083E8 	FC 81 A0  1 5C 4C A0  1 
1A083F0 	24 47 A0  1 DC 41 A0  1 
1A083F8 	1C  0  0  0 
         \ If back to level 0, execute the temporary definition
         compile unnest  reset-dp
1A083FC 	8C 75 A0  1 
1A08400 	58 46 A0  1 A0 82 A0  1 
         [compile] [  compile-buffer >ip
1A08408 	90 6D A0  1 50 82 A0  1 
1A08410 	6C 46 A0  1 
      then
   then
;
1A08414 	58 46 A0  1 
[then]

headerless
: add-char  ( char -- )  $buf ncount + c!  $buf @ 1+ $buf !  ;
1A08418 	 0  0  0 61 64 64 2D 63 
1A08420 	68 61 72 88 98 83 A0  1 
1A08428 	20 40 A0  1  8 7D A0  1 
1A08430 	F0 53 A0  1  4 45 A0  1 
1A08438 	B8 4D A0  1  8 7D A0  1 
1A08440 	5C 4C A0  1 30 4B A0  1 
1A08448 	 8 7D A0  1 54 4D A0  1 
1A08450 	58 46 A0  1 

: nextchar  ( adr len -- false | adr' len' char true )
1A08454 	 0  0  0 6E 
1A08458 	65 78 74 63 68 61 72 88 
1A08460 	28 84 A0  1 20 40 A0  1 
   dup  0=  if  nip exit  then   ( adr len )
1A08468 	40 49 A0  1 24 47 A0  1 
1A08470 	DC 41 A0  1  C  0  0  0 
1A08478 	FC 46 A0  1 40 46 A0  1 
   over c@ >r  swap 1+ swap 1-  r> true
1A08480 	54 49 A0  1 C4 4C A0  1 
1A08488 	BC 45 A0  1 68 49 A0  1 
1A08490 	30 4B A0  1 68 49 A0  1 
1A08498 	54 4B A0  1 D0 45 A0  1 
1A084A0 	 4 70 A0  1 
;
1A084A4 	58 46 A0  1 

: nexthex  ( adr len -- false | adr' len' digit true )
1A084A8 	6E 65 78 74 68 65 78 87 
1A084B0 	64 84 A0  1 20 40 A0  1 
   begin
      nextchar  if         ( adr' len' char )
1A084B8 	64 84 A0  1 DC 41 A0  1 
1A084C0 	38  0  0  0 
	 d# 16 digit  if   ( adr' len' digit )
1A084C4 	58 41 A0  1 
1A084C8 	10  0  0  0 D8 43 A0  1 
1A084D0 	DC 41 A0  1 14  0  0  0 
	    true true      ( adr' len' digit true done )
1A084D8 	 4 70 A0  1  4 70 A0  1 
	 else              ( adr' len' char )
1A084E0 	C8 41 A0  1  C  0  0  0 
	    drop false     ( adr' len' notdone )
1A084E8 	30 49 A0  1 18 70 A0  1 
	 then              ( adr' len' digit true done | adr' len' notdone )
      else                 (  )
1A084F0 	C8 41 A0  1  C  0  0  0 
	 false true        ( false done )
1A084F8 	18 70 A0  1  4 70 A0  1 
      then
   until
1A08500 	DC 41 A0  1 B4 FF FF FF 
;
1A08508 	58 46 A0  1 

nuser caps
1A0850C 	 0  0  0 63 
1A08510 	61 70 73 84 B4 84 A0  1 
1A08518 	48 40 A0  1 28  1  0  0 
variable >in
1A08520 	3E 69 6E 83 18 85 A0  1 
1A08528 	48 40 A0  1 2C  1  0  0 

: /string  ( adr len cnt -- adr' len' )  tuck - -rot + swap  ;
1A08530 	2F 73 74 72 69 6E 67 87 
1A08538 	28 85 A0  1 20 40 A0  1 
1A08540 	E8 46 A0  1 18 45 A0  1 
1A08548 	94 49 A0  1  4 45 A0  1 
1A08550 	68 49 A0  1 58 46 A0  1 

: upper  (s adr len -- )  bounds  ?do i dup c@ upc swap c!  loop  ;
1A08558 	 0  0 75 70 70 65 72 85 
1A08560 	3C 85 A0  1 20 40 A0  1 
1A08568 	F0 6D A0  1 50 42 A0  1 
1A08570 	24  0  0  0 B4 42 A0  1 
1A08578 	40 49 A0  1 C4 4C A0  1 
1A08580 	D0 51 A0  1 68 49 A0  1 
1A08588 	B8 4D A0  1 F8 41 A0  1 
1A08590 	E4 FF FF FF 58 46 A0  1 
: lower  (s adr len -- )  bounds  ?do i dup c@ lcc swap c!  loop  ;
1A08598 	 0  0 6C 6F 77 65 72 85 
1A085A0 	64 85 A0  1 20 40 A0  1 
1A085A8 	F0 6D A0  1 50 42 A0  1 
1A085B0 	24  0  0  0 B4 42 A0  1 
1A085B8 	40 49 A0  1 C4 4C A0  1 
1A085C0 	F0 51 A0  1 68 49 A0  1 
1A085C8 	B8 4D A0  1 F8 41 A0  1 
1A085D0 	E4 FF FF FF 58 46 A0  1 

: parse  ( delim -- adr len )
1A085D8 	 0  0 70 61 72 73 65 85 
1A085E0 	A4 85 A0  1 20 40 A0  1 
   source >in @ /string  over >r   ( delim adr1 len1 )  ( r: adr1 )
1A085E8 	84 81 A0  1 28 85 A0  1 
1A085F0 	5C 4C A0  1 3C 85 A0  1 
1A085F8 	54 49 A0  1 BC 45 A0  1 
   rot scantochar                  ( adr1 adr2 adr3 )  ( r: adr1 )
1A08600 	7C 49 A0  1 60 65 A0  1 
   r> - >in +!                     ( adr1 adr2 ) ( r: )
1A08608 	D0 45 A0  1 18 45 A0  1 
1A08610 	28 85 A0  1  C 4C A0  1 
   over -                          ( adr1 len )
1A08618 	54 49 A0  1 18 45 A0  1 
;
1A08620 	58 46 A0  1 

: get-hex-bytes  ( -- )
1A08624 	 0  0 67 65 
1A08628 	74 2D 68 65 78 2D 62 79 
1A08630 	74 65 73 8D E4 85 A0  1 
1A08638 	20 40 A0  1 
   ascii ) parse                    ( adr len )
1A0863C 	58 41 A0  1 
1A08640 	29  0  0  0 E4 85 A0  1 
   caps @  if  2dup lower  then     ( adr len )
1A08648 	18 85 A0  1 5C 4C A0  1 
1A08650 	DC 41 A0  1  C  0  0  0 
1A08658 	C0 49 A0  1 A4 85 A0  1 
   begin  nexthex  while            ( adr' len' digit1 )
1A08660 	B4 84 A0  1 DC 41 A0  1 
1A08668 	54  0  0  0 
      >r  nexthex  0= ( ?? ) abort" Odd number of hex digits in string"
1A0866C 	BC 45 A0  1 
1A08670 	B4 84 A0  1 24 47 A0  1 
1A08678 	 8 81 A0  1 22 4F 64 64 
1A08680 	20 6E 75 6D 62 65 72 20 
1A08688 	6F 66 20 68 65 78 20 64 
1A08690 	69 67 69 74 73 20 69 6E 
1A08698 	20 73 74 72 69 6E 67  0 
      r>                            ( adr'' len'' digit2 digit1 )
1A086A0 	D0 45 A0  1 
      4 << +  add-char              ( adr'' len'' )
1A086A4 	B0 6F A0  1 
1A086A8 	C8 44 A0  1  4 45 A0  1 
1A086B0 	28 84 A0  1 
   repeat
1A086B4 	C8 41 A0  1 
1A086B8 	A8 FF FF FF 
;
1A086BC 	58 46 A0  1 


\ : get-char  ( -- char )  input-file @ fgetc  ;


: get-char  ( -- char|-1 )
1A086C0 	 0  0  0 67 65 74 2D 63 
1A086C8 	68 61 72 88 38 86 A0  1 
1A086D0 	20 40 A0  1 
   source  >in @  /string  if  c@  1 >in +!  else  drop -1  then
1A086D4 	84 81 A0  1 
1A086D8 	28 85 A0  1 5C 4C A0  1 
1A086E0 	3C 85 A0  1 DC 41 A0  1 
1A086E8 	1C  0  0  0 C4 4C A0  1 
1A086F0 	80 6F A0  1 28 85 A0  1 
1A086F8 	 C 4C A0  1 C8 41 A0  1 
1A08700 	10  0  0  0 30 49 A0  1 
1A08708 	58 41 A0  1 FF FF FF FF 
;
1A08710 	58 46 A0  1 

headers
: get-escaped-string  ( -- adr len )
1A08714 	 0 67 65 74 
1A08718 	2D 65 73 63 61 70 65 64 
1A08720 	2D 73 74 72 69 6E 67 92 
1A08728 	D0 86 A0  1 20 40 A0  1 
   0 $buf !
1A08730 	70 6F A0  1  8 7D A0  1 
1A08738 	54 4D A0  1 
   begin
      ascii " parse   $buf $ncat
1A0873C 	58 41 A0  1 
1A08740 	22  0  0  0 E4 85 A0  1 
1A08748 	 8 7D A0  1  0 7E A0  1 
      get-char  dup bl <=  if  drop $buf ncount exit  then  ( char )
1A08750 	D0 86 A0  1 40 49 A0  1 
1A08758 	28 70 A0  1  C 49 A0  1 
1A08760 	DC 41 A0  1 14  0  0  0 
1A08768 	30 49 A0  1  8 7D A0  1 
1A08770 	F0 53 A0  1 40 46 A0  1 
      case
         ascii n of  newline            add-char  endof
1A08778 	58 41 A0  1 6E  0  0  0 
1A08780 	48 43 A0  1 14  0  0  0 
1A08788 	A8 71 A0  1 28 84 A0  1 
1A08790 	6C 43 A0  1 24  1  0  0 
         ascii r of  carret             add-char  endof
1A08798 	58 41 A0  1 72  0  0  0 
1A087A0 	48 43 A0  1 14  0  0  0 
1A087A8 	60 6F A0  1 28 84 A0  1 
1A087B0 	6C 43 A0  1  4  1  0  0 
         ascii t of  control I          add-char  endof
1A087B8 	58 41 A0  1 74  0  0  0 
1A087C0 	48 43 A0  1 18  0  0  0 
1A087C8 	58 41 A0  1  9  0  0  0 
1A087D0 	28 84 A0  1 6C 43 A0  1 
1A087D8 	E0  0  0  0 
         ascii f of  control L          add-char  endof
1A087DC 	58 41 A0  1 
1A087E0 	66  0  0  0 48 43 A0  1 
1A087E8 	18  0  0  0 58 41 A0  1 
1A087F0 	 C  0  0  0 28 84 A0  1 
1A087F8 	6C 43 A0  1 BC  0  0  0 
         ascii l of  linefeed           add-char  endof
1A08800 	58 41 A0  1 6C  0  0  0 
1A08808 	48 43 A0  1 14  0  0  0 
1A08810 	4C 6F A0  1 28 84 A0  1 
1A08818 	6C 43 A0  1 9C  0  0  0 
         ascii b of  control H          add-char  endof
1A08820 	58 41 A0  1 62  0  0  0 
1A08828 	48 43 A0  1 18  0  0  0 
1A08830 	58 41 A0  1  8  0  0  0 
1A08838 	28 84 A0  1 6C 43 A0  1 
1A08840 	78  0  0  0 
         ascii ! of  bell               add-char  endof
1A08844 	58 41 A0  1 
1A08848 	21  0  0  0 48 43 A0  1 
1A08850 	14  0  0  0 24 6F A0  1 
1A08858 	28 84 A0  1 6C 43 A0  1 
1A08860 	58  0  0  0 
         ascii ^ of  get-char h# 1f and add-char  endof
1A08864 	58 41 A0  1 
1A08868 	5E  0  0  0 48 43 A0  1 
1A08870 	20  0  0  0 D0 86 A0  1 
1A08878 	58 41 A0  1 1F  0  0  0 
1A08880 	5C 44 A0  1 28 84 A0  1 
1A08888 	6C 43 A0  1 2C  0  0  0 
         ascii ( of  get-hex-bytes                endof
1A08890 	58 41 A0  1 28  0  0  0 
1A08898 	48 43 A0  1 10  0  0  0 
1A088A0 	38 86 A0  1 6C 43 A0  1 
1A088A8 	10  0  0  0 
         ( default ) dup                add-char
1A088AC 	40 49 A0  1 
1A088B0 	28 84 A0  1 
      endcase
1A088B4 	84 43 A0  1 
   again
1A088B8 	C8 41 A0  1 80 FE FF FF 
;
1A088C0 	58 46 A0  1 

: .(  \ string)  (s -- )
1A088C4 	 0 2E 28 C2 
1A088C8 	2C 87 A0  1 20 40 A0  1 
   ascii ) parse type
1A088D0 	58 41 A0  1 29  0  0  0 
1A088D8 	E4 85 A0  1  4 6C A0  1 
; immediate
1A088E0 	58 46 A0  1 

\ : (   \ string  (s -- )  \ Skips to next )
\    ascii ) parse 2drop
\ ; immediate
[then]

\ Words for copying strings
\ Places a series of bytes in memory at to as a packed string
: place     (s adr len to-adr -- )  pack drop  ;
1A088E4 	 0  0 70 6C 
1A088E8 	61 63 65 85 CC 88 A0  1 
1A088F0 	20 40 A0  1 DC 52 A0  1 
1A088F8 	30 49 A0  1 58 46 A0  1 
: nplace    (s adr len to-adr -- )  npack drop  ;
1A08900 	 0 6E 70 6C 61 63 65 86 
1A08908 	F0 88 A0  1 20 40 A0  1 
1A08910 	A8 7D A0  1 30 49 A0  1 
1A08918 	58 46 A0  1 


: ",    (s adr len -- )
1A0891C 	 0 22 2C 82 
1A08920 	 C 89 A0  1 20 40 A0  1 
   dup 2+ taligned  here swap  noop  allot  place
1A08928 	40 49 A0  1 40 4B A0  1 
1A08930 	54 62 A0  1 70 54 A0  1 
1A08938 	68 49 A0  1 64 4F A0  1 
1A08940 	E4 54 A0  1 F0 88 A0  1 
;
1A08948 	58 46 A0  1 

: n",    (s adr len -- )
1A0894C 	6E 22 2C 83 
1A08950 	24 89 A0  1 20 40 A0  1 
   dup 1+ na1+ taligned  here swap  noop  allot  nplace
1A08958 	40 49 A0  1 30 4B A0  1 
1A08960 	CC 50 A0  1 54 62 A0  1 
1A08968 	70 54 A0  1 68 49 A0  1 
1A08970 	64 4F A0  1 E4 54 A0  1 
1A08978 	 C 89 A0  1 
;
1A0897C 	58 46 A0  1 

[ifndef] run-time
: ,"  \ string"  (s -- )
1A08980 	 0 2C 22 82 54 89 A0  1 
1A08988 	20 40 A0  1 
   get-escaped-string  ",
1A0898C 	2C 87 A0  1 
1A08990 	24 89 A0  1 
;
1A08994 	58 46 A0  1 

: ."  \ string"  (s -- )
1A08998 	 0 2E 22 C2 88 89 A0  1 
1A089A0 	20 40 A0  1 
   +level compile (.")   ," -level
1A089A4 	 4 83 A0  1 
1A089A8 	8C 75 A0  1 20 7C A0  1 
1A089B0 	88 89 A0  1 98 83 A0  1 
; immediate
1A089B8 	58 46 A0  1 


: compile-string  ( adr len -- )
1A089BC 	 0 63 6F 6D 
1A089C0 	70 69 6C 65 2D 73 74 72 
1A089C8 	69 6E 67 8E A0 89 A0  1 
1A089D0 	20 40 A0  1 
   state @  if
1A089D4 	38 54 A0  1 
1A089D8 	5C 4C A0  1 DC 41 A0  1 
1A089E0 	44  0  0  0 
      dup  d# 255 >  if
1A089E4 	40 49 A0  1 
1A089E8 	58 41 A0  1 FF  0  0  0 
1A089F0 	 4 48 A0  1 DC 41 A0  1 
1A089F8 	18  0  0  0 
         compile (n") n",
1A089FC 	8C 75 A0  1 
1A08A00 	D4 53 A0  1 54 89 A0  1 
      else
1A08A08 	C8 41 A0  1 10  0  0  0 
         compile (") ",
1A08A10 	8C 75 A0  1 9C 53 A0  1 
1A08A18 	24 89 A0  1 
      then
   else
1A08A1C 	C8 41 A0  1 
1A08A20 	10  0  0  0 
      switch-string "temp $nsave
1A08A24 	6C 7D A0  1 
1A08A28 	C4 7C A0  1 E4 7D A0  1 
   then
;
1A08A30 	58 46 A0  1 
: s"  \ string   (s -- adr len )
1A08A34 	 0 73 22 C2 
1A08A38 	D0 89 A0  1 20 40 A0  1 
   ascii " parse compile-string
1A08A40 	58 41 A0  1 22  0  0  0 
1A08A48 	E4 85 A0  1 D0 89 A0  1 
; immediate
1A08A50 	58 46 A0  1 

: "   \ string"  (s -- adr len )
1A08A54 	 0  0 22 C1 
1A08A58 	3C 8A A0  1 20 40 A0  1 
   get-escaped-string compile-string
1A08A60 	2C 87 A0  1 D0 89 A0  1 
; immediate
1A08A68 	58 46 A0  1 

: \  \ rest-of-line  (s -- )      \ skips rest of line
1A08A6C 	 0  0 5C C1 
1A08A70 	5C 8A A0  1 20 40 A0  1 
   -1 parse 2drop
1A08A78 	58 41 A0  1 FF FF FF FF 
1A08A80 	E4 85 A0  1 AC 49 A0  1 
; immediate
1A08A88 	58 46 A0  1 
[then]

create nullstring 0 c, 0 c,
1A08A8C 	 0 6E 75 6C 
1A08A90 	6C 73 74 72 69 6E 67 8A 
1A08A98 	74 8A A0  1 30 40 A0  1 
1A08AA0 	 0  0 


: place-cstr  ( adr len cstr-adr -- cstr-adr )
1A08AA2 	 0  0  0 70 6C 61 
1A08AA8 	63 65 2D 63 73 74 72 8A 
1A08AB0 	9C 8A A0  1 20 40 A0  1 
   >r  tuck r@ swap cmove  ( len ) r@ +  0 swap c!  r>
1A08AB8 	BC 45 A0  1 E8 46 A0  1 
1A08AC0 	E4 45 A0  1 68 49 A0  1 
1A08AC8 	10 44 A0  1 E4 45 A0  1 
1A08AD0 	 4 45 A0  1 70 6F A0  1 
1A08AD8 	68 49 A0  1 B8 4D A0  1 
1A08AE0 	D0 45 A0  1 
;
1A08AE4 	58 46 A0  1 

: even      (s n -- n | n+1 )  dup 1 and +  ;
1A08AE8 	 0  0  0 65 76 65 6E 84 
1A08AF0 	B4 8A A0  1 20 40 A0  1 
1A08AF8 	40 49 A0  1 80 6F A0  1 
1A08B00 	5C 44 A0  1  4 45 A0  1 
1A08B08 	58 46 A0  1 

\ Nullfix
: +str  (s pstr -- adr )     count + 1+ taligned ;
1A08B0C 	 0  0  0 2B 
1A08B10 	73 74 72 84 F4 8A A0  1 
1A08B18 	20 40 A0  1 BC 53 A0  1 
1A08B20 	 4 45 A0  1 30 4B A0  1 
1A08B28 	54 62 A0  1 58 46 A0  1 

: +nstr  (s pstr -- adr )     ncount + 1+ taligned ;
1A08B30 	 0  0 2B 6E 73 74 72 85 
1A08B38 	18 8B A0  1 20 40 A0  1 
1A08B40 	F0 53 A0  1  4 45 A0  1 
1A08B48 	30 4B A0  1 54 62 A0  1 
1A08B50 	58 46 A0  1 

\ Copy a packed string from "from-pstr" to "to-pstr"
: "copy (s from-pstr to-pstr -- )      >r count r> place ;
1A08B54 	 0  0 22 63 
1A08B58 	6F 70 79 85 3C 8B A0  1 
1A08B60 	20 40 A0  1 BC 45 A0  1 
1A08B68 	BC 53 A0  1 D0 45 A0  1 
1A08B70 	F0 88 A0  1 58 46 A0  1 

\ Copy a packed string from "from-pstr" to "to-pstr", returning "to-pstr"
: "move (s from-pstr to-pstr -- to-pstr )   >r count r> pack  ;
1A08B78 	 0  0 22 6D 6F 76 65 85 
1A08B80 	60 8B A0  1 20 40 A0  1 
1A08B88 	BC 45 A0  1 BC 53 A0  1 
1A08B90 	D0 45 A0  1 DC 52 A0  1 
1A08B98 	58 46 A0  1 

\ : count      (s adr -- adr+1 len )  dup 1+   swap c@   ;

: printable?  ( n -- flag ) \ true if n is a printable ascii character
1A08B9C 	 0 70 72 69 
1A08BA0 	6E 74 61 62 6C 65 3F 8A 
1A08BA8 	84 8B A0  1 20 40 A0  1 
   dup bl th 7f within  swap  th 80  th ff  between  or
1A08BB0 	40 49 A0  1 28 70 A0  1 
1A08BB8 	58 41 A0  1 7F  0  0  0 
1A08BC0 	 8 71 A0  1 68 49 A0  1 
1A08BC8 	58 41 A0  1 80  0  0  0 
1A08BD0 	58 41 A0  1 FF  0  0  0 
1A08BD8 	D8 70 A0  1 70 44 A0  1 
;
1A08BE0 	58 46 A0  1 
: white-space? ( n -- flag ) \ true is n is non-printable? or a blank
1A08BE4 	 0  0  0 77 
1A08BE8 	68 69 74 65 2D 73 70 61 
1A08BF0 	63 65 3F 8C AC 8B A0  1 
1A08BF8 	20 40 A0  1 
   dup printable? 0=  swap  bl =  or
1A08BFC 	40 49 A0  1 
1A08C00 	AC 8B A0  1 24 47 A0  1 
1A08C08 	68 49 A0  1 28 70 A0  1 
1A08C10 	24 48 A0  1 70 44 A0  1 
;
1A08C18 	58 46 A0  1 

: -leading  ( adr len -- adr' len' )
1A08C1C 	 0  0  0 2D 
1A08C20 	6C 65 61 64 69 6E 67 88 
1A08C28 	F8 8B A0  1 20 40 A0  1 
   begin  dup  while   ( adr' len' )
1A08C30 	40 49 A0  1 DC 41 A0  1 
1A08C38 	38  0  0  0 
      over c@  white-space? 0=  if  exit  then
1A08C3C 	54 49 A0  1 
1A08C40 	C4 4C A0  1 F8 8B A0  1 
1A08C48 	24 47 A0  1 DC 41 A0  1 
1A08C50 	 8  0  0  0 40 46 A0  1 
      swap 1+ swap 1-
1A08C58 	68 49 A0  1 30 4B A0  1 
1A08C60 	68 49 A0  1 54 4B A0  1 
   repeat
1A08C68 	C8 41 A0  1 C4 FF FF FF 
;
1A08C70 	58 46 A0  1 

: -trailing  (s adr len -- adr len' )
1A08C74 	 0  0 2D 74 
1A08C78 	72 61 69 6C 69 6E 67 89 
1A08C80 	2C 8C A0  1 20 40 A0  1 
   dup  0  ?do   2dup + 1- c@   white-space? 0=  ?leave  1-    loop
1A08C88 	40 49 A0  1 70 6F A0  1 
1A08C90 	50 42 A0  1 2C  0  0  0 
1A08C98 	C0 49 A0  1  4 45 A0  1 
1A08CA0 	54 4B A0  1 C4 4C A0  1 
1A08CA8 	F8 8B A0  1 24 47 A0  1 
1A08CB0 	34 43 A0  1 54 4B A0  1 
1A08CB8 	F8 41 A0  1 DC FF FF FF 
;
1A08CC0 	58 46 A0  1 

: f83-compare  (s adr adr2 len -- -1 | 0 | 1 )
1A08CC4 	66 38 33 2D 
1A08CC8 	63 6F 6D 70 61 72 65 8B 
1A08CD0 	84 8C A0  1 20 40 A0  1 
   caps @  if  caps-comp  else  comp  then
1A08CD8 	18 85 A0  1 5C 4C A0  1 
1A08CE0 	DC 41 A0  1 10  0  0  0 
1A08CE8 	60 52 A0  1 C8 41 A0  1 
1A08CF0 	 8  0  0  0 38 52 A0  1 
;
1A08CF8 	58 46 A0  1 
headers
\ Unpacked string comparison
: +-1  ( n -- -1|0|+1 )  0< 2* 1+  ;
1A08CFC 	2B 2D 31 83 
1A08D00 	D4 8C A0  1 20 40 A0  1 
1A08D08 	64 47 A0  1 A0 4B A0  1 
1A08D10 	30 4B A0  1 58 46 A0  1 
: compare  (s adr1 len1 adr2 len2 -- same? )
1A08D18 	63 6F 6D 70 61 72 65 87 
1A08D20 	 4 8D A0  1 20 40 A0  1 
   rot 2dup 2>r min             ( adr1 adr2 min-len )  ( r: len2 len1 )
1A08D28 	7C 49 A0  1 C0 49 A0  1 
1A08D30 	F8 45 A0  1 74 4A A0  1 
   comp dup  if                 ( +-1 )
1A08D38 	38 52 A0  1 40 49 A0  1 
1A08D40 	DC 41 A0  1 14  0  0  0 
      2r> 2drop                 ( +-1 )  \ Initial substrings differ
1A08D48 	10 46 A0  1 AC 49 A0  1 
   else                         ( 0 )
1A08D50 	C8 41 A0  1 28  0  0  0 
      drop  2r> -               ( diff ) \ Initial substrings are the same
1A08D58 	30 49 A0  1 10 46 A0  1 
1A08D60 	18 45 A0  1 
      \ This is tricky.  We want to convert zero to zero, positive
      \ numbers to -1, and negative numbers to +1.  Here's how it works:
      \ "dup  if  ..  then" leave 0 unchanged, and nonzero number are
      \ transformed as follows:
      \       +n  -n
      \ 0>    -1   0
      \ 2*    -2   0
      \ 1+    -1   1
      dup  if  0> 2* 1+  then
1A08D64 	40 49 A0  1 
1A08D68 	DC 41 A0  1 10  0  0  0 
1A08D70 	A4 47 A0  1 A0 4B A0  1 
1A08D78 	30 4B A0  1 
   then
;
1A08D7C 	58 46 A0  1 
\ $= can be defined as "compare 0=", but $= is used much more often,
\ and doesn't require all the tricky argument fixups, so it makes
\ sense to define $= directly, so it runs quite a bit faster.
: $=  (s adr1 len1 adr2 len2 -- same? )
1A08D80 	 0 24 3D 82 24 8D A0  1 
1A08D88 	20 40 A0  1 
   rot tuck  <>  if  3drop false exit  then   ( adr1 adr2 len1 )
1A08D8C 	7C 49 A0  1 
1A08D90 	E8 46 A0  1 44 48 A0  1 
1A08D98 	DC 41 A0  1 10  0  0  0 
1A08DA0 	90 52 A0  1 18 70 A0  1 
1A08DA8 	40 46 A0  1 
   comp 0=    
1A08DAC 	38 52 A0  1 
1A08DB0 	24 47 A0  1 
;
1A08DB4 	58 46 A0  1 


\ From kernel2.fth

: hex        (s -- )   16 base !  ;
1A08DB8 	68 65 78 83 88 8D A0  1 
1A08DC0 	20 40 A0  1 58 41 A0  1 
1A08DC8 	10  0  0  0 B8 75 A0  1 
1A08DD0 	54 4D A0  1 58 46 A0  1 
: decimal    (s -- )   10 base !  ;
1A08DD8 	64 65 63 69 6D 61 6C 87 
1A08DE0 	C0 8D A0  1 20 40 A0  1 
1A08DE8 	58 41 A0  1  A  0  0  0 
1A08DF0 	B8 75 A0  1 54 4D A0  1 
1A08DF8 	58 46 A0  1 
: octal      (s -- )    8 base !  ;
1A08DFC 	 0  0 6F 63 
1A08E00 	74 61 6C 85 E4 8D A0  1 
1A08E08 	20 40 A0  1 F0 6F A0  1 
1A08E10 	B8 75 A0  1 54 4D A0  1 
1A08E18 	58 46 A0  1 
: binary     (s -- )    2 base !  ;
1A08E1C 	 0 62 69 6E 
1A08E20 	61 72 79 86  8 8E A0  1 
1A08E28 	20 40 A0  1 90 6F A0  1 
1A08E30 	B8 75 A0  1 54 4D A0  1 
1A08E38 	58 46 A0  1 

: ?enough   (s n -- )  depth 1- >   ( -4 ) abort" Not enough Parameters"  ;
1A08E3C 	3F 65 6E 6F 
1A08E40 	75 67 68 87 28 8E A0  1 
1A08E48 	20 40 A0  1 28 73 A0  1 
1A08E50 	54 4B A0  1  4 48 A0  1 
1A08E58 	 8 81 A0  1 15 4E 6F 74 
1A08E60 	20 65 6E 6F 75 67 68 20 
1A08E68 	50 61 72 61 6D 65 74 65 
1A08E70 	72 73  0  0 58 46 A0  1 

hex
ps-size-t constant ps-size
1A08E78 	70 73 2D 73 69 7A 65 87 
1A08E80 	48 8E A0  1 68 40 A0  1 
1A08E88 	 0  8  0  0 
rs-size-t constant rs-size
1A08E8C 	72 73 2D 73 
1A08E90 	69 7A 65 87 84 8E A0  1 
1A08E98 	68 40 A0  1  0  8  0  0 

: dump-chars  ( adr -- )
1A08EA0 	 0 64 75 6D 70 2D 63 68 
1A08EA8 	61 72 73 8A 98 8E A0  1 
1A08EB0 	20 40 A0  1 
   h# 10  bounds  do
1A08EB4 	58 41 A0  1 
1A08EB8 	10  0  0  0 F0 6D A0  1 
1A08EC0 	88 42 A0  1 48  0  0  0 
     i c@  dup  bl h# 80 within  if  emit  else  drop ." ."  then
1A08EC8 	B4 42 A0  1 C4 4C A0  1 
1A08ED0 	40 49 A0  1 28 70 A0  1 
1A08ED8 	58 41 A0  1 80  0  0  0 
1A08EE0 	 8 71 A0  1 DC 41 A0  1 
1A08EE8 	10  0  0  0 2C 6C A0  1 
1A08EF0 	C8 41 A0  1 10  0  0  0 
1A08EF8 	30 49 A0  1 20 7C A0  1 
1A08F00 	 1 2E  0  0 
   loop
1A08F04 	F8 41 A0  1 
1A08F08 	C0 FF FF FF 
;
1A08F0C 	58 46 A0  1 
: bdump  (s adr len -- )
1A08F10 	 0  0 62 64 75 6D 70 85 
1A08F18 	B0 8E A0  1 20 40 A0  1 
   base @ >r  hex
1A08F20 	B8 75 A0  1 5C 4C A0  1 
1A08F28 	BC 45 A0  1 C0 8D A0  1 
   bounds  ?do
1A08F30 	F0 6D A0  1 50 42 A0  1 
1A08F38 	84  0  0  0 
      i 8 u.r  ." : "  i  h# 10  bounds  do
1A08F3C 	B4 42 A0  1 
1A08F40 	F0 6F A0  1 E4 77 A0  1 
1A08F48 	20 7C A0  1  2 3A 20  0 
1A08F50 	B4 42 A0  1 58 41 A0  1 
1A08F58 	10  0  0  0 F0 6D A0  1 
1A08F60 	88 42 A0  1 3C  0  0  0 
         i /l bounds  do  i c@ .2  loop  space
1A08F68 	B4 42 A0  1 30 51 A0  1 
1A08F70 	F0 6D A0  1 88 42 A0  1 
1A08F78 	18  0  0  0 B4 42 A0  1 
1A08F80 	C4 4C A0  1 60 79 A0  1 
1A08F88 	F8 41 A0  1 F0 FF FF FF 
1A08F90 	CC 71 A0  1 
      /l +loop
1A08F94 	30 51 A0  1 
1A08F98 	1C 42 A0  1 CC FF FF FF 
      i  dump-chars
1A08FA0 	B4 42 A0  1 B0 8E A0  1 
      cr
1A08FA8 	80 6D A0  1 
   h# 10 +loop
1A08FAC 	58 41 A0  1 
1A08FB0 	10  0  0  0 1C 42 A0  1 
1A08FB8 	84 FF FF FF 
   r> base !
1A08FBC 	D0 45 A0  1 
1A08FC0 	B8 75 A0  1 54 4D A0  1 
;
1A08FC8 	58 46 A0  1 
: wdump  (s adr len -- )
1A08FCC 	 0  0 77 64 
1A08FD0 	75 6D 70 85 1C 8F A0  1 
1A08FD8 	20 40 A0  1 
   base @ >r  hex
1A08FDC 	B8 75 A0  1 
1A08FE0 	5C 4C A0  1 BC 45 A0  1 
1A08FE8 	C0 8D A0  1 
   bounds  ?do
1A08FEC 	F0 6D A0  1 
1A08FF0 	50 42 A0  1 70  0  0  0 
      i 8 u.r  ." : "  i  h# 10  bounds  do
1A08FF8 	B4 42 A0  1 F0 6F A0  1 
1A09000 	E4 77 A0  1 20 7C A0  1 
1A09008 	 2 3A 20  0 B4 42 A0  1 
1A09010 	58 41 A0  1 10  0  0  0 
1A09018 	F0 6D A0  1 88 42 A0  1 
1A09020 	28  0  0  0 
         i w@ 4 u.r space space
1A09024 	B4 42 A0  1 
1A09028 	94 4C A0  1 B0 6F A0  1 
1A09030 	E4 77 A0  1 CC 71 A0  1 
1A09038 	CC 71 A0  1 
      /w +loop
1A0903C 	20 51 A0  1 
1A09040 	1C 42 A0  1 E0 FF FF FF 
      i  dump-chars
1A09048 	B4 42 A0  1 B0 8E A0  1 
      cr
1A09050 	80 6D A0  1 
   h# 10 +loop
1A09054 	58 41 A0  1 
1A09058 	10  0  0  0 1C 42 A0  1 
1A09060 	98 FF FF FF 
   r> base !
1A09064 	D0 45 A0  1 
1A09068 	B8 75 A0  1 54 4D A0  1 
;
1A09070 	58 46 A0  1 
: ldump  (s adr len -- )
1A09074 	 0  0 6C 64 
1A09078 	75 6D 70 85 D8 8F A0  1 
1A09080 	20 40 A0  1 
   base @ >r  hex
1A09084 	B8 75 A0  1 
1A09088 	5C 4C A0  1 BC 45 A0  1 
1A09090 	C0 8D A0  1 
   bounds  ?do
1A09094 	F0 6D A0  1 
1A09098 	50 42 A0  1 70  0  0  0 
      i 8 u.r  ." : "  i  h# 10  bounds  do
1A090A0 	B4 42 A0  1 F0 6F A0  1 
1A090A8 	E4 77 A0  1 20 7C A0  1 
1A090B0 	 2 3A 20  0 B4 42 A0  1 
1A090B8 	58 41 A0  1 10  0  0  0 
1A090C0 	F0 6D A0  1 88 42 A0  1 
1A090C8 	28  0  0  0 
         i l@ 8 u.r space space
1A090CC 	B4 42 A0  1 
1A090D0 	6C 4C A0  1 F0 6F A0  1 
1A090D8 	E4 77 A0  1 CC 71 A0  1 
1A090E0 	CC 71 A0  1 
      /l +loop
1A090E4 	30 51 A0  1 
1A090E8 	1C 42 A0  1 E0 FF FF FF 
      i  dump-chars
1A090F0 	B4 42 A0  1 B0 8E A0  1 
      cr
1A090F8 	80 6D A0  1 
   h# 10 +loop
1A090FC 	58 41 A0  1 
1A09100 	10  0  0  0 1C 42 A0  1 
1A09108 	98 FF FF FF 
   r> base !
1A0910C 	D0 45 A0  1 
1A09110 	B8 75 A0  1 54 4D A0  1 
;
1A09118 	58 46 A0  1 


: abort  (s ?? -- )  mark-error  -1 throw  ;
1A0911C 	 0  0 61 62 
1A09120 	6F 72 74 85 80 90 A0  1 
1A09128 	20 40 A0  1 E0 7F A0  1 
1A09130 	58 41 A0  1 FF FF FF FF 
1A09138 	74 7F A0  1 58 46 A0  1 

\ Run-time words used by the compiler; also used by metacompiled programs
\ even if the interactive compiler is not present

: ?throw  ( flag throw-code -- )  swap  if  throw  else  drop  then  ;
1A09140 	 0 3F 74 68 72 6F 77 86 
1A09148 	28 91 A0  1 20 40 A0  1 
1A09150 	68 49 A0  1 DC 41 A0  1 
1A09158 	10  0  0  0 74 7F A0  1 
1A09160 	C8 41 A0  1  8  0  0  0 
1A09168 	30 49 A0  1 58 46 A0  1 

\ [ifndef] round-down
: round-down  ( adr granularity -- adr' )  1- invert and  ;
1A09170 	 0 72 6F 75 6E 64 2D 64 
1A09178 	6F 77 6E 8A 4C 91 A0  1 
1A09180 	20 40 A0  1 54 4B A0  1 
1A09188 	30 45 A0  1 5C 44 A0  1 
1A09190 	58 46 A0  1 
\ [then]
: round-up  ( adr granularity -- adr' )  1-  tuck +  swap invert and  ;
1A09194 	 0  0  0 72 
1A09198 	6F 75 6E 64 2D 75 70 88 
1A091A0 	80 91 A0  1 20 40 A0  1 
1A091A8 	54 4B A0  1 E8 46 A0  1 
1A091B0 	 4 45 A0  1 68 49 A0  1 
1A091B8 	30 45 A0  1 5C 44 A0  1 
1A091C0 	58 46 A0  1 
: (align)  ( size granularity -- )
1A091C4 	28 61 6C 69 
1A091C8 	67 6E 29 87 A4 91 A0  1 
1A091D0 	20 40 A0  1 
   1-  begin  dup here and  while  0 c,  repeat  drop
1A091D4 	54 4B A0  1 
1A091D8 	40 49 A0  1 70 54 A0  1 
1A091E0 	5C 44 A0  1 DC 41 A0  1 
1A091E8 	14  0  0  0 70 6F A0  1 
1A091F0 	B8 55 A0  1 C8 41 A0  1 
1A091F8 	E0 FF FF FF 30 49 A0  1 
;
1A09200 	58 46 A0  1 

\ From compiler.fth

hex


[ifdef] run-time

:-h immediate ( -- )
\ Don't fix the target header because there isn't one!
\   lastacf-t @ 1-  th 40 toggle-t       \ fix target header
   \ We can't do this with immediate-h because the symbol we need to make
   \ immediate isn't necessarily the last one for which a header was
   \ created.  It could have been a forward reference, with the header
   \ created long ago.
   lastacf-s @ >flags  th 40 toggle        \ fix symbol table
;-h

: allot-abort  (s size -- size )
   ." Dictionary overflow - here "  here .  ." limit " limit .  cr
   ( -8 ) abort
;

[else]

: allot-abort  (s size -- size )
1A09204 	61 6C 6C 6F 
1A09208 	74 2D 61 62 6F 72 74 8B 
1A09210 	D0 91 A0  1 20 40 A0  1 
   ." Dictionary overflow - here "  here .  ." limit " limit .  cr
1A09218 	20 7C A0  1 1B 44 69 63 
1A09220 	74 69 6F 6E 61 72 79 20 
1A09228 	6F 76 65 72 66 6C 6F 77 
1A09230 	20 2D 20 68 65 72 65 20 
1A09238 	 0  0  0  0 70 54 A0  1 
1A09240 	94 7A A0  1 20 7C A0  1 
1A09248 	 6 6C 69 6D 69 74 20  0 
1A09250 	5C 54 A0  1 94 7A A0  1 
1A09258 	80 6D A0  1 
   ( -8 ) abort
1A0925C 	28 91 A0  1 
;
1A09260 	58 46 A0  1 

[then]

' allot-abort is allot-error


64\ : x,     (s x -- )       here   /x allot   unaligned-!   ;
[ifdef] big-endian-t
: d,     (s d -- )       here   2 /n* allot   2!   ;
[else]
: d,     (s d -- )       swap , ,   ;
1A09264 	 0 64 2C 82 
1A09268 	14 92 A0  1 20 40 A0  1 
1A09270 	68 49 A0  1 98 55 A0  1 
1A09278 	98 55 A0  1 58 46 A0  1 
[then]


: ?pairs  (s n1 n2 -- )   <>  ( -22 ) abort" Control structure mismatch" ;
1A09280 	 0 3F 70 61 69 72 73 86 
1A09288 	6C 92 A0  1 20 40 A0  1 
1A09290 	44 48 A0  1  8 81 A0  1 
1A09298 	1A 43 6F 6E 74 72 6F 6C 
1A092A0 	20 73 74 72 75 63 74 75 
1A092A8 	72 65 20 6D 69 73 6D 61 
1A092B0 	74 63 68  0 58 46 A0  1 

[ifndef] run-time

\ Compiler and state error checking
: ?comp   (s -- )  state @  0= ( -14 ) abort" Compilation Only " ;
1A092B8 	 0  0 3F 63 6F 6D 70 85 
1A092C0 	8C 92 A0  1 20 40 A0  1 
1A092C8 	38 54 A0  1 5C 4C A0  1 
1A092D0 	24 47 A0  1  8 81 A0  1 
1A092D8 	11 43 6F 6D 70 69 6C 61 
1A092E0 	74 69 6F 6E 20 4F 6E 6C 
1A092E8 	79 20  0  0 58 46 A0  1 
: ?exec   (s -- )  state @     ( -29 ) abort" Execution Only " ;
1A092F0 	 0  0 3F 65 78 65 63 85 
1A092F8 	C4 92 A0  1 20 40 A0  1 
1A09300 	38 54 A0  1 5C 4C A0  1 
1A09308 	 8 81 A0  1  F 45 78 65 
1A09310 	63 75 74 69 6F 6E 20 4F 
1A09318 	6E 6C 79 20  0  0  0  0 
1A09320 	58 46 A0  1 

: parse-word  ( -- adr len )
1A09324 	 0 70 61 72 
1A09328 	73 65 2D 77 6F 72 64 8A 
1A09330 	FC 92 A0  1 20 40 A0  1 
   source >in @ /string  over >r   ( adr1 len1 )  ( r: adr1 )
1A09338 	84 81 A0  1 28 85 A0  1 
1A09340 	5C 4C A0  1 3C 85 A0  1 
1A09348 	54 49 A0  1 BC 45 A0  1 
   skipwhite                       ( adr2 len2 )
1A09350 	CC 64 A0  1 
   scantowhite                     ( adr2 adr3 adr4 )
1A09354 	 0 65 A0  1 
   r> - >in +!                     ( adr2 adr3 ) ( r: )
1A09358 	D0 45 A0  1 18 45 A0  1 
1A09360 	28 85 A0  1  C 4C A0  1 
   over -                          ( adr1 len )
1A09368 	54 49 A0  1 18 45 A0  1 
;
1A09370 	58 46 A0  1 

: safe-parse-word  ( -- adr len )
1A09374 	73 61 66 65 
1A09378 	2D 70 61 72 73 65 2D 77 
1A09380 	6F 72 64 8F 34 93 A0  1 
1A09388 	20 40 A0  1 
   parse-word dup 0=  ( -16 ) abort" Unexpected end-of-line"
1A0938C 	34 93 A0  1 
1A09390 	40 49 A0  1 24 47 A0  1 
1A09398 	 8 81 A0  1 16 55 6E 65 
1A093A0 	78 70 65 63 74 65 64 20 
1A093A8 	65 6E 64 2D 6F 66 2D 6C 
1A093B0 	69 6E 65  0 
;
1A093B4 	58 46 A0  1 

defer $find
1A093B8 	 0  0 24 66 69 6E 64 85 
1A093C0 	88 93 A0  1 5C 40 A0  1 
1A093C8 	30  1  0  0 

: defined?  ( "name" -- flag )
1A093CC 	 0  0  0 64 
1A093D0 	65 66 69 6E 65 64 3F 88 
1A093D8 	C4 93 A0  1 20 40 A0  1 
   safe-parse-word  $find  dup  if  nip  else  nip nip  then
1A093E0 	88 93 A0  1 C4 93 A0  1 
1A093E8 	40 49 A0  1 DC 41 A0  1 
1A093F0 	10  0  0  0 FC 46 A0  1 
1A093F8 	C8 41 A0  1  C  0  0  0 
1A09400 	FC 46 A0  1 FC 46 A0  1 
;
1A09408 	58 46 A0  1 
: $defined   (s -- adr len 0 | xt +-1 )  safe-parse-word $find  ;
1A0940C 	 0  0  0 24 
1A09410 	64 65 66 69 6E 65 64 88 
1A09418 	DC 93 A0  1 20 40 A0  1 
1A09420 	88 93 A0  1 C4 93 A0  1 
1A09428 	58 46 A0  1 
  ' noop is mark-error
  ' noop is show-error
: where  ( -- )  mark-error show-error  ;
1A0942C 	 0  0 77 68 
1A09430 	65 72 65 85 1C 94 A0  1 
1A09438 	20 40 A0  1 E0 7F A0  1 
1A09440 	F8 7F A0  1 58 46 A0  1 

: .not-found  ( adr len -- )  where  type ."  ?" cr  ;
1A09448 	 0 2E 6E 6F 74 2D 66 6F 
1A09450 	75 6E 64 8A 38 94 A0  1 
1A09458 	20 40 A0  1 38 94 A0  1 
1A09460 	 4 6C A0  1 20 7C A0  1 
1A09468 	 2 20 3F  0 80 6D A0  1 
1A09470 	58 46 A0  1 
: $?missing  ( +-1 | adr len 0 -- +-1 )
1A09474 	 0  0 24 3F 
1A09478 	6D 69 73 73 69 6E 67 89 
1A09480 	58 94 A0  1 20 40 A0  1 
   dup 0=  if  drop  .not-found  ( -13 ) abort  then
1A09488 	40 49 A0  1 24 47 A0  1 
1A09490 	DC 41 A0  1 10  0  0  0 
1A09498 	30 49 A0  1 58 94 A0  1 
1A094A0 	28 91 A0  1 
;
1A094A4 	58 46 A0  1 
: 'i  ( "name" -- xt +-1 )  $defined $?missing  ;
1A094A8 	 0 27 69 82 84 94 A0  1 
1A094B0 	20 40 A0  1 1C 94 A0  1 
1A094B8 	84 94 A0  1 58 46 A0  1 
: literal     (s n -- )
1A094C0 	6C 69 74 65 72 61 6C C7 
1A094C8 	B0 94 A0  1 20 40 A0  1 
\t16   dup -1  h# fffe  between  if
\t16      compile (wlit) 1+ w,
\t16   else
\t16      compile  (lit)  ,
\t16   then

64\ \t32   dup -1 h# 0.ffff.fffe n->l between  if
64\ \t32      compile (llit) 1+ l,
64\ \t32   else
    \t32      compile (lit) ,
1A094D0 	8C 75 A0  1 58 41 A0  1 
1A094D8 	98 55 A0  1 
64\ \t32   then
;  immediate
1A094DC 	58 46 A0  1 
: lliteral  (s l -- )  compile (llit) l,  ; immediate
1A094E0 	 0  0  0 6C 6C 69 74 65 
1A094E8 	72 61 6C C8 CC 94 A0  1 
1A094F0 	20 40 A0  1 8C 75 A0  1 
1A094F8 	6C 41 A0  1 F8 55 A0  1 
1A09500 	58 46 A0  1 
: dliteral  (s l -- )  compile (dlit) d,  ; immediate
1A09504 	 0  0  0 64 
1A09508 	6C 69 74 65 72 61 6C C8 
1A09510 	F0 94 A0  1 20 40 A0  1 
1A09518 	8C 75 A0  1 80 41 A0  1 
1A09520 	6C 92 A0  1 58 46 A0  1 

: 2literal   ( d -- )  swap  [compile] literal  [compile] literal  ; immediate
1A09528 	 0  0  0 32 6C 69 74 65 
1A09530 	72 61 6C C8 14 95 A0  1 
1A09538 	20 40 A0  1 68 49 A0  1 
1A09540 	CC 94 A0  1 CC 94 A0  1 
1A09548 	58 46 A0  1 

: char  \ char (s -- n )
1A0954C 	 0  0  0 63 
1A09550 	68 61 72 84 38 95 A0  1 
1A09558 	20 40 A0  1 
   safe-parse-word drop c@
1A0955C 	88 93 A0  1 
1A09560 	30 49 A0  1 C4 4C A0  1 
;
1A09568 	58 46 A0  1 

defer do-literal
1A0956C 	 0 64 6F 2D 
1A09570 	6C 69 74 65 72 61 6C 8A 
1A09578 	58 95 A0  1 5C 40 A0  1 
1A09580 	34  1  0  0 

: [char]  \ char  (s -- )
1A09584 	 0 5B 63 68 
1A09588 	61 72 5D C6 7C 95 A0  1 
1A09590 	20 40 A0  1 
   char  1 do-literal
1A09594 	58 95 A0  1 
1A09598 	80 6F A0  1 7C 95 A0  1 
; immediate
1A095A0 	58 46 A0  1 
: ascii  \ char (s -- n )
1A095A4 	 0  0 61 73 
1A095A8 	63 69 69 C5 90 95 A0  1 
1A095B0 	20 40 A0  1 
   char  1 do-literal
1A095B4 	58 95 A0  1 
1A095B8 	80 6F A0  1 7C 95 A0  1 
; immediate
1A095C0 	58 46 A0  1 
: control  \ char  (s -- n )
1A095C4 	63 6F 6E 74 
1A095C8 	72 6F 6C C7 B0 95 A0  1 
1A095D0 	20 40 A0  1 
   char  bl 1- and  1 do-literal
1A095D4 	58 95 A0  1 
1A095D8 	28 70 A0  1 54 4B A0  1 
1A095E0 	5C 44 A0  1 80 6F A0  1 
1A095E8 	7C 95 A0  1 
; immediate
1A095EC 	58 46 A0  1 

: '   \ name  (s -- cfa )
1A095F0 	 0  0 27 81 D0 95 A0  1 
1A095F8 	20 40 A0  1 
   'i drop
1A095FC 	B0 94 A0  1 
1A09600 	30 49 A0  1 
;
1A09604 	58 46 A0  1 
: [']  \ name  (s -- )  ( Run time: -- acf )
1A09608 	5B 27 5D C3 F8 95 A0  1 
1A09610 	20 40 A0  1 
   +level ' compile (') compile, -level
1A09614 	 4 83 A0  1 
1A09618 	F8 95 A0  1 8C 75 A0  1 
1A09620 	60 53 A0  1 74 75 A0  1 
1A09628 	98 83 A0  1 
; immediate
1A0962C 	58 46 A0  1 
: [compile]  \ name  (s -- )
1A09630 	 0  0 5B 63 6F 6D 70 69 
1A09638 	6C 65 5D C9 10 96 A0  1 
1A09640 	20 40 A0  1 
   ' compile,
1A09644 	F8 95 A0  1 
1A09648 	74 75 A0  1 
; immediate
1A0964C 	58 46 A0  1 
: postpone  \ name  (s -- )
1A09650 	 0  0  0 70 6F 73 74 70 
1A09658 	6F 6E 65 C8 40 96 A0  1 
1A09660 	20 40 A0  1 
   'i  0<  if  compile compile  then  compile,
1A09664 	B0 94 A0  1 
1A09668 	64 47 A0  1 DC 41 A0  1 
1A09670 	 C  0  0  0 8C 75 A0  1 
1A09678 	8C 75 A0  1 74 75 A0  1 
; immediate
1A09680 	58 46 A0  1 

: recurse  (s -- )  lastacf compile,  ; immediate
1A09684 	72 65 63 75 
1A09688 	72 73 65 C7 60 96 A0  1 
1A09690 	20 40 A0  1 AC 57 A0  1 
1A09698 	74 75 A0  1 58 46 A0  1 

\ : dumpx  \ name  (s -- )
\   blword 10 dump
\ ;

: abort"  \ string"  (s -- )
1A096A0 	 0 61 62 6F 72 74 22 C6 
1A096A8 	90 96 A0  1 20 40 A0  1 
   +level  compile (abort")  ,"  -level
1A096B0 	 4 83 A0  1 8C 75 A0  1 
1A096B8 	 8 81 A0  1 88 89 A0  1 
1A096C0 	98 83 A0  1 
; immediate
1A096C4 	58 46 A0  1 

[then]


headerless
: +>mark    (s acf -- >mark )  +level compile,  here 0 branch,  ;
1A096C8 	 0 2B 3E 6D 61 72 6B 86 
1A096D0 	AC 96 A0  1 20 40 A0  1 
1A096D8 	 4 83 A0  1 74 75 A0  1 
1A096E0 	70 54 A0  1 70 6F A0  1 
1A096E8 	10 58 A0  1 58 46 A0  1 
: +<mark    (s -- <mark )      +level  here  ;
1A096F0 	 0 2B 3C 6D 61 72 6B 86 
1A096F8 	D4 96 A0  1 20 40 A0  1 
1A09700 	 4 83 A0  1 70 54 A0  1 
1A09708 	58 46 A0  1 
: ->resolve (s >mark -- )      here over - swap branch!  -level  ;
1A0970C 	 0  0 2D 3E 
1A09710 	72 65 73 6F 6C 76 65 89 
1A09718 	FC 96 A0  1 20 40 A0  1 
1A09720 	70 54 A0  1 54 49 A0  1 
1A09728 	18 45 A0  1 68 49 A0  1 
1A09730 	40 58 A0  1 98 83 A0  1 
1A09738 	58 46 A0  1 
: -<resolve (s <mark acf -- )  compile,  here - branch,  -level  ;
1A0973C 	 0  0 2D 3C 
1A09740 	72 65 73 6F 6C 76 65 89 
1A09748 	1C 97 A0  1 20 40 A0  1 
1A09750 	74 75 A0  1 70 54 A0  1 
1A09758 	18 45 A0  1 10 58 A0  1 
1A09760 	98 83 A0  1 58 46 A0  1 
headers

: but      ( m1 m2 -- m2 m1 )  swap  ;
1A09768 	62 75 74 83 4C 97 A0  1 
1A09770 	20 40 A0  1 68 49 A0  1 
1A09778 	58 46 A0  1 
: yet      ( m -- m m )  dup  ;
1A0977C 	79 65 74 83 
1A09780 	70 97 A0  1 20 40 A0  1 
1A09788 	40 49 A0  1 58 46 A0  1 
: cs-pick  ( mn .. m0 n -- mn .. m0 mn )  pick  ;
1A09790 	63 73 2D 70 69 63 6B 87 
1A09798 	84 97 A0  1 20 40 A0  1 
1A097A0 	 C 4A A0  1 58 46 A0  1 
: cs-roll  ( mn .. m0 n -- mn-1 .. m0 mn )  roll  ;
1A097A8 	63 73 2D 72 6F 6C 6C 87 
1A097B0 	9C 97 A0  1 20 40 A0  1 
1A097B8 	50 70 A0  1 58 46 A0  1 

: begin   ( -- <m )        +<mark				; immediate
1A097C0 	 0  0 62 65 67 69 6E C5 
1A097C8 	B4 97 A0  1 20 40 A0  1 
1A097D0 	FC 96 A0  1 58 46 A0  1 
: until   ( <m -- )        ['] ?branch -<resolve		; immediate
1A097D8 	 0  0 75 6E 74 69 6C C5 
1A097E0 	CC 97 A0  1 20 40 A0  1 
1A097E8 	60 53 A0  1 DC 41 A0  1 
1A097F0 	4C 97 A0  1 58 46 A0  1 
: again   ( <m -- )        ['] branch  -<resolve		; immediate
1A097F8 	 0  0 61 67 61 69 6E C5 
1A09800 	E4 97 A0  1 20 40 A0  1 
1A09808 	60 53 A0  1 C8 41 A0  1 
1A09810 	4C 97 A0  1 58 46 A0  1 

: if      ( -- >m )        ['] ?branch +>mark			; immediate
1A09818 	 0 69 66 C2  4 98 A0  1 
1A09820 	20 40 A0  1 60 53 A0  1 
1A09828 	DC 41 A0  1 D4 96 A0  1 
1A09830 	58 46 A0  1 
: ahead   ( -- >m )        ['] branch  +>mark			; immediate
1A09834 	 0  0 61 68 
1A09838 	65 61 64 C5 20 98 A0  1 
1A09840 	20 40 A0  1 60 53 A0  1 
1A09848 	C8 41 A0  1 D4 96 A0  1 
1A09850 	58 46 A0  1 
: then    ( >m -- )        ->resolve				; immediate
1A09854 	 0  0  0 74 
1A09858 	68 65 6E C4 40 98 A0  1 
1A09860 	20 40 A0  1 1C 97 A0  1 
1A09868 	58 46 A0  1 

: repeat  ( >m <m -- )     [compile] again      [compile] then	; immediate
1A0986C 	 0 72 65 70 
1A09870 	65 61 74 C6 60 98 A0  1 
1A09878 	20 40 A0  1  4 98 A0  1 
1A09880 	60 98 A0  1 58 46 A0  1 
: else	  ( >m1 -- >m2 )   [compile] ahead  but [compile] then	; immediate
1A09888 	 0  0  0 65 6C 73 65 C4 
1A09890 	78 98 A0  1 20 40 A0  1 
1A09898 	40 98 A0  1 70 97 A0  1 
1A098A0 	60 98 A0  1 58 46 A0  1 
: while   ( <m -- >m <m )  [compile] if     but			; immediate
1A098A8 	 0  0 77 68 69 6C 65 C5 
1A098B0 	94 98 A0  1 20 40 A0  1 
1A098B8 	20 98 A0  1 70 97 A0  1 
1A098C0 	58 46 A0  1 

: do      ( -- >m <m )     ['] (do)    +>mark     +<mark	; immediate
1A098C4 	 0 64 6F C2 
1A098C8 	B4 98 A0  1 20 40 A0  1 
1A098D0 	60 53 A0  1 88 42 A0  1 
1A098D8 	D4 96 A0  1 FC 96 A0  1 
1A098E0 	58 46 A0  1 
: ?do     ( -- >m <m )     ['] (?do)   +>mark     +<mark	; immediate
1A098E4 	3F 64 6F C3 
1A098E8 	CC 98 A0  1 20 40 A0  1 
1A098F0 	60 53 A0  1 50 42 A0  1 
1A098F8 	D4 96 A0  1 FC 96 A0  1 
1A09900 	58 46 A0  1 
: loop    ( >m <m -- )     ['] (loop)  -<resolve  ->resolve	; immediate
1A09904 	 0  0  0 6C 
1A09908 	6F 6F 70 C4 EC 98 A0  1 
1A09910 	20 40 A0  1 60 53 A0  1 
1A09918 	F8 41 A0  1 4C 97 A0  1 
1A09920 	1C 97 A0  1 58 46 A0  1 
: +loop   ( >m <m -- )     ['] (+loop) -<resolve  ->resolve	; immediate
1A09928 	 0  0 2B 6C 6F 6F 70 C5 
1A09930 	10 99 A0  1 20 40 A0  1 
1A09938 	60 53 A0  1 1C 42 A0  1 
1A09940 	4C 97 A0  1 1C 97 A0  1 
1A09948 	58 46 A0  1 

\ XXX According to ANS Forth, LEAVE and ?LEAVE no longer have to be immediate
: leave   ( -- )   compile (leave)                              ; immediate
1A0994C 	 0  0 6C 65 
1A09950 	61 76 65 C5 34 99 A0  1 
1A09958 	20 40 A0  1 8C 75 A0  1 
1A09960 	18 43 A0  1 58 46 A0  1 
: ?leave  ( -- )   compile (?leave)                             ; immediate
1A09968 	 0 3F 6C 65 61 76 65 C6 
1A09970 	58 99 A0  1 20 40 A0  1 
1A09978 	8C 75 A0  1 34 43 A0  1 
1A09980 	58 46 A0  1 


: ualloc  ( #bytes -- new-user-number )  \ allocates user space
1A09984 	 0 75 61 6C 
1A09988 	6C 6F 63 86 74 99 A0  1 
1A09990 	20 40 A0  1 
   #user @ user-size >=  ( ?? ) abort" User area used up!"   ( #bytes )
1A09994 	7C 66 A0  1 
1A09998 	5C 4C A0  1 E8 65 A0  1 
1A099A0 	EC 48 A0  1  8 81 A0  1 
1A099A8 	12 55 73 65 72 20 61 72 
1A099B0 	65 61 20 75 73 65 64 20 
1A099B8 	75 70 21  0 

   \ If we are allocating fewer bytes than the alignment granularity,
   \ it is safe to assume that strict alignment is not required.
   \ For example, a 2-byte token doesn't have to be aligned on a 4-byte
   \ boundary.
   ( #bytes )
   #user @  over #ualign >=  if  ualigned dup #user !  then  ( #bytes user# )
1A099BC 	7C 66 A0  1 
1A099C0 	5C 4C A0  1 54 49 A0  1 
1A099C8 	D0 66 A0  1 EC 48 A0  1 
1A099D0 	DC 41 A0  1 14  0  0  0 
1A099D8 	E8 66 A0  1 40 49 A0  1 
1A099E0 	7C 66 A0  1 54 4D A0  1 

   swap #user +!
1A099E8 	68 49 A0  1 7C 66 A0  1 
1A099F0 	 C 4C A0  1 
;
1A099F4 	58 46 A0  1 

: user  \ name  (s user# -- )
1A099F8 	 0  0  0 75 73 65 72 84 
1A09A00 	90 99 A0  1 20 40 A0  1 
   header user-cf
1A09A08 	DC 6D A0  1 C4 5B A0  1 
\t32  l,
1A09A10 	F8 55 A0  1 
\t16  w,
;
1A09A14 	58 46 A0  1 

[ifndef] run-time
: nuser  \ name  ( -- )  \ like user but automatically allocates space
1A09A18 	 0  0 6E 75 73 65 72 85 
1A09A20 	 4 9A A0  1 20 40 A0  1 
   /n ualloc user
1A09A28 	40 51 A0  1 90 99 A0  1 
1A09A30 	 4 9A A0  1 
;
1A09A34 	58 46 A0  1 
: tuser  \ name  ( -- )  \ like user but automatically allocates space
1A09A38 	 0  0 74 75 73 65 72 85 
1A09A40 	24 9A A0  1 20 40 A0  1 
   /token ualloc user
1A09A48 	B4 46 A0  1 90 99 A0  1 
1A09A50 	 4 9A A0  1 
;
1A09A54 	58 46 A0  1 
: auser  \ name  ( -- )  \ like user but automatically allocates space
1A09A58 	 0  0 61 75 73 65 72 85 
1A09A60 	44 9A A0  1 20 40 A0  1 
   /a ualloc user
1A09A68 	78 58 A0  1 90 99 A0  1 
1A09A70 	 4 9A A0  1 
;
1A09A74 	58 46 A0  1 
[then]

: user#,  ( #bytes -- user-var-adr )
1A09A78 	 0 75 73 65 72 23 2C 86 
1A09A80 	64 9A A0  1 20 40 A0  1 
   here swap ualloc
1A09A88 	70 54 A0  1 68 49 A0  1 
1A09A90 	90 99 A0  1 
\t32   l,
1A09A94 	F8 55 A0  1 
\t16   w,
   >user
1A09A98 	C8 74 A0  1 
;
1A09A9C 	58 46 A0  1 

[ifndef] run-time
: .id     (s anf -- )  name>string type space  ;
1A09AA0 	2E 69 64 83 84 9A A0  1 
1A09AA8 	20 40 A0  1 58 74 A0  1 
1A09AB0 	 4 6C A0  1 CC 71 A0  1 
1A09AB8 	58 46 A0  1 
: .name   (s acf -- )  >name .id  ;
1A09ABC 	 0  0 2E 6E 
1A09AC0 	61 6D 65 85 A8 9A A0  1 
1A09AC8 	20 40 A0  1 24 74 A0  1 
1A09AD0 	A8 9A A0  1 58 46 A0  1 
[then]

nuser warning      \ control of warning messages
1A09AD8 	77 61 72 6E 69 6E 67 87 
1A09AE0 	C8 9A A0  1 48 40 A0  1 
1A09AE8 	38  1  0  0 
-1       is warning

[ifndef] run-time

\ Dr. Charles Eaker's case statement
\ Example of use:
\ : foo ( selector -- )
\   case
\     0  of  ." It was 0"   endof
\     1  of  ." It was 1"   endof
\     2  of  ." It was 2"   endof
\     ( selector) ." **** It was " dup u.
\   endcase
\ ;
\ The default clause is optional.
\ When an of clause is executed, the selector is NOT on the stack
\ When a default clause is executed, the selector IS on the stack.
\ The default clause may use the selector, but must not remove it
\ from the stack (it will be automatically removed just before the endcase)

\ At run time, (of) tests the top of the stack against the selector.
\ If they are the same, the selector is dropped and the following
\ forth code is executed.  If they are not the same, execution continues
\ at the point just following the the matching ENDOF

: case   ( -- 0 )   +level  0                            ; immediate
1A09AEC 	 0  0  0 63 
1A09AF0 	61 73 65 C4 E4 9A A0  1 
1A09AF8 	20 40 A0  1  4 83 A0  1 
1A09B00 	70 6F A0  1 58 46 A0  1 
: of     ( -- >m )  ['] (of)     +>mark                  ; immediate
1A09B08 	 0 6F 66 C2 F8 9A A0  1 
1A09B10 	20 40 A0  1 60 53 A0  1 
1A09B18 	48 43 A0  1 D4 96 A0  1 
1A09B20 	58 46 A0  1 
: endof  ( >m -- )  ['] (endof)  +>mark  but  ->resolve  ; immediate
1A09B24 	 0  0 65 6E 
1A09B28 	64 6F 66 C5 10 9B A0  1 
1A09B30 	20 40 A0  1 60 53 A0  1 
1A09B38 	6C 43 A0  1 D4 96 A0  1 
1A09B40 	70 97 A0  1 1C 97 A0  1 
1A09B48 	58 46 A0  1 

: endcase  ( 0 [ >m ... ] -- )
1A09B4C 	65 6E 64 63 
1A09B50 	61 73 65 C7 30 9B A0  1 
1A09B58 	20 40 A0  1 
   compile (endcase)
1A09B5C 	8C 75 A0  1 
1A09B60 	84 43 A0  1 
   begin  ?dup  while  ->resolve  repeat
1A09B64 	B4 70 A0  1 
1A09B68 	DC 41 A0  1 10  0  0  0 
1A09B70 	1C 97 A0  1 C8 41 A0  1 
1A09B78 	EC FF FF FF 
   -level
1A09B7C 	98 83 A0  1 
; immediate
1A09B80 	58 46 A0  1 

[then]

\ From interp.fth

\ The Text Interpreter

\ Input stream parsing

\ Error reporting

: lose  (s -- ) true ( -13) abort" Undefined word encountered "  ;
1A09B84 	 0  0  0 6C 
1A09B88 	6F 73 65 84 58 9B A0  1 
1A09B90 	20 40 A0  1  4 70 A0  1 
1A09B98 	 8 81 A0  1 1B 55 6E 64 
1A09BA0 	65 66 69 6E 65 64 20 77 
1A09BA8 	6F 72 64 20 65 6E 63 6F 
1A09BB0 	75 6E 74 65 72 65 64 20 
1A09BB8 	 0  0  0  0 58 46 A0  1 

\ Number parsing
hex
: >number  (s ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
1A09BC0 	3E 6E 75 6D 62 65 72 87 
1A09BC8 	90 9B A0  1 20 40 A0  1 
  \ convert double number, leaving address of first unconverted byte
   begin  dup  while                  ( ud adr len )
1A09BD0 	40 49 A0  1 DC 41 A0  1 
1A09BD8 	74  0  0  0 
      over c@  base @  digit          ( ud adr len  digit true  |  char false )
1A09BDC 	54 49 A0  1 
1A09BE0 	C4 4C A0  1 B8 75 A0  1 
1A09BE8 	5C 4C A0  1 D8 43 A0  1 
      0=  if  drop exit  then         ( ud adr len  digit )
1A09BF0 	24 47 A0  1 DC 41 A0  1 
1A09BF8 	 C  0  0  0 30 49 A0  1 
1A09C00 	40 46 A0  1 
      >r  2swap  r>                   ( adr len ud  digit )
1A09C04 	BC 45 A0  1 
1A09C08 	F4 49 A0  1 D0 45 A0  1 
      swap base @ um*  drop           ( adr len ud.low  digit ud.high' )
1A09C10 	68 49 A0  1 B8 75 A0  1 
1A09C18 	5C 4C A0  1 50 5D A0  1 
1A09C20 	30 49 A0  1 
      rot base @ um*  d+              ( adr len  ud' )
1A09C24 	7C 49 A0  1 
1A09C28 	B8 75 A0  1 5C 4C A0  1 
1A09C30 	50 5D A0  1 E0 5D A0  1 
      2swap  1 /string                ( ud' adr len )
1A09C38 	F4 49 A0  1 80 6F A0  1 
1A09C40 	3C 85 A0  1 
   repeat                             ( ud' adr len )
1A09C44 	C8 41 A0  1 
1A09C48 	88 FF FF FF 
;
1A09C4C 	58 46 A0  1 
: numdelim?  ( char -- flag )  dup ascii . =  swap ascii , =  or  ;
1A09C50 	 0  0 6E 75 6D 64 65 6C 
1A09C58 	69 6D 3F 89 CC 9B A0  1 
1A09C60 	20 40 A0  1 40 49 A0  1 
1A09C68 	58 41 A0  1 2E  0  0  0 
1A09C70 	24 48 A0  1 68 49 A0  1 
1A09C78 	58 41 A0  1 2C  0  0  0 
1A09C80 	24 48 A0  1 70 44 A0  1 
1A09C88 	58 46 A0  1 
: $dnumber?  ( adr len -- [ n .. ] #cells )
1A09C8C 	 0  0 24 64 
1A09C90 	6E 75 6D 62 65 72 3F 89 
1A09C98 	60 9C A0  1 20 40 A0  1 
   0 0  2swap                                         ( ud $ )
1A09CA0 	70 6F A0  1 70 6F A0  1 
1A09CA8 	F4 49 A0  1 
   dup  0=  if  4drop  0  exit  then            ( ud $ )
1A09CAC 	40 49 A0  1 
1A09CB0 	24 47 A0  1 DC 41 A0  1 
1A09CB8 	10  0  0  0 38 53 A0  1 
1A09CC0 	70 6F A0  1 40 46 A0  1 
   over c@ ascii - =                                  ( ud $ neg? )
1A09CC8 	54 49 A0  1 C4 4C A0  1 
1A09CD0 	58 41 A0  1 2D  0  0  0 
1A09CD8 	24 48 A0  1 
   dup  >r  negate /string                            ( ud $' )  ( r: neg? )
1A09CDC 	40 49 A0  1 
1A09CE0 	BC 45 A0  1 48 45 A0  1 
1A09CE8 	3C 85 A0  1 

   \ Convert groups of digits possibly separated by periods or commas
   begin  >number  dup 1 >  while                     ( ud' $' )
1A09CEC 	CC 9B A0  1 
1A09CF0 	40 49 A0  1 80 6F A0  1 
1A09CF8 	 4 48 A0  1 DC 41 A0  1 
1A09D00 	3C  0  0  0 
      over c@ numdelim?  0=  if                       ( ud' $' )
1A09D04 	54 49 A0  1 
1A09D08 	C4 4C A0  1 60 9C A0  1 
1A09D10 	24 47 A0  1 DC 41 A0  1 
1A09D18 	14  0  0  0 
         r> 5drop  0  exit				( ud' $' )
1A09D1C 	D0 45 A0  1 
1A09D20 	4C 53 A0  1 70 6F A0  1 
1A09D28 	40 46 A0  1 
      then                                            ( ud' $' )
      1 /string                                       ( ud' $' )
1A09D2C 	80 6F A0  1 
1A09D30 	3C 85 A0  1 
   repeat                                             ( ud' $' )
1A09D34 	C8 41 A0  1 
1A09D38 	B4 FF FF FF 

   if                                                 ( ud adr )
1A09D3C 	DC 41 A0  1 
1A09D40 	40  0  0  0 
      \ Do not accept a trailing comma, thus preventing,
      \ for example, "c," from being interpreted as a number
      c@  ascii . =  if                               ( ud )
1A09D44 	C4 4C A0  1 
1A09D48 	58 41 A0  1 2E  0  0  0 
1A09D50 	24 48 A0  1 DC 41 A0  1 
1A09D58 	10  0  0  0 
         true                                         ( ud dbl? )
1A09D5C 	 4 70 A0  1 
      else                                            ( ud )
1A09D60 	C8 41 A0  1 14  0  0  0 
         r> 3drop  0  exit
1A09D68 	D0 45 A0  1 90 52 A0  1 
1A09D70 	70 6F A0  1 40 46 A0  1 
      then                                            ( ud dbl? )
   else                                               ( ud adr )
1A09D78 	C8 41 A0  1  C  0  0  0 
      drop false                                      ( ud dbl? )
1A09D80 	30 49 A0  1 18 70 A0  1 
   then                                               ( ud dbl? )

   over or  if                                        ( ud )
1A09D88 	54 49 A0  1 70 44 A0  1 
1A09D90 	DC 41 A0  1 20  0  0  0 
      r>  if  dnegate  then  2
1A09D98 	D0 45 A0  1 DC 41 A0  1 
1A09DA0 	 8  0  0  0 4C 68 A0  1 
1A09DA8 	90 6F A0  1 
   else
1A09DAC 	C8 41 A0  1 
1A09DB0 	1C  0  0  0 
      drop  r>  if  negate  then  1
1A09DB4 	30 49 A0  1 
1A09DB8 	D0 45 A0  1 DC 41 A0  1 
1A09DC0 	 8  0  0  0 48 45 A0  1 
1A09DC8 	80 6F A0  1 
   then
;
1A09DCC 	58 46 A0  1 

defer do-defined    ( cfa -1 | cfa 1  -- ?? )
1A09DD0 	 0 64 6F 2D 64 65 66 69 
1A09DD8 	6E 65 64 8A 9C 9C A0  1 
1A09DE0 	5C 40 A0  1 3C  1  0  0 
defer $do-undefined  ( adr len -- )
1A09DE8 	 0  0 24 64 6F 2D 75 6E 
1A09DF0 	64 65 66 69 6E 65 64 8D 
1A09DF8 	E0 9D A0  1 5C 40 A0  1 
1A09E00 	40  1  0  0 

headers
: (do-literal)  ( n 1 | d 2 -- n | d | )
1A09E04 	 0  0  0 28 
1A09E08 	64 6F 2D 6C 69 74 65 72 
1A09E10 	61 6C 29 8C FC 9D A0  1 
1A09E18 	20 40 A0  1 
   state @  if
1A09E1C 	38 54 A0  1 
1A09E20 	5C 4C A0  1 DC 41 A0  1 
1A09E28 	2C  0  0  0 
      2 =  if  [compile] dliteral  else  [compile] literal  then
1A09E2C 	90 6F A0  1 
1A09E30 	24 48 A0  1 DC 41 A0  1 
1A09E38 	10  0  0  0 14 95 A0  1 
1A09E40 	C8 41 A0  1  8  0  0  0 
1A09E48 	CC 94 A0  1 
   else
1A09E4C 	C8 41 A0  1 
1A09E50 	 8  0  0  0 
      drop
1A09E54 	30 49 A0  1 
   then
;
1A09E58 	58 46 A0  1 
' (do-literal) is do-literal
defer $handle-literal?  ( adr len -- handled? )
1A09E5C 	 0  0  0 24 
1A09E60 	68 61 6E 64 6C 65 2D 6C 
1A09E68 	69 74 65 72 61 6C 3F 90 
1A09E70 	18 9E A0  1 5C 40 A0  1 
1A09E78 	44  1  0  0 
: ($handle-literal?)  ( adr len -- handled? )
1A09E7C 	 0 28 24 68 
1A09E80 	61 6E 64 6C 65 2D 6C 69 
1A09E88 	74 65 72 61 6C 3F 29 92 
1A09E90 	74 9E A0  1 20 40 A0  1 
   $dnumber?  dup  if  do-literal true  then
1A09E98 	9C 9C A0  1 40 49 A0  1 
1A09EA0 	DC 41 A0  1  C  0  0  0 
1A09EA8 	7C 95 A0  1  4 70 A0  1 
;
1A09EB0 	58 46 A0  1 
' ($handle-literal?) is $handle-literal?

headers
: $compile  ( adr len -- ?? )
1A09EB4 	 0  0  0 24 
1A09EB8 	63 6F 6D 70 69 6C 65 88 
1A09EC0 	94 9E A0  1 20 40 A0  1 
   2dup  2>r                        ( adr len )  ( r: adr len )
1A09EC8 	C0 49 A0  1 F8 45 A0  1 
   $find  dup  if                   ( xt +-1 )
1A09ED0 	C4 93 A0  1 40 49 A0  1 
1A09ED8 	DC 41 A0  1 18  0  0  0 
      2r> 2drop do-defined          ( )
1A09EE0 	10 46 A0  1 AC 49 A0  1 
1A09EE8 	E0 9D A0  1 
   else                             ( adr' len' 0 )
1A09EEC 	C8 41 A0  1 
1A09EF0 	2C  0  0  0 
      3drop                         ( )
1A09EF4 	90 52 A0  1 
      2r@ $handle-literal?  0=  if  ( )
1A09EF8 	28 46 A0  1 74 9E A0  1 
1A09F00 	24 47 A0  1 DC 41 A0  1 
1A09F08 	 C  0  0  0 
         2r@  $do-undefined         ( )
1A09F0C 	28 46 A0  1 
1A09F10 	FC 9D A0  1 
      then
      2r> 2drop
1A09F14 	10 46 A0  1 
1A09F18 	AC 49 A0  1 
  then
;
1A09F1C 	58 46 A0  1 
headerless
: interpret-do-defined  ( cfa -1 | cfa 1 -- ?? )  drop execute  ;
1A09F20 	 0  0  0 69 6E 74 65 72 
1A09F28 	70 72 65 74 2D 64 6F 2D 
1A09F30 	64 65 66 69 6E 65 64 94 
1A09F38 	C4 9E A0  1 20 40 A0  1 
1A09F40 	30 49 A0  1 98 41 A0  1 
1A09F48 	58 46 A0  1 
: compile-do-defined    ( cfa -1 | cfa 1 -- )
1A09F4C 	 0 63 6F 6D 
1A09F50 	70 69 6C 65 2D 64 6F 2D 
1A09F58 	64 65 66 69 6E 65 64 92 
1A09F60 	3C 9F A0  1 20 40 A0  1 
  0> if    execute   \ if immediate
1A09F68 	A4 47 A0  1 DC 41 A0  1 
1A09F70 	10  0  0  0 98 41 A0  1 
     else  compile,  \ if not immediate
1A09F78 	C8 41 A0  1  8  0  0  0 
1A09F80 	74 75 A0  1 
     then
;
1A09F84 	58 46 A0  1 
headers
0 value 'error-word
1A09F88 	27 65 72 72 6F 72 2D 77 
1A09F90 	6F 72 64 8B 64 9F A0  1 
1A09F98 	50 40 A0  1 48  1  0  0 
\ Abort after an undefined word in interpret state
: $interpret-do-undefined  ( adr len -- )
1A09FA0 	24 69 6E 74 65 72 70 72 
1A09FA8 	65 74 2D 64 6F 2D 75 6E 
1A09FB0 	64 65 66 69 6E 65 64 97 
1A09FB8 	98 9F A0  1 20 40 A0  1 
   d# 32 min 'error-word pack  count
1A09FC0 	58 41 A0  1 20  0  0  0 
1A09FC8 	74 4A A0  1 98 9F A0  1 
1A09FD0 	DC 52 A0  1 BC 53 A0  1 
   set-abort-message  d# -13 throw
1A09FD8 	60 80 A0  1 58 41 A0  1 
1A09FE0 	F3 FF FF FF 74 7F A0  1 
;
1A09FE8 	58 46 A0  1 
\ Compile a surrogate for an undefined word in compile state
: $compile-do-undefined    ( adr len -- )  .not-found  compile lose  ;
1A09FEC 	 0  0 24 63 
1A09FF0 	6F 6D 70 69 6C 65 2D 64 
1A09FF8 	6F 2D 75 6E 64 65 66 69 
1A0A000 	6E 65 64 95 BC 9F A0  1 
1A0A008 	20 40 A0  1 58 94 A0  1 
1A0A010 	8C 75 A0  1 90 9B A0  1 
1A0A018 	58 46 A0  1 

headers
\ Run-time error checking
: ?stack  (s ?? -- )
1A0A01C 	 0 3F 73 74 
1A0A020 	61 63 6B 86  8 A0 A0  1 
1A0A028 	20 40 A0  1 
   sp@  sp0 @  swap       u<  ( -4 ) abort" Stack Underflow"
1A0A02C 	6C 45 A0  1 
1A0A030 	8C 66 A0  1 5C 4C A0  1 
1A0A038 	68 49 A0  1 A8 48 A0  1 
1A0A040 	 8 81 A0  1  F 53 74 61 
1A0A048 	63 6B 20 55 6E 64 65 72 
1A0A050 	66 6C 6F 77  0  0  0  0 
   sp@  sp0 @  ps-size -  u<  ( -3 ) abort" Stack Overflow"
1A0A058 	6C 45 A0  1 8C 66 A0  1 
1A0A060 	5C 4C A0  1 84 8E A0  1 
1A0A068 	18 45 A0  1 A8 48 A0  1 
1A0A070 	 8 81 A0  1  E 53 74 61 
1A0A078 	63 6B 20 4F 76 65 72 66 
1A0A080 	6C 6F 77  0 
;
1A0A084 	58 46 A0  1 

defer ?permitted  ' noop is ?permitted
1A0A088 	 0 3F 70 65 72 6D 69 74 
1A0A090 	74 65 64 8A 28 A0 A0  1 
1A0A098 	5C 40 A0  1 4C  1  0  0 

defer interpret
1A0A0A0 	 0  0 69 6E 74 65 72 70 
1A0A0A8 	72 65 74 89 98 A0 A0  1 
1A0A0B0 	5C 40 A0  1 50  1  0  0 
: (interpret  (s -- )
1A0A0B8 	 0 28 69 6E 74 65 72 70 
1A0A0C0 	72 65 74 8A B0 A0 A0  1 
1A0A0C8 	20 40 A0  1 
   begin
\     ?stack
      parse-word dup
1A0A0CC 	34 93 A0  1 
1A0A0D0 	40 49 A0  1 
   while
1A0A0D4 	DC 41 A0  1 
1A0A0D8 	14  0  0  0 
      ?permitted
1A0A0DC 	98 A0 A0  1 
      $compile
1A0A0E0 	C4 9E A0  1 
   repeat
1A0A0E4 	C8 41 A0  1 
1A0A0E8 	E4 FF FF FF 
   2drop
1A0A0EC 	AC 49 A0  1 
;
1A0A0F0 	58 46 A0  1 
' (interpret  is interpret

\ Ensure that the cursor in on an empty line.
: ??cr  ( -- )  #out @  if  cr  then  ;
1A0A0F4 	 0  0  0 3F 
1A0A0F8 	3F 63 72 84 C8 A0 A0  1 
1A0A100 	20 40 A0  1 5C 6D A0  1 
1A0A108 	5C 4C A0  1 DC 41 A0  1 
1A0A110 	 8  0  0  0 80 6D A0  1 
1A0A118 	58 46 A0  1 

\ This hack is for users of window systems.  If you pick up with the
\ mouse an entire previous command line, including the prompt, then
\ paste it into the current line, Forth will ignore the prompt.
: ok  ( -- )  ;
1A0A11C 	 0 6F 6B 82 
1A0A120 	 0 A1 A0  1 20 40 A0  1 
1A0A128 	58 46 A0  1 

defer status  ( -- )  ' noop is status
1A0A12C 	 0 73 74 61 
1A0A130 	74 75 73 86 24 A1 A0  1 
1A0A138 	5C 40 A0  1 54  1  0  0 


\ A hook for automatic pagination

defer mark-output  ( -- )  ' noop is mark-output
1A0A140 	6D 61 72 6B 2D 6F 75 74 
1A0A148 	70 75 74 8B 38 A1 A0  1 
1A0A150 	5C 40 A0  1 58  1  0  0 


\ Prompts the user for another line of input.  Executed only if the input
\ stream is coming from a terminal.

defer (ok) ( -- )
1A0A158 	 0  0  0 28 6F 6B 29 84 
1A0A160 	50 A1 A0  1 5C 40 A0  1 
1A0A168 	5C  1  0  0 
: "ok" ." ok " ;
1A0A16C 	 0  0  0 22 
1A0A170 	6F 6B 22 84 64 A1 A0  1 
1A0A178 	20 40 A0  1 20 7C A0  1 
1A0A180 	 3 6F 6B 20  0  0  0  0 
1A0A188 	58 46 A0  1 
' "ok" is (ok)

defer reset-page
1A0A18C 	 0 72 65 73 
1A0A190 	65 74 2D 70 61 67 65 8A 
1A0A198 	78 A1 A0  1 5C 40 A0  1 
1A0A1A0 	60  1  0  0 
' noop is reset-page

\ From kernport.fth


[ifndef] run-time

\itc : \itc ; immediate
\itc : \dtc  [compile] \ ; immediate
\itc : \ttc  [compile] \ ; immediate
\dtc : \itc  [compile] \ ; immediate
1A0A1A4 	 0  0  0 5C 
1A0A1A8 	69 74 63 C4 9C A1 A0  1 
1A0A1B0 	20 40 A0  1 74 8A A0  1 
1A0A1B8 	58 46 A0  1 
\dtc : \dtc ; immediate
1A0A1BC 	 0  0  0 5C 
1A0A1C0 	64 74 63 C4 B0 A1 A0  1 
1A0A1C8 	20 40 A0  1 58 46 A0  1 
\dtc : \ttc  [compile] \ ; immediate
1A0A1D0 	 0  0  0 5C 74 74 63 C4 
1A0A1D8 	C8 A1 A0  1 20 40 A0  1 
1A0A1E0 	74 8A A0  1 58 46 A0  1 
\ttc : \itc  [compile] \ ; immediate
\ttc : \dtc  [compile] \ ; immediate
\ttc : \ttc ; immediate
\t8  : \t8  ; immediate
\t8  : \t16  [compile] \ ; immediate
\t8  : \t32  [compile] \ ; immediate
\t16 : \t8   [compile] \ ; immediate
\t16 : \t16 ; immediate
\t16 : \t32  [compile] \ ; immediate
\t32 : \t8   [compile] \ ; immediate
1A0A1E8 	5C 74 38 C3 DC A1 A0  1 
1A0A1F0 	20 40 A0  1 74 8A A0  1 
1A0A1F8 	58 46 A0  1 
\t32 : \t16  [compile] \ ; immediate
1A0A1FC 	 0  0  0 5C 
1A0A200 	74 31 36 C4 F0 A1 A0  1 
1A0A208 	20 40 A0  1 74 8A A0  1 
1A0A210 	58 46 A0  1 
\t32 : \t32 ; immediate
1A0A214 	 0  0  0 5C 
1A0A218 	74 33 32 C4  8 A2 A0  1 
1A0A220 	20 40 A0  1 58 46 A0  1 
16\ : 16\  ; immediate
16\ : 32\  [compile] \  ; immediate
16\ : 64\  [compile] \  ; immediate
32\ : 16\  [compile] \  ; immediate
1A0A228 	31 36 5C C3 20 A2 A0  1 
1A0A230 	20 40 A0  1 74 8A A0  1 
1A0A238 	58 46 A0  1 
32\ : 32\  ; immediate
1A0A23C 	33 32 5C C3 
1A0A240 	30 A2 A0  1 20 40 A0  1 
1A0A248 	58 46 A0  1 
32\ : 64\  [compile] \  ; immediate
1A0A24C 	36 34 5C C3 
1A0A250 	44 A2 A0  1 20 40 A0  1 
1A0A258 	74 8A A0  1 58 46 A0  1 
64\ : 16\  [compile] \  ; immediate
64\ : 32\  [compile] \  ; immediate
64\ : 64\  ; immediate
[then]

\ From definers.fth

\ Extensible Layer            Defining Words
headers

: (header)  \ name  ( -- )
1A0A260 	 0  0  0 28 68 65 61 64 
1A0A268 	65 72 29 88 54 A2 A0  1 
1A0A270 	20 40 A0  1 
   safe-parse-word $header
1A0A274 	88 93 A0  1 
1A0A278 	C8 6D A0  1 
;
1A0A27C 	58 46 A0  1 

' (header) is header

: $create  ( adr len -- )  $header  create-cf  ;
1A0A280 	24 63 72 65 61 74 65 87 
1A0A288 	70 A2 A0  1 20 40 A0  1 
1A0A290 	C8 6D A0  1 30 5B A0  1 
1A0A298 	58 46 A0  1 

: create  \ name  (s -- )
1A0A29C 	 0 63 72 65 
1A0A2A0 	61 74 65 86 8C A2 A0  1 
1A0A2A8 	20 40 A0  1 
   header create-cf
1A0A2AC 	DC 6D A0  1 
1A0A2B0 	30 5B A0  1 
;
1A0A2B4 	58 46 A0  1 

nuser csp          \ for stack position error checking
1A0A2B8 	63 73 70 83 A8 A2 A0  1 
1A0A2C0 	48 40 A0  1 64  1  0  0 
: !csp   (s -- )   sp@ csp !   ;
1A0A2C8 	 0  0  0 21 63 73 70 84 
1A0A2D0 	C0 A2 A0  1 20 40 A0  1 
1A0A2D8 	6C 45 A0  1 C0 A2 A0  1 
1A0A2E0 	54 4D A0  1 58 46 A0  1 
: ?csp   (s -- )   sp@ csp @ <>   ( -22 ) abort" Stack Changed "  ;
1A0A2E8 	 0  0  0 3F 63 73 70 84 
1A0A2F0 	D4 A2 A0  1 20 40 A0  1 
1A0A2F8 	6C 45 A0  1 C0 A2 A0  1 
1A0A300 	5C 4C A0  1 44 48 A0  1 
1A0A308 	 8 81 A0  1  E 53 74 61 
1A0A310 	63 6B 20 43 68 61 6E 67 
1A0A318 	65 64 20  0 58 46 A0  1 

: (;code)   (s -- )  ip>  aligned acf-aligned  used   ;
1A0A320 	28 3B 63 6F 64 65 29 87 
1A0A328 	F4 A2 A0  1 20 40 A0  1 
1A0A330 	84 46 A0  1 EC 5C A0  1 
1A0A338 	 C 5D A0  1 E0 57 A0  1 
1A0A340 	58 46 A0  1 
: (does>)   (s -- )  ip>  acf-aligned  used   ;
1A0A344 	28 64 6F 65 
1A0A348 	73 3E 29 87 2C A3 A0  1 
1A0A350 	20 40 A0  1 84 46 A0  1 
1A0A358 	 C 5D A0  1 E0 57 A0  1 
1A0A360 	58 46 A0  1 

defer do-entercode
1A0A364 	 0  0  0 64 
1A0A368 	6F 2D 65 6E 74 65 72 63 
1A0A370 	6F 64 65 8C 50 A3 A0  1 
1A0A378 	5C 40 A0  1 68  1  0  0 
' noop is do-entercode

: code  \ name  (s -- )
1A0A380 	 0  0  0 63 6F 64 65 84 
1A0A388 	78 A3 A0  1 20 40 A0  1 
   header  code-cf  !csp  do-entercode
1A0A390 	DC 6D A0  1  8 5B A0  1 
1A0A398 	D4 A2 A0  1 78 A3 A0  1 
;
1A0A3A0 	58 46 A0  1 

defer do-exitcode
1A0A3A4 	64 6F 2D 65 
1A0A3A8 	78 69 74 63 6F 64 65 8B 
1A0A3B0 	8C A3 A0  1 5C 40 A0  1 
1A0A3B8 	6C  1  0  0 
' noop is do-exitcode


decimal
32 equ nvocs
nvocs constant #vocs	\ The # of vocabularies that can be in the search path
1A0A3BC 	 0  0 23 76 
1A0A3C0 	6F 63 73 85 B4 A3 A0  1 
1A0A3C8 	68 40 A0  1 20  0  0  0 

nvocs /token-t * ualloc-t user context   \ vocabulary searched first
1A0A3D0 	63 6F 6E 74 65 78 74 87 
1A0A3D8 	C8 A3 A0  1 48 40 A0  1 
1A0A3E0 	70  1  0  0 
tuser current      \ vocabulary which gets new definitions
1A0A3E4 	63 75 72 72 
1A0A3E8 	65 6E 74 87 DC A3 A0  1 
1A0A3F0 	48 40 A0  1 F0  1  0  0 
nuser last
1A0A3F8 	 0  0  0 6C 61 73 74 84 
1A0A400 	F0 A3 A0  1 48 40 A0  1 
1A0A408 	F4  1  0  0 
tuser hidden-voc
1A0A40C 	 0 68 69 64 
1A0A410 	64 65 6E 2D 76 6F 63 8A 
1A0A418 	 4 A4 A0  1 48 40 A0  1 
1A0A420 	F8  1  0  0 

: current-voc  ( -- voc-xt )  current token@  ;
1A0A424 	63 75 72 72 
1A0A428 	65 6E 74 2D 76 6F 63 8B 
1A0A430 	1C A4 A0  1 20 40 A0  1 
1A0A438 	F0 A3 A0  1  C 54 A0  1 
1A0A440 	58 46 A0  1 

: remove-word  ( new-alf voc-acf -- )
1A0A444 	72 65 6D 6F 
1A0A448 	76 65 2D 77 6F 72 64 8B 
1A0A450 	34 A4 A0  1 20 40 A0  1 
   >threads                                   ( new-alf prev-link )
1A0A458 	EC 74 A0  1 
   swap link> swap link>                      ( new-acf prev-link )
1A0A45C 	68 49 A0  1 
1A0A460 	D0 73 A0  1 68 49 A0  1 
1A0A468 	D0 73 A0  1 
   begin                                      ( acf prev-link )
      >link
1A0A46C 	EC 73 A0  1 
      2dup a@ =  if                        ( acf prev-link )
1A0A470 	C0 49 A0  1 88 58 A0  1 
1A0A478 	24 48 A0  1 DC 41 A0  1 
1A0A480 	1C  0  0  0 
         swap >link a@ swap a!  exit    (  )
1A0A484 	68 49 A0  1 
1A0A488 	EC 73 A0  1 88 58 A0  1 
1A0A490 	68 49 A0  1 98 58 A0  1 
1A0A498 	40 46 A0  1 
      then                                    ( acf prev-link )
      another-link? 0=                  ( acf [ next-link ] end? )
1A0A49C 	90 59 A0  1 
1A0A4A0 	24 47 A0  1 
   until
1A0A4A4 	DC 41 A0  1 
1A0A4A8 	C4 FF FF FF 
   drop
1A0A4AC 	30 49 A0  1 
;
1A0A4B0 	58 46 A0  1 

: >ptr  ( alf voc-acf -- ptr )
1A0A4B4 	 0  0  0 3E 
1A0A4B8 	70 74 72 84 54 A4 A0  1 
1A0A4C0 	20 40 A0  1 
   over  if  drop  else  nip >threads  then
1A0A4C4 	54 49 A0  1 
1A0A4C8 	DC 41 A0  1 10  0  0  0 
1A0A4D0 	30 49 A0  1 C8 41 A0  1 
1A0A4D8 	 C  0  0  0 FC 46 A0  1 
1A0A4E0 	EC 74 A0  1 
;
1A0A4E4 	58 46 A0  1 

: insert-word  ( new-alf old-alf voc-ptr -- )
1A0A4E8 	69 6E 73 65 72 74 2D 77 
1A0A4F0 	6F 72 64 8B C0 A4 A0  1 
1A0A4F8 	20 40 A0  1 
   >ptr              ( new-alf alf )
1A0A4FC 	C0 A4 A0  1 
   swap link> swap   ( new-acf alf )
1A0A500 	68 49 A0  1 D0 73 A0  1 
1A0A508 	68 49 A0  1 
   2dup a@        ( new-acf alf  new-acf next-acf )
1A0A50C 	C0 49 A0  1 
1A0A510 	88 58 A0  1 
   swap >link a! a!
1A0A514 	68 49 A0  1 
1A0A518 	EC 73 A0  1 98 58 A0  1 
1A0A520 	98 58 A0  1 
;
1A0A524 	58 46 A0  1 

: not-hidden  ( -- )  hidden-voc !null-token  ;
1A0A528 	 0 6E 6F 74 2D 68 69 64 
1A0A530 	64 65 6E 8A F8 A4 A0  1 
1A0A538 	20 40 A0  1 1C A4 A0  1 
1A0A540 	10 59 A0  1 58 46 A0  1 

: hide   (s -- )
1A0A548 	 0  0  0 68 69 64 65 84 
1A0A550 	38 A5 A0  1 20 40 A0  1 
   current-voc hidden-voc token!
1A0A558 	34 A4 A0  1 1C A4 A0  1 
1A0A560 	20 54 A0  1 
   last @ n>link current-voc remove-word
1A0A564 	 4 A4 A0  1 
1A0A568 	5C 4C A0  1 8C 73 A0  1 
1A0A570 	34 A4 A0  1 54 A4 A0  1 
;
1A0A578 	58 46 A0  1 

: reveal  (s -- )
1A0A57C 	 0 72 65 76 
1A0A580 	65 61 6C 86 54 A5 A0  1 
1A0A588 	20 40 A0  1 
   hidden-voc get-token?  if             ( xt )
1A0A58C 	1C A4 A0  1 
1A0A590 	6C 59 A0  1 DC 41 A0  1 
1A0A598 	20  0  0  0 
      last @ n>link 0  rot  insert-word  ( )
1A0A59C 	 4 A4 A0  1 
1A0A5A0 	5C 4C A0  1 8C 73 A0  1 
1A0A5A8 	70 6F A0  1 7C 49 A0  1 
1A0A5B0 	F8 A4 A0  1 
      not-hidden
1A0A5B4 	38 A5 A0  1 
   then
;
1A0A5B8 	58 46 A0  1 

: end-code  ( -- )
1A0A5BC 	 0  0  0 65 
1A0A5C0 	6E 64 2D 63 6F 64 65 88 
1A0A5C8 	88 A5 A0  1 20 40 A0  1 
   do-exitcode  ?csp
1A0A5D0 	B4 A3 A0  1 F4 A2 A0  1 
;
1A0A5D8 	58 46 A0  1 
: c;  ( -- )  next  end-code  ;
1A0A5DC 	 0 63 3B 82 
1A0A5E0 	CC A5 A0  1 20 40 A0  1 
1A0A5E8 	1C 56 A0  1 CC A5 A0  1 
1A0A5F0 	58 46 A0  1 

: ;code     (s -- )
1A0A5F4 	 0  0 3B 63 
1A0A5F8 	6F 64 65 C5 E4 A5 A0  1 
1A0A600 	20 40 A0  1 
   ?csp   compile  (;code)  align acf-align  place-;code
1A0A604 	F4 A2 A0  1 
1A0A608 	8C 75 A0  1 2C A3 A0  1 
1A0A610 	34 62 A0  1 2C 5D A0  1 
1A0A618 	B8 56 A0  1 
   [compile] [   reveal   do-entercode
1A0A61C 	90 6D A0  1 
1A0A620 	88 A5 A0  1 78 A3 A0  1 
; immediate
1A0A628 	58 46 A0  1 


origin-t is hidden-voc


: does>   (s -- )
1A0A62C 	 0  0 64 6F 
1A0A630 	65 73 3E C5  0 A6 A0  1 
1A0A638 	20 40 A0  1 
   state @  if
1A0A63C 	38 54 A0  1 
1A0A640 	5C 4C A0  1 DC 41 A0  1 
1A0A648 	14  0  0  0 
     compile (does>)
1A0A64C 	8C 75 A0  1 
1A0A650 	50 A3 A0  1 
   else
1A0A654 	C8 41 A0  1 
1A0A658 	20  0  0  0 
     here  aligned acf-aligned  used  !csp not-hidden  ]
1A0A65C 	70 54 A0  1 
1A0A660 	EC 5C A0  1  C 5D A0  1 
1A0A668 	E0 57 A0  1 D4 A2 A0  1 
1A0A670 	38 A5 A0  1 A0 6D A0  1 
   then
   align acf-align  place-does
1A0A678 	34 62 A0  1 2C 5D A0  1 
1A0A680 	4C 56 A0  1 
; immediate
1A0A684 	58 46 A0  1 



: :        (s -- )  ?exec  !csp   header  hide   ]  colon-cf  ;
1A0A688 	 0  0 3A 81 38 A6 A0  1 
1A0A690 	20 40 A0  1 FC 92 A0  1 
1A0A698 	D4 A2 A0  1 DC 6D A0  1 
1A0A6A0 	54 A5 A0  1 A0 6D A0  1 
1A0A6A8 	78 5B A0  1 58 46 A0  1 
: :noname  (s -- xt )  ?exec  not-hidden     ]  colon-cf  lastacf  !csp  ;
1A0A6B0 	3A 6E 6F 6E 61 6D 65 87 
1A0A6B8 	90 A6 A0  1 20 40 A0  1 
1A0A6C0 	FC 92 A0  1 38 A5 A0  1 
1A0A6C8 	A0 6D A0  1 78 5B A0  1 
1A0A6D0 	AC 57 A0  1 D4 A2 A0  1 
1A0A6D8 	58 46 A0  1 
: ;        (s -- )
1A0A6DC 	 0  0 3B C1 
1A0A6E0 	BC A6 A0  1 20 40 A0  1 
   ?comp  ?csp   compile unnest   reveal   [compile] [
1A0A6E8 	C4 92 A0  1 F4 A2 A0  1 
1A0A6F0 	8C 75 A0  1 58 46 A0  1 
1A0A6F8 	88 A5 A0  1 90 6D A0  1 
; immediate
1A0A700 	58 46 A0  1 

: recursive  (s -- )   reveal  ; immediate
1A0A704 	 0  0 72 65 
1A0A708 	63 75 72 73 69 76 65 C9 
1A0A710 	E4 A6 A0  1 20 40 A0  1 
1A0A718 	88 A5 A0  1 58 46 A0  1 

: constant  \ name  (s n -- )
1A0A720 	 0  0  0 63 6F 6E 73 74 
1A0A728 	61 6E 74 88 14 A7 A0  1 
1A0A730 	20 40 A0  1 
   header constant-cf  ,
1A0A734 	DC 6D A0  1 
1A0A738 	 C 5C A0  1 98 55 A0  1 
;
1A0A740 	58 46 A0  1 

: value  \ name  (s value -- )
1A0A744 	 0  0 76 61 
1A0A748 	6C 75 65 85 30 A7 A0  1 
1A0A750 	20 40 A0  1 
   header value-cf  /n user#,  !
1A0A754 	DC 6D A0  1 
1A0A758 	E8 5B A0  1 40 51 A0  1 
1A0A760 	84 9A A0  1 54 4D A0  1 
;
1A0A768 	58 46 A0  1 
: variable  \ name  (s -- )
1A0A76C 	 0  0  0 76 
1A0A770 	61 72 69 61 62 6C 65 88 
1A0A778 	50 A7 A0  1 20 40 A0  1 
   header variable-cf  0 ,
1A0A780 	DC 6D A0  1 54 5B A0  1 
1A0A788 	70 6F A0  1 98 55 A0  1 
;
1A0A790 	58 46 A0  1 
: wvariable  \ name  (s -- )
1A0A794 	 0  0 77 76 
1A0A798 	61 72 69 61 62 6C 65 89 
1A0A7A0 	7C A7 A0  1 20 40 A0  1 
   create variable-cf 0 w,
1A0A7A8 	A8 A2 A0  1 54 5B A0  1 
1A0A7B0 	70 6F A0  1 D8 55 A0  1 
;
1A0A7B8 	58 46 A0  1 

\ defer (is is
\ Also known as execution vectors.
\ Usage:   defer bar
\ : foo ." Hello" ;  ' foo is bar
\ Alternatively: ' foo ' bar (is

\ Since the execution of an execution vector doesn't leave around
\ information about which deferred word was used, we have to try
\ to find it by looking on the return stack
\ if the vector was EXECUTE'd, we don't know what it was.  This
\ will be the case if the deferred word was interpreted from the
\ input stream

: crash ( -- )  \ unitialized execution vector routine
1A0A7BC 	 0  0 63 72 
1A0A7C0 	61 73 68 85 A4 A7 A0  1 
1A0A7C8 	20 40 A0  1 
   \ The following line may not always work right for token-threaded code
   \ with variable-length tokens
   ip@ /token - token@         \ use the return stack to see who called us
1A0A7CC 	9C 46 A0  1 
1A0A7D0 	B4 46 A0  1 18 45 A0  1 
1A0A7D8 	 C 54 A0  1 
   dup word-type  ['] emit word-type =  if  .name  ." <--"  then
1A0A7DC 	40 49 A0  1 
1A0A7E0 	B0 59 A0  1 60 53 A0  1 
1A0A7E8 	2C 6C A0  1 B0 59 A0  1 
1A0A7F0 	24 48 A0  1 DC 41 A0  1 
1A0A7F8 	14  0  0  0 C8 9A A0  1 
1A0A800 	20 7C A0  1  3 3C 2D 2D 
1A0A808 	 0  0  0  0 
   ." deferred word not initialized" abort
1A0A80C 	20 7C A0  1 
1A0A810 	1D 64 65 66 65 72 72 65 
1A0A818 	64 20 77 6F 72 64 20 6E 
1A0A820 	6F 74 20 69 6E 69 74 69 
1A0A828 	61 6C 69 7A 65 64  0  0 
1A0A830 	28 91 A0  1 
;
1A0A834 	58 46 A0  1 

\ Allocates a user area location to hold the vector
: defer  \ name  (s -- )
1A0A838 	 0  0 64 65 66 65 72 85 
1A0A840 	C8 A7 A0  1 20 40 A0  1 
   header  defer-cf
1A0A848 	DC 6D A0  1 30 5C A0  1 
   ['] crash   /token user#,   token!	\ Allocate user location
1A0A850 	60 53 A0  1 C8 A7 A0  1 
1A0A858 	B4 46 A0  1 84 9A A0  1 
1A0A860 	20 54 A0  1 
;
1A0A864 	58 46 A0  1 

: 2constant  \ name  (s d# -- )
1A0A868 	 0  0 32 63 6F 6E 73 74 
1A0A870 	61 6E 74 89 44 A8 A0  1 
1A0A878 	20 40 A0  1 
   header 2constant-cf  swap  , ,
1A0A87C 	DC 6D A0  1 
1A0A880 	58 5C A0  1 68 49 A0  1 
1A0A888 	98 55 A0  1 98 55 A0  1 
;
1A0A890 	58 46 A0  1 
: 2variable  \ name (s -- )
1A0A894 	 0  0 32 76 
1A0A898 	61 72 69 61 62 6C 65 89 
1A0A8A0 	78 A8 A0  1 20 40 A0  1 
   create 0 , 0 ,   (s -- apf )
1A0A8A8 	A8 A2 A0  1 70 6F A0  1 
1A0A8B0 	98 55 A0  1 70 6F A0  1 
1A0A8B8 	98 55 A0  1 
;
1A0A8BC 	58 46 A0  1 

\ buffer:  \ name  ( size -- )
\       Defines a word which returns the address of a buffer of the
\       requested size.  The buffer is allocated at initialization
\       time from free memory, not from the dictionary.

auser buffer-link
1A0A8C0 	62 75 66 66 65 72 2D 6C 
1A0A8C8 	69 6E 6B 8B A4 A8 A0  1 
1A0A8D0 	48 40 A0  1 FC  1  0  0 
0   is buffer-link

headerless
: make-buffer  ( size -- )
1A0A8D8 	6D 61 6B 65 2D 62 75 66 
1A0A8E0 	66 65 72 8B D0 A8 A0  1 
1A0A8E8 	20 40 A0  1 
   here body> swap     ( acf size )
1A0A8EC 	70 54 A0  1 
1A0A8F0 	C8 59 A0  1 68 49 A0  1 
   0 /n user#,  !      ( acf size )
1A0A8F8 	70 6F A0  1 40 51 A0  1 
1A0A900 	84 9A A0  1 54 4D A0  1 
   ,                   ( acf )
1A0A908 	98 55 A0  1 
   buffer-link a@  a,  buffer-link a!
1A0A90C 	D0 A8 A0  1 
1A0A910 	88 58 A0  1 AC 58 A0  1 
1A0A918 	D0 A8 A0  1 98 58 A0  1 
;
1A0A920 	58 46 A0  1 

headers
: do-buffer  ( apf -- adr )
1A0A924 	 0  0 64 6F 
1A0A928 	2D 62 75 66 66 65 72 89 
1A0A930 	E8 A8 A0  1 20 40 A0  1 
   dup >user @  if          ( apf )
1A0A938 	40 49 A0  1 C8 74 A0  1 
1A0A940 	5C 4C A0  1 DC 41 A0  1 
1A0A948 	14  0  0  0 
      >user @               ( adr )
1A0A94C 	C8 74 A0  1 
1A0A950 	5C 4C A0  1 
   else                     ( apf )
1A0A954 	C8 41 A0  1 
1A0A958 	38  0  0  0 
      dup /user# + @        ( apf size )
1A0A95C 	40 49 A0  1 
1A0A960 	40 5A A0  1  4 45 A0  1 
1A0A968 	5C 4C A0  1 
      dup alloc-mem         ( apf size adr )
1A0A96C 	40 49 A0  1 
1A0A970 	F0 6C A0  1 
      dup rot erase         ( apf adr )
1A0A974 	40 49 A0  1 
1A0A978 	7C 49 A0  1 F0 72 A0  1 
      dup rot >user !       ( adr )
1A0A980 	40 49 A0  1 7C 49 A0  1 
1A0A988 	C8 74 A0  1 54 4D A0  1 
   then
;
1A0A990 	58 46 A0  1 
: (buffer:)  ( size -- )
1A0A994 	 0  0 28 62 
1A0A998 	75 66 66 65 72 3A 29 89 
1A0A9A0 	34 A9 A0  1 20 40 A0  1 
   create-cf  make-buffer  does> do-buffer
1A0A9A8 	30 5B A0  1 E8 A8 A0  1 
1A0A9B0 	50 A3 A0  1 90 90 90 E8 
1A0A9B8 	C0 96 FF FF 34 A9 A0  1 
;
1A0A9C0 	58 46 A0  1 

doestarget @ IS DOBUFFER: \ mmo
headers
: buffer:  \ name  ( size -- )
1A0A9C4 	62 75 66 66 
1A0A9C8 	65 72 3A 87 A4 A9 A0  1 
1A0A9D0 	20 40 A0  1 
   header (buffer:)
1A0A9D4 	DC 6D A0  1 
1A0A9D8 	A4 A9 A0  1 
;
1A0A9DC 	58 46 A0  1 

: >buffer-link ( acf -- link-adr )  >body /user# + 1 na+  ;
1A0A9E0 	 0  0  0 3E 62 75 66 66 
1A0A9E8 	65 72 2D 6C 69 6E 6B 8C 
1A0A9F0 	D0 A9 A0  1 20 40 A0  1 
1A0A9F8 	E4 59 A0  1 40 5A A0  1 
1A0AA00 	 4 45 A0  1 80 6F A0  1 
1A0AA08 	48 50 A0  1 58 46 A0  1 

headerless
: clear-buffer:s ( -- )
1A0AA10 	 0 63 6C 65 61 72 2D 62 
1A0AA18 	75 66 66 65 72 3A 73 8E 
1A0AA20 	F4 A9 A0  1 20 40 A0  1 
   buffer-link                         ( next-buffer-word )
1A0AA28 	D0 A8 A0  1 
   begin  another-link?  while         ( acf )
1A0AA2C 	90 59 A0  1 
1A0AA30 	DC 41 A0  1 20  0  0  0 
      dup >body  >user  off            ( acf )
1A0AA38 	40 49 A0  1 E4 59 A0  1 
1A0AA40 	C8 74 A0  1 F8 4B A0  1 
      >buffer-link                     ( prev-buffer:-acf )
1A0AA48 	F4 A9 A0  1 
   repeat                              ( )
1A0AA4C 	C8 41 A0  1 
1A0AA50 	DC FF FF FF 
;
1A0AA54 	58 46 A0  1 

: init  ( -- )  init  clear-buffer:s  ;
1A0AA58 	 0  0  0 69 6E 69 74 84 
1A0AA60 	24 AA A0  1 20 40 A0  1 
1A0AA68 	6C 82 A0  1 24 AA A0  1 
1A0AA70 	58 46 A0  1 
headers

\ From tagvoc.fth

\ Implementation of vocabularies.  Vocabularies are lists of word names.
\ The following operations may be performed on vocabularies:
\    find-word  - Search for a given word
\    "header    - Create a new word in the "current" vocabulary
\    trim       - Remove all words in a vocabulary created after an address
\    another?   - Enumerate all the the words
\
\ Each word name in a vocabulary has the following attributes:
\    immediate flag  - Controls compilation of that word
\

\ Find a potential name field address
: find-name  ( acf -- anf )  >link l>name  ;
1A0AA74 	 0  0 66 69 
1A0AA78 	6E 64 2D 6E 61 6D 65 89 
1A0AA80 	64 AA A0  1 20 40 A0  1 
1A0AA88 	EC 73 A0  1 A4 73 A0  1 
1A0AA90 	58 46 A0  1 

\ The test for a valid header searches backward for the first byte
\ that appears to be a name length byte.  Then the length of the
\ name field implied by the length byte is compared with the actual
\ length, calculated by subtracting anf from acf.  Finally, the characters
\ in the name are checked to make sure that the name contains only printable
\ characters.

: >name?  ( acf -- anf good-name? )
1A0AA94 	 0 3E 6E 61 
1A0AA98 	6D 65 3F 86 84 AA A0  1 
1A0AAA0 	20 40 A0  1 
   dup  find-name                      ( acf anf )
1A0AAA4 	40 49 A0  1 
1A0AAA8 	84 AA A0  1 
   tuck name>string                    ( anf acf name-adr name-len )
1A0AAAC 	E8 46 A0  1 
1A0AAB0 	58 74 A0  1 
   dup 0=  if  3drop false exit  then  ( anf acf name-adr name-len )
1A0AAB4 	40 49 A0  1 
1A0AAB8 	24 47 A0  1 DC 41 A0  1 
1A0AAC0 	10  0  0  0 90 52 A0  1 
1A0AAC8 	18 70 A0  1 40 46 A0  1 
   + /link + acf-aligned               ( anf acf test-acf )
1A0AAD0 	 4 45 A0  1 78 73 A0  1 
1A0AAD8 	 4 45 A0  1  C 5D A0  1 
   <>  if  false exit  then            ( anf )
1A0AAE0 	44 48 A0  1 DC 41 A0  1 
1A0AAE8 	 C  0  0  0 18 70 A0  1 
1A0AAF0 	40 46 A0  1 

   \ Check for bogus (non-printable) characters in the name.
   dup name>string                     ( anf adr len )
1A0AAF4 	40 49 A0  1 
1A0AAF8 	58 74 A0  1 
   true -rot  bounds ?do               ( anf true )
1A0AAFC 	 4 70 A0  1 
1A0AB00 	94 49 A0  1 F0 6D A0  1 
1A0AB08 	50 42 A0  1 38  0  0  0 
      i c@  bl  h# 7f  between  0=  if  0= leave  then
1A0AB10 	B4 42 A0  1 C4 4C A0  1 
1A0AB18 	28 70 A0  1 58 41 A0  1 
1A0AB20 	7F  0  0  0 D8 70 A0  1 
1A0AB28 	24 47 A0  1 DC 41 A0  1 
1A0AB30 	 C  0  0  0 24 47 A0  1 
1A0AB38 	18 43 A0  1 
   loop                                ( anf good-name? )
1A0AB3C 	F8 41 A0  1 
1A0AB40 	D0 FF FF FF 
;
1A0AB44 	58 46 A0  1 



nuser tag-file
1A0AB48 	 0  0  0 74 61 67 2D 66 
1A0AB50 	69 6C 65 88 A0 AA A0  1 
1A0AB58 	48 40 A0  1  0  2  0  0 
nuser 'source-id
1A0AB60 	 0 27 73 6F 75 72 63 65 
1A0AB68 	2D 69 64 8A 58 AB A0  1 
1A0AB70 	48 40 A0  1  4  2  0  0 
nuser file
1A0AB78 	 0  0  0 66 69 6C 65 84 
1A0AB80 	70 AB A0  1 48 40 A0  1 
1A0AB88 	 8  2  0  0 


\ field creates words which return their address within the structure
\ pointed-to by the contents of file

\ The file descriptor structure describes an open file.
\ There is a pool of several of these structures.  When a file is opened,
\ a structure is allocated and initialized.  While performing an io
\ operation, the user variable "file" contains a pointer to the file
\ on which the operation is being performed.

: bfbase    file @  0 na+  ;   \ starting address of the buffer for this file
1A0AB8C 	 0 62 66 62 
1A0AB90 	61 73 65 86 84 AB A0  1 
1A0AB98 	20 40 A0  1 84 AB A0  1 
1A0ABA0 	5C 4C A0  1 70 6F A0  1 
1A0ABA8 	48 50 A0  1 58 46 A0  1 
: bflimit   file @  1 na+  ;   \ ending address of the buffer for this file
1A0ABB0 	62 66 6C 69 6D 69 74 87 
1A0ABB8 	98 AB A0  1 20 40 A0  1 
1A0ABC0 	84 AB A0  1 5C 4C A0  1 
1A0ABC8 	80 6F A0  1 48 50 A0  1 
1A0ABD0 	58 46 A0  1 
headerless
: bftop     file @  2 na+  ;   \ address past last valid character in the buffer
1A0ABD4 	 0  0 62 66 
1A0ABD8 	74 6F 70 85 BC AB A0  1 
1A0ABE0 	20 40 A0  1 84 AB A0  1 
1A0ABE8 	5C 4C A0  1 90 6F A0  1 
1A0ABF0 	48 50 A0  1 58 46 A0  1 
: bfend     file @  3 na+  ;   \ address past last place to write in the buffer
1A0ABF8 	 0  0 62 66 65 6E 64 85 
1A0AC00 	E0 AB A0  1 20 40 A0  1 
1A0AC08 	84 AB A0  1 5C 4C A0  1 
1A0AC10 	A0 6F A0  1 48 50 A0  1 
1A0AC18 	58 46 A0  1 
: bfcurrent file @  4 na+  ;   \ address of the current character in the buffer
1A0AC1C 	 0  0 62 66 
1A0AC20 	63 75 72 72 65 6E 74 89 
1A0AC28 	 4 AC A0  1 20 40 A0  1 
1A0AC30 	84 AB A0  1 5C 4C A0  1 
1A0AC38 	B0 6F A0  1 48 50 A0  1 
1A0AC40 	58 46 A0  1 
: bfdirty   file @  5 na+  ;   \ contains true if the buffer has been modified
1A0AC44 	62 66 64 69 
1A0AC48 	72 74 79 87 2C AC A0  1 
1A0AC50 	20 40 A0  1 84 AB A0  1 
1A0AC58 	5C 4C A0  1 C0 6F A0  1 
1A0AC60 	48 50 A0  1 58 46 A0  1 
: fmode     file @  6 na+  ;   \ not-open, read, write, or modify
1A0AC68 	 0  0 66 6D 6F 64 65 85 
1A0AC70 	50 AC A0  1 20 40 A0  1 
1A0AC78 	84 AB A0  1 5C 4C A0  1 
1A0AC80 	D0 6F A0  1 48 50 A0  1 
1A0AC88 	58 46 A0  1 
: fstart    file @  7 na+  ;   \ Position in file of the first byte in buffer
1A0AC8C 	 0 66 73 74 
1A0AC90 	61 72 74 86 74 AC A0  1 
1A0AC98 	20 40 A0  1 84 AB A0  1 
1A0ACA0 	5C 4C A0  1 E0 6F A0  1 
1A0ACA8 	48 50 A0  1 58 46 A0  1 
: fid       file @  9 na+  ;   \ File handle for underlying operating system
1A0ACB0 	66 69 64 83 98 AC A0  1 
1A0ACB8 	20 40 A0  1 84 AB A0  1 
1A0ACC0 	5C 4C A0  1 58 41 A0  1 
1A0ACC8 	 9  0  0  0 48 50 A0  1 
1A0ACD0 	58 46 A0  1 
: seekop    file @ 10 na+  ;   \ Points to system routine to set the file position
1A0ACD4 	 0 73 65 65 
1A0ACD8 	6B 6F 70 86 B8 AC A0  1 
1A0ACE0 	20 40 A0  1 84 AB A0  1 
1A0ACE8 	5C 4C A0  1 58 41 A0  1 
1A0ACF0 	 A  0  0  0 48 50 A0  1 
1A0ACF8 	58 46 A0  1 
: readop    file @ 11 na+  ;   \ Points to system routine to read blocks
1A0ACFC 	 0 72 65 61 
1A0AD00 	64 6F 70 86 E0 AC A0  1 
1A0AD08 	20 40 A0  1 84 AB A0  1 
1A0AD10 	5C 4C A0  1 58 41 A0  1 
1A0AD18 	 B  0  0  0 48 50 A0  1 
1A0AD20 	58 46 A0  1 
: writeop   file @ 12 na+  ;   \ Points to system routine to write blocks
1A0AD24 	77 72 69 74 
1A0AD28 	65 6F 70 87  8 AD A0  1 
1A0AD30 	20 40 A0  1 84 AB A0  1 
1A0AD38 	5C 4C A0  1 58 41 A0  1 
1A0AD40 	 C  0  0  0 48 50 A0  1 
1A0AD48 	58 46 A0  1 
: closeop   file @ 13 na+  ;   \ Points to system routine to close file
1A0AD4C 	63 6C 6F 73 
1A0AD50 	65 6F 70 87 30 AD A0  1 
1A0AD58 	20 40 A0  1 84 AB A0  1 
1A0AD60 	5C 4C A0  1 58 41 A0  1 
1A0AD68 	 D  0  0  0 48 50 A0  1 
1A0AD70 	58 46 A0  1 
: alignop   file @ 14 na+  ;   \ Points to system routine to align to block boundary
1A0AD74 	61 6C 69 67 
1A0AD78 	6E 6F 70 87 58 AD A0  1 
1A0AD80 	20 40 A0  1 84 AB A0  1 
1A0AD88 	5C 4C A0  1 58 41 A0  1 
1A0AD90 	 E  0  0  0 48 50 A0  1 
1A0AD98 	58 46 A0  1 
: sizeop    file @ 15 na+  ;   \ Points to system routine to return the file size
1A0AD9C 	 0 73 69 7A 
1A0ADA0 	65 6F 70 86 80 AD A0  1 
1A0ADA8 	20 40 A0  1 84 AB A0  1 
1A0ADB0 	5C 4C A0  1 58 41 A0  1 
1A0ADB8 	 F  0  0  0 48 50 A0  1 
1A0ADC0 	58 46 A0  1 
: (file-line)    file @ 16 na+  ;   \ Number of line delims that read-line has consumed
1A0ADC4 	28 66 69 6C 
1A0ADC8 	65 2D 6C 69 6E 65 29 8B 
1A0ADD0 	A8 AD A0  1 20 40 A0  1 
1A0ADD8 	84 AB A0  1 5C 4C A0  1 
1A0ADE0 	58 41 A0  1 10  0  0  0 
1A0ADE8 	48 50 A0  1 58 46 A0  1 
: line-delimiter file @ 17 na+  ;   \ The last delimiter at the end of each line
1A0ADF0 	 0 6C 69 6E 65 2D 64 65 
1A0ADF8 	6C 69 6D 69 74 65 72 8E 
1A0AE00 	D4 AD A0  1 20 40 A0  1 
1A0AE08 	84 AB A0  1 5C 4C A0  1 
1A0AE10 	58 41 A0  1 11  0  0  0 
1A0AE18 	48 50 A0  1 58 46 A0  1 
: pre-delimiter  file @ 18 na+  ;   \ The first line delimiter (if any)
1A0AE20 	 0  0 70 72 65 2D 64 65 
1A0AE28 	6C 69 6D 69 74 65 72 8D 
1A0AE30 	 4 AE A0  1 20 40 A0  1 
1A0AE38 	84 AB A0  1 5C 4C A0  1 
1A0AE40 	58 41 A0  1 12  0  0  0 
1A0AE48 	48 50 A0  1 58 46 A0  1 
: (file-name)    file @ 19 na+  ;   \ The name of the file
1A0AE50 	28 66 69 6C 65 2D 6E 61 
1A0AE58 	6D 65 29 8B 34 AE A0  1 
1A0AE60 	20 40 A0  1 84 AB A0  1 
1A0AE68 	5C 4C A0  1 58 41 A0  1 
1A0AE70 	13  0  0  0 48 50 A0  1 
1A0AE78 	58 46 A0  1 


: source-id  ( -- fid )  'source-id @  ;
1A0AE7C 	 0  0 73 6F 
1A0AE80 	75 72 63 65 2D 69 64 89 
1A0AE88 	60 AE A0  1 20 40 A0  1 
1A0AE90 	70 AB A0  1 5C 4C A0  1 
1A0AE98 	58 46 A0  1 

\ An implementation factor which
\ ensures that the bftop is >= the bfcurrent variable.  bfcurrent
\ can temporarily advance beyond bftop while a file is being extended.

: sync  ( -- )  \ if current > top, move up top
1A0AE9C 	 0  0  0 73 
1A0AEA0 	79 6E 63 84 8C AE A0  1 
1A0AEA8 	20 40 A0  1 
   bftop @ bfcurrent @ u<   if    bfcurrent @  bftop !    then
1A0AEAC 	E0 AB A0  1 
1A0AEB0 	5C 4C A0  1 2C AC A0  1 
1A0AEB8 	5C 4C A0  1 A8 48 A0  1 
1A0AEC0 	DC 41 A0  1 14  0  0  0 
1A0AEC8 	2C AC A0  1 5C 4C A0  1 
1A0AED0 	E0 AB A0  1 54 4D A0  1 
;
1A0AED8 	58 46 A0  1 


\ If the current file's buffer is modified, write it out
\ Need to better handle the case where the file can't be extended,
\ for instance if the file is a memory array
: ?flushbuf  ( -- )
1A0AEDC 	 0  0 3F 66 
1A0AEE0 	6C 75 73 68 62 75 66 89 
1A0AEE8 	A8 AE A0  1 20 40 A0  1 
   bfdirty @   if
1A0AEF0 	50 AC A0  1 5C 4C A0  1 
1A0AEF8 	DC 41 A0  1 94  0  0  0 
      sync
1A0AF00 	A8 AE A0  1 
      fstart 2@  fid @  seekop @ execute  ( )
1A0AF04 	98 AC A0  1 
1A0AF08 	CC 4D A0  1 B8 AC A0  1 
1A0AF10 	5C 4C A0  1 E0 AC A0  1 
1A0AF18 	5C 4C A0  1 98 41 A0  1 
      bftop @ bfbase @  -                 ( #bytes-to-write)
1A0AF20 	E0 AB A0  1 5C 4C A0  1 
1A0AF28 	98 AB A0  1 5C 4C A0  1 
1A0AF30 	18 45 A0  1 
      bfbase @  over                      ( #bytes adr #bytes )
1A0AF34 	98 AB A0  1 
1A0AF38 	5C 4C A0  1 54 49 A0  1 
      fid @ writeop @ execute             ( #bytes-to-write #bytes-written )
1A0AF40 	B8 AC A0  1 5C 4C A0  1 
1A0AF48 	30 AD A0  1 5C 4C A0  1 
1A0AF50 	98 41 A0  1 
      u>  ( -37 ) abort" Flushbuf error"
1A0AF54 	64 48 A0  1 
1A0AF58 	 8 81 A0  1  E 46 6C 75 
1A0AF60 	73 68 62 75 66 20 65 72 
1A0AF68 	72 6F 72  0 
      bfdirty off
1A0AF6C 	50 AC A0  1 
1A0AF70 	F8 4B A0  1 
      bfbase @   dup bftop !  bfcurrent !
1A0AF74 	98 AB A0  1 
1A0AF78 	5C 4C A0  1 40 49 A0  1 
1A0AF80 	E0 AB A0  1 54 4D A0  1 
1A0AF88 	2C AC A0  1 54 4D A0  1 
   then
;
1A0AF90 	58 46 A0  1 

: align-byte#  ( d.byte# -- d.aln-byte# )  fid @ alignop @ execute  ;
1A0AF94 	61 6C 69 67 
1A0AF98 	6E 2D 62 79 74 65 23 8B 
1A0AFA0 	EC AE A0  1 20 40 A0  1 
1A0AFA8 	B8 AC A0  1 5C 4C A0  1 
1A0AFB0 	80 AD A0  1 5C 4C A0  1 
1A0AFB8 	98 41 A0  1 58 46 A0  1 

\ An implementation factor which
\ fills the buffer with a block from the current file.  The block will
\ be chosen so that the file address "d.byte#" is somewhere within that
\ block.

: fillbuf  ( d.byte# -- )
1A0AFC0 	66 69 6C 6C 62 75 66 87 
1A0AFC8 	A4 AF A0  1 20 40 A0  1 
   align-byte#              ( d.byte# ) \ Aligns position to a buffer boundary
1A0AFD0 	A4 AF A0  1 
   2dup fstart 2!           ( d.byte# )
1A0AFD4 	C0 49 A0  1 
1A0AFD8 	98 AC A0  1 E4 4D A0  1 
   fid @ seekop @ execute               ( )
1A0AFE0 	B8 AC A0  1 5C 4C A0  1 
1A0AFE8 	E0 AC A0  1 5C 4C A0  1 
1A0AFF0 	98 41 A0  1 
   bfbase @   bflimit @ over -          ( adr #bytes-to-read )
1A0AFF4 	98 AB A0  1 
1A0AFF8 	5C 4C A0  1 BC AB A0  1 
1A0B000 	5C 4C A0  1 54 49 A0  1 
1A0B008 	18 45 A0  1 
   fid @ readop @ execute               ( #bytes-read )
1A0B00C 	B8 AC A0  1 
1A0B010 	5C 4C A0  1  8 AD A0  1 
1A0B018 	5C 4C A0  1 98 41 A0  1 
   bfbase @ +   bftop !
1A0B020 	98 AB A0  1 5C 4C A0  1 
1A0B028 	 4 45 A0  1 E0 AB A0  1 
1A0B030 	54 4D A0  1 
   bflimit @  bfend !
1A0B034 	BC AB A0  1 
1A0B038 	5C 4C A0  1  4 AC A0  1 
1A0B040 	54 4D A0  1 
;
1A0B044 	58 46 A0  1 

\ An implementation factor which
\ returns the address within the buffer corresponding to the
\ selected position "d.byte#" within the current file.

: bufaddr>  ( bufaddr -- d.byte# )  bfbase @ - s>d  fstart 2@ d+  ;
1A0B048 	 0  0  0 62 75 66 61 64 
1A0B050 	64 72 3E 88 CC AF A0  1 
1A0B058 	20 40 A0  1 98 AB A0  1 
1A0B060 	5C 4C A0  1 18 45 A0  1 
1A0B068 	9C 68 A0  1 98 AC A0  1 
1A0B070 	CC 4D A0  1 E0 5D A0  1 
1A0B078 	58 46 A0  1 
: >bufaddr  ( d.byte# -- bufaddr )  fstart 2@ d- drop  bfbase @ +  ;
1A0B07C 	 0  0  0 3E 
1A0B080 	62 75 66 61 64 64 72 88 
1A0B088 	58 B0 A0  1 20 40 A0  1 
1A0B090 	98 AC A0  1 CC 4D A0  1 
1A0B098 	F8 5D A0  1 30 49 A0  1 
1A0B0A0 	98 AB A0  1 5C 4C A0  1 
1A0B0A8 	 4 45 A0  1 58 46 A0  1 

\ An implementation factor which
\ advances to the next block in the file.  This is used when accesses
\ to the file are sequential (the most common case).

\ Assumes the byte is not already in the buffer!
: shortseek  ( bufaddr -- )
1A0B0B0 	 0  0 73 68 6F 72 74 73 
1A0B0B8 	65 65 6B 89 8C B0 A0  1 
1A0B0C0 	20 40 A0  1 
   ?flushbuf                             ( bufaddr )
1A0B0C4 	EC AE A0  1 
   bfbase @ - s>d  fstart 2@  d+         ( d.byte# )
1A0B0C8 	98 AB A0  1 5C 4C A0  1 
1A0B0D0 	18 45 A0  1 9C 68 A0  1 
1A0B0D8 	98 AC A0  1 CC 4D A0  1 
1A0B0E0 	E0 5D A0  1 
   2dup fillbuf                          ( d.byte# )
1A0B0E4 	C0 49 A0  1 
1A0B0E8 	CC AF A0  1 
   >bufaddr  bftop @  umin  bfcurrent !
1A0B0EC 	8C B0 A0  1 
1A0B0F0 	E0 AB A0  1 5C 4C A0  1 
1A0B0F8 	4C 4A A0  1 2C AC A0  1 
1A0B100 	54 4D A0  1 
;
1A0B104 	58 46 A0  1 

\ An implementation factor
\ Copyin copies bytes starting at current into the file buffer at
\ bfcurrent.  The number of bytes copied is either all the bytes from
\ current to end, if the buffer has enough room, or all the bytes the
\ buffer will hold, if not.
\ newcurrent is left pointing to the first byte not copied.
headerless
: copyin  ( end current -- end newcurrent )
1A0B108 	 0 63 6F 70 79 69 6E 86 
1A0B110 	C0 B0 A0  1 20 40 A0  1 
   2dup -                      ( end current remaining )
1A0B118 	C0 49 A0  1 18 45 A0  1 
   bfend @  bfcurrent @  -     ( end current remaining bfremaining )
1A0B120 	 4 AC A0  1 5C 4C A0  1 
1A0B128 	2C AC A0  1 5C 4C A0  1 
1A0B130 	18 45 A0  1 
   min                         ( end current #bytes-to-copy )
1A0B134 	74 4A A0  1 
   dup if  bfdirty on  then    ( end current #bytes-to-copy )
1A0B138 	40 49 A0  1 DC 41 A0  1 
1A0B140 	 C  0  0  0 50 AC A0  1 
1A0B148 	E0 4B A0  1 
   2dup  bfcurrent @ swap      ( end current #bytes  current bfcurrent #bytes)
1A0B14C 	C0 49 A0  1 
1A0B150 	2C AC A0  1 5C 4C A0  1 
1A0B158 	68 49 A0  1 
   move                        ( end current #bytes )
1A0B15C 	F4 4A A0  1 
   dup bfcurrent +!            ( end current #bytes )
1A0B160 	40 49 A0  1 2C AC A0  1 
1A0B168 	 C 4C A0  1 
   +                           ( end newcurrent)
1A0B16C 	 4 45 A0  1 
;
1A0B170 	58 46 A0  1 

: byte#-aligned?  ( d.byte# -- flag )  2dup align-byte#  d=  ;
1A0B174 	 0 62 79 74 
1A0B178 	65 23 2D 61 6C 69 67 6E 
1A0B180 	65 64 3F 8E 14 B1 A0  1 
1A0B188 	20 40 A0  1 C0 49 A0  1 
1A0B190 	A4 AF A0  1 4C 67 A0  1 
1A0B198 	58 46 A0  1 

\ This is called from fputs to open up space in the buffer for block-sized
\ chunks, avoiding prefills that would be completely overwritten.
: prefill?  ( endaddr curaddr -- endaddr curraddr flag )
1A0B19C 	 0  0  0 70 
1A0B1A0 	72 65 66 69 6C 6C 3F 88 
1A0B1A8 	88 B1 A0  1 20 40 A0  1 

   \ If the current buffer pointer is not block-aligned, must prefill
   bfcurrent @  bufaddr>  byte#-aligned?  0=  if  true  exit  then  ( end curr )
1A0B1B0 	2C AC A0  1 5C 4C A0  1 
1A0B1B8 	58 B0 A0  1 88 B1 A0  1 
1A0B1C0 	24 47 A0  1 DC 41 A0  1 
1A0B1C8 	 C  0  0  0  4 70 A0  1 
1A0B1D0 	40 46 A0  1 

   2dup -  0 align-byte# drop           ( end curr aln-size )
1A0B1D4 	C0 49 A0  1 
1A0B1D8 	18 45 A0  1 70 6F A0  1 
1A0B1E0 	A4 AF A0  1 30 49 A0  1 

   \ If the incoming data won't fill a block, must prefill
   ?dup  0=  if  true exit  then        ( end curr aln-size )
1A0B1E8 	B4 70 A0  1 24 47 A0  1 
1A0B1F0 	DC 41 A0  1  C  0  0  0 
1A0B1F8 	 4 70 A0  1 40 46 A0  1 

   \ If there is still space in the buffer, just open it up for copyin
   bflimit @ bfend @ -  ?dup  if        ( end curr aln-len buffer-avail )
1A0B200 	BC AB A0  1 5C 4C A0  1 
1A0B208 	 4 AC A0  1 5C 4C A0  1 
1A0B210 	18 45 A0  1 B4 70 A0  1 
1A0B218 	DC 41 A0  1 18  0  0  0 
      min  bfend +!  false exit
1A0B220 	74 4A A0  1  4 AC A0  1 
1A0B228 	 C 4C A0  1 18 70 A0  1 
1A0B230 	40 46 A0  1 
   then                                 ( end curr aln-len )

   \ Save current on stack because ?flushbuf clears it
   bfcurrent @                          ( end curr aln-len current )
1A0B234 	2C AC A0  1 
1A0B238 	5C 4C A0  1 

   \ The buffer is full; clear out its old contents
   ?flushbuf                            ( end curr aln-len )
1A0B23C 	EC AE A0  1 

   \ Advance the file pointer to the new buffer starting position
   bufaddr> fstart 2!                   ( end curr aln-len )
1A0B240 	58 B0 A0  1 98 AC A0  1 
1A0B248 	E4 4D A0  1 

   bfbase @ + bflimit @ min  bfend !    ( end curr )  \ Room for new bytes
1A0B24C 	98 AB A0  1 
1A0B250 	5C 4C A0  1  4 45 A0  1 
1A0B258 	BC AB A0  1 5C 4C A0  1 
1A0B260 	74 4A A0  1  4 AC A0  1 
1A0B268 	54 4D A0  1 
   bfbase @  dup bftop !  bfcurrent !   ( end curr )  \ No valid bytes yet
1A0B26C 	98 AB A0  1 
1A0B270 	5C 4C A0  1 40 49 A0  1 
1A0B278 	E0 AB A0  1 54 4D A0  1 
1A0B280 	2C AC A0  1 54 4D A0  1 
   false
1A0B288 	18 70 A0  1 
;
1A0B28C 	58 46 A0  1 


\ Stores a byte into the current file at the next position
: fputc  ( byte fd -- )
1A0B290 	 0  0 66 70 75 74 63 85 
1A0B298 	AC B1 A0  1 20 40 A0  1 
   file @ >r  file !
1A0B2A0 	84 AB A0  1 5C 4C A0  1 
1A0B2A8 	BC 45 A0  1 84 AB A0  1 
1A0B2B0 	54 4D A0  1 
   bfcurrent @   bfend @ u>=     ( byte flag )  \ Is the buffer full?
1A0B2B4 	2C AC A0  1 
1A0B2B8 	5C 4C A0  1  4 AC A0  1 
1A0B2C0 	5C 4C A0  1 CC 48 A0  1 
   if  bfcurrent @ shortseek  then     ( byte ) \ If so advance to next buffer
1A0B2C8 	DC 41 A0  1 10  0  0  0 
1A0B2D0 	2C AC A0  1 5C 4C A0  1 
1A0B2D8 	C0 B0 A0  1 
   bfcurrent @c!++  bfdirty on
1A0B2DC 	2C AC A0  1 
1A0B2E0 	 4 63 A0  1 50 AC A0  1 
1A0B2E8 	E0 4B A0  1 
   r> file !
1A0B2EC 	D0 45 A0  1 
1A0B2F0 	84 AB A0  1 54 4D A0  1 
;
1A0B2F8 	58 46 A0  1 

\ Writes count bytes from memory starting at "adr" to the current file
: fputs  ( adr count fd -- )
1A0B2FC 	 0  0 66 70 
1A0B300 	75 74 73 85 9C B2 A0  1 
1A0B308 	20 40 A0  1 
   file @ >r  file !
1A0B30C 	84 AB A0  1 
1A0B310 	5C 4C A0  1 BC 45 A0  1 
1A0B318 	84 AB A0  1 54 4D A0  1 
   over + swap                    ( endaddr startaddr )
1A0B320 	54 49 A0  1  4 45 A0  1 
1A0B328 	68 49 A0  1 
   begin  copyin  2dup u>  while  ( endaddr curraddr )
1A0B32C 	14 B1 A0  1 
1A0B330 	C0 49 A0  1 64 48 A0  1 
1A0B338 	DC 41 A0  1 28  0  0  0 
      sync                        ( endaddr curraddr )
1A0B340 	A8 AE A0  1 
      \ Prefill? tries to avoid unnecessary reads by opening up space
      \ in the buffer for chunks that will completely fill a block.
      prefill?  if                ( endaddr curraddr )
1A0B344 	AC B1 A0  1 
1A0B348 	DC 41 A0  1 10  0  0  0 
         bfcurrent @ shortseek    ( endaddr curraddr )
1A0B350 	2C AC A0  1 5C 4C A0  1 
1A0B358 	C0 B0 A0  1 
      then
   repeat
1A0B35C 	C8 41 A0  1 
1A0B360 	CC FF FF FF 
   2drop
1A0B364 	AC 49 A0  1 
   r> file !
1A0B368 	D0 45 A0  1 84 AB A0  1 
1A0B370 	54 4D A0  1 
;
1A0B374 	58 46 A0  1 


: file-name  ( fd -- adr len )
1A0B378 	 0  0 66 69 6C 65 2D 6E 
1A0B380 	61 6D 65 89  8 B3 A0  1 
1A0B388 	20 40 A0  1 
   file @ >r  file !  (file-name) count  r> file !
1A0B38C 	84 AB A0  1 
1A0B390 	5C 4C A0  1 BC 45 A0  1 
1A0B398 	84 AB A0  1 54 4D A0  1 
1A0B3A0 	60 AE A0  1 BC 53 A0  1 
1A0B3A8 	D0 45 A0  1 84 AB A0  1 
1A0B3B0 	54 4D A0  1 
;
1A0B3B4 	58 46 A0  1 

: file-line  ( fd -- n )  file @ >r  file !  (file-line) @  r> file !  ;
1A0B3B8 	 0  0 66 69 6C 65 2D 6C 
1A0B3C0 	69 6E 65 89 88 B3 A0  1 
1A0B3C8 	20 40 A0  1 84 AB A0  1 
1A0B3D0 	5C 4C A0  1 BC 45 A0  1 
1A0B3D8 	84 AB A0  1 54 4D A0  1 
1A0B3E0 	D4 AD A0  1 5C 4C A0  1 
1A0B3E8 	D0 45 A0  1 84 AB A0  1 
1A0B3F0 	54 4D A0  1 58 46 A0  1 

decimal
[ifdef] omit-files
: $tagout 2drop ;
[else]
: $tag-field  ( $ -- )  tag-file @ fputs  ;
1A0B3F8 	 0 24 74 61 67 2D 66 69 
1A0B400 	65 6C 64 8A C8 B3 A0  1 
1A0B408 	20 40 A0  1 58 AB A0  1 
1A0B410 	5C 4C A0  1  8 B3 A0  1 
1A0B418 	58 46 A0  1 
: tag-char  ( char -- )  tag-file @ fputc  ;
1A0B41C 	 0  0  0 74 
1A0B420 	61 67 2D 63 68 61 72 88 
1A0B428 	 8 B4 A0  1 20 40 A0  1 
1A0B430 	58 AB A0  1 5C 4C A0  1 
1A0B438 	9C B2 A0  1 58 46 A0  1 

: $tagout  ( name$ -- )
1A0B440 	24 74 61 67 6F 75 74 87 
1A0B448 	2C B4 A0  1 20 40 A0  1 
   tag-file @ 0=  if  2drop exit  then
1A0B450 	58 AB A0  1 5C 4C A0  1 
1A0B458 	24 47 A0  1 DC 41 A0  1 
1A0B460 	 C  0  0  0 AC 49 A0  1 
1A0B468 	40 46 A0  1 
   source-id -1 =  if  2drop exit  then
1A0B46C 	8C AE A0  1 
1A0B470 	58 41 A0  1 FF FF FF FF 
1A0B478 	24 48 A0  1 DC 41 A0  1 
1A0B480 	 C  0  0  0 AC 49 A0  1 
1A0B488 	40 46 A0  1 
   $tag-field  9 tag-char
1A0B48C 	 8 B4 A0  1 
1A0B490 	58 41 A0  1  9  0  0  0 
1A0B498 	2C B4 A0  1 
   source-id file-name  $tag-field  9 tag-char
1A0B49C 	8C AE A0  1 
1A0B4A0 	88 B3 A0  1  8 B4 A0  1 
1A0B4A8 	58 41 A0  1  9  0  0  0 
1A0B4B0 	2C B4 A0  1 
   base @ decimal  source-id file-line (.) $tag-field  base !
1A0B4B4 	B8 75 A0  1 
1A0B4B8 	5C 4C A0  1 E4 8D A0  1 
1A0B4C0 	8C AE A0  1 C8 B3 A0  1 
1A0B4C8 	10 78 A0  1  8 B4 A0  1 
1A0B4D0 	B8 75 A0  1 54 4D A0  1 
   newline-string $tag-field
1A0B4D8 	8C 71 A0  1  8 B4 A0  1 
;
1A0B4E0 	58 46 A0  1 
[then]

: $make-header  ( adr len voc-acf -- )
1A0B4E4 	 0  0  0 24 
1A0B4E8 	6D 61 6B 65 2D 68 65 61 
1A0B4F0 	64 65 72 8C 4C B4 A0  1 
1A0B4F8 	20 40 A0  1 
   -rot                        ( voc-acf adr,len )
1A0B4FC 	94 49 A0  1 
   2dup $tagout
1A0B500 	C0 49 A0  1 4C B4 A0  1 
   dup 1+ /link +              ( voc-acf adr,len hdr-len )
1A0B508 	40 49 A0  1 30 4B A0  1 
1A0B510 	78 73 A0  1  4 45 A0  1 

   here +                       ( voc-acf adr,len  addr' )
1A0B518 	70 54 A0  1  4 45 A0  1 
   dup acf-aligned swap - allot ( voc-acf adr,len )
1A0B520 	40 49 A0  1  C 5D A0  1 
1A0B528 	68 49 A0  1 18 45 A0  1 
1A0B530 	E4 54 A0  1 
   tuck here over 1+  noop  allot     ( voc-acf len adr,len anf )
1A0B534 	E8 46 A0  1 
1A0B538 	70 54 A0  1 54 49 A0  1 
1A0B540 	30 4B A0  1 64 4F A0  1 
1A0B548 	E4 54 A0  1 
   place-cstr                  ( voc-acf len anf )
1A0B54C 	B4 8A A0  1 
   over + c!                   ( voc-acf )
1A0B550 	54 49 A0  1  4 45 A0  1 
1A0B558 	B8 4D A0  1 
   here 1- last !              ( voc-acf )
1A0B55C 	70 54 A0  1 
1A0B560 	54 4B A0  1  4 A4 A0  1 
1A0B568 	54 4D A0  1 
   >threads                    ( threads-adr )
1A0B56C 	EC 74 A0  1 
   /link allot here            ( threads-adr acf )
1A0B570 	78 73 A0  1 E4 54 A0  1 
1A0B578 	70 54 A0  1 

   swap 2dup a@             ( acf threads-adr acf succ-acf )
1A0B57C 	68 49 A0  1 
1A0B580 	C0 49 A0  1 88 58 A0  1 
   swap >link a! a!      (  )
1A0B588 	68 49 A0  1 EC 73 A0  1 
1A0B590 	98 58 A0  1 98 58 A0  1 

   last @ c@  h# 80 or  last @ c!
1A0B598 	 4 A4 A0  1 5C 4C A0  1 
1A0B5A0 	C4 4C A0  1 58 41 A0  1 
1A0B5A8 	80  0  0  0 70 44 A0  1 
1A0B5B0 	 4 A4 A0  1 5C 4C A0  1 
1A0B5B8 	B8 4D A0  1 
;
1A0B5BC 	58 46 A0  1 

headers
: >first  ( voc-acf -- first-alf )  >threads  ;
1A0B5C0 	 0 3E 66 69 72 73 74 86 
1A0B5C8 	F8 B4 A0  1 20 40 A0  1 
1A0B5D0 	EC 74 A0  1 58 46 A0  1 

defer $find-next
1A0B5D8 	 0 24 66 69 6E 64 2D 6E 
1A0B5E0 	65 78 74 8A CC B5 A0  1 
1A0B5E8 	5C 40 A0  1  C  2  0  0 


headerless

: next-word  ( alf voc-acf -- false  |  alf' true )
1A0B5F0 	 0  0 6E 65 78 74 2D 77 
1A0B5F8 	6F 72 64 89 E8 B5 A0  1 
1A0B600 	20 40 A0  1 
   >ptr another-link?  if  >link  true  else  false  then
1A0B604 	C0 A4 A0  1 
1A0B608 	90 59 A0  1 DC 41 A0  1 
1A0B610 	14  0  0  0 EC 73 A0  1 
1A0B618 	 4 70 A0  1 C8 41 A0  1 
1A0B620 	 8  0  0  0 18 70 A0  1 
;
1A0B628 	58 46 A0  1 


\ Makes a sealed vocabulary with the top-of-voc pointer in user area
\ parameter field of vocabularies contains:
\ user-#-of-voc-pointer ,  voc-link ,

\ For navigating inside a vocabulary's data structure.
\ A vocabulary's parameter field contains:
\   user#  link
\ The threads are stored in the user area.

: voc>      (s voc-link-adr -- acf )
1A0B62C 	 0  0  0 76 
1A0B630 	6F 63 3E 84  0 B6 A0  1 
1A0B638 	20 40 A0  1 
\   /user# -  body>
;
1A0B63C 	58 46 A0  1 

: >voc-link ( voc-acf -- voc-link-adr )  >body /user# +  ;
1A0B640 	 0  0 3E 76 6F 63 2D 6C 
1A0B648 	69 6E 6B 89 38 B6 A0  1 
1A0B650 	20 40 A0  1 E4 59 A0  1 
1A0B658 	40 5A A0  1  4 45 A0  1 
1A0B660 	58 46 A0  1 


auser voc-link     \ points to newest vocabulary
1A0B664 	 0  0  0 76 
1A0B668 	6F 63 2D 6C 69 6E 6B 88 
1A0B670 	50 B6 A0  1 48 40 A0  1 
1A0B678 	10  2  0  0 

: voc-link,  (s -- )  \ links this vocabulary to the chain
1A0B67C 	 0  0 76 6F 
1A0B680 	63 2D 6C 69 6E 6B 2C 89 
1A0B688 	74 B6 A0  1 20 40 A0  1 
   lastacf  voc-link a@  a,   voc-link a!
1A0B690 	AC 57 A0  1 74 B6 A0  1 
1A0B698 	88 58 A0  1 AC 58 A0  1 
1A0B6A0 	74 B6 A0  1 98 58 A0  1 
;
1A0B6A8 	58 46 A0  1 


: (wordlist)  ( -- )
1A0B6AC 	 0 28 77 6F 
1A0B6B0 	72 64 6C 69 73 74 29 8A 
1A0B6B8 	8C B6 A0  1 20 40 A0  1 
   create-cf
1A0B6C0 	30 5B A0  1 
   /link user#,  !null-link   ( )
1A0B6C4 	78 73 A0  1 
1A0B6C8 	84 9A A0  1 EC 58 A0  1 
   voc-link,
1A0B6D0 	8C B6 A0  1 
   0 ,				\ Space for additional information
1A0B6D4 	70 6F A0  1 
1A0B6D8 	98 55 A0  1 
   does> body> context token!
1A0B6DC 	50 A3 A0  1 
1A0B6E0 	90 90 90 E8 94 89 FF FF 
1A0B6E8 	C8 59 A0  1 DC A3 A0  1 
1A0B6F0 	20 54 A0  1 
; resolves <vocabulary>
1A0B6F4 	58 46 A0  1 

headers

\ From voccom.fth

\ Common routines for vocabularies, independent of name field
\ implementation details

headers
: wordlist  ( -- wid )  (wordlist) lastacf  ;
1A0B6F8 	 0  0  0 77 6F 72 64 6C 
1A0B700 	69 73 74 88 BC B6 A0  1 
1A0B708 	20 40 A0  1 BC B6 A0  1 
1A0B710 	AC 57 A0  1 58 46 A0  1 
: vocabulary  ( "name" -- )  header (wordlist)  ;
1A0B718 	 0 76 6F 63 61 62 75 6C 
1A0B720 	61 72 79 8A  8 B7 A0  1 
1A0B728 	20 40 A0  1 DC 6D A0  1 
1A0B730 	BC B6 A0  1 58 46 A0  1 

' ($find-next) is $find-next


#threads-t constant #threads
1A0B738 	 0  0  0 23 74 68 72 65 
1A0B740 	61 64 73 88 28 B7 A0  1 
1A0B748 	68 40 A0  1  1  0  0  0 


: find-voc ( xt - voc-node|false )
1A0B750 	 0  0  0 66 69 6E 64 2D 
1A0B758 	76 6F 63 88 48 B7 A0  1 
1A0B760 	20 40 A0  1 
   >r voc-link  			( voc-node )
1A0B764 	BC 45 A0  1 
1A0B768 	74 B6 A0  1 
   begin
      another-link? false = if          ( - | voc-node )
1A0B76C 	90 59 A0  1 
1A0B770 	18 70 A0  1 24 48 A0  1 
1A0B778 	DC 41 A0  1 14  0  0  0 
         false true			( false loop-flag )
1A0B780 	18 70 A0  1  4 70 A0  1 
      else				( voc-node )
1A0B788 	C8 41 A0  1 20  0  0  0 
	 dup voc> 			( voc-node voc-xt )
1A0B790 	40 49 A0  1 38 B6 A0  1 
	 swap >voc-link swap            ( voc-node' voc-xt )
1A0B798 	68 49 A0  1 50 B6 A0  1 
1A0B7A0 	68 49 A0  1 
         r@ execute	     		( voc-node' flag )
1A0B7A4 	E4 45 A0  1 
1A0B7A8 	98 41 A0  1 
      then				( voc-node'|false loop-flag )
   until				( voc-node' )
1A0B7AC 	DC 41 A0  1 
1A0B7B0 	BC FF FF FF 
   r> drop				( voc-node|false )
1A0B7B4 	D0 45 A0  1 
1A0B7B8 	30 49 A0  1 
;
1A0B7BC 	58 46 A0  1 

headerless
hex
0 value fake-name-buf
1A0B7C0 	 0  0 66 61 6B 65 2D 6E 
1A0B7C8 	61 6D 65 2D 62 75 66 8D 
1A0B7D0 	60 B7 A0  1 50 40 A0  1 
1A0B7D8 	14  2  0  0 

: fake-name  ( xt -- anf )
1A0B7DC 	 0  0 66 61 
1A0B7E0 	6B 65 2D 6E 61 6D 65 89 
1A0B7E8 	D4 B7 A0  1 20 40 A0  1 
   base @ >r hex
1A0B7F0 	B8 75 A0  1 5C 4C A0  1 
1A0B7F8 	BC 45 A0  1 C0 8D A0  1 
   <#  0 hold ascii ) hold  u#s  ascii ( hold  u#>   ( adr len )
1A0B800 	 8 76 A0  1 70 6F A0  1 
1A0B808 	DC 75 A0  1 58 41 A0  1 
1A0B810 	29  0  0  0 DC 75 A0  1 
1A0B818 	BC 76 A0  1 58 41 A0  1 
1A0B820 	28  0  0  0 DC 75 A0  1 
1A0B828 	E0 76 A0  1 
   fake-name-buf $save       ( adr len )
1A0B82C 	D4 B7 A0  1 
1A0B830 	68 7E A0  1 
   tuck + 1- tuck            ( anf len adr+len )
1A0B834 	E8 46 A0  1 
1A0B838 	 4 45 A0  1 54 4B A0  1 
1A0B840 	E8 46 A0  1 
   swap 1- h# 80 or swap c!  ( adr )
1A0B844 	68 49 A0  1 
1A0B848 	54 4B A0  1 58 41 A0  1 
1A0B850 	80  0  0  0 70 44 A0  1 
1A0B858 	68 49 A0  1 B8 4D A0  1 
   r> base !
1A0B860 	D0 45 A0  1 B8 75 A0  1 
1A0B868 	54 4D A0  1 
;
1A0B86C 	58 46 A0  1 

\ Returns the name field address, or if the word is headerless, the
\ address of a numeric string representing the xt in parentheses.
: >name-do  ( xt -- anf )
1A0B870 	 0  0  0 3E 6E 61 6D 65 
1A0B878 	2D 64 6F 88 EC B7 A0  1 
1A0B880 	20 40 A0  1 
   dup >name?  if  nip  else  drop fake-name  then
1A0B884 	40 49 A0  1 
1A0B888 	A0 AA A0  1 DC 41 A0  1 
1A0B890 	10  0  0  0 FC 46 A0  1 
1A0B898 	C8 41 A0  1  C  0  0  0 
1A0B8A0 	30 49 A0  1 EC B7 A0  1 
;
1A0B8A8 	58 46 A0  1 

' >name-do is >name

: immediate  (s -- )  last @  n>flags  dup c@  40 or  swap c!  ;
1A0B8AC 	 0  0 69 6D 
1A0B8B0 	6D 65 64 69 61 74 65 89 
1A0B8B8 	80 B8 A0  1 20 40 A0  1 
1A0B8C0 	 4 A4 A0  1 5C 4C A0  1 
1A0B8C8 	BC 73 A0  1 40 49 A0  1 
1A0B8D0 	C4 4C A0  1 58 41 A0  1 
1A0B8D8 	40  0  0  0 70 44 A0  1 
1A0B8E0 	68 49 A0  1 B8 4D A0  1 
1A0B8E8 	58 46 A0  1 
: immediate?  (s xt -- flag )  >flags c@  40 and  0<>  ;
1A0B8EC 	 0 69 6D 6D 
1A0B8F0 	65 64 69 61 74 65 3F 8A 
1A0B8F8 	BC B8 A0  1 20 40 A0  1 
1A0B900 	38 74 A0  1 C4 4C A0  1 
1A0B908 	58 41 A0  1 40  0  0  0 
1A0B910 	5C 44 A0  1 44 47 A0  1 
1A0B918 	58 46 A0  1 
: flagalias  (s -- )  last @  n>flags  dup c@  20 or  swap c!  ;
1A0B91C 	 0  0 66 6C 
1A0B920 	61 67 61 6C 69 61 73 89 
1A0B928 	FC B8 A0  1 20 40 A0  1 
1A0B930 	 4 A4 A0  1 5C 4C A0  1 
1A0B938 	BC 73 A0  1 40 49 A0  1 
1A0B940 	C4 4C A0  1 58 41 A0  1 
1A0B948 	20  0  0  0 70 44 A0  1 
1A0B950 	68 49 A0  1 B8 4D A0  1 
1A0B958 	58 46 A0  1 
: .last  (s -- )  last @ .id  ;
1A0B95C 	 0  0 2E 6C 
1A0B960 	61 73 74 85 2C B9 A0  1 
1A0B968 	20 40 A0  1  4 A4 A0  1 
1A0B970 	5C 4C A0  1 A8 9A A0  1 
1A0B978 	58 46 A0  1 


0 value canonical-word
1A0B97C 	 0 63 61 6E 
1A0B980 	6F 6E 69 63 61 6C 2D 77 
1A0B988 	6F 72 64 8E 68 B9 A0  1 
1A0B990 	50 40 A0  1 18  2  0  0 
headerless
: init  ( -- )
1A0B998 	 0  0  0 69 6E 69 74 84 
1A0B9A0 	90 B9 A0  1 20 40 A0  1 
   init
1A0B9A8 	64 AA A0  1 
   d# 20 alloc-mem  is fake-name-buf
1A0B9AC 	58 41 A0  1 
1A0B9B0 	14  0  0  0 F0 6C A0  1 
1A0B9B8 	B8 65 A0  1 D4 B7 A0  1 
   d# 32 alloc-mem  is canonical-word
1A0B9C0 	58 41 A0  1 20  0  0  0 
1A0B9C8 	F0 6C A0  1 B8 65 A0  1 
1A0B9D0 	90 B9 A0  1 
   d# 34 alloc-mem  is 'error-word
1A0B9D4 	58 41 A0  1 
1A0B9D8 	22  0  0  0 F0 6C A0  1 
1A0B9E0 	B8 65 A0  1 98 9F A0  1 
;
1A0B9E8 	58 46 A0  1 
headers

: $canonical  ( adr len -- adr' len' )
1A0B9EC 	 0 24 63 61 
1A0B9F0 	6E 6F 6E 69 63 61 6C 8A 
1A0B9F8 	A4 B9 A0  1 20 40 A0  1 
   caps @  if  d# 31 min  canonical-word $save  2dup lower  then
1A0BA00 	18 85 A0  1 5C 4C A0  1 
1A0BA08 	DC 41 A0  1 20  0  0  0 
1A0BA10 	58 41 A0  1 1F  0  0  0 
1A0BA18 	74 4A A0  1 90 B9 A0  1 
1A0BA20 	68 7E A0  1 C0 49 A0  1 
1A0BA28 	A4 85 A0  1 
;
1A0BA2C 	58 46 A0  1 


: find-fixup  ( adr len alf true  |  adr len false -- xt +-1  |  adr len 0 )
1A0BA30 	 0 66 69 6E 64 2D 66 69 
1A0BA38 	78 75 70 8A FC B9 A0  1 
1A0BA40 	20 40 A0  1 
   dup  if                                        ( adr len alf true )
1A0BA44 	40 49 A0  1 
1A0BA48 	DC 41 A0  1 74  0  0  0 
      drop nip nip                                ( alf )
1A0BA50 	30 49 A0  1 FC 46 A0  1 
1A0BA58 	FC 46 A0  1 
      dup link> swap l>name n>flags c@            ( xt flags )
1A0BA5C 	40 49 A0  1 
1A0BA60 	D0 73 A0  1 68 49 A0  1 
1A0BA68 	A4 73 A0  1 BC 73 A0  1 
1A0BA70 	C4 4C A0  1 
      dup  h# 20 and  if  swap token@ swap  then  ( xt' flags )  \ alias?
1A0BA74 	40 49 A0  1 
1A0BA78 	58 41 A0  1 20  0  0  0 
1A0BA80 	5C 44 A0  1 DC 41 A0  1 
1A0BA88 	10  0  0  0 68 49 A0  1 
1A0BA90 	 C 54 A0  1 68 49 A0  1 
      h# 40 and  if  1  else  -1  then                           \ immediate?
1A0BA98 	58 41 A0  1 40  0  0  0 
1A0BAA0 	5C 44 A0  1 DC 41 A0  1 
1A0BAA8 	10  0  0  0 80 6F A0  1 
1A0BAB0 	C8 41 A0  1  C  0  0  0 
1A0BAB8 	58 41 A0  1 FF FF FF FF 
   then
;
1A0BAC0 	58 46 A0  1 

: $find-word  ( adr len voc-acf -- adr len   false | xt +-1 )
1A0BAC4 	 0 24 66 69 
1A0BAC8 	6E 64 2D 77 6F 72 64 8A 
1A0BAD0 	40 BA A0  1 20 40 A0  1 
   >first  $find-next  find-fixup
1A0BAD8 	CC B5 A0  1 E8 B5 A0  1 
1A0BAE0 	40 BA A0  1 
;
1A0BAE4 	58 46 A0  1 


: (search-wordlist)  ( adr len vocabulary -- false | xt +-1 )
1A0BAE8 	 0  0 28 73 65 61 72 63 
1A0BAF0 	68 2D 77 6F 72 64 6C 69 
1A0BAF8 	73 74 29 91 D4 BA A0  1 
1A0BB00 	20 40 A0  1 
   $find-word  dup  0=  if  nip nip  then
1A0BB04 	D4 BA A0  1 
1A0BB08 	40 49 A0  1 24 47 A0  1 
1A0BB10 	DC 41 A0  1  C  0  0  0 
1A0BB18 	FC 46 A0  1 FC 46 A0  1 
;
1A0BB20 	58 46 A0  1 
: search-wordlist  ( adr len vocabulary -- false | xt +-1 )
1A0BB24 	73 65 61 72 
1A0BB28 	63 68 2D 77 6F 72 64 6C 
1A0BB30 	69 73 74 8F  0 BB A0  1 
1A0BB38 	20 40 A0  1 
   >r $canonical r> (search-wordlist)
1A0BB3C 	BC 45 A0  1 
1A0BB40 	FC B9 A0  1 D0 45 A0  1 
1A0BB48 	 0 BB A0  1 
;
1A0BB4C 	58 46 A0  1 

: $vfind  ( adr len vocabulary -- adr len false | xt +-1 )
1A0BB50 	 0 24 76 66 69 6E 64 86 
1A0BB58 	38 BB A0  1 20 40 A0  1 
   >r $canonical r> $find-word
1A0BB60 	BC 45 A0  1 FC B9 A0  1 
1A0BB68 	D0 45 A0  1 D4 BA A0  1 
;
1A0BB70 	58 46 A0  1 

: $create-word  ( adr len voc-xt -- )
1A0BB74 	 0  0  0 24 
1A0BB78 	63 72 65 61 74 65 2D 77 
1A0BB80 	6F 72 64 8C 5C BB A0  1 
1A0BB88 	20 40 A0  1 
   >r $canonical r>
1A0BB8C 	BC 45 A0  1 
1A0BB90 	FC B9 A0  1 D0 45 A0  1 
   warning @  if
1A0BB98 	E4 9A A0  1 5C 4C A0  1 
1A0BBA0 	DC 41 A0  1 4C  0  0  0 
      3dup  $find-word  if   ( adr len voc-xt  xt )
1A0BBA8 	A4 52 A0  1 D4 BA A0  1 
1A0BBB0 	DC 41 A0  1 38  0  0  0 
         drop
1A0BBB8 	30 49 A0  1 
	 >r 2dup type r> ."  isn't unique " cr
1A0BBBC 	BC 45 A0  1 
1A0BBC0 	C0 49 A0  1  4 6C A0  1 
1A0BBC8 	D0 45 A0  1 20 7C A0  1 
1A0BBD0 	 E 20 69 73 6E 27 74 20 
1A0BBD8 	75 6E 69 71 75 65 20  0 
1A0BBE0 	80 6D A0  1 
      else                   ( adr len voc-xt  adr len )
1A0BBE4 	C8 41 A0  1 
1A0BBE8 	 8  0  0  0 
         2drop
1A0BBEC 	AC 49 A0  1 
      then
   then                      ( adr len voc-xt )
   $make-header
1A0BBF0 	F8 B4 A0  1 
;
1A0BBF4 	58 46 A0  1 

: ($header)  (s adr len -- )  current-voc $create-word  ;
1A0BBF8 	 0  0 28 24 68 65 61 64 
1A0BC00 	65 72 29 89 88 BB A0  1 
1A0BC08 	20 40 A0  1 34 A4 A0  1 
1A0BC10 	88 BB A0  1 58 46 A0  1 

' ($header) is $header

headerless
2 /n-t * ualloc-t user tbuf
1A0BC18 	 0  0  0 74 62 75 66 84 
1A0BC20 	 8 BC A0  1 48 40 A0  1 
1A0BC28 	1C  2  0  0 
headers
: follow  ( voc-acf -- )  tbuf token!  0 tbuf na1+ !  ;
1A0BC2C 	 0 66 6F 6C 
1A0BC30 	6C 6F 77 86 24 BC A0  1 
1A0BC38 	20 40 A0  1 24 BC A0  1 
1A0BC40 	20 54 A0  1 70 6F A0  1 
1A0BC48 	24 BC A0  1 CC 50 A0  1 
1A0BC50 	54 4D A0  1 58 46 A0  1 

: another?  ( -- false  |  anf true )
1A0BC58 	 0  0  0 61 6E 6F 74 68 
1A0BC60 	65 72 3F 88 38 BC A0  1 
1A0BC68 	20 40 A0  1 
   tbuf na1+ @  tbuf token@  next-word  ( 0 | alf true )
1A0BC6C 	24 BC A0  1 
1A0BC70 	CC 50 A0  1 5C 4C A0  1 
1A0BC78 	24 BC A0  1  C 54 A0  1 
1A0BC80 	 0 B6 A0  1 
   if  dup tbuf na1+ !  l>name  true  else  false  then
1A0BC84 	DC 41 A0  1 
1A0BC88 	24  0  0  0 40 49 A0  1 
1A0BC90 	24 BC A0  1 CC 50 A0  1 
1A0BC98 	54 4D A0  1 A4 73 A0  1 
1A0BCA0 	 4 70 A0  1 C8 41 A0  1 
1A0BCA8 	 8  0  0  0 18 70 A0  1 
;
1A0BCB0 	58 46 A0  1 

\ Forget

headerless
: trim   (s alf voc-acf -- )
1A0BCB4 	 0  0  0 74 
1A0BCB8 	72 69 6D 84 68 BC A0  1 
1A0BCC0 	20 40 A0  1 
   >r 0                                       ( adr 0 )
1A0BCC4 	BC 45 A0  1 
1A0BCC8 	70 6F A0  1 
   begin  r@ next-word   while                ( adr alf )
1A0BCCC 	E4 45 A0  1 
1A0BCD0 	 0 B6 A0  1 DC 41 A0  1 
1A0BCD8 	28  0  0  0 
      2dup <=  if  dup r@ remove-word  then   ( adr alf )
1A0BCDC 	C0 49 A0  1 
1A0BCE0 	 C 49 A0  1 DC 41 A0  1 
1A0BCE8 	10  0  0  0 40 49 A0  1 
1A0BCF0 	E4 45 A0  1 54 A4 A0  1 
   repeat                                     ( adr )
1A0BCF8 	C8 41 A0  1 D0 FF FF FF 
   r> 2drop
1A0BD00 	D0 45 A0  1 AC 49 A0  1 
;
1A0BD08 	58 46 A0  1 

\ From order.fth

\ Search order.  Maintains the list of vocabularies which are
\ searched while interpreting Forth code.

#vocs /token * constant /context
1A0BD0C 	 0  0  0 2F 
1A0BD10 	63 6F 6E 74 65 78 74 88 
1A0BD18 	C0 BC A0  1 68 40 A0  1 
1A0BD20 	80  0  0  0 
: context-bounds  ( -- end start )  context /context bounds  ;
1A0BD24 	 0 63 6F 6E 
1A0BD28 	74 65 78 74 2D 62 6F 75 
1A0BD30 	6E 64 73 8E 1C BD A0  1 
1A0BD38 	20 40 A0  1 DC A3 A0  1 
1A0BD40 	1C BD A0  1 F0 6D A0  1 
1A0BD48 	58 46 A0  1 

headerless
: shuffle-down  ( adr -- finished? )
1A0BD4C 	 0  0  0 73 
1A0BD50 	68 75 66 66 6C 65 2D 64 
1A0BD58 	6F 77 6E 8C 38 BD A0  1 
1A0BD60 	20 40 A0  1 
   \ The loop goes from the next location after adr to the end of the
   \ context array.
   context-bounds drop  over /token +  ?do    ( adr )
1A0BD64 	38 BD A0  1 
1A0BD68 	30 49 A0  1 54 49 A0  1 
1A0BD70 	B4 46 A0  1  4 45 A0  1 
1A0BD78 	50 42 A0  1 34  0  0  0 
       \ Look for a non-null entry, replace the current entry with that one,
       \ and replace that one with null
       i get-token?  if                       ( adr acf )
1A0BD80 	B4 42 A0  1 6C 59 A0  1 
1A0BD88 	DC 41 A0  1 18  0  0  0 
          over token!   i !null-token  leave  ( adr )
1A0BD90 	54 49 A0  1 20 54 A0  1 
1A0BD98 	B4 42 A0  1 10 59 A0  1 
1A0BDA0 	18 43 A0  1 
       then                                   ( adr )
   /token +loop
1A0BDA4 	B4 46 A0  1 
1A0BDA8 	1C 42 A0  1 D4 FF FF FF 
   drop
1A0BDB0 	30 49 A0  1 
;
1A0BDB4 	58 46 A0  1 
headers
: clear-context  ( -- )
1A0BDB8 	 0  0 63 6C 65 61 72 2D 
1A0BDC0 	63 6F 6E 74 65 78 74 8D 
1A0BDC8 	60 BD A0  1 20 40 A0  1 
   context-bounds  ?do  i !null-token  /token +loop
1A0BDD0 	38 BD A0  1 50 42 A0  1 
1A0BDD8 	18  0  0  0 B4 42 A0  1 
1A0BDE0 	10 59 A0  1 B4 46 A0  1 
1A0BDE8 	1C 42 A0  1 F0 FF FF FF 
;
1A0BDF0 	58 46 A0  1 
headerless
: compact-search-order  ( -- )
1A0BDF4 	 0  0  0 63 
1A0BDF8 	6F 6D 70 61 63 74 2D 73 
1A0BE00 	65 61 72 63 68 2D 6F 72 
1A0BE08 	64 65 72 94 CC BD A0  1 
1A0BE10 	20 40 A0  1 
   context-bounds  ?do
1A0BE14 	38 BD A0  1 
1A0BE18 	50 42 A0  1 38  0  0  0 
      i get-token? 0=  if   i shuffle-down  else  drop  then
1A0BE20 	B4 42 A0  1 6C 59 A0  1 
1A0BE28 	24 47 A0  1 DC 41 A0  1 
1A0BE30 	14  0  0  0 B4 42 A0  1 
1A0BE38 	60 BD A0  1 C8 41 A0  1 
1A0BE40 	 8  0  0  0 30 49 A0  1 
   /token +loop
1A0BE48 	B4 46 A0  1 1C 42 A0  1 
1A0BE50 	D0 FF FF FF 
;
1A0BE54 	58 46 A0  1 
headers
: (except  ( voc-acf -- )   \ Remove a vocabulary from the search order
1A0BE58 	28 65 78 63 65 70 74 87 
1A0BE60 	10 BE A0  1 20 40 A0  1 
   context-bounds  ?do
1A0BE68 	38 BD A0  1 50 42 A0  1 
1A0BE70 	30  0  0  0 
      dup  i token@  =  if  i  !null-token  then
1A0BE74 	40 49 A0  1 
1A0BE78 	B4 42 A0  1  C 54 A0  1 
1A0BE80 	24 48 A0  1 DC 41 A0  1 
1A0BE88 	 C  0  0  0 B4 42 A0  1 
1A0BE90 	10 59 A0  1 
   /token +loop
1A0BE94 	B4 46 A0  1 
1A0BE98 	1C 42 A0  1 D8 FF FF FF 
   drop compact-search-order
1A0BEA0 	30 49 A0  1 10 BE A0  1 
;
1A0BEA8 	58 46 A0  1 

auser fence        \ barrier for forgetting
1A0BEAC 	 0  0 66 65 
1A0BEB0 	6E 63 65 85 64 BE A0  1 
1A0BEB8 	48 40 A0  1 24  2  0  0 

: (forget)   (s adr -- )	\ reclaim dictionary space above "adr"
1A0BEC0 	 0  0  0 28 66 6F 72 67 
1A0BEC8 	65 74 29 88 B8 BE A0  1 
1A0BED0 	20 40 A0  1 

   dup fence a@ u< ( -15 ) abort" below fence"  ( adr )
1A0BED4 	40 49 A0  1 
1A0BED8 	B8 BE A0  1 88 58 A0  1 
1A0BEE0 	A8 48 A0  1  8 81 A0  1 
1A0BEE8 	 B 62 65 6C 6F 77 20 66 
1A0BEF0 	65 6E 63 65  0  0  0  0 

   \ Forget any entire vocabularies defined after "adr"

   voc-link                          ( adr first-voc )
1A0BEF8 	74 B6 A0  1 
   begin                             ( adr voc )
      \ XXX this may not work with a mixed RAM/ROM system where
      \ RAM is at a lower address than ROM
      a@ 2dup  u<                 ( adr voc' more? )
1A0BEFC 	88 58 A0  1 
1A0BF00 	C0 49 A0  1 A8 48 A0  1 
   while                             ( adr voc )
1A0BF08 	DC 41 A0  1 58  0  0  0 
      dup voc> current-voc =         ( adr voc error? )
1A0BF10 	40 49 A0  1 38 B6 A0  1 
1A0BF18 	34 A4 A0  1 24 48 A0  1 
      ( -15 ) abort" I can't forget the current vocabulary."
1A0BF20 	 8 81 A0  1 26 49 20 63 
1A0BF28 	61 6E 27 74 20 66 6F 72 
1A0BF30 	67 65 74 20 74 68 65 20 
1A0BF38 	63 75 72 72 65 6E 74 20 
1A0BF40 	76 6F 63 61 62 75 6C 61 
1A0BF48 	72 79 2E  0 
      \ Remove the voc from the search order
      dup voc> (except               ( adr voc )
1A0BF4C 	40 49 A0  1 
1A0BF50 	38 B6 A0  1 64 BE A0  1 
      >voc-link                      ( adr voc-link )
1A0BF58 	50 B6 A0  1 
   repeat                            ( adr voc )
1A0BF5C 	C8 41 A0  1 
1A0BF60 	9C FF FF FF 
   dup voc-link a!                ( adr voc )
1A0BF64 	40 49 A0  1 
1A0BF68 	74 B6 A0  1 98 58 A0  1 

   \ For all remaining vocabularies, unlink words defined after "adr"

   \ We assume that we haven't forgotten all the vocabularies;
   \ otherwise this will fail.  Forgetting all the vocabularies would
   \ crash the system anyway, so we don't worry about it.
   begin                             ( adr voc )
      2dup voc> trim                 ( adr voc )
1A0BF70 	C0 49 A0  1 38 B6 A0  1 
1A0BF78 	C0 BC A0  1 
      >voc-link                      ( adr voc-link-adr )
1A0BF7C 	50 B6 A0  1 
      another-link? 0=               ( adr voc' )
1A0BF80 	90 59 A0  1 24 47 A0  1 
   until                             ( adr )
1A0BF88 	DC 41 A0  1 E4 FF FF FF 
   l>beginning  here - allot     \ Reclaim dictionary space
1A0BF90 	90 74 A0  1 70 54 A0  1 
1A0BF98 	18 45 A0  1 E4 54 A0  1 
;
1A0BFA0 	58 46 A0  1 

: forget   (s -- )
1A0BFA4 	 0 66 6F 72 
1A0BFA8 	67 65 74 86 D0 BE A0  1 
1A0BFB0 	20 40 A0  1 
   safe-parse-word   current-voc $vfind  $?missing  drop
1A0BFB4 	88 93 A0  1 
1A0BFB8 	34 A4 A0  1 5C BB A0  1 
1A0BFC0 	84 94 A0  1 30 49 A0  1 
   >link  (forget)
1A0BFC8 	EC 73 A0  1 D0 BE A0  1 
;
1A0BFD0 	58 46 A0  1 

: marker  ( "name" -- )
1A0BFD4 	 0 6D 61 72 
1A0BFD8 	6B 65 72 86 B0 BF A0  1 
1A0BFE0 	20 40 A0  1 
   create  #user @ ,
1A0BFE4 	A8 A2 A0  1 
1A0BFE8 	7C 66 A0  1 5C 4C A0  1 
1A0BFF0 	98 55 A0  1 
   does> dup @  #user !  body> >link  (forget)
1A0BFF4 	50 A3 A0  1 
1A0BFF8 	90 90 90 E8 7C 80 FF FF 
1A0C000 	40 49 A0  1 5C 4C A0  1 
1A0C008 	7C 66 A0  1 54 4D A0  1 
1A0C010 	C8 59 A0  1 EC 73 A0  1 
1A0C018 	D0 BE A0  1 
;
1A0C01C 	58 46 A0  1 
headerless
: init ( -- )  init  ['] ($find-next) is $find-next  ;
1A0C020 	 0  0  0 69 6E 69 74 84 
1A0C028 	E0 BF A0  1 20 40 A0  1 
1A0C030 	A4 B9 A0  1 60 53 A0  1 
1A0C038 	74 60 A0  1 B8 65 A0  1 
1A0C040 	E8 B5 A0  1 58 46 A0  1 
headers


nuser prior        \ used for dictionary searches
1A0C048 	 0  0 70 72 69 6F 72 85 
1A0C050 	2C C0 A0  1 48 40 A0  1 
1A0C058 	28  2  0  0 
: $find-do   (s adr len -- xt +-1 | adr len 0 )
1A0C05C 	 0  0  0 24 
1A0C060 	66 69 6E 64 2D 64 6F 88 
1A0C068 	54 C0 A0  1 20 40 A0  1 
   2dup 2>r
1A0C070 	C0 49 A0  1 F8 45 A0  1 
   $canonical        ( adr' len' )
1A0C078 	FC B9 A0  1 
   prior off         ( adr len )
1A0C07C 	54 C0 A0  1 
1A0C080 	F8 4B A0  1 
   false             ( adr len found? )
1A0C084 	18 70 A0  1 
   context-bounds  ?do
1A0C088 	38 BD A0  1 50 42 A0  1 
1A0C090 	70  0  0  0 
      drop
1A0C094 	30 49 A0  1 
      i get-token?  if                    ( adr len voc )
1A0C098 	B4 42 A0  1 6C 59 A0  1 
1A0C0A0 	DC 41 A0  1 4C  0  0  0 

         \ Don't search the vocabulary again if we just searched it.
         dup prior @ over prior !  =  if  ( adr len voc )
1A0C0A8 	40 49 A0  1 54 C0 A0  1 
1A0C0B0 	5C 4C A0  1 54 49 A0  1 
1A0C0B8 	54 C0 A0  1 54 4D A0  1 
1A0C0C0 	24 48 A0  1 DC 41 A0  1 
1A0C0C8 	14  0  0  0 
            drop false                    ( adr len false )
1A0C0CC 	30 49 A0  1 
1A0C0D0 	18 70 A0  1 
         else                             ( adr len voc )
1A0C0D4 	C8 41 A0  1 
1A0C0D8 	10  0  0  0 
	    $find-word  dup ?leave        ( adr len false )
1A0C0DC 	D4 BA A0  1 
1A0C0E0 	40 49 A0  1 34 43 A0  1 
         then                             ( adr len false )

      else                                ( adr len voc )
1A0C0E8 	C8 41 A0  1  8  0  0  0 
         false                            ( adr len false )
1A0C0F0 	18 70 A0  1 
      then                                ( adr len false )
   /token +loop                           ( adr len false  |  xt +-1 )
1A0C0F4 	B4 46 A0  1 
1A0C0F8 	1C 42 A0  1 98 FF FF FF 
   ?dup  if
1A0C100 	B4 70 A0  1 DC 41 A0  1 
1A0C108 	14  0  0  0 
      2r> 2drop
1A0C10C 	10 46 A0  1 
1A0C110 	AC 49 A0  1 
   else
1A0C114 	C8 41 A0  1 
1A0C118 	10  0  0  0 
      2drop  2r> false
1A0C11C 	AC 49 A0  1 
1A0C120 	10 46 A0  1 18 70 A0  1 
   then
;
1A0C128 	58 46 A0  1 
' $find-do is $find
: find  ( pstr -- pstr false  |  xt +-1 )
1A0C12C 	 0  0  0 66 
1A0C130 	69 6E 64 84 6C C0 A0  1 
1A0C138 	20 40 A0  1 
   dup >r count $find  dup  0=  if  nip nip  r> swap  else  r> drop  then
1A0C13C 	40 49 A0  1 
1A0C140 	BC 45 A0  1 BC 53 A0  1 
1A0C148 	C4 93 A0  1 40 49 A0  1 
1A0C150 	24 47 A0  1 DC 41 A0  1 
1A0C158 	1C  0  0  0 FC 46 A0  1 
1A0C160 	FC 46 A0  1 D0 45 A0  1 
1A0C168 	68 49 A0  1 C8 41 A0  1 
1A0C170 	 C  0  0  0 D0 45 A0  1 
1A0C178 	30 49 A0  1 
;
1A0C17C 	58 46 A0  1 

\ The also/only vocabulary search order scheme

decimal
: >voc  ( n -- adr )  /token *  context +  ;
1A0C180 	 0  0  0 3E 76 6F 63 84 
1A0C188 	38 C1 A0  1 20 40 A0  1 
1A0C190 	B4 46 A0  1 1C 5F A0  1 
1A0C198 	DC A3 A0  1  4 45 A0  1 
1A0C1A0 	58 46 A0  1 

vocabulary root   root definitions
1A0C1A4 	 0  0  0 72 
1A0C1A8 	6F 6F 74 84 8C C1 A0  1 
1A0C1B0 	E0 B6 A0  1 2C  2  0  0 
1A0C1B8 	 0  0 A0  1 

: also  (s -- )  context  1 >voc   #vocs 2- /token *  cmove>  ;
1A0C1BC 	 0  0  0 61 
1A0C1C0 	6C 73 6F 84  0  0 A0  1 
1A0C1C8 	20 40 A0  1 DC A3 A0  1 
1A0C1D0 	80 6F A0  1 8C C1 A0  1 
1A0C1D8 	C8 A3 A0  1 64 4B A0  1 
1A0C1E0 	B4 46 A0  1 1C 5F A0  1 
1A0C1E8 	34 44 A0  1 58 46 A0  1 

: (min-search)  root also  ;
1A0C1F0 	 0  0  0 28 6D 69 6E 2D 
1A0C1F8 	73 65 61 72 63 68 29 8C 
1A0C200 	C8 C1 A0  1 20 40 A0  1 
1A0C208 	B0 C1 A0  1 C8 C1 A0  1 
1A0C210 	58 46 A0  1 
defer minimum-search-order  ' (min-search) is minimum-search-order
1A0C214 	 0  0  0 6D 
1A0C218 	69 6E 69 6D 75 6D 2D 73 
1A0C220 	65 61 72 63 68 2D 6F 72 
1A0C228 	64 65 72 94  4 C2 A0  1 
1A0C230 	5C 40 A0  1 30  2  0  0 
: forth-wordlist  ( -- wid )  ['] forth  ;
1A0C238 	 0 66 6F 72 74 68 2D 77 
1A0C240 	6F 72 64 6C 69 73 74 8E 
1A0C248 	30 C2 A0  1 20 40 A0  1 
1A0C250 	60 53 A0  1  4 FF  9  8 
1A0C258 	58 46 A0  1 
: get-current  ( -- )  current token@  ;
1A0C25C 	67 65 74 2D 
1A0C260 	63 75 72 72 65 6E 74 8B 
1A0C268 	4C C2 A0  1 20 40 A0  1 
1A0C270 	F0 A3 A0  1  C 54 A0  1 
1A0C278 	58 46 A0  1 
: set-current  ( -- )  current token!  ;
1A0C27C 	73 65 74 2D 
1A0C280 	63 75 72 72 65 6E 74 8B 
1A0C288 	6C C2 A0  1 20 40 A0  1 
1A0C290 	F0 A3 A0  1 20 54 A0  1 
1A0C298 	58 46 A0  1 

: get-order  ( -- vocn .. voc1 n )
1A0C29C 	 0  0 67 65 
1A0C2A0 	74 2D 6F 72 64 65 72 89 
1A0C2A8 	8C C2 A0  1 20 40 A0  1 
   0  0  #vocs 1-  do
1A0C2B0 	70 6F A0  1 70 6F A0  1 
1A0C2B8 	C8 A3 A0  1 54 4B A0  1 
1A0C2C0 	88 42 A0  1 34  0  0  0 
      i >voc token@ non-null?  if  swap 1+  then
1A0C2C8 	B4 42 A0  1 8C C1 A0  1 
1A0C2D0 	 C 54 A0  1 34 59 A0  1 
1A0C2D8 	DC 41 A0  1  C  0  0  0 
1A0C2E0 	68 49 A0  1 30 4B A0  1 
   -1 +loop
1A0C2E8 	58 41 A0  1 FF FF FF FF 
1A0C2F0 	1C 42 A0  1 D4 FF FF FF 
;
1A0C2F8 	58 46 A0  1 
: set-order  ( vocn .. voc1 n -- )
1A0C2FC 	 0  0 73 65 
1A0C300 	74 2D 6F 72 64 65 72 89 
1A0C308 	AC C2 A0  1 20 40 A0  1 
   dup #vocs >  abort" Too many vocabularies in requested search order"
1A0C310 	40 49 A0  1 C8 A3 A0  1 
1A0C318 	 4 48 A0  1  8 81 A0  1 
1A0C320 	2F 54 6F 6F 20 6D 61 6E 
1A0C328 	79 20 76 6F 63 61 62 75 
1A0C330 	6C 61 72 69 65 73 20 69 
1A0C338 	6E 20 72 65 71 75 65 73 
1A0C340 	74 65 64 20 73 65 61 72 
1A0C348 	63 68 20 6F 72 64 65 72 
1A0C350 	 0  0  0  0 
   clear-context
1A0C354 	CC BD A0  1 
   0  ?do  i >voc token!  loop
1A0C358 	70 6F A0  1 50 42 A0  1 
1A0C360 	18  0  0  0 B4 42 A0  1 
1A0C368 	8C C1 A0  1 20 54 A0  1 
1A0C370 	F8 41 A0  1 F0 FF FF FF 
;
1A0C378 	58 46 A0  1 

: only  (s -- )
1A0C37C 	 0  0  0 6F 
1A0C380 	6E 6C 79 84  C C3 A0  1 
1A0C388 	20 40 A0  1 
   clear-context
1A0C38C 	CC BD A0  1 
\   ['] root  #vocs 1- >voc  token!
   minimum-search-order
1A0C390 	30 C2 A0  1 
;
1A0C394 	58 46 A0  1 

: except  \ vocabulary-name  ( -- )
1A0C398 	 0 65 78 63 65 70 74 86 
1A0C3A0 	88 C3 A0  1 20 40 A0  1 
   ' (except
1A0C3A8 	F8 95 A0  1 64 BE A0  1 
;
1A0C3B0 	58 46 A0  1 
: seal  (s -- )  ['] root (except  ;
1A0C3B4 	 0  0  0 73 
1A0C3B8 	65 61 6C 84 A4 C3 A0  1 
1A0C3C0 	20 40 A0  1 60 53 A0  1 
1A0C3C8 	B0 C1 A0  1 64 BE A0  1 
1A0C3D0 	58 46 A0  1 
: previous   (s -- )
1A0C3D4 	 0  0  0 70 
1A0C3D8 	72 65 76 69 6F 75 73 88 
1A0C3E0 	C0 C3 A0  1 20 40 A0  1 
   1 >voc  context  #vocs 2- /token *  cmove
1A0C3E8 	80 6F A0  1 8C C1 A0  1 
1A0C3F0 	DC A3 A0  1 C8 A3 A0  1 
1A0C3F8 	64 4B A0  1 B4 46 A0  1 
1A0C400 	1C 5F A0  1 10 44 A0  1 
   #vocs 2- >voc  !null-token
1A0C408 	C8 A3 A0  1 64 4B A0  1 
1A0C410 	8C C1 A0  1 10 59 A0  1 
;
1A0C418 	58 46 A0  1 

: definitions  ( -- )  context token@ set-current  ;
1A0C41C 	64 65 66 69 
1A0C420 	6E 69 74 69 6F 6E 73 8B 
1A0C428 	E4 C3 A0  1 20 40 A0  1 
1A0C430 	DC A3 A0  1  C 54 A0  1 
1A0C438 	8C C2 A0  1 58 46 A0  1 

: order   (s -- )
1A0C440 	 0  0 6F 72 64 65 72 85 
1A0C448 	2C C4 A0  1 20 40 A0  1 
   ." context: "
1A0C450 	20 7C A0  1  9 63 6F 6E 
1A0C458 	74 65 78 74 3A 20  0  0 
   get-order  0  ?do  .name  loop
1A0C460 	AC C2 A0  1 70 6F A0  1 
1A0C468 	50 42 A0  1 10  0  0  0 
1A0C470 	C8 9A A0  1 F8 41 A0  1 
1A0C478 	F8 FF FF FF 
   4 spaces  ." current: "  get-current .name
1A0C47C 	B0 6F A0  1 
1A0C480 	E8 71 A0  1 20 7C A0  1 
1A0C488 	 9 63 75 72 72 65 6E 74 
1A0C490 	3A 20  0  0 6C C2 A0  1 
1A0C498 	C8 9A A0  1 
;
1A0C49C 	58 46 A0  1 
: vocs   (s -- )
1A0C4A0 	 0  0  0 76 6F 63 73 84 
1A0C4A8 	4C C4 A0  1 20 40 A0  1 
   voc-link  begin  another-link?  while  ( link )
1A0C4B0 	74 B6 A0  1 90 59 A0  1 
1A0C4B8 	DC 41 A0  1 3C  0  0  0 
      #out @ 64 >  if  cr  then
1A0C4C0 	5C 6D A0  1 5C 4C A0  1 
1A0C4C8 	58 41 A0  1 40  0  0  0 
1A0C4D0 	 4 48 A0  1 DC 41 A0  1 
1A0C4D8 	 8  0  0  0 80 6D A0  1 
      dup  voc>  .name
1A0C4E0 	40 49 A0  1 38 B6 A0  1 
1A0C4E8 	C8 9A A0  1 
      >voc-link
1A0C4EC 	50 B6 A0  1 
   repeat
1A0C4F0 	C8 41 A0  1 C0 FF FF FF 
;
1A0C4F8 	58 46 A0  1 

forthusadr fw-pa userarea-t + - #user-t !

vocabulary forth forth definitions
1A0C4FC 	 0  0 66 6F 
1A0C500 	72 74 68 85 AC C4 A0  1 
1A0C508 	E0 B6 A0  1 60  2  0  0 
1A0C510 	B0 C1 A0  1 



\ only forth also definitions
\ : (cold-hook   ( -- )   (cold-hook  only forth also definitions  ;
\ headers

headerless
also root
: init  ( -- )  init  only forth also definitions  ;
1A0C514 	 0  0  0 69 
1A0C518 	6E 69 74 84 B0 C1 A0  1 
1A0C520 	20 40 A0  1 2C C0 A0  1 
1A0C528 	88 C3 A0  1  8 C5 A0  1 
1A0C530 	C8 C1 A0  1 2C C4 A0  1 
1A0C538 	58 46 A0  1 
[p]
headers


variable isvar
1A0C53C 	 0  0 69 73 
1A0C540 	76 61 72 85 20 C5 A0  1 
1A0C548 	48 40 A0  1 64  2  0  0 
0 value isval
1A0C550 	 0  0 69 73 76 61 6C 85 
1A0C558 	48 C5 A0  1 50 40 A0  1 
1A0C560 	68  2  0  0 

headerless

[ifdef] run-time
: is-error  ( data acf -- )  true ( -32 ) abort" inappropriate use of `is'"  ;
[else]
: is-error  ( data acf -- )  ." Can't use is with " .name cr ( -32 ) abort  ;
1A0C564 	 0  0  0 69 
1A0C568 	73 2D 65 72 72 6F 72 88 
1A0C570 	5C C5 A0  1 20 40 A0  1 
1A0C578 	20 7C A0  1 12 43 61 6E 
1A0C580 	27 74 20 75 73 65 20 69 
1A0C588 	73 20 77 69 74 68 20  0 
1A0C590 	C8 9A A0  1 80 6D A0  1 
1A0C598 	28 91 A0  1 58 46 A0  1 
[then]

headers

defer to-hook
1A0C5A0 	74 6F 2D 68 6F 6F 6B 87 
1A0C5A8 	74 C5 A0  1 5C 40 A0  1 
1A0C5B0 	6C  2  0  0 
' is-error is to-hook

headerless

: >bu  ( acf -- data-adr )  >body >user  ;
1A0C5B4 	3E 62 75 83 
1A0C5B8 	AC C5 A0  1 20 40 A0  1 
1A0C5C0 	E4 59 A0  1 C8 74 A0  1 
1A0C5C8 	58 46 A0  1 

create word-types
1A0C5CC 	 0 77 6F 72 
1A0C5D0 	64 2D 74 79 70 65 73 8A 
1A0C5D8 	BC C5 A0  1 30 40 A0  1 
   ' key    token,-t	\ defer
1A0C5E0 	50 6C A0  1 
   ' #user  token,-t	\ user variable
1A0C5E4 	7C 66 A0  1 
   ' isval  token,-t	\ value
1A0C5E8 	5C C5 A0  1 
   ' bl     token,-t	\ constant
1A0C5EC 	28 70 A0  1 
   ' isvar  token,-t	\ variable
1A0C5F0 	48 C5 A0  1 
   origin   token,-t	\ END   \ origin should be null
1A0C5F4 	 0  0 A0  1 

create data-locs
1A0C5F8 	 0  0 64 61 74 61 2D 6C 
1A0C600 	6F 63 73 89 DC C5 A0  1 
1A0C608 	30 40 A0  1 
   ' >bu    token,-t	\ defer
1A0C60C 	BC C5 A0  1 
   ' >bu    token,-t	\ user variable
1A0C610 	BC C5 A0  1 
   ' >bu    token,-t	\ value
1A0C614 	BC C5 A0  1 
   ' >body  token,-t	\ constant
1A0C618 	E4 59 A0  1 
   ' >body  token,-t	\ variable
1A0C61C 	E4 59 A0  1 

create !ops
1A0C620 	 0  0  0 21 6F 70 73 84 
1A0C628 	 8 C6 A0  1 30 40 A0  1 
   ' token! token,-t	\ defer
1A0C630 	20 54 A0  1 
   ' !      token,-t	\ user variable
1A0C634 	54 4D A0  1 
   ' !      token,-t	\ value
1A0C638 	54 4D A0  1 
   ' !      token,-t	\ constant
1A0C63C 	54 4D A0  1 
   ' !      token,-t	\ variable
1A0C640 	54 4D A0  1 

create is-ops
1A0C644 	 0 69 73 2D 
1A0C648 	6F 70 73 86 2C C6 A0  1 
1A0C650 	30 40 A0  1 
   ' isdefer    token,-t	\ defer
1A0C654 	98 40 A0  1 
   ' isuser     token,-t	\ user variable
1A0C658 	D8 40 A0  1 
   ' isvalue    token,-t	\ value
1A0C65C 	B8 40 A0  1 
   ' isconstant token,-t	\ constant
1A0C660 	FC 40 A0  1 
   ' isvariable token,-t	\ variable
1A0C664 	1C 41 A0  1 

: associate  ( acf -- true  |  index false )
1A0C668 	 0  0 61 73 73 6F 63 69 
1A0C670 	61 74 65 89 50 C6 A0  1 
1A0C678 	20 40 A0  1 
   word-type  ( n )
1A0C67C 	B0 59 A0  1 
   word-types  begin              ( n adr )
1A0C680 	DC C5 A0  1 
      2dup get-token?             ( n adr n  false | acf true )
1A0C684 	C0 49 A0  1 
1A0C688 	6C 59 A0  1 
   while                          ( n adr n acf )
1A0C68C 	DC 41 A0  1 
1A0C690 	3C  0  0  0 
      word-type  = if             ( n adr )
1A0C694 	B0 59 A0  1 
1A0C698 	24 48 A0  1 DC 41 A0  1 
1A0C6A0 	20  0  0  0 
         word-types -  /token /   ( n index )
1A0C6A4 	DC C5 A0  1 
1A0C6A8 	18 45 A0  1 B4 46 A0  1 
1A0C6B0 	98 5F A0  1 
	 nip false  exit          ( index false )
1A0C6B4 	FC 46 A0  1 
1A0C6B8 	18 70 A0  1 40 46 A0  1 
      then                        ( n adr )
      ta1+                        ( n adr' )
1A0C6C0 	FC 50 A0  1 
   repeat                         ( n adr n )
1A0C6C4 	C8 41 A0  1 
1A0C6C8 	BC FF FF FF 
   3drop true                     ( true )
1A0C6CC 	90 52 A0  1 
1A0C6D0 	 4 70 A0  1 
;
1A0C6D4 	58 46 A0  1 

: +execute  ( index table -- )
1A0C6D8 	 0  0  0 2B 65 78 65 63 
1A0C6E0 	75 74 65 88 78 C6 A0  1 
1A0C6E8 	20 40 A0  1 
   swap ta+ token@ execute        ( )
1A0C6EC 	68 49 A0  1 
1A0C6F0 	60 50 A0  1  C 54 A0  1 
1A0C6F8 	98 41 A0  1 
;
1A0C6FC 	58 46 A0  1 

headers
: behavior  ( defer-acf -- acf2 )  >bu token@  ;
1A0C700 	 0  0  0 62 65 68 61 76 
1A0C708 	69 6F 72 88 E8 C6 A0  1 
1A0C710 	20 40 A0  1 BC C5 A0  1 
1A0C718 	 C 54 A0  1 58 46 A0  1 


: (is-do
1A0C720 	 0 28 69 73 2D 64 6F 86 
1A0C728 	10 C7 A0  1 20 40 A0  1 
   dup  associate  if  is-error  then   ( data acf index )
1A0C730 	40 49 A0  1 78 C6 A0  1 
1A0C738 	DC 41 A0  1  8  0  0  0 
1A0C740 	74 C5 A0  1 
   tuck data-locs +execute              ( data index data-adr )
1A0C744 	E8 46 A0  1 
1A0C748 	 8 C6 A0  1 E8 C6 A0  1 
   swap !ops +execute                   ( )
1A0C750 	68 49 A0  1 2C C6 A0  1 
1A0C758 	E8 C6 A0  1 
;
1A0C75C 	58 46 A0  1 
' (is-do is (is

: >data  ( acf -- data-adr )
1A0C760 	 0  0 3E 64 61 74 61 85 
1A0C768 	2C C7 A0  1 20 40 A0  1 
   dup associate  if        ( acf )
1A0C770 	40 49 A0  1 78 C6 A0  1 
1A0C778 	DC 41 A0  1 10  0  0  0 
      >body                 ( data-adr )
1A0C780 	E4 59 A0  1 
   else                     ( acf index )
1A0C784 	C8 41 A0  1 
1A0C788 	 C  0  0  0 
      data-locs +execute    ( data-adr )
1A0C78C 	 8 C6 A0  1 
1A0C790 	E8 C6 A0  1 
   then                     ( data-adr )
;
1A0C794 	58 46 A0  1 

\ (is) is a run-time word that is compiled into definitions


: ([)  (s -- )
1A0C798 	28 5B 29 83 6C C7 A0  1 
1A0C7A0 	20 40 A0  1 
  ['] interpret-do-defined    ['] do-defined    (is
1A0C7A4 	60 53 A0  1 
1A0C7A8 	3C 9F A0  1 60 53 A0  1 
1A0C7B0 	E0 9D A0  1 A4 65 A0  1 
  ['] $interpret-do-undefined ['] $do-undefined (is
1A0C7B8 	60 53 A0  1 BC 9F A0  1 
1A0C7C0 	60 53 A0  1 FC 9D A0  1 
1A0C7C8 	A4 65 A0  1 
  state off
1A0C7CC 	38 54 A0  1 
1A0C7D0 	F8 4B A0  1 
;
1A0C7D4 	58 46 A0  1 
' ([) is [

: (])  (s -- )
1A0C7D8 	28 5D 29 83 A0 C7 A0  1 
1A0C7E0 	20 40 A0  1 
  ['] compile-do-defined     ['] do-defined    (is
1A0C7E4 	60 53 A0  1 
1A0C7E8 	64 9F A0  1 60 53 A0  1 
1A0C7F0 	E0 9D A0  1 A4 65 A0  1 
  ['] $compile-do-undefined  ['] $do-undefined (is
1A0C7F8 	60 53 A0  1  8 A0 A0  1 
1A0C800 	60 53 A0  1 FC 9D A0  1 
1A0C808 	A4 65 A0  1 
  state on
1A0C80C 	38 54 A0  1 
1A0C810 	E0 4B A0  1 
;
1A0C814 	58 46 A0  1 
' (]) is ]

[ifndef] run-time

: do-is  ( data acf -- )
1A0C818 	 0  0 64 6F 2D 69 73 85 
1A0C820 	E0 C7 A0  1 20 40 A0  1 
   dup associate  if              ( [data] acf )
1A0C828 	40 49 A0  1 78 C6 A0  1 
1A0C830 	DC 41 A0  1 10  0  0  0 
      to-hook
1A0C838 	AC C5 A0  1 
   else                           ( [data] acf index )
1A0C83C 	C8 41 A0  1 
1A0C840 	4C  0  0  0 
      state @  if                 ( acf index )
1A0C844 	38 54 A0  1 
1A0C848 	5C 4C A0  1 DC 41 A0  1 
1A0C850 	24  0  0  0 
         is-ops swap ta+ token@   ( acf is-token )
1A0C854 	50 C6 A0  1 
1A0C858 	68 49 A0  1 60 50 A0  1 
1A0C860 	 C 54 A0  1 
         token, token,            ( )
1A0C864 	2C 55 A0  1 
1A0C868 	2C 55 A0  1 
      else                        ( data acf index )
1A0C86C 	C8 41 A0  1 
1A0C870 	1C  0  0  0 
         tuck data-locs +execute  ( data index data-adr )
1A0C874 	E8 46 A0  1 
1A0C878 	 8 C6 A0  1 E8 C6 A0  1 
         swap !ops +execute       ( )
1A0C880 	68 49 A0  1 2C C6 A0  1 
1A0C888 	E8 C6 A0  1 
      then                        ( )
   then                           ( )
;
1A0C88C 	58 46 A0  1 
\ is is the word that is actually used by applications
: is  \ name  ( data -- )
1A0C890 	 0 69 73 C2 24 C8 A0  1 
1A0C898 	20 40 A0  1 
   ' do-is
1A0C89C 	F8 95 A0  1 
1A0C8A0 	24 C8 A0  1 
; immediate
1A0C8A4 	58 46 A0  1 
\ only forth also definitions

[then]

\ A place to put the last word returned by blword
0 value 'word
1A0C8A8 	 0  0 27 77 6F 72 64 85 
1A0C8B0 	98 C8 A0  1 50 40 A0  1 
1A0C8B8 	70  2  0  0 

[ifndef] omit-files
\ From filecomm.fth

decimal

\ buffered i/o  constants
-1 constant eof
1A0C8BC 	65 6F 66 83 
1A0C8C0 	B4 C8 A0  1 68 40 A0  1 
1A0C8C8 	FF FF FF FF 

nuser delimiter  \ delimiter actually found at end of word
1A0C8CC 	 0  0 64 65 
1A0C8D0 	6C 69 6D 69 74 65 72 89 
1A0C8D8 	C4 C8 A0  1 48 40 A0  1 
1A0C8E0 	74  2  0  0 

/n round-up
headers
20 /n-t * d# 68 +  constant /fd
1A0C8E4 	2F 66 64 83 
1A0C8E8 	DC C8 A0  1 68 40 A0  1 
1A0C8F0 	94  0  0  0 

: set-name  ( adr len -- )
1A0C8F4 	 0  0  0 73 
1A0C8F8 	65 74 2D 6E 61 6D 65 88 
1A0C900 	EC C8 A0  1 20 40 A0  1 
   \ If the name is too long, cut off initial characters (because the
   \ latter ones are more likely to be interesting), and replace the
   \ first character with "?".
   dup d# 64 -  0 max  dup >r  /string  (file-name) place
1A0C908 	40 49 A0  1 58 41 A0  1 
1A0C910 	40  0  0  0 18 45 A0  1 
1A0C918 	70 6F A0  1 9C 4A A0  1 
1A0C920 	40 49 A0  1 BC 45 A0  1 
1A0C928 	3C 85 A0  1 60 AE A0  1 
1A0C930 	F0 88 A0  1 
   r>  if  ascii ? (file-name) 1+ c!  then
1A0C934 	D0 45 A0  1 
1A0C938 	DC 41 A0  1 18  0  0  0 
1A0C940 	58 41 A0  1 3F  0  0  0 
1A0C948 	60 AE A0  1 30 4B A0  1 
1A0C950 	B8 4D A0  1 
;
1A0C954 	58 46 A0  1 

: setupfd  ( fid fmode sizeop alignop closeop seekop writeop readop -- )
1A0C958 	73 65 74 75 70 66 64 87 
1A0C960 	 4 C9 A0  1 20 40 A0  1 
   readop !  writeop !  seekop !  closeop !  alignop !  sizeop !
1A0C968 	 8 AD A0  1 54 4D A0  1 
1A0C970 	30 AD A0  1 54 4D A0  1 
1A0C978 	E0 AC A0  1 54 4D A0  1 
1A0C980 	58 AD A0  1 54 4D A0  1 
1A0C988 	80 AD A0  1 54 4D A0  1 
1A0C990 	A8 AD A0  1 54 4D A0  1 
   fmode !  fid !  0 (file-line) !  0 0 set-name
1A0C998 	74 AC A0  1 54 4D A0  1 
1A0C9A0 	B8 AC A0  1 54 4D A0  1 
1A0C9A8 	70 6F A0  1 D4 AD A0  1 
1A0C9B0 	54 4D A0  1 70 6F A0  1 
1A0C9B8 	70 6F A0  1  4 C9 A0  1 
;
1A0C9C0 	58 46 A0  1 

headerless
\ values for mode field
-1  constant not-open
1A0C9C4 	 0  0  0 6E 
1A0C9C8 	6F 74 2D 6F 70 65 6E 88 
1A0C9D0 	64 C9 A0  1 68 40 A0  1 
1A0C9D8 	FF FF FF FF 
headers
 0  constant read
1A0C9DC 	 0  0  0 72 
1A0C9E0 	65 61 64 84 D4 C9 A0  1 
1A0C9E8 	68 40 A0  1  0  0  0  0 
 1  constant write
1A0C9F0 	 0  0 77 72 69 74 65 85 
1A0C9F8 	E8 C9 A0  1 68 40 A0  1 
1A0CA00 	 1  0  0  0 
 2  constant modify
1A0CA04 	 0 6D 6F 64 
1A0CA08 	69 66 79 86 FC C9 A0  1 
1A0CA10 	68 40 A0  1  2  0  0  0 
headerless
modify constant read-write  ( for old programs )
1A0CA18 	 0 72 65 61 64 2D 77 72 
1A0CA20 	69 74 65 8A 10 CA A0  1 
1A0CA28 	68 40 A0  1  2  0  0  0 

\ Stub routines for readop and writeop
headers
\ These return 0 for the number of bytes actually transferred.
: nullwrite  ( adr count fd -- 0 )  3drop 0  ;
1A0CA30 	 0  0 6E 75 6C 6C 77 72 
1A0CA38 	69 74 65 89 28 CA A0  1 
1A0CA40 	20 40 A0  1 90 52 A0  1 
1A0CA48 	70 6F A0  1 58 46 A0  1 
: fakewrite  ( adr count fd -- count )  drop nip  ;
1A0CA50 	 0  0 66 61 6B 65 77 72 
1A0CA58 	69 74 65 89 40 CA A0  1 
1A0CA60 	20 40 A0  1 30 49 A0  1 
1A0CA68 	FC 46 A0  1 58 46 A0  1 
: nullalign  ( d.position fd -- d.position' )  drop  ;
1A0CA70 	 0  0 6E 75 6C 6C 61 6C 
1A0CA78 	69 67 6E 89 60 CA A0  1 
1A0CA80 	20 40 A0  1 30 49 A0  1 
1A0CA88 	58 46 A0  1 
: nullread  ( adr count fd -- 0 )  3drop 0  ;
1A0CA8C 	 0  0  0 6E 
1A0CA90 	75 6C 6C 72 65 61 64 88 
1A0CA98 	80 CA A0  1 20 40 A0  1 
1A0CAA0 	90 52 A0  1 70 6F A0  1 
1A0CAA8 	58 46 A0  1 
: nullseek  ( d.byte# fd -- )  3drop  ;
1A0CAAC 	 0  0  0 6E 
1A0CAB0 	75 6C 6C 73 65 65 6B 88 
1A0CAB8 	9C CA A0  1 20 40 A0  1 
1A0CAC0 	90 52 A0  1 58 46 A0  1 
headerless
\ This one pretends to have transferred the requested number of bytes
: fakeread  ( adr count fd -- count )  drop nip  ;
1A0CAC8 	 0  0  0 66 61 6B 65 72 
1A0CAD0 	65 61 64 88 BC CA A0  1 
1A0CAD8 	20 40 A0  1 30 49 A0  1 
1A0CAE0 	FC 46 A0  1 58 46 A0  1 

headers
\ Initializes the current descriptor to use the buffer "bufstart,buflen"
: initbuf  ( bufstart buflen -- )
1A0CAE8 	69 6E 69 74 62 75 66 87 
1A0CAF0 	D8 CA A0  1 20 40 A0  1 
   0 0 fstart 2!   over + bflimit !  ( bufstart )
1A0CAF8 	70 6F A0  1 70 6F A0  1 
1A0CB00 	98 AC A0  1 E4 4D A0  1 
1A0CB08 	54 49 A0  1  4 45 A0  1 
1A0CB10 	BC AB A0  1 54 4D A0  1 
   dup bfbase ! dup bfcurrent ! dup bfend !  bftop !
1A0CB18 	40 49 A0  1 98 AB A0  1 
1A0CB20 	54 4D A0  1 40 49 A0  1 
1A0CB28 	2C AC A0  1 54 4D A0  1 
1A0CB30 	40 49 A0  1  4 AC A0  1 
1A0CB38 	54 4D A0  1 E0 AB A0  1 
1A0CB40 	54 4D A0  1 
   bfdirty off
1A0CB44 	50 AC A0  1 
1A0CB48 	F8 4B A0  1 
;
1A0CB4C 	58 46 A0  1 

\ "unallocate" a file descriptor
: release-fd  ( fd -- )  file @ >r  file !  not-open fmode !  r> file !  ;
1A0CB50 	 0 72 65 6C 65 61 73 65 
1A0CB58 	2D 66 64 8A F4 CA A0  1 
1A0CB60 	20 40 A0  1 84 AB A0  1 
1A0CB68 	5C 4C A0  1 BC 45 A0  1 
1A0CB70 	84 AB A0  1 54 4D A0  1 
1A0CB78 	D4 C9 A0  1 74 AC A0  1 
1A0CB80 	54 4D A0  1 D0 45 A0  1 
1A0CB88 	84 AB A0  1 54 4D A0  1 
1A0CB90 	58 46 A0  1 
headerless

\ An implementation factor which returns true if the file descriptor fd
\ is not currently in use
: fdavail?  ( fd -- f )  file @ >r  file !  fmode @ not-open =  r> file !  ;
1A0CB94 	 0  0  0 66 
1A0CB98 	64 61 76 61 69 6C 3F 88 
1A0CBA0 	60 CB A0  1 20 40 A0  1 
1A0CBA8 	84 AB A0  1 5C 4C A0  1 
1A0CBB0 	BC 45 A0  1 84 AB A0  1 
1A0CBB8 	54 4D A0  1 74 AC A0  1 
1A0CBC0 	5C 4C A0  1 D4 C9 A0  1 
1A0CBC8 	24 48 A0  1 D0 45 A0  1 
1A0CBD0 	84 AB A0  1 54 4D A0  1 
1A0CBD8 	58 46 A0  1 

\ These are the words that a program uses to read and write to/from a file.



\ Buffer boundaries are transparent
\ end-of-file conditions work correctly
\ The actual delimiter encountered is stored in delimiter.

headers
\ input-file contains the file descriptor which defines the input stream.
nuser input-file
1A0CBDC 	 0 69 6E 70 
1A0CBE0 	75 74 2D 66 69 6C 65 8A 
1A0CBE8 	A4 CB A0  1 48 40 A0  1 
1A0CBF0 	78  2  0  0 

headerless

\ ?fillbuf is called by the string scanning routines after skipbl, scanbl,
\ skipto, or scanto has returned.  ?fillbuf determines whether or not
\ the end of a buffer has been reached.  If so, the buffer is refilled and
\ end? is set to false so that the skip/scan routine will be called again,
\ (unless the end of the file is reached).

: ?fillbuf  ( endaddr [ adr ]  delimiter -- endaddr' addr' end? )
1A0CBF4 	 0  0  0 3F 
1A0CBF8 	66 69 6C 6C 62 75 66 88 
1A0CC00 	EC CB A0  1 20 40 A0  1 
    dup delimiter !  eof =  if ( endaddr )
1A0CC08 	40 49 A0  1 DC C8 A0  1 
1A0CC10 	54 4D A0  1 C4 C8 A0  1 
1A0CC18 	24 48 A0  1 DC 41 A0  1 
1A0CC20 	28  0  0  0 
       shortseek
1A0CC24 	C0 B0 A0  1 
       bftop @  bfcurrent @    ( endaddr'  addr' )
1A0CC28 	E0 AB A0  1 5C 4C A0  1 
1A0CC30 	2C AC A0  1 5C 4C A0  1 
       2dup u<=                ( endaddr'  addr' end-of-file? )
1A0CC38 	C0 49 A0  1 88 48 A0  1 
    else                       ( endaddr addr )
1A0CC40 	C8 41 A0  1  8  0  0  0 
       true            \ True so we'll exit the loop
1A0CC48 	 4 70 A0  1 
    then
;
1A0CC4C 	58 46 A0  1 

headers
\ Closes the file.
: fclose  ( fd -- )
1A0CC50 	 0 66 63 6C 6F 73 65 86 
1A0CC58 	 4 CC A0  1 20 40 A0  1 
   file @ >r  file !
1A0CC60 	84 AB A0  1 5C 4C A0  1 
1A0CC68 	BC 45 A0  1 84 AB A0  1 
1A0CC70 	54 4D A0  1 
   file @  fdavail?  0=  if
1A0CC74 	84 AB A0  1 
1A0CC78 	5C 4C A0  1 A4 CB A0  1 
1A0CC80 	24 47 A0  1 DC 41 A0  1 
1A0CC88 	28  0  0  0 
      ?flushbuf  fid @ closeop @ execute
1A0CC8C 	EC AE A0  1 
1A0CC90 	B8 AC A0  1 5C 4C A0  1 
1A0CC98 	58 AD A0  1 5C 4C A0  1 
1A0CCA0 	98 41 A0  1 
      file @  release-fd
1A0CCA4 	84 AB A0  1 
1A0CCA8 	5C 4C A0  1 60 CB A0  1 
   then
   r> file !
1A0CCB0 	D0 45 A0  1 84 AB A0  1 
1A0CCB8 	54 4D A0  1 
;
1A0CCBC 	58 46 A0  1 
: close-file  ( fd -- ior )  fclose 0  ;
1A0CCC0 	 0 63 6C 6F 73 65 2D 66 
1A0CCC8 	69 6C 65 8A 5C CC A0  1 
1A0CCD0 	20 40 A0  1 5C CC A0  1 
1A0CCD8 	70 6F A0  1 58 46 A0  1 

headerless
\ File descriptor allocation


32         constant #fds
1A0CCE0 	 0  0  0 23 66 64 73 84 
1A0CCE8 	D0 CC A0  1 68 40 A0  1 
1A0CCF0 	20  0  0  0 
#fds /fd * constant /fds
1A0CCF4 	 0  0  0 2F 
1A0CCF8 	66 64 73 84 EC CC A0  1 
1A0CD00 	68 40 A0  1 80 12  0  0 

nuser fds
1A0CD08 	66 64 73 83  0 CD A0  1 
1A0CD10 	48 40 A0  1 7C  2  0  0 

headerless
\ Initialize pool of file descriptors
: init  ( -- )
1A0CD18 	 0  0  0 69 6E 69 74 84 
1A0CD20 	10 CD A0  1 20 40 A0  1 
   init
1A0CD28 	20 C5 A0  1 
   /stringbuf alloc-mem is 'word
1A0CD2C 	DC 7C A0  1 
1A0CD30 	F0 6C A0  1 B8 65 A0  1 
1A0CD38 	B4 C8 A0  1 
   /fds alloc-mem  ( base-address )  fds !
1A0CD3C 	 0 CD A0  1 
1A0CD40 	F0 6C A0  1 10 CD A0  1 
1A0CD48 	54 4D A0  1 
   fds @  /fds   bounds   do   i release-fd   /fd +loop
1A0CD4C 	10 CD A0  1 
1A0CD50 	5C 4C A0  1  0 CD A0  1 
1A0CD58 	F0 6D A0  1 88 42 A0  1 
1A0CD60 	18  0  0  0 B4 42 A0  1 
1A0CD68 	60 CB A0  1 EC C8 A0  1 
1A0CD70 	1C 42 A0  1 F0 FF FF FF 
;
1A0CD78 	58 46 A0  1 

headers
\ Allocates a file descriptor if possible
: (get-fd  ( -- fd | 0 )
1A0CD7C 	28 67 65 74 
1A0CD80 	2D 66 64 87 24 CD A0  1 
1A0CD88 	20 40 A0  1 
   0
1A0CD8C 	70 6F A0  1 
   fds @  /fds  bounds  ?do               ( 0 )
1A0CD90 	10 CD A0  1 5C 4C A0  1 
1A0CD98 	 0 CD A0  1 F0 6D A0  1 
1A0CDA0 	50 42 A0  1 2C  0  0  0 
      i fdavail?  if  drop i leave  then  ( 0 )
1A0CDA8 	B4 42 A0  1 A4 CB A0  1 
1A0CDB0 	DC 41 A0  1 10  0  0  0 
1A0CDB8 	30 49 A0  1 B4 42 A0  1 
1A0CDC0 	18 43 A0  1 
   /fd +loop                              ( fd | 0 )
1A0CDC4 	EC C8 A0  1 
1A0CDC8 	1C 42 A0  1 DC FF FF FF 
;
1A0CDD0 	58 46 A0  1 

: string-sizeop  ( fhandle -- d.length )  drop  bflimit @  bfbase @ -  0  ;
1A0CDD4 	 0  0 73 74 
1A0CDD8 	72 69 6E 67 2D 73 69 7A 
1A0CDE0 	65 6F 70 8D 88 CD A0  1 
1A0CDE8 	20 40 A0  1 30 49 A0  1 
1A0CDF0 	BC AB A0  1 5C 4C A0  1 
1A0CDF8 	98 AB A0  1 5C 4C A0  1 
1A0CE00 	18 45 A0  1 70 6F A0  1 
1A0CE08 	58 46 A0  1 
: hold$  ( adr len -- )
1A0CE0C 	 0  0 68 6F 
1A0CE10 	6C 64 24 85 E8 CD A0  1 
1A0CE18 	20 40 A0  1 
   dup  if
1A0CE1C 	40 49 A0  1 
1A0CE20 	DC 41 A0  1 3C  0  0  0 
      1- bounds swap  do  i c@ hold  -1 +loop
1A0CE28 	54 4B A0  1 F0 6D A0  1 
1A0CE30 	68 49 A0  1 88 42 A0  1 
1A0CE38 	20  0  0  0 B4 42 A0  1 
1A0CE40 	C4 4C A0  1 DC 75 A0  1 
1A0CE48 	58 41 A0  1 FF FF FF FF 
1A0CE50 	1C 42 A0  1 E8 FF FF FF 
   else
1A0CE58 	C8 41 A0  1  8  0  0  0 
      2drop
1A0CE60 	AC 49 A0  1 
   then
;
1A0CE64 	58 46 A0  1 

: init-delims   ( -- )
1A0CE68 	69 6E 69 74 2D 64 65 6C 
1A0CE70 	69 6D 73 8B 18 CE A0  1 
1A0CE78 	20 40 A0  1 
   \ initialize the delimiters to the default values for the
   \ underlying operating system, in case the file is initially empty.
   newline-string  case
1A0CE7C 	8C 71 A0  1 
      1 of  c@         0        endof
1A0CE80 	80 6F A0  1 48 43 A0  1 
1A0CE88 	14  0  0  0 C4 4C A0  1 
1A0CE90 	70 6F A0  1 6C 43 A0  1 
1A0CE98 	3C  0  0  0 
      2 of  dup 1+ c@  swap c@  endof
1A0CE9C 	90 6F A0  1 
1A0CEA0 	48 43 A0  1 20  0  0  0 
1A0CEA8 	40 49 A0  1 30 4B A0  1 
1A0CEB0 	C4 4C A0  1 68 49 A0  1 
1A0CEB8 	C4 4C A0  1 6C 43 A0  1 
1A0CEC0 	14  0  0  0 
      ( default )  linefeed carret rot
1A0CEC4 	4C 6F A0  1 
1A0CEC8 	60 6F A0  1 7C 49 A0  1 
   endcase   pre-delimiter c!  line-delimiter c!
1A0CED0 	84 43 A0  1 34 AE A0  1 
1A0CED8 	B8 4D A0  1  4 AE A0  1 
1A0CEE0 	B8 4D A0  1 
;
1A0CEE4 	58 46 A0  1 

[then]

headerless
\ A version that knows about multi-segment dictionaries can be installed
\ if such dictionaries exist.
: (in-dictionary?  ( adr -- )  origin here between  ;
1A0CEE8 	28 69 6E 2D 64 69 63 74 
1A0CEF0 	69 6F 6E 61 72 79 3F 8F 
1A0CEF8 	78 CE A0  1 20 40 A0  1 
1A0CF00 	50 55 A0  1 70 54 A0  1 
1A0CF08 	D8 70 A0  1 58 46 A0  1 
headers
defer in-dictionary? ' (in-dictionary? is in-dictionary?
1A0CF10 	 0 69 6E 2D 64 69 63 74 
1A0CF18 	69 6F 6E 61 72 79 3F 8E 
1A0CF20 	FC CE A0  1 5C 40 A0  1 
1A0CF28 	80  2  0  0 

defer .error#
1A0CF2C 	2E 65 72 72 
1A0CF30 	6F 72 23 87 24 CF A0  1 
1A0CF38 	5C 40 A0  1 84  2  0  0 

: .abort  ( -- )
1A0CF40 	 0 2E 61 62 6F 72 74 86 
1A0CF48 	38 CF A0  1 20 40 A0  1 
   show-error
1A0CF50 	F8 7F A0  1 
   drop abort-message type
1A0CF54 	30 49 A0  1 
1A0CF58 	BC 80 A0  1  4 6C A0  1 
;
1A0CF60 	58 46 A0  1 


defer .error
1A0CF64 	 0 2E 65 72 
1A0CF68 	72 6F 72 86 4C CF A0  1 
1A0CF70 	5C 40 A0  1 88  2  0  0 
: (.error)  ( error# -- )
1A0CF78 	 0  0  0 28 2E 65 72 72 
1A0CF80 	6F 72 29 88 70 CF A0  1 
1A0CF88 	20 40 A0  1 
   dup  -13  =  if
1A0CF8C 	40 49 A0  1 
1A0CF90 	58 41 A0  1 F3 FF FF FF 
1A0CF98 	24 48 A0  1 DC 41 A0  1 
1A0CFA0 	1C  0  0  0 
      .abort  ."  ?"  cr
1A0CFA4 	4C CF A0  1 
1A0CFA8 	20 7C A0  1  2 20 3F  0 
1A0CFB0 	80 6D A0  1 
   else  dup  -2 =  if
1A0CFB4 	C8 41 A0  1 
1A0CFB8 	7C  0  0  0 40 49 A0  1 
1A0CFC0 	58 41 A0  1 FE FF FF FF 
1A0CFC8 	24 48 A0  1 DC 41 A0  1 
1A0CFD0 	14  0  0  0 
      .abort  cr
1A0CFD4 	4C CF A0  1 
1A0CFD8 	80 6D A0  1 
   else  dup -1 =  if
1A0CFDC 	C8 41 A0  1 
1A0CFE0 	54  0  0  0 40 49 A0  1 
1A0CFE8 	58 41 A0  1 FF FF FF FF 
1A0CFF0 	24 48 A0  1 DC 41 A0  1 
1A0CFF8 	10  0  0  0 
      drop
1A0CFFC 	30 49 A0  1 
   else
1A0D000 	C8 41 A0  1 30  0  0  0 
      show-error
1A0D008 	F8 7F A0  1 
      dup in-dictionary?  if  count type  else  .error#  then cr
1A0D00C 	40 49 A0  1 
1A0D010 	24 CF A0  1 DC 41 A0  1 
1A0D018 	14  0  0  0 BC 53 A0  1 
1A0D020 	 4 6C A0  1 C8 41 A0  1 
1A0D028 	 8  0  0  0 38 CF A0  1 
1A0D030 	80 6D A0  1 
   then
   then
   then
;
1A0D034 	58 46 A0  1 
' (.error) is .error

: guarded  ( acf -- )  catch  ?dup  if  .error  then  ;
1A0D038 	67 75 61 72 64 65 64 87 
1A0D040 	88 CF A0  1 20 40 A0  1 
1A0D048 	14 7F A0  1 B4 70 A0  1 
1A0D050 	DC 41 A0  1  8  0  0  0 
1A0D058 	70 CF A0  1 58 46 A0  1 

\ From cold.fth

\ Some hooks for multitasking
\ Main task points to the initial task.  This usage is currently not ROM-able
\ since the user area address has to be later stored in the parameter field
\ of main-task.  It could be made ROM-able by allocating the user area
\ at a fixed location and storing that address in main-task at compile time.

' noop  is pause

defer init-io    ( -- )
1A0D060 	69 6E 69 74 2D 69 6F 87 
1A0D068 	44 D0 A0  1 5C 40 A0  1 
1A0D070 	8C  2  0  0 
defer do-init    ( -- )
1A0D074 	64 6F 2D 69 
1A0D078 	6E 69 74 87 6C D0 A0  1 
1A0D080 	5C 40 A0  1 90  2  0  0 
defer cold-hook  ( -- )
1A0D088 	 0  0 63 6F 6C 64 2D 68 
1A0D090 	6F 6F 6B 89 80 D0 A0  1 
1A0D098 	5C 40 A0  1 94  2  0  0 
defer init-environment  ( -- )
1A0D0A0 	 0  0  0 69 6E 69 74 2D 
1A0D0A8 	65 6E 76 69 72 6F 6E 6D 
1A0D0B0 	65 6E 74 90 98 D0 A0  1 
1A0D0B8 	5C 40 A0  1 98  2  0  0 

[ifndef] run-time
: (cold-hook  (s -- )
1A0D0C0 	 0 28 63 6F 6C 64 2D 68 
1A0D0C8 	6F 6F 6B 8A B8 D0 A0  1 
1A0D0D0 	20 40 A0  1 
   [compile] [
1A0D0D4 	90 6D A0  1 
;
1A0D0D8 	58 46 A0  1 

' (cold-hook  is cold-hook
[then]

defer title  ' noop is title
1A0D0DC 	 0  0 74 69 
1A0D0E0 	74 6C 65 85 D0 D0 A0  1 
1A0D0E8 	5C 40 A0  1 9C  2  0  0 
defer quit
1A0D0F0 	 0  0  0 71 75 69 74 84 
1A0D0F8 	E8 D0 A0  1 5C 40 A0  1 
1A0D100 	A0  2  0  0 
[ifndef] run-time
headerless
: single  (s -- )  \ Turns off multitasking
1A0D104 	 0 73 69 6E 
1A0D108 	67 6C 65 86 FC D0 A0  1 
1A0D110 	20 40 A0  1 
   ['] noop ['] pause (is
1A0D114 	60 53 A0  1 
1A0D118 	64 4F A0  1 60 53 A0  1 
1A0D120 	B4 6D A0  1 A4 65 A0  1 
;
1A0D128 	58 46 A0  1 
headers
: warm   (s -- )  single  sp0 @ sp!  quit  ;
1A0D12C 	 0  0  0 77 
1A0D130 	61 72 6D 84 10 D1 A0  1 
1A0D138 	20 40 A0  1 10 D1 A0  1 
1A0D140 	8C 66 A0  1 5C 4C A0  1 
1A0D148 	9C 45 A0  1 FC D0 A0  1 
1A0D150 	58 46 A0  1 
[then]

[ifdef] omit-files
: read-line  ( adr len fd -- actual not-eof? error? )  3drop 0 true  ;
: .file-open-error  ( -- )  ;
[else]
\ From disk.fth

\ High level interface to disk files.

headerless

\ If the underlying operating system requires that files be accessed
\ in fixed-length records, then /fbuf must be a multiple of that length.
\ Even if the system allows arbitrary length file accesses, there is probably
\ a length that is particularly efficient, and /fbuf should be a multiple
\ of that length for best performance.  1K works well for many systems.

td 1024 constant /fbuf
1A0D154 	 0  0 2F 66 
1A0D158 	62 75 66 85 38 D1 A0  1 
1A0D160 	68 40 A0  1  0  4  0  0 

headerless

\ An implementation factor which gets a file descriptor and attaches a
\ file buffer to it
headerless
: get-fd  ( -- )
1A0D168 	 0 67 65 74 2D 66 64 86 
1A0D170 	60 D1 A0  1 20 40 A0  1 
   (get-fd  dup 0= ( ?? ) abort" all fds used "  ( fd )
1A0D178 	88 CD A0  1 40 49 A0  1 
1A0D180 	24 47 A0  1  8 81 A0  1 
1A0D188 	 D 61 6C 6C 20 66 64 73 
1A0D190 	20 75 73 65 64 20  0  0 
   file !
1A0D198 	84 AB A0  1 54 4D A0  1 
   /fbuf alloc-mem  /fbuf initbuf     ( )
1A0D1A0 	60 D1 A0  1 F0 6C A0  1 
1A0D1A8 	60 D1 A0  1 F4 CA A0  1 
;
1A0D1B0 	58 46 A0  1 
headers
\ Amount of space needed:
\   #fds * /fd     for automatically allocated file descriptors
\   1 * /fd        for "accept" descriptor
\   tib            for "accept" buffer
\
\ #fds = 8, so total of 9 * /fd  = 9 * 56 = 486 for fds
\ 8 * 1024 +  3 * 128  +  tib
\ Total is ~9K

\ Updates the disk copy of the file to match the buffer
headerless
: fflush  ( fd -- )  file @ >r  file !  ?flushbuf  r> file !  ;
1A0D1B4 	 0 66 66 6C 
1A0D1B8 	75 73 68 86 74 D1 A0  1 
1A0D1C0 	20 40 A0  1 84 AB A0  1 
1A0D1C8 	5C 4C A0  1 BC 45 A0  1 
1A0D1D0 	84 AB A0  1 54 4D A0  1 
1A0D1D8 	EC AE A0  1 D0 45 A0  1 
1A0D1E0 	84 AB A0  1 54 4D A0  1 
1A0D1E8 	58 46 A0  1 
headers
\ Starting here, some stuff doesn't have to be in the kernel

\ Sets the position within the current file to "d.byte#".
: dfseek  ( d.byte# fd -- )
1A0D1EC 	 0 64 66 73 
1A0D1F0 	65 65 6B 86 C0 D1 A0  1 
1A0D1F8 	20 40 A0  1 
   file @ >r  file !
1A0D1FC 	84 AB A0  1 
1A0D200 	5C 4C A0  1 BC 45 A0  1 
1A0D208 	84 AB A0  1 54 4D A0  1 
   sync
1A0D210 	A8 AE A0  1 

   \ See if the desired byte is in the buffer
   \ The byte is in the buffer iff offset.high is 0 and offset.low
   \ is less than the number of bytes in the buffer
   2dup fstart 2@ d-                   ( d.byte# offset.low offset.high )
1A0D214 	C0 49 A0  1 
1A0D218 	98 AC A0  1 CC 4D A0  1 
1A0D220 	F8 5D A0  1 
   over bfend @ bfbase @ -  u>= or  if ( d.byte# offset )
1A0D224 	54 49 A0  1 
1A0D228 	 4 AC A0  1 5C 4C A0  1 
1A0D230 	98 AB A0  1 5C 4C A0  1 
1A0D238 	18 45 A0  1 CC 48 A0  1 
1A0D240 	70 44 A0  1 DC 41 A0  1 
1A0D248 	60  0  0  0 
      \ Not in buffer
      \ Flush the buffer and get the one containing the desired byte.
      drop ?flushbuf                         ( d.byte# )
1A0D24C 	30 49 A0  1 
1A0D250 	EC AE A0  1 
      2dup byte#-aligned?  if                ( d.byte# )
1A0D254 	C0 49 A0  1 
1A0D258 	88 B1 A0  1 DC 41 A0  1 
1A0D260 	34  0  0  0 
         \ If the new offset is on a block boundary, don't read yet,
         \ because the next op could be a large write that fills the buffer.
         fstart 2!                           ( )
1A0D264 	98 AC A0  1 
1A0D268 	E4 4D A0  1 
         bfbase @  dup bftop !  dup bfend !  ( bufaddr )
1A0D26C 	98 AB A0  1 
1A0D270 	5C 4C A0  1 40 49 A0  1 
1A0D278 	E0 AB A0  1 54 4D A0  1 
1A0D280 	40 49 A0  1  4 AC A0  1 
1A0D288 	54 4D A0  1 
      else
1A0D28C 	C8 41 A0  1 
1A0D290 	10  0  0  0 
         2dup fillbuf                        ( d.byte# )
1A0D294 	C0 49 A0  1 
1A0D298 	CC AF A0  1 
         >bufaddr                            ( bufaddr )
1A0D29C 	8C B0 A0  1 
      then                                   ( bufaddr )
   else
1A0D2A0 	C8 41 A0  1 18  0  0  0 
      \ The desired byte is already in the buffer.
      nip nip  bfbase @ +           ( bufaddr )
1A0D2A8 	FC 46 A0  1 FC 46 A0  1 
1A0D2B0 	98 AB A0  1 5C 4C A0  1 
1A0D2B8 	 4 45 A0  1 
   then

   \ Seeking past end of file actually goes to the end of the file
   bftop @  umin   bfcurrent !
1A0D2BC 	E0 AB A0  1 
1A0D2C0 	5C 4C A0  1 4C 4A A0  1 
1A0D2C8 	2C AC A0  1 54 4D A0  1 
   r> file !
1A0D2D0 	D0 45 A0  1 84 AB A0  1 
1A0D2D8 	54 4D A0  1 
;
1A0D2DC 	58 46 A0  1 
: fseek  ( byte# fd -- )  0 swap dfseek  ;
1A0D2E0 	 0  0 66 73 65 65 6B 85 
1A0D2E8 	F8 D1 A0  1 20 40 A0  1 
1A0D2F0 	70 6F A0  1 68 49 A0  1 
1A0D2F8 	F8 D1 A0  1 58 46 A0  1 

\ Returns true if the current file has reached the end.
\ XXX This may only be valid after fseek or shortseek
headerless
: (feof?  ( -- f )   bfcurrent @  bftop @  u>=  ;
1A0D300 	 0 28 66 65 6F 66 3F 86 
1A0D308 	EC D2 A0  1 20 40 A0  1 
1A0D310 	2C AC A0  1 5C 4C A0  1 
1A0D318 	E0 AB A0  1 5C 4C A0  1 
1A0D320 	CC 48 A0  1 58 46 A0  1 

headers
\ Gets the next byte from the current file
: fgetc  ( fd -- byte )
1A0D328 	 0  0 66 67 65 74 63 85 
1A0D330 	 C D3 A0  1 20 40 A0  1 
   file @ >r  file !   bfcurrent @  bftop @  u<
1A0D338 	84 AB A0  1 5C 4C A0  1 
1A0D340 	BC 45 A0  1 84 AB A0  1 
1A0D348 	54 4D A0  1 2C AC A0  1 
1A0D350 	5C 4C A0  1 E0 AB A0  1 
1A0D358 	5C 4C A0  1 A8 48 A0  1 
   if   \ desired character is in the buffer
1A0D360 	DC 41 A0  1 14  0  0  0 
      bfcurrent @c@++
1A0D368 	2C AC A0  1 E8 62 A0  1 
   else \ end of buffer has been reached
1A0D370 	C8 41 A0  1 30  0  0  0 
      bfcurrent @ shortseek
1A0D378 	2C AC A0  1 5C 4C A0  1 
1A0D380 	C0 B0 A0  1 
      (feof?  if  eof  else  bfcurrent @c@++  then
1A0D384 	 C D3 A0  1 
1A0D388 	DC 41 A0  1 10  0  0  0 
1A0D390 	C4 C8 A0  1 C8 41 A0  1 
1A0D398 	 C  0  0  0 2C AC A0  1 
1A0D3A0 	E8 62 A0  1 
   then
   r> file !
1A0D3A4 	D0 45 A0  1 
1A0D3A8 	84 AB A0  1 54 4D A0  1 
;
1A0D3B0 	58 46 A0  1 


\ Copyout copies bytes from the file buffer into memory starting at current.
\ The number of bytes copied is either enough to fill memory up to end,
\ if the buffer has enough characters, or all the bytes the
\ buffer has left, if not.
\ newcurrent is left pointing to the first byte not filled.
headerless
: copyout  ( end current -- end newcurrent )
1A0D3B4 	63 6F 70 79 
1A0D3B8 	6F 75 74 87 34 D3 A0  1 
1A0D3C0 	20 40 A0  1 
   2dup -                      ( end current remaining )
1A0D3C4 	C0 49 A0  1 
1A0D3C8 	18 45 A0  1 
   bftop @  bfcurrent @  -     ( end current remaining bfrem )
1A0D3CC 	E0 AB A0  1 
1A0D3D0 	5C 4C A0  1 2C AC A0  1 
1A0D3D8 	5C 4C A0  1 18 45 A0  1 
   min                         ( end current #bytes-to-copy)
1A0D3E0 	74 4A A0  1 
   2dup bfcurrent @ rot rot    ( end current #bytes  current bfcurrent #bytes)
1A0D3E4 	C0 49 A0  1 
1A0D3E8 	2C AC A0  1 5C 4C A0  1 
1A0D3F0 	7C 49 A0  1 7C 49 A0  1 
   move                        ( end current #bytes)
1A0D3F8 	F4 4A A0  1 
   dup  bfcurrent +!           ( end current #bytes)
1A0D3FC 	40 49 A0  1 
1A0D400 	2C AC A0  1  C 4C A0  1 
   +                           ( end newcurrent )
1A0D408 	 4 45 A0  1 
;
1A0D40C 	58 46 A0  1 

\ Reads up to count characters from the file into memory starting
\ at "adr"

: fgets  ( adr count fd -- #read )
1A0D410 	 0  0 66 67 65 74 73 85 
1A0D418 	C0 D3 A0  1 20 40 A0  1 
   file @ >r  file !
1A0D420 	84 AB A0  1 5C 4C A0  1 
1A0D428 	BC 45 A0  1 84 AB A0  1 
1A0D430 	54 4D A0  1 
   sync
1A0D434 	A8 AE A0  1 
   over + over  ( startaddr endaddr startaddr )
1A0D438 	54 49 A0  1  4 45 A0  1 
1A0D440 	54 49 A0  1 
   begin  copyout  2dup u>
1A0D444 	C0 D3 A0  1 
1A0D448 	C0 49 A0  1 64 48 A0  1 
   while
1A0D450 	DC 41 A0  1 40  0  0  0 
      \ Here there should be some code to see if there are enough remaining
      \ bytes in the request to justify bypassing the file buffer and reading
      \ directly to the user's buffer.  'Enough' = more than one file buffer
      bfcurrent @ shortseek ( startaddr endaddr curraddr )
1A0D458 	2C AC A0  1 5C 4C A0  1 
1A0D460 	C0 B0 A0  1 
      (feof?  if  nip swap -  r> file !  exit then
1A0D464 	 C D3 A0  1 
1A0D468 	DC 41 A0  1 20  0  0  0 
1A0D470 	FC 46 A0  1 68 49 A0  1 
1A0D478 	18 45 A0  1 D0 45 A0  1 
1A0D480 	84 AB A0  1 54 4D A0  1 
1A0D488 	40 46 A0  1 
   repeat
1A0D48C 	C8 41 A0  1 
1A0D490 	B4 FF FF FF 
   nip swap -
1A0D494 	FC 46 A0  1 
1A0D498 	68 49 A0  1 18 45 A0  1 
   r> file !
1A0D4A0 	D0 45 A0  1 84 AB A0  1 
1A0D4A8 	54 4D A0  1 
;
1A0D4AC 	58 46 A0  1 

\ Returns the current length of the file
: dfsize  ( fd -- d.size )
1A0D4B0 	 0 64 66 73 69 7A 65 86 
1A0D4B8 	1C D4 A0  1 20 40 A0  1 
   file @ >r  file !
1A0D4C0 	84 AB A0  1 5C 4C A0  1 
1A0D4C8 	BC 45 A0  1 84 AB A0  1 
1A0D4D0 	54 4D A0  1 
   sync
1A0D4D4 	A8 AE A0  1 
   fstart 2@  bftop @  bfbase @  -  0 d+  ( buffered-position )
1A0D4D8 	98 AC A0  1 CC 4D A0  1 
1A0D4E0 	E0 AB A0  1 5C 4C A0  1 
1A0D4E8 	98 AB A0  1 5C 4C A0  1 
1A0D4F0 	18 45 A0  1 70 6F A0  1 
1A0D4F8 	E0 5D A0  1 
   fid @  sizeop @  execute               ( buffered-position file-size )
1A0D4FC 	B8 AC A0  1 
1A0D500 	5C 4C A0  1 A8 AD A0  1 
1A0D508 	5C 4C A0  1 98 41 A0  1 
   dmax
1A0D510 	68 69 A0  1 
   r> file !
1A0D514 	D0 45 A0  1 
1A0D518 	84 AB A0  1 54 4D A0  1 
;
1A0D520 	58 46 A0  1 
: fsize  ( fd -- size )  dfsize drop  ;
1A0D524 	 0  0 66 73 
1A0D528 	69 7A 65 85 BC D4 A0  1 
1A0D530 	20 40 A0  1 BC D4 A0  1 
1A0D538 	30 49 A0  1 58 46 A0  1 


\ End of stuff that doesn't have to be in the kernel

defer do-fopen
1A0D540 	 0  0  0 64 6F 2D 66 6F 
1A0D548 	70 65 6E 88 30 D5 A0  1 
1A0D550 	5C 40 A0  1 A4  2  0  0 

\ Prepares a file for later access, returning "fd" which is subsequently
\ used to refer to the file.

: fopen  ( name mode -- fd )
1A0D558 	 0  0 66 6F 70 65 6E 85 
1A0D560 	50 D5 A0  1 20 40 A0  1 
   2 ?enough
1A0D568 	90 6F A0  1 48 8E A0  1 
   get-fd   ( name mode )  over >r  ( name mode )
1A0D570 	74 D1 A0  1 54 49 A0  1 
1A0D578 	BC 45 A0  1 
   dup fmode !          \ Make descriptor busy now, in case of re-entry
1A0D57C 	40 49 A0  1 
1A0D580 	74 AC A0  1 54 4D A0  1 
   do-fopen  if
1A0D588 	50 D5 A0  1 DC 41 A0  1 
1A0D590 	24  0  0  0 
      setupfd  file @  r> count set-name
1A0D594 	64 C9 A0  1 
1A0D598 	84 AB A0  1 5C 4C A0  1 
1A0D5A0 	D0 45 A0  1 BC 53 A0  1 
1A0D5A8 	 4 C9 A0  1 
   else
1A0D5AC 	C8 41 A0  1 
1A0D5B0 	1C  0  0  0 
      not-open fmode !  0  r> drop
1A0D5B4 	D4 C9 A0  1 
1A0D5B8 	74 AC A0  1 54 4D A0  1 
1A0D5C0 	70 6F A0  1 D0 45 A0  1 
1A0D5C8 	30 49 A0  1 
   then
;
1A0D5CC 	58 46 A0  1 

headers

\ Closes all the open files and reclaims their file descriptors.
\ Use this if you see an "all fds used" message.

: close-files ( -- )  fds @  /fds  bounds   do   i fclose   /fd +loop  ;
1A0D5D0 	63 6C 6F 73 65 2D 66 69 
1A0D5D8 	6C 65 73 8B 64 D5 A0  1 
1A0D5E0 	20 40 A0  1 10 CD A0  1 
1A0D5E8 	5C 4C A0  1  0 CD A0  1 
1A0D5F0 	F0 6D A0  1 88 42 A0  1 
1A0D5F8 	18  0  0  0 B4 42 A0  1 
1A0D600 	5C CC A0  1 EC C8 A0  1 
1A0D608 	1C 42 A0  1 F0 FF FF FF 
1A0D610 	58 46 A0  1 


\ From readline.fth

headers
0 constant r/o
1A0D614 	72 2F 6F 83 
1A0D618 	E0 D5 A0  1 68 40 A0  1 
1A0D620 	 0  0  0  0 
1 constant w/o
1A0D624 	77 2F 6F 83 
1A0D628 	1C D6 A0  1 68 40 A0  1 
1A0D630 	 1  0  0  0 
2 constant r/w
1A0D634 	72 2F 77 83 
1A0D638 	2C D6 A0  1 68 40 A0  1 
1A0D640 	 2  0  0  0 
4 constant bin
1A0D644 	62 69 6E 83 
1A0D648 	3C D6 A0  1 68 40 A0  1 
1A0D650 	 4  0  0  0 
8 constant create-flag
1A0D654 	63 72 65 61 
1A0D658 	74 65 2D 66 6C 61 67 8B 
1A0D660 	4C D6 A0  1 68 40 A0  1 
1A0D668 	 8  0  0  0 

headerless
2 /n-t * ualloc-t user opened-filename
1A0D66C 	6F 70 65 6E 
1A0D670 	65 64 2D 66 69 6C 65 6E 
1A0D678 	61 6D 65 8F 64 D6 A0  1 
1A0D680 	48 40 A0  1 A8  2  0  0 
headers


: .file-open-error  ( -- )
1A0D688 	 0  0  0 2E 66 69 6C 65 
1A0D690 	2D 6F 70 65 6E 2D 65 72 
1A0D698 	72 6F 72 90 80 D6 A0  1 
1A0D6A0 	20 40 A0  1 
   ." The file '"  opened-filename 2@ type  ." ' cannot be opened."
1A0D6A4 	20 7C A0  1 
1A0D6A8 	 A 54 68 65 20 66 69 6C 
1A0D6B0 	65 20 27  0 80 D6 A0  1 
1A0D6B8 	CC 4D A0  1  4 6C A0  1 
1A0D6C0 	20 7C A0  1 13 27 20 63 
1A0D6C8 	61 6E 6E 6F 74 20 62 65 
1A0D6D0 	20 6F 70 65 6E 65 64 2E 
1A0D6D8 	 0  0  0  0 
;
1A0D6DC 	58 46 A0  1 

: (.error#)  ( error# -- )
1A0D6E0 	 0  0 28 2E 65 72 72 6F 
1A0D6E8 	72 23 29 89 A0 D6 A0  1 
1A0D6F0 	20 40 A0  1 
   dup d# -38  =  if  .file-open-error  else  ." Error " .  then
1A0D6F4 	40 49 A0  1 
1A0D6F8 	58 41 A0  1 DA FF FF FF 
1A0D700 	24 48 A0  1 DC 41 A0  1 
1A0D708 	10  0  0  0 A0 D6 A0  1 
1A0D710 	C8 41 A0  1 14  0  0  0 
1A0D718 	20 7C A0  1  6 45 72 72 
1A0D720 	6F 72 20  0 94 7A A0  1 
;
1A0D728 	58 46 A0  1 

' (.error#) is .error#


: left-parse-string  ( adr len delim -- tail$ head$ )
1A0D72C 	 0  0 6C 65 
1A0D730 	66 74 2D 70 61 72 73 65 
1A0D738 	2D 73 74 72 69 6E 67 91 
1A0D740 	F0 D6 A0  1 20 40 A0  1 
   split-string  dup if  1 /string  then  2swap
1A0D748 	3C 64 A0  1 40 49 A0  1 
1A0D750 	DC 41 A0  1  C  0  0  0 
1A0D758 	80 6F A0  1 3C 85 A0  1 
1A0D760 	F4 49 A0  1 
;
1A0D764 	58 46 A0  1 

headerless
: remaining$  ( -- adr len )  bfcurrent @  bftop @ over -  ;
1A0D768 	 0 72 65 6D 61 69 6E 69 
1A0D770 	6E 67 24 8A 44 D7 A0  1 
1A0D778 	20 40 A0  1 2C AC A0  1 
1A0D780 	5C 4C A0  1 E0 AB A0  1 
1A0D788 	5C 4C A0  1 54 49 A0  1 
1A0D790 	18 45 A0  1 58 46 A0  1 

: $set-line-delimiter  ( adr len -- )
1A0D798 	24 73 65 74 2D 6C 69 6E 
1A0D7A0 	65 2D 64 65 6C 69 6D 69 
1A0D7A8 	74 65 72 93 78 D7 A0  1 
1A0D7B0 	20 40 A0  1 
   carret split-string  dup  if           ( head-adr,len tail-adr,len )
1A0D7B4 	60 6F A0  1 
1A0D7B8 	3C 64 A0  1 40 49 A0  1 
1A0D7C0 	DC 41 A0  1 5C  0  0  0 
      carret line-delimiter c!            ( head-adr,len tail-adr,len )
1A0D7C8 	60 6F A0  1  4 AE A0  1 
1A0D7D0 	B8 4D A0  1 
      1 >  if                             ( head-adr,len tail-adr )
1A0D7D4 	80 6F A0  1 
1A0D7D8 	 4 48 A0  1 DC 41 A0  1 
1A0D7E0 	38  0  0  0 
         dup 1+ c@ linefeed  =  if        ( head-adr,len tail-adr )
1A0D7E4 	40 49 A0  1 
1A0D7E8 	30 4B A0  1 C4 4C A0  1 
1A0D7F0 	4C 6F A0  1 24 48 A0  1 
1A0D7F8 	DC 41 A0  1 1C  0  0  0 
            carret pre-delimiter c!       ( head-adr,len tail-adr )
1A0D800 	60 6F A0  1 34 AE A0  1 
1A0D808 	B8 4D A0  1 
            linefeed line-delimiter c!    ( head-adr,len tail-adr )
1A0D80C 	4C 6F A0  1 
1A0D810 	 4 AE A0  1 B8 4D A0  1 
         then                             ( head-adr,len tail-adr )
      then                                ( head-adr,len tail-adr )
   else                                   ( adr,len tail-adr,0 )
1A0D818 	C8 41 A0  1 30  0  0  0 
      2drop  linefeed split-string  if    ( head-adr,len tail-adr )
1A0D820 	AC 49 A0  1 4C 6F A0  1 
1A0D828 	3C 64 A0  1 DC 41 A0  1 
1A0D830 	1C  0  0  0 
         0 pre-delimiter c!               ( head-adr,len tail-adr )
1A0D834 	70 6F A0  1 
1A0D838 	34 AE A0  1 B8 4D A0  1 
         linefeed line-delimiter c!       ( head-adr,len tail-adr )
1A0D840 	4C 6F A0  1  4 AE A0  1 
1A0D848 	B8 4D A0  1 
      then                                ( head-adr,len tail-adr )
   then                                   ( head-adr,len tail-adr )
   3drop                                  ( )
1A0D84C 	90 52 A0  1 
;
1A0D850 	58 46 A0  1 
: set-line-delimiter  ( fd -- )
1A0D854 	 0 73 65 74 
1A0D858 	2D 6C 69 6E 65 2D 64 65 
1A0D860 	6C 69 6D 69 74 65 72 92 
1A0D868 	B0 D7 A0  1 20 40 A0  1 
   file @ >r  file !  0 0 fillbuf  remaining$  $set-line-delimiter  r> file !
1A0D870 	84 AB A0  1 5C 4C A0  1 
1A0D878 	BC 45 A0  1 84 AB A0  1 
1A0D880 	54 4D A0  1 70 6F A0  1 
1A0D888 	70 6F A0  1 CC AF A0  1 
1A0D890 	78 D7 A0  1 B0 D7 A0  1 
1A0D898 	D0 45 A0  1 84 AB A0  1 
1A0D8A0 	54 4D A0  1 
;
1A0D8A4 	58 46 A0  1 

0 value cstrbuf		\ Initialized in
1A0D8A8 	63 73 74 72 62 75 66 87 
1A0D8B0 	6C D8 A0  1 50 40 A0  1 
1A0D8B8 	B0  2  0  0 

: open-file  ( adr len mode -- fd ior )
1A0D8BC 	 0  0 6F 70 
1A0D8C0 	65 6E 2D 66 69 6C 65 89 
1A0D8C8 	B4 D8 A0  1 20 40 A0  1 
   file @ >r		\ Guard against re-entrancy
1A0D8D0 	84 AB A0  1 5C 4C A0  1 
1A0D8D8 	BC 45 A0  1 

   >r 2dup opened-filename 2! cstrbuf pack r@ fopen   ( fd )  ( r: mode )
1A0D8DC 	BC 45 A0  1 
1A0D8E0 	C0 49 A0  1 80 D6 A0  1 
1A0D8E8 	E4 4D A0  1 B4 D8 A0  1 
1A0D8F0 	DC 52 A0  1 E4 45 A0  1 
1A0D8F8 	64 D5 A0  1 

   \ Bail out now if the open failed
   dup  0=  if  d# -38  r> drop  r> file !  exit  then
1A0D8FC 	40 49 A0  1 
1A0D900 	24 47 A0  1 DC 41 A0  1 
1A0D908 	24  0  0  0 58 41 A0  1 
1A0D910 	DA FF FF FF D0 45 A0  1 
1A0D918 	30 49 A0  1 D0 45 A0  1 
1A0D920 	84 AB A0  1 54 4D A0  1 
1A0D928 	40 46 A0  1 

   \ First initialize the delimiters to the default values for the
   \ underlying operating system, in case the file is initially empty.
   init-delims
1A0D92C 	78 CE A0  1 

   \ If the mode is neither "w/o" nor "binary", and the file isn't
   \ being newly created, establish the line delimiter(s) by looking
   \ for the first carriage return or line feed

   dup  r@ bin create-flag or  and 0=  and  r> w/o <> and  if
1A0D930 	40 49 A0  1 E4 45 A0  1 
1A0D938 	4C D6 A0  1 64 D6 A0  1 
1A0D940 	70 44 A0  1 5C 44 A0  1 
1A0D948 	24 47 A0  1 5C 44 A0  1 
1A0D950 	D0 45 A0  1 2C D6 A0  1 
1A0D958 	44 48 A0  1 5C 44 A0  1 
1A0D960 	DC 41 A0  1  C  0  0  0 
      dup set-line-delimiter
1A0D968 	40 49 A0  1 6C D8 A0  1 
   then                                           ( fd )
   0                                              ( fd ior )
1A0D970 	70 6F A0  1 
   r> file !
1A0D974 	D0 45 A0  1 
1A0D978 	84 AB A0  1 54 4D A0  1 
;
1A0D980 	58 46 A0  1 

: create-file  ( name$ mode -- fileid ior )  8 or  open-file  ;
1A0D984 	63 72 65 61 
1A0D988 	74 65 2D 66 69 6C 65 8B 
1A0D990 	CC D8 A0  1 20 40 A0  1 
1A0D998 	F0 6F A0  1 70 44 A0  1 
1A0D9A0 	CC D8 A0  1 58 46 A0  1 

: make  ( name-pstr -- flag )	\ Creates an empty file
1A0D9A8 	 0  0  0 6D 61 6B 65 84 
1A0D9B0 	94 D9 A0  1 20 40 A0  1 
   count  r/w  create-file  if  drop false  else  close-file drop true  then
1A0D9B8 	BC 53 A0  1 3C D6 A0  1 
1A0D9C0 	94 D9 A0  1 DC 41 A0  1 
1A0D9C8 	14  0  0  0 30 49 A0  1 
1A0D9D0 	18 70 A0  1 C8 41 A0  1 
1A0D9D8 	10  0  0  0 D0 CC A0  1 
1A0D9E0 	30 49 A0  1  4 70 A0  1 
;
1A0D9E8 	58 46 A0  1 

: close-file  ( fd -- ior )
1A0D9EC 	 0 63 6C 6F 
1A0D9F0 	73 65 2D 66 69 6C 65 8A 
1A0D9F8 	B4 D9 A0  1 20 40 A0  1 
   ?dup  0=  if  0  exit  then
1A0DA00 	B4 70 A0  1 24 47 A0  1 
1A0DA08 	DC 41 A0  1  C  0  0  0 
1A0DA10 	70 6F A0  1 40 46 A0  1 
   dup -1 =  if  drop 0  exit  then
1A0DA18 	40 49 A0  1 58 41 A0  1 
1A0DA20 	FF FF FF FF 24 48 A0  1 
1A0DA28 	DC 41 A0  1 10  0  0  0 
1A0DA30 	30 49 A0  1 70 6F A0  1 
1A0DA38 	40 46 A0  1 
   ['] fclose catch  ?dup  if  nip  else  0  then
1A0DA3C 	60 53 A0  1 
1A0DA40 	5C CC A0  1 14 7F A0  1 
1A0DA48 	B4 70 A0  1 DC 41 A0  1 
1A0DA50 	10  0  0  0 FC 46 A0  1 
1A0DA58 	C8 41 A0  1  8  0  0  0 
1A0DA60 	70 6F A0  1 
;
1A0DA64 	58 46 A0  1 

: -pre-delimiter  ( adr len -- adr' len' )
1A0DA68 	 0 2D 70 72 65 2D 64 65 
1A0DA70 	6C 69 6D 69 74 65 72 8E 
1A0DA78 	FC D9 A0  1 20 40 A0  1 
   pre-delimiter c@  if
1A0DA80 	34 AE A0  1 C4 4C A0  1 
1A0DA88 	DC 41 A0  1 38  0  0  0 
      dup  if
1A0DA90 	40 49 A0  1 DC 41 A0  1 
1A0DA98 	2C  0  0  0 
         2dup + 1- c@  pre-delimiter c@  =  if
1A0DA9C 	C0 49 A0  1 
1A0DAA0 	 4 45 A0  1 54 4B A0  1 
1A0DAA8 	C4 4C A0  1 34 AE A0  1 
1A0DAB0 	C4 4C A0  1 24 48 A0  1 
1A0DAB8 	DC 41 A0  1  8  0  0  0 
            1-
1A0DAC0 	54 4B A0  1 
         then
      then
   then
;
1A0DAC4 	58 46 A0  1 

: parse-line-piece  ( adr len #so-far -- actual retry? )
1A0DAC8 	 0  0  0 70 61 72 73 65 
1A0DAD0 	2D 6C 69 6E 65 2D 70 69 
1A0DAD8 	65 63 65 90 7C DA A0  1 
1A0DAE0 	20 40 A0  1 
   >r  2>r  ( r: #so-far adr len )
1A0DAE4 	BC 45 A0  1 
1A0DAE8 	F8 45 A0  1 

   remaining$                          ( fbuf$ )
1A0DAEC 	78 D7 A0  1 
   line-delimiter c@ split-string      ( head$ tail$ )  ( r: # adr len )
1A0DAF0 	 4 AE A0  1 C4 4C A0  1 
1A0DAF8 	3C 64 A0  1 

   2swap -pre-delimiter                ( tail$ head$')  ( r: # adr len )
1A0DAFC 	F4 49 A0  1 
1A0DB00 	7C DA A0  1 

   dup r@  u>=  if                     ( tail$ head$ )  ( r: # adr len )
1A0DB04 	40 49 A0  1 
1A0DB08 	E4 45 A0  1 CC 48 A0  1 
1A0DB10 	DC 41 A0  1 44  0  0  0 
      \ The parsed line doesn't fit into the buffer, so we consume
      \ from the file buffer only the portion that we copy into the
      \ buffer.
      over r@ +  bfcurrent !           ( tail$ head$ )
1A0DB18 	54 49 A0  1 E4 45 A0  1 
1A0DB20 	 4 45 A0  1 2C AC A0  1 
1A0DB28 	54 4D A0  1 
      drop nip nip                     ( head-adr )  ( r: # adr len )
1A0DB2C 	30 49 A0  1 
1A0DB30 	FC 46 A0  1 FC 46 A0  1 
      2r> dup >r  move                 ( )           ( r: # len )
1A0DB38 	10 46 A0  1 40 49 A0  1 
1A0DB40 	BC 45 A0  1 F4 4A A0  1 
      2r> + false                      ( actual don't-retry )
1A0DB48 	10 46 A0  1  4 45 A0  1 
1A0DB50 	18 70 A0  1 
      exit
1A0DB54 	40 46 A0  1 
   then                                ( tail$ head$ )  ( r: # adr len )

   \ The parsed line fits into the buffer, so we copy it all in
   tuck  2r> drop  swap  move          ( tail$ head-len )  ( r: # )
1A0DB58 	E8 46 A0  1 10 46 A0  1 
1A0DB60 	30 49 A0  1 68 49 A0  1 
1A0DB68 	F4 4A A0  1 
   r> +  -rot                          ( actual tail$ )
1A0DB6C 	D0 45 A0  1 
1A0DB70 	 4 45 A0  1 94 49 A0  1 

   \ Consume the parsed line from the file buffer, including the
   \ delimiter if one was found (as indicated by nonzero tail-len)
   tuck  if  1+  then  bfcurrent !     ( actual tail-len )
1A0DB78 	E8 46 A0  1 DC 41 A0  1 
1A0DB80 	 8  0  0  0 30 4B A0  1 
1A0DB88 	2C AC A0  1 54 4D A0  1 

   \ If a delimiter was found, increment the line number the next time.
   dup if  1 (file-line) +!  then
1A0DB90 	40 49 A0  1 DC 41 A0  1 
1A0DB98 	10  0  0  0 80 6F A0  1 
1A0DBA0 	D4 AD A0  1  C 4C A0  1 

   \ If a delimiter was found, we need not retry.
   0=                                  ( actual retry? )
1A0DBA8 	24 47 A0  1 
;
1A0DBAC 	58 46 A0  1 

headers
: read-line  ( adr len fd -- actual not-eof? error? )
1A0DBB0 	 0  0 72 65 61 64 2D 6C 
1A0DBB8 	69 6E 65 89 E0 DA A0  1 
1A0DBC0 	20 40 A0  1 
   file @ >r  file !
1A0DBC4 	84 AB A0  1 
1A0DBC8 	5C 4C A0  1 BC 45 A0  1 
1A0DBD0 	84 AB A0  1 54 4D A0  1 
   0
1A0DBD8 	70 6F A0  1 
   begin  >r 2dup r>  parse-line-piece  while   ( adr len actual )
1A0DBDC 	BC 45 A0  1 
1A0DBE0 	C0 49 A0  1 D0 45 A0  1 
1A0DBE8 	E0 DA A0  1 DC 41 A0  1 
1A0DBF0 	98  0  0  0 

      \ The end of the file buffer was reached without filling the
      \ argument buffer, so we refill the file buffer and try again.

      bftop @  ['] shortseek catch  ?dup  if  ( adr len actual x error-code )
1A0DBF4 	E0 AB A0  1 
1A0DBF8 	5C 4C A0  1 60 53 A0  1 
1A0DC00 	C0 B0 A0  1 14 7F A0  1 
1A0DC08 	B4 70 A0  1 DC 41 A0  1 
1A0DC10 	28  0  0  0 
         \ A file read error (more serious than end-of-file) occurred
         drop 2swap 2drop  false swap         ( actual false ior )
1A0DC14 	30 49 A0  1 
1A0DC18 	F4 49 A0  1 AC 49 A0  1 
1A0DC20 	18 70 A0  1 68 49 A0  1 
	 r> file !  exit
1A0DC28 	D0 45 A0  1 84 AB A0  1 
1A0DC30 	54 4D A0  1 40 46 A0  1 
      then                                    ( adr len actual )
      remaining$  nip 0=  if                  ( adr len actual )
1A0DC38 	78 D7 A0  1 FC 46 A0  1 
1A0DC40 	24 47 A0  1 DC 41 A0  1 
1A0DC48 	28  0  0  0 

         \ Shortseek did not put any more characters into the file buffer,
         \ so we return the number of characters that were copied into the
	 \ argument buffer before shortseek was called and a flag.
         \ If no characters were copied into the argument buffer, the
         \ flag is false, indicating end-of-file

         nip  nip  dup 0<>  0                ( #copied not-eof? 0 )
1A0DC4C 	FC 46 A0  1 
1A0DC50 	FC 46 A0  1 40 49 A0  1 
1A0DC58 	44 47 A0  1 70 6F A0  1 
         r> file !  exit
1A0DC60 	D0 45 A0  1 84 AB A0  1 
1A0DC68 	54 4D A0  1 40 46 A0  1 
      then                                   ( adr len #copied )
      \ There are more characters in the file buffer, so we update
      \ adr len to reflect the portion of the buffer that has
      \ already been filled.
      dup >r /string r>                     ( adr' len' actual' )
1A0DC70 	40 49 A0  1 BC 45 A0  1 
1A0DC78 	3C 85 A0  1 D0 45 A0  1 
   repeat                                   ( adr len actual )
1A0DC80 	C8 41 A0  1 58 FF FF FF 
   nip nip true 0                           ( actual true 0 )
1A0DC88 	FC 46 A0  1 FC 46 A0  1 
1A0DC90 	 4 70 A0  1 70 6F A0  1 
   r> file !
1A0DC98 	D0 45 A0  1 84 AB A0  1 
1A0DCA0 	54 4D A0  1 
;
1A0DCA4 	58 46 A0  1 
\ Some more ANS Forth versions of file operations
: reposition-file  ( d.position fd -- ior )
1A0DCA8 	72 65 70 6F 73 69 74 69 
1A0DCB0 	6F 6E 2D 66 69 6C 65 8F 
1A0DCB8 	C0 DB A0  1 20 40 A0  1 
   ['] dfseek catch  dup  if  nip nip nip  then
1A0DCC0 	60 53 A0  1 F8 D1 A0  1 
1A0DCC8 	14 7F A0  1 40 49 A0  1 
1A0DCD0 	DC 41 A0  1 10  0  0  0 
1A0DCD8 	FC 46 A0  1 FC 46 A0  1 
1A0DCE0 	FC 46 A0  1 
;
1A0DCE4 	58 46 A0  1 
: file-size  ( fd -- d.size ior )
1A0DCE8 	 0  0 66 69 6C 65 2D 73 
1A0DCF0 	69 7A 65 89 BC DC A0  1 
1A0DCF8 	20 40 A0  1 
   ['] dfsize catch  dup if  0 0 rot  then
1A0DCFC 	60 53 A0  1 
1A0DD00 	BC D4 A0  1 14 7F A0  1 
1A0DD08 	40 49 A0  1 DC 41 A0  1 
1A0DD10 	10  0  0  0 70 6F A0  1 
1A0DD18 	70 6F A0  1 7C 49 A0  1 
;
1A0DD20 	58 46 A0  1 
: read-file  ( adr len fd -- actual ior )
1A0DD24 	 0  0 72 65 
1A0DD28 	61 64 2D 66 69 6C 65 89 
1A0DD30 	F8 DC A0  1 20 40 A0  1 
   ['] fgets catch  dup  if  >r 3drop 0 r>  then
1A0DD38 	60 53 A0  1 1C D4 A0  1 
1A0DD40 	14 7F A0  1 40 49 A0  1 
1A0DD48 	DC 41 A0  1 14  0  0  0 
1A0DD50 	BC 45 A0  1 90 52 A0  1 
1A0DD58 	70 6F A0  1 D0 45 A0  1 
;
1A0DD60 	58 46 A0  1 
: write-file  ( adr len fd -- actual ior )
1A0DD64 	 0 77 72 69 
1A0DD68 	74 65 2D 66 69 6C 65 8A 
1A0DD70 	34 DD A0  1 20 40 A0  1 
   over >r  ['] fputs catch  dup  if   ( x x x ior )  ( r: len )
1A0DD78 	54 49 A0  1 BC 45 A0  1 
1A0DD80 	60 53 A0  1  8 B3 A0  1 
1A0DD88 	14 7F A0  1 40 49 A0  1 
1A0DD90 	DC 41 A0  1 24  0  0  0 
      r> drop  >r 3drop 0 r>           ( 0 ior )
1A0DD98 	D0 45 A0  1 30 49 A0  1 
1A0DDA0 	BC 45 A0  1 90 52 A0  1 
1A0DDA8 	70 6F A0  1 D0 45 A0  1 
   else                                ( ior )        ( r: len )
1A0DDB0 	C8 41 A0  1  C  0  0  0 
      r> swap                          ( len ior )
1A0DDB8 	D0 45 A0  1 68 49 A0  1 
   then                                ( actual ior )
;
1A0DDC0 	58 46 A0  1 
: flush-file  ( fd -- ior )  ['] fflush  catch  dup  if  nip  then  ;
1A0DDC4 	 0 66 6C 75 
1A0DDC8 	73 68 2D 66 69 6C 65 8A 
1A0DDD0 	74 DD A0  1 20 40 A0  1 
1A0DDD8 	60 53 A0  1 C0 D1 A0  1 
1A0DDE0 	14 7F A0  1 40 49 A0  1 
1A0DDE8 	DC 41 A0  1  8  0  0  0 
1A0DDF0 	FC 46 A0  1 58 46 A0  1 
: write-line  ( adr len fd -- ior )
1A0DDF8 	 0 77 72 69 74 65 2D 6C 
1A0DE00 	69 6E 65 8A D4 DD A0  1 
1A0DE08 	20 40 A0  1 
   dup >r ['] fputs catch  ?dup  if  nip nip nip  r> drop exit  then  ( )
1A0DE0C 	40 49 A0  1 
1A0DE10 	BC 45 A0  1 60 53 A0  1 
1A0DE18 	 8 B3 A0  1 14 7F A0  1 
1A0DE20 	B4 70 A0  1 DC 41 A0  1 
1A0DE28 	1C  0  0  0 FC 46 A0  1 
1A0DE30 	FC 46 A0  1 FC 46 A0  1 
1A0DE38 	D0 45 A0  1 30 49 A0  1 
1A0DE40 	40 46 A0  1 
   pre-delimiter c@  if
1A0DE44 	34 AE A0  1 
1A0DE48 	C4 4C A0  1 DC 41 A0  1 
1A0DE50 	3C  0  0  0 
      pre-delimiter c@  r@  ['] fputc catch  ?dup  if  ( x x ior )
1A0DE54 	34 AE A0  1 
1A0DE58 	C4 4C A0  1 E4 45 A0  1 
1A0DE60 	60 53 A0  1 9C B2 A0  1 
1A0DE68 	14 7F A0  1 B4 70 A0  1 
1A0DE70 	DC 41 A0  1 18  0  0  0 
         nip nip  r> drop exit
1A0DE78 	FC 46 A0  1 FC 46 A0  1 
1A0DE80 	D0 45 A0  1 30 49 A0  1 
1A0DE88 	40 46 A0  1 
      then                                             ( )
   then
   line-delimiter c@  r>  ['] fputc catch  dup  if     ( x x ior )
1A0DE8C 	 4 AE A0  1 
1A0DE90 	C4 4C A0  1 D0 45 A0  1 
1A0DE98 	60 53 A0  1 9C B2 A0  1 
1A0DEA0 	14 7F A0  1 40 49 A0  1 
1A0DEA8 	DC 41 A0  1 10  0  0  0 
      nip nip exit
1A0DEB0 	FC 46 A0  1 FC 46 A0  1 
1A0DEB8 	40 46 A0  1 
   then                                                ( ior )
;
1A0DEBC 	58 46 A0  1 
\ Missing: file-status, create-file, delete-file, resize-file, rename-file
[then]

\ From cstrings.fth

\ Conversion between Forth-style strings and C-style null-terminated strings.
\ cstrlen and cscount are defined in cmdline.fth

decimal

headerless
: init  ( -- )  init  102 alloc-mem is cstrbuf  ;
1A0DEC0 	 0  0  0 69 6E 69 74 84 
1A0DEC8 	 8 DE A0  1 20 40 A0  1 
1A0DED0 	24 CD A0  1 58 41 A0  1 
1A0DED8 	66  0  0  0 F0 6C A0  1 
1A0DEE0 	B8 65 A0  1 B4 D8 A0  1 
1A0DEE8 	58 46 A0  1 

headers
\ Convert an unpacked string to a C string
: $cstr  ( adr len -- c-string-adr )
1A0DEEC 	 0  0 24 63 
1A0DEF0 	73 74 72 85 CC DE A0  1 
1A0DEF8 	20 40 A0  1 
   \ If, as is usually the case, there is already a null byte at the end,
   \ we can avoid the copy.
   2dup +  c@  0=  if  drop exit  then
1A0DEFC 	C0 49 A0  1 
1A0DF00 	 4 45 A0  1 C4 4C A0  1 
1A0DF08 	24 47 A0  1 DC 41 A0  1 
1A0DF10 	 C  0  0  0 30 49 A0  1 
1A0DF18 	40 46 A0  1 
   >r   cstrbuf r@  cmove  0 cstrbuf r> + c!  cstrbuf
1A0DF1C 	BC 45 A0  1 
1A0DF20 	B4 D8 A0  1 E4 45 A0  1 
1A0DF28 	10 44 A0  1 70 6F A0  1 
1A0DF30 	B4 D8 A0  1 D0 45 A0  1 
1A0DF38 	 4 45 A0  1 B8 4D A0  1 
1A0DF40 	B4 D8 A0  1 
;
1A0DF44 	58 46 A0  1 

\ Convert a packed string to a C string
: cstr  ( forth-pstring -- c-string-adr )  count $cstr  ;
1A0DF48 	 0  0  0 63 73 74 72 84 
1A0DF50 	F8 DE A0  1 20 40 A0  1 
1A0DF58 	BC 53 A0  1 F8 DE A0  1 
1A0DF60 	58 46 A0  1 

\ Find the length of a C string, not counting the null byte
: cstrlen  ( c-string -- length )
1A0DF64 	63 73 74 72 
1A0DF68 	6C 65 6E 87 54 DF A0  1 
1A0DF70 	20 40 A0  1 
   dup  begin  dup c@  while  ca1+  repeat  swap -
1A0DF74 	40 49 A0  1 
1A0DF78 	40 49 A0  1 C4 4C A0  1 
1A0DF80 	DC 41 A0  1 10  0  0  0 
1A0DF88 	78 50 A0  1 C8 41 A0  1 
1A0DF90 	E8 FF FF FF 68 49 A0  1 
1A0DF98 	18 45 A0  1 
;
1A0DF9C 	58 46 A0  1 
\ Convert a null-terminated C string to an unpacked string
: cscount  ( cstr -- adr len )  dup cstrlen  ;
1A0DFA0 	63 73 63 6F 75 6E 74 87 
1A0DFA8 	70 DF A0  1 20 40 A0  1 
1A0DFB0 	40 49 A0  1 70 DF A0  1 
1A0DFB8 	58 46 A0  1 

headers

\ From alias.fth

\ Alias makes a new word which behaves exactly like an existing
\ word.  This works whether the new word is encountered during
\ compilation or interpretation, and does the right thing even
\  if the old word is immediate.

decimal

: setalias  ( xt +-1 -- )
1A0DFBC 	 0  0  0 73 
1A0DFC0 	65 74 61 6C 69 61 73 88 
1A0DFC8 	AC DF A0  1 20 40 A0  1 
   0> if  immediate  then                ( acf )
1A0DFD0 	A4 47 A0  1 DC 41 A0  1 
1A0DFD8 	 8  0  0  0 BC B8 A0  1 
   flagalias
1A0DFE0 	2C B9 A0  1 
   lastacf  here - allot   token,
1A0DFE4 	AC 57 A0  1 
1A0DFE8 	70 54 A0  1 18 45 A0  1 
1A0DFF0 	E4 54 A0  1 2C 55 A0  1 
;
1A0DFF8 	58 46 A0  1 
: alias  \ new-name old-name  ( -- )
1A0DFFC 	 0  0 61 6C 
1A0E000 	69 61 73 85 CC DF A0  1 
1A0E008 	20 40 A0  1 
   create  hide  'i  reveal  setalias
1A0E00C 	A8 A2 A0  1 
1A0E010 	54 A5 A0  1 B0 94 A0  1 
1A0E018 	88 A5 A0  1 CC DF A0  1 
;
1A0E020 	58 46 A0  1 

\ From ansio.fth

headers
: allocate  ( size -- adr ior )  alloc-mem  dup 0=  ;
1A0E024 	 0  0  0 61 
1A0E028 	6C 6C 6F 63 61 74 65 88 
1A0E030 	 8 E0 A0  1 20 40 A0  1 
1A0E038 	F0 6C A0  1 40 49 A0  1 
1A0E040 	24 47 A0  1 58 46 A0  1 

\ Assumes free-mem doesn't really need the size parameter; usually true
: free  ( adr -- ior )  0 free-mem 0  ;
1A0E048 	 0  0  0 66 72 65 65 84 
1A0E050 	34 E0 A0  1 20 40 A0  1 
1A0E058 	70 6F A0  1  8 6D A0  1 
1A0E060 	70 6F A0  1 58 46 A0  1 

headerless
nuser insane
1A0E068 	 0 69 6E 73 61 6E 65 86 
1A0E070 	54 E0 A0  1 48 40 A0  1 
1A0E078 	B4  2  0  0 

headers
0 value exit-interact?
1A0E07C 	 0 65 78 69 
1A0E080 	74 2D 69 6E 74 65 72 61 
1A0E088 	63 74 3F 8E 74 E0 A0  1 
1A0E090 	50 40 A0  1 B8  2  0  0 

headerless
\ XXX check for EOF on keyboard stream
: more-input?  ( -- flag )  insane off  true  ;
1A0E098 	6D 6F 72 65 2D 69 6E 70 
1A0E0A0 	75 74 3F 8B 90 E0 A0  1 
1A0E0A8 	20 40 A0  1 74 E0 A0  1 
1A0E0B0 	F8 4B A0  1  4 70 A0  1 
1A0E0B8 	58 46 A0  1 

headers

variable blk
1A0E0BC 	62 6C 6B 83 
1A0E0C0 	A8 E0 A0  1 48 40 A0  1 
1A0E0C8 	BC  2  0  0 

headerless
defer ?block-valid  ( -- flag )  ' false is ?block-valid
1A0E0CC 	 0  0  0 3F 
1A0E0D0 	62 6C 6F 63 6B 2D 76 61 
1A0E0D8 	6C 69 64 8C C4 E0 A0  1 
1A0E0E0 	5C 40 A0  1 C0  2  0  0 

headers
variable #tib
1A0E0E8 	 0  0  0 23 74 69 62 84 
1A0E0F0 	E0 E0 A0  1 48 40 A0  1 
1A0E0F8 	C4  2  0  0 


: save-input  ( -- source-adr source-len source-id >in blk 5 )
1A0E0FC 	 0 73 61 76 
1A0E100 	65 2D 69 6E 70 75 74 8A 
1A0E108 	F4 E0 A0  1 20 40 A0  1 
   source  source-id  >in @  blk @  5
1A0E110 	84 81 A0  1 8C AE A0  1 
1A0E118 	28 85 A0  1 5C 4C A0  1 
1A0E120 	C4 E0 A0  1 5C 4C A0  1 
1A0E128 	C0 6F A0  1 
;
1A0E12C 	58 46 A0  1 
: restore-input  ( source-adr source-len source-id >in blk 5 -- flag )
1A0E130 	 0  0 72 65 73 74 6F 72 
1A0E138 	65 2D 69 6E 70 75 74 8D 
1A0E140 	 C E1 A0  1 20 40 A0  1 
   drop
1A0E148 	30 49 A0  1 
   blk !  >in !  'source-id !  set-source
1A0E14C 	C4 E0 A0  1 
1A0E150 	54 4D A0  1 28 85 A0  1 
1A0E158 	54 4D A0  1 70 AB A0  1 
1A0E160 	54 4D A0  1 A8 81 A0  1 
   false
1A0E168 	18 70 A0  1 
;
1A0E16C 	58 46 A0  1 
: set-input  ( source-adr source-len source-id -- )
1A0E170 	 0  0 73 65 74 2D 69 6E 
1A0E178 	70 75 74 89 44 E1 A0  1 
1A0E180 	20 40 A0  1 
   0 0 5 restore-input drop
1A0E184 	70 6F A0  1 
1A0E188 	70 6F A0  1 C0 6F A0  1 
1A0E190 	44 E1 A0  1 30 49 A0  1 
;
1A0E198 	58 46 A0  1 

: word  ( delim -- pstr )
1A0E19C 	 0  0  0 77 
1A0E1A0 	6F 72 64 84 80 E1 A0  1 
1A0E1A8 	20 40 A0  1 
   source >in @ /string  over >r   ( delim adr1 len1 )  ( r: adr1 )
1A0E1AC 	84 81 A0  1 
1A0E1B0 	28 85 A0  1 5C 4C A0  1 
1A0E1B8 	3C 85 A0  1 54 49 A0  1 
1A0E1C0 	BC 45 A0  1 
   rot >r r@ skipchar              ( adr2 len2 )        ( r: adr1 delim )
1A0E1C4 	7C 49 A0  1 
1A0E1C8 	BC 45 A0  1 E4 45 A0  1 
1A0E1D0 	34 65 A0  1 
   r> scantochar                   ( adr2 adr3 adr4 )   ( r: adr1 )
1A0E1D4 	D0 45 A0  1 
1A0E1D8 	60 65 A0  1 
   r> - >in +!                     ( adr2 adr3 ) ( r: )
1A0E1DC 	D0 45 A0  1 
1A0E1E0 	18 45 A0  1 28 85 A0  1 
1A0E1E8 	 C 4C A0  1 
   over -                          ( adr1 len )
1A0E1EC 	54 49 A0  1 
1A0E1F0 	18 45 A0  1 
   dup d# 255 >  ( -18 ) abort" Parsed string overflow"
1A0E1F4 	40 49 A0  1 
1A0E1F8 	58 41 A0  1 FF  0  0  0 
1A0E200 	 4 48 A0  1  8 81 A0  1 
1A0E208 	16 50 61 72 73 65 64 20 
1A0E210 	73 74 72 69 6E 67 20 6F 
1A0E218 	76 65 72 66 6C 6F 77  0 
   'word pack                      ( pstr )
1A0E220 	B4 C8 A0  1 DC 52 A0  1 
;
1A0E228 	58 46 A0  1 

: refill  ( -- more? )
1A0E22C 	 0 72 65 66 
1A0E230 	69 6C 6C 86 A8 E1 A0  1 
1A0E238 	20 40 A0  1 
   blk @  if  1 blk +!  ?block-valid  exit  then
1A0E23C 	C4 E0 A0  1 
1A0E240 	5C 4C A0  1 DC 41 A0  1 
1A0E248 	18  0  0  0 80 6F A0  1 
1A0E250 	C4 E0 A0  1  C 4C A0  1 
1A0E258 	E0 E0 A0  1 40 46 A0  1 

   source-id  -1 =  if  false exit  then
1A0E260 	8C AE A0  1 58 41 A0  1 
1A0E268 	FF FF FF FF 24 48 A0  1 
1A0E270 	DC 41 A0  1  C  0  0  0 
1A0E278 	18 70 A0  1 40 46 A0  1 
   source-adr					     ( adr )
1A0E280 	68 81 A0  1 
   source-id  if                                     ( adr )
1A0E284 	8C AE A0  1 
1A0E288 	DC 41 A0  1 64  0  0  0 
      /tib source-id read-line
1A0E290 	3C 70 A0  1 8C AE A0  1 
1A0E298 	C0 DB A0  1 
      ( -37 ) abort" Read error in refill"  ( cnt more? )
1A0E29C 	 8 81 A0  1 
1A0E2A0 	14 52 65 61 64 20 65 72 
1A0E2A8 	72 6F 72 20 69 6E 20 72 
1A0E2B0 	65 66 69 6C 6C  0  0  0 
      over /tib = ( -18 ) abort" line too long in input file"  ( cnt more? )
1A0E2B8 	54 49 A0  1 3C 70 A0  1 
1A0E2C0 	24 48 A0  1  8 81 A0  1 
1A0E2C8 	1B 6C 69 6E 65 20 74 6F 
1A0E2D0 	6F 20 6C 6F 6E 67 20 69 
1A0E2D8 	6E 20 69 6E 70 75 74 20 
1A0E2E0 	66 69 6C 65  0  0  0  0 
   else                                              ( adr )
1A0E2E8 	C8 41 A0  1 30  0  0  0 
      \ The ANS Forth standard does not mention the possibility
      \ that ACCEPT might not be able to deliver any more input,
      \ but in this implementation, the `keyboard' can be redirected
      \ to a file via the command line, so it is indeed possible for
      \ ACCEPT to have no more characters to deliver.  Furthermore,
      \ we also provide a "finished" flag that can be set to force an
      \ exit from the interpreter loop.
      /tib accept  insane off                        ( cnt )
1A0E2F0 	3C 70 A0  1 D8 6C A0  1 
1A0E2F8 	74 E0 A0  1 F8 4B A0  1 
      dup  if  true  else  more-input?  then         ( cnt more? )
1A0E300 	40 49 A0  1 DC 41 A0  1 
1A0E308 	10  0  0  0  4 70 A0  1 
1A0E310 	C8 41 A0  1  8  0  0  0 
1A0E318 	A8 E0 A0  1 
   then                                              ( cnt more? )
   swap  #source !  0 >in !                          ( more? )
1A0E31C 	68 49 A0  1 
1A0E320 	50 81 A0  1 54 4D A0  1 
1A0E328 	70 6F A0  1 28 85 A0  1 
1A0E330 	54 4D A0  1 
;
1A0E334 	58 46 A0  1 

defer prompt
1A0E338 	 0 70 72 6F 6D 70 74 86 
1A0E340 	38 E2 A0  1 5C 40 A0  1 
1A0E348 	C8  2  0  0 

: do-prompt  ( -- )  reset-page prompt  ;
1A0E34C 	 0  0 64 6F 
1A0E350 	2D 70 72 6F 6D 70 74 89 
1A0E358 	44 E3 A0  1 20 40 A0  1 
1A0E360 	9C A1 A0  1 44 E3 A0  1 
1A0E368 	58 46 A0  1 

: (prompt)  ( -- )
1A0E36C 	 0  0  0 28 
1A0E370 	70 72 6F 6D 70 74 29 88 
1A0E378 	5C E3 A0  1 20 40 A0  1 
   interactive?  if	\ Suppress prompt if input is redirected to a file
1A0E380 	C4 6C A0  1 DC 41 A0  1 
1A0E388 	60  0  0  0 
      ??cr status
1A0E38C 	 0 A1 A0  1 
1A0E390 	38 A1 A0  1 
      state @  if
1A0E394 	38 54 A0  1 
1A0E398 	5C 4C A0  1 DC 41 A0  1 
1A0E3A0 	40  0  0  0 
         level @  ?dup if  1 .r  else  ."  "  then  ." ] "
1A0E3A4 	FC 81 A0  1 
1A0E3A8 	5C 4C A0  1 B4 70 A0  1 
1A0E3B0 	DC 41 A0  1 14  0  0  0 
1A0E3B8 	80 6F A0  1 58 78 A0  1 
1A0E3C0 	C8 41 A0  1  C  0  0  0 
1A0E3C8 	20 7C A0  1  1 20  0  0 
1A0E3D0 	20 7C A0  1  2 5D 20  0 
      else
1A0E3D8 	C8 41 A0  1  8  0  0  0 
         (ok)
1A0E3E0 	64 A1 A0  1 
      then
      mark-output
1A0E3E4 	50 A1 A0  1 
   then
;
1A0E3E8 	58 46 A0  1 

: (interact)  ( -- )
1A0E3EC 	 0 28 69 6E 
1A0E3F0 	74 65 72 61 63 74 29 8A 
1A0E3F8 	7C E3 A0  1 20 40 A0  1 
   tib /tib 0 set-input
1A0E400 	 4 75 A0  1 3C 70 A0  1 
1A0E408 	70 6F A0  1 80 E1 A0  1 
   [compile] [
1A0E410 	90 6D A0  1 
   begin
      depth 0<  if  ." Stack Underflow" cr  clear  then
1A0E414 	28 73 A0  1 
1A0E418 	64 47 A0  1 DC 41 A0  1 
1A0E420 	24  0  0  0 20 7C A0  1 
1A0E428 	 F 53 74 61 63 6B 20 55 
1A0E430 	6E 64 65 72 66 6C 6F 77 
1A0E438 	 0  0  0  0 80 6D A0  1 
1A0E440 	58 73 A0  1 
      sp@  sp0 @  ps-size -  u<  if  ." Stack Overflow" cr  clear  then
1A0E444 	6C 45 A0  1 
1A0E448 	8C 66 A0  1 5C 4C A0  1 
1A0E450 	84 8E A0  1 18 45 A0  1 
1A0E458 	A8 48 A0  1 DC 41 A0  1 
1A0E460 	20  0  0  0 20 7C A0  1 
1A0E468 	 E 53 74 61 63 6B 20 4F 
1A0E470 	76 65 72 66 6C 6F 77  0 
1A0E478 	80 6D A0  1 58 73 A0  1 
      do-prompt
1A0E480 	5C E3 A0  1 
   refill  while
1A0E484 	38 E2 A0  1 
1A0E488 	DC 41 A0  1 34  0  0  0 
      ['] interpret catch  ??cr  ?dup if
1A0E490 	60 53 A0  1 B0 A0 A0  1 
1A0E498 	14 7F A0  1  0 A1 A0  1 
1A0E4A0 	B4 70 A0  1 DC 41 A0  1 
1A0E4A8 	 C  0  0  0 
         [compile] [  .error
1A0E4AC 	90 6D A0  1 
1A0E4B0 	70 CF A0  1 
	 \ ANS Forth sort of requires the following "clear", but it's a
	 \ real pain and doesn't affect programs, so we don't do it
\        clear
      then
   exit-interact? until then
1A0E4B4 	90 E0 A0  1 
1A0E4B8 	DC 41 A0  1 58 FF FF FF 
   false is exit-interact?
1A0E4C0 	18 70 A0  1 B8 65 A0  1 
1A0E4C8 	90 E0 A0  1 
;
1A0E4CC 	58 46 A0  1 
: interact  ( -- )
1A0E4D0 	 0  0  0 69 6E 74 65 72 
1A0E4D8 	61 63 74 88 FC E3 A0  1 
1A0E4E0 	20 40 A0  1 
   save-input  2>r 2>r 2>r
1A0E4E4 	 C E1 A0  1 
1A0E4E8 	F8 45 A0  1 F8 45 A0  1 
1A0E4F0 	F8 45 A0  1 
   (interact)
1A0E4F4 	FC E3 A0  1 
   2r> 2r> 2r> restore-input  throw
1A0E4F8 	10 46 A0  1 10 46 A0  1 
1A0E500 	10 46 A0  1 44 E1 A0  1 
1A0E508 	74 7F A0  1 
;
1A0E50C 	58 46 A0  1 
: (quit)  ( -- )
1A0E510 	 0 28 71 75 69 74 29 86 
1A0E518 	E0 E4 A0  1 20 40 A0  1 
   \ XXX We really should clean up any open input files here...
   0 level !  ]
1A0E520 	70 6F A0  1 FC 81 A0  1 
1A0E528 	54 4D A0  1 A0 6D A0  1 
   rp0 @ rp!
1A0E530 	9C 66 A0  1 5C 4C A0  1 
1A0E538 	AC 45 A0  1 
   interact
1A0E53C 	E0 E4 A0  1 
   bye
1A0E540 	74 6C A0  1 
;
1A0E544 	58 46 A0  1 

: interpret-lines  ( -- )  begin  refill  while  interpret  repeat  ;
1A0E548 	69 6E 74 65 72 70 72 65 
1A0E550 	74 2D 6C 69 6E 65 73 8F 
1A0E558 	1C E5 A0  1 20 40 A0  1 
1A0E560 	38 E2 A0  1 DC 41 A0  1 
1A0E568 	10  0  0  0 B0 A0 A0  1 
1A0E570 	C8 41 A0  1 EC FF FF FF 
1A0E578 	58 46 A0  1 

: (evaluate)  ( adr len -- )
1A0E57C 	 0 28 65 76 
1A0E580 	61 6C 75 61 74 65 29 8A 
1A0E588 	5C E5 A0  1 20 40 A0  1 
   begin  dup  while         ( adr len )
1A0E590 	40 49 A0  1 DC 41 A0  1 
1A0E598 	28  0  0  0 
      parse-line  2>r        ( head$ )    ( r: tail$ )
1A0E59C 	78 64 A0  1 
1A0E5A0 	F8 45 A0  1 
      -1 set-input           ( )          ( r: tail$ )
1A0E5A4 	58 41 A0  1 
1A0E5A8 	FF FF FF FF 80 E1 A0  1 
      interpret              ( )          ( r: tail$ )
1A0E5B0 	B0 A0 A0  1 
      2r>                    ( adr len )
1A0E5B4 	10 46 A0  1 
   repeat                    ( adr len )
1A0E5B8 	C8 41 A0  1 D4 FF FF FF 
   2drop
1A0E5C0 	AC 49 A0  1 
;
1A0E5C4 	58 46 A0  1 

: evaluate  ( adr len -- )
1A0E5C8 	 0  0  0 65 76 61 6C 75 
1A0E5D0 	61 74 65 88 8C E5 A0  1 
1A0E5D8 	20 40 A0  1 
   save-input  2>r 2>r 2>r   ( adr len )
1A0E5DC 	 C E1 A0  1 
1A0E5E0 	F8 45 A0  1 F8 45 A0  1 
1A0E5E8 	F8 45 A0  1 
   ['] (evaluate) catch  dup  if  nip nip  then   ( error# )
1A0E5EC 	60 53 A0  1 
1A0E5F0 	8C E5 A0  1 14 7F A0  1 
1A0E5F8 	40 49 A0  1 DC 41 A0  1 
1A0E600 	 C  0  0  0 FC 46 A0  1 
1A0E608 	FC 46 A0  1 
   2r> 2r> 2r> restore-input  throw               ( error# )
1A0E60C 	10 46 A0  1 
1A0E610 	10 46 A0  1 10 46 A0  1 
1A0E618 	44 E1 A0  1 74 7F A0  1 
   throw
1A0E620 	74 7F A0  1 
;
1A0E624 	58 46 A0  1 

' (prompt) is prompt

' (quit) is quit

: include-file  ( fid -- )
1A0E628 	 0  0  0 69 6E 63 6C 75 
1A0E630 	64 65 2D 66 69 6C 65 8C 
1A0E638 	D8 E5 A0  1 20 40 A0  1 
   /tib 4 + allocate throw	( fid adr )
1A0E640 	3C 70 A0  1 B0 6F A0  1 
1A0E648 	 4 45 A0  1 34 E0 A0  1 
1A0E650 	74 7F A0  1 
   save-input 2>r 2>r 2>r       ( fid adr )
1A0E654 	 C E1 A0  1 
1A0E658 	F8 45 A0  1 F8 45 A0  1 
1A0E660 	F8 45 A0  1 

   /tib rot set-input
1A0E664 	3C 70 A0  1 
1A0E668 	7C 49 A0  1 80 E1 A0  1 

   ['] interpret-lines catch    ( error# )
1A0E670 	60 53 A0  1 5C E5 A0  1 
1A0E678 	14 7F A0  1 
   source-id close-file drop    ( error# )
1A0E67C 	8C AE A0  1 
1A0E680 	FC D9 A0  1 30 49 A0  1 

   source-adr free drop         ( error# )
1A0E688 	68 81 A0  1 54 E0 A0  1 
1A0E690 	30 49 A0  1 

   2r> 2r> 2r> restore-input  throw  ( error# )
1A0E694 	10 46 A0  1 
1A0E698 	10 46 A0  1 10 46 A0  1 
1A0E6A0 	44 E1 A0  1 74 7F A0  1 
   throw
1A0E6A8 	74 7F A0  1 
;
1A0E6AC 	58 46 A0  1 
defer $open-error        ' noop is $open-error
1A0E6B0 	24 6F 70 65 6E 2D 65 72 
1A0E6B8 	72 6F 72 8B 3C E6 A0  1 
1A0E6C0 	5C 40 A0  1 CC  2  0  0 
defer include-hook       ' noop is include-hook
1A0E6C8 	 0  0  0 69 6E 63 6C 75 
1A0E6D0 	64 65 2D 68 6F 6F 6B 8C 
1A0E6D8 	C0 E6 A0  1 5C 40 A0  1 
1A0E6E0 	D0  2  0  0 
defer include-exit-hook  ' noop is include-exit-hook
1A0E6E4 	 0  0 69 6E 
1A0E6E8 	63 6C 75 64 65 2D 65 78 
1A0E6F0 	69 74 2D 68 6F 6F 6B 91 
1A0E6F8 	DC E6 A0  1 5C 40 A0  1 
1A0E700 	D4  2  0  0 

: open-buffer  ( adr len -- fd ior )
1A0E704 	6F 70 65 6E 
1A0E708 	2D 62 75 66 66 65 72 8B 
1A0E710 	FC E6 A0  1 20 40 A0  1 
   2 ?enough
1A0E718 	90 6F A0  1 48 8E A0  1 
   \ XXX we need a "throw" code for "no more fds"
   (get-fd  ?dup 0=  if  0 true exit  then	( adr len fd )
1A0E720 	88 CD A0  1 B4 70 A0  1 
1A0E728 	24 47 A0  1 DC 41 A0  1 
1A0E730 	10  0  0  0 70 6F A0  1 
1A0E738 	 4 70 A0  1 40 46 A0  1 
   file !
1A0E740 	84 AB A0  1 54 4D A0  1 
   2dup						( adr len )
1A0E748 	C0 49 A0  1 
   initbuf  init-delims				( adr len )
1A0E74C 	F4 CA A0  1 
1A0E750 	78 CE A0  1 
   bflimit @  dup bfend !  bftop !		( adr len )
1A0E754 	BC AB A0  1 
1A0E758 	5C 4C A0  1 40 49 A0  1 
1A0E760 	 4 AC A0  1 54 4D A0  1 
1A0E768 	E0 AB A0  1 54 4D A0  1 

   0  modify
1A0E770 	70 6F A0  1 10 CA A0  1 
   ['] string-sizeop  ['] drop  ['] drop
1A0E778 	60 53 A0  1 E8 CD A0  1 
1A0E780 	60 53 A0  1 30 49 A0  1 
1A0E788 	60 53 A0  1 30 49 A0  1 
   ['] nullseek  ['] fakewrite  ['] nullread   setupfd  ( adr len )
1A0E790 	60 53 A0  1 BC CA A0  1 
1A0E798 	60 53 A0  1 60 CA A0  1 
1A0E7A0 	60 53 A0  1 9C CA A0  1 
1A0E7A8 	64 C9 A0  1 
   $set-line-delimiter
1A0E7AC 	B0 D7 A0  1 

   \ Set the file name field to "<buffer@ADDRESS>"
   base @ >r hex
1A0E7B0 	B8 75 A0  1 5C 4C A0  1 
1A0E7B8 	BC 45 A0  1 C0 8D A0  1 
   bfbase @ <#  ascii > hold  u#s " <buffer@" hold$ u#> set-name
1A0E7C0 	98 AB A0  1 5C 4C A0  1 
1A0E7C8 	 8 76 A0  1 58 41 A0  1 
1A0E7D0 	3E  0  0  0 DC 75 A0  1 
1A0E7D8 	BC 76 A0  1 9C 53 A0  1 
1A0E7E0 	 8 3C 62 75 66 66 65 72 
1A0E7E8 	40  0  0  0 18 CE A0  1 
1A0E7F0 	E0 76 A0  1  4 C9 A0  1 
   r> base !
1A0E7F8 	D0 45 A0  1 B8 75 A0  1 
1A0E800 	54 4D A0  1 

   file @  false
1A0E804 	84 AB A0  1 
1A0E808 	5C 4C A0  1 18 70 A0  1 
;
1A0E810 	58 46 A0  1 

: include-buffer  ( adr len -- )
1A0E814 	 0 69 6E 63 
1A0E818 	6C 75 64 65 2D 62 75 66 
1A0E820 	66 65 72 8E 14 E7 A0  1 
1A0E828 	20 40 A0  1 
   open-buffer  ?dup  if  " <buffer>" $open-error  then  include-file
1A0E82C 	14 E7 A0  1 
1A0E830 	B4 70 A0  1 DC 41 A0  1 
1A0E838 	18  0  0  0 9C 53 A0  1 
1A0E840 	 8 3C 62 75 66 66 65 72 
1A0E848 	3E  0  0  0 C0 E6 A0  1 
1A0E850 	3C E6 A0  1 
;
1A0E854 	58 46 A0  1 

: $abort-include  ( error# filename$ -- )  2drop  throw  ;
1A0E858 	 0 24 61 62 6F 72 74 2D 
1A0E860 	69 6E 63 6C 75 64 65 8E 
1A0E868 	28 E8 A0  1 20 40 A0  1 
1A0E870 	AC 49 A0  1 74 7F A0  1 
1A0E878 	58 46 A0  1 
' $abort-include is $open-error

: (included)  ( adr len -- )
1A0E87C 	 0 28 69 6E 
1A0E880 	63 6C 75 64 65 64 29 8A 
1A0E888 	6C E8 A0  1 20 40 A0  1 
   r/o open-file  ?dup  if
1A0E890 	1C D6 A0  1 CC D8 A0  1 
1A0E898 	B4 70 A0  1 DC 41 A0  1 
1A0E8A0 	10  0  0  0 
      opened-filename 2@ $open-error
1A0E8A4 	80 D6 A0  1 
1A0E8A8 	CC 4D A0  1 C0 E6 A0  1 
   then                 ( fid )
   include-file
1A0E8B0 	3C E6 A0  1 
;
1A0E8B4 	58 46 A0  1 
: included  ( adr len -- )
1A0E8B8 	 0  0  0 69 6E 63 6C 75 
1A0E8C0 	64 65 64 88 8C E8 A0  1 
1A0E8C8 	20 40 A0  1 
   include-hook          ( adr len )
1A0E8CC 	DC E6 A0  1 
   ['] (included) catch  ( error# )
1A0E8D0 	60 53 A0  1 8C E8 A0  1 
1A0E8D8 	14 7F A0  1 
   include-exit-hook     ( error# )
1A0E8DC 	FC E6 A0  1 
   throw
1A0E8E0 	74 7F A0  1 
;
1A0E8E4 	58 46 A0  1 
: including  ( "name" -- )  safe-parse-word included  ;
1A0E8E8 	 0  0 69 6E 63 6C 75 64 
1A0E8F0 	69 6E 67 89 C8 E8 A0  1 
1A0E8F8 	20 40 A0  1 88 93 A0  1 
1A0E900 	C8 E8 A0  1 58 46 A0  1 
: fl  ( "name" -- )  including  ;
1A0E908 	 0 66 6C 82 F8 E8 A0  1 
1A0E910 	20 40 A0  1 F8 E8 A0  1 
1A0E918 	58 46 A0  1 

0 value error-file
1A0E91C 	 0 65 72 72 
1A0E920 	6F 72 2D 66 69 6C 65 8A 
1A0E928 	10 E9 A0  1 50 40 A0  1 
1A0E930 	D8  2  0  0 
: init  ( -- )  init  d# 128 alloc-mem  is error-file  ;
1A0E934 	 0  0  0 69 
1A0E938 	6E 69 74 84 2C E9 A0  1 
1A0E940 	20 40 A0  1 CC DE A0  1 
1A0E948 	58 41 A0  1 80  0  0  0 
1A0E950 	F0 6C A0  1 B8 65 A0  1 
1A0E958 	2C E9 A0  1 58 46 A0  1 
nuser error-line#
1A0E960 	65 72 72 6F 72 2D 6C 69 
1A0E968 	6E 65 23 8B 40 E9 A0  1 
1A0E970 	48 40 A0  1 DC  2  0  0 
nuser error-source-id
1A0E978 	65 72 72 6F 72 2D 73 6F 
1A0E980 	75 72 63 65 2D 69 64 8F 
1A0E988 	70 E9 A0  1 48 40 A0  1 
1A0E990 	E0  2  0  0 
nuser error-source-adr
1A0E994 	 0  0  0 65 
1A0E998 	72 72 6F 72 2D 73 6F 75 
1A0E9A0 	72 63 65 2D 61 64 72 90 
1A0E9A8 	8C E9 A0  1 48 40 A0  1 
1A0E9B0 	E4  2  0  0 
nuser error-#source
1A0E9B4 	 0  0 65 72 
1A0E9B8 	72 6F 72 2D 23 73 6F 75 
1A0E9C0 	72 63 65 8D AC E9 A0  1 
1A0E9C8 	48 40 A0  1 E8  2  0  0 
: (mark-error)  ( -- )
1A0E9D0 	 0  0  0 28 6D 61 72 6B 
1A0E9D8 	2D 65 72 72 6F 72 29 8C 
1A0E9E0 	C8 E9 A0  1 20 40 A0  1 
   \ Suppress message if input is interactive or from "evaluate"
   source-id  error-source-id !
1A0E9E8 	8C AE A0  1 8C E9 A0  1 
1A0E9F0 	54 4D A0  1 
   source-id  0<>  if
1A0E9F4 	8C AE A0  1 
1A0E9F8 	44 47 A0  1 DC 41 A0  1 
1A0EA00 	58  0  0  0 
      source-id  -1 =  if
1A0EA04 	8C AE A0  1 
1A0EA08 	58 41 A0  1 FF FF FF FF 
1A0EA10 	24 48 A0  1 DC 41 A0  1 
1A0EA18 	20  0  0  0 
         source error-#source !  error-source-adr !
1A0EA1C 	84 81 A0  1 
1A0EA20 	C8 E9 A0  1 54 4D A0  1 
1A0EA28 	AC E9 A0  1 54 4D A0  1 
      else
1A0EA30 	C8 41 A0  1 24  0  0  0 
         source-id file-name error-file place
1A0EA38 	8C AE A0  1 88 B3 A0  1 
1A0EA40 	2C E9 A0  1 F0 88 A0  1 
         source-id file-line error-line# !
1A0EA48 	8C AE A0  1 C8 B3 A0  1 
1A0EA50 	70 E9 A0  1 54 4D A0  1 
      then
   then
;
1A0EA58 	58 46 A0  1 
' (mark-error) is mark-error
: (show-error)  ( -- )
1A0EA5C 	 0  0  0 28 
1A0EA60 	73 68 6F 77 2D 65 72 72 
1A0EA68 	6F 72 29 8C E4 E9 A0  1 
1A0EA70 	20 40 A0  1 
   ??cr
1A0EA74 	 0 A1 A0  1 
   error-source-id @  if
1A0EA78 	8C E9 A0  1 5C 4C A0  1 
1A0EA80 	DC 41 A0  1 9C  0  0  0 
      error-source-id @ -1  =  if
1A0EA88 	8C E9 A0  1 5C 4C A0  1 
1A0EA90 	58 41 A0  1 FF FF FF FF 
1A0EA98 	24 48 A0  1 DC 41 A0  1 
1A0EAA0 	38  0  0  0 
         ." Evaluating: " error-source-adr @ error-#source @  type cr
1A0EAA4 	20 7C A0  1 
1A0EAA8 	 C 45 76 61 6C 75 61 74 
1A0EAB0 	69 6E 67 3A 20  0  0  0 
1A0EAB8 	AC E9 A0  1 5C 4C A0  1 
1A0EAC0 	C8 E9 A0  1 5C 4C A0  1 
1A0EAC8 	 4 6C A0  1 80 6D A0  1 
      else
1A0EAD0 	C8 41 A0  1 4C  0  0  0 
         error-file count type  ." :"
1A0EAD8 	2C E9 A0  1 BC 53 A0  1 
1A0EAE0 	 4 6C A0  1 20 7C A0  1 
1A0EAE8 	 1 3A  0  0 
         base @ >r decimal  error-line# @ (.) type  r> base !
1A0EAEC 	B8 75 A0  1 
1A0EAF0 	5C 4C A0  1 BC 45 A0  1 
1A0EAF8 	E4 8D A0  1 70 E9 A0  1 
1A0EB00 	5C 4C A0  1 10 78 A0  1 
1A0EB08 	 4 6C A0  1 D0 45 A0  1 
1A0EB10 	B8 75 A0  1 54 4D A0  1 
         ." : "
1A0EB18 	20 7C A0  1  2 3A 20  0 
      then
   then
;
1A0EB20 	58 46 A0  1 
' (show-error) is show-error

\ Environment?

defer environment?
1A0EB24 	 0  0  0 65 
1A0EB28 	6E 76 69 72 6F 6E 6D 65 
1A0EB30 	6E 74 3F 8C 70 EA A0  1 
1A0EB38 	5C 40 A0  1 EC  2  0  0 
: null-environment?  ( c-addr u -- false | i*x true )  2drop false  ;
1A0EB40 	 0  0 6E 75 6C 6C 2D 65 
1A0EB48 	6E 76 69 72 6F 6E 6D 65 
1A0EB50 	6E 74 3F 91 38 EB A0  1 
1A0EB58 	20 40 A0  1 AC 49 A0  1 
1A0EB60 	18 70 A0  1 58 46 A0  1 
' null-environment? is environment?

: fload fl ;
1A0EB68 	 0  0 66 6C 6F 61 64 85 
1A0EB70 	58 EB A0  1 20 40 A0  1 
1A0EB78 	10 E9 A0  1 58 46 A0  1 

: $report-name  ( name$ -- name$ )
1A0EB80 	 0  0  0 24 72 65 70 6F 
1A0EB88 	72 74 2D 6E 61 6D 65 8C 
1A0EB90 	74 EB A0  1 20 40 A0  1 
   ." Loading " 2dup type cr
1A0EB98 	20 7C A0  1  8 4C 6F 61 
1A0EBA0 	64 69 6E 67 20  0  0  0 
1A0EBA8 	C0 49 A0  1  4 6C A0  1 
1A0EBB0 	80 6D A0  1 
;
1A0EBB4 	58 46 A0  1 
: fexit ( -- )  source-id close-file drop -1 'source-id !  ;
1A0EBB8 	 0  0 66 65 78 69 74 85 
1A0EBC0 	94 EB A0  1 20 40 A0  1 
1A0EBC8 	8C AE A0  1 FC D9 A0  1 
1A0EBD0 	30 49 A0  1 58 41 A0  1 
1A0EBD8 	FF FF FF FF 70 AB A0  1 
1A0EBE0 	54 4D A0  1 58 46 A0  1 

\ From copyright.fth

: id: [compile] \ ;
1A0EBE8 	69 64 3A 83 C4 EB A0  1 
1A0EBF0 	20 40 A0  1 74 8A A0  1 
1A0EBF8 	58 46 A0  1 
: copyright: [compile] \ ;
1A0EBFC 	 0 63 6F 70 
1A0EC00 	79 72 69 67 68 74 3A 8A 
1A0EC08 	F0 EB A0  1 20 40 A0  1 
1A0EC10 	74 8A A0  1 58 46 A0  1 
: purpose: [compile] \ ;
1A0EC18 	 0  0  0 70 75 72 70 6F 
1A0EC20 	73 65 3A 88  C EC A0  1 
1A0EC28 	20 40 A0  1 74 8A A0  1 
1A0EC30 	58 46 A0  1 
: build-now ;
1A0EC34 	 0  0 62 75 
1A0EC38 	69 6C 64 2D 6E 6F 77 89 
1A0EC40 	28 EC A0  1 20 40 A0  1 
1A0EC48 	58 46 A0  1 
: command: [compile] \ ;
1A0EC4C 	 0  0  0 63 
1A0EC50 	6F 6D 6D 61 6E 64 3A 88 
1A0EC58 	44 EC A0  1 20 40 A0  1 
1A0EC60 	74 8A A0  1 58 46 A0  1 
: in: [compile] \ ;
1A0EC68 	69 6E 3A 83 5C EC A0  1 
1A0EC70 	20 40 A0  1 74 8A A0  1 
1A0EC78 	58 46 A0  1 
: dictionary: [compile] \ ;
1A0EC7C 	64 69 63 74 
1A0EC80 	69 6F 6E 61 72 79 3A 8B 
1A0EC88 	70 EC A0  1 20 40 A0  1 
1A0EC90 	74 8A A0  1 58 46 A0  1 
: fixme:  ." FIXME: "  opened-filename 2@ type  ." : "  -1 parse type cr  ;
1A0EC98 	 0 66 69 78 6D 65 3A 86 
1A0ECA0 	8C EC A0  1 20 40 A0  1 
1A0ECA8 	20 7C A0  1  7 46 49 58 
1A0ECB0 	4D 45 3A 20  0  0  0  0 
1A0ECB8 	80 D6 A0  1 CC 4D A0  1 
1A0ECC0 	 4 6C A0  1 20 7C A0  1 
1A0ECC8 	 2 3A 20  0 58 41 A0  1 
1A0ECD0 	FF FF FF FF E4 85 A0  1 
1A0ECD8 	 4 6C A0  1 80 6D A0  1 
1A0ECE0 	58 46 A0  1 

\ From cmdline.fth

\ Get the arguments passed from the program


defer time&date  ( -- s m h d m y )
1A0ECE4 	 0  0 74 69 
1A0ECE8 	6D 65 26 64 61 74 65 89 
1A0ECF0 	A4 EC A0  1 5C 40 A0  1 
1A0ECF8 	F0  2  0  0 
: now  ( -- s m h )  time&date 3drop  ;
1A0ECFC 	6E 6F 77 83 
1A0ED00 	F4 EC A0  1 20 40 A0  1 
1A0ED08 	F4 EC A0  1 90 52 A0  1 
1A0ED10 	58 46 A0  1 
: today  ( -- d m y )  time&date >r >r >r  3drop  r> r> r>  ;
1A0ED14 	 0  0 74 6F 
1A0ED18 	64 61 79 85  4 ED A0  1 
1A0ED20 	20 40 A0  1 F4 EC A0  1 
1A0ED28 	BC 45 A0  1 BC 45 A0  1 
1A0ED30 	BC 45 A0  1 90 52 A0  1 
1A0ED38 	D0 45 A0  1 D0 45 A0  1 
1A0ED40 	D0 45 A0  1 58 46 A0  1 

: cold  (s -- )
1A0ED48 	 0  0  0 63 6F 6C 64 84 
1A0ED50 	20 ED A0  1 20 40 A0  1 
   decimal
1A0ED58 	E4 8D A0  1 
   init-io			  \ Memory allocator and character I/O
1A0ED5C 	6C D0 A0  1 
   do-init			  \ Kernel
1A0ED60 	80 D0 A0  1 
   ['] init-environment guarded	  \ Environmental dependencies
1A0ED64 	60 53 A0  1 
1A0ED68 	B8 D0 A0  1 44 D0 A0  1 
   ['] cold-hook        guarded	  \ Last-minute stuff
1A0ED70 	60 53 A0  1 98 D0 A0  1 
1A0ED78 	44 D0 A0  1 

;
1A0ED7C 	58 46 A0  1 

\ From comment.fth

\ Comments that span multiple lines

\ Turn this variable on to make long comments apply to the keyboard too.
\ This is useful for cutting and pasting bits of code into a Forth
\ system.
variable long-comments
1A0ED80 	 0  0 6C 6F 6E 67 2D 63 
1A0ED88 	6F 6D 6D 65 6E 74 73 8D 
1A0ED90 	54 ED A0  1 48 40 A0  1 
1A0ED98 	F4  2  0  0 
: (  \ "comments)"  ( -- )
1A0ED9C 	 0  0 28 C1 
1A0EDA0 	94 ED A0  1 20 40 A0  1 
   begin
      >in @  [char] ) parse       ( >in adr len )
1A0EDA8 	28 85 A0  1 5C 4C A0  1 
1A0EDB0 	58 41 A0  1 29  0  0  0 
1A0EDB8 	E4 85 A0  1 
      nip +  >in @  =             ( delimiter-not-found? )
1A0EDBC 	FC 46 A0  1 
1A0EDC0 	 4 45 A0  1 28 85 A0  1 
1A0EDC8 	5C 4C A0  1 24 48 A0  1 
      long-comments @  source-id  -1 0 between  0=  or  and  ( more? )
1A0EDD0 	94 ED A0  1 5C 4C A0  1 
1A0EDD8 	8C AE A0  1 58 41 A0  1 
1A0EDE0 	FF FF FF FF 70 6F A0  1 
1A0EDE8 	D8 70 A0  1 24 47 A0  1 
1A0EDF0 	70 44 A0  1 5C 44 A0  1 
   while                          ( )
1A0EDF8 	DC 41 A0  1 14  0  0  0 
      refill  0=
1A0EE00 	38 E2 A0  1 24 47 A0  1 
   until  then
1A0EE08 	DC 41 A0  1 9C FF FF FF 
; immediate
1A0EE10 	58 46 A0  1 
[then]


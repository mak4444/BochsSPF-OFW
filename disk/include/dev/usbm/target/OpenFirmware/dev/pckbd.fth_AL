purpose: Package methods for 80C42 keyboard controller

\ " us" d# 16 config-string pc-keyboard-type

hex
headerless

my-space " reg" integer-property
1A3C778 	 0  0  0  0 72 65 67 83 
1A3C780 	 0  0 A0  1 BC 13 A2  1 
1A3C788 	10  0  0  0  4  0  0  0 
" keyboard"  device-name
1A3C790 	6B 65 79 62 6F 61 72 64 
1A3C798 	 0  0  0 6E 61 6D 65 84 
1A3C7A0 	84 C7 A3  1 BC 13 A2  1 
1A3C7A8 	18  0  0  0  9  0  0  0 

" pnpPNP,303" " compatible" string-property
1A3C7B0 	70 6E 70 50 4E 50 2C 33 
1A3C7B8 	30 33  0  0  0 63 6F 6D 
1A3C7C0 	70 61 74 69 62 6C 65 8A 
1A3C7C8 	A4 C7 A3  1 BC 13 A2  1 
1A3C7D0 	20  0  0  0  B  0  0  0 

" keyboard" device-type
1A3C7D8 	6B 65 79 62 6F 61 72 64 
1A3C7E0 	 0  0  0  0 64 65 76 69 
1A3C7E8 	63 65 5F 74 79 70 65 8B 
1A3C7F0 	CC C7 A3  1 BC 13 A2  1 
1A3C7F8 	20  0  0  0  9  0  0  0 

: kbdtest ;
1A3C800 	6B 62 64 74 65 73 74 87 
1A3C808 	 0  0 A0  1 20 40 A0  1 
1A3C810 	58 46 A0  1 

0 value #queued
1A3C814 	23 71 75 65 
1A3C818 	75 65 64 87  C C8 A3  1 
1A3C820 	50 40 A0  1 84  C  0  0 
d# 4 buffer: ascii-queue
1A3C828 	61 73 63 69 69 2D 71 75 
1A3C830 	65 75 65 8B 20 C8 A3  1 
1A3C838 	B4 A9 A0  1 88  C  0  0 
1A3C840 	 4  0  0  0 4C BC A3  1 

\ Keyboard command constants
\  ed constant set-leds
\  ee constant echo
\  f0 constant set-scan-codes
\  f2 constant read-id
\  f4 constant enable-scan
\  f5 constant default-disable
\  f6 constant default-enable
\  ff constant reset

\ Keyboard status constants
\  fa constant ack
\  aa constant bat-pass
\  fc constant bat-fail
\  ee constant echo
\  fe constant resend

\ Various keyboard flags
false value check-abort?	\ True to abort on CTRL-BREAK
1A3C848 	 0  0  0 63 68 65 63 6B 
1A3C850 	2D 61 62 6F 72 74 3F 8C 
1A3C858 	38 C8 A3  1 50 40 A0  1 
1A3C860 	8C  C  0  0 
0 value last-scan		\ Memory for detecting up transitions
1A3C864 	 0  0 6C 61 
1A3C868 	73 74 2D 73 63 61 6E 89 
1A3C870 	5C C8 A3  1 50 40 A0  1 
1A3C878 	90  C  0  0 

false value keyboard-probed?      \ Used to identify whether keyboard methods
1A3C87C 	 0  0  0 6B 
1A3C880 	65 79 62 6F 61 72 64 2D 
1A3C888 	70 72 6F 62 65 64 3F 90 
1A3C890 	74 C8 A3  1 50 40 A0  1 
1A3C898 	94  C  0  0 
				  \ have already been installed
false value keyboard-present?     \ Nonzero if the keyboard is operational
1A3C89C 	 0  0 6B 65 
1A3C8A0 	79 62 6F 61 72 64 2D 70 
1A3C8A8 	72 65 73 65 6E 74 3F 91 
1A3C8B0 	94 C8 A3  1 50 40 A0  1 
1A3C8B8 	98  C  0  0 
false value locked?		  \ Interrupt lockout for get-scan
1A3C8BC 	6C 6F 63 6B 
1A3C8C0 	65 64 3F 87 B4 C8 A3  1 
1A3C8C8 	50 40 A0  1 9C  C  0  0 

: lock    ( -- )  true  to locked?  ;
1A3C8D0 	 0  0  0 6C 6F 63 6B 84 
1A3C8D8 	C8 C8 A3  1 20 40 A0  1 
1A3C8E0 	 4 70 A0  1 B8 40 A0  1 
1A3C8E8 	C8 C8 A3  1 58 46 A0  1 
: unlock  ( -- )  false to locked?  ;
1A3C8F0 	 0 75 6E 6C 6F 63 6B 86 
1A3C8F8 	DC C8 A3  1 20 40 A0  1 
1A3C900 	18 70 A0  1 B8 40 A0  1 
1A3C908 	C8 C8 A3  1 58 46 A0  1 

\ Scan code queue
d# 100 constant /q
1A3C910 	 0 2F 71 82 FC C8 A3  1 
1A3C918 	68 40 A0  1 64  0  0  0 

variable head  0 head !
1A3C920 	 0  0  0 68 65 61 64 84 
1A3C928 	18 C9 A3  1 48 40 A0  1 
1A3C930 	A0  C  0  0 
variable tail  0 tail !
1A3C934 	 0  0  0 74 
1A3C938 	61 69 6C 84 2C C9 A3  1 
1A3C940 	48 40 A0  1 A4  C  0  0 
/q dup buffer: q
1A3C948 	 0  0 71 81 40 C9 A3  1 
1A3C950 	B4 A9 A0  1 A8  C  0  0 
1A3C958 	64  0  0  0 38 C8 A3  1 
1-     value   q-end
1A3C960 	 0  0 71 2D 65 6E 64 85 
1A3C968 	50 C9 A3  1 50 40 A0  1 
1A3C970 	AC  C  0  0 

: init-q  ( -- )  0 head !  0 tail !  q drop  /q 1- to q-end  ;
1A3C974 	 0 69 6E 69 
1A3C978 	74 2D 71 86 6C C9 A3  1 
1A3C980 	20 40 A0  1 70 6F A0  1 
1A3C988 	2C C9 A3  1 54 4D A0  1 
1A3C990 	70 6F A0  1 40 C9 A3  1 
1A3C998 	54 4D A0  1 50 C9 A3  1 
1A3C9A0 	30 49 A0  1 18 C9 A3  1 
1A3C9A8 	54 4B A0  1 B8 40 A0  1 
1A3C9B0 	6C C9 A3  1 58 46 A0  1 
: inc-q-ptr  ( pointer-addr -- )
1A3C9B8 	 0  0 69 6E 63 2D 71 2D 
1A3C9C0 	70 74 72 89 80 C9 A3  1 
1A3C9C8 	20 40 A0  1 
   dup @ q-end >=  if  0 swap !  else  /c swap +!  then
1A3C9CC 	40 49 A0  1 
1A3C9D0 	5C 4C A0  1 6C C9 A3  1 
1A3C9D8 	EC 48 A0  1 DC 41 A0  1 
1A3C9E0 	18  0  0  0 70 6F A0  1 
1A3C9E8 	68 49 A0  1 54 4D A0  1 
1A3C9F0 	C8 41 A0  1 10  0  0  0 
1A3C9F8 	10 51 A0  1 68 49 A0  1 
1A3CA00 	 C 4C A0  1 
;
1A3CA04 	58 46 A0  1 

: enque  ( new-entry -- )
1A3CA08 	 0  0 65 6E 71 75 65 85 
1A3CA10 	C8 C9 A3  1 20 40 A0  1 
   tail @  head @  2dup >  if  - q-end  else  1-  then  ( new-entry tail head )
1A3CA18 	40 C9 A3  1 5C 4C A0  1 
1A3CA20 	2C C9 A3  1 5C 4C A0  1 
1A3CA28 	C0 49 A0  1  4 48 A0  1 
1A3CA30 	DC 41 A0  1 14  0  0  0 
1A3CA38 	18 45 A0  1 6C C9 A3  1 
1A3CA40 	C8 41 A0  1  8  0  0  0 
1A3CA48 	54 4B A0  1 
   <>  if  q tail @ ca+ c!  tail inc-q-ptr  else  drop  then
1A3CA4C 	44 48 A0  1 
1A3CA50 	DC 41 A0  1 28  0  0  0 
1A3CA58 	50 C9 A3  1 40 C9 A3  1 
1A3CA60 	5C 4C A0  1  4 50 A0  1 
1A3CA68 	B8 4D A0  1 40 C9 A3  1 
1A3CA70 	C8 C9 A3  1 C8 41 A0  1 
1A3CA78 	 8  0  0  0 30 49 A0  1 
;
1A3CA80 	58 46 A0  1 

: deque?  ( -- false | entry true )
1A3CA84 	 0 64 65 71 
1A3CA88 	75 65 3F 86 14 CA A3  1 
1A3CA90 	20 40 A0  1 
   lock
1A3CA94 	DC C8 A3  1 
   head @  tail @  <>  if
1A3CA98 	2C C9 A3  1 5C 4C A0  1 
1A3CAA0 	40 C9 A3  1 5C 4C A0  1 
1A3CAA8 	44 48 A0  1 DC 41 A0  1 
1A3CAB0 	2C  0  0  0 
      q head @ ca+ c@   head inc-q-ptr  true
1A3CAB4 	50 C9 A3  1 
1A3CAB8 	2C C9 A3  1 5C 4C A0  1 
1A3CAC0 	 4 50 A0  1 C4 4C A0  1 
1A3CAC8 	2C C9 A3  1 C8 C9 A3  1 
1A3CAD0 	 4 70 A0  1 
   else
1A3CAD4 	C8 41 A0  1 
1A3CAD8 	 8  0  0  0 
      false
1A3CADC 	18 70 A0  1 
   then
   unlock
1A3CAE0 	FC C8 A3  1 
;
1A3CAE4 	58 46 A0  1 

false value shift?		\ True if the shift key is down
1A3CAE8 	 0 73 68 69 66 74 3F 86 
1A3CAF0 	90 CA A3  1 50 40 A0  1 
1A3CAF8 	B0  C  0  0 
false value ctrl?	  	\ True if the ctrl key is down
1A3CAFC 	 0  0 63 74 
1A3CB00 	72 6C 3F 85 F4 CA A3  1 
1A3CB08 	50 40 A0  1 B4  C  0  0 
false value mfii?               \ True if MF II extended keys
1A3CB10 	 0  0 6D 66 69 69 3F 85 
1A3CB18 	 8 CB A3  1 50 40 A0  1 
1A3CB20 	B8  C  0  0 
false value alt-gr?		\ True if the AltGr key is down
1A3CB24 	61 6C 74 2D 
1A3CB28 	67 72 3F 87 1C CB A3  1 
1A3CB30 	50 40 A0  1 BC  C  0  0 
-1 value dead-accent            \ The dead accent index (0-5) or -1
1A3CB38 	64 65 61 64 2D 61 63 63 
1A3CB40 	65 6E 74 8B 30 CB A3  1 
1A3CB48 	50 40 A0  1 C0  C  0  0 

0 value led-state
1A3CB50 	 0  0 6C 65 64 2D 73 74 
1A3CB58 	61 74 65 89 48 CB A3  1 
1A3CB60 	50 40 A0  1 C4  C  0  0 
: numlk?        ( -- flag )  led-state 2 and  0<>  ;
1A3CB68 	 0 6E 75 6D 6C 6B 3F 86 
1A3CB70 	60 CB A3  1 20 40 A0  1 
1A3CB78 	60 CB A3  1 90 6F A0  1 
1A3CB80 	5C 44 A0  1 44 47 A0  1 
1A3CB88 	58 46 A0  1 
: caps-lock?    ( -- flag )  led-state 4 and  0<>  ;
1A3CB8C 	 0 63 61 70 
1A3CB90 	73 2D 6C 6F 63 6B 3F 8A 
1A3CB98 	74 CB A3  1 20 40 A0  1 
1A3CBA0 	60 CB A3  1 B0 6F A0  1 
1A3CBA8 	5C 44 A0  1 44 47 A0  1 
1A3CBB0 	58 46 A0  1 
: scroll-lock?  ( -- flag )  led-state 1 and  0<>  ;
1A3CBB4 	 0  0  0 73 
1A3CBB8 	63 72 6F 6C 6C 2D 6C 6F 
1A3CBC0 	63 6B 3F 8C 9C CB A3  1 
1A3CBC8 	20 40 A0  1 60 CB A3  1 
1A3CBD0 	80 6F A0  1 5C 44 A0  1 
1A3CBD8 	44 47 A0  1 58 46 A0  1 

: init-data  ( -- )
1A3CBE0 	 0  0 69 6E 69 74 2D 64 
1A3CBE8 	61 74 61 89 C8 CB A3  1 
1A3CBF0 	20 40 A0  1 
   false to keyboard-present?
1A3CBF4 	18 70 A0  1 
1A3CBF8 	B8 40 A0  1 B4 C8 A3  1 
   false to shift?   false to ctrl?
1A3CC00 	18 70 A0  1 B8 40 A0  1 
1A3CC08 	F4 CA A3  1 18 70 A0  1 
1A3CC10 	B8 40 A0  1  8 CB A3  1 
   0 to last-scan
1A3CC18 	70 6F A0  1 B8 40 A0  1 
1A3CC20 	74 C8 A3  1 
   init-q
1A3CC24 	80 C9 A3  1 
;   
1A3CC28 	58 46 A0  1 

\ Frequently-used interfaces to parent (8042 controller) routines

: get-data   ( -- data | -1 )  " get-data" $call-parent  ;
1A3CC2C 	 0  0  0 67 
1A3CC30 	65 74 2D 64 61 74 61 88 
1A3CC38 	F0 CB A3  1 20 40 A0  1 
1A3CC40 	9C 53 A0  1  8 67 65 74 
1A3CC48 	2D 64 61 74 61  0  0  0 
1A3CC50 	DC 31 A2  1 58 46 A0  1 
: get-data?  ( -- false | data true )  " get-data?" $call-parent  ;
1A3CC58 	 0  0 67 65 74 2D 64 61 
1A3CC60 	74 61 3F 89 3C CC A3  1 
1A3CC68 	20 40 A0  1 9C 53 A0  1 
1A3CC70 	 9 67 65 74 2D 64 61 74 
1A3CC78 	61 3F  0  0 DC 31 A2  1 
1A3CC80 	58 46 A0  1 
: put-get-data  ( cmd -- data | -1 )  " put-get-data" $call-parent  ;
1A3CC84 	 0  0  0 70 
1A3CC88 	75 74 2D 67 65 74 2D 64 
1A3CC90 	61 74 61 8C 68 CC A3  1 
1A3CC98 	20 40 A0  1 9C 53 A0  1 
1A3CCA0 	 C 70 75 74 2D 67 65 74 
1A3CCA8 	2D 64 61 74 61  0  0  0 
1A3CCB0 	DC 31 A2  1 58 46 A0  1 

: clear-out-buf  ( -- )  " clear-out-buf" $call-parent  ;
1A3CCB8 	 0  0 63 6C 65 61 72 2D 
1A3CCC0 	6F 75 74 2D 62 75 66 8D 
1A3CCC8 	98 CC A3  1 20 40 A0  1 
1A3CCD0 	9C 53 A0  1  D 63 6C 65 
1A3CCD8 	61 72 2D 6F 75 74 2D 62 
1A3CCE0 	75 66  0  0 DC 31 A2  1 
1A3CCE8 	58 46 A0  1 

: timed-read  ( #ms -- true | data false )
1A3CCEC 	 0 74 69 6D 
1A3CCF0 	65 64 2D 72 65 61 64 8A 
1A3CCF8 	CC CC A3  1 20 40 A0  1 
   0  do
1A3CD00 	70 6F A0  1 88 42 A0  1 
1A3CD08 	2C  0  0  0 
      get-data?  if  unloop false exit  then
1A3CD0C 	68 CC A3  1 
1A3CD10 	DC 41 A0  1 10  0  0  0 
1A3CD18 	3C 42 A0  1 18 70 A0  1 
1A3CD20 	40 46 A0  1 
      1 ms
1A3CD24 	80 6F A0  1 
1A3CD28 	60 E0 A1  1 
   loop
1A3CD2C 	F8 41 A0  1 
1A3CD30 	DC FF FF FF 
   true
1A3CD34 	 4 70 A0  1 
;
1A3CD38 	58 46 A0  1 

0 value kbd-debug?
1A3CD3C 	 0 6B 62 64 
1A3CD40 	2D 64 65 62 75 67 3F 8A 
1A3CD48 	FC CC A3  1 50 40 A0  1 
1A3CD50 	C8  C  0  0 

\ This is fairly complicated to handle several possibilities.
\ In the usual case, where the response is ACK (fa), we return true on the top
\ Another case is a RETRY (fe) response - then we return "false false" so the
\ caller will continue to retry as long as we keep seeing RETRY.
\ Bytes that are neither fa nor fe are silently discarded.
\ If we timeout without seeing either fa or fe, we return "true false" so the
\ caller will retry a limited number of times before giving up.

: got-ack?  ( -- true | timeout? false )
1A3CD54 	 0  0  0 67 
1A3CD58 	6F 74 2D 61 63 6B 3F 88 
1A3CD60 	4C CD A3  1 20 40 A0  1 
   begin
      \ No response - retry once
      d# 50 timed-read  if  true false exit  then  ( data )
1A3CD68 	58 41 A0  1 32  0  0  0 
1A3CD70 	FC CC A3  1 DC 41 A0  1 
1A3CD78 	10  0  0  0  4 70 A0  1 
1A3CD80 	18 70 A0  1 40 46 A0  1 
      case
         h# fa of        true  exit  endof  \ ACK - exit without retry
1A3CD88 	58 41 A0  1 FA  0  0  0 
1A3CD90 	48 43 A0  1 14  0  0  0 
1A3CD98 	 4 70 A0  1 40 46 A0  1 
1A3CDA0 	6C 43 A0  1 2C  0  0  0 
         h# fe of  false false exit  endof  \ RETRY - retry as long as we keep getting fe
1A3CDA8 	58 41 A0  1 FE  0  0  0 
1A3CDB0 	48 43 A0  1 18  0  0  0 
1A3CDB8 	18 70 A0  1 18 70 A0  1 
1A3CDC0 	40 46 A0  1 6C 43 A0  1 
1A3CDC8 	 8  0  0  0 
         \ discard other characters
      endcase
1A3CDCC 	84 43 A0  1 
   again
1A3CDD0 	C8 41 A0  1 94 FF FF FF 
;
1A3CDD8 	58 46 A0  1 

: cmd  ( cmd -- )
1A3CDDC 	63 6D 64 83 
1A3CDE0 	64 CD A3  1 20 40 A0  1 
   1  begin                                 ( cmd #retries )
1A3CDE8 	80 6F A0  1 
      over  " put-data" $call-parent        ( cmd #retries )
1A3CDEC 	54 49 A0  1 
1A3CDF0 	9C 53 A0  1  8 70 75 74 
1A3CDF8 	2D 64 61 74 61  0  0  0 
1A3CE00 	DC 31 A2  1 
      got-ack?  if  2drop exit  then        ( cmd #retries timeout? )
1A3CE04 	64 CD A3  1 
1A3CE08 	DC 41 A0  1  C  0  0  0 
1A3CE10 	AC 49 A0  1 40 46 A0  1 

      \ Decrease the retry count if got-ack? timed out
      \ Otherwise got-ack? saw a RETRY response, in which case
      \ we retry without decrementing the count
      if  1-  then                          ( cmd #retries )
1A3CE18 	DC 41 A0  1  8  0  0  0 
1A3CE20 	54 4B A0  1 

   dup 0<  until                            ( cmd #retries )
1A3CE24 	40 49 A0  1 
1A3CE28 	64 47 A0  1 DC 41 A0  1 
1A3CE30 	BC FF FF FF 

   drop                                     ( cmd )
1A3CE34 	30 49 A0  1 
   kbd-debug?  if                           ( cmd )
1A3CE38 	4C CD A3  1 DC 41 A0  1 
1A3CE40 	34  0  0  0 
      ." Keyboard cmd " . ." failed" cr     ( )
1A3CE44 	20 7C A0  1 
1A3CE48 	 D 4B 65 79 62 6F 61 72 
1A3CE50 	64 20 63 6D 64 20  0  0 
1A3CE58 	94 7A A0  1 20 7C A0  1 
1A3CE60 	 6 66 61 69 6C 65 64  0 
1A3CE68 	80 6D A0  1 
   else                                     ( cmd )
1A3CE6C 	C8 41 A0  1 
1A3CE70 	 8  0  0  0 
      drop                                  ( )
1A3CE74 	30 49 A0  1 
   then                                     ( )
;
1A3CE78 	58 46 A0  1 

headers

\ Despite the manual's claim that this command can be executed at any time,
\ experience has shown that it does not work reliably.  Executing
\ cntlr-selftest, test-intf and reset seem to prepare the system.
\ kbd-reset (at least sometimes) is not sufficient preparation.
: set-scan-set  ( scan-set -- )  f0 cmd cmd  ;
1A3CE7C 	 0  0  0 73 
1A3CE80 	65 74 2D 73 63 61 6E 2D 
1A3CE88 	73 65 74 8C E4 CD A3  1 
1A3CE90 	20 40 A0  1 58 41 A0  1 
1A3CE98 	F0  0  0  0 E4 CD A3  1 
1A3CEA0 	E4 CD A3  1 58 46 A0  1 

\ The return value is:
\   1, 2, 3	Scan set 1, 2, or 3, h#40 bit in the 8042 cmd register clear
\   43		Scan set 1           h#40 bit set
\   41		Scan set 2           h#40 bit set
\   3f		Scan set 3           h#40 bit set
\ When the h#40 bit is set, the 8042 translates scan set 2 coming from the
\ keyboard to scan set 1 (when read from the 8042).  One might suspect from
\ the above encodings that it might also translate scan set 1 from the keyboard
\ into scan set 3.

: get-scan-set  ( -- scan-set )  lock  0 set-scan-set  get-data  unlock  ;
1A3CEA8 	 0  0  0 67 65 74 2D 73 
1A3CEB0 	63 61 6E 2D 73 65 74 8C 
1A3CEB8 	90 CE A3  1 20 40 A0  1 
1A3CEC0 	DC C8 A3  1 70 6F A0  1 
1A3CEC8 	90 CE A3  1 3C CC A3  1 
1A3CED0 	FC C8 A3  1 58 46 A0  1 

\ Re-initialize the keyboard and controller with the following:
\
\ 1.    Disable keyboard interface.
\ 2.	Perform controller self-test.  Report an error on failure.
\       (Selftest re-enables keyboard interface.)
\ 3.	Perform keyboard interface test.  Report an error on failure.
\ 4.	Reset the keyboard which results in the selection of Scan Set 2.  Report
\	an error on failure.
\ 5.	Perform a keyboard echo.  Report an error on failure.
\ 6.	Flash the three LEDs.

: default-disable-kbd  ( -- )  h# f5 cmd  ;
1A3CED8 	64 65 66 61 75 6C 74 2D 
1A3CEE0 	64 69 73 61 62 6C 65 2D 
1A3CEE8 	6B 62 64 93 BC CE A3  1 
1A3CEF0 	20 40 A0  1 58 41 A0  1 
1A3CEF8 	F5  0  0  0 E4 CD A3  1 
1A3CF00 	58 46 A0  1 
: enable-scan  ( -- )  h# f4 cmd  ;
1A3CF04 	65 6E 61 62 
1A3CF08 	6C 65 2D 73 63 61 6E 8B 
1A3CF10 	F0 CE A3  1 20 40 A0  1 
1A3CF18 	58 41 A0  1 F4  0  0  0 
1A3CF20 	E4 CD A3  1 58 46 A0  1 

\ Empirically, the delays help some keyboards to pass the echo test
: echo?  ( -- failed-echo? )
1A3CF28 	 0  0 65 63 68 6F 3F 85 
1A3CF30 	14 CF A3  1 20 40 A0  1 
   d# 32 ms  h# ee put-get-data h# ee <>  d# 32 ms
1A3CF38 	58 41 A0  1 20  0  0  0 
1A3CF40 	60 E0 A1  1 58 41 A0  1 
1A3CF48 	EE  0  0  0 98 CC A3  1 
1A3CF50 	58 41 A0  1 EE  0  0  0 
1A3CF58 	44 48 A0  1 58 41 A0  1 
1A3CF60 	20  0  0  0 60 E0 A1  1 
;
1A3CF68 	58 46 A0  1 
: set-leds  ( led-mask -- )  lock  dup to led-state h# ed cmd cmd  unlock  ;
1A3CF6C 	 0  0  0 73 
1A3CF70 	65 74 2D 6C 65 64 73 88 
1A3CF78 	34 CF A3  1 20 40 A0  1 
1A3CF80 	DC C8 A3  1 40 49 A0  1 
1A3CF88 	B8 40 A0  1 60 CB A3  1 
1A3CF90 	58 41 A0  1 ED  0  0  0 
1A3CF98 	E4 CD A3  1 E4 CD A3  1 
1A3CFA0 	FC C8 A3  1 58 46 A0  1 
: toggle-leds  ( led-mask -- )  led-state xor  set-leds  ;
1A3CFA8 	74 6F 67 67 6C 65 2D 6C 
1A3CFB0 	65 64 73 8B 7C CF A3  1 
1A3CFB8 	20 40 A0  1 60 CB A3  1 
1A3CFC0 	84 44 A0  1 7C CF A3  1 
1A3CFC8 	58 46 A0  1 

: kbd-reset  ( -- failed-reset? )
1A3CFCC 	 0  0 6B 62 
1A3CFD0 	64 2D 72 65 73 65 74 89 
1A3CFD8 	B8 CF A3  1 20 40 A0  1 
   lock
1A3CFE0 	DC C8 A3  1 
   \ Send kbd reset command
   h# ff cmd
1A3CFE4 	58 41 A0  1 
1A3CFE8 	FF  0  0  0 E4 CD A3  1 
   get-data  h# aa <>
1A3CFF0 	3C CC A3  1 58 41 A0  1 
1A3CFF8 	AA  0  0  0 44 48 A0  1 
   unlock
1A3D000 	FC C8 A3  1 
;
1A3D004 	58 46 A0  1 

: do-esc  ( char -- ESC )
1A3D008 	 0 64 6F 2D 65 73 63 86 
1A3D010 	DC CF A3  1 20 40 A0  1 
\   ascii-queue c!  ascii [ ascii-queue 1+ c!  2 to #queued   h# 1b  ( ESC )
   ascii-queue c!  1 to #queued  h# 9b  ( Unicode-CSI )
1A3D018 	38 C8 A3  1 B8 4D A0  1 
1A3D020 	80 6F A0  1 B8 40 A0  1 
1A3D028 	20 C8 A3  1 58 41 A0  1 
1A3D030 	9B  0  0  0 
;
1A3D034 	58 46 A0  1 
: do-func  ( char -- ESC )
1A3D038 	64 6F 2D 66 75 6E 63 87 
1A3D040 	14 D0 A3  1 20 40 A0  1 
   ascii-queue c!  ascii O ascii-queue 1+ c!  2 to #queued  h# 9b
1A3D048 	38 C8 A3  1 B8 4D A0  1 
1A3D050 	58 41 A0  1 4F  0  0  0 
1A3D058 	38 C8 A3  1 30 4B A0  1 
1A3D060 	B8 4D A0  1 90 6F A0  1 
1A3D068 	B8 40 A0  1 20 C8 A3  1 
1A3D070 	58 41 A0  1 9B  0  0  0 
;
1A3D078 	58 46 A0  1 
\ The following keymaps map scan codes to ASCII codes.  In those cases
\ where the scan code represents a key for which there is no ASCII equivalent,
\ the table contains a 0 byte.  This use of 0 does not prevent the generation
\ ASCII NUL (whose numerical value is 0) because control characters are
\ mostly generated by masking bits off of printable entries.  (The only
\ exceptions are Tab, BackSpace, Escape, and Return, which are the only
\ control characters that are directly generated by single keys on a
\ PC keyboard.)

\ "Syntactic sugar" to make keymaps easier to read and write
: ch  ( "char" -- )  char c,  ;
1A3D07C 	 0 63 68 82 
1A3D080 	44 D0 A3  1 20 40 A0  1 
1A3D088 	58 95 A0  1 B8 55 A0  1 
1A3D090 	58 46 A0  1 
: xx  ( -- )  0 c,  ;
1A3D094 	 0 78 78 82 
1A3D098 	84 D0 A3  1 20 40 A0  1 
1A3D0A0 	70 6F A0  1 B8 55 A0  1 
1A3D0A8 	58 46 A0  1 

0 value keymap  ( -- adr )
1A3D0AC 	 0 6B 65 79 
1A3D0B0 	6D 61 70 86 9C D0 A3  1 
1A3D0B8 	50 40 A0  1 CC  C  0  0 
h# 60 3 * 1+ constant /keymap  \ The maximum size of a keymap
1A3D0C0 	2F 6B 65 79 6D 61 70 87 
1A3D0C8 	B8 D0 A3  1 68 40 A0  1 
1A3D0D0 	21  1  0  0 

vocabulary keyboards
1A3D0D4 	 0  0 6B 65 
1A3D0D8 	79 62 6F 61 72 64 73 89 
1A3D0E0 	CC D0 A3  1 E0 B6 A0  1 
1A3D0E8 	D0  C  0  0 6C 6B A3  1 
1A3D0F0 	 0  0  0  0 

also keyboards definitions
create us
1A3D0F4 	 0 75 73 82 
1A3D0F8 	 0  0 A0  1 30 40 A0  1 
   ch E  ch N  \ Language
1A3D100 	45 4E 
   2 c,  \ #submaps
1A3D102 	 2 
\ Unshifted
  (  0 )   xx     1b c,  ch 1   ch 2   ch 3   ch 4   ch 5   ch 6
1A3D103 	 0 1B 31 32 33 
1A3D108 	34 35 36 
  (  8 )   ch 7   ch 8   ch 9   ch 0   ch -   ch =    8 c,   9 c,
1A3D10B 	37 38 39 30 2D 
1A3D110 	3D  8  9 
  ( 10 )   ch q   ch w   ch e   ch r   ch t   ch y   ch u   ch i
1A3D113 	71 77 65 72 74 
1A3D118 	79 75 69 
  ( 18 )   ch o   ch p   ch [   ch ]    d c,   2 c,  ch a   ch s
1A3D11B 	6F 70 5B 5D  D 
1A3D120 	 2 61 73 
  ( 20 )   ch d   ch f   ch g   ch h   ch j   ch k   ch l   ch ;
1A3D123 	64 66 67 68 6A 
1A3D128 	6B 6C 3B 
  ( 28 )   ch '   ch `    1 c,  ch \   ch z   ch x   ch c   ch v
1A3D12B 	27 60  1 5C 7A 
1A3D130 	78 63 76 
  ( 30 )   ch b   ch n   ch m   ch ,   ch .   ch /    1 c,  ch *
1A3D133 	62 6E 6D 2C 2E 
1A3D138 	2F  1 2A 
  ( 38 )    3 c,  20 c,   4 c,  81 c,  82 c,  83 c,  84 c,  85 c,
1A3D13B 	 3 20  4 81 82 
1A3D140 	83 84 85 
  ( 40 )   86 c,  87 c,  88 c,  89 c,  8a c,   5 c,   6 c,  97 c,
1A3D143 	86 87 88 89 8A 
1A3D148 	 5  6 97 
  ( 48 )   98 c,  99 c,  ch -   94 c,  95 c,  96 c,  ch +   91 c,
1A3D14B 	98 99 2D 94 95 
1A3D150 	96 2B 91 
  ( 50 )   92 c,  93 c,  90 c,  9a c,  xx     xx     ch <   8b c,
1A3D153 	92 93 90 9A  0 
1A3D158 	 0 3C 8B 
  ( 58 )   8c c,  xx     xx     xx     xx     xx     xx     xx
1A3D15B 	8C  0  0  0  0 
1A3D160 	 0  0  0 
\ Shifted
  (  0 )   xx     1b c,  ch !   ch @   ch #   ch $   ch %   ch ^
1A3D163 	 0 1B 21 40 23 
1A3D168 	24 25 5E 
  (  8 )   ch &   ch *   ch (   ch )   ch _   ch +    8 c,   9 c,
1A3D16B 	26 2A 28 29 5F 
1A3D170 	2B  8  9 
  ( 10 )   ch Q   ch W   ch E   ch R   ch T   ch Y   ch U   ch I
1A3D173 	51 57 45 52 54 
1A3D178 	59 55 49 
  ( 18 )   ch O   ch P   ch {   ch }   xx     xx     ch A   ch S
1A3D17B 	4F 50 7B 7D  0 
1A3D180 	 0 41 53 
  ( 20 )   ch D   ch F   ch G   ch H   ch J   ch K   ch L   ch :
1A3D183 	44 46 47 48 4A 
1A3D188 	4B 4C 3A 
  ( 28 )   ch "   ch ~   xx     ch |   ch Z   ch X   ch C   ch V
1A3D18B 	22 7E  0 7C 5A 
1A3D190 	58 43 56 
  ( 30 )   ch B   ch N   ch M   ch <   ch >   ch ?   xx     xx
1A3D193 	42 4E 4D 3C 3E 
1A3D198 	3F  0  0 
  ( 38 )   xx     20 c,  xx     8b c,  8c c,  xx     xx     xx
1A3D19B 	 0 20  0 8B 8C 
1A3D1A0 	 0  0  0 
  ( 40 )   xx     xx     xx     xx     xx     xx     xx     97 c,
1A3D1A3 	 0  0  0  0  0 
1A3D1A8 	 0  0 97 
  ( 48 )   98 c,  99 c,  xx     94 c,  95 c,  96 c,  xx     91 c,
1A3D1AB 	98 99  0 94 95 
1A3D1B0 	96  0 91 
  ( 50 )   92 c,  93 c,  90 c,  9a c,  xx     xx     ch >   8b c,
1A3D1B3 	92 93 90 9A  0 
1A3D1B8 	 0 3E 8B 
  ( 58 )   8c c,  xx     xx     xx     xx     xx     xx     xx
1A3D1BB 	8C  0  0  0  0 
1A3D1C0 	 0  0  0 

previous definitions

: ?set-property  ( value$ name$ -- )
1A3D1C3 	 0  0  0 3F 73 
1A3D1C8 	65 74 2D 70 72 6F 70 65 
1A3D1D0 	72 74 79 8D E4 D0 A3  1 
1A3D1D8 	20 40 A0  1 
   2swap 2over get-my-property  0=  if   ( name$ value$ name$ adr1 len1 )
1A3D1DC 	F4 49 A0  1 
1A3D1E0 	D8 49 A0  1 1C 34 A2  1 
1A3D1E8 	24 47 A0  1 DC 41 A0  1 
1A3D1F0 	24  0  0  0 
      get-encoded-string  2over $=  if   ( name$ value$ )
1A3D1F4 	24 F7 A1  1 
1A3D1F8 	D8 49 A0  1 88 8D A0  1 
1A3D200 	DC 41 A0  1 10  0  0  0 
         2drop 2drop exit                ( )
1A3D208 	AC 49 A0  1 AC 49 A0  1 
1A3D210 	40 46 A0  1 
      then                               ( name$ value$ )
   then                                  ( name$ value$ )
   encode-string 2swap property          ( )
1A3D214 	A0 F6 A1  1 
1A3D218 	F4 49 A0  1 BC 14 A2  1 
;
1A3D220 	58 46 A0  1 
0 instance value oem-keymap
1A3D224 	 0 6F 65 6D 
1A3D228 	2D 6B 65 79 6D 61 70 8A 
1A3D230 	D8 D1 A3  1 C0 FE A1  1 
1A3D238 	18  0  0  0 
: (set-keyboard)  ( adr len xt -- )
1A3D23C 	 0 28 73 65 
1A3D240 	74 2D 6B 65 79 62 6F 61 
1A3D248 	72 64 29 8E 34 D2 A3  1 
1A3D250 	20 40 A0  1 
   -rot                                              ( xt adr len )
1A3D254 	94 49 A0  1 
   " keyboard-type" ?set-property                    ( xt )
1A3D258 	9C 53 A0  1  D 6B 65 79 
1A3D260 	62 6F 61 72 64 2D 74 79 
1A3D268 	70 65  0  0 D8 D1 A3  1 
   execute                                           ( adr )
1A3D270 	98 41 A0  1 
   dup 2 " language" ?set-property                   ( adr )
1A3D274 	40 49 A0  1 
1A3D278 	90 6F A0  1 9C 53 A0  1 
1A3D280 	 8 6C 61 6E 67 75 61 67 
1A3D288 	65  0  0  0 D8 D1 A3  1 
   2+ to keymap                                      ( )
1A3D290 	40 4B A0  1 B8 40 A0  1 
1A3D298 	B8 D0 A3  1 
;
1A3D29C 	58 46 A0  1 
: set-keyboard  ( adr len -- )
1A3D2A0 	 0  0  0 73 65 74 2D 6B 
1A3D2A8 	65 79 62 6F 61 72 64 8C 
1A3D2B0 	50 D2 A3  1 20 40 A0  1 
   2dup ['] keyboards $vfind  0=  if                       ( adr len )
1A3D2B8 	C0 49 A0  1 60 53 A0  1 
1A3D2C0 	E4 D0 A3  1 5C BB A0  1 
1A3D2C8 	24 47 A0  1 DC 41 A0  1 
1A3D2D0 	18  0  0  0 
      2drop " us" [ also keyboards ] ['] us  [ previous ]  ( adr' len' xt )
1A3D2D4 	AC 49 A0  1 
1A3D2D8 	9C 53 A0  1  2 75 73  0 
1A3D2E0 	60 53 A0  1 FC D0 A3  1 
   then                                                    ( adr len xt )
   (set-keyboard)
1A3D2E8 	50 D2 A3  1 
;
1A3D2EC 	58 46 A0  1 
: ?free-keymap  ( -- )
1A3D2F0 	 0  0  0 3F 66 72 65 65 
1A3D2F8 	2D 6B 65 79 6D 61 70 8C 
1A3D300 	B4 D2 A3  1 20 40 A0  1 
   oem-keymap  if  oem-keymap  /keymap  free-mem  then
1A3D308 	34 D2 A3  1 DC 41 A0  1 
1A3D310 	10  0  0  0 34 D2 A3  1 
1A3D318 	CC D0 A3  1  8 6D A0  1 
   0 to oem-keymap
1A3D320 	70 6F A0  1 48 B8 A1  1 
1A3D328 	34 D2 A3  1 
;
1A3D32C 	58 46 A0  1 

: choose-type  ( -- )
1A3D330 	63 68 6F 6F 73 65 2D 74 
1A3D338 	79 70 65 8B  4 D3 A3  1 
1A3D340 	20 40 A0  1 
   my-args  dup  if
1A3D344 	10  7 A2  1 
1A3D348 	40 49 A0  1 DC 41 A0  1 
1A3D350 	28  0  0  0 
      [char] , left-parse-string  2swap 2drop  ( $ )
1A3D354 	58 41 A0  1 
1A3D358 	2C  0  0  0 44 D7 A0  1 
1A3D360 	F4 49 A0  1 AC 49 A0  1 
      set-keyboard
1A3D368 	B4 D2 A3  1 
      exit
1A3D36C 	40 46 A0  1 
   else
1A3D370 	C8 41 A0  1  8  0  0  0 
      2drop
1A3D378 	AC 49 A0  1 
   then

   " pc-keymap" $getenv  0=  if    \ Property exists ( adr len )
1A3D37C 	9C 53 A0  1 
1A3D380 	 9 70 63 2D 6B 65 79 6D 
1A3D388 	61 70  0  0 48 6D A0  1 
1A3D390 	24 47 A0  1 DC 41 A0  1 
1A3D398 	7C  0  0  0 
      decode-string " keyboard-type" ?set-property   ( adr' len' )
1A3D39C 	FC F6 A1  1 
1A3D3A0 	9C 53 A0  1  D 6B 65 79 
1A3D3A8 	62 6F 61 72 64 2D 74 79 
1A3D3B0 	70 65  0  0 D8 D1 A3  1 
      2 decode-bytes " language" ?set-property       ( adr' len' )
1A3D3B8 	90 6F A0  1 68 F6 A1  1 
1A3D3C0 	9C 53 A0  1  8 6C 61 6E 
1A3D3C8 	67 75 61 67 65  0  0  0 
1A3D3D0 	D8 D1 A3  1 
      ?free-keymap
1A3D3D4 	 4 D3 A3  1 
      /keymap alloc-mem to oem-keymap                ( adr' len' )
1A3D3D8 	CC D0 A3  1 F0 6C A0  1 
1A3D3E0 	48 B8 A1  1 34 D2 A3  1 
      oem-keymap /keymap 0 fill                      ( adr' len' )
1A3D3E8 	34 D2 A3  1 CC D0 A3  1 
1A3D3F0 	70 6F A0  1 8C 4E A0  1 
      oem-keymap swap move                           ( )
1A3D3F8 	34 D2 A3  1 68 49 A0  1 
1A3D400 	F4 4A A0  1 
      oem-keymap to keymap                           ( )
1A3D404 	34 D2 A3  1 
1A3D408 	B8 40 A0  1 B8 D0 A3  1 
      exit
1A3D410 	40 46 A0  1 
   then


   " us" set-keyboard
1A3D414 	9C 53 A0  1 
1A3D418 	 2 75 73  0 B4 D2 A3  1 
\    pc-keyboard-type set-keyboard
;
1A3D420 	58 46 A0  1 

: map?  ( scancode map-adr -- scancode false | char true )
1A3D424 	 0  0  0 6D 
1A3D428 	61 70 3F 84 40 D3 A3  1 
1A3D430 	20 40 A0  1 
   >r
1A3D434 	BC 45 A0  1 
   dup  r@ c@  r@ 1+ c@  between  if      ( scancode )
1A3D438 	40 49 A0  1 E4 45 A0  1 
1A3D440 	C4 4C A0  1 E4 45 A0  1 
1A3D448 	30 4B A0  1 C4 4C A0  1 
1A3D450 	D8 70 A0  1 DC 41 A0  1 
1A3D458 	2C  0  0  0 
      r@ c@ -  r> 2+ + c@  true           ( char true )
1A3D45C 	E4 45 A0  1 
1A3D460 	C4 4C A0  1 18 45 A0  1 
1A3D468 	D0 45 A0  1 40 4B A0  1 
1A3D470 	 4 45 A0  1 C4 4C A0  1 
1A3D478 	 4 70 A0  1 
   else                                   ( scancode )
1A3D47C 	C8 41 A0  1 
1A3D480 	10  0  0  0 
      r> drop false
1A3D484 	D0 45 A0  1 
1A3D488 	30 49 A0  1 18 70 A0  1 
   then
;
1A3D490 	58 46 A0  1 
   
\ The escape sequences implied by the following two tables are as
\ defined by the Windows NT "Portable Boot Loader" (formerly known
\ as ARC firmware) spec. They were subsequently adopted in some PowerPC
\ Open Firmware bindings. 
create move-map  90 c,  9a c,
1A3D494 	 0  0  0 6D 
1A3D498 	6F 76 65 2D 6D 61 70 88 
1A3D4A0 	30 D4 A3  1 30 40 A0  1 
1A3D4A8 	90 9A 
   ch @   \ Insert
1A3D4AA 	40 
   ch K   \ End
1A3D4AB 	4B 
   ch B   \ Down
1A3D4AC 	42 
   ch /   \ Page Down
1A3D4AD 	2F 
   ch D   \ Left
1A3D4AE 	44 
   ch 5   \ bogus
1A3D4AF 	35 
   ch C   \ Right
1A3D4B0 	43 
   ch H   \ Home
1A3D4B1 	48 
   ch A   \ Up
1A3D4B2 	41 
   ch ?   \ Page Up
1A3D4B3 	3F 
   ch P   \ Delete  (use DEL, 7f)
1A3D4B4 	50 

create func-map  81 c,  8c c,
1A3D4B5 	 0  0 66 
1A3D4B8 	75 6E 63 2D 6D 61 70 88 
1A3D4C0 	A4 D4 A3  1 30 40 A0  1 
1A3D4C8 	81 8C 
   ch P   \ F1
1A3D4CA 	50 
   ch Q   \ F2
1A3D4CB 	51 
   ch W   \ F3
1A3D4CC 	57 
   ch x   \ F4
1A3D4CD 	78 
   ch t   \ F5
1A3D4CE 	74 
   ch u   \ F6
1A3D4CF 	75 
   ch q   \ F7
1A3D4D0 	71 
   ch r   \ F8
1A3D4D1 	72 
   ch p   \ F9
1A3D4D2 	70 
   ch M   \ F10
1A3D4D3 	4D 
   ch A   \ F11
1A3D4D4 	41 
   ch B   \ F12
1A3D4D5 	42 

: get-special-key  ( char -- false | ASCII-code true )
1A3D4D6 	 0  0 
1A3D4D8 	67 65 74 2D 73 70 65 63 
1A3D4E0 	69 61 6C 2D 6B 65 79 8F 
1A3D4E8 	C4 D4 A3  1 20 40 A0  1 
   func-map  map?  if  do-func true  exit  then  
1A3D4F0 	C4 D4 A3  1 30 D4 A3  1 
1A3D4F8 	DC 41 A0  1 10  0  0  0 
1A3D500 	44 D0 A3  1  4 70 A0  1 
1A3D508 	40 46 A0  1 
   move-map  map?  if  do-esc  true  exit  then
1A3D50C 	A4 D4 A3  1 
1A3D510 	30 D4 A3  1 DC 41 A0  1 
1A3D518 	10  0  0  0 14 D0 A3  1 
1A3D520 	 4 70 A0  1 40 46 A0  1 
   ?dup 0<>
1A3D528 	B4 70 A0  1 44 47 A0  1 
;
1A3D530 	58 46 A0  1 

\ Handle reports of keys already down.
\ Also, some keyboards send an unsolicited "aa" code after power is applied,
\ indicating successful completion of the keyboard's internal selftest, which
\ we ignore.

0 value ctrl-down?
1A3D534 	 0 63 74 72 
1A3D538 	6C 2D 64 6F 77 6E 3F 8A 
1A3D540 	EC D4 A3  1 50 40 A0  1 
1A3D548 	D4  C  0  0 
0 value alt-down?
1A3D54C 	 0  0 61 6C 
1A3D550 	74 2D 64 6F 77 6E 3F 89 
1A3D558 	44 D5 A3  1 50 40 A0  1 
1A3D560 	D8  C  0  0 
0 value initial-key
1A3D564 	69 6E 69 74 
1A3D568 	69 61 6C 2D 6B 65 79 8B 
1A3D570 	5C D5 A3  1 50 40 A0  1 
1A3D578 	DC  C  0  0 

\ These scancodes are from set 1.
: handle-initial-scan  ( scancode -- )
1A3D57C 	68 61 6E 64 
1A3D580 	6C 65 2D 69 6E 69 74 69 
1A3D588 	61 6C 2D 73 63 61 6E 93 
1A3D590 	74 D5 A3  1 20 40 A0  1 
   case
      h# 1d  of  true  to ctrl-down?   endof
1A3D598 	58 41 A0  1 1D  0  0  0 
1A3D5A0 	48 43 A0  1 18  0  0  0 
1A3D5A8 	 4 70 A0  1 B8 40 A0  1 
1A3D5B0 	44 D5 A3  1 6C 43 A0  1 
1A3D5B8 	A8  0  0  0 
      h# 38  of  true  to alt-down?    endof
1A3D5BC 	58 41 A0  1 
1A3D5C0 	38  0  0  0 48 43 A0  1 
1A3D5C8 	18  0  0  0  4 70 A0  1 
1A3D5D0 	B8 40 A0  1 5C D5 A3  1 
1A3D5D8 	6C 43 A0  1 84  0  0  0 
      h# 9d  of  false to ctrl-down?   endof
1A3D5E0 	58 41 A0  1 9D  0  0  0 
1A3D5E8 	48 43 A0  1 18  0  0  0 
1A3D5F0 	18 70 A0  1 B8 40 A0  1 
1A3D5F8 	44 D5 A3  1 6C 43 A0  1 
1A3D600 	60  0  0  0 
      h# b8  of  false to alt-down?    endof
1A3D604 	58 41 A0  1 
1A3D608 	B8  0  0  0 48 43 A0  1 
1A3D610 	18  0  0  0 18 70 A0  1 
1A3D618 	B8 40 A0  1 5C D5 A3  1 
1A3D620 	6C 43 A0  1 3C  0  0  0 
      ( default )
      dup  h# 60 <=  if  dup keymap 1+ + c@  to initial-key  then
1A3D628 	40 49 A0  1 58 41 A0  1 
1A3D630 	60  0  0  0  C 49 A0  1 
1A3D638 	DC 41 A0  1 20  0  0  0 
1A3D640 	40 49 A0  1 B8 D0 A3  1 
1A3D648 	30 4B A0  1  4 45 A0  1 
1A3D650 	C4 4C A0  1 B8 40 A0  1 
1A3D658 	74 D5 A3  1 
   endcase
1A3D65C 	84 43 A0  1 
;
1A3D660 	58 46 A0  1 

: clear-state  ( -- )
1A3D664 	63 6C 65 61 
1A3D668 	72 2D 73 74 61 74 65 8B 
1A3D670 	94 D5 A3  1 20 40 A0  1 
   false to ctrl-down?
1A3D678 	18 70 A0  1 B8 40 A0  1 
1A3D680 	44 D5 A3  1 
   false to alt-down?
1A3D684 	18 70 A0  1 
1A3D688 	B8 40 A0  1 5C D5 A3  1 
   ff    to initial-key
1A3D690 	58 41 A0  1 FF  0  0  0 
1A3D698 	B8 40 A0  1 74 D5 A3  1 
   " us" set-keyboard
1A3D6A0 	9C 53 A0  1  2 75 73  0 
1A3D6A8 	B4 D2 A3  1 
\   choose-type
;
1A3D6AC 	58 46 A0  1 
: consume  ( -- )   begin  5 timed-read  0=  while  drop  repeat  ;
1A3D6B0 	63 6F 6E 73 75 6D 65 87 
1A3D6B8 	74 D6 A3  1 20 40 A0  1 
1A3D6C0 	C0 6F A0  1 FC CC A3  1 
1A3D6C8 	24 47 A0  1 DC 41 A0  1 
1A3D6D0 	10  0  0  0 30 49 A0  1 
1A3D6D8 	C8 41 A0  1 E4 FF FF FF 
1A3D6E0 	58 46 A0  1 

: get-initial-state  ( -- )
1A3D6E4 	 0  0 67 65 
1A3D6E8 	74 2D 69 6E 69 74 69 61 
1A3D6F0 	6C 2D 73 74 61 74 65 91 
1A3D6F8 	BC D6 A3  1 20 40 A0  1 
   d# 200 ms      \ Give the keyboard time to respond
1A3D700 	58 41 A0  1 C8  0  0  0 
1A3D708 	60 E0 A1  1 

   \ 5 ms is less than the standard auto-repeat rate
   begin  5 timed-read  0=  while  handle-initial-scan  repeat
1A3D70C 	C0 6F A0  1 
1A3D710 	FC CC A3  1 24 47 A0  1 
1A3D718 	DC 41 A0  1 10  0  0  0 
1A3D720 	94 D5 A3  1 C8 41 A0  1 
1A3D728 	E4 FF FF FF 

   default-disable-kbd	\ Clear last typematic key, if any
1A3D72C 	F0 CE A3  1 
   consume
1A3D730 	BC D6 A3  1 
;
1A3D734 	58 46 A0  1 

: initial-key?  ( -- false | char true )
1A3D738 	 0  0  0 69 6E 69 74 69 
1A3D740 	61 6C 2D 6B 65 79 3F 8C 
1A3D748 	FC D6 A3  1 20 40 A0  1 
   initial-key ff =  if  false exit  then
1A3D750 	74 D5 A3  1 58 41 A0  1 
1A3D758 	FF  0  0  0 24 48 A0  1 
1A3D760 	DC 41 A0  1  C  0  0  0 
1A3D768 	18 70 A0  1 40 46 A0  1 

   \ 5 and 6 are the codes for BREAK and CTRL-BREAK, respectively
   \ -1 as a return value means "break"
   initial-key  5 6 between  if  -1 true exit  then
1A3D770 	74 D5 A3  1 C0 6F A0  1 
1A3D778 	D0 6F A0  1 D8 70 A0  1 
1A3D780 	DC 41 A0  1 14  0  0  0 
1A3D788 	58 41 A0  1 FF FF FF FF 
1A3D790 	 4 70 A0  1 40 46 A0  1 

   \ 81..8c are the function keys F1..F12
   initial-key  h# 81  h# 8c between  if  initial-key true  exit  then
1A3D798 	74 D5 A3  1 58 41 A0  1 
1A3D7A0 	81  0  0  0 58 41 A0  1 
1A3D7A8 	8C  0  0  0 D8 70 A0  1 
1A3D7B0 	DC 41 A0  1 10  0  0  0 
1A3D7B8 	74 D5 A3  1  4 70 A0  1 
1A3D7C0 	40 46 A0  1 

   alt-down?  if  initial-key true exit  then
1A3D7C4 	5C D5 A3  1 
1A3D7C8 	DC 41 A0  1 10  0  0  0 
1A3D7D0 	74 D5 A3  1  4 70 A0  1 
1A3D7D8 	40 46 A0  1 
   false
1A3D7DC 	18 70 A0  1 
;
1A3D7E0 	58 46 A0  1 

: reset  ( -- )
1A3D7E4 	 0  0 72 65 
1A3D7E8 	73 65 74 85 4C D7 A3  1 
1A3D7F0 	20 40 A0  1 
   init-data
1A3D7F4 	F0 CB A3  1 
   clear-state
1A3D7F8 	74 D6 A3  1 
[ifdef] ?olpc-keyboard
   ?olpc-keyboard
[else]
   get-initial-state
1A3D7FC 	FC D6 A3  1 

   \ Test the keyboard interface clock and data lines
   " test-lines" $call-parent  if  false to keyboard-present? exit  then
1A3D800 	9C 53 A0  1  A 74 65 73 
1A3D808 	74 2D 6C 69 6E 65 73  0 
1A3D810 	DC 31 A2  1 DC 41 A0  1 
1A3D818 	14  0  0  0 18 70 A0  1 
1A3D820 	B8 40 A0  1 B4 C8 A3  1 
1A3D828 	40 46 A0  1 
   consume
1A3D82C 	BC D6 A3  1 

   kbd-reset  if
1A3D830 	DC CF A3  1 DC 41 A0  1 
1A3D838 	18  0  0  0 
      false to keyboard-present?
1A3D83C 	18 70 A0  1 
1A3D840 	B8 40 A0  1 B4 C8 A3  1 
   else
1A3D848 	C8 41 A0  1 48  0  0  0 
      get-initial-state     \ Handle reports of keys already down
1A3D850 	FC D6 A3  1 

      echo?  dup 0= to keyboard-present?  if
1A3D854 	34 CF A3  1 
1A3D858 	40 49 A0  1 24 47 A0  1 
1A3D860 	B8 40 A0  1 B4 C8 A3  1 
1A3D868 	DC 41 A0  1 28  0  0  0 
         ." Failed keyboard echo test" cr
1A3D870 	20 7C A0  1 19 46 61 69 
1A3D878 	6C 65 64 20 6B 65 79 62 
1A3D880 	6F 61 72 64 20 65 63 68 
1A3D888 	6F 20 74 65 73 74  0  0 
1A3D890 	80 6D A0  1 
      then

\     7 set-leds  d# 100 ms  0 set-leds
   then

   \ Leave the keyboard in scan set 2 (its default state), but also leave
   \ the 8042 in the mode where it translates to scan set 1.

   keyboard-present?  if  enable-scan  then
1A3D894 	B4 C8 A3  1 
1A3D898 	DC 41 A0  1  8  0  0  0 
1A3D8A0 	14 CF A3  1 
[then]
   true to keyboard-probed?
1A3D8A4 	 4 70 A0  1 
1A3D8A8 	B8 40 A0  1 94 C8 A3  1 
;
1A3D8B0 	58 46 A0  1 

\ Without doing unnecessary testing, put the keyboard into a known state.
\ This routine is used after watchdog timer resets and other conditions
\ that leave the system in an unknown state.

: restore  ( -- )
1A3D8B4 	72 65 73 74 
1A3D8B8 	6F 72 65 87 F0 D7 A3  1 
1A3D8C0 	20 40 A0  1 
   init-data
1A3D8C4 	F0 CB A3  1 
   kbd-reset 0= to keyboard-present?
1A3D8C8 	DC CF A3  1 24 47 A0  1 
1A3D8D0 	B8 40 A0  1 B4 C8 A3  1 
;
1A3D8D8 	58 46 A0  1 
defer scan-handled?
1A3D8DC 	 0  0 73 63 
1A3D8E0 	61 6E 2D 68 61 6E 64 6C 
1A3D8E8 	65 64 3F 8D C0 D8 A3  1 
1A3D8F0 	5C 40 A0  1 E0  C  0  0 
' false to scan-handled?
headerless
: check-abort  ( scan-code -- flag )  \ Ctrl-break pressed?
1A3D8F8 	63 68 65 63 6B 2D 61 62 
1A3D900 	6F 72 74 8B F0 D8 A3  1 
1A3D908 	20 40 A0  1 
   check-abort?  if
1A3D90C 	5C C8 A3  1 
1A3D910 	DC 41 A0  1 40  0  0  0 
      \ Ctrl-break does not auto-repeat, so we needn't worry about
      \ multiple down transitions
      dup h# c6 =  if				\ Ctrl-break?
1A3D918 	40 49 A0  1 58 41 A0  1 
1A3D920 	C6  0  0  0 24 48 A0  1 
1A3D928 	DC 41 A0  1 1C  0  0  0 
         last-scan h# e0 =
1A3D930 	74 C8 A3  1 58 41 A0  1 
1A3D938 	E0  0  0  0 24 48 A0  1 
      else
1A3D940 	C8 41 A0  1  8  0  0  0 
         false
1A3D948 	18 70 A0  1 
      then
   else
1A3D94C 	C8 41 A0  1 
1A3D950 	 8  0  0  0 
      false
1A3D954 	18 70 A0  1 
   then
   swap to last-scan
1A3D958 	68 49 A0  1 B8 40 A0  1 
1A3D960 	74 C8 A3  1 
;
1A3D964 	58 46 A0  1 

: get-scan  ( -- )
1A3D968 	 0  0  0 67 65 74 2D 73 
1A3D970 	63 61 6E 88  8 D9 A3  1 
1A3D978 	20 40 A0  1 
   locked?  if  exit  then
1A3D97C 	C8 C8 A3  1 
1A3D980 	DC 41 A0  1  8  0  0  0 
1A3D988 	40 46 A0  1 

   lock
1A3D98C 	DC C8 A3  1 
   begin
      get-data?
1A3D990 	68 CC A3  1 
   while                                     ( scan-code )
1A3D994 	DC 41 A0  1 
1A3D998 	54  0  0  0 
      \ In the following code, we must be careful to unlock the
      \ queue before calling user-abort, because a timer interrupt
      \ can occur at any time after user-abort is executed.
      dup check-abort  if                    ( scan-code )
1A3D99C 	40 49 A0  1 
1A3D9A0 	 8 D9 A3  1 DC 41 A0  1 
1A3D9A8 	20  0  0  0 
         drop
1A3D9AC 	30 49 A0  1 
         unlock  user-abort
1A3D9B0 	FC C8 A3  1  C E3 A1  1 
         \ Wait here for long enough to ensure that an alarm timer tick
         \ will happen if it is going to happen.  This is the safest
         \ solution I have found to the following problem: If the abort
         \ sequence is detected while polling the keyboard from the
         \ application level (i.e. not from the alarm handler), then
         \ the alarm handler is likely to sense it a little later,
         \ perhaps in the middle of deque? .  Aborting in the middle of
         \ of deque? is bad, because it leaves the lock set and potentially
         \ leaves the queue pointers and/or stateful hardware in an
         \ inconsistent state.  One solution would be to avoid calling
         \ deque after calling user-abort, but that would hang the driver
         \ if the alarm tick is turned off.
         d# 20 ms
1A3D9B8 	58 41 A0  1 14  0  0  0 
1A3D9C0 	60 E0 A1  1 
         exit
1A3D9C4 	40 46 A0  1 
      then                                         ( scan-code )
      scan-handled?  if  drop  else  enque  then   ( )
1A3D9C8 	F0 D8 A3  1 DC 41 A0  1 
1A3D9D0 	10  0  0  0 30 49 A0  1 
1A3D9D8 	C8 41 A0  1  8  0  0  0 
1A3D9E0 	14 CA A3  1 
   repeat
1A3D9E4 	C8 41 A0  1 
1A3D9E8 	A8 FF FF FF 
   unlock
1A3D9EC 	FC C8 A3  1 
;
1A3D9F0 	58 46 A0  1 

: set-port  ( port# -- )  " set-port" $call-parent  ;
1A3D9F4 	 0  0  0 73 
1A3D9F8 	65 74 2D 70 6F 72 74 88 
1A3DA00 	78 D9 A3  1 20 40 A0  1 
1A3DA08 	9C 53 A0  1  8 73 65 74 
1A3DA10 	2D 70 6F 72 74  0  0  0 
1A3DA18 	DC 31 A2  1 58 46 A0  1 

variable kbd-refcount
1A3DA20 	 0  0  0 6B 62 64 2D 72 
1A3DA28 	65 66 63 6F 75 6E 74 8C 
1A3DA30 	 4 DA A3  1 48 40 A0  1 
1A3DA38 	E4  C  0  0 
: +refcnt  ( n -- )  kbd-refcount +!  ;
1A3DA3C 	2B 72 65 66 
1A3DA40 	63 6E 74 87 34 DA A3  1 
1A3DA48 	20 40 A0  1 34 DA A3  1 
1A3DA50 	 C 4C A0  1 58 46 A0  1 
0 kbd-refcount !

headers
: open  ( -- okay? )
1A3DA58 	 0  0  0 6F 70 65 6E 84 
1A3DA60 	48 DA A3  1 20 40 A0  1 
   my-space set-port
1A3DA68 	AC  3 A2  1  4 DA A3  1 
   kbd-refcount @  if  1 +refcnt  true exit  then
1A3DA70 	34 DA A3  1 5C 4C A0  1 
1A3DA78 	DC 41 A0  1 14  0  0  0 
1A3DA80 	80 6F A0  1 48 DA A3  1 
1A3DA88 	 4 70 A0  1 40 46 A0  1 
   unlock
1A3DA90 	FC C8 A3  1 
   keyboard-present?  if  clear-out-buf  else  reset  then
1A3DA94 	B4 C8 A3  1 
1A3DA98 	DC 41 A0  1 10  0  0  0 
1A3DAA0 	CC CC A3  1 C8 41 A0  1 
1A3DAA8 	 8  0  0  0 F0 D7 A3  1 
   keyboard-present?  0=  if  false exit  then
1A3DAB0 	B4 C8 A3  1 24 47 A0  1 
1A3DAB8 	DC 41 A0  1  C  0  0  0 
1A3DAC0 	18 70 A0  1 40 46 A0  1 
   choose-type
1A3DAC8 	40 D3 A3  1 
   ['] get-scan d# 10 alarm
1A3DACC 	60 53 A0  1 
1A3DAD0 	78 D9 A3  1 58 41 A0  1 
1A3DAD8 	 A  0  0  0 48 73 A2  1 
   1 +refcnt
1A3DAE0 	80 6F A0  1 48 DA A3  1 
   true
1A3DAE8 	 4 70 A0  1 
;
1A3DAEC 	58 46 A0  1 

: close  ( -- )
1A3DAF0 	 0  0 63 6C 6F 73 65 85 
1A3DAF8 	64 DA A3  1 20 40 A0  1 
   -1 +refcnt  kbd-refcount @  if  exit  then
1A3DB00 	58 41 A0  1 FF FF FF FF 
1A3DB08 	48 DA A3  1 34 DA A3  1 
1A3DB10 	5C 4C A0  1 DC 41 A0  1 
1A3DB18 	 8  0  0  0 40 46 A0  1 
   ?free-keymap
1A3DB20 	 4 D3 A3  1 
   ['] get-scan  0 alarm
1A3DB24 	60 53 A0  1 
1A3DB28 	78 D9 A3  1 70 6F A0  1 
1A3DB30 	48 73 A2  1 
;
1A3DB34 	58 46 A0  1 

: install-abort  ( -- )  true to check-abort?  ;
1A3DB38 	 0  0 69 6E 73 74 61 6C 
1A3DB40 	6C 2D 61 62 6F 72 74 8D 
1A3DB48 	FC DA A3  1 20 40 A0  1 
1A3DB50 	 4 70 A0  1 B8 40 A0  1 
1A3DB58 	5C C8 A3  1 58 46 A0  1 
: remove-abort  ( -- )  false to check-abort?  ;
1A3DB60 	 0  0  0 72 65 6D 6F 76 
1A3DB68 	65 2D 61 62 6F 72 74 8C 
1A3DB70 	4C DB A3  1 20 40 A0  1 
1A3DB78 	18 70 A0  1 B8 40 A0  1 
1A3DB80 	5C C8 A3  1 58 46 A0  1 

headerless
: >keycode  ( scan-code -- char )
1A3DB88 	 0  0  0 3E 6B 65 79 63 
1A3DB90 	6F 64 65 88 74 DB A3  1 
1A3DB98 	20 40 A0  1 
   keymap c@ 2 >  alt-gr?  and  if
1A3DB9C 	B8 D0 A3  1 
1A3DBA0 	C4 4C A0  1 90 6F A0  1 
1A3DBA8 	 4 48 A0  1 30 CB A3  1 
1A3DBB0 	5C 44 A0  1 DC 41 A0  1 
1A3DBB8 	18  0  0  0 
      h# c0 +
1A3DBBC 	58 41 A0  1 
1A3DBC0 	C0  0  0  0  4 45 A0  1 
   else
1A3DBC8 	C8 41 A0  1 1C  0  0  0 
      shift?  if  h# 60 +  then
1A3DBD0 	F4 CA A3  1 DC 41 A0  1 
1A3DBD8 	10  0  0  0 58 41 A0  1 
1A3DBE0 	60  0  0  0  4 45 A0  1 
   then
   keymap 1+ +  c@
1A3DBE8 	B8 D0 A3  1 30 4B A0  1 
1A3DBF0 	 4 45 A0  1 C4 4C A0  1 
;
1A3DBF8 	58 46 A0  1 

\ Schema for Latin-1 accents:
\ lower-case is c0+x, upper case is e0+x
\ letter   grave  acute circumflex tilde diaresis  ring  .e  slash  cedilla obl
\    A     c0     c1    c2         c3    c4        c5    c6
\    E     c8     c9    ca         cb
\    I     cc     cd    ce         cf
\    O     d2     d3    d4         d5    d6				    d8
\    U     d9     da    db               dc
\    Y            dd
\    y                                   ff
\    C                                                                 c7
\    N                             d1

\    ETH d0  eth f0
\    multiply d7  division f7
\    oslash f8
\    THORN de  thorn fe
\    ssharp df

\ grave: vowel-base + 0
\ acute: vowel-base + 1
\ circumflex: vowel-base + 2
\ tilde: vowel-base + 3       (but bogus for u)
\ diaresis: vowel-base + (3 for u, 4 for a and o)

\ Search for a match for "byte" in the "key" position of the table at
\ "table-adr". If a match is found, return the corresponding "value" byte
\ and true.  Otherwise return the argument byte and false.  The table
\ consists of pairs of bytes - the first byte of the pair is "key" and
\ the second is "value".  The end of the table is marked by a 0 byte in
\ the "key" position.
: translate-byte ( byte table-adr -- byte false | byte' true )
1A3DBFC 	 0 74 72 61 
1A3DC00 	6E 73 6C 61 74 65 2D 62 
1A3DC08 	79 74 65 8E 98 DB A3  1 
1A3DC10 	20 40 A0  1 
   begin  dup c@  while                             ( char adr )
1A3DC14 	40 49 A0  1 
1A3DC18 	C4 4C A0  1 DC 41 A0  1 
1A3DC20 	38  0  0  0 
      2dup c@ =  if  nip 1+ c@ true  exit  then     ( char adr )
1A3DC24 	C0 49 A0  1 
1A3DC28 	C4 4C A0  1 24 48 A0  1 
1A3DC30 	DC 41 A0  1 18  0  0  0 
1A3DC38 	FC 46 A0  1 30 4B A0  1 
1A3DC40 	C4 4C A0  1  4 70 A0  1 
1A3DC48 	40 46 A0  1 
      2+                                            ( char adr' )
1A3DC4C 	40 4B A0  1 
   repeat                                           ( char adr' )
1A3DC50 	C8 41 A0  1 C0 FF FF FF 
   drop false
1A3DC58 	30 49 A0  1 18 70 A0  1 
;
1A3DC60 	58 46 A0  1 

create dead-punctuation
1A3DC64 	 0  0  0 64 
1A3DC68 	65 61 64 2D 70 75 6E 63 
1A3DC70 	74 75 61 74 69 6F 6E 90 
1A3DC78 	10 DC A3  1 30 40 A0  1 
\ base  grave  acute  circumflex  tilde  diaeresis  cedilla
  ch /   xx     xx        ch |     xx      xx         xx
1A3DC80 	2F  0  0 7C  0  0  0 
  bl c,  ch `   ch '      ch ^     ch ~    a8 c,      xx     \ diaeresis
1A3DC87 	20 
1A3DC88 	60 27 5E 7E A8  0 
  ch 0   xx     xx        b0 c,    xx      xx         xx     \ degree
1A3DC8E 	30  0 
1A3DC90 	 0 B0  0  0  0 
  ch 1   xx     xx        b9 c,    xx      xx         xx     \ onesuperior
1A3DC95 	31  0  0 
1A3DC98 	B9  0  0  0 
  ch 2   xx     xx        b2 c,    xx      xx         xx     \ twosuperior
1A3DC9C 	32  0  0 B2 
1A3DCA0 	 0  0  0 
  ch 3   xx     xx        b3 c,    xx      xx         xx     \ threesuperior
1A3DCA3 	33  0  0 B3  0 
1A3DCA8 	 0  0 
  ch .   xx     xx        b7 c,    xx      xx         xx     \ periodcentered
1A3DCAA 	2E  0  0 B7  0  0 
1A3DCB0 	 0 
  ch !   xx     xx        a6 c,    xx      xx         xx     \ brokenbar
1A3DCB1 	21  0  0 A6  0  0  0 
  ch -   xx     xx        af c,    xx      xx         ac c,  \ macron, notsign
1A3DCB8 	2D  0  0 AF  0  0 AC 
  ch _   xx     xx        af c,    xx      xx         xx     \ macron
1A3DCBF 	5F 
1A3DCC0 	 0  0 AF  0  0  0 
  ch '   xx     b4 c,     xx       xx      xx         xx     \ acute
1A3DCC6 	27  0 
1A3DCC8 	B4  0  0  0  0 
  ch ,   xx     xx        xx       xx      xx         b8 c,  \ cedilla
1A3DCCD 	2C  0  0 
1A3DCD0 	 0  0  0 B8 
  ch "   xx     xx        xx       xx      a8 c,      xx     \ diaeresis
1A3DCD4 	22  0  0  0 
1A3DCD8 	 0 A8  0 
  ch C   xx     xx        xx       xx      xx         c7 c,  \ Ccedilla
1A3DCDB 	43  0  0  0  0 
1A3DCE0 	 0 C7 
  ch c   xx     xx        xx       xx      xx         e7 c,  \ ccedilla
1A3DCE2 	63  0  0  0  0  0 
1A3DCE8 	E7 
  0 c,
1A3DCE9 	 0 

\ Positions of accented vowels within the ISO-Latin-1 character encoding
create vowel-bases
1A3DCEA 	 0  0 76 6F 77 65 
1A3DCF0 	6C 2D 62 61 73 65 73 8B 
1A3DCF8 	7C DC A3  1 30 40 A0  1 
ch A  c0 c,  ch E  c8 c,  ch I  cc c,  ch O  d2 c,  ch U  d9 c,
1A3DD00 	41 C0 45 C8 49 CC 4F D2 
1A3DD08 	55 D9 
ch a  e0 c,  ch e  e8 c,  ch i  ec c,  ch o  f2 c,  ch u  f9 c,
1A3DD0A 	61 E0 65 E8 69 EC 
1A3DD10 	6F F2 75 F9 
0 c,
1A3DD14 	 0 

create dead-map  h# 10 c,  h# 15 c,
1A3DD15 	 0  0 64 
1A3DD18 	65 61 64 2D 6D 61 70 88 
1A3DD20 	FC DC A3  1 30 40 A0  1 
1A3DD28 	10 15 
   0 c,  \ 10: dead_grave      - index 0
1A3DD2A 	 0 
   1 c,  \ 11: dead_acute      - index 1
1A3DD2B 	 1 
   2 c,  \ 12: dead_circumflex - index 2
1A3DD2C 	 2 
   3 c,  \ 13: dead_tilde      - index 3
1A3DD2D 	 3 
   4 c,  \ 14: dead_diaeresis  - index 4
1A3DD2E 	 4 
   5 c,  \ 15: dead_cedilla    - index 5
1A3DD2F 	 5 

: ?dead-accent  ( char -- char' )
1A3DD30 	 0  0  0 3F 64 65 61 64 
1A3DD38 	2D 61 63 63 65 6E 74 8C 
1A3DD40 	24 DD A3  1 20 40 A0  1 
   dead-accent  -1  =  if  exit  then
1A3DD48 	48 CB A3  1 58 41 A0  1 
1A3DD50 	FF FF FF FF 24 48 A0  1 
1A3DD58 	DC 41 A0  1  8  0  0  0 
1A3DD60 	40 46 A0  1 

   \ First search the punctuation table
   dead-punctuation  begin  2dup c@  dup  while   ( char adr char char' )
1A3DD64 	7C DC A3  1 
1A3DD68 	C0 49 A0  1 C4 4C A0  1 
1A3DD70 	40 49 A0  1 DC 41 A0  1 
1A3DD78 	40  0  0  0 
      =  if                                       ( char adr )
1A3DD7C 	24 48 A0  1 
1A3DD80 	DC 41 A0  1 24  0  0  0 
         dead-accent + c@                         ( char char'|0 )
1A3DD88 	48 CB A3  1  4 45 A0  1 
1A3DD90 	C4 4C A0  1 
         ?dup  if  nip  then   exit               ( char|char' )
1A3DD94 	B4 70 A0  1 
1A3DD98 	DC 41 A0  1  8  0  0  0 
1A3DDA0 	FC 46 A0  1 40 46 A0  1 
      then                                        ( char adr )
      7 +                                         ( char adr' )
1A3DDA8 	E0 6F A0  1  4 45 A0  1 
   repeat                                         ( char adr char char' )
1A3DDB0 	C8 41 A0  1 B4 FF FF FF 
   3drop                                          ( char )
1A3DDB8 	90 52 A0  1 

   \ If it isn't in the punctuation table, try the vowel table, but
   \ not if the dead accent is cedilla (cedilla doesn't apply to vowels)
   dead-accent 5 =  if  drop exit  then           ( char )
1A3DDBC 	48 CB A3  1 
1A3DDC0 	C0 6F A0  1 24 48 A0  1 
1A3DDC8 	DC 41 A0  1  C  0  0  0 
1A3DDD0 	30 49 A0  1 40 46 A0  1 

   \ Unlike the other diaeresis vowels, u diaeresis is offset 3 instead of 4
   dup [char] u =  dead-accent 4  =  and  if      ( char )
1A3DDD8 	40 49 A0  1 58 41 A0  1 
1A3DDE0 	75  0  0  0 24 48 A0  1 
1A3DDE8 	48 CB A3  1 B0 6F A0  1 
1A3DDF0 	24 48 A0  1 5C 44 A0  1 
1A3DDF8 	DC 41 A0  1 14  0  0  0 
      dead-accent 1- to dead-accent               ( char )
1A3DE00 	48 CB A3  1 54 4B A0  1 
1A3DE08 	B8 40 A0  1 48 CB A3  1 
   then                                           ( char )
   vowel-bases translate-byte  if  dead-accent +  then    ( char' )
1A3DE10 	FC DC A3  1 10 DC A3  1 
1A3DE18 	DC 41 A0  1  C  0  0  0 
1A3DE20 	48 CB A3  1  4 45 A0  1 
;
1A3DE28 	58 46 A0  1 

create keypad-map  h# 90 c,  h# 9a c,
1A3DE2C 	 0 6B 65 79 
1A3DE30 	70 61 64 2D 6D 61 70 8A 
1A3DE38 	44 DD A3  1 30 40 A0  1 
1A3DE40 	90 9A 
   ch 0   \ 0/Insert
1A3DE42 	30 
   ch 1   \ 1/End
1A3DE43 	31 
   ch 2   \ 2/Down
1A3DE44 	32 
   ch 3   \ 3/PageDown
1A3DE45 	33 
   ch 4   \ 4/Left
1A3DE46 	34 
   ch 5   \ 5/<nothing>
1A3DE47 	35 
   ch 6   \ 6/Right
1A3DE48 	36 
   ch 7   \ 7/Home
1A3DE49 	37 
   ch 8   \ 8/Up
1A3DE4A 	38 
   ch 9   \ 9/PageUp
1A3DE4B 	39 
   ch .   \ ./Del
1A3DE4C 	2E 

\ Exchange the codes for the two symbol sets of the numeric keypad
\ if NumLock is on.
: ?numkey  ( char -- char' )
1A3DE4D 	 0  0  0 
1A3DE50 	3F 6E 75 6D 6B 65 79 87 
1A3DE58 	3C DE A3  1 20 40 A0  1 
   \ The mfii? 0= clause prevents the non-keypad Delete key from being
   \ affected by NumLock.
   numlk? mfii? 0= and  if                 ( char )
1A3DE60 	74 CB A3  1 1C CB A3  1 
1A3DE68 	24 47 A0  1 5C 44 A0  1 
1A3DE70 	DC 41 A0  1 18  0  0  0 
      keypad-map map?  if  exit  then      ( char )
1A3DE78 	3C DE A3  1 30 D4 A3  1 
1A3DE80 	DC 41 A0  1  8  0  0  0 
1A3DE88 	40 46 A0  1 
   then
;
1A3DE8C 	58 46 A0  1 

: ?caps  ( ASCII -- ASCII' )
1A3DE90 	 0  0 3F 63 61 70 73 85 
1A3DE98 	5C DE A3  1 20 40 A0  1 
   caps-lock?  if
1A3DEA0 	9C CB A3  1 DC 41 A0  1 
1A3DEA8 	74  0  0  0 
      \ Knock off the case bit so we can test fewer ranges
      dup  h# 20 invert and                  ( ASCII upc-ASCII )
1A3DEAC 	40 49 A0  1 
1A3DEB0 	58 41 A0  1 20  0  0  0 
1A3DEB8 	30 45 A0  1 5C 44 A0  1 

      \ In the ASCII range, the alphabetic character are in the range A-Z
      dup  [char] A  [char] Z  between       ( ASCII upc-ASCII flag )
1A3DEC0 	40 49 A0  1 58 41 A0  1 
1A3DEC8 	41  0  0  0 58 41 A0  1 
1A3DED0 	5A  0  0  0 D8 70 A0  1 

      \ In the ISO-Latin-1 range, the alphabetic characters are in the range
      \ 0xc0-0xde, except for d7 which is multiply; its conjugate f7 is
      \ divide.  df is sharp; its conjugate ff is ydiaeresis.
      over h# c0  h# de  between  or         ( ASCII upc-ASCII flag' )
1A3DED8 	54 49 A0  1 58 41 A0  1 
1A3DEE0 	C0  0  0  0 58 41 A0  1 
1A3DEE8 	DE  0  0  0 D8 70 A0  1 
1A3DEF0 	70 44 A0  1 
      swap  h# d7 <>  and  if                ( ASCII )
1A3DEF4 	68 49 A0  1 
1A3DEF8 	58 41 A0  1 D7  0  0  0 
1A3DF00 	44 48 A0  1 5C 44 A0  1 
1A3DF08 	DC 41 A0  1 10  0  0  0 
         h# 20 xor                           ( ASCII' )
1A3DF10 	58 41 A0  1 20  0  0  0 
1A3DF18 	84 44 A0  1 
      then                                   ( ASCII' )
   then                                      ( ASCII' )
;
1A3DF1C 	58 46 A0  1 
: ascii?  ( scancode -- flag )  h# 7f and  h# 20 h# 7f between  ;
1A3DF20 	 0 61 73 63 69 69 3F 86 
1A3DF28 	9C DE A3  1 20 40 A0  1 
1A3DF30 	58 41 A0  1 7F  0  0  0 
1A3DF38 	5C 44 A0  1 58 41 A0  1 
1A3DF40 	20  0  0  0 58 41 A0  1 
1A3DF48 	7F  0  0  0 D8 70 A0  1 
1A3DF50 	58 46 A0  1 

: ?ctrl?  ( char -- char false | char' true )
1A3DF54 	 0 3F 63 74 
1A3DF58 	72 6C 3F 86 2C DF A3  1 
1A3DF60 	20 40 A0  1 
   ctrl?  if                                ( char )
1A3DF64 	 8 CB A3  1 
1A3DF68 	DC 41 A0  1 38  0  0  0 
      dup  h# 40 h# 7f between  if  h# 1f and  true  exit  then
1A3DF70 	40 49 A0  1 58 41 A0  1 
1A3DF78 	40  0  0  0 58 41 A0  1 
1A3DF80 	7F  0  0  0 D8 70 A0  1 
1A3DF88 	DC 41 A0  1 18  0  0  0 
1A3DF90 	58 41 A0  1 1F  0  0  0 
1A3DF98 	5C 44 A0  1  4 70 A0  1 
1A3DFA0 	40 46 A0  1 
   then
   false
1A3DFA4 	18 70 A0  1 
;
1A3DFA8 	58 46 A0  1 
: clear-accent  ( -- )
1A3DFAC 	 0  0  0 63 
1A3DFB0 	6C 65 61 72 2D 61 63 63 
1A3DFB8 	65 6E 74 8C 60 DF A3  1 
1A3DFC0 	20 40 A0  1 
   \ If we just turned on the dead-accent variable (as indicated by the
   \ bias of 10), remove the bias.  Otherwise zap it.
   dead-accent  h# 10 >  if  h# 10 -  else  -1  then  to dead-accent
1A3DFC4 	48 CB A3  1 
1A3DFC8 	58 41 A0  1 10  0  0  0 
1A3DFD0 	 4 48 A0  1 DC 41 A0  1 
1A3DFD8 	18  0  0  0 58 41 A0  1 
1A3DFE0 	10  0  0  0 18 45 A0  1 
1A3DFE8 	C8 41 A0  1  C  0  0  0 
1A3DFF0 	58 41 A0  1 FF FF FF FF 
1A3DFF8 	B8 40 A0  1 48 CB A3  1 
;
1A3E000 	58 46 A0  1 
: get-ascii  ( scan-code -- false | ASCII-code true )
1A3E004 	 0  0 67 65 
1A3E008 	74 2D 61 73 63 69 69 89 
1A3E010 	C0 DF A3  1 20 40 A0  1 
   >keycode                                         ( char )
1A3E018 	98 DB A3  1 
   ?numkey                                          ( char' )
1A3E01C 	5C DE A3  1 

   dead-map map?  if                                ( index )
1A3E020 	24 DD A3  1 30 D4 A3  1 
1A3E028 	DC 41 A0  1 20  0  0  0 
      \ Set dead-accent with a bias so it won't be cleared when we exit
      h# 10 + to dead-accent false exit             ( false )
1A3E030 	58 41 A0  1 10  0  0  0 
1A3E038 	 4 45 A0  1 B8 40 A0  1 
1A3E040 	48 CB A3  1 18 70 A0  1 
1A3E048 	40 46 A0  1 
   then                                             ( char )

   dup ascii?  if                                   ( char )
1A3E04C 	40 49 A0  1 
1A3E050 	2C DF A3  1 DC 41 A0  1 
1A3E058 	2C  0  0  0 
      ?ctrl?  if  true exit  then                   ( char )
1A3E05C 	60 DF A3  1 
1A3E060 	DC 41 A0  1  C  0  0  0 
1A3E068 	 4 70 A0  1 40 46 A0  1 
      ?caps ?dead-accent  true                      ( ASCII true )
1A3E070 	9C DE A3  1 44 DD A3  1 
1A3E078 	 4 70 A0  1 
   else  \ No ASCII code equivalent	    	    ( scan char )
1A3E07C 	C8 41 A0  1 
1A3E080 	 8  0  0  0 
      get-special-key                               ( false | ASCII true )
1A3E084 	EC D4 A3  1 
   then                                             ( false | ASCII true )
;
1A3E088 	58 46 A0  1 

create mode-map  01 c,  06 c,
1A3E08C 	 0  0  0 6D 
1A3E090 	6F 64 65 2D 6D 61 70 88 
1A3E098 	14 E0 A3  1 30 40 A0  1 
1A3E0A0 	 1  6 
   00 c,  \ Shift
1A3E0A2 	 0 
   01 c,  \ Control
1A3E0A3 	 1 
   02 c,  \ Alt
1A3E0A4 	 2 
   03 c,  \ Caps_Lock
1A3E0A5 	 3 
   04 c,  \ Num_Lock
1A3E0A6 	 4 
   05 c,  \ Scroll_Lock
1A3E0A7 	 5 

: modifier?  ( down? scan -- true | down? scan false )
1A3E0A8 	 0  0 6D 6F 64 69 66 69 
1A3E0B0 	65 72 3F 89 9C E0 A3  1 
1A3E0B8 	20 40 A0  1 
   dup keymap 1+ + c@  mode-map  map?  if       ( down? scan char )
1A3E0BC 	40 49 A0  1 
1A3E0C0 	B8 D0 A3  1 30 4B A0  1 
1A3E0C8 	 4 45 A0  1 C4 4C A0  1 
1A3E0D0 	9C E0 A3  1 30 D4 A3  1 
1A3E0D8 	DC 41 A0  1 24  1  0  0 
      nip                                       ( down? char )
1A3E0E0 	FC 46 A0  1 
      case 
         0  of  mfii?  if  drop  else  to shift?  then  endof   \ Shift
1A3E0E4 	70 6F A0  1 
1A3E0E8 	48 43 A0  1 2C  0  0  0 
1A3E0F0 	1C CB A3  1 DC 41 A0  1 
1A3E0F8 	10  0  0  0 30 49 A0  1 
1A3E100 	C8 41 A0  1  C  0  0  0 
1A3E108 	B8 40 A0  1 F4 CA A3  1 
1A3E110 	6C 43 A0  1 E0  0  0  0 
         1  of  to ctrl?                                endof   \ Ctrl
1A3E118 	80 6F A0  1 48 43 A0  1 
1A3E120 	14  0  0  0 B8 40 A0  1 
1A3E128 	 8 CB A3  1 6C 43 A0  1 
1A3E130 	C4  0  0  0 
         2  of  mfii? and  to alt-gr?                   endof   \ Alt or AltGr
1A3E134 	90 6F A0  1 
1A3E138 	48 43 A0  1 1C  0  0  0 
1A3E140 	1C CB A3  1 5C 44 A0  1 
1A3E148 	B8 40 A0  1 30 CB A3  1 
1A3E150 	6C 43 A0  1 A0  0  0  0 
         3  of  scroll-lock?  if	\ If ScrollLock is on ...
1A3E158 	A0 6F A0  1 48 43 A0  1 
1A3E160 	34  0  0  0 C8 CB A3  1 
1A3E168 	DC 41 A0  1 14  0  0  0 
                   to ctrl?		\ ... treat the CapsLock key like Ctrl
1A3E170 	B8 40 A0  1  8 CB A3  1 
                else			\ Otherwise give it ...
1A3E178 	C8 41 A0  1 10  0  0  0 
                   4 and toggle-leds	\ ... the normal CapsLock function
1A3E180 	B0 6F A0  1 5C 44 A0  1 
1A3E188 	B8 CF A3  1 
                then                                    endof   \ Caps Lock
1A3E18C 	6C 43 A0  1 
1A3E190 	64  0  0  0 
         \ Pause is encoded as E1, 1D (CTRL), 45 (NUMLOCK)
         \ CTRL/Break is encoded as 1D (CTRL), E0 (MF II), 46 (ScrollLock)
         \ We filter out those modified locks to sense the real locks.
         4  of  2 and  ctrl? 0= and  toggle-leds        endof   \ Num Lock
1A3E194 	B0 6F A0  1 
1A3E198 	48 43 A0  1 24  0  0  0 
1A3E1A0 	90 6F A0  1 5C 44 A0  1 
1A3E1A8 	 8 CB A3  1 24 47 A0  1 
1A3E1B0 	5C 44 A0  1 B8 CF A3  1 
1A3E1B8 	6C 43 A0  1 38  0  0  0 
         5  of  1 and  mfii? 0= and  toggle-leds        endof   \ Scroll Lock
1A3E1C0 	C0 6F A0  1 48 43 A0  1 
1A3E1C8 	24  0  0  0 80 6F A0  1 
1A3E1D0 	5C 44 A0  1 1C CB A3  1 
1A3E1D8 	24 47 A0  1 5C 44 A0  1 
1A3E1E0 	B8 CF A3  1 6C 43 A0  1 
1A3E1E8 	 C  0  0  0 
         ( down? scan )  nip
1A3E1EC 	FC 46 A0  1 
      endcase
1A3E1F0 	84 43 A0  1 
      true
1A3E1F4 	 4 70 A0  1 
   else                                         ( down? scan char )
1A3E1F8 	C8 41 A0  1  C  0  0  0 
      drop false                                ( down? scan false )
1A3E200 	30 49 A0  1 18 70 A0  1 
   then
;
1A3E208 	58 46 A0  1 
: (scancode->char)  ( scan-code -- false | ASCII-code true )  \ Next ASCII code
1A3E20C 	 0  0  0 28 
1A3E210 	73 63 61 6E 63 6F 64 65 
1A3E218 	2D 3E 63 68 61 72 29 90 
1A3E220 	B8 E0 A3  1 20 40 A0  1 
   \ Split the scancode into the up/down indicator and the key identifier
   h# 80 /mod 0=  swap                           ( down? scan )
1A3E228 	58 41 A0  1 80  0  0  0 
1A3E230 	50 5F A0  1 24 47 A0  1 
1A3E238 	68 49 A0  1 
	
[ifdef] ?multkey  ?multkey  [then]

   \ Exit if the scancode is one that is never used for ASCII characters
   dup h# 60 >=  if  2drop  false  exit  then    ( down? scan )
1A3E23C 	40 49 A0  1 
1A3E240 	58 41 A0  1 60  0  0  0 
1A3E248 	EC 48 A0  1 DC 41 A0  1 
1A3E250 	10  0  0  0 AC 49 A0  1 
1A3E258 	18 70 A0  1 40 46 A0  1 

   \ Handle modifiers like shift, ctrl, etc.
   modifier?  if  false exit  then               ( down? scan )
1A3E260 	B8 E0 A3  1 DC 41 A0  1 
1A3E268 	 C  0  0  0 18 70 A0  1 
1A3E270 	40 46 A0  1 

   \ We have handled all the mode keys.  For the rest of the keys,
   \ we can ignore the up transition.
   swap  0= if  drop false exit  then            ( scan )
1A3E274 	68 49 A0  1 
1A3E278 	24 47 A0  1 DC 41 A0  1 
1A3E280 	10  0  0  0 30 49 A0  1 
1A3E288 	18 70 A0  1 40 46 A0  1 

   \ Try to translate the scancode into a one or more ASCII characters
   get-ascii                                     ( false | ASCII true )
1A3E290 	14 E0 A3  1 
   clear-accent                                  ( false | ASCII true )
1A3E294 	C0 DF A3  1 
;
1A3E298 	58 46 A0  1 
: scancode->char  ( scan-code -- false | ASCII-code true )  \ Next ASCII code
1A3E29C 	 0 73 63 61 
1A3E2A0 	6E 63 6F 64 65 2D 3E 63 
1A3E2A8 	68 61 72 8E 24 E2 A3  1 
1A3E2B0 	20 40 A0  1 
   \ If the scancode is the keyboard escape prefix, set the MF II flag
   \ for use in processing the next scancode.
   dup h# e0 =  if  true to mfii?  drop false exit  then
1A3E2B4 	40 49 A0  1 
1A3E2B8 	58 41 A0  1 E0  0  0  0 
1A3E2C0 	24 48 A0  1 DC 41 A0  1 
1A3E2C8 	1C  0  0  0  4 70 A0  1 
1A3E2D0 	B8 40 A0  1 1C CB A3  1 
1A3E2D8 	30 49 A0  1 18 70 A0  1 
1A3E2E0 	40 46 A0  1 

   \ Otherwise, leave the MF II flag at its previous value while
   \ decoding this scancode, then clear it before returning.

   (scancode->char)                     ( false | ASCII true )
1A3E2E4 	24 E2 A3  1 

   false to mfii?                       ( false | ASCII true )
1A3E2E8 	18 70 A0  1 B8 40 A0  1 
1A3E2F0 	1C CB A3  1 
;
1A3E2F4 	58 46 A0  1 

0 instance value time-limit
1A3E2F8 	 0 74 69 6D 65 2D 6C 69 
1A3E300 	6D 69 74 8A B0 E2 A3  1 
1A3E308 	C0 FE A1  1 1C  0  0  0 
headers
: get-scancode  ( msecs -- false | scancode true )
1A3E310 	 0  0  0 67 65 74 2D 73 
1A3E318 	63 61 6E 63 6F 64 65 8C 
1A3E320 	 8 E3 A3  1 20 40 A0  1 
   get-msecs + to time-limit
1A3E328 	50 E0 A1  1  4 45 A0  1 
1A3E330 	48 B8 A1  1  8 E3 A3  1 
   begin
      get-scan  deque?  if  true exit  then
1A3E338 	78 D9 A3  1 90 CA A3  1 
1A3E340 	DC 41 A0  1  C  0  0  0 
1A3E348 	 4 70 A0  1 40 46 A0  1 
      get-msecs time-limit - 0>=
1A3E350 	50 E0 A1  1  8 E3 A3  1 
1A3E358 	18 45 A0  1 C4 47 A0  1 
   until
1A3E360 	DC 41 A0  1 D4 FF FF FF 
   false
1A3E368 	18 70 A0  1 
;
1A3E36C 	58 46 A0  1 

headerless
: getkey  ( -- ASCII-char true | false )
1A3E370 	 0 67 65 74 6B 65 79 86 
1A3E378 	24 E3 A3  1 20 40 A0  1 
   #queued  if  #queued 1- dup to #queued  ascii-queue + c@  true exit  then
1A3E380 	20 C8 A3  1 DC 41 A0  1 
1A3E388 	2C  0  0  0 20 C8 A3  1 
1A3E390 	54 4B A0  1 40 49 A0  1 
1A3E398 	B8 40 A0  1 20 C8 A3  1 
1A3E3A0 	38 C8 A3  1  4 45 A0  1 
1A3E3A8 	C4 4C A0  1  4 70 A0  1 
1A3E3B0 	40 46 A0  1 
   begin
      get-scan  deque?  0=  if  false exit  then   ( scancode )
1A3E3B4 	78 D9 A3  1 
1A3E3B8 	90 CA A3  1 24 47 A0  1 
1A3E3C0 	DC 41 A0  1  C  0  0  0 
1A3E3C8 	18 70 A0  1 40 46 A0  1 
   scancode->char  until     ( ASCII-char )
1A3E3D0 	B0 E2 A3  1 DC 41 A0  1 
1A3E3D8 	DC FF FF FF 
   true
1A3E3DC 	 4 70 A0  1 
;
1A3E3E0 	58 46 A0  1 

[ifdef] fix-keyboard
\ keyboard-owner: 0 firmware  1 client   2 firmware,using client's scan set
0 value keyboard-owner
0 value client-scan-set
: fw-scan-set  ( -- )
   keyboard-owner 1 =  if
      get-scan-set to client-scan-set
      client-scan-set  h# f and  1  =  if
         2 to keyboard-owner		\ We can use the client's scan set
      else
         0 to keyboard-owner		\ The firmware scan set is in use
         \ The client is using a scan set other than 1, so we switch
         \ it to set 1.  If translation is off, we tell the keyboard to
         \ send set 1; otherwise we tell the keyboard to send set 2,
         \ and let the 8042 translate it to 1.  This minimizes the
         \ amount of work we must do.
         client-scan-set  3  <=  if  1  else  2  then  lock set-scan-set unlock
      then
   then
;

\ Restore the scan set to whatever the client was using
: entering-client  ( -- )
   keyboard-owner  0=  if
      client-scan-set ?dup  if
         dup  3 >  if   ( scan-set:1,2,3,43,41,3f )
            \ Translation is on, so we have to account for the translation
            \ 43 -> 1  41 -> 2  3f -> 3
            h# 45 swap - 2/
         then                            ( kbd-scan-set:1,2,3 )
         lock set-scan-set unlock
      then
   then
   1 to keyboard-owner
;

[then]


headers
\ Search the keyboards vocabulary for an entry that contains the
\ given string in its language field.
: set-language  ( adr len -- flag )
1A3E3E4 	 0  0  0 73 
1A3E3E8 	65 74 2D 6C 61 6E 67 75 
1A3E3F0 	61 67 65 8C 7C E3 A3  1 
1A3E3F8 	20 40 A0  1 
   2 <>  if  drop false  exit  then                ( adr )
1A3E3FC 	90 6F A0  1 
1A3E400 	44 48 A0  1 DC 41 A0  1 
1A3E408 	10  0  0  0 30 49 A0  1 
1A3E410 	18 70 A0  1 40 46 A0  1 
   ['] keyboards  follow  begin  another?  while   ( adr anf )
1A3E418 	60 53 A0  1 E4 D0 A3  1 
1A3E420 	38 BC A0  1 68 BC A0  1 
1A3E428 	DC 41 A0  1 4C  0  0  0 
      2dup  name> >body  2 comp  0=  if            ( adr anf )
1A3E430 	C0 49 A0  1  8 74 A0  1 
1A3E438 	E4 59 A0  1 90 6F A0  1 
1A3E440 	38 52 A0  1 24 47 A0  1 
1A3E448 	DC 41 A0  1 24  0  0  0 
         dup name>string rot name> (set-keyboard)  ( adr )
1A3E450 	40 49 A0  1 58 74 A0  1 
1A3E458 	7C 49 A0  1  8 74 A0  1 
1A3E460 	50 D2 A3  1 
         drop  true exit                           ( flag )
1A3E464 	30 49 A0  1 
1A3E468 	 4 70 A0  1 40 46 A0  1 
      then                                         ( adr anf )
   repeat                                          ( adr anf )
1A3E470 	C8 41 A0  1 B0 FF FF FF 
   2drop false                                     ( false )
1A3E478 	AC 49 A0  1 18 70 A0  1 
;
1A3E480 	58 46 A0  1 

: read   ( adr len -- #read )
1A3E484 	 0  0  0 72 
1A3E488 	65 61 64 84 F8 E3 A3  1 
1A3E490 	20 40 A0  1 
[ifdef] fw-scan-set  fw-scan-set  [then]

   \ Poll the keyboard even if len is 0, as extra insurance against overrun
   get-scan                                   ( adr len )
1A3E494 	78 D9 A3  1 
   tuck                                       ( len adr len )
1A3E498 	E8 46 A0  1 
   begin                                      ( len adr' len' )
      dup 0<>  if  getkey  else  false  then  ( len adr' len' [ char ] flag )
1A3E49C 	40 49 A0  1 
1A3E4A0 	44 47 A0  1 DC 41 A0  1 
1A3E4A8 	10  0  0  0 7C E3 A3  1 
1A3E4B0 	C8 41 A0  1  8  0  0  0 
1A3E4B8 	18 70 A0  1 
   while                                      ( len adr' len' char )
1A3E4BC 	DC 41 A0  1 
1A3E4C0 	20  0  0  0 
      2 pick c!                               ( len adr' len' )
1A3E4C4 	90 6F A0  1 
1A3E4C8 	 C 4A A0  1 B8 4D A0  1 
      1 /string                               ( len adr'' len'' )
1A3E4D0 	80 6F A0  1 3C 85 A0  1 
   repeat                                     ( len adr' len' )
1A3E4D8 	C8 41 A0  1 C0 FF FF FF 
   nip -                                      ( #read )
1A3E4E0 	FC 46 A0  1 18 45 A0  1 
   dup  0=  if  drop -2  then                 ( #read | -2 )
1A3E4E8 	40 49 A0  1 24 47 A0  1 
1A3E4F0 	DC 41 A0  1 10  0  0  0 
1A3E4F8 	30 49 A0  1 58 41 A0  1 
1A3E500 	FE FF FF FF 
;
1A3E504 	58 46 A0  1 

: ring-bell  ( -- )  " audio" " ring-bell" execute-device-method drop  ;
1A3E508 	 0  0 72 69 6E 67 2D 62 
1A3E510 	65 6C 6C 89 90 E4 A3  1 
1A3E518 	20 40 A0  1 9C 53 A0  1 
1A3E520 	 5 61 75 64 69 6F  0  0 
1A3E528 	9C 53 A0  1  9 72 69 6E 
1A3E530 	67 2D 62 65 6C 6C  0  0 
1A3E538 	84 3F A2  1 30 49 A0  1 
1A3E540 	58 46 A0  1 

: selftest  ( -- fail? )
1A3E544 	 0  0  0 73 
1A3E548 	65 6C 66 74 65 73 74 88 
1A3E550 	18 E5 A3  1 20 40 A0  1 
   kbd-refcount @ 0<>  if  
1A3E558 	34 DA A3  1 5C 4C A0  1 
1A3E560 	44 47 A0  1 DC 41 A0  1 
1A3E568 	 C  0  0  0 
      0 exit
1A3E56C 	70 6F A0  1 
1A3E570 	40 46 A0  1 
   then
   reset  keyboard-present?  if
1A3E574 	F0 D7 A3  1 
1A3E578 	B4 C8 A3  1 DC 41 A0  1 
1A3E580 	10  0  0  0 
      false
1A3E584 	18 70 A0  1 
   else
1A3E588 	C8 41 A0  1 24  0  0  0 
      ." No keyboard found" cr  true
1A3E590 	20 7C A0  1 11 4E 6F 20 
1A3E598 	6B 65 79 62 6F 61 72 64 
1A3E5A0 	20 66 6F 75 6E 64  0  0 
1A3E5A8 	80 6D A0  1  4 70 A0  1 
   then
;
1A3E5B0 	58 46 A0  1 

[ifdef] apple-chords
0 value previous-scan		\ Memory for detecting key chords.
\ These words are for detecting key-chords
\ chord-index takes two scan codes, and returns and index which
\ tells if a pair of keys is held down. The scan codes are expected to
\ be regular keys. Other code will deal with the cntl, alt etc.

\ 1 = forth prompt on scc-a  o-f
\ 2 = menu           o-m
\ 3 = set NVRAM defaults n-v
\ 4 = set Diag-mode o-d
\ 5 = forth prompt on com1
\ add others as needed.   

create chord-pairs      \ table of pairs of scan codes to watch for
\ for scancodes
h# 18 h# 21 , ,         \ o f - debug out scca
h# 18 h# 32 , ,         \ o m - force firmware menu
h# 31 h# 2f , ,         \ n v - reset nvram
h# 18 h# 20 , ,         \ o d - set true to diagnostic-mode?
h# 18 h# 2e , ,         \ o c - debug out com1
create end-pairs

\ chord-index searches for special key pairs.
: chord-index ( n1 n2 -- index ) \ index where  (n1n2 or n2n1) found. 0=none.
   end-pairs chord-pairs do
      2dup  i 2@  d=  -rot       ( flag1 n1 n2 )
      2dup swap  i 2@  d=        ( flag1 n1 n2 flag2 )
      -rot 2swap                 ( n1 n2 flag1 flag2 )
      or  if                     ( n1 n2 ) \ if match found ....
         2drop                    (  )  \ drop n1 n2
         i chord-pairs -          ( relative addr where found )
         2 cells /  1+            ( index ) \  return index showing where match found
         unloop exit              \ leave now
      then
   2 cells +loop                ( n1 n2 ) \ step through 2 cells at a time
   2drop                         (  )  \ drop n1 n2
   false                        \ if we never exit no match was found.
;

\ set-specials  searches for ctrl-alt-x-y key combinations which do 
\ special things like force the menu or debug out the com port.
: set-specials ( scancode - flag )
   false swap 
   dup h# e0 = if  drop  exit  then
   dup h# 80 and  0=  swap  h# 7f and   ( false down? scan )
   dup h# 60 >=  if  2drop  exit  then
   case					( false  down? scan )
     1d  of  to ctrl?   endof    \ CTRL-L  (CTLR-R is eO 1d)
     38  of  to alt-gr? endof    \ ALT-L   (ALT-R is e0 38)
     nip alt-gr? ctrl? and if 		( false scan )
        ." ca " 
        dup previous-scan chord-index ?dup if ( false scan index )
            rot drop swap  		( index scan )
        then 
        dup to previous-scan
     then 
   endcase				( index )
;

\ get-key-chord  polls the keyboard for approx. 2 seconds looking for a 
\ special key code sequence.  
: get-key-chord ( -- chord-index)
   reset			\ reset-kbd
   unlock
   0 to previous-scan 
   \ Loop for approximately 2 seconds on a 200 Mhz 604. 
   8000 0 do
      get-scan deque? if
         set-specials ?dup if 
	    \ make sure to unlock the keyboard when finished. 
            unloop unlock exit 
         then 
      then
   loop

   \ Only get here if no keys were pressed so return false. 
   false
;
[then]


\ From standini.fth
0 value stand-init-debug?
1A1DF83 	 0  0  0 73 74 
1A1DF88 	61 6E 64 2D 69 6E 69 74 
1A1DF90 	2D 64 65 62 75 67 3F 91 
1A1DF98 	24 DF A1  1 50 40 A0  1 
1A1DFA0 	60  5  0  0 

defer ?message-code  ( adr len -- adr len )  ' noop to ?message-code
1A1DFA4 	 0  0 3F 6D 
1A1DFA8 	65 73 73 61 67 65 2D 63 
1A1DFB0 	6F 64 65 8D 9C DF A1  1 
1A1DFB8 	5C 40 A0  1 64  5  0  0 
: ?type  ( adr len -- )
1A1DFC0 	 0  0 3F 74 79 70 65 85 
1A1DFC8 	B8 DF A1  1 20 40 A0  1 
;
1A1DFD0 	58 46 A0  1 

only forth also hidden also forth definitions

\needs standalone?  false value standalone?

only forth also definitions
: stand-init-io  ( -- )  true to standalone?  ;	\ First definition
1A1DFD4 	 0  0 73 74 
1A1DFD8 	61 6E 64 2D 69 6E 69 74 
1A1DFE0 	2D 69 6F 8D CC DF A1  1 
1A1DFE8 	20 40 A0  1  4 70 A0  1 
1A1DFF0 	B8 40 A0  1 F4 DE A1  1 
1A1DFF8 	58 46 A0  1 
headers

\ From sysintf.fth
purpose: Interfaces to low-level system functions

\ Interfaces to system-dependent routines

headers
defer diag-key     ( -- char )  \ Used by dl, dlbin, dlfcode.
1A1DFFC 	 0  0  0 64 
1A1E000 	69 61 67 2D 6B 65 79 88 
1A1E008 	E8 DF A1  1 5C 40 A0  1 
1A1E010 	68  5  0  0 
defer diag-key?    ( -- flag )  \ Used by dlbin.
1A1E014 	 0  0 64 69 
1A1E018 	61 67 2D 6B 65 79 3F 89 
1A1E020 	 C E0 A1  1 5C 40 A0  1 
1A1E028 	6C  5  0  0 

\ (Approximately) millisecond-granularity timing
\ Typically implemented by a driver for a counter/timer device

d# 10 value ms/tick
1A1E02C 	6D 73 2F 74 
1A1E030 	69 63 6B 87 24 E0 A1  1 
1A1E038 	50 40 A0  1 70  5  0  0 
defer get-msecs  ( -- n )  ' 0 is get-msecs
1A1E040 	 0  0 67 65 74 2D 6D 73 
1A1E048 	65 63 73 89 38 E0 A1  1 
1A1E050 	5C 40 A0  1 74  5  0  0 
defer ms  ( n -- )   ' drop is ms
1A1E058 	 0 6D 73 82 50 E0 A1  1 
1A1E060 	5C 40 A0  1 78  5  0  0 
defer us  ( n -- )   ' drop is us
1A1E068 	 0 75 73 82 60 E0 A1  1 
1A1E070 	5C 40 A0  1 7C  5  0  0 


\ Enabling/disabling interrupts
\ Typically implemented by a driver for an interrupt controller

defer lock[    ( -- )   ' noop is lock[
1A1E078 	 0  0 6C 6F 63 6B 5B 85 
1A1E080 	70 E0 A1  1 5C 40 A0  1 
1A1E088 	80  5  0  0 
defer ]unlock  ( -- )   ' noop is ]unlock
1A1E08C 	5D 75 6E 6C 
1A1E090 	6F 63 6B 87 84 E0 A1  1 
1A1E098 	5C 40 A0  1 84  5  0  0 
defer enable-interrupts   ( -- )  ' noop is enable-interrupts
1A1E0A0 	 0  0 65 6E 61 62 6C 65 
1A1E0A8 	2D 69 6E 74 65 72 72 75 
1A1E0B0 	70 74 73 91 98 E0 A1  1 
1A1E0B8 	5C 40 A0  1 88  5  0  0 
defer disable-interrupts  ( -- )  ' noop is disable-interrupts
1A1E0C0 	 0 64 69 73 61 62 6C 65 
1A1E0C8 	2D 69 6E 74 65 72 72 75 
1A1E0D0 	70 74 73 92 B8 E0 A1  1 
1A1E0D8 	5C 40 A0  1 8C  5  0  0 


\ System-wide DMA memory allocation (used only by the deblocker)
\ Typically implemented by a MMU driver

headerless
: null-allocate-dma  ( #bytes -- 0 )  drop 0  ;
1A1E0E0 	 0  0 6E 75 6C 6C 2D 61 
1A1E0E8 	6C 6C 6F 63 61 74 65 2D 
1A1E0F0 	64 6D 61 91 D8 E0 A1  1 
1A1E0F8 	20 40 A0  1 30 49 A0  1 
1A1E100 	70 6F A0  1 58 46 A0  1 

headers
defer allocate-dma  ' null-allocate-dma is allocate-dma
1A1E108 	 0  0  0 61 6C 6C 6F 63 
1A1E110 	61 74 65 2D 64 6D 61 8C 
1A1E118 	F8 E0 A1  1 5C 40 A0  1 
1A1E120 	90  5  0  0 

headerless
: null-free-dma  ( virt #bytes -- )  2drop  ;
1A1E124 	 0  0 6E 75 
1A1E128 	6C 6C 2D 66 72 65 65 2D 
1A1E130 	64 6D 61 8D 1C E1 A1  1 
1A1E138 	20 40 A0  1 AC 49 A0  1 
1A1E140 	58 46 A0  1 

headers
defer free-dma  ' null-free-dma is free-dma
1A1E144 	 0  0  0 66 
1A1E148 	72 65 65 2D 64 6D 61 88 
1A1E150 	38 E1 A1  1 5C 40 A0  1 
1A1E158 	94  5  0  0 

\ Storage of reboot information across system resets
\ The reboot information is typically stored in some type of memory
\ that is not cleared by a system reset.  The information does not
\ necessary have to survive across power cycles.

false value reboot?	\ Usually set in machine-dependent startup code
1A1E15C 	72 65 62 6F 
1A1E160 	6F 74 3F 87 54 E1 A1  1 
1A1E168 	50 40 A0  1 98  5  0  0 
			\ after testing a magic flag in physical memory

: null$  ( -- adr len )  " "  ;
1A1E170 	 0  0 6E 75 6C 6C 24 85 
1A1E178 	68 E1 A1  1 20 40 A0  1 
1A1E180 	9C 53 A0  1  0  0  0  0 
1A1E188 	58 46 A0  1 

headerless

defer save-reboot-info  ( arg$ cmd$ line# column# -- )
1A1E18C 	 0  0  0 73 
1A1E190 	61 76 65 2D 72 65 62 6F 
1A1E198 	6F 74 2D 69 6E 66 6F 90 
1A1E1A0 	7C E1 A1  1 5C 40 A0  1 
1A1E1A8 	9C  5  0  0 
defer get-reboot-info  ( -- cmd+arg$ line# column# )
1A1E1AC 	67 65 74 2D 
1A1E1B0 	72 65 62 6F 6F 74 2D 69 
1A1E1B8 	6E 66 6F 8F A4 E1 A1  1 
1A1E1C0 	5C 40 A0  1 A0  5  0  0 

headerless
: null-save-reboot-info  ( arg$ cmd$ line# column# -- )  2drop 2drop 2drop  ;
1A1E1C8 	 0  0 6E 75 6C 6C 2D 73 
1A1E1D0 	61 76 65 2D 72 65 62 6F 
1A1E1D8 	6F 74 2D 69 6E 66 6F 95 
1A1E1E0 	C0 E1 A1  1 20 40 A0  1 
1A1E1E8 	AC 49 A0  1 AC 49 A0  1 
1A1E1F0 	AC 49 A0  1 58 46 A0  1 
' null-save-reboot-info is save-reboot-info
: null-get-reboot-info  ( -- cmd+arg$ line# column# )  null$ 0 0  ;
1A1E1F8 	 0  0  0 6E 75 6C 6C 2D 
1A1E200 	67 65 74 2D 72 65 62 6F 
1A1E208 	6F 74 2D 69 6E 66 6F 94 
1A1E210 	E4 E1 A1  1 20 40 A0  1 
1A1E218 	7C E1 A1  1 70 6F A0  1 
1A1E220 	70 6F A0  1 58 46 A0  1 
' null-get-reboot-info is get-reboot-info
headers

\ Force a system reset
\ Typically implemented by a driver for system-level special registers.

defer reset-all ( -- )  ' noop is reset-all
1A1E228 	 0  0 72 65 73 65 74 2D 
1A1E230 	61 6C 6C 89 14 E2 A1  1 
1A1E238 	5C 40 A0  1 A4  5  0  0 


defer cleanup ' noop is cleanup	\ pkg/boot/go.fth
1A1E240 	63 6C 65 61 6E 75 70 87 
1A1E248 	38 E2 A1  1 5C 40 A0  1 
1A1E250 	A8  5  0  0 

false value already-go?	\ sun4/reenter.fth
1A1E254 	61 6C 72 65 
1A1E258 	61 64 79 2D 67 6F 3F 8B 
1A1E260 	4C E2 A1  1 50 40 A0  1 
1A1E268 	AC  5  0  0 

\ From reenter.fth
headerless
nuser aborted?      aborted? off
1A1E26C 	 0  0  0 61 
1A1E270 	62 6F 72 74 65 64 3F 88 
1A1E278 	64 E2 A1  1 48 40 A0  1 
1A1E280 	B0  5  0  0 
1 value allow-user-aborts?  \ Must be 0/1 instead of false/true because of the incrementing in the low-level handler
1A1E284 	 0 61 6C 6C 
1A1E288 	6F 77 2D 75 73 65 72 2D 
1A1E290 	61 62 6F 72 74 73 3F 92 
1A1E298 	7C E2 A1  1 50 40 A0  1 
1A1E2A0 	B4  5  0  0 
: enable-user-aborts  ( -- )  1 to allow-user-aborts?  ;
1A1E2A4 	 0 65 6E 61 
1A1E2A8 	62 6C 65 2D 75 73 65 72 
1A1E2B0 	2D 61 62 6F 72 74 73 92 
1A1E2B8 	9C E2 A1  1 20 40 A0  1 
1A1E2C0 	80 6F A0  1 B8 40 A0  1 
1A1E2C8 	9C E2 A1  1 58 46 A0  1 
: disable-user-aborts  ( -- )  0 to allow-user-aborts?  ;
1A1E2D0 	64 69 73 61 62 6C 65 2D 
1A1E2D8 	75 73 65 72 2D 61 62 6F 
1A1E2E0 	72 74 73 93 BC E2 A1  1 
1A1E2E8 	20 40 A0  1 70 6F A0  1 
1A1E2F0 	B8 40 A0  1 9C E2 A1  1 
1A1E2F8 	58 46 A0  1 

headers
: user-abort  ( -- )  allow-user-aborts? aborted? ! ;
1A1E2FC 	 0 75 73 65 
1A1E300 	72 2D 61 62 6F 72 74 8A 
1A1E308 	E8 E2 A1  1 20 40 A0  1 
1A1E310 	9C E2 A1  1 7C E2 A1  1 
1A1E318 	54 4D A0  1 58 46 A0  1 
headerless

\ System and version identification

\ System architecture name - used to locate the proper boot file
defer cpu-arch  ( -- adr len )   ' null$ is cpu-arch
1A1E320 	 0  0  0 63 70 75 2D 61 
1A1E328 	72 63 68 88  C E3 A1  1 
1A1E330 	5C 40 A0  1 B8  5  0  0 

defer idprom-valid?  ( -- flag )
1A1E338 	 0  0 69 64 70 72 6F 6D 
1A1E340 	2D 76 61 6C 69 64 3F 8D 
1A1E348 	30 E3 A1  1 5C 40 A0  1 
1A1E350 	BC  5  0  0 
' true  is idprom-valid?

3 value major-release  0 value minor-release
1A1E354 	 0  0 6D 61 
1A1E358 	6A 6F 72 2D 72 65 6C 65 
1A1E360 	61 73 65 8D 4C E3 A1  1 
1A1E368 	50 40 A0  1 C0  5  0  0 
1A1E370 	 0  0 6D 69 6E 6F 72 2D 
1A1E378 	72 65 6C 65 61 73 65 8D 
1A1E380 	68 E3 A1  1 50 40 A0  1 
1A1E388 	C4  5  0  0 
defer sub-release  ( -- adr len )   ' null$ is sub-release
1A1E38C 	73 75 62 2D 
1A1E390 	72 65 6C 65 61 73 65 8B 
1A1E398 	84 E3 A1  1 5C 40 A0  1 
1A1E3A0 	C8  5  0  0 

defer serial#  ( -- n )   ' 0 is serial#
1A1E3A4 	73 65 72 69 
1A1E3A8 	61 6C 23 87 9C E3 A1  1 
1A1E3B0 	5C 40 A0  1 CC  5  0  0 


\ System-wide network address

\ system-mac-address is typically defined in some sort of ID PROM
defer system-mac-address  ( -- adr len )  ' null$ is system-mac-address
1A1E3B8 	 0 73 79 73 74 65 6D 2D 
1A1E3C0 	6D 61 63 2D 61 64 64 72 
1A1E3C8 	65 73 73 92 B0 E3 A1  1 
1A1E3D0 	5C 40 A0  1 D0  5  0  0 


\ Device to use for console output if the preferred device is unavailable

headers
defer fallback-device  ( -- adr len )  ' null$ is fallback-device
1A1E3D8 	66 61 6C 6C 62 61 63 6B 
1A1E3E0 	2D 64 65 76 69 63 65 8F 
1A1E3E8 	D0 E3 A1  1 5C 40 A0  1 
1A1E3F0 	D4  5  0  0 
headerless


\ Compatibility FCode support

defer sbus-intr>cpu   ( sbus-level -- cpu-level )  ' noop is sbus-intr>cpu
1A1E3F4 	 0  0 73 62 
1A1E3F8 	75 73 2D 69 6E 74 72 3E 
1A1E400 	63 70 75 8D EC E3 A1  1 
1A1E408 	5C 40 A0  1 D8  5  0  0 

: no-memory  ( -- adr len )  0 0  ;
1A1E410 	 0  0 6E 6F 2D 6D 65 6D 
1A1E418 	6F 72 79 89  8 E4 A1  1 
1A1E420 	20 40 A0  1 70 6F A0  1 
1A1E428 	70 6F A0  1 58 46 A0  1 

headers
\ OS callbacks
\ The real stack effect appears to be ( args vector -- )
\ defer callback-call  ( arg-array -- error? )  ' noop is callback-call


\ Default font
defer romfont  ( -- fontadr )  ' false is romfont
1A1E430 	72 6F 6D 66 6F 6E 74 87 
1A1E438 	20 E4 A1  1 5C 40 A0  1 
1A1E440 	DC  5  0  0 


\ Logo dimensions.  These particular values are stipulated by IEEE 1275-1994
d# 64 constant logo-width
1A1E444 	 0 6C 6F 67 
1A1E448 	6F 2D 77 69 64 74 68 8A 
1A1E450 	3C E4 A1  1 68 40 A0  1 
1A1E458 	40  0  0  0 
d# 64 constant logo-height
1A1E45C 	6C 6F 67 6F 
1A1E460 	2D 68 65 69 67 68 74 8B 
1A1E468 	54 E4 A1  1 68 40 A0  1 
1A1E470 	40  0  0  0 

defer default-logo  ' null$ is default-logo
1A1E474 	 0  0  0 64 
1A1E478 	65 66 61 75 6C 74 2D 6C 
1A1E480 	6F 67 6F 8C 6C E4 A1  1 
1A1E488 	5C 40 A0  1 E0  5  0  0 

defer nv-c@
1A1E490 	 0  0 6E 76 2D 63 40 85 
1A1E498 	88 E4 A1  1 5C 40 A0  1 
1A1E4A0 	E4  5  0  0 
defer nv-c!
1A1E4A4 	 0  0 6E 76 
1A1E4A8 	2D 63 21 85 9C E4 A1  1 
1A1E4B0 	5C 40 A0  1 E8  5  0  0 

defer power-off  ( -- )
1A1E4B8 	 0  0 70 6F 77 65 72 2D 
1A1E4C0 	6F 66 66 89 B0 E4 A1  1 
1A1E4C8 	5C 40 A0  1 EC  5  0  0 

defer (init-program) ' noop is (init-program)
1A1E4D0 	 0 28 69 6E 69 74 2D 70 
1A1E4D8 	72 6F 67 72 61 6D 29 8E 
1A1E4E0 	C8 E4 A1  1 5C 40 A0  1 
1A1E4E8 	F0  5  0  0 

headers
variable cpu-node
1A1E4EC 	 0  0  0 63 
1A1E4F0 	70 75 2D 6E 6F 64 65 88 
1A1E4F8 	E4 E4 A1  1 48 40 A0  1 
1A1E500 	F4  5  0  0 

\ From execbuf.fth
purpose: Chain of recognizers for image formats

defer interpret-string  ( adr len -- )  ' evaluate is interpret-string
1A1E504 	 0  0  0 69 
1A1E508 	6E 74 65 72 70 72 65 74 
1A1E510 	2D 73 74 72 69 6E 67 90 
1A1E518 	FC E4 A1  1 5C 40 A0  1 
1A1E520 	F8  5  0  0 

: safe-include-buffer  ( adr len -- ? )
1A1E524 	73 61 66 65 
1A1E528 	2D 69 6E 63 6C 75 64 65 
1A1E530 	2D 62 75 66 66 65 72 93 
1A1E538 	1C E5 A1  1 20 40 A0  1 
   dup alloc-mem          ( adr len adr1 )
1A1E540 	40 49 A0  1 F0 6C A0  1 
   swap 2>r               ( adr r: adr1,len )
1A1E548 	68 49 A0  1 F8 45 A0  1 
   2r@ move               ( r: adr1,len )
1A1E550 	28 46 A0  1 F4 4A A0  1 
   2r@ include-buffer     ( ? r: adr1,len )
1A1E558 	28 46 A0  1 28 E8 A0  1 
   2r> free-mem           ( ? )
1A1E560 	10 46 A0  1  8 6D A0  1 
;
1A1E568 	58 46 A0  1 
: execute-buffer  ( adr len -- )  true abort" Unrecognized program format"  ;
1A1E56C 	 0 65 78 65 
1A1E570 	63 75 74 65 2D 62 75 66 
1A1E578 	66 65 72 8E 3C E5 A1  1 
1A1E580 	20 40 A0  1  4 70 A0  1 
1A1E588 	 8 81 A0  1 1B 55 6E 72 
1A1E590 	65 63 6F 67 6E 69 7A 65 
1A1E598 	64 20 70 72 6F 67 72 61 
1A1E5A0 	6D 20 66 6F 72 6D 61 74 
1A1E5A8 	 0  0  0  0 58 46 A0  1 
: execute-buffer    ( adr len -- )              \ Try Forth
1A1E5B0 	 0 65 78 65 63 75 74 65 
1A1E5B8 	2D 62 75 66 66 65 72 8E 
1A1E5C0 	80 E5 A1  1 20 40 A0  1 
   " \ "         2over substring?  if  safe-include-buffer exit  then   ( adr len )
1A1E5C8 	9C 53 A0  1  2 5C 20  0 
1A1E5D0 	D8 49 A0  1 84 16 A1  1 
1A1E5D8 	DC 41 A0  1  C  0  0  0 
1A1E5E0 	3C E5 A1  1 40 46 A0  1 
   " purpose: "  2over substring?  if  safe-include-buffer exit  then   ( adr len )
1A1E5E8 	9C 53 A0  1  9 70 75 72 
1A1E5F0 	70 6F 73 65 3A 20  0  0 
1A1E5F8 	D8 49 A0  1 84 16 A1  1 
1A1E600 	DC 41 A0  1  C  0  0  0 
1A1E608 	3C E5 A1  1 40 46 A0  1 
   " id: "       2over substring?  if  safe-include-buffer exit  then   ( adr len )
1A1E610 	9C 53 A0  1  4 69 64 3A 
1A1E618 	20  0  0  0 D8 49 A0  1 
1A1E620 	84 16 A1  1 DC 41 A0  1 
1A1E628 	 C  0  0  0 3C E5 A1  1 
1A1E630 	40 46 A0  1 

   execute-buffer
1A1E634 	80 E5 A1  1 
;
1A1E638 	58 46 A0  1 
: 'execute-buffer  ( -- xt )
1A1E63C 	27 65 78 65 
1A1E640 	63 75 74 65 2D 62 75 66 
1A1E648 	66 65 72 8F C4 E5 A1  1 
1A1E650 	20 40 A0  1 
   " execute-buffer" ['] forth  search-wordlist  drop
1A1E654 	9C 53 A0  1 
1A1E658 	 E 65 78 65 63 75 74 65 
1A1E660 	2D 62 75 66 66 65 72  0 
1A1E668 	60 53 A0  1  8 C5 A0  1 
1A1E670 	38 BB A0  1 30 49 A0  1 
;
1A1E678 	58 46 A0  1 

headers


\ From diagmode.fth

headers
defer (diagnostic-mode?)  ' false is (diagnostic-mode?)
1A1E67C 	 0 28 64 69 
1A1E680 	61 67 6E 6F 73 74 69 63 
1A1E688 	2D 6D 6F 64 65 3F 29 92 
1A1E690 	50 E6 A1  1 5C 40 A0  1 
1A1E698 	FC  5  0  0 
: diagnostic-mode?  ( -- flag )
1A1E69C 	 0  0  0 64 
1A1E6A0 	69 61 67 6E 6F 73 74 69 
1A1E6A8 	63 2D 6D 6F 64 65 3F 90 
1A1E6B0 	94 E6 A1  1 20 40 A0  1 
   standalone?  if  (diagnostic-mode?)  else  false  then  
1A1E6B8 	F4 DE A1  1 DC 41 A0  1 
1A1E6C0 	10  0  0  0 94 E6 A1  1 
1A1E6C8 	C8 41 A0  1  8  0  0  0 
1A1E6D0 	18 70 A0  1 
;
1A1E6D4 	58 46 A0  1 

: diag-type ( adr,len -- )  diagnostic-mode?  if  type  else  2drop  then  ;
1A1E6D8 	 0  0 64 69 61 67 2D 74 
1A1E6E0 	79 70 65 89 B4 E6 A1  1 
1A1E6E8 	20 40 A0  1 B4 E6 A1  1 
1A1E6F0 	DC 41 A0  1 10  0  0  0 
1A1E6F8 	 4 6C A0  1 C8 41 A0  1 
1A1E700 	 8  0  0  0 AC 49 A0  1 
1A1E708 	58 46 A0  1 
: diag-cr   ( -- )  diagnostic-mode?  if  cr  then  ;
1A1E70C 	64 69 61 67 
1A1E710 	2D 63 72 87 E8 E6 A1  1 
1A1E718 	20 40 A0  1 B4 E6 A1  1 
1A1E720 	DC 41 A0  1  8  0  0  0 
1A1E728 	80 6D A0  1 58 46 A0  1 
: diag-.d   ( n -- ) diagnostic-mode?  if  .d  else  drop  then  ;   
1A1E730 	64 69 61 67 2D 2E 64 87 
1A1E738 	18 E7 A1  1 20 40 A0  1 
1A1E740 	B4 E6 A1  1 DC 41 A0  1 
1A1E748 	10  0  0  0 48  E A1  1 
1A1E750 	C8 41 A0  1  8  0  0  0 
1A1E758 	30 49 A0  1 58 46 A0  1 
: diag-type-cr ( adr,len -- )  diag-type diag-cr  ;
1A1E760 	 0  0  0 64 69 61 67 2D 
1A1E768 	74 79 70 65 2D 63 72 8C 
1A1E770 	3C E7 A1  1 20 40 A0  1 
1A1E778 	E8 E6 A1  1 18 E7 A1  1 
1A1E780 	58 46 A0  1 

headers

\ interpolated from loaddevt.fth

\ Create the options vocabulary.  Later, it will become the property
\ list of "options" node in the device tree.

vocabulary options
1A1E784 	6F 70 74 69 
1A1E788 	6F 6E 73 87 74 E7 A1  1 
1A1E790 	E0 B6 A0  1  0  6  0  0 
1A1E798 	E0 C6 A1  1  0  0  0  0 

\ Make the options vocabulary a permanent part of the search order.

only forth also root also definitions
: fw-search-order  ( -- )  root also options also  ;
1A1E7A0 	66 77 2D 73 65 61 72 63 
1A1E7A8 	68 2D 6F 72 64 65 72 8F 
1A1E7B0 	88 1F A1  1 20 40 A0  1 
1A1E7B8 	B0 C1 A0  1 C8 C1 A0  1 
1A1E7C0 	90 E7 A1  1 C8 C1 A0  1 
1A1E7C8 	58 46 A0  1 
' fw-search-order to minimum-search-order
only forth hidden also forth also definitions

\ end interpolation

\ From confact.fth

purpose: Generic framework for configuration options

\ Action names for configuration objects

headers

\ 0 action = value on stack  ( apf -- value )
\      call with: fieldname
\ 1 action = store value   ( value apf -- )
\      call with: value to fieldname
\ 2 action = adr on stack  ( apf -- adr )
\      call with: addr fieldname
\ 3 action = decode for display  ( apf -- adr len )
\      call with: decode fieldname
\ 4 action = encode for storage  ( adr len apf -- )
\      call with: encode fieldname
\ 5 action = default value  ( apf -- value )
\ "value" is either int, char, or ( adr len) for strings

: get  ( acf -- value )  0 perform-action  ;
1A1E7CC 	67 65 74 83 
1A1E7D0 	90 E7 A1  1 20 40 A0  1 
1A1E7D8 	70 6F A0  1 10 B8 A1  1 
1A1E7E0 	58 46 A0  1 
: set  ( value acf -- )  1 perform-action  ;
1A1E7E4 	73 65 74 83 
1A1E7E8 	D4 E7 A1  1 20 40 A0  1 
1A1E7F0 	80 6F A0  1 10 B8 A1  1 
1A1E7F8 	58 46 A0  1 
: decode  ( value acf -- adr len )  3 perform-action  ;
1A1E7FC 	 0 64 65 63 
1A1E800 	6F 64 65 86 EC E7 A1  1 
1A1E808 	20 40 A0  1 A0 6F A0  1 
1A1E810 	10 B8 A1  1 58 46 A0  1 
: encode  ( adr len acf -- true | value false )
1A1E818 	 0 65 6E 63 6F 64 65 86 
1A1E820 	 8 E8 A1  1 20 40 A0  1 
   4 ['] perform-action  catch  if
1A1E828 	B0 6F A0  1 60 53 A0  1 
1A1E830 	10 B8 A1  1 14 7F A0  1 
1A1E838 	DC 41 A0  1 18  0  0  0 
      2drop 2drop true
1A1E840 	AC 49 A0  1 AC 49 A0  1 
1A1E848 	 4 70 A0  1 
   else
1A1E84C 	C8 41 A0  1 
1A1E850 	 8  0  0  0 
      false
1A1E854 	18 70 A0  1 
   then
;
1A1E858 	58 46 A0  1 
: get-default  ( acf -- value )  5 perform-action  ;
1A1E85C 	67 65 74 2D 
1A1E860 	64 65 66 61 75 6C 74 8B 
1A1E868 	24 E8 A1  1 20 40 A0  1 
1A1E870 	C0 6F A0  1 10 B8 A1  1 
1A1E878 	58 46 A0  1 

defer config-rw  ( -- )  ' noop is config-rw
1A1E87C 	 0  0 63 6F 
1A1E880 	6E 66 69 67 2D 72 77 89 
1A1E888 	6C E8 A1  1 5C 40 A0  1 
1A1E890 	 4  6  0  0 
defer config-ro  ( -- )  ' noop is config-ro
1A1E894 	 0  0 63 6F 
1A1E898 	6E 66 69 67 2D 72 6F 89 
1A1E8A0 	8C E8 A1  1 5C 40 A0  1 
1A1E8A8 	 8  6  0  0 
headerless

: to-column:  \ name ( col# -- )  ( -- )
1A1E8AC 	 0 74 6F 2D 
1A1E8B0 	63 6F 6C 75 6D 6E 3A 8A 
1A1E8B8 	A4 E8 A1  1 20 40 A0  1 
   create c,  does>  c@ to-column
1A1E8C0 	A8 A2 A0  1 B8 55 A0  1 
1A1E8C8 	50 A3 A0  1 90 90 90 E8 
1A1E8D0 	A8 57 FE FF C4 4C A0  1 
1A1E8D8 	 8 14 A1  1 
;
1A1E8DC 	58 46 A0  1 

d# 22 to-column: value-column
1A1E8E0 	 0  0  0 76 61 6C 75 65 
1A1E8E8 	2D 63 6F 6C 75 6D 6E 8C 
1A1E8F0 	BC E8 A1  1 CC E8 A1  1 
1A1E8F8 	16 
d# 53 to-column: default-column
1A1E8F9 	64 65 66 61 75 6C 74 
1A1E900 	2D 63 6F 6C 75 6D 6E 8E 
1A1E908 	F4 E8 A1  1 CC E8 A1  1 
1A1E910 	35 

: 3u.r ( u -- ) <# bl hold u# u#s u#> type  ;
1A1E911 	 0  0 33 75 2E 72 84 
1A1E918 	 C E9 A1  1 20 40 A0  1 
1A1E920 	 8 76 A0  1 28 70 A0  1 
1A1E928 	DC 75 A0  1 94 76 A0  1 
1A1E930 	BC 76 A0  1 E0 76 A0  1 
1A1E938 	 4 6C A0  1 58 46 A0  1 

: cdump  ( adr len -- )  push-hex  bounds ?do  i c@ 3u.r  loop  pop-base  ;
1A1E940 	 0  0 63 64 75 6D 70 85 
1A1E948 	1C E9 A1  1 20 40 A0  1 
1A1E950 	5C F4 A0  1 F0 6D A0  1 
1A1E958 	50 42 A0  1 18  0  0  0 
1A1E960 	B4 42 A0  1 C4 4C A0  1 
1A1E968 	1C E9 A1  1 F8 41 A0  1 
1A1E970 	F0 FF FF FF 9C F4 A0  1 
1A1E978 	58 46 A0  1 
: -null  ( adr len -- adr len' )
1A1E97C 	 0  0 2D 6E 
1A1E980 	75 6C 6C 85 4C E9 A1  1 
1A1E988 	20 40 A0  1 
   \ Remove last character if it's a null
   dup  if                             ( adr len )
1A1E98C 	40 49 A0  1 
1A1E990 	DC 41 A0  1 24  0  0  0 
      2dup + 1- c@  0=  if  1-  then   ( adr len' )
1A1E998 	C0 49 A0  1  4 45 A0  1 
1A1E9A0 	54 4B A0  1 C4 4C A0  1 
1A1E9A8 	24 47 A0  1 DC 41 A0  1 
1A1E9B0 	 8  0  0  0 54 4B A0  1 
   then                                ( adr len' )
;
1A1E9B8 	58 46 A0  1 
: text?  ( adr len -- flag )
1A1E9BC 	 0  0 74 65 
1A1E9C0 	78 74 3F 85 88 E9 A1  1 
1A1E9C8 	20 40 A0  1 
   true -rot  bounds ?do                          ( true )
1A1E9CC 	 4 70 A0  1 
1A1E9D0 	94 49 A0  1 F0 6D A0  1 
1A1E9D8 	50 42 A0  1 64  0  0  0 
      i c@  bl h# 7e between  0=                  ( non-printable? )
1A1E9E0 	B4 42 A0  1 C4 4C A0  1 
1A1E9E8 	28 70 A0  1 58 41 A0  1 
1A1E9F0 	7E  0  0  0 D8 70 A0  1 
1A1E9F8 	24 47 A0  1 
      i c@  dup carret  =  swap linefeed  =  or   ( non-printable?  cr/nl? )
1A1E9FC 	B4 42 A0  1 
1A1EA00 	C4 4C A0  1 40 49 A0  1 
1A1EA08 	60 6F A0  1 24 48 A0  1 
1A1EA10 	68 49 A0  1 4C 6F A0  1 
1A1EA18 	24 48 A0  1 70 44 A0  1 
      0=  and  if  0= leave  then                 ( true )
1A1EA20 	24 47 A0  1 5C 44 A0  1 
1A1EA28 	DC 41 A0  1  C  0  0  0 
1A1EA30 	24 47 A0  1 18 43 A0  1 
   loop                            ( all-characters-printable? )
1A1EA38 	F8 41 A0  1 A4 FF FF FF 
;
1A1EA40 	58 46 A0  1 
: (type-entry)  ( adr,len  -- )
1A1EA44 	 0  0  0 28 
1A1EA48 	74 79 70 65 2D 65 6E 74 
1A1EA50 	72 79 29 8C C8 E9 A1  1 
1A1EA58 	20 40 A0  1 
   2dup text?  if
1A1EA5C 	C0 49 A0  1 
1A1EA60 	C8 E9 A1  1 DC 41 A0  1 
1A1EA68 	5C  0  0  0 
      bounds  ?do
1A1EA6C 	F0 6D A0  1 
1A1EA70 	50 42 A0  1 48  0  0  0 
	 i c@  dup  newline =  if
1A1EA78 	B4 42 A0  1 C4 4C A0  1 
1A1EA80 	40 49 A0  1 A8 71 A0  1 
1A1EA88 	24 48 A0  1 DC 41 A0  1 
1A1EA90 	20  0  0  0 
	    drop cr value-column  exit? ?leave
1A1EA94 	30 49 A0  1 
1A1EA98 	80 6D A0  1 F4 E8 A1  1 
1A1EAA0 	34  D A1  1 34 43 A0  1 
	 else
1A1EAA8 	C8 41 A0  1  8  0  0  0 
	    emit
1A1EAB0 	2C 6C A0  1 
	 then
      loop
1A1EAB4 	F8 41 A0  1 
1A1EAB8 	C0 FF FF FF 
   else
1A1EABC 	C8 41 A0  1 
1A1EAC0 	 8  0  0  0 
      cdump
1A1EAC4 	4C E9 A1  1 
   then
;
1A1EAC8 	58 46 A0  1 
: $type-entry  ( adr len acf -- )
1A1EACC 	24 74 79 70 
1A1EAD0 	65 2D 65 6E 74 72 79 8B 
1A1EAD8 	58 EA A1  1 20 40 A0  1 
   decode -null                                   ( adr len )
1A1EAE0 	 8 E8 A1  1 88 E9 A1  1 
   tuck 2dup text?  if  d# 28  else  d# 12  then  ( len adr len len' )
1A1EAE8 	E8 46 A0  1 C0 49 A0  1 
1A1EAF0 	C8 E9 A1  1 DC 41 A0  1 
1A1EAF8 	14  0  0  0 58 41 A0  1 
1A1EB00 	1C  0  0  0 C8 41 A0  1 
1A1EB08 	 C  0  0  0 58 41 A0  1 
1A1EB10 	 C  0  0  0 
   min rot over                                   ( adr len' len len' )
1A1EB14 	74 4A A0  1 
1A1EB18 	7C 49 A0  1 54 49 A0  1 
   >  if  4 - (type-entry) ." ..."  else  (type-entry)  then  (  )
1A1EB20 	 4 48 A0  1 DC 41 A0  1 
1A1EB28 	24  0  0  0 B0 6F A0  1 
1A1EB30 	18 45 A0  1 58 EA A1  1 
1A1EB38 	20 7C A0  1  3 2E 2E 2E 
1A1EB40 	 0  0  0  0 C8 41 A0  1 
1A1EB48 	 8  0  0  0 58 EA A1  1 
;
1A1EB50 	58 46 A0  1 
: $type-entry-long  ( adr len acf -- )  decode -null (type-entry)  ;
1A1EB54 	 0  0  0 24 
1A1EB58 	74 79 70 65 2D 65 6E 74 
1A1EB60 	72 79 2D 6C 6F 6E 67 90 
1A1EB68 	DC EA A1  1 20 40 A0  1 
1A1EB70 	 8 E8 A1  1 88 E9 A1  1 
1A1EB78 	58 EA A1  1 58 46 A0  1 

\ 0 action = value on stack  ( apf -- value )
\      call with: fieldname
\ 1 action = store value   ( value apf -- )
\      call with: value to fieldname
\ 2 action = adr on stack  ( apf -- adr )
\      call with: addr fieldname
\ 3 action = decode for display  ( apf -- adr len )
\ 4 action = encode for storage  ( adr len apf -- )
\ 5 action = default value  ( apf -- value )
\ "value" is either int, char, or ( adr len) for strings

\ XXX should be done using "string-property" or "driver" or something
\ create name " options" 1+ ",  does> count  ;  \ Include null byte in count

headerless

defer nodefault?  ' false is nodefault?
1A1EB80 	 0 6E 6F 64 65 66 61 75 
1A1EB88 	6C 74 3F 8A 6C EB A1  1 
1A1EB90 	5C 40 A0  1  C  6  0  0 

\ Copy default value to current value
: do-set-default  ( acf -- )
1A1EB98 	 0 64 6F 2D 73 65 74 2D 
1A1EBA0 	64 65 66 61 75 6C 74 8E 
1A1EBA8 	90 EB A1  1 20 40 A0  1 
   dup >body nodefault?  if  drop  else  >r r@ get-default  r> set  then
1A1EBB0 	40 49 A0  1 E4 59 A0  1 
1A1EBB8 	90 EB A1  1 DC 41 A0  1 
1A1EBC0 	10  0  0  0 30 49 A0  1 
1A1EBC8 	C8 41 A0  1 18  0  0  0 
1A1EBD0 	BC 45 A0  1 E4 45 A0  1 
1A1EBD8 	6C E8 A1  1 D0 45 A0  1 
1A1EBE0 	EC E7 A1  1 
;
1A1EBE4 	58 46 A0  1 
: $find-option  ( adr len -- false | xt true )
1A1EBE8 	 0  0  0 24 66 69 6E 64 
1A1EBF0 	2D 6F 70 74 69 6F 6E 8C 
1A1EBF8 	AC EB A1  1 20 40 A0  1 
   ['] options search-wordlist
1A1EC00 	60 53 A0  1 90 E7 A1  1 
1A1EC08 	38 BB A0  1 
;
1A1EC0C 	58 46 A0  1 
: find-option  ( adr len -- false | xt true )
1A1EC10 	66 69 6E 64 2D 6F 70 74 
1A1EC18 	69 6F 6E 8B FC EB A1  1 
1A1EC20 	20 40 A0  1 
   2dup  $find-option  if            ( adr len xt )
1A1EC24 	C0 49 A0  1 
1A1EC28 	FC EB A1  1 DC 41 A0  1 
1A1EC30 	18  0  0  0 
      nip nip  true                  ( xt true )
1A1EC34 	FC 46 A0  1 
1A1EC38 	FC 46 A0  1  4 70 A0  1 
   else                              ( adr len )
1A1EC40 	C8 41 A0  1 28  0  0  0 
      ." Unknown option: " type cr   ( )
1A1EC48 	20 7C A0  1 10 55 6E 6B 
1A1EC50 	6E 6F 77 6E 20 6F 70 74 
1A1EC58 	69 6F 6E 3A 20  0  0  0 
1A1EC60 	 4 6C A0  1 80 6D A0  1 
      false                          ( false )
1A1EC68 	18 70 A0  1 
   then
;
1A1EC6C 	58 46 A0  1 
   
: show-config-entry  ( acf -- )
1A1EC70 	 0  0 73 68 6F 77 2D 63 
1A1EC78 	6F 6E 66 69 67 2D 65 6E 
1A1EC80 	74 72 79 91 20 EC A1  1 
1A1EC88 	20 40 A0  1 
   >r
1A1EC8C 	BC 45 A0  1 
   r@ .name
1A1EC90 	E4 45 A0  1 C8 9A A0  1 
   value-column     r@ get           r@ $type-entry
1A1EC98 	F4 E8 A1  1 E4 45 A0  1 
1A1ECA0 	D4 E7 A1  1 E4 45 A0  1 
1A1ECA8 	DC EA A1  1 
   r@ >body  nodefault?  if
1A1ECAC 	E4 45 A0  1 
1A1ECB0 	E4 59 A0  1 90 EB A1  1 
1A1ECB8 	DC 41 A0  1 14  0  0  0 
      r> drop
1A1ECC0 	D0 45 A0  1 30 49 A0  1 
   else
1A1ECC8 	C8 41 A0  1 18  0  0  0 
      default-column  r@ get-default   r> $type-entry
1A1ECD0 	 C E9 A1  1 E4 45 A0  1 
1A1ECD8 	6C E8 A1  1 D0 45 A0  1 
1A1ECE0 	DC EA A1  1 
   then
   cr
1A1ECE4 	80 6D A0  1 
;
1A1ECE8 	58 46 A0  1 

: show-current-value ( acf -- )
1A1ECEC 	 0 73 68 6F 
1A1ECF0 	77 2D 63 75 72 72 65 6E 
1A1ECF8 	74 2D 76 61 6C 75 65 92 
1A1ED00 	88 EC A1  1 20 40 A0  1 
   dup .name ." = "  value-column
1A1ED08 	40 49 A0  1 C8 9A A0  1 
1A1ED10 	20 7C A0  1  2 3D 20  0 
1A1ED18 	F4 E8 A1  1 
   >r  r@ get  r> ( adr len acf )  $type-entry-long cr
1A1ED1C 	BC 45 A0  1 
1A1ED20 	E4 45 A0  1 D4 E7 A1  1 
1A1ED28 	D0 45 A0  1 6C EB A1  1 
1A1ED30 	80 6D A0  1 
;
1A1ED34 	58 46 A0  1 

\ Interfaces to the mechanism (if any) for user-created environment variables
\ Some of these interfaces are used in clientif.fth instead of in this file.

defer next-env-var  ( adr len -- adr' len' )
1A1ED38 	 0  0  0 6E 65 78 74 2D 
1A1ED40 	65 6E 76 2D 76 61 72 8C 
1A1ED48 	 4 ED A1  1 5C 40 A0  1 
1A1ED50 	10  6  0  0 
: no-next-env-var  ( adr len -- null$ )  2drop null$  ;
1A1ED54 	6E 6F 2D 6E 
1A1ED58 	65 78 74 2D 65 6E 76 2D 
1A1ED60 	76 61 72 8F 4C ED A1  1 
1A1ED68 	20 40 A0  1 AC 49 A0  1 
1A1ED70 	7C E1 A1  1 58 46 A0  1 
' no-next-env-var to next-env-var

defer put-env-var  ( value$ name$ -- len )
1A1ED78 	70 75 74 2D 65 6E 76 2D 
1A1ED80 	76 61 72 8B 68 ED A1  1 
1A1ED88 	5C 40 A0  1 14  6  0  0 
: no-put-env-var  ( value$ name$ -- len )  2drop 2drop -1  ;
1A1ED90 	 0 6E 6F 2D 70 75 74 2D 
1A1ED98 	65 6E 76 2D 76 61 72 8E 
1A1EDA0 	88 ED A1  1 20 40 A0  1 
1A1EDA8 	AC 49 A0  1 AC 49 A0  1 
1A1EDB0 	58 41 A0  1 FF FF FF FF 
1A1EDB8 	58 46 A0  1 
' no-put-env-var to put-env-var

\ show-extra-env displays the values of environment variables
\ other than the ones explicitly known by Open Firmware.
defer show-extra-env-vars
1A1EDBC 	73 68 6F 77 
1A1EDC0 	2D 65 78 74 72 61 2D 65 
1A1EDC8 	6E 76 2D 76 61 72 73 93 
1A1EDD0 	A4 ED A1  1 5C 40 A0  1 
1A1EDD8 	18  6  0  0 
' noop is show-extra-env-vars

defer show-extra-env-var  ( name$ -- )
1A1EDDC 	 0 73 68 6F 
1A1EDE0 	77 2D 65 78 74 72 61 2D 
1A1EDE8 	65 6E 76 2D 76 61 72 92 
1A1EDF0 	D4 ED A1  1 5C 40 A0  1 
1A1EDF8 	1C  6  0  0 
: no-show-extra  ( name$ -- )  ." Unknown option: " type cr  ;
1A1EDFC 	 0  0 6E 6F 
1A1EE00 	2D 73 68 6F 77 2D 65 78 
1A1EE08 	74 72 61 8D F4 ED A1  1 
1A1EE10 	20 40 A0  1 20 7C A0  1 
1A1EE18 	10 55 6E 6B 6E 6F 77 6E 
1A1EE20 	20 6F 70 74 69 6F 6E 3A 
1A1EE28 	20  0  0  0  4 6C A0  1 
1A1EE30 	80 6D A0  1 58 46 A0  1 
' no-show-extra to show-extra-env-var

defer put-extra-env-var  ( value$ name$ -- )
1A1EE38 	 0  0 70 75 74 2D 65 78 
1A1EE40 	74 72 61 2D 65 6E 76 2D 
1A1EE48 	76 61 72 91 10 EE A1  1 
1A1EE50 	5C 40 A0  1 20  6  0  0 
: no-put-extra  ( value$ name$ -- )  no-show-extra 2drop  ;
1A1EE58 	 0  0  0 6E 6F 2D 70 75 
1A1EE60 	74 2D 65 78 74 72 61 8C 
1A1EE68 	50 EE A1  1 20 40 A0  1 
1A1EE70 	10 EE A1  1 AC 49 A0  1 
1A1EE78 	58 46 A0  1 
' no-put-extra to put-extra-env-var

defer get-env-var  ( name$ -- true | value$ false )
1A1EE7C 	67 65 74 2D 
1A1EE80 	65 6E 76 2D 76 61 72 8B 
1A1EE88 	6C EE A1  1 5C 40 A0  1 
1A1EE90 	24  6  0  0 
: no-get-env-var  ( name$ -- true )  2drop  true  ;
1A1EE94 	 0 6E 6F 2D 
1A1EE98 	67 65 74 2D 65 6E 76 2D 
1A1EEA0 	76 61 72 8E 8C EE A1  1 
1A1EEA8 	20 40 A0  1 AC 49 A0  1 
1A1EEB0 	 4 70 A0  1 58 46 A0  1 
' no-get-env-var to get-env-var

defer erase-user-env-vars  ( -- )
1A1EEB8 	65 72 61 73 65 2D 75 73 
1A1EEC0 	65 72 2D 65 6E 76 2D 76 
1A1EEC8 	61 72 73 93 A8 EE A1  1 
1A1EED0 	5C 40 A0  1 28  6  0  0 
' noop to erase-user-env-vars

: printenv-all  ( -- )
1A1EED8 	 0  0  0 70 72 69 6E 74 
1A1EEE0 	65 6E 76 2D 61 6C 6C 8C 
1A1EEE8 	D0 EE A1  1 20 40 A0  1 
   ." Variable Name"  value-column  ." Value"
1A1EEF0 	20 7C A0  1  D 56 61 72 
1A1EEF8 	69 61 62 6C 65 20 4E 61 
1A1EF00 	6D 65  0  0 F4 E8 A1  1 
1A1EF08 	20 7C A0  1  5 56 61 6C 
1A1EF10 	75 65  0  0 
   default-column ." Default Value" cr cr
1A1EF14 	 C E9 A1  1 
1A1EF18 	20 7C A0  1  D 44 65 66 
1A1EF20 	61 75 6C 74 20 56 61 6C 
1A1EF28 	75 65  0  0 80 6D A0  1 
1A1EF30 	80 6D A0  1 

   ['] options  follow
1A1EF34 	60 53 A0  1 
1A1EF38 	90 E7 A1  1 38 BC A0  1 
   begin  another?  while
1A1EF40 	68 BC A0  1 DC 41 A0  1 
1A1EF48 	54  0  0  0 
      exit?  if  drop exit  then
1A1EF4C 	34  D A1  1 
1A1EF50 	DC 41 A0  1  C  0  0  0 
1A1EF58 	30 49 A0  1 40 46 A0  1 
      dup name>string " name" $= if  \ Don't display the "name" property
1A1EF60 	40 49 A0  1 58 74 A0  1 
1A1EF68 	9C 53 A0  1  4 6E 61 6D 
1A1EF70 	65  0  0  0 88 8D A0  1 
1A1EF78 	DC 41 A0  1 10  0  0  0 
         drop
1A1EF80 	30 49 A0  1 
      else
1A1EF84 	C8 41 A0  1 
1A1EF88 	 C  0  0  0 
         name>  show-config-entry
1A1EF8C 	 8 74 A0  1 
1A1EF90 	88 EC A1  1 
      then
   repeat
1A1EF94 	C8 41 A0  1 
1A1EF98 	A8 FF FF FF 
   show-extra-env-vars
1A1EF9C 	D4 ED A1  1 
;
1A1EFA0 	58 46 A0  1 

: (printenv)  ( adr len -- )
1A1EFA4 	 0 28 70 72 
1A1EFA8 	69 6E 74 65 6E 76 29 8A 
1A1EFB0 	EC EE A1  1 20 40 A0  1 
   2dup  $find-option  if
1A1EFB8 	C0 49 A0  1 FC EB A1  1 
1A1EFC0 	DC 41 A0  1 18  0  0  0 
      nip nip show-current-value
1A1EFC8 	FC 46 A0  1 FC 46 A0  1 
1A1EFD0 	 4 ED A1  1 
   else
1A1EFD4 	C8 41 A0  1 
1A1EFD8 	 8  0  0  0 
      show-extra-env-var
1A1EFDC 	F4 ED A1  1 
   then
;
1A1EFE0 	58 46 A0  1 

headers

: set-default  \ name  ( -- )
1A1EFE4 	73 65 74 2D 
1A1EFE8 	64 65 66 61 75 6C 74 8B 
1A1EFF0 	B4 EF A1  1 20 40 A0  1 
   parse-word dup   if                              ( adr len )
1A1EFF8 	34 93 A0  1 40 49 A0  1 
1A1F000 	DC 41 A0  1 1C  0  0  0 
      find-option  if  do-set-default  then         ( )
1A1F008 	20 EC A1  1 DC 41 A0  1 
1A1F010 	 8  0  0  0 AC EB A1  1 
   else                                             ( adr len )
1A1F018 	C8 41 A0  1 30  0  0  0 
      2drop  ." Usage: set-default option-name" cr  ( )
1A1F020 	AC 49 A0  1 20 7C A0  1 
1A1F028 	1E 55 73 61 67 65 3A 20 
1A1F030 	73 65 74 2D 64 65 66 61 
1A1F038 	75 6C 74 20 6F 70 74 69 
1A1F040 	6F 6E 2D 6E 61 6D 65  0 
1A1F048 	80 6D A0  1 
   then                                             ( )
;
1A1F04C 	58 46 A0  1 
: set-defaults  ( -- )
1A1F050 	 0  0  0 73 65 74 2D 64 
1A1F058 	65 66 61 75 6C 74 73 8C 
1A1F060 	F4 EF A1  1 20 40 A0  1 
   ." Setting configuration variables to default values."  cr
1A1F068 	20 7C A0  1 32 53 65 74 
1A1F070 	74 69 6E 67 20 63 6F 6E 
1A1F078 	66 69 67 75 72 61 74 69 
1A1F080 	6F 6E 20 76 61 72 69 61 
1A1F088 	62 6C 65 73 20 74 6F 20 
1A1F090 	64 65 66 61 75 6C 74 20 
1A1F098 	76 61 6C 75 65 73 2E  0 
1A1F0A0 	80 6D A0  1 
   config-rw
1A1F0A4 	8C E8 A1  1 
   erase-user-env-vars
1A1F0A8 	D0 EE A1  1 
   ['] options  follow
1A1F0AC 	60 53 A0  1 
1A1F0B0 	90 E7 A1  1 38 BC A0  1 
   begin  another?  while
1A1F0B8 	68 BC A0  1 DC 41 A0  1 
1A1F0C0 	40  0  0  0 
      dup name>string  " name" $=  if  drop  else  name> do-set-default  then
1A1F0C4 	40 49 A0  1 
1A1F0C8 	58 74 A0  1 9C 53 A0  1 
1A1F0D0 	 4 6E 61 6D 65  0  0  0 
1A1F0D8 	88 8D A0  1 DC 41 A0  1 
1A1F0E0 	10  0  0  0 30 49 A0  1 
1A1F0E8 	C8 41 A0  1  C  0  0  0 
1A1F0F0 	 8 74 A0  1 AC EB A1  1 
   repeat
1A1F0F8 	C8 41 A0  1 BC FF FF FF 
   config-ro
1A1F100 	A4 E8 A1  1 
;
1A1F104 	58 46 A0  1 

: ofw-$getenv  ( name$ -- true | value$ false )
1A1F108 	6F 66 77 2D 24 67 65 74 
1A1F110 	65 6E 76 8B 64 F0 A1  1 
1A1F118 	20 40 A0  1 
   2dup  $find-option  if                 ( name$ xt )
1A1F11C 	C0 49 A0  1 
1A1F120 	FC EB A1  1 DC 41 A0  1 
1A1F128 	30  0  0  0 
      nip nip                             ( xt )
1A1F12C 	FC 46 A0  1 
1A1F130 	FC 46 A0  1 
      >r  r@ get  r> decode -null false   ( prop$ false )
1A1F134 	BC 45 A0  1 
1A1F138 	E4 45 A0  1 D4 E7 A1  1 
1A1F140 	D0 45 A0  1  8 E8 A1  1 
1A1F148 	88 E9 A1  1 18 70 A0  1 
   else                                   ( name$ )
1A1F150 	C8 41 A0  1  8  0  0  0 
      get-env-var                         ( true | prop$ false )
1A1F158 	8C EE A1  1 
   then
   \ Remove the trailing null if there is one; the result from this
   \ word is a Forth string, not a prop-encoded array
   if  true  else  -null false  then
1A1F15C 	DC 41 A0  1 
1A1F160 	10  0  0  0  4 70 A0  1 
1A1F168 	C8 41 A0  1  C  0  0  0 
1A1F170 	88 E9 A1  1 18 70 A0  1 
;
1A1F178 	58 46 A0  1 

: printenv  \ [ option-name ]  ( -- )
1A1F17C 	 0  0  0 70 
1A1F180 	72 69 6E 74 65 6E 76 88 
1A1F188 	18 F1 A1  1 20 40 A0  1 
   parse-word dup  if  (printenv)  else  2drop printenv-all  then
1A1F190 	34 93 A0  1 40 49 A0  1 
1A1F198 	DC 41 A0  1 10  0  0  0 
1A1F1A0 	B4 EF A1  1 C8 41 A0  1 
1A1F1A8 	 C  0  0  0 AC 49 A0  1 
1A1F1B0 	EC EE A1  1 
;
1A1F1B4 	58 46 A0  1 

: $setenv  ( value$ name$ -- )
1A1F1B8 	24 73 65 74 65 6E 76 87 
1A1F1C0 	8C F1 A1  1 20 40 A0  1 
   2dup $find-option  if                             ( value$ name$ xt )
1A1F1C8 	C0 49 A0  1 FC EB A1  1 
1A1F1D0 	DC 41 A0  1 78  0  0  0 
      nip nip
1A1F1D8 	FC 46 A0  1 FC 46 A0  1 

      >r r@  encode  if
1A1F1E0 	BC 45 A0  1 E4 45 A0  1 
1A1F1E8 	24 E8 A1  1 DC 41 A0  1 
1A1F1F0 	44  0  0  0 
         r> drop  ." Invalid value; previous value retained." cr
1A1F1F4 	D0 45 A0  1 
1A1F1F8 	30 49 A0  1 20 7C A0  1 
1A1F200 	27 49 6E 76 61 6C 69 64 
1A1F208 	20 76 61 6C 75 65 3B 20 
1A1F210 	70 72 65 76 69 6F 75 73 
1A1F218 	20 76 61 6C 75 65 20 72 
1A1F220 	65 74 61 69 6E 65 64 2E 
1A1F228 	 0  0  0  0 80 6D A0  1 
         exit
1A1F230 	40 46 A0  1 
      then                                              ( value )

      \ We've passed all the error checks, now set the option value.

      r@ set  r> show-current-value                           ( )
1A1F234 	E4 45 A0  1 
1A1F238 	EC E7 A1  1 D0 45 A0  1 
1A1F240 	 4 ED A1  1 
   else
1A1F244 	C8 41 A0  1 
1A1F248 	 8  0  0  0 
      put-extra-env-var
1A1F24C 	50 EE A1  1 
   then
;
1A1F250 	58 46 A0  1 
: setenv  \ name value  ( -- )
1A1F254 	 0 73 65 74 
1A1F258 	65 6E 76 86 C4 F1 A1  1 
1A1F260 	20 40 A0  1 
   parse-word -1 parse strip-blanks  2swap       ( value$ name$ )
1A1F264 	34 93 A0  1 
1A1F268 	58 41 A0  1 FF FF FF FF 
1A1F270 	E4 85 A0  1 2C  F A1  1 
1A1F278 	F4 49 A0  1 
   2 pick 0=  over 0=  or  if                    ( value$ name$ )
1A1F27C 	90 6F A0  1 
1A1F280 	 C 4A A0  1 24 47 A0  1 
1A1F288 	54 49 A0  1 24 47 A0  1 
1A1F290 	70 44 A0  1 DC 41 A0  1 
1A1F298 	3C  0  0  0 
      2drop 2drop                                ( )
1A1F29C 	AC 49 A0  1 
1A1F2A0 	AC 49 A0  1 
      ." Usage: setenv option-name value" cr     ( )
1A1F2A4 	20 7C A0  1 
1A1F2A8 	1F 55 73 61 67 65 3A 20 
1A1F2B0 	73 65 74 65 6E 76 20 6F 
1A1F2B8 	70 74 69 6F 6E 2D 6E 61 
1A1F2C0 	6D 65 20 76 61 6C 75 65 
1A1F2C8 	 0  0  0  0 80 6D A0  1 
      exit                                       ( )
1A1F2D0 	40 46 A0  1 
   then                                          ( value$ name$ )
   $setenv                                       ( )
1A1F2D4 	C4 F1 A1  1 
;
1A1F2D8 	58 46 A0  1 

defer $unsetenv  ( name$ -- )   ' 2drop to $unsetenv
1A1F2DC 	 0  0 24 75 
1A1F2E0 	6E 73 65 74 65 6E 76 89 
1A1F2E8 	60 F2 A1  1 5C 40 A0  1 
1A1F2F0 	2C  6  0  0 
: unsetenv  ( "name" -- )  safe-parse-word $unsetenv  ;
1A1F2F4 	 0  0  0 75 
1A1F2F8 	6E 73 65 74 65 6E 76 88 
1A1F300 	EC F2 A1  1 20 40 A0  1 
1A1F308 	88 93 A0  1 EC F2 A1  1 
1A1F310 	58 46 A0  1 

: show  \ name  ( -- )
1A1F314 	 0  0  0 73 
1A1F318 	68 6F 77 84  4 F3 A1  1 
1A1F320 	20 40 A0  1 
   parse-word dup  if
1A1F324 	34 93 A0  1 
1A1F328 	40 49 A0  1 DC 41 A0  1 
1A1F330 	10  0  0  0 
      (printenv)
1A1F334 	B4 EF A1  1 
   else
1A1F338 	C8 41 A0  1 2C  0  0  0 
      2drop ." Usage: show option-name" cr
1A1F340 	AC 49 A0  1 20 7C A0  1 
1A1F348 	17 55 73 61 67 65 3A 20 
1A1F350 	73 68 6F 77 20 6F 70 74 
1A1F358 	69 6F 6E 2D 6E 61 6D 65 
1A1F360 	 0  0  0  0 80 6D A0  1 
   then
;
1A1F368 	58 46 A0  1 
: list  ( addr count -- )  \ a version of "type" used for displaying nvramrc
1A1F36C 	 0  0  0 6C 
1A1F370 	69 73 74 84 20 F3 A1  1 
1A1F378 	20 40 A0  1 
   bounds  ?do
1A1F37C 	F0 6D A0  1 
1A1F380 	50 42 A0  1 44  0  0  0 
      i c@ newline =  if  cr  exit? ?leave  else  i c@ emit  then
1A1F388 	B4 42 A0  1 C4 4C A0  1 
1A1F390 	A8 71 A0  1 24 48 A0  1 
1A1F398 	DC 41 A0  1 18  0  0  0 
1A1F3A0 	80 6D A0  1 34  D A1  1 
1A1F3A8 	34 43 A0  1 C8 41 A0  1 
1A1F3B0 	10  0  0  0 B4 42 A0  1 
1A1F3B8 	C4 4C A0  1 2C 6C A0  1 
   loop
1A1F3C0 	F8 41 A0  1 C4 FF FF FF 
;
1A1F3C8 	58 46 A0  1 

headerless
h# 2000 constant /$edit-max
1A1F3CC 	 0 2F 24 65 
1A1F3D0 	64 69 74 2D 6D 61 78 8A 
1A1F3D8 	78 F3 A1  1 68 40 A0  1 
1A1F3E0 	 0 20  0  0 
0 value $edit-buf
1A1F3E4 	 0  0 24 65 
1A1F3E8 	64 69 74 2D 62 75 66 89 
1A1F3F0 	DC F3 A1  1 50 40 A0  1 
1A1F3F8 	30  6  0  0 
: .edit-msg  ( -- )   ." Type Enter or Return to finish editing" cr  ;
1A1F3FC 	 0  0 2E 65 
1A1F400 	64 69 74 2D 6D 73 67 89 
1A1F408 	F4 F3 A1  1 20 40 A0  1 
1A1F410 	20 7C A0  1 26 54 79 70 
1A1F418 	65 20 45 6E 74 65 72 20 
1A1F420 	6F 72 20 52 65 74 75 72 
1A1F428 	6E 20 74 6F 20 66 69 6E 
1A1F430 	69 73 68 20 65 64 69 74 
1A1F438 	69 6E 67  0 80 6D A0  1 
1A1F440 	58 46 A0  1 
: $edit  ( default$ -- edited$ )
1A1F444 	 0  0 24 65 
1A1F448 	64 69 74 85  C F4 A1  1 
1A1F450 	20 40 A0  1 
   $edit-buf  0=  if  /$edit-max alloc-mem to $edit-buf  then   ( default$ )
1A1F454 	F4 F3 A1  1 
1A1F458 	24 47 A0  1 DC 41 A0  1 
1A1F460 	14  0  0  0 DC F3 A1  1 
1A1F468 	F0 6C A0  1 B8 40 A0  1 
1A1F470 	F4 F3 A1  1 
   $edit-buf /$edit-max erase           ( default$ )
1A1F474 	F4 F3 A1  1 
1A1F478 	DC F3 A1  1 F0 72 A0  1 
   tuck  $edit-buf swap  move           ( len )
1A1F480 	E8 46 A0  1 F4 F3 A1  1 
1A1F488 	68 49 A0  1 F4 4A A0  1 
   $edit-buf swap /$edit-max edit-line  ( len' )
1A1F490 	F4 F3 A1  1 68 49 A0  1 
1A1F498 	DC F3 A1  1 40 5F A1  1 
   $edit-buf swap   
1A1F4A0 	F4 F3 A1  1 68 49 A0  1 
;
1A1F4A8 	58 46 A0  1 
: free-edit-buf  ( -- )
1A1F4AC 	 0  0 66 72 
1A1F4B0 	65 65 2D 65 64 69 74 2D 
1A1F4B8 	62 75 66 8D 50 F4 A1  1 
1A1F4C0 	20 40 A0  1 
   $edit-buf  if  $edit-buf /$edit-max free-mem  0 to $edit-buf  then 
1A1F4C4 	F4 F3 A1  1 
1A1F4C8 	DC 41 A0  1 1C  0  0  0 
1A1F4D0 	F4 F3 A1  1 DC F3 A1  1 
1A1F4D8 	 8 6D A0  1 70 6F A0  1 
1A1F4E0 	B8 40 A0  1 F4 F3 A1  1 
;
1A1F4E8 	58 46 A0  1 
headers
: $editenv  ( name$ -- )
1A1F4EC 	 0  0  0 24 
1A1F4F0 	65 64 69 74 65 6E 76 88 
1A1F4F8 	C0 F4 A1  1 20 40 A0  1 
   2dup  $getenv  if  null$  then            ( name$ value$ )
1A1F500 	C0 49 A0  1 48 6D A0  1 
1A1F508 	DC 41 A0  1  8  0  0  0 
1A1F510 	7C E1 A1  1 

   .edit-msg $edit                           ( name$ value$' )
1A1F514 	 C F4 A1  1 
1A1F518 	50 F4 A1  1 

   \ If the new value is empty and the variable can be deleted,
   \ offer the user the opportunity to do so.
   dup  0=  if                               ( name$ value$ )
1A1F51C 	40 49 A0  1 
1A1F520 	24 47 A0  1 DC 41 A0  1 
1A1F528 	54  0  0  0 
      2over  $find-option  if                ( name$ value$ xt )
1A1F52C 	D8 49 A0  1 
1A1F530 	FC EB A1  1 DC 41 A0  1 
1A1F538 	10  0  0  0 
         drop                                ( name$ value$ )
1A1F53C 	30 49 A0  1 
      else                                   ( name$ value$ )
1A1F540 	C8 41 A0  1 38  0  0  0 
         " Delete variable"  confirmed?  if  ( name$ value$ )
1A1F548 	9C 53 A0  1  F 44 65 6C 
1A1F550 	65 74 65 20 76 61 72 69 
1A1F558 	61 62 6C 65  0  0  0  0 
1A1F560 	8C 10 A1  1 DC 41 A0  1 
1A1F568 	14  0  0  0 
            2drop  $unsetenv                 ( )
1A1F56C 	AC 49 A0  1 
1A1F570 	EC F2 A1  1 
            free-edit-buf                    ( )
1A1F574 	C0 F4 A1  1 
            exit
1A1F578 	40 46 A0  1 
         then                                ( name$ value$ )
      then                                   ( name$ value$ )
   then                                      ( name$ value$ )

   " Update configuration variable" confirmed?  if  ( name$ value$ )
1A1F57C 	9C 53 A0  1 
1A1F580 	1D 55 70 64 61 74 65 20 
1A1F588 	63 6F 6E 66 69 67 75 72 
1A1F590 	61 74 69 6F 6E 20 76 61 
1A1F598 	72 69 61 62 6C 65  0  0 
1A1F5A0 	8C 10 A1  1 DC 41 A0  1 
1A1F5A8 	14  0  0  0 
      2swap $setenv                                 ( )
1A1F5AC 	F4 49 A0  1 
1A1F5B0 	C4 F1 A1  1 
   else                                             ( name$ value$ )
1A1F5B4 	C8 41 A0  1 
1A1F5B8 	 8  0  0  0 
      4drop                                         ( )
1A1F5BC 	38 53 A0  1 
   then                                             ( )

   free-edit-buf
1A1F5C0 	C0 F4 A1  1 
;
1A1F5C4 	58 46 A0  1 
: editenv  ( "name" -- )  safe-parse-word $editenv  ;
1A1F5C8 	65 64 69 74 65 6E 76 87 
1A1F5D0 	FC F4 A1  1 20 40 A0  1 
1A1F5D8 	88 93 A0  1 FC F4 A1  1 
1A1F5E0 	58 46 A0  1 


\ From propenc.fth
purpose: Property encoding and decoding primitives

\ External encoding and decoding for primitive data types

\ Encode integers into a byte array, suitable for passing to Unix.
\ Decode integers from a byte array.

decimal
headers
\ Merge two property-encoded arrays into a single array
\ Assumes that adr0+len0 == adr1
: encode+    ( adr0 len0 adr1 len1 -- adr0 len0+len1 )  nip +  ;
1A1F5E4 	65 6E 63 6F 
1A1F5E8 	64 65 2B 87 D4 F5 A1  1 
1A1F5F0 	20 40 A0  1 FC 46 A0  1 
1A1F5F8 	 4 45 A0  1 58 46 A0  1 


\ Copy a byte array into the dictionary.
: encode-bytes  ( adr len -- adr' len )
1A1F600 	 0  0  0 65 6E 63 6F 64 
1A1F608 	65 2D 62 79 74 65 73 8C 
1A1F610 	F0 F5 A1  1 20 40 A0  1 
   here >r                      ( adr len )
1A1F618 	70 54 A0  1 BC 45 A0  1 
   bounds  ?do  i c@ c,  loop   ( rs: start )
1A1F620 	F0 6D A0  1 50 42 A0  1 
1A1F628 	18  0  0  0 B4 42 A0  1 
1A1F630 	C4 4C A0  1 B8 55 A0  1 
1A1F638 	F8 41 A0  1 F0 FF FF FF 
   r> here over -               ( adr' len )
1A1F640 	D0 45 A0  1 70 54 A0  1 
1A1F648 	54 49 A0  1 18 45 A0  1 
;
1A1F650 	58 46 A0  1 

: decode-bytes  ( adr1 len1  len2  -- adr1+len2 len1-len2  adr1 len2 )
1A1F654 	 0  0  0 64 
1A1F658 	65 63 6F 64 65 2D 62 79 
1A1F660 	74 65 73 8C 14 F6 A1  1 
1A1F668 	20 40 A0  1 
   >r  over swap r@ /string  rot r>
1A1F66C 	BC 45 A0  1 
1A1F670 	54 49 A0  1 68 49 A0  1 
1A1F678 	E4 45 A0  1 3C 85 A0  1 
1A1F680 	7C 49 A0  1 D0 45 A0  1 
;
1A1F688 	58 46 A0  1 


\ Copy a string to the dictionary, and add a null byte at the end
: encode-string  ( adr len -- adr' len+1 )
1A1F68C 	 0  0 65 6E 
1A1F690 	63 6F 64 65 2D 73 74 72 
1A1F698 	69 6E 67 8D 68 F6 A1  1 
1A1F6A0 	20 40 A0  1 
   here >r                             ( adr len )
1A1F6A4 	70 54 A0  1 
1A1F6A8 	BC 45 A0  1 
   bounds  ?do  i c@ c,  loop   0 c,   ( )  ( rs: start )
1A1F6AC 	F0 6D A0  1 
1A1F6B0 	50 42 A0  1 18  0  0  0 
1A1F6B8 	B4 42 A0  1 C4 4C A0  1 
1A1F6C0 	B8 55 A0  1 F8 41 A0  1 
1A1F6C8 	F0 FF FF FF 70 6F A0  1 
1A1F6D0 	B8 55 A0  1 
   r> here over -                      ( adr' len+1 )
1A1F6D4 	D0 45 A0  1 
1A1F6D8 	70 54 A0  1 54 49 A0  1 
1A1F6E0 	18 45 A0  1 
;
1A1F6E4 	58 46 A0  1 

\ adrb,lenb is the initial null-terminated string from the argument string.
\ lenb does not include the null.  adra lena is the remainder string.
: decode-string  ( adr len -- adra lena adrb lenb )
1A1F6E8 	 0  0 64 65 63 6F 64 65 
1A1F6F0 	2D 73 74 72 69 6E 67 8D 
1A1F6F8 	A0 F6 A1  1 20 40 A0  1 
   0 left-parse-string
1A1F700 	70 6F A0  1 44 D7 A0  1 
;
1A1F708 	58 46 A0  1 
: get-encoded-string  ( adr len -- adr len-1 )  1-  ;
1A1F70C 	 0 67 65 74 
1A1F710 	2D 65 6E 63 6F 64 65 64 
1A1F718 	2D 73 74 72 69 6E 67 92 
1A1F720 	FC F6 A1  1 20 40 A0  1 
1A1F728 	54 4B A0  1 58 46 A0  1 

\ Copy an int as 4 bytes to the dictionary
: encode-int  ( i -- adr len )   here  swap be-l,  /l  ;
1A1F730 	 0 65 6E 63 6F 64 65 2D 
1A1F738 	69 6E 74 8A 24 F7 A1  1 
1A1F740 	20 40 A0  1 70 54 A0  1 
1A1F748 	68 49 A0  1 48 7A A1  1 
1A1F750 	30 51 A0  1 58 46 A0  1 

: decode-int  ( adr len -- adr' len' n )
1A1F758 	 0 64 65 63 6F 64 65 2D 
1A1F760 	69 6E 74 8A 40 F7 A1  1 
1A1F768 	20 40 A0  1 
   over be-l@ >r  /l /string  r> l->n
1A1F76C 	54 49 A0  1 
1A1F770 	30 FC A0  1 BC 45 A0  1 
1A1F778 	30 51 A0  1 3C 85 A0  1 
1A1F780 	D0 45 A0  1 88 61 A0  1 
;
1A1F788 	58 46 A0  1 
: get-encoded-int  ( adr len -- n )  drop be-l@  ;
1A1F78C 	67 65 74 2D 
1A1F790 	65 6E 63 6F 64 65 64 2D 
1A1F798 	69 6E 74 8F 68 F7 A1  1 
1A1F7A0 	20 40 A0  1 30 49 A0  1 
1A1F7A8 	30 FC A0  1 58 46 A0  1 

: encode-cell  ( n -- adr len )   here  swap be-n,  /n  ;
1A1F7B0 	65 6E 63 6F 64 65 2D 63 
1A1F7B8 	65 6C 6C 8B A0 F7 A1  1 
1A1F7C0 	20 40 A0  1 70 54 A0  1 
1A1F7C8 	68 49 A0  1 E0 FC A0  1 
1A1F7D0 	40 51 A0  1 58 46 A0  1 

: decode-cell  ( adr len -- adr' len' n )
1A1F7D8 	64 65 63 6F 64 65 2D 63 
1A1F7E0 	65 6C 6C 8B C0 F7 A1  1 
1A1F7E8 	20 40 A0  1 
   over be-x@ >r  /x /string  r>
1A1F7EC 	54 49 A0  1 
1A1F7F0 	3C FD A0  1 BC 45 A0  1 
1A1F7F8 	 0 FD A0  1 3C 85 A0  1 
1A1F800 	D0 45 A0  1 
;
1A1F804 	58 46 A0  1 
: get-encoded-cell  ( adr len -- n )  drop be-n@  ;
1A1F808 	 0  0  0 67 65 74 2D 65 
1A1F810 	6E 63 6F 64 65 64 2D 63 
1A1F818 	65 6C 6C 90 E8 F7 A1  1 
1A1F820 	20 40 A0  1 30 49 A0  1 
1A1F828 	30 FC A0  1 58 46 A0  1 
headers

\ From devtree.fth
purpose: 

headers

defer voc>phandle ' noop to voc>phandle
1A1F830 	76 6F 63 3E 70 68 61 6E 
1A1F838 	64 6C 65 8B 20 F8 A1  1 
1A1F840 	5C 40 A0  1 34  6  0  0 
defer phandle>voc ' noop to phandle>voc
1A1F848 	70 68 61 6E 64 6C 65 3E 
1A1F850 	76 6F 63 8B 40 F8 A1  1 
1A1F858 	5C 40 A0  1 38  6  0  0 
defer dt-null     ' null to dt-null
1A1F860 	64 74 2D 6E 75 6C 6C 87 
1A1F868 	58 F8 A1  1 5C 40 A0  1 
1A1F870 	3C  6  0  0 

\ : : :  lastacf .name cr ;

: rel-voc>phandle  ( voc -- ph )  origin -  ;  ' rel-voc>phandle to voc>phandle
1A1F874 	72 65 6C 2D 
1A1F878 	76 6F 63 3E 70 68 61 6E 
1A1F880 	64 6C 65 8F 6C F8 A1  1 
1A1F888 	20 40 A0  1 50 55 A0  1 
1A1F890 	18 45 A0  1 58 46 A0  1 
: rel-phandle>voc  ( ph -- voc )  origin +  ;  ' rel-phandle>voc to phandle>voc
1A1F898 	72 65 6C 2D 70 68 61 6E 
1A1F8A0 	64 6C 65 3E 76 6F 63 8F 
1A1F8A8 	88 F8 A1  1 20 40 A0  1 
1A1F8B0 	50 55 A0  1  4 45 A0  1 
1A1F8B8 	58 46 A0  1 
' 0 to dt-null

\ TODO
\ Don't use the system search order; use a private stack
\ $find searches through the private stack
\ Change names back from "regprop" to "reg", etc.
\ Either implement a true breadth-first search or don't specify it.

: cdev drop context token@  voc>phandle  ;
1A1F8BC 	 0  0  0 63 
1A1F8C0 	64 65 76 84 AC F8 A1  1 
1A1F8C8 	20 40 A0  1 30 49 A0  1 
1A1F8D0 	DC A3 A0  1  C 54 A0  1 
1A1F8D8 	40 F8 A1  1 58 46 A0  1 
: devc drop phandle>voc  context token!  definitions  ;
1A1F8E0 	 0  0  0 64 65 76 63 84 
1A1F8E8 	C8 F8 A1  1 20 40 A0  1 
1A1F8F0 	30 49 A0  1 58 F8 A1  1 
1A1F8F8 	DC A3 A0  1 20 54 A0  1 
1A1F900 	2C C4 A0  1 58 46 A0  1 
2 actions
1A1F908 	20 F9 A1  1  2  0  0  0 
action: cdev ;
1A1F910 	90 90 90 E8 64 47 FE FF 
1A1F918 	C8 F8 A1  1 58 46 A0  1 
action: devc ;
1A1F920 	20 40 A0  1 EC F8 A1  1 
1A1F928 	58 46 A0  1 
create current-device  use-actions
1A1F92C 	 0 63 75 72 
1A1F930 	72 65 6E 74 2D 64 65 76 
1A1F938 	69 63 65 8E EC F8 A1  1 
1A1F940 	10 F9 A1  1 

action-adr-t to ^current-device

headerless
: ufield  \ name  ( offset size -- offset' )
1A1F944 	 0 75 66 69 
1A1F948 	65 6C 64 86 40 F9 A1  1 
1A1F950 	20 40 A0  1 
   create  over ,   +
1A1F954 	A8 A2 A0  1 
1A1F958 	54 49 A0  1 98 55 A0  1 
1A1F960 	 4 45 A0  1 
   does>  @  current-device  phandle>voc  >body >user +
1A1F964 	50 A3 A0  1 
1A1F968 	90 90 90 E8  C 47 FE FF 
1A1F970 	5C 4C A0  1 40 F9 A1  1 
1A1F978 	58 F8 A1  1 E4 59 A0  1 
1A1F980 	C8 74 A0  1  4 45 A0  1 
;
1A1F988 	58 46 A0  1 

\ Notes for a more abstract searching mechanism:
\ Instead of the child and peer links in the device node, packages
\ with children have "search", "create", and "enumerate" methods.
\ To search a level, call that package's search method.  Those
\ methods probably need to work from a phandle, not an ihandle.

: unaligned-ualloc  ( size -- user# )
1A1F98C 	 0  0  0 75 
1A1F990 	6E 61 6C 69 67 6E 65 64 
1A1F998 	2D 75 61 6C 6C 6F 63 90 
1A1F9A0 	50 F9 A1  1 20 40 A0  1 
   #user @  dup user-size > abort" User area used up!"  ( size user# )
1A1F9A8 	7C 66 A0  1 5C 4C A0  1 
1A1F9B0 	40 49 A0  1 E8 65 A0  1 
1A1F9B8 	 4 48 A0  1  8 81 A0  1 
1A1F9C0 	12 55 73 65 72 20 61 72 
1A1F9C8 	65 61 20 75 73 65 64 20 
1A1F9D0 	75 70 21  0 
   swap #user +!  ( user# )
1A1F9D4 	68 49 A0  1 
1A1F9D8 	7C 66 A0  1  C 4C A0  1 
;
1A1F9E0 	58 46 A0  1 

struct  ( devnode )
/link #threads *  ufield  'threads	\ Package methods
1A1F9E4 	 0  0  0 27 
1A1F9E8 	74 68 72 65 61 64 73 88 
1A1F9F0 	A4 F9 A1  1 68 F9 A1  1 
1A1F9F8 	 0  0  0  0 
dup				\ The following fields will be "ualloc"ed
   /token  ufield  'child	\ Pointer to first child
1A1F9FC 	 0 27 63 68 
1A1FA00 	69 6C 64 86 F4 F9 A1  1 
1A1FA08 	68 F9 A1  1  4  0  0  0 
   /token  ufield  'peer	\ Pointer to next peer
1A1FA10 	 0  0 27 70 65 65 72 85 
1A1FA18 	 8 FA A1  1 68 F9 A1  1 
1A1FA20 	 8  0  0  0 
   /token  ufield  'properties	\ Pointer to properties vocabulary
1A1FA24 	27 70 72 6F 
1A1FA28 	70 65 72 74 69 65 73 8B 
1A1FA30 	1C FA A1  1 68 F9 A1  1 
1A1FA38 	 C  0  0  0 
   /n      ufield  '#adr-cells	\ Size of a parent address
1A1FA3C 	27 23 61 64 
1A1FA40 	72 2D 63 65 6C 6C 73 8B 
1A1FA48 	34 FA A1  1 68 F9 A1  1 
1A1FA50 	10  0  0  0 
   /n      ufield  '#buffers
1A1FA54 	 0  0 27 23 
1A1FA58 	62 75 66 66 65 72 73 89 
1A1FA60 	4C FA A1  1 68 F9 A1  1 
1A1FA68 	14  0  0  0 
   /n      ufield  '#values
1A1FA6C 	 0  0  0 27 
1A1FA70 	23 76 61 6C 75 65 73 88 
1A1FA78 	64 FA A1  1 68 F9 A1  1 
1A1FA80 	18  0  0  0 
   /token  ufield  'values
1A1FA84 	27 76 61 6C 
1A1FA88 	75 65 73 87 7C FA A1  1 
1A1FA90 	68 F9 A1  1 1C  0  0  0 
( starting-offset ending-offset )  swap -  ( size-to-ualloc )
constant /devnode-extra
1A1FA98 	 0 2F 64 65 76 6E 6F 64 
1A1FAA0 	65 2D 65 78 74 72 61 8E 
1A1FAA8 	90 FA A1  1 68 40 A0  1 
1A1FAB0 	1C  0  0  0 

headers
: >parent  ( node -- parent-node )  phandle>voc >voc-link  a@ voc>phandle  ;
1A1FAB4 	3E 70 61 72 
1A1FAB8 	65 6E 74 87 AC FA A1  1 
1A1FAC0 	20 40 A0  1 58 F8 A1  1 
1A1FAC8 	50 B6 A0  1 88 58 A0  1 
1A1FAD0 	40 F8 A1  1 58 46 A0  1 
: parent-device  ( -- parent-node )  current-device >parent  ;
1A1FAD8 	 0  0 70 61 72 65 6E 74 
1A1FAE0 	2D 64 65 76 69 63 65 8D 
1A1FAE8 	C0 FA A1  1 20 40 A0  1 
1A1FAF0 	40 F9 A1  1 C0 FA A1  1 
1A1FAF8 	58 46 A0  1 

: (select-package)  ( phandle -- )  phandle>voc execute  ;
1A1FAFC 	 0  0  0 28 
1A1FB00 	73 65 6C 65 63 74 2D 70 
1A1FB08 	61 63 6B 61 67 65 29 90 
1A1FB10 	EC FA A1  1 20 40 A0  1 
1A1FB18 	58 F8 A1  1 98 41 A0  1 
1A1FB20 	58 46 A0  1 
: (push-package)  ( phandle -- )  also (select-package)  ;
1A1FB24 	 0 28 70 75 
1A1FB28 	73 68 2D 70 61 63 6B 61 
1A1FB30 	67 65 29 8E 14 FB A1  1 
1A1FB38 	20 40 A0  1 C8 C1 A0  1 
1A1FB40 	14 FB A1  1 58 46 A0  1 
: (pop-package)  ( phandle -- )  previous  ;
1A1FB48 	 0  0 28 70 6F 70 2D 70 
1A1FB50 	61 63 6B 61 67 65 29 8D 
1A1FB58 	38 FB A1  1 20 40 A0  1 
1A1FB60 	E4 C3 A0  1 58 46 A0  1 
: push-package  ( phandle -- )
1A1FB68 	 0  0  0 70 75 73 68 2D 
1A1FB70 	70 61 63 6B 61 67 65 8C 
1A1FB78 	5C FB A1  1 20 40 A0  1 
   dup  0=  if  ." Attempting to push null package!!!" abort  then
1A1FB80 	40 49 A0  1 24 47 A0  1 
1A1FB88 	DC 41 A0  1 30  0  0  0 
1A1FB90 	20 7C A0  1 22 41 74 74 
1A1FB98 	65 6D 70 74 69 6E 67 20 
1A1FBA0 	74 6F 20 70 75 73 68 20 
1A1FBA8 	6E 75 6C 6C 20 70 61 63 
1A1FBB0 	6B 61 67 65 21 21 21  0 
1A1FBB8 	28 91 A0  1 
   (push-package)  definitions
1A1FBBC 	38 FB A1  1 
1A1FBC0 	2C C4 A0  1 
;
1A1FBC4 	58 46 A0  1 
: pop-package  ( -- )  (pop-package) definitions  ;
1A1FBC8 	70 6F 70 2D 70 61 63 6B 
1A1FBD0 	61 67 65 8B 7C FB A1  1 
1A1FBD8 	20 40 A0  1 5C FB A1  1 
1A1FBE0 	2C C4 A0  1 58 46 A0  1 
: push-device  ( phandle -- )  to current-device  ;
1A1FBE8 	70 75 73 68 2D 64 65 76 
1A1FBF0 	69 63 65 8B D8 FB A1  1 
1A1FBF8 	20 40 A0  1 48 B8 A1  1 
1A1FC00 	40 F9 A1  1 58 46 A0  1 

: pop-device  ( -- )
1A1FC08 	 0 70 6F 70 2D 64 65 76 
1A1FC10 	69 63 65 8A F8 FB A1  1 
1A1FC18 	20 40 A0  1 
   parent-device                     ( parent-phandle )
1A1FC1C 	EC FA A1  1 
   dup dt-null <>  if  push-device  else  drop  then
1A1FC20 	40 49 A0  1 6C F8 A1  1 
1A1FC28 	44 48 A0  1 DC 41 A0  1 
1A1FC30 	10  0  0  0 F8 FB A1  1 
1A1FC38 	C8 41 A0  1  8  0  0  0 
1A1FC40 	30 49 A0  1 
\    non-null?  if  push-device  then
;
1A1FC44 	58 46 A0  1 

\ Each package instance has its own private data storage area.
\ The data creation words "value", "variable", and "buffer:",
\ when used during compilation of a package, allocate memory
\ relative to a base pointer.  The package definition includes the
\ initial values for the words created with "value" and "variable".
\ When a package instance is created, memory is allocated for the
\ package's data and the portion used for values and variables is
\ initialized from the values stored in the package definition.
\
\ While the package is being defined (i.e. its code is being compiled),
\ a "dummy" instance is created with space for data, so that
\ data words may be used as soon as they are created.  The "dummy"
\ instance data area is given a "generous" default size (for 100 * cellsize
\ bytes of initialized data, 700 * cellsize for buffers).
\ Hopefully this won't be exceeded.

headerless
variable package-level  package-level off
1A1FC48 	 0  0 70 61 63 6B 61 67 
1A1FC50 	65 2D 6C 65 76 65 6C 8D 
1A1FC58 	18 FC A1  1 48 40 A0  1 
1A1FC60 	40  6  0  0 
variable next-is-package  next-is-package off
1A1FC64 	6E 65 78 74 
1A1FC68 	2D 69 73 2D 70 61 63 6B 
1A1FC70 	61 67 65 8F 5C FC A1  1 
1A1FC78 	48 40 A0  1 44  6  0  0 
variable next-is-instance  next-is-instance off
1A1FC80 	 0  0  0 6E 65 78 74 2D 
1A1FC88 	69 73 2D 69 6E 73 74 61 
1A1FC90 	6E 63 65 90 78 FC A1  1 
1A1FC98 	48 40 A0  1 48  6  0  0 
: instance?  ( -- flag )
1A1FCA0 	 0  0 69 6E 73 74 61 6E 
1A1FCA8 	63 65 3F 89 98 FC A1  1 
1A1FCB0 	20 40 A0  1 
   package-level @ 0<>  next-is-instance @  and
1A1FCB4 	5C FC A1  1 
1A1FCB8 	5C 4C A0  1 44 47 A0  1 
1A1FCC0 	98 FC A1  1 5C 4C A0  1 
1A1FCC8 	5C 44 A0  1 
   next-is-instance off
1A1FCCC 	98 FC A1  1 
1A1FCD0 	F8 4B A0  1 
;
1A1FCD4 	58 46 A0  1 
: package?  ( -- flag )
1A1FCD8 	 0  0  0 70 61 63 6B 61 
1A1FCE0 	67 65 3F 88 B0 FC A1  1 
1A1FCE8 	20 40 A0  1 
   package-level @ 0<>  next-is-package @  and
1A1FCEC 	5C FC A1  1 
1A1FCF0 	5C 4C A0  1 44 47 A0  1 
1A1FCF8 	78 FC A1  1 5C 4C A0  1 
1A1FD00 	5C 44 A0  1 
   next-is-package off
1A1FD04 	78 FC A1  1 
1A1FD08 	F8 4B A0  1 
;
1A1FD0C 	58 46 A0  1 
headers
: instance  ( -- )  next-is-instance on  ;
1A1FD10 	 0  0  0 69 6E 73 74 61 
1A1FD18 	6E 63 65 88 E8 FC A1  1 
1A1FD20 	20 40 A0  1 98 FC A1  1 
1A1FD28 	E0 4B A0  1 58 46 A0  1 
: package  ( -- )  next-is-package on  ;
1A1FD30 	70 61 63 6B 61 67 65 87 
1A1FD38 	20 FD A1  1 20 40 A0  1 
1A1FD40 	78 FC A1  1 E0 4B A0  1 
1A1FD48 	58 46 A0  1 
: global   ( -- )  next-is-package off  ;  \ The default, for now
1A1FD4C 	 0 67 6C 6F 
1A1FD50 	62 61 6C 86 3C FD A1  1 
1A1FD58 	20 40 A0  1 78 FC A1  1 
1A1FD60 	F8 4B A0  1 58 46 A0  1 
headerless

\ Should be in machine code
: >instance-data  ( pfa -- adr )
1A1FD68 	 0 3E 69 6E 73 74 61 6E 
1A1FD70 	63 65 2D 64 61 74 61 8E 
1A1FD78 	58 FD A1  1 20 40 A0  1 
   my-self  if  @ my-self + exit  then
1A1FD80 	EC 7E A0  1 DC 41 A0  1 
1A1FD88 	14  0  0  0 5C 4C A0  1 
1A1FD90 	EC 7E A0  1  4 45 A0  1 
1A1FD98 	40 46 A0  1 
   true abort" Tried to access instance-specific data with no current instance"
1A1FD9C 	 4 70 A0  1 
1A1FDA0 	 8 81 A0  1 3F 54 72 69 
1A1FDA8 	65 64 20 74 6F 20 61 63 
1A1FDB0 	63 65 73 73 20 69 6E 73 
1A1FDB8 	74 61 6E 63 65 2D 73 70 
1A1FDC0 	65 63 69 66 69 63 20 64 
1A1FDC8 	61 74 61 20 77 69 74 68 
1A1FDD0 	20 6E 6F 20 63 75 72 72 
1A1FDD8 	65 6E 74 20 69 6E 73 74 
1A1FDE0 	61 6E 63 65  0  0  0  0 
;
1A1FDE8 	58 46 A0  1 

\ Sizes of the initialized and unitialized portions of the buffer that
\ is used as the instance data when the package is being created.
\ This allows variables, buffers, and values to be used while the
\ package is being created.

d# 100 /n* constant /value-area
1A1FDEC 	2F 76 61 6C 
1A1FDF0 	75 65 2D 61 72 65 61 8B 
1A1FDF8 	7C FD A1  1 68 40 A0  1 
1A1FE00 	90  1  0  0 
d# 700 /n* constant /buffer-area
1A1FE04 	 0  0  0 2F 
1A1FE08 	62 75 66 66 65 72 2D 61 
1A1FE10 	72 65 61 8C FC FD A1  1 
1A1FE18 	68 40 A0  1 F0  A  0  0 

: value#,  ( size -- adr )
1A1FE20 	76 61 6C 75 65 23 2C 87 
1A1FE28 	18 FE A1  1 20 40 A0  1 
   '#values @  dup ,   ( size offset )
1A1FE30 	7C FA A1  1 5C 4C A0  1 
1A1FE38 	40 49 A0  1 98 55 A0  1 
   tuck +              ( offset offset' )
1A1FE40 	E8 46 A0  1  4 45 A0  1 
   dup /value-area >= abort" Too many instance variables/values/defers"
1A1FE48 	40 49 A0  1 FC FD A1  1 
1A1FE50 	EC 48 A0  1  8 81 A0  1 
1A1FE58 	29 54 6F 6F 20 6D 61 6E 
1A1FE60 	79 20 69 6E 73 74 61 6E 
1A1FE68 	63 65 20 76 61 72 69 61 
1A1FE70 	62 6C 65 73 2F 76 61 6C 
1A1FE78 	75 65 73 2F 64 65 66 65 
1A1FE80 	72 73  0  0 
   '#values !          ( offset )
1A1FE84 	7C FA A1  1 
1A1FE88 	54 4D A0  1 
   my-self +           ( adr )
1A1FE8C 	EC 7E A0  1 
1A1FE90 	 4 45 A0  1 
;
1A1FE94 	58 46 A0  1 

headers
: value  \ name  ( initial-value -- )
1A1FE98 	 0  0 76 61 6C 75 65 85 
1A1FEA0 	2C FE A1  1 20 40 A0  1 
   header noop   \  Will patch with (value)
1A1FEA8 	DC 6D A0  1 E8  5 A2  1 
;
1A1FEB0 	58 46 A0  1 
headerless
3 actions
1A1FEB4 	E4 FE A1  1 
1A1FEB8 	D4 FE A1  1  3  0  0  0 
action:  >instance-data @  ;
1A1FEC0 	90 90 90 E8 B4 41 FE FF 
1A1FEC8 	7C FD A1  1 5C 4C A0  1 
1A1FED0 	58 46 A0  1 
action:  >instance-data !  ;
1A1FED4 	20 40 A0  1 
1A1FED8 	7C FD A1  1 54 4D A0  1 
1A1FEE0 	58 46 A0  1 
action:  >instance-data    ;
1A1FEE4 	20 40 A0  1 
1A1FEE8 	7C FD A1  1 58 46 A0  1 
action-adr-t to ^instance
: instance-value  ( initial-value -- )
1A1FEF0 	 0 69 6E 73 74 61 6E 63 
1A1FEF8 	65 2D 76 61 6C 75 65 8E 
1A1FF00 	A4 FE A1  1 20 40 A0  1 
   create-cf use-actions  /n value#, !
1A1FF08 	30 5B A0  1 60 53 A0  1 
1A1FF10 	C0 FE A1  1 E0 57 A0  1 
1A1FF18 	40 51 A0  1 2C FE A1  1 
1A1FF20 	54 4D A0  1 
;
1A1FF24 	58 46 A0  1 

\ Create fields which are present in every instance record.
\ "fixed instance value"

headers
transient
: fibuf:  \ name  ( offset -- offset' )
1A1FF28 	 0 66 69 62 75 66 3A 86 
1A1FF30 	 4 FF A1  1 20 40 A0  1 
   create -1 na+ dup ,  ( offset' )
1A1FF38 	A8 A2 A0  1 58 41 A0  1 
1A1FF40 	FF FF FF FF 48 50 A0  1 
1A1FF48 	40 49 A0  1 98 55 A0  1 
   use-actions
1A1FF50 	60 53 A0  1 C0 FE A1  1 
1A1FF58 	E0 57 A0  1 
;
1A1FF5C 	58 46 A0  1 
: fival:  \ name  ( offset -- offset' )
1A1FF60 	 0 66 69 76 61 6C 3A 86 
1A1FF68 	34 FF A1  1 20 40 A0  1 
   create dup , na1+ ( offset' )
1A1FF70 	A8 A2 A0  1 40 49 A0  1 
1A1FF78 	98 55 A0  1 CC 50 A0  1 
   use-actions
1A1FF80 	60 53 A0  1 C0 FE A1  1 
1A1FF88 	E0 57 A0  1 
;
1A1FF8C 	58 46 A0  1 
resident

headerless
: 2value  \ name  ( d.initial-value -- )
1A1FF90 	 0 32 76 61 6C 75 65 86 
1A1FF98 	6C FF A1  1 20 40 A0  1 
   header noop   \  Will patch with (2value)
1A1FFA0 	DC 6D A0  1 B8  6 A2  1 
;
1A1FFA8 	58 46 A0  1 

3 actions
1A1FFAC 	DC FF A1  1 
1A1FFB0 	CC FF A1  1  3  0  0  0 
action:  >instance-data 2@  ;
1A1FFB8 	90 90 90 E8 BC 40 FE FF 
1A1FFC0 	7C FD A1  1 CC 4D A0  1 
1A1FFC8 	58 46 A0  1 
action:  >instance-data 2!  ;
1A1FFCC 	20 40 A0  1 
1A1FFD0 	7C FD A1  1 E4 4D A0  1 
1A1FFD8 	58 46 A0  1 
action:  >instance-data     ;
1A1FFDC 	20 40 A0  1 
1A1FFE0 	7C FD A1  1 58 46 A0  1 

: instance-2value  ( d.initial-value -- )
1A1FFE8 	69 6E 73 74 61 6E 63 65 
1A1FFF0 	2D 32 76 61 6C 75 65 8F 
1A1FFF8 	9C FF A1  1 20 40 A0  1 
   create-cf use-actions  /n 2* value#,  2!
1A20000 	30 5B A0  1 60 53 A0  1 
1A20008 	B8 FF A1  1 E0 57 A0  1 
1A20010 	40 51 A0  1 A0 4B A0  1 
1A20018 	2C FE A1  1 E4 4D A0  1 
;
1A20020 	58 46 A0  1 

action-adr-t to ^instance-2value

headers
: buffer:  \ name  ( size -- )
1A20024 	62 75 66 66 
1A20028 	65 72 3A 87 FC FF A1  1 
1A20030 	20 40 A0  1 
   header noop  \ Will patch with (buffer:)
1A20034 	DC 6D A0  1 
1A20038 	88  0 A2  1 
;
1A2003C 	58 46 A0  1 

3 actions
1A20040 	6C  0 A2  1 5C  0 A2  1 
1A20048 	 3  0  0  0 
action:  >instance-data    ;
1A2004C 	90 90 90 E8 
1A20050 	28 40 FE FF 7C FD A1  1 
1A20058 	58 46 A0  1 
action:  >instance-data !  ;
1A2005C 	20 40 A0  1 
1A20060 	7C FD A1  1 54 4D A0  1 
1A20068 	58 46 A0  1 
action:  >instance-data    ;
1A2006C 	20 40 A0  1 
1A20070 	7C FD A1  1 58 46 A0  1 

headerless
: (buffer:)  ( #bytes -- )
1A20078 	 0  0 28 62 75 66 66 65 
1A20080 	72 3A 29 89 30  0 A2  1 
1A20088 	20 40 A0  1 
   instance?  if
1A2008C 	B0 FC A1  1 
1A20090 	DC 41 A0  1 78  0  0  0 
      create-cf
1A20098 	30 5B A0  1 
      '#buffers @ swap aligned -  dup  ,  ( offset' )
1A2009C 	64 FA A1  1 
1A200A0 	5C 4C A0  1 68 49 A0  1 
1A200A8 	EC 5C A0  1 18 45 A0  1 
1A200B0 	40 49 A0  1 98 55 A0  1 
      dup negate /buffer-area > abort" Too many bytes of instance buffers"
1A200B8 	40 49 A0  1 48 45 A0  1 
1A200C0 	18 FE A1  1  4 48 A0  1 
1A200C8 	 8 81 A0  1 22 54 6F 6F 
1A200D0 	20 6D 61 6E 79 20 62 79 
1A200D8 	74 65 73 20 6F 66 20 69 
1A200E0 	6E 73 74 61 6E 63 65 20 
1A200E8 	62 75 66 66 65 72 73  0 
      '#buffers !  use-actions
1A200F0 	64 FA A1  1 54 4D A0  1 
1A200F8 	60 53 A0  1 4C  0 A2  1 
1A20100 	E0 57 A0  1 
   else
1A20104 	C8 41 A0  1 
1A20108 	 8  0  0  0 
      (buffer:)
1A2010C 	A4 A9 A0  1 
   then
; patch (buffer:) noop buffer:
1A20110 	58 46 A0  1 

action-adr-t to ^instanceBUF

headers
: variable  \ name  ( -- )
1A20114 	 0  0  0 76 
1A20118 	61 72 69 61 62 6C 65 88 
1A20120 	88  0 A2  1 20 40 A0  1 
   header  noop \ Will patch with (variable)
1A20128 	DC 6D A0  1 7C  1 A2  1 
;
1A20130 	58 46 A0  1 

3 actions
1A20134 	60  1 A2  1 
1A20138 	50  1 A2  1  3  0  0  0 
action:  >instance-data    ;
1A20140 	90 90 90 E8 34 3F FE FF 
1A20148 	7C FD A1  1 58 46 A0  1 
action:  >instance-data !  ;
1A20150 	20 40 A0  1 7C FD A1  1 
1A20158 	54 4D A0  1 58 46 A0  1 
action:  >instance-data    ;
1A20160 	20 40 A0  1 7C FD A1  1 
1A20168 	58 46 A0  1 

headerless
: (variable)  ( -- )
1A2016C 	 0 28 76 61 
1A20170 	72 69 61 62 6C 65 29 8A 
1A20178 	24  1 A2  1 20 40 A0  1 
   instance?  if
1A20180 	B0 FC A1  1 DC 41 A0  1 
1A20188 	28  0  0  0 
      create-cf use-actions  0 /n value#,  else  user-cf  0 /n  user#,
1A2018C 	30 5B A0  1 
1A20190 	60 53 A0  1 40  1 A2  1 
1A20198 	E0 57 A0  1 70 6F A0  1 
1A201A0 	40 51 A0  1 2C FE A1  1 
1A201A8 	C8 41 A0  1 14  0  0  0 
1A201B0 	C4 5B A0  1 70 6F A0  1 
1A201B8 	40 51 A0  1 84 9A A0  1 
   then
   !
1A201C0 	54 4D A0  1 
; patch (variable) noop variable
1A201C4 	58 46 A0  1 
action-adr-t to ^instance-VARIABLE 
headers
: defer  \ name  ( -- )
1A201C8 	 0  0 64 65 66 65 72 85 
1A201D0 	7C  1 A2  1 20 40 A0  1 
   header noop \ Will patch with (defer)
1A201D8 	DC 6D A0  1 70  2 A2  1 
;
1A201E0 	58 46 A0  1 
3 actions
1A201E4 	18  2 A2  1 
1A201E8 	 8  2 A2  1  3  0  0  0 
action:  >instance-data token@ execute  ;
1A201F0 	90 90 90 E8 84 3E FE FF 
1A201F8 	7C FD A1  1  C 54 A0  1 
1A20200 	98 41 A0  1 58 46 A0  1 
action:  >instance-data token!  ;
1A20208 	20 40 A0  1 7C FD A1  1 
1A20210 	20 54 A0  1 58 46 A0  1 
action:  >instance-data token@  ;
1A20218 	20 40 A0  1 7C FD A1  1 
1A20220 	 C 54 A0  1 58 46 A0  1 

headerless
: instance-defer  ( -- )
1A20228 	 0 69 6E 73 74 61 6E 63 
1A20230 	65 2D 64 65 66 65 72 8E 
1A20238 	D4  1 A2  1 20 40 A0  1 
   create-cf  ['] crash /token  ( value data-size )
1A20240 	30 5B A0  1 60 53 A0  1 
1A20248 	C8 A7 A0  1 B4 46 A0  1 
   use-actions  value#,
1A20250 	60 53 A0  1 F0  1 A2  1 
1A20258 	E0 57 A0  1 2C FE A1  1 
;
1A20260 	58 46 A0  1 
: (defer)  ( -- )
1A20264 	28 64 65 66 
1A20268 	65 72 29 87 3C  2 A2  1 
1A20270 	20 40 A0  1 
   instance?  if
1A20274 	B0 FC A1  1 
1A20278 	DC 41 A0  1 10  0  0  0 
      instance-defer
1A20280 	3C  2 A2  1 
   else
1A20284 	C8 41 A0  1 
1A20288 	18  0  0  0 
      defer-cf  ['] crash /token   ( value data-size )
1A2028C 	30 5C A0  1 
1A20290 	60 53 A0  1 C8 A7 A0  1 
1A20298 	B4 46 A0  1 
      user#,
1A2029C 	84 9A A0  1 
   then                            ( value adr )
   token!
1A202A0 	20 54 A0  1 
; patch (defer) noop defer
1A202A4 	58 46 A0  1 
action-adr-t to ^instance-defer

\ Extend debugger to handle instance defers
: (resolve-instance-defers)  ( xt -- xt' )
1A202A8 	 0  0 28 72 65 73 6F 6C 
1A202B0 	76 65 2D 69 6E 73 74 61 
1A202B8 	6E 63 65 2D 64 65 66 65 
1A202C0 	72 73 29 99 70  2 A2  1 
1A202C8 	20 40 A0  1 
   begin
      dup defer?  if                             ( xt )
1A202CC 	40 49 A0  1 
1A202D0 	 C CA A1  1 DC 41 A0  1 
1A202D8 	10  0  0  0 
	 behavior                                ( xt' )
1A202DC 	10 C7 A0  1 
      else                                       ( xt )
1A202E0 	C8 41 A0  1 34  0  0  0 
         dup definer ['] instance-defer  =  if   ( xt )
1A202E8 	40 49 A0  1 48 3F A1  1 
1A202F0 	60 53 A0  1 3C  2 A2  1 
1A202F8 	24 48 A0  1 DC 41 A0  1 
1A20300 	14  0  0  0 
            2 perform-action                     ( xt' )
1A20304 	90 6F A0  1 
1A20308 	10 B8 A1  1 
	 else                                    ( xt )
1A2030C 	C8 41 A0  1 
1A20310 	 8  0  0  0 
	    exit
1A20314 	40 46 A0  1 
         then
      then
   again
1A20318 	C8 41 A0  1 B0 FF FF FF 
;
1A20320 	58 46 A0  1 
' (resolve-instance-defers) to resolve-defers

\ Extend decompiler to handle instance defers
: .instance-defer  ( xt definer -- )
1A20324 	2E 69 6E 73 
1A20328 	74 61 6E 63 65 2D 64 65 
1A20330 	66 65 72 8F C8  2 A2  1 
1A20338 	20 40 A0  1 
   .definer  ." is " cr   ( xt )
1A2033C 	88 39 A1  1 
1A20340 	20 7C A0  1  3 69 73 20 
1A20348 	 0  0  0  0 80 6D A0  1 
   2 perform-action       ( xt' )
1A20350 	90 6F A0  1 10 B8 A1  1 
   (see)
1A20358 	98 20 A1  1 
;
1A2035C 	58 46 A0  1 
' instance-defer  ' .instance-defer  install-decomp-definer

headers
\ Instance values that are automatically created for every package instance.

0
fival: my-adr0		\ F: First component of device probe address
1A20360 	6D 79 2D 61 64 72 30 87 
1A20368 	38  3 A2  1 C0 FE A1  1 
1A20370 	 0  0  0  0 
fival: my-adr1		\ F: Intermediate component of device probe address
1A20374 	6D 79 2D 61 
1A20378 	64 72 31 87 6C  3 A2  1 
1A20380 	C0 FE A1  1  4  0  0  0 
fival: my-adr2		\ F: Intermediate component of device probe address
1A20388 	6D 79 2D 61 64 72 32 87 
1A20390 	80  3 A2  1 C0 FE A1  1 
1A20398 	 8  0  0  0 
fival: my-space 	\ F: Last component of device probe address
1A2039C 	 0  0  0 6D 
1A203A0 	79 2D 73 70 61 63 65 88 
1A203A8 	94  3 A2  1 C0 FE A1  1 
1A203B0 	 C  0  0  0 
fival: frame-buffer-adr \ F: Frame buffer address.  Strictly speaking, this
1A203B4 	 0  0  0 66 
1A203B8 	72 61 6D 65 2D 62 75 66 
1A203C0 	66 65 72 2D 61 64 72 90 
1A203C8 	AC  3 A2  1 C0 FE A1  1 
1A203D0 	10  0  0  0 
                        \ should not be in every package, but we put it
                        \ here as a work-around for some old CG6 FCode
                        \ drivers whose selftest routines use frame-buffer-adr
                        \ for diagnostics mappings.  If frame-buffer-adr is
                        \ global, that would cause dual-cg6 systems to break.
fival: my-termemu
1A203D4 	 0 6D 79 2D 
1A203D8 	74 65 72 6D 65 6D 75 8A 
1A203E0 	CC  3 A2  1 C0 FE A1  1 
1A203E8 	14  0  0  0 

headerless
constant #fixed-vals
1A203EC 	23 66 69 78 
1A203F0 	65 64 2D 76 61 6C 73 8B 
1A203F8 	E4  3 A2  1 68 40 A0  1 
1A20400 	18  0  0  0 
headers

0
fibuf: my-voc           \ Package definition (code) for this instance
1A20404 	 0 6D 79 2D 
1A20408 	76 6F 63 86 FC  3 A2  1 
1A20410 	C0 FE A1  1 FC FF FF FF 
fibuf: my-parent        \ Current instance just before this one was created
1A20418 	 0  0 6D 79 2D 70 61 72 
1A20420 	65 6E 74 89 10  4 A2  1 
1A20428 	C0 FE A1  1 F8 FF FF FF 
fibuf: my-args-adr      \ Argument string - base address
1A20430 	6D 79 2D 61 72 67 73 2D 
1A20438 	61 64 72 8B 28  4 A2  1 
1A20440 	C0 FE A1  1 F4 FF FF FF 
fibuf: my-args-len      \ Argument string - length
1A20448 	6D 79 2D 61 72 67 73 2D 
1A20450 	6C 65 6E 8B 40  4 A2  1 
1A20458 	C0 FE A1  1 F0 FF FF FF 
fibuf: my-unit-3	\ Fourth component of device instance address
1A20460 	 0  0 6D 79 2D 75 6E 69 
1A20468 	74 2D 33 89 58  4 A2  1 
1A20470 	C0 FE A1  1 EC FF FF FF 
fibuf: my-unit-2	\ Third  component of device instance address
1A20478 	 0  0 6D 79 2D 75 6E 69 
1A20480 	74 2D 32 89 70  4 A2  1 
1A20488 	C0 FE A1  1 E8 FF FF FF 
fibuf: my-unit-1	\ Second component of device instance address
1A20490 	 0  0 6D 79 2D 75 6E 69 
1A20498 	74 2D 31 89 88  4 A2  1 
1A204A0 	C0 FE A1  1 E4 FF FF FF 
fibuf: my-unit-low	\ First  component of device instance address
1A204A8 	6D 79 2D 75 6E 69 74 2D 
1A204B0 	6C 6F 77 8B A0  4 A2  1 
1A204B8 	C0 FE A1  1 E0 FF FF FF 

headerless
constant #fixed-bufs
1A204C0 	23 66 69 78 65 64 2D 62 
1A204C8 	75 66 73 8B B8  4 A2  1 
1A204D0 	68 40 A0  1 E0 FF FF FF 

: initial-values  ( -- adr )  'values token@  ;
1A204D8 	 0 69 6E 69 74 69 61 6C 
1A204E0 	2D 76 61 6C 75 65 73 8E 
1A204E8 	D0  4 A2  1 20 40 A0  1 
1A204F0 	90 FA A1  1  C 54 A0  1 
1A204F8 	58 46 A0  1 

\ Non-instance values defined inside packages are stored in the initial
\ value array that is used to initialize instance data, but unlike instance
\ values, they are accessed directly from the initial value array instead
\ of from the instance record.  This allows their values to be shared among
\ different instances, either simultaneously-active ones or ones that are
\ separated in time, and also allows different clones of that package to
\ have separate copies of that data.  The down side of this scheme, compared
\ to the previous technique of using the user area for non-instance values
\ is that it is not ROMable, because the initial value array must be writeable
\ (previously it was only written at package creation time, and read-only
\ thereafter).  One up side is that packages that use large numbers of non-
\ instance values no longer consume a lot of user area (a relative-limited
\ resource).  If we ever need to make this ROMable, we can implement copy-on-
\ write for initial values.

: initial-values'  ( -- adr )
1A204FC 	69 6E 69 74 
1A20500 	69 61 6C 2D 76 61 6C 75 
1A20508 	65 73 27 8F EC  4 A2  1 
1A20510 	20 40 A0  1 
   my-self  if	\ Use current instance's package if there is a current instance
1A20514 	EC 7E A0  1 
1A20518 	DC 41 A0  1 1C  0  0  0 
      my-voc (push-package)  initial-values  (pop-package)
1A20520 	10  4 A2  1 38 FB A1  1 
1A20528 	EC  4 A2  1 5C FB A1  1 
   else		\ Otherwise use the active package
1A20530 	C8 41 A0  1  8  0  0  0 
      initial-values
1A20538 	EC  4 A2  1 
   then
;
1A2053C 	58 46 A0  1 

: >initial-value  ( pfa -- adr )  @  initial-values' +  ;
1A20540 	 0 3E 69 6E 69 74 69 61 
1A20548 	6C 2D 76 61 6C 75 65 8E 
1A20550 	10  5 A2  1 20 40 A0  1 
1A20558 	5C 4C A0  1 10  5 A2  1 
1A20560 	 4 45 A0  1 58 46 A0  1 

3 actions
1A20568 	98  5 A2  1 88  5 A2  1 
1A20570 	 3  0  0  0 
action:  >initial-value @  ;
1A20574 	90 90 90 E8 
1A20578 	 0 3B FE FF 54  5 A2  1 
1A20580 	5C 4C A0  1 58 46 A0  1 
action:  >initial-value !  ;
1A20588 	20 40 A0  1 54  5 A2  1 
1A20590 	54 4D A0  1 58 46 A0  1 
action:  >initial-value    ;
1A20598 	20 40 A0  1 54  5 A2  1 
1A205A0 	58 46 A0  1 

: package-value  ( initial-value -- )
1A205A4 	 0  0 70 61 
1A205A8 	63 6B 61 67 65 2D 76 61 
1A205B0 	6C 75 65 8D 54  5 A2  1 
1A205B8 	20 40 A0  1 
   create-cf use-actions  /n value#,  !
1A205BC 	30 5B A0  1 
1A205C0 	60 53 A0  1 74  5 A2  1 
1A205C8 	E0 57 A0  1 40 51 A0  1 
1A205D0 	2C FE A1  1 54 4D A0  1 
;
1A205D8 	58 46 A0  1 
 action-adr-t to dopackage-value
: (value)  ( initial-value -- )
1A205DC 	28 76 61 6C 
1A205E0 	75 65 29 87 B8  5 A2  1 
1A205E8 	20 40 A0  1 
   instance?  if
1A205EC 	B0 FC A1  1 
1A205F0 	DC 41 A0  1 10  0  0  0 
      instance-value
1A205F8 	 4 FF A1  1 
   else
1A205FC 	C8 41 A0  1 
1A20600 	2C  0  0  0 
      package?  if  package-value  else  value-cf /n user#, !  then
1A20604 	E8 FC A1  1 
1A20608 	DC 41 A0  1 10  0  0  0 
1A20610 	B8  5 A2  1 C8 41 A0  1 
1A20618 	14  0  0  0 E8 5B A0  1 
1A20620 	40 51 A0  1 84 9A A0  1 
1A20628 	54 4D A0  1 
   then
;
1A2062C 	58 46 A0  1 
patch (value) noop value

3 actions
1A20630 	60  6 A2  1 50  6 A2  1 
1A20638 	 3  0  0  0 
action:  >initial-value 2@  ;
1A2063C 	90 90 90 E8 
1A20640 	38 3A FE FF 54  5 A2  1 
1A20648 	CC 4D A0  1 58 46 A0  1 
action:  >initial-value 2!  ;
1A20650 	20 40 A0  1 54  5 A2  1 
1A20658 	E4 4D A0  1 58 46 A0  1 
action:  >initial-value     ;
1A20660 	20 40 A0  1 54  5 A2  1 
1A20668 	58 46 A0  1 

: package-2value  ( initial-value -- )
1A2066C 	 0 70 61 63 
1A20670 	6B 61 67 65 2D 32 76 61 
1A20678 	6C 75 65 8E E8  5 A2  1 
1A20680 	20 40 A0  1 
   create-cf use-actions  2 /n* value#,  2!
1A20684 	30 5B A0  1 
1A20688 	60 53 A0  1 3C  6 A2  1 
1A20690 	E0 57 A0  1 90 6F A0  1 
1A20698 	98 51 A0  1 2C FE A1  1 
1A206A0 	E4 4D A0  1 
;
1A206A4 	58 46 A0  1 

: (2value)  ( initial-value -- )
1A206A8 	 0  0  0 28 32 76 61 6C 
1A206B0 	75 65 29 88 80  6 A2  1 
1A206B8 	20 40 A0  1 
   instance?  if
1A206BC 	B0 FC A1  1 
1A206C0 	DC 41 A0  1 10  0  0  0 
      instance-2value
1A206C8 	FC FF A1  1 
   else
1A206CC 	C8 41 A0  1 
1A206D0 	30  0  0  0 
     package?  if  package-2value  else  2value-cf  2 /n* user#, 2!  then
1A206D4 	E8 FC A1  1 
1A206D8 	DC 41 A0  1 10  0  0  0 
1A206E0 	80  6 A2  1 C8 41 A0  1 
1A206E8 	18  0  0  0 64 BA A1  1 
1A206F0 	90 6F A0  1 98 51 A0  1 
1A206F8 	84 9A A0  1 E4 4D A0  1 
   then
;
1A20700 	58 46 A0  1 
patch (2value) noop 2value

headers
: my-args  ( -- adr len )  my-args-adr my-args-len  ;
1A20704 	6D 79 2D 61 
1A20708 	72 67 73 87 B8  6 A2  1 
1A20710 	20 40 A0  1 40  4 A2  1 
1A20718 	58  4 A2  1 58 46 A0  1 

headerless
: allocate-instance  ( value-size variable-size -- )
1A20720 	 0  0 61 6C 6C 6F 63 61 
1A20728 	74 65 2D 69 6E 73 74 61 
1A20730 	6E 63 65 91 10  7 A2  1 
1A20738 	20 40 A0  1 
   \ Allocate instance record
   my-self >r                                 ( val-size var-size )
1A2073C 	EC 7E A0  1 
1A20740 	BC 45 A0  1 
   tuck +  alloc-mem                          ( var-size base-adr )
1A20744 	E8 46 A0  1 
1A20748 	 4 45 A0  1 F0 6C A0  1 
   + is my-self                               ( )
1A20750 	 4 45 A0  1 B8 40 A0  1 
1A20758 	EC 7E A0  1 

   \ Set the fixed fields
   r> to my-parent                            ( )
1A2075C 	D0 45 A0  1 
1A20760 	48 B8 A1  1 28  4 A2  1 
   current-device  to my-voc                  ( )
1A20768 	40 F9 A1  1 48 B8 A1  1 
1A20770 	10  4 A2  1 
   0 to my-args-len  0 to my-args-adr         ( )  \ May be changed later
1A20774 	70 6F A0  1 
1A20778 	48 B8 A1  1 58  4 A2  1 
1A20780 	70 6F A0  1 48 B8 A1  1 
1A20788 	40  4 A2  1 
;
1A2078C 	58 46 A0  1 

\ Returns the address of the initial value of the named instance data.
: (initial-addr)  ( adr -- adr' )    my-self -  initial-values' +  ;
1A20790 	 0 28 69 6E 69 74 69 61 
1A20798 	6C 2D 61 64 64 72 29 8E 
1A207A0 	38  7 A2  1 20 40 A0  1 
1A207A8 	EC 7E A0  1 18 45 A0  1 
1A207B0 	10  5 A2  1  4 45 A0  1 
1A207B8 	58 46 A0  1 
: initial-addr  \ name  ( -- addr )
1A207BC 	 0  0  0 69 
1A207C0 	6E 69 74 69 61 6C 2D 61 
1A207C8 	64 64 72 CC A4  7 A2  1 
1A207D0 	20 40 A0  1 
   [compile] addr
1A207D4 	DC B9 A1  1 
   state @  if  compile (initial-addr)  else  (initial-addr)  then
1A207D8 	38 54 A0  1 5C 4C A0  1 
1A207E0 	DC 41 A0  1 14  0  0  0 
1A207E8 	8C 75 A0  1 A4  7 A2  1 
1A207F0 	C8 41 A0  1  8  0  0  0 
1A207F8 	A4  7 A2  1 
; immediate
1A207FC 	58 46 A0  1 

: copy-args  ( args-adr,len -- )
1A20800 	 0  0 63 6F 70 79 2D 61 
1A20808 	72 67 73 89 D0  7 A2  1 
1A20810 	20 40 A0  1 
   dup  if
1A20814 	40 49 A0  1 
1A20818 	DC 41 A0  1 30  0  0  0 
      dup alloc-mem to my-args-adr          ( args-adr,len )
1A20820 	40 49 A0  1 F0 6C A0  1 
1A20828 	48 B8 A1  1 40  4 A2  1 
      to my-args-len                        ( args-adr )
1A20830 	48 B8 A1  1 58  4 A2  1 
      my-args-adr my-args-len move          ( )
1A20838 	40  4 A2  1 58  4 A2  1 
1A20840 	F4 4A A0  1 
   else
1A20844 	C8 41 A0  1 
1A20848 	 8  0  0  0 
      2drop
1A2084C 	AC 49 A0  1 
   then
;
1A20850 	58 46 A0  1 

: copy-instance-data  ( -- )
1A20854 	 0 63 6F 70 
1A20858 	79 2D 69 6E 73 74 61 6E 
1A20860 	63 65 2D 64 61 74 61 92 
1A20868 	10  8 A2  1 20 40 A0  1 
   initial-values  my-self  '#values @  move
1A20870 	EC  4 A2  1 EC 7E A0  1 
1A20878 	7C FA A1  1 5C 4C A0  1 
1A20880 	F4 4A A0  1 
;
1A20884 	58 46 A0  1 
\ my-self points to a position in the middle of the instance record.
\ Initialized data ("values") is at positive offsets from my-self,
\ and uninitialized data ("variables" and "buffers") is at negative offsets.
: new-instance  ( args-adr args-len -- )
1A20888 	 0  0  0 6E 65 77 2D 69 
1A20890 	6E 73 74 61 6E 63 65 8C 
1A20898 	6C  8 A2  1 20 40 A0  1 
   '#values @  '#buffers @ negate  allocate-instance  ( args-adr args-len )
1A208A0 	7C FA A1  1 5C 4C A0  1 
1A208A8 	64 FA A1  1 5C 4C A0  1 
1A208B0 	48 45 A0  1 38  7 A2  1 
   copy-instance-data                                 ( args-adr args-len )
1A208B8 	6C  8 A2  1 
   copy-args
1A208BC 	10  8 A2  1 
;
1A208C0 	58 46 A0  1 

: deallocate-instance  ( value-size variabled-size -- )
1A208C4 	64 65 61 6C 
1A208C8 	6C 6F 63 61 74 65 2D 69 
1A208D0 	6E 73 74 61 6E 63 65 93 
1A208D8 	9C  8 A2  1 20 40 A0  1 
   my-args-len  if  my-args-adr my-args-len free-mem  then
1A208E0 	58  4 A2  1 DC 41 A0  1 
1A208E8 	10  0  0  0 40  4 A2  1 
1A208F0 	58  4 A2  1  8 6D A0  1 
   my-self  my-parent is my-self   ( val-size var-size self )
1A208F8 	EC 7E A0  1 28  4 A2  1 
1A20900 	B8 40 A0  1 EC 7E A0  1 
   over -                          ( val-size var-size base-adr )
1A20908 	54 49 A0  1 18 45 A0  1 
   -rot  +  free-mem               ( )
1A20910 	94 49 A0  1  4 45 A0  1 
1A20918 	 8 6D A0  1 
;
1A2091C 	58 46 A0  1 

\ Destroy instance has the side effect of setting my-self to the parent
\ of the node that is being destroyed.  This prevents my-self from referring
\ to a non-existent instance.

: destroy-instance  ( -- )
1A20920 	 0  0  0 64 65 73 74 72 
1A20928 	6F 79 2D 69 6E 73 74 61 
1A20930 	6E 63 65 90 DC  8 A2  1 
1A20938 	20 40 A0  1 
   my-voc (push-package)              ( )
1A2093C 	10  4 A2  1 
1A20940 	38 FB A1  1 
   '#values @  '#buffers @  negate    ( value-size variable-size )
1A20944 	7C FA A1  1 
1A20948 	5C 4C A0  1 64 FA A1  1 
1A20950 	5C 4C A0  1 48 45 A0  1 
   (pop-package)                      ( value-size variable-size )
1A20958 	5C FB A1  1 
   deallocate-instance
1A2095C 	DC  8 A2  1 

;
1A20960 	58 46 A0  1 
\ When creating a package definition, we initialize the buffer
\ (uninitialized data) allocation pointer and the value (initialized data)
\ allocation pointer.

: prime-package  ( -- )
1A20964 	 0  0 70 72 
1A20968 	69 6D 65 2D 70 61 63 6B 
1A20970 	61 67 65 8D 38  9 A2  1 
1A20978 	20 40 A0  1 
   next-is-instance off
1A2097C 	98 FC A1  1 
1A20980 	F8 4B A0  1 
   1 package-level +!  /value-area /buffer-area  allocate-instance
1A20984 	80 6F A0  1 
1A20988 	5C FC A1  1  C 4C A0  1 
1A20990 	FC FD A1  1 18 FE A1  1 
1A20998 	38  7 A2  1 
   my-self  'values token!
1A2099C 	EC 7E A0  1 
1A209A0 	90 FA A1  1 20 54 A0  1 
;
1A209A8 	58 46 A0  1 
headers
: extend-package  ( -- )
1A209AC 	 0 65 78 74 
1A209B0 	65 6E 64 2D 70 61 63 6B 
1A209B8 	61 67 65 8E 78  9 A2  1 
1A209C0 	20 40 A0  1 
   initial-values              ( 'values )
1A209C4 	EC  4 A2  1 
   prime-package               ( 'values )
1A209C8 	78  9 A2  1 
   my-self  '#values @  move   \ Preserve the initial values
1A209CC 	EC 7E A0  1 
1A209D0 	7C FA A1  1 5C 4C A0  1 
1A209D8 	F4 4A A0  1 
;
1A209DC 	58 46 A0  1 
headerless

: allot-package-data  ( -- )
1A209E0 	 0 61 6C 6C 6F 74 2D 70 
1A209E8 	61 63 6B 61 67 65 2D 64 
1A209F0 	61 74 61 92 C0  9 A2  1 
1A209F8 	20 40 A0  1 
   acf-align here dup 'values token!  '#values @ dup allot  erase
1A209FC 	2C 5D A0  1 
1A20A00 	70 54 A0  1 40 49 A0  1 
1A20A08 	90 FA A1  1 20 54 A0  1 
1A20A10 	7C FA A1  1 5C 4C A0  1 
1A20A18 	40 49 A0  1 E4 54 A0  1 
1A20A20 	F0 72 A0  1 
;
1A20A24 	58 46 A0  1 
: finish-package-data  ( -- )
1A20A28 	66 69 6E 69 73 68 2D 70 
1A20A30 	61 63 6B 61 67 65 2D 64 
1A20A38 	61 74 61 93 F8  9 A2  1 
1A20A40 	20 40 A0  1 
   \ Copy the initialized data into the dictionary and set up the
   \ pointer to it.
   '#values @  if  allot-package-data  then
1A20A44 	7C FA A1  1 
1A20A48 	5C 4C A0  1 DC 41 A0  1 
1A20A50 	 8  0  0  0 F8  9 A2  1 
   my-self  initial-values  '#values @  move            ( )
1A20A58 	EC 7E A0  1 EC  4 A2  1 
1A20A60 	7C FA A1  1 5C 4C A0  1 
1A20A68 	F4 4A A0  1 

   initial-addr frame-buffer-adr off
1A20A6C 	5C B8 A1  1 
1A20A70 	CC  3 A2  1 A4  7 A2  1 
1A20A78 	F8 4B A0  1 
   initial-addr my-termemu       off
1A20A7C 	5C B8 A1  1 
1A20A80 	E4  3 A2  1 A4  7 A2  1 
1A20A88 	F8 4B A0  1 

   /value-area /buffer-area deallocate-instance         ( )
1A20A8C 	FC FD A1  1 
1A20A90 	18 FE A1  1 DC  8 A2  1 
   package-level @ 1- 0 max package-level !
1A20A98 	5C FC A1  1 5C 4C A0  1 
1A20AA0 	54 4B A0  1 70 6F A0  1 
1A20AA8 	9C 4A A0  1 5C FC A1  1 
1A20AB0 	54 4D A0  1 
;
1A20AB4 	58 46 A0  1 

\ Internal factor used to implement first-child and next-child
: set-child?  ( link-adr -- flag )
1A20AB8 	 0 73 65 74 2D 63 68 69 
1A20AC0 	6C 64 3F 8A 40  A A2  1 
1A20AC8 	20 40 A0  1 
   get-token?  if  voc>phandle push-device true  else  false  then
1A20ACC 	6C 59 A0  1 
1A20AD0 	DC 41 A0  1 18  0  0  0 
1A20AD8 	40 F8 A1  1 F8 FB A1  1 
1A20AE0 	 4 70 A0  1 C8 41 A0  1 
1A20AE8 	 8  0  0  0 18 70 A0  1 
;
1A20AF0 	58 46 A0  1 

\ Interface to searching code in breadth.fth:
: first-child  ( -- another? )  'child set-child?  ;
1A20AF4 	66 69 72 73 
1A20AF8 	74 2D 63 68 69 6C 64 8B 
1A20B00 	C8  A A2  1 20 40 A0  1 
1A20B08 	 8 FA A1  1 C8  A A2  1 
1A20B10 	58 46 A0  1 
: next-child   ( -- another? )  'peer  pop-device  set-child?  ;
1A20B14 	 0 6E 65 78 
1A20B18 	74 2D 63 68 69 6C 64 8A 
1A20B20 	 4  B A2  1 20 40 A0  1 
1A20B28 	1C FA A1  1 18 FC A1  1 
1A20B30 	C8  A A2  1 58 46 A0  1 

\ Removes the voc-link field from the most-recently-created vocabulary
: erase-voc-link  ( -- )
1A20B38 	 0 65 72 61 73 65 2D 76 
1A20B40 	6F 63 2D 6C 69 6E 6B 8E 
1A20B48 	24  B A2  1 20 40 A0  1 
   voc-link  a@ >voc-link a@  voc-link a!
1A20B50 	74 B6 A0  1 88 58 A0  1 
1A20B58 	50 B6 A0  1 88 58 A0  1 
1A20B60 	74 B6 A0  1 98 58 A0  1 
   /link na1+ negate allot
1A20B68 	78 73 A0  1 CC 50 A0  1 
1A20B70 	48 45 A0  1 E4 54 A0  1 
;
1A20B78 	58 46 A0  1 

\ Creates an unnamed vocabulary
: (vocabulary)  ( -- )
1A20B7C 	 0  0  0 28 
1A20B80 	76 6F 63 61 62 75 6C 61 
1A20B88 	72 79 29 8C 4C  B A2  1 
1A20B90 	20 40 A0  1 
   ['] acf-align is header
1A20B94 	60 53 A0  1 
1A20B98 	2C 5D A0  1 98 40 A0  1 
1A20BA0 	DC 6D A0  1 
   vocabulary
1A20BA4 	28 B7 A0  1 
   ['] (header) is header
1A20BA8 	60 53 A0  1 70 A2 A0  1 
1A20BB0 	98 40 A0  1 DC 6D A0  1 

   erase-voc-link
1A20BB8 	4C  B A2  1 
;
1A20BBC 	58 46 A0  1 

: allocate-node-record  ( -- )
1A20BC0 	 0  0  0 61 6C 6C 6F 63 
1A20BC8 	61 74 65 2D 6E 6F 64 65 
1A20BD0 	2D 72 65 63 6F 72 64 94 
1A20BD8 	90  B A2  1 20 40 A0  1 
   \ Allocate user (RAM) space for  properties, "last" field, children, peers
   /devnode-extra  unaligned-ualloc drop
1A20BE0 	AC FA A1  1 A4 F9 A1  1 
1A20BE8 	30 49 A0  1 

   lastacf voc>phandle push-device           ( parent's-child-field )
1A20BEC 	AC 57 A0  1 
1A20BF0 	40 F8 A1  1 F8 FB A1  1 
;
1A20BF8 	58 46 A0  1 
: init-properties  ( -- )  (vocabulary)  lastacf 'properties token!  ;
1A20BFC 	69 6E 69 74 
1A20C00 	2D 70 72 6F 70 65 72 74 
1A20C08 	69 65 73 8F DC  B A2  1 
1A20C10 	20 40 A0  1 90  B A2  1 
1A20C18 	AC 57 A0  1 34 FA A1  1 
1A20C20 	20 54 A0  1 58 46 A0  1 

: init-node  ( #address-cells -- )
1A20C28 	 0  0 69 6E 69 74 2D 6E 
1A20C30 	6F 64 65 89 10  C A2  1 
1A20C38 	20 40 A0  1 
   allocate-node-record
1A20C3C 	DC  B A2  1 

  '#adr-cells !
1A20C40 	4C FA A1  1 54 4D A0  1 
  'child      !null-token      \ No children yet
1A20C48 	 8 FA A1  1 10 59 A0  1 
  'peer       !null-token      \ Null peer
1A20C50 	1C FA A1  1 10 59 A0  1 

   #fixed-vals  '#values    !  \ Initialize data sizes
1A20C58 	FC  3 A2  1 7C FA A1  1 
1A20C60 	54 4D A0  1 
   #fixed-bufs  '#buffers   !
1A20C64 	D0  4 A2  1 
1A20C68 	64 FA A1  1 54 4D A0  1 

   'values    !null-token      \ No initial data values yet
1A20C70 	90 FA A1  1 10 59 A0  1 

   init-properties
1A20C78 	10  C A2  1 
;
1A20C7C 	58 46 A0  1 

: current-properties  ( -- )  'properties token@  ;
1A20C80 	 0 63 75 72 72 65 6E 74 
1A20C88 	2D 70 72 6F 70 65 72 74 
1A20C90 	69 65 73 92 38  C A2  1 
1A20C98 	20 40 A0  1 34 FA A1  1 
1A20CA0 	 C 54 A0  1 58 46 A0  1 

headerless
: link-to-peer  ( parent's-child-field -- )
1A20CA8 	 0  0  0 6C 69 6E 6B 2D 
1A20CB0 	74 6F 2D 70 65 65 72 8C 
1A20CB8 	98  C A2  1 20 40 A0  1 
   dup token@ 'peer token!             ( parent's-child-field )
1A20CC0 	40 49 A0  1  C 54 A0  1 
1A20CC8 	1C FA A1  1 20 54 A0  1 
   current-device phandle>voc  swap token!         ( )
1A20CD0 	40 F9 A1  1 58 F8 A1  1 
1A20CD8 	68 49 A0  1 20 54 A0  1 
;
1A20CE0 	58 46 A0  1 
: device-node?  ( voc -- flag )
1A20CE4 	 0  0  0 64 
1A20CE8 	65 76 69 63 65 2D 6E 6F 
1A20CF0 	64 65 3F 8C BC  C A2  1 
1A20CF8 	20 40 A0  1 
   voc-link  begin  another-link?  while        ( voc link )
1A20CFC 	74 B6 A0  1 
1A20D00 	90 59 A0  1 DC 41 A0  1 
1A20D08 	30  0  0  0 
      2dup voc>  =  if  2drop false exit  then  ( voc link )
1A20D0C 	C0 49 A0  1 
1A20D10 	38 B6 A0  1 24 48 A0  1 
1A20D18 	DC 41 A0  1 10  0  0  0 
1A20D20 	AC 49 A0  1 18 70 A0  1 
1A20D28 	40 46 A0  1 
      >voc-link
1A20D2C 	50 B6 A0  1 
   repeat                                       ( voc )
1A20D30 	C8 41 A0  1 CC FF FF FF 
   drop true
1A20D38 	30 49 A0  1  4 70 A0  1 
;
1A20D40 	58 46 A0  1 

: $vexecute?  ( adr len voc-acf -- true | ??? false)
1A20D44 	 0 24 76 65 
1A20D48 	78 65 63 75 74 65 3F 8A 
1A20D50 	F8  C A2  1 20 40 A0  1 
   (search-wordlist)  if  execute false  else  true  then
1A20D58 	 0 BB A0  1 DC 41 A0  1 
1A20D60 	14  0  0  0 98 41 A0  1 
1A20D68 	18 70 A0  1 C8 41 A0  1 
1A20D70 	 8  0  0  0  4 70 A0  1 
;
1A20D78 	58 46 A0  1 
: $package-execute?  ( adr len phandle -- true | ??? false)
1A20D7C 	 0  0 24 70 
1A20D80 	61 63 6B 61 67 65 2D 65 
1A20D88 	78 65 63 75 74 65 3F 91 
1A20D90 	54  D A2  1 20 40 A0  1 
   phandle>voc (search-wordlist)  if  execute false  else  true  then
1A20D98 	58 F8 A1  1  0 BB A0  1 
1A20DA0 	DC 41 A0  1 14  0  0  0 
1A20DA8 	98 41 A0  1 18 70 A0  1 
1A20DB0 	C8 41 A0  1  8  0  0  0 
1A20DB8 	 4 70 A0  1 
;
1A20DBC 	58 46 A0  1 
: $vexecute  ( adr len voc-acf -- ?? )  $vexecute? drop  ;
1A20DC0 	 0  0 24 76 65 78 65 63 
1A20DC8 	75 74 65 89 94  D A2  1 
1A20DD0 	20 40 A0  1 54  D A2  1 
1A20DD8 	30 49 A0  1 58 46 A0  1 

headers
\ Used during compilation (probing), when the search order includes
\ the current vocabulary as well as the parent vocabularies.
: get-property  ( name-adr,len -- true | value-adr,len false )
1A20DE0 	 0  0  0 67 65 74 2D 70 
1A20DE8 	72 6F 70 65 72 74 79 8C 
1A20DF0 	D0  D A2  1 20 40 A0  1 
   current-properties (search-wordlist)  if  ( xt )
1A20DF8 	98  C A2  1  0 BB A0  1 
1A20E00 	DC 41 A0  1 24  0  0  0 
      >r r@ get  r> decode                   ( value-adr,len )
1A20E08 	BC 45 A0  1 E4 45 A0  1 
1A20E10 	D4 E7 A1  1 D0 45 A0  1 
1A20E18 	 8 E8 A1  1 
      false                                  ( value-adr,len false )
1A20E1C 	18 70 A0  1 
   else                                      ( )
1A20E20 	C8 41 A0  1  8  0  0  0 
      true                                   ( true )
1A20E28 	 4 70 A0  1 
   then
;
1A20E2C 	58 46 A0  1 

headerless
: #adr-cells  ( -- n )
1A20E30 	 0 23 61 64 72 2D 63 65 
1A20E38 	6C 6C 73 8A F4  D A2  1 
1A20E40 	20 40 A0  1 
   " #address-cells" get-property  if  2  else  get-encoded-int  then
1A20E44 	9C 53 A0  1 
1A20E48 	 E 23 61 64 64 72 65 73 
1A20E50 	73 2D 63 65 6C 6C 73  0 
1A20E58 	F4  D A2  1 DC 41 A0  1 
1A20E60 	10  0  0  0 90 6F A0  1 
1A20E68 	C8 41 A0  1  8  0  0  0 
1A20E70 	A0 F7 A1  1 
;
1A20E74 	58 46 A0  1 

headers
: new-node  ( -- )
1A20E78 	 0  0  0 6E 65 77 2D 6E 
1A20E80 	6F 64 65 88 40  E A2  1 
1A20E88 	20 40 A0  1 
   (vocabulary)  current-device phandle>voc a,  ( )  \ Up-link to parent device
1A20E8C 	90  B A2  1 
1A20E90 	40 F9 A1  1 58 F8 A1  1 
1A20E98 	AC 58 A0  1 

   \ Save parent linkage address on stack for later use
   'child                              ( parent's-child-field )
1A20E9C 	 8 FA A1  1 
   #adr-cells init-node                ( parent's-child-field )
1A20EA0 	40  E A2  1 38  C A2  1 
   link-to-peer                        ( )
1A20EA8 	BC  C A2  1 
;
1A20EAC 	58 46 A0  1 

: (clone)  ( template-phandle parent-phandle -- )
1A20EB0 	28 63 6C 6F 6E 65 29 87 
1A20EB8 	88  E A2  1 20 40 A0  1 
   (vocabulary)  a,                 ( template )  \ Up-link
1A20EC0 	90  B A2  1 AC 58 A0  1 

   \ Get pointers from template node
   push-package                        ( )
1A20EC8 	7C FB A1  1 
   current-properties >threads token@  ( props )
1A20ECC 	98  C A2  1 
1A20ED0 	EC 74 A0  1  C 54 A0  1 
   'threads                            ( props record )
1A20ED8 	F4 F9 A1  1 
   pop-package                         ( props record )
1A20EDC 	D8 FB A1  1 

   \ Inherit methods and initialized data
   allocate-node-record                ( props record )
1A20EE0 	DC  B A2  1 
   'threads /devnode-extra  /link #threads * +  move   ( props )
1A20EE4 	F4 F9 A1  1 
1A20EE8 	AC FA A1  1 78 73 A0  1 
1A20EF0 	48 B7 A0  1 1C 5F A0  1 
1A20EF8 	 4 45 A0  1 F4 4A A0  1 

   \ Inherit properties
   init-properties                     ( props )
1A20F00 	10  C A2  1 
   current-properties >threads token!  ( )
1A20F04 	98  C A2  1 
1A20F08 	EC 74 A0  1 20 54 A0  1 

   \ Don't inherit children
   'child      !null-token             ( )
1A20F10 	 8 FA A1  1 10 59 A0  1 

   parent-device push-package          ( )
1A20F18 	EC FA A1  1 7C FB A1  1 
   #adr-cells 'child                   ( #adr-cells parent's-child-field )
1A20F20 	40  E A2  1  8 FA A1  1 
   pop-package                         ( #adr-cells parent's-child-field )
1A20F28 	D8 FB A1  1 

   \ Attach the new node to its parent's list of children
   link-to-peer                        ( #adr-cells )
1A20F2C 	BC  C A2  1 

   \ Fix #adr-cells in case the template is under a node that doesn't have
   \ the right number of address cells (e.g. /templates).

   '#adr-cells !                       ( )
1A20F30 	4C FA A1  1 54 4D A0  1 

   extend-package                      ( )
1A20F38 	C0  9 A2  1 
;
1A20F3C 	58 46 A0  1 

\ Creates a copy of current-device, setting current-device to the new copy.
\ The new clone is located in the device tree as a peer of the package that
\ was copied.
\ See also "$clone-node" in instance.fth
: clone-node  ( -- )  current-device  parent-device  (clone)  ;
1A20F40 	 0 63 6C 6F 6E 65 2D 6E 
1A20F48 	6F 64 65 8A BC  E A2  1 
1A20F50 	20 40 A0  1 40 F9 A1  1 
1A20F58 	EC FA A1  1 BC  E A2  1 
1A20F60 	58 46 A0  1 

: new-device   ( -- )  new-node  prime-package  ;
1A20F64 	 0 6E 65 77 
1A20F68 	2D 64 65 76 69 63 65 8A 
1A20F70 	50  F A2  1 20 40 A0  1 
1A20F78 	88  E A2  1 78  9 A2  1 
1A20F80 	58 46 A0  1 

: device-end   ( -- )  only forth also definitions  package-level off  ;
1A20F84 	 0 64 65 76 
1A20F88 	69 63 65 2D 65 6E 64 8A 
1A20F90 	74  F A2  1 20 40 A0  1 
1A20F98 	88 C3 A0  1  8 C5 A0  1 
1A20FA0 	C8 C1 A0  1 2C C4 A0  1 
1A20FA8 	5C FC A1  1 F8 4B A0  1 
1A20FB0 	58 46 A0  1 
alias dend device-end
1A20FB4 	 0  0  0 64 
1A20FB8 	65 6E 64 A4 94  F A2  1 
1A20FC0 	94  F A2  1 

: my-#adr-cells  ( -- n )
1A20FC4 	 0  0 6D 79 
1A20FC8 	2D 23 61 64 72 2D 63 65 
1A20FD0 	6C 6C 73 8D C0  F A2  1 
1A20FD8 	20 40 A0  1 
   my-self  if	\ Use current instance's package if there is a current instance
1A20FDC 	EC 7E A0  1 
1A20FE0 	DC 41 A0  1 20  0  0  0 
      my-voc (push-package)  '#adr-cells @  (pop-package)
1A20FE8 	10  4 A2  1 38 FB A1  1 
1A20FF0 	4C FA A1  1 5C 4C A0  1 
1A20FF8 	5C FB A1  1 
   else		\ Otherwise use the active package
1A20FFC 	C8 41 A0  1 
1A21000 	 C  0  0  0 
      '#adr-cells @
1A21004 	4C FA A1  1 
1A21008 	5C 4C A0  1 
   then
;
1A2100C 	58 46 A0  1 

\ my-address applies to the current instance, regardless of whether or
\ not the active package corresponds to the current instance, thus it must
\ use my-#adr-cells, which explicitly refers to the current instance's
\ package.

: my-address  ( -- phys.lo .. )
1A21010 	 0 6D 79 2D 61 64 64 72 
1A21018 	65 73 73 8A D8  F A2  1 
1A21020 	20 40 A0  1 
   addr my-adr0  my-#adr-cells 1- 0 max /n* bounds  ?do  i @  /n +loop
1A21024 	5C B8 A1  1 
1A21028 	6C  3 A2  1 D8  F A2  1 
1A21030 	54 4B A0  1 70 6F A0  1 
1A21038 	9C 4A A0  1 98 51 A0  1 
1A21040 	F0 6D A0  1 50 42 A0  1 
1A21048 	18  0  0  0 B4 42 A0  1 
1A21050 	5C 4C A0  1 40 51 A0  1 
1A21058 	1C 42 A0  1 F0 FF FF FF 
;
1A21060 	58 46 A0  1 
: my-unit  ( -- phys.lo .. )
1A21064 	6D 79 2D 75 
1A21068 	6E 69 74 87 20 10 A2  1 
1A21070 	20 40 A0  1 
   addr my-unit-low  my-#adr-cells /n* bounds  ?do  i @  /n +loop
1A21074 	5C B8 A1  1 
1A21078 	B8  4 A2  1 D8  F A2  1 
1A21080 	98 51 A0  1 F0 6D A0  1 
1A21088 	50 42 A0  1 18  0  0  0 
1A21090 	B4 42 A0  1 5C 4C A0  1 
1A21098 	40 51 A0  1 1C 42 A0  1 
1A210A0 	F0 FF FF FF 
;
1A210A4 	58 46 A0  1 

vocabulary root-node
1A210A8 	 0  0 72 6F 6F 74 2D 6E 
1A210B0 	6F 64 65 89 70 10 A2  1 
1A210B8 	E0 B6 A0  1 4C  6  0  0 
1A210C0 	 0  0 A0  1 
 ' root-node TO LASTACFV \ MMO
   erase-voc-link  null ,   \ Root has no parent
   0 init-node
1A210C4 	E0 B6 A0  1 
1A210C8 	6C  6  0  0 
   allot-package-data
1A210CC 	 0  0  0  0 
1A210D0 	 0  0  0  0  0  0  0  0 
1A210D8 	 0  0  0  0  0  0  0  0 
1A210E0 	 0  0  0  0 
device-end
: root-phandle  ( -- ph )  ['] root-node voc>phandle  ;
1A210E4 	 0  0  0 72 
1A210E8 	6F 6F 74 2D 70 68 61 6E 
1A210F0 	64 6C 65 8C B8 10 A2  1 
1A210F8 	20 40 A0  1 60 53 A0  1 
1A21100 	B8 10 A2  1 40 F8 A1  1 
1A21108 	58 46 A0  1 

: root-device  ( -- )  only forth also  root-phandle push-device  ;
1A2110C 	72 6F 6F 74 
1A21110 	2D 64 65 76 69 63 65 8B 
1A21118 	F8 10 A2  1 20 40 A0  1 
1A21120 	88 C3 A0  1  8 C5 A0  1 
1A21128 	C8 C1 A0  1 F8 10 A2  1 
1A21130 	F8 FB A1  1 58 46 A0  1 

: root-device?  ( -- flag )  parent-device dt-null =  ;
1A21138 	 0  0  0 72 6F 6F 74 2D 
1A21140 	64 65 76 69 63 65 3F 8C 
1A21148 	1C 11 A2  1 20 40 A0  1 
1A21150 	EC FA A1  1 6C F8 A1  1 
1A21158 	24 48 A0  1 58 46 A0  1 

: finish-device  ( -- )  finish-package-data  pop-device  ;
1A21160 	 0  0 66 69 6E 69 73 68 
1A21168 	2D 64 65 76 69 63 65 8D 
1A21170 	4C 11 A2  1 20 40 A0  1 
1A21178 	40  A A2  1 18 FC A1  1 
1A21180 	58 46 A0  1 

: next-package  ( phandle -- phandle' )
1A21184 	 0  0  0 6E 
1A21188 	65 78 74 2D 70 61 63 6B 
1A21190 	61 67 65 8C 74 11 A2  1 
1A21198 	20 40 A0  1 
   push-package 'peer a@ pop-package   ( phandle phandle' )
1A2119C 	7C FB A1  1 
1A211A0 	1C FA A1  1 88 58 A0  1 
1A211A8 	D8 FB A1  1 
;
1A211AC 	58 46 A0  1 
: previous-link  ( phandle -- link-adr )
1A211B0 	 0  0 70 72 65 76 69 6F 
1A211B8 	75 73 2D 6C 69 6E 6B 8D 
1A211C0 	98 11 A2  1 20 40 A0  1 
   dup >r push-package             (                    R: phandle )
1A211C8 	40 49 A0  1 BC 45 A0  1 
1A211D0 	7C FB A1  1 
   root-device?  abort" Attempted to find the predecessor of the root package"
1A211D4 	4C 11 A2  1 
1A211D8 	 8 81 A0  1 35 41 74 74 
1A211E0 	65 6D 70 74 65 64 20 74 
1A211E8 	6F 20 66 69 6E 64 20 74 
1A211F0 	68 65 20 70 72 65 64 65 
1A211F8 	63 65 73 73 6F 72 20 6F 
1A21200 	66 20 74 68 65 20 72 6F 
1A21208 	6F 74 20 70 61 63 6B 61 
1A21210 	67 65  0  0 
   pop-device                      (                    R: phandle )
1A21214 	18 FC A1  1 
   'child   begin                  ( link               R: phandle )
1A21218 	 8 FA A1  1 
      dup a@                    ( link voc'          R: phandle )
1A2121C 	40 49 A0  1 
1A21220 	88 58 A0  1 
      dup r@ phandle>voc <>        ( link voc'          flag R: phandle )
1A21224 	40 49 A0  1 
1A21228 	E4 45 A0  1 58 F8 A1  1 
1A21230 	44 48 A0  1 
   while                           ( link phandle'      R: phandle )
1A21234 	DC 41 A0  1 
1A21238 	1C  0  0  0 
      voc>phandle push-device      ( link               R: phandle)
1A2123C 	40 F8 A1  1 
1A21240 	F8 FB A1  1 
      drop  'peer                  ( link'              R: phandle)
1A21244 	30 49 A0  1 
1A21248 	1C FA A1  1 
   repeat                          ( link phandle'      R: phandle )
1A2124C 	C8 41 A0  1 
1A21250 	CC FF FF FF 
   r> 2drop                        ( link )
1A21254 	D0 45 A0  1 
1A21258 	AC 49 A0  1 
   pop-package                     ( link )
1A2125C 	D8 FB A1  1 
;
1A21260 	58 46 A0  1 
: delete-package  ( phandle -- )
1A21264 	 0 64 65 6C 
1A21268 	65 74 65 2D 70 61 63 6B 
1A21270 	61 67 65 8E C4 11 A2  1 
1A21278 	20 40 A0  1 
   dup next-package  swap previous-link a!
1A2127C 	40 49 A0  1 
1A21280 	98 11 A2  1 68 49 A0  1 
1A21288 	C4 11 A2  1 98 58 A0  1 
;
1A21290 	58 46 A0  1 

\ The magic-device-types vocabulary contains words whose names are the
\ same as the names of the device_type property values that we wish to
\ recognize as special cases.  "device_type" in the "magic-properties"
\ vocabulary searches this vocabulary every time that a "device_type"
\ property is created, and executes the corresponding word if a match
\ is found.  That word may look at the property name and value on the
\ stack, but it must not remove them.  However, it might wish to alter
\ the value!

vocabulary magic-device-types
1A21294 	 0 6D 61 67 
1A21298 	69 63 2D 64 65 76 69 63 
1A212A0 	65 2D 74 79 70 65 73 92 
1A212A8 	78 12 A2  1 E0 B6 A0  1 
1A212B0 	70  6  0  0 90 E7 A1  1 
1A212B8 	 0  0  0  0 

\ The magic-properties vocabulary contains words whose names are the
\ same as the names of properties that we wish to recognize as special
\ cases.  "property" searches this vocabulary every time that an
\ property is created, and executes the corresponding word if a match
\ is found.  That word may look at the property name and value on the
\ stack, but it must not remove them.  However, it might wish to alter
\ either the name or the value!

headerless
false value autoloading?		\ Used to suppress probe reports
1A212BC 	 0  0  0 61 
1A212C0 	75 74 6F 6C 6F 61 64 69 
1A212C8 	6E 67 3F 8C AC 12 A2  1 
1A212D0 	50 40 A0  1 74  6  0  0 
headers

vocabulary magic-properties
1A212D8 	 0  0  0 6D 61 67 69 63 
1A212E0 	2D 70 72 6F 70 65 72 74 
1A212E8 	69 65 73 90 D0 12 A2  1 
1A212F0 	E0 B6 A0  1 78  6  0  0 
1A212F8 	AC 12 A2  1  0  0  0  0 

\ The parameter field of a property word contains:
\    offset size
\ Offset is the 32-bit positive distance from the beginning of the
\ property-encoded byte array to the parameter field address.  size is the
\ 16-bit size of the property value array.  This representation depends on
\ the fact that property-encoded arrays are stored in the dictionary.

: make-property-name  ( name-adr,len -- )
1A21300 	 0 6D 61 6B 65 2D 70 72 
1A21308 	6F 70 65 72 74 79 2D 6E 
1A21310 	61 6D 65 92 F0 12 A2  1 
1A21318 	20 40 A0  1 
   current token@ >r current-properties current token!
1A2131C 	F0 A3 A0  1 
1A21320 	 C 54 A0  1 BC 45 A0  1 
1A21328 	98  C A2  1 F0 A3 A0  1 
1A21330 	20 54 A0  1 
   $create
1A21334 	8C A2 A0  1 
   r> current token!
1A21338 	D0 45 A0  1 F0 A3 A0  1 
1A21340 	20 54 A0  1 
;
1A21344 	58 46 A0  1 

headerless
: change-property  ( value-adr,len property-acf -- )
1A21348 	63 68 61 6E 67 65 2D 70 
1A21350 	72 6F 70 65 72 74 79 8F 
1A21358 	18 13 A2  1 20 40 A0  1 
   \ Make a safe copy of the property value string if necessary
   >r  over in-dictionary?  0=  if  encode-bytes  then  r>
1A21360 	BC 45 A0  1 54 49 A0  1 
1A21368 	24 CF A0  1 24 47 A0  1 
1A21370 	DC 41 A0  1  8  0  0  0 
1A21378 	14 F6 A1  1 D0 45 A0  1 
   >body tuck na1+ !     ( value-adr property-apf )
1A21380 	E4 59 A0  1 E8 46 A0  1 
1A21388 	CC 50 A0  1 54 4D A0  1 
   dup rot - swap !      ( )
1A21390 	40 49 A0  1 7C 49 A0  1 
1A21398 	18 45 A0  1 68 49 A0  1 
1A213A0 	54 4D A0  1 
;
1A213A4 	58 46 A0  1 

headers
5 actions
1A213A8 	 8 14 A2  1 FC 13 A2  1 
1A213B0 	F4 13 A2  1 E4 13 A2  1 
1A213B8 	 5  0  0  0 
action:  dup dup @ -  swap na1+ @  ;
1A213BC 	90 90 90 E8 
1A213C0 	B8 2C FE FF 40 49 A0  1 
1A213C8 	40 49 A0  1 5C 4C A0  1 
1A213D0 	18 45 A0  1 68 49 A0  1 
1A213D8 	CC 50 A0  1 5C 4C A0  1 
1A213E0 	58 46 A0  1 
action:  body> change-property  ;
1A213E4 	20 40 A0  1 
1A213E8 	C8 59 A0  1 5C 13 A2  1 
1A213F0 	58 46 A0  1 
action:  ;
1A213F4 	20 40 A0  1 
1A213F8 	58 46 A0  1 
action:  drop  ;
1A213FC 	20 40 A0  1 
1A21400 	30 49 A0  1 58 46 A0  1 
action:  drop  ;
1A21408 	20 40 A0  1 30 49 A0  1 
1A21410 	58 46 A0  1 

action-adr-t dup h. to vproperty \ mmo

: (property)  ( value-adr,len  name-adr,len  -- )
1A21414 	 0 28 70 72 
1A21418 	6F 70 65 72 74 79 29 8A 
1A21420 	5C 13 A2  1 20 40 A0  1 
   caps @ >r  caps off
1A21428 	18 85 A0  1 5C 4C A0  1 
1A21430 	BC 45 A0  1 18 85 A0  1 
1A21438 	F8 4B A0  1 
   2dup  ['] magic-properties  $vexecute          ( value-str name-str )
1A2143C 	C0 49 A0  1 
1A21440 	60 53 A0  1 F0 12 A2  1 
1A21448 	D0  D A2  1 
   2dup current-properties (search-wordlist)  if  ( value-str name-str acf )
1A2144C 	C0 49 A0  1 
1A21450 	98  C A2  1  0 BB A0  1 
1A21458 	DC 41 A0  1 18  0  0  0 
      nip nip change-property                     ( )
1A21460 	FC 46 A0  1 FC 46 A0  1 
1A21468 	5C 13 A2  1 
   else                                           ( value-str name-str )
1A2146C 	C8 41 A0  1 
1A21470 	2C  0  0  0 
      make-property-name                          ( value-str )
1A21474 	18 13 A2  1 
      here rot - , ,  align use-actions           ( )
1A21478 	70 54 A0  1 7C 49 A0  1 
1A21480 	18 45 A0  1 98 55 A0  1 
1A21488 	98 55 A0  1 34 62 A0  1 
1A21490 	60 53 A0  1 BC 13 A2  1 
1A21498 	E0 57 A0  1 
   then                                           ( )
   r> caps !
1A2149C 	D0 45 A0  1 
1A214A0 	18 85 A0  1 54 4D A0  1 
;
1A214A8 	58 46 A0  1 

: property  ( value-adr,len  name-adr,len  -- )
1A214AC 	 0  0  0 70 
1A214B0 	72 6F 70 65 72 74 79 88 
1A214B8 	24 14 A2  1 20 40 A0  1 
   my-self if
1A214C0 	EC 7E A0  1 DC 41 A0  1 
1A214C8 	30  0  0  0 
      context token@ >r my-voc (select-package)
1A214CC 	DC A3 A0  1 
1A214D0 	 C 54 A0  1 BC 45 A0  1 
1A214D8 	10  4 A2  1 14 FB A1  1 
      (property)
1A214E0 	24 14 A2  1 
      r> context token!
1A214E4 	D0 45 A0  1 
1A214E8 	DC A3 A0  1 20 54 A0  1 
   else
1A214F0 	C8 41 A0  1  8  0  0  0 
      (property)
1A214F8 	24 14 A2  1 
   then
;
1A214FC 	58 46 A0  1 

: delete-property  ( name-adr,len -- )
1A21500 	64 65 6C 65 74 65 2D 70 
1A21508 	72 6F 70 65 72 74 79 8F 
1A21510 	BC 14 A2  1 20 40 A0  1 
   current-properties (search-wordlist)  if
1A21518 	98  C A2  1  0 BB A0  1 
1A21520 	DC 41 A0  1 10  0  0  0 
      >link current-properties  remove-word
1A21528 	EC 73 A0  1 98  C A2  1 
1A21530 	54 A4 A0  1 
   then
;
1A21534 	58 46 A0  1 
: forget  \ name  ( -- )
1A21538 	 0 66 6F 72 67 65 74 86 
1A21540 	14 15 A2  1 20 40 A0  1 
   current token@  device-node?  abort" Can't forget device methods"
1A21548 	F0 A3 A0  1  C 54 A0  1 
1A21550 	F8  C A2  1  8 81 A0  1 
1A21558 	1B 43 61 6E 27 74 20 66 
1A21560 	6F 72 67 65 74 20 64 65 
1A21568 	76 69 63 65 20 6D 65 74 
1A21570 	68 6F 64 73  0  0  0  0 
   forget
1A21578 	B0 BF A0  1 
;
1A2157C 	58 46 A0  1 

: get-unit  ( -- true | adr len false )  " reg" get-property  ;
1A21580 	 0  0  0 67 65 74 2D 75 
1A21588 	6E 69 74 88 44 15 A2  1 
1A21590 	20 40 A0  1 9C 53 A0  1 
1A21598 	 3 72 65 67  0  0  0  0 
1A215A0 	F4  D A2  1 58 46 A0  1 

headerless
: unit-str>phys-  ( adr len -- phys.hi .. phys.lo )
1A215A8 	 0 75 6E 69 74 2D 73 74 
1A215B0 	72 3E 70 68 79 73 2D 8E 
1A215B8 	90 15 A2  1 20 40 A0  1 
   '#adr-cells @  0  ?do  decode-int -rot  loop  2drop   ( phys.hi .. phys.lo )
1A215C0 	4C FA A1  1 5C 4C A0  1 
1A215C8 	70 6F A0  1 50 42 A0  1 
1A215D0 	14  0  0  0 68 F7 A1  1 
1A215D8 	94 49 A0  1 F8 41 A0  1 
1A215E0 	F4 FF FF FF AC 49 A0  1 
;
1A215E8 	58 46 A0  1 

: reorder  ( xn .. x1 n -- x1 .. xn )  0  ?do  i roll  loop  ;
1A215EC 	72 65 6F 72 
1A215F0 	64 65 72 87 BC 15 A2  1 
1A215F8 	20 40 A0  1 70 6F A0  1 
1A21600 	50 42 A0  1 14  0  0  0 
1A21608 	B4 42 A0  1 50 70 A0  1 
1A21610 	F8 41 A0  1 F4 FF FF FF 
1A21618 	58 46 A0  1 

: unit-str>phys  ( adr len -- phys.lo .. phys.hi )
1A2161C 	 0  0 75 6E 
1A21620 	69 74 2D 73 74 72 3E 70 
1A21628 	68 79 73 8D F8 15 A2  1 
1A21630 	20 40 A0  1 
   unit-str>phys-           ( phys.hi .. phys.lo )
1A21634 	BC 15 A2  1 
   '#adr-cells @  reorder   ( phys.lo .. phys.hi )
1A21638 	4C FA A1  1 5C 4C A0  1 
1A21640 	F8 15 A2  1 
;
1A21644 	58 46 A0  1 
headers

\ From breadth.fth
purpose: 

\ Tree searching code:
\ This implements a funny-order search of an n-ary tree.
\ First, all the child nodes at this level are searched.
\ If not found, then the first child node is made the current node
\ and the process is repeated recursively.  If that fails, the second
\ child node is selected, and so on.
\ All the descendents of the first node will thus be searched before
\ any of the descendents of the second node.
\ This is not quite a breadth-first search.

\ Interface to code in devtree.fth:
\   first-child   ( -- another? )
\       If current-node has a first child, sets current-node to that
\	child and returns true.
\   next-child    ( -- another? )
\	If current-node has a next peer, sets current-node to that peer
\	and returns true, else sets current-node to the parent of
\	current-node and returns false.
\
\ This rather strange interface turns out to be extremely convenient
\ to use in a loop over all children; e.g.
\
\       first-child  begin while   XXX   next-child repeat
\
\ where XXX is the code to be executed for each child.

headerless

: error:  \ name  ( -- )
1A21648 	 0 65 72 72 6F 72 3A 86 
1A21650 	30 16 A2  1 20 40 A0  1 
   create  does>
1A21658 	A8 A2 A0  1 50 A3 A0  1 
1A21660 	90 90 90 E8 14 2A FE FF 
;
1A21668 	58 46 A0  1 

error: found      ," "
1A2166C 	 0  0 66 6F 
1A21670 	75 6E 64 85 54 16 A2  1 
1A21678 	60 16 A2  1  0  0  0  0 
error: not-found  ," Device not found"
1A21680 	 0  0 6E 6F 74 2D 66 6F 
1A21688 	75 6E 64 89 78 16 A2  1 
1A21690 	60 16 A2  1 10 44 65 76 
1A21698 	69 63 65 20 6E 6F 74 20 
1A216A0 	66 6F 75 6E 64  0  0  0 

: (search-level)  ( ? acf -- ? acf )
1A216A8 	 0 28 73 65 61 72 63 68 
1A216B0 	2D 6C 65 76 65 6C 29 8E 
1A216B8 	90 16 A2  1 20 40 A0  1 
   first-child  begin while                ( ? acf )
1A216C0 	 4  B A2  1 DC 41 A0  1 
1A216C8 	40  0  0  0 

      dup catch  ?dup  if                  ( ? acf error )
1A216CC 	40 49 A0  1 
1A216D0 	14 7F A0  1 B4 70 A0  1 
1A216D8 	DC 41 A0  1 10  0  0  0 
         .error                            ( ? acf )
1A216E0 	70 CF A0  1 
      else                                 ( ? acf found? )
1A216E4 	C8 41 A0  1 
1A216E8 	14  0  0  0 
         if  found throw  then             ( ? acf )
1A216EC 	DC 41 A0  1 
1A216F0 	 C  0  0  0 78 16 A2  1 
1A216F8 	74 7F A0  1 
      then

   next-child repeat                       ( ? acf )
1A216FC 	24  B A2  1 
1A21700 	C8 41 A0  1 C0 FF FF FF 
;
1A21708 	58 46 A0  1 

: (search-preorder)  ( ? acf -- ? acf )   recursive
1A2170C 	 0  0 28 73 
1A21710 	65 61 72 63 68 2D 70 72 
1A21718 	65 6F 72 64 65 72 29 91 
1A21720 	BC 16 A2  1 20 40 A0  1 
   (search-level)
1A21728 	BC 16 A2  1 

   first-child  begin while  (search-preorder)  next-child repeat
1A2172C 	 4  B A2  1 
1A21730 	DC 41 A0  1 14  0  0  0 
1A21738 	24 17 A2  1 24  B A2  1 
1A21740 	C8 41 A0  1 EC FF FF FF 
;
1A21748 	58 46 A0  1 

: invert-signal  ( ? acf -- ? acf )
1A2174C 	 0  0 69 6E 
1A21750 	76 65 72 74 2D 73 69 67 
1A21758 	6E 61 6C 8D 24 17 A2  1 
1A21760 	20 40 A0  1 
   catch  case
1A21764 	14 7F A0  1 
      0     of     not-found throw    endof
1A21768 	70 6F A0  1 48 43 A0  1 
1A21770 	14  0  0  0 90 16 A2  1 
1A21778 	74 7F A0  1 6C 43 A0  1 
1A21780 	20  0  0  0 
      found of                        endof
1A21784 	78 16 A2  1 
1A21788 	48 43 A0  1  C  0  0  0 
1A21790 	6C 43 A0  1  C  0  0  0 
      ( default )  throw
1A21798 	74 7F A0  1 
   endcase
1A2179C 	84 43 A0  1 
;
1A217A0 	58 46 A0  1 
: search-preorder  ( ? acf -- ? acf )  ['] (search-preorder)  invert-signal  ;
1A217A4 	73 65 61 72 
1A217A8 	63 68 2D 70 72 65 6F 72 
1A217B0 	64 65 72 8F 60 17 A2  1 
1A217B8 	20 40 A0  1 60 53 A0  1 
1A217C0 	24 17 A2  1 60 17 A2  1 
1A217C8 	58 46 A0  1 
: search-level     ( ? acf -- ? acf )  ['] (search-level)     invert-signal  ;
1A217CC 	 0  0  0 73 
1A217D0 	65 61 72 63 68 2D 6C 65 
1A217D8 	76 65 6C 8C B8 17 A2  1 
1A217E0 	20 40 A0  1 60 53 A0  1 
1A217E8 	BC 16 A2  1 60 17 A2  1 
1A217F0 	58 46 A0  1 
headers

\ From finddev.fth
purpose: 

vocabulary aliases
1A217F4 	61 6C 69 61 
1A217F8 	73 65 73 87 E0 17 A2  1 
1A21800 	E0 B6 A0  1 7C  6  0  0 
1A21808 	F0 12 A2  1  0  0  0  0 

4 /n* buffer: unit#
1A21810 	 0  0 75 6E 69 74 23 85 
1A21818 	 0 18 A2  1 B4 A9 A0  1 
1A21820 	80  6  0  0 10  0  0  0 
1A21828 	BC D4 A1  1 

headerless
0 value unit#-valid?
1A2182C 	 0  0  0 75 
1A21830 	6E 69 74 23 2D 76 61 6C 
1A21838 	69 64 3F 8C 1C 18 A2  1 
1A21840 	50 40 A0  1 84  6  0  0 
: unit-bounds  ( -- end-adr start-adr )  unit#  '#adr-cells @ /n*  bounds  ;
1A21848 	75 6E 69 74 2D 62 6F 75 
1A21850 	6E 64 73 8B 40 18 A2  1 
1A21858 	20 40 A0  1 1C 18 A2  1 
1A21860 	4C FA A1  1 5C 4C A0  1 
1A21868 	98 51 A0  1 F0 6D A0  1 
1A21870 	58 46 A0  1 

: "name" ( -- adr,len )  " name"  ;  \ Space savings
1A21874 	 0 22 6E 61 
1A21878 	6D 65 22 86 58 18 A2  1 
1A21880 	20 40 A0  1 9C 53 A0  1 
1A21888 	 4 6E 61 6D 65  0  0  0 
1A21890 	58 46 A0  1 

\ True if "name$" matches the node's name
: name-match?  ( name$ -- name$ flag )
1A21894 	6E 61 6D 65 
1A21898 	2D 6D 61 74 63 68 3F 8B 
1A218A0 	80 18 A2  1 20 40 A0  1 
   "name" get-property  if                  ( name$ )
1A218A8 	80 18 A2  1 F4  D A2  1 
1A218B0 	DC 41 A0  1 10  0  0  0 
      false                                 ( name$ false )
1A218B8 	18 70 A0  1 
   else                                     ( name$ adr' len' )
1A218BC 	C8 41 A0  1 
1A218C0 	44  0  0  0 
      1-    \ Omit null byte 		    ( name$ adr' len' )
1A218C4 	54 4B A0  1 
      2over 2over  $=  if                   ( name$ adr' len' )
1A218C8 	D8 49 A0  1 D8 49 A0  1 
1A218D0 	88 8D A0  1 DC 41 A0  1 
1A218D8 	14  0  0  0 
         2drop true                         ( name$ true )
1A218DC 	AC 49 A0  1 
1A218E0 	 4 70 A0  1 
      else                                  ( name$ adr' len' )
1A218E4 	C8 41 A0  1 
1A218E8 	1C  0  0  0 
         \ Omit the manufacturer name and test again
         ascii , left-parse-string  2drop  2over  $=
1A218EC 	58 41 A0  1 
1A218F0 	2C  0  0  0 44 D7 A0  1 
1A218F8 	AC 49 A0  1 D8 49 A0  1 
1A21900 	88 8D A0  1 
      then
   then                                     ( name$ flag )
;
1A21904 	58 46 A0  1 

\ True if "unit-adr,space" matches the node's unit number
: unit-match?  ( -- flag )
1A21908 	75 6E 69 74 2D 6D 61 74 
1A21910 	63 68 3F 8B A4 18 A2  1 
1A21918 	20 40 A0  1 
   get-unit  if                 ( )
1A2191C 	90 15 A2  1 
1A21920 	DC 41 A0  1 10  0  0  0 
      false  	                ( flag )  \ No "reg" property
1A21928 	18 70 A0  1 
   else                         ( phys.lo .. phys.hi )
1A2192C 	C8 41 A0  1 
1A21930 	48  0  0  0 
      true                      ( unit-adr,len )
1A21934 	 4 70 A0  1 
      unit-bounds  ?do          ( unit-adr,len  flag )
1A21938 	58 18 A2  1 50 42 A0  1 
1A21940 	30  0  0  0 
         -rot  decode-int       ( flag  unit-adr,len' n )
1A21944 	94 49 A0  1 
1A21948 	68 F7 A1  1 
	 i @ =  3 roll and      ( unit-adr,len' flag' )
1A2194C 	B4 42 A0  1 
1A21950 	5C 4C A0  1 24 48 A0  1 
1A21958 	A0 6F A0  1 50 70 A0  1 
1A21960 	5C 44 A0  1 
      /n +loop                  ( unit-adr,len' flag )
1A21964 	40 51 A0  1 
1A21968 	1C 42 A0  1 D8 FF FF FF 
      nip nip                   ( flag )
1A21970 	FC 46 A0  1 FC 46 A0  1 
   then                         ( flag )
;
1A21978 	58 46 A0  1 

headerless
create bad-number ," Bad number syntax"
1A2197C 	 0 62 61 64 
1A21980 	2D 6E 75 6D 62 65 72 8A 
1A21988 	18 19 A2  1 30 40 A0  1 
1A21990 	11 42 61 64 20 6E 75 6D 
1A21998 	62 65 72 20 73 79 6E 74 
1A219A0 	61 78  0  0 
: safe->number  ( adr len -- n )  $number  if  bad-number throw  then  ;
1A219A4 	 0  0  0 73 
1A219A8 	61 66 65 2D 3E 6E 75 6D 
1A219B0 	62 65 72 8C 8C 19 A2  1 
1A219B8 	20 40 A0  1 40 FE A0  1 
1A219C0 	DC 41 A0  1  C  0  0  0 
1A219C8 	8C 19 A2  1 74 7F A0  1 
1A219D0 	58 46 A0  1 

headers
: package-execute  ( ?? adr len -- ?? )
1A219D4 	70 61 63 6B 
1A219D8 	61 67 65 2D 65 78 65 63 
1A219E0 	75 74 65 8F B8 19 A2  1 
1A219E8 	20 40 A0  1 
   current-device $package-execute?  abort" Package method not found"
1A219EC 	40 F9 A1  1 
1A219F0 	94  D A2  1  8 81 A0  1 
1A219F8 	18 50 61 63 6B 61 67 65 
1A21A00 	20 6D 65 74 68 6F 64 20 
1A21A08 	6E 6F 74 20 66 6F 75 6E 
1A21A10 	64  0  0  0 
;
1A21A14 	58 46 A0  1 
headerless

\ True if the node has no unit number and "name$" matches the node's name
: wildcard-match?  ( name$ acf -- name$ acf flag )
1A21A18 	77 69 6C 64 63 61 72 64 
1A21A20 	2D 6D 61 74 63 68 3F 8F 
1A21A28 	E8 19 A2  1 20 40 A0  1 
   >r
1A21A30 	BC 45 A0  1 
   dup  if
1A21A34 	40 49 A0  1 
1A21A38 	DC 41 A0  1 20  0  0  0 
      name-match?  0=  if  r> false  exit  then
1A21A40 	A4 18 A2  1 24 47 A0  1 
1A21A48 	DC 41 A0  1 10  0  0  0 
1A21A50 	D0 45 A0  1 18 70 A0  1 
1A21A58 	40 46 A0  1 
   then                                                   ( name$ )

   get-unit  0=  if  2drop  r> false  exit  then          ( name$ )
1A21A5C 	90 15 A2  1 
1A21A60 	24 47 A0  1 DC 41 A0  1 
1A21A68 	14  0  0  0 AC 49 A0  1 
1A21A70 	D0 45 A0  1 18 70 A0  1 
1A21A78 	40 46 A0  1 

   dup 0=  unit#-valid? 0=  and  if  r> false  exit  then
1A21A7C 	40 49 A0  1 
1A21A80 	24 47 A0  1 40 18 A2  1 
1A21A88 	24 47 A0  1 5C 44 A0  1 
1A21A90 	DC 41 A0  1 10  0  0  0 
1A21A98 	D0 45 A0  1 18 70 A0  1 
1A21AA0 	40 46 A0  1 

   r> true
1A21AA4 	D0 45 A0  1 
1A21AA8 	 4 70 A0  1 
;
1A21AAC 	58 46 A0  1 

: exact-match?  ( name$ acf -- name$ acf flag )
1A21AB0 	 0  0  0 65 78 61 63 74 
1A21AB8 	2D 6D 61 74 63 68 3F 8C 
1A21AC0 	2C 1A A2  1 20 40 A0  1 
   >r
1A21AC8 	BC 45 A0  1 
   dup  if                              ( name$ )       \ Name present
1A21ACC 	40 49 A0  1 
1A21AD0 	DC 41 A0  1 20  0  0  0 
      name-match?  0=  if  r> false  exit  then
1A21AD8 	A4 18 A2  1 24 47 A0  1 
1A21AE0 	DC 41 A0  1 10  0  0  0 
1A21AE8 	D0 45 A0  1 18 70 A0  1 
1A21AF0 	40 46 A0  1 
   then                                 ( name$ )
   unit#-valid?  if                     ( name$ )       \ Unit present
1A21AF4 	40 18 A2  1 
1A21AF8 	DC 41 A0  1 20  0  0  0 
      unit-match?  0=  if  r> false  exit  then
1A21B00 	18 19 A2  1 24 47 A0  1 
1A21B08 	DC 41 A0  1 10  0  0  0 
1A21B10 	D0 45 A0  1 18 70 A0  1 
1A21B18 	40 46 A0  1 
   then
   r> true
1A21B1C 	D0 45 A0  1 
1A21B20 	 4 70 A0  1 
;
1A21B24 	58 46 A0  1 

\ 1) Search direct children for an exact match
\ 2) Search direct children for a wildcard match
\ 3) Select each child node in turn and (recursively) repeat steps
\    (1), (2), and (3)

: (find-node)  ( unit$ name$ -- unit$ name$ )
1A21B28 	28 66 69 6E 64 2D 6E 6F 
1A21B30 	64 65 29 8B C4 1A A2  1 
1A21B38 	20 40 A0  1 

   \ If the node has no children, then there is no point in searching it,
   \ and it doesn't matter if it has no decode-unit method
   first-child  0=  if  exit  then  pop-device
1A21B3C 	 4  B A2  1 
1A21B40 	24 47 A0  1 DC 41 A0  1 
1A21B48 	 8  0  0  0 40 46 A0  1 
1A21B50 	18 FC A1  1 

   unit#-valid?  if		\ Omit unit match test if no unit string
1A21B54 	40 18 A2  1 
1A21B58 	DC 41 A0  1 68  0  0  0 
      2over " decode-unit"           ( unit$ name$  unit$ method$ )
1A21B60 	D8 49 A0  1 9C 53 A0  1 
1A21B68 	 B 64 65 63 6F 64 65 2D 
1A21B70 	75 6E 69 74  0  0  0  0 

      ['] package-execute catch  if  ( unit$ name$  x x x x )
1A21B78 	60 53 A0  1 E8 19 A2  1 
1A21B80 	14 7F A0  1 DC 41 A0  1 
1A21B88 	10  0  0  0 
         \ If decode-unit aborted, a match at this level is impossible 
         2drop 2drop exit
1A21B8C 	AC 49 A0  1 
1A21B90 	AC 49 A0  1 40 46 A0  1 
      then                           ( unit$ name$ phys.lo .. phys.hi )

      \ We can't use unit-bounds here
      unit# #adr-cells /n*  bounds  ?do  i !  /n +loop   ( unit$ name$ )
1A21B98 	1C 18 A2  1 40  E A2  1 
1A21BA0 	98 51 A0  1 F0 6D A0  1 
1A21BA8 	50 42 A0  1 18  0  0  0 
1A21BB0 	B4 42 A0  1 54 4D A0  1 
1A21BB8 	40 51 A0  1 1C 42 A0  1 
1A21BC0 	F0 FF FF FF 
   then

   \ (search-level) will throw "found" to (find-device) if it succeeds
   ['] exact-match?     (search-level)  drop             ( unit$ name$ )
1A21BC4 	60 53 A0  1 
1A21BC8 	C4 1A A2  1 BC 16 A2  1 
1A21BD0 	30 49 A0  1 
   ['] wildcard-match?  (search-level)  drop             ( unit$ name$ )
1A21BD4 	60 53 A0  1 
1A21BD8 	2C 1A A2  1 BC 16 A2  1 
1A21BE0 	30 49 A0  1 
;
1A21BE4 	58 46 A0  1 

: (find-child-node)  ( unit$ name$ -- unit$ name$ ) recursive
1A21BE8 	 0  0 28 66 69 6E 64 2D 
1A21BF0 	63 68 69 6C 64 2D 6E 6F 
1A21BF8 	64 65 29 91 38 1B A2  1 
1A21C00 	20 40 A0  1 
   first-child  begin while   (find-node) (find-child-node)  next-child repeat
1A21C04 	 4  B A2  1 
1A21C08 	DC 41 A0  1 18  0  0  0 
1A21C10 	38 1B A2  1  0 1C A2  1 
1A21C18 	24  B A2  1 C8 41 A0  1 
1A21C20 	E8 FF FF FF 
;
1A21C24 	58 46 A0  1 

: find-component  ( component$ -- )
1A21C28 	 0 66 69 6E 64 2D 63 6F 
1A21C30 	6D 70 6F 6E 65 6E 74 8E 
1A21C38 	 0 1C A2  1 20 40 A0  1 
   \ Separate out arguments
   ascii : left-parse-string            ( args-str name.unit$ )
1A21C40 	58 41 A0  1 3A  0  0  0 
1A21C48 	44 D7 A0  1 

   \ Arguments only apply to "open", so discard them when searching
   2swap 2drop                              ( name.unit$ )
1A21C4C 	F4 49 A0  1 
1A21C50 	AC 49 A0  1 

   \ Split name and unit
   ascii @  left-parse-string               ( unit$ name$ )
1A21C54 	58 41 A0  1 
1A21C58 	40  0  0  0 44 D7 A0  1 

   2 pick is unit#-valid?                   ( unit$ name$ )
1A21C60 	90 6F A0  1  C 4A A0  1 
1A21C68 	B8 40 A0  1 40 18 A2  1 

   ['] (find-node)  catch  ?dup  if         ( unit$ name$ error )
1A21C70 	60 53 A0  1 38 1B A2  1 
1A21C78 	14 7F A0  1 B4 70 A0  1 
1A21C80 	DC 41 A0  1 30  0  0  0 
       dup found <>  if                     ( unit$ name$ error )
1A21C88 	40 49 A0  1 78 16 A2  1 
1A21C90 	44 48 A0  1 DC 41 A0  1 
1A21C98 	10  0  0  0 
           dup .error throw
1A21C9C 	40 49 A0  1 
1A21CA0 	70 CF A0  1 74 7F A0  1 
       then                                 ( unit$ name$ error )
       drop                                 ( unit$ name$ )
1A21CA8 	30 49 A0  1 
   else                                     ( unit$ name$ )
1A21CAC 	C8 41 A0  1 
1A21CB0 	10  0  0  0 
       ['] (find-child-node)  invert-signal ( unit$ name$ )
1A21CB4 	60 53 A0  1 
1A21CB8 	 0 1C A2  1 60 17 A2  1 
   then                                     ( unit$ name$ )

   2drop 2drop                              ( )
1A21CC0 	AC 49 A0  1 AC 49 A0  1 
;
1A21CC8 	58 46 A0  1 
: (find-device)  ( str -- )
1A21CCC 	 0  0 28 66 
1A21CD0 	69 6E 64 2D 64 65 76 69 
1A21CD8 	63 65 29 8D 3C 1C A2  1 
1A21CE0 	20 40 A0  1 

   0 to unit#-valid?
1A21CE4 	70 6F A0  1 
1A21CE8 	B8 40 A0  1 40 18 A2  1 

   \ If a search path is present, find the indicated subdirectory
   begin  dup  while        ( rem$ )
1A21CF0 	40 49 A0  1 DC 41 A0  1 
1A21CF8 	44  0  0  0 

      \ Split the remaining string at the first backslash, if there is one
      ascii / left-parse-string            ( rem$' component$ )
1A21CFC 	58 41 A0  1 
1A21D00 	2F  0  0  0 44 D7 A0  1 

      dup  if                              ( rem$ component$ )
1A21D08 	40 49 A0  1 DC 41 A0  1 
1A21D10 	10  0  0  0 
         find-component                    ( rem$ )
1A21D14 	3C 1C A2  1 
      else                                 ( rem$ component$ )
1A21D18 	C8 41 A0  1 18  0  0  0 
         \ If the component name string is null, there was a double slash,
         \ indicating an interposed support package.  Skip it.
         2drop                             ( rem$ )
1A21D20 	AC 49 A0  1 
         ascii / left-parse-string  2drop  ( rem$' )
1A21D24 	58 41 A0  1 
1A21D28 	2F  0  0  0 44 D7 A0  1 
1A21D30 	AC 49 A0  1 
      then                                 ( rem$ )

   repeat                   ( rem$ )
1A21D34 	C8 41 A0  1 
1A21D38 	B8 FF FF FF 

   2drop
1A21D3C 	AC 49 A0  1 
;
1A21D40 	58 46 A0  1 

: not-alias?  ( str -- expansion$ false | true )
1A21D44 	 0 6E 6F 74 
1A21D48 	2D 61 6C 69 61 73 3F 8A 
1A21D50 	E0 1C A2  1 20 40 A0  1 
   \ Search the alias list.
   ['] aliases (search-wordlist)  if  execute false  else  true  then
1A21D58 	60 53 A0  1  0 18 A2  1 
1A21D60 	 0 BB A0  1 DC 41 A0  1 
1A21D68 	14  0  0  0 98 41 A0  1 
1A21D70 	18 70 A0  1 C8 41 A0  1 
1A21D78 	 8  0  0  0  4 70 A0  1 
;
1A21D80 	58 46 A0  1 

headerless
\ Ultimately, we need a more robust way to manage the alias buffer.
\ One approach would be to use a two-entry ping-pong buffer.  In every
\ place where "?expand-alias" or "aliased?" is called, save the buffer
\ specification and allocate a new two-entry buffer.  When the buffer
\ is no longer needed, free the buffer and restore the previous one.
\ That will be a little tricky, since they are used in several places,
\ both in this directory and also in pkg/*/*th.
h# 800 buffer: (alias-buf)
1A21D84 	28 61 6C 69 
1A21D88 	61 73 2D 62 75 66 29 8B 
1A21D90 	54 1D A2  1 B4 A9 A0  1 
1A21D98 	88  6  0  0  0  8  0  0 
1A21DA0 	1C 18 A2  1 
0 value alias-buf-offset
1A21DA4 	 0  0  0 61 
1A21DA8 	6C 69 61 73 2D 62 75 66 
1A21DB0 	2D 6F 66 66 73 65 74 90 
1A21DB8 	94 1D A2  1 50 40 A0  1 
1A21DC0 	8C  6  0  0 
: alias-buf  ( -- adr )  (alias-buf) alias-buf-offset +  ;
1A21DC4 	 0  0 61 6C 
1A21DC8 	69 61 73 2D 62 75 66 89 
1A21DD0 	BC 1D A2  1 20 40 A0  1 
1A21DD8 	94 1D A2  1 BC 1D A2  1 
1A21DE0 	 4 45 A0  1 58 46 A0  1 
: switch-alias-buf  ( -- )
1A21DE8 	 0  0  0 73 77 69 74 63 
1A21DF0 	68 2D 61 6C 69 61 73 2D 
1A21DF8 	62 75 66 90 D4 1D A2  1 
1A21E00 	20 40 A0  1 
   alias-buf-offset  h# 100 +  h# 7ff and  to alias-buf-offset
1A21E04 	BC 1D A2  1 
1A21E08 	58 41 A0  1  0  1  0  0 
1A21E10 	 4 45 A0  1 58 41 A0  1 
1A21E18 	FF  7  0  0 5C 44 A0  1 
1A21E20 	B8 40 A0  1 BC 1D A2  1 
;
1A21E28 	58 46 A0  1 

\ Expands devaliases optionally overwriting the default argument
\ to the rightmost component of the expanded pathname
: expand-alias  ( devspec$ -- pathname$ flag )
1A21E2C 	 0  0  0 65 
1A21E30 	78 70 61 6E 64 2D 61 6C 
1A21E38 	69 61 73 8C  0 1E A2  1 
1A21E40 	20 40 A0  1 
   switch-alias-buf
1A21E44 	 0 1E A2  1 
   \ Extract the part of the pathname that can be an alias

   2dup  ascii /  split-before  ( devspec$ tail$ head$ )
1A21E48 	C0 49 A0  1 58 41 A0  1 
1A21E50 	2F  0  0  0 20 19 A1  1 
   ascii :  split-before        ( devspec$ tail$ arg$ name$ )
1A21E58 	58 41 A0  1 3A  0  0  0 
1A21E60 	20 19 A1  1 

   \ If the device-specifier is not an alias, return it unmodified.

   not-alias?  if               ( devspec$ tail$ arg$ )
1A21E64 	54 1D A2  1 
1A21E68 	DC 41 A0  1 14  0  0  0 
      2drop 2drop false  exit   ( devspec$ )
1A21E70 	AC 49 A0  1 AC 49 A0  1 
1A21E78 	18 70 A0  1 40 46 A0  1 
   then                         ( devspec$ tail$ arg$ expansion$ )

   \ The device-specifier is an alias.

   \ If the aliased component of the device-specifier had explicit
   \ arguments, use them to override any arguments that were included
   \ in the alias expansion.

   2 pick  if                   ( devspec$ tail$ arg$ expansion$ )
1A21E80 	90 6F A0  1  C 4A A0  1 
1A21E88 	DC 41 A0  1 40  0  0  0 
      \ alias name has args
      ascii / split-after       ( devspec$ tail$ arg$ alias-tail$ alias-head$ )
1A21E90 	58 41 A0  1 2F  0  0  0 
1A21E98 	BC 19 A1  1 
      alias-buf place           ( devspec$ tail$ arg$ alias-tail$ )
1A21E9C 	D4 1D A2  1 
1A21EA0 	F0 88 A0  1 
      ascii : split-before      ( devspec$ tail$ arg$ $deadargs $alias-tail$' )
1A21EA4 	58 41 A0  1 
1A21EA8 	3A  0  0  0 20 19 A1  1 
      alias-buf $cat            ( devspec$ tail$ arg$ $deadargs )
1A21EB0 	D4 1D A2  1 84 7E A0  1 
      2drop  alias-buf $cat     ( devspec$ tail$ )
1A21EB8 	AC 49 A0  1 D4 1D A2  1 
1A21EC0 	84 7E A0  1 
   else                         ( devspec$ tail$ arg$ expansion$ )
1A21EC4 	C8 41 A0  1 
1A21EC8 	10  0  0  0 
      \ alias name does not have args
      alias-buf place           ( devspec$ tail$ arg$ )
1A21ECC 	D4 1D A2  1 
1A21ED0 	F0 88 A0  1 
      2drop                     ( devspec$ tail$ )
1A21ED4 	AC 49 A0  1 
   then                         ( devspec$ tail$ )

   \ Append the tail of the device specifier to the expanded alias

   alias-buf $cat               ( devspec$ )
1A21ED8 	D4 1D A2  1 84 7E A0  1 
   2drop                        ( devspec$ )
1A21EE0 	AC 49 A0  1 
   alias-buf count  true        ( pathname$ true )
1A21EE4 	D4 1D A2  1 
1A21EE8 	BC 53 A0  1  4 70 A0  1 
;
1A21EF0 	58 46 A0  1 
: aliased?  ( name-str -- name-str false | alias-expansion-str true )
1A21EF4 	 0  0  0 61 
1A21EF8 	6C 69 61 73 65 64 3F 88 
1A21F00 	40 1E A2  1 20 40 A0  1 
   \ The empty string is not an alias
   dup 0=  if  false exit  then               ( str )
1A21F08 	40 49 A0  1 24 47 A0  1 
1A21F10 	DC 41 A0  1  C  0  0  0 
1A21F18 	18 70 A0  1 40 46 A0  1 

   \ A pathname beginning with a slash is not an alias
   over c@  ascii / =  if  false exit  then   ( str )
1A21F20 	54 49 A0  1 C4 4C A0  1 
1A21F28 	58 41 A0  1 2F  0  0  0 
1A21F30 	24 48 A0  1 DC 41 A0  1 
1A21F38 	 C  0  0  0 18 70 A0  1 
1A21F40 	40 46 A0  1 

   d# 100  0  do                              ( str )
1A21F44 	58 41 A0  1 
1A21F48 	64  0  0  0 70 6F A0  1 
1A21F50 	88 42 A0  1 38  0  0  0 
      expand-alias  0=  if                    ( str )
1A21F58 	40 1E A2  1 24 47 A0  1 
1A21F60 	DC 41 A0  1 20  0  0  0 
         \ The result has been expanded if the first character
         \ is now a "/"
         over c@  [char] / =                  ( str flag )
1A21F68 	54 49 A0  1 C4 4C A0  1 
1A21F70 	58 41 A0  1 2F  0  0  0 
1A21F78 	24 48 A0  1 
         unloop exit
1A21F7C 	3C 42 A0  1 
1A21F80 	40 46 A0  1 
      then                                    ( str )
   loop
1A21F84 	F8 41 A0  1 
1A21F88 	D0 FF FF FF 
   true abort" Too many levels of aliasing"
1A21F8C 	 4 70 A0  1 
1A21F90 	 8 81 A0  1 1B 54 6F 6F 
1A21F98 	20 6D 61 6E 79 20 6C 65 
1A21FA0 	76 65 6C 73 20 6F 66 20 
1A21FA8 	61 6C 69 61 73 69 6E 67 
1A21FB0 	 0  0  0  0 
;
1A21FB4 	58 46 A0  1 
: ?expand-alias  ( name-str -- name-str | alias-expansion-str )
1A21FB8 	 0  0 3F 65 78 70 61 6E 
1A21FC0 	64 2D 61 6C 69 61 73 8D 
1A21FC8 	 4 1F A2  1 20 40 A0  1 
   aliased? drop
1A21FD0 	 4 1F A2  1 30 49 A0  1 
;
1A21FD8 	58 46 A0  1 

: context-voc?  ( voc-acf -- flag )  context token@ =  ;
1A21FDC 	 0  0  0 63 
1A21FE0 	6F 6E 74 65 78 74 2D 76 
1A21FE8 	6F 63 3F 8C CC 1F A2  1 
1A21FF0 	20 40 A0  1 DC A3 A0  1 
1A21FF8 	 C 54 A0  1 24 48 A0  1 
1A22000 	58 46 A0  1 
: device-context?  ( -- flag )  ['] context-voc? find-voc  0=  ;
1A22004 	64 65 76 69 
1A22008 	63 65 2D 63 6F 6E 74 65 
1A22010 	78 74 3F 8F F0 1F A2  1 
1A22018 	20 40 A0  1 60 53 A0  1 
1A22020 	F0 1F A2  1 60 B7 A0  1 
1A22028 	24 47 A0  1 58 46 A0  1 

: ?not-found  ( flag -- )  if  not-found throw  then  ;
1A22030 	 0 3F 6E 6F 74 2D 66 6F 
1A22038 	75 6E 64 8A 18 20 A2  1 
1A22040 	20 40 A0  1 DC 41 A0  1 
1A22048 	 C  0  0  0 90 16 A2  1 
1A22050 	74 7F A0  1 58 46 A0  1 
: noalias-find-device  ( str -- )
1A22058 	6E 6F 61 6C 69 61 73 2D 
1A22060 	66 69 6E 64 2D 64 65 76 
1A22068 	69 63 65 93 40 20 A2  1 
1A22070 	20 40 A0  1 
   \ Throw if null string
   ?dup 0=  ?not-found                 ( str$ )
1A22074 	B4 70 A0  1 
1A22078 	24 47 A0  1 40 20 A2  1 

   \ The path starts at the root directory if the first character is "/";
   \ otherwise it starts at the current directory
   dup 1 >=  if                        ( str$ )
1A22080 	40 49 A0  1 80 6F A0  1 
1A22088 	EC 48 A0  1 DC 41 A0  1 
1A22090 	30  0  0  0 
      over c@  ascii /  =  if  1 /string  root-phandle push-device  then
1A22094 	54 49 A0  1 
1A22098 	C4 4C A0  1 58 41 A0  1 
1A220A0 	2F  0  0  0 24 48 A0  1 
1A220A8 	DC 41 A0  1 14  0  0  0 
1A220B0 	80 6F A0  1 3C 85 A0  1 
1A220B8 	F8 10 A2  1 F8 FB A1  1 
   then                                ( str$ )

   current-device dt-null =  ?not-found
1A220C0 	40 F9 A1  1 6C F8 A1  1 
1A220C8 	24 48 A0  1 40 20 A2  1 
   device-context?  0= ?not-found
1A220D0 	18 20 A2  1 24 47 A0  1 
1A220D8 	40 20 A2  1 
   (find-device)
1A220DC 	E0 1C A2  1 
;
1A220E0 	58 46 A0  1 
: aliased-find-device  ( str -- )  ?expand-alias noalias-find-device  ;
1A220E4 	61 6C 69 61 
1A220E8 	73 65 64 2D 66 69 6E 64 
1A220F0 	2D 64 65 76 69 63 65 93 
1A220F8 	70 20 A2  1 20 40 A0  1 
1A22100 	CC 1F A2  1 70 20 A2  1 
1A22108 	58 46 A0  1 
headers
5 actions
1A2210C 	5C 21 A2  1 
1A22110 	44 21 A2  1 3C 21 A2  1 
1A22118 	30 21 A2  1  5  0  0  0 
action: count  ;
1A22120 	90 90 90 E8 54 1F FE FF 
1A22128 	BC 53 A0  1 58 46 A0  1 
action: 3drop  ;        \ No "store" method
1A22130 	20 40 A0  1 90 52 A0  1 
1A22138 	58 46 A0  1 
action:        ;        \ Just return the address
1A2213C 	20 40 A0  1 
1A22140 	58 46 A0  1 
action: drop $cstr cscount 1+  ;    \ Convert to string encoding
1A22144 	20 40 A0  1 
1A22148 	30 49 A0  1 F8 DE A0  1 
1A22150 	AC DF A0  1 30 4B A0  1 
1A22158 	58 46 A0  1 
action: drop get-encoded-string  ;  \ Remove null byte
1A2215C 	20 40 A0  1 
1A22160 	30 49 A0  1 24 F7 A1  1 
1A22168 	58 46 A0  1 
: $devalias  ( name-str expansion-str -- )
1A2216C 	 0  0 24 64 
1A22170 	65 76 61 6C 69 61 73 89 
1A22178 	FC 20 A2  1 20 40 A0  1 
   also aliases definitions
1A22180 	C8 C1 A0  1  0 18 A2  1 
1A22188 	2C C4 A0  1 
   strip-blanks  2swap strip-blanks
1A2218C 	2C  F A1  1 
1A22190 	F4 49 A0  1 2C  F A1  1 
   warning @ >r warning off $create r> warning !
1A22198 	E4 9A A0  1 5C 4C A0  1 
1A221A0 	BC 45 A0  1 E4 9A A0  1 
1A221A8 	F8 4B A0  1 8C A2 A0  1 
1A221B0 	D0 45 A0  1 E4 9A A0  1 
1A221B8 	54 4D A0  1 
   previous definitions
1A221BC 	E4 C3 A0  1 
1A221C0 	2C C4 A0  1 
   ",
1A221C4 	24 89 A0  1 
   use-actions
1A221C8 	60 53 A0  1 20 21 A2  1 
1A221D0 	E0 57 A0  1 
;
1A221D4 	58 46 A0  1 

action-adr-t to dodevalias \ mmo

: locate-device  ( adr len -- true  |  phandle false )
1A221D8 	 0  0 6C 6F 63 61 74 65 
1A221E0 	2D 64 65 76 69 63 65 8D 
1A221E8 	7C 21 A2  1 20 40 A0  1 
   also
1A221F0 	C8 C1 A0  1 
   ['] aliased-find-device catch  if
1A221F4 	60 53 A0  1 
1A221F8 	FC 20 A2  1 14 7F A0  1 
1A22200 	DC 41 A0  1 14  0  0  0 
      2drop true
1A22208 	AC 49 A0  1  4 70 A0  1 
   else
1A22210 	C8 41 A0  1  C  0  0  0 
      current-device false
1A22218 	40 F9 A1  1 18 70 A0  1 
   then
   previous definitions
1A22220 	E4 C3 A0  1 2C C4 A0  1 
;
1A22228 	58 46 A0  1 

headerless
: noa-find-device  ( adr len -- )
1A2222C 	6E 6F 61 2D 
1A22230 	66 69 6E 64 2D 64 65 76 
1A22238 	69 63 65 8F EC 21 A2  1 
1A22240 	20 40 A0  1 
   current-device >r
1A22244 	40 F9 A1  1 
1A22248 	BC 45 A0  1 
   ['] noalias-find-device  catch  case
1A2224C 	60 53 A0  1 
1A22250 	70 20 A2  1 14 7F A0  1 
      0          of  r> drop                          endof
1A22258 	70 6F A0  1 48 43 A0  1 
1A22260 	14  0  0  0 D0 45 A0  1 
1A22268 	30 49 A0  1 6C 43 A0  1 
1A22270 	38  0  0  0 
      not-found  of  r> push-device  not-found throw  endof
1A22274 	90 16 A2  1 
1A22278 	48 43 A0  1 1C  0  0  0 
1A22280 	D0 45 A0  1 F8 FB A1  1 
1A22288 	90 16 A2  1 74 7F A0  1 
1A22290 	6C 43 A0  1 14  0  0  0 
      ( default )    r> push-device  throw
1A22298 	D0 45 A0  1 F8 FB A1  1 
1A222A0 	74 7F A0  1 
   endcase
1A222A4 	84 43 A0  1 
;
1A222A8 	58 46 A0  1 
headers
: find-device  ( adr len -- )  ?expand-alias noa-find-device  ;
1A222AC 	66 69 6E 64 
1A222B0 	2D 64 65 76 69 63 65 8B 
1A222B8 	40 22 A2  1 20 40 A0  1 
1A222C0 	CC 1F A2  1 40 22 A2  1 
1A222C8 	58 46 A0  1 

headerless
: $parent-execute  ( adr len -- )
1A222CC 	24 70 61 72 
1A222D0 	65 6E 74 2D 65 78 65 63 
1A222D8 	75 74 65 8F BC 22 A2  1 
1A222E0 	20 40 A0  1 
   current-device >r  pop-device  package-execute  r> push-device
1A222E4 	40 F9 A1  1 
1A222E8 	BC 45 A0  1 18 FC A1  1 
1A222F0 	E8 19 A2  1 D0 45 A0  1 
1A222F8 	F8 FB A1  1 
;
1A222FC 	58 46 A0  1 
headers

\ From testdevt.fth
purpose: 

headerless
: (nh.) ( u -- adr,len )  push-hex   (u.)  pop-base  ;
1A22300 	 0  0 28 6E 68 2E 29 85 
1A22308 	E0 22 A2  1 20 40 A0  1 
1A22310 	5C F4 A0  1 AC 77 A0  1 
1A22318 	9C F4 A0  1 58 46 A0  1 
: .nh  ( u -- )  (nh.) type  ;
1A22320 	2E 6E 68 83  C 23 A2  1 
1A22328 	20 40 A0  1  C 23 A2  1 
1A22330 	 4 6C A0  1 58 46 A0  1 

: is-named? ( -- value-adr,len true | false )  " name" get-property 0=  ;
1A22338 	 0  0 69 73 2D 6E 61 6D 
1A22340 	65 64 3F 89 28 23 A2  1 
1A22348 	20 40 A0  1 9C 53 A0  1 
1A22350 	 4 6E 61 6D 65  0  0  0 
1A22358 	F4  D A2  1 24 47 A0  1 
1A22360 	58 46 A0  1 
: get-node-name  ( -- adr,len )
1A22364 	 0  0 67 65 
1A22368 	74 2D 6E 6F 64 65 2D 6E 
1A22370 	61 6D 65 8D 48 23 A2  1 
1A22378 	20 40 A0  1 
   is-named?  if  get-encoded-string   else  " <Unnamed>"   then
1A2237C 	48 23 A2  1 
1A22380 	DC 41 A0  1 10  0  0  0 
1A22388 	24 F7 A1  1 C8 41 A0  1 
1A22390 	14  0  0  0 9C 53 A0  1 
1A22398 	 9 3C 55 6E 6E 61 6D 65 
1A223A0 	64 3E  0  0 
;
1A223A4 	58 46 A0  1 

: .node-name  ( -- )
1A223A8 	 0 2E 6E 6F 64 65 2D 6E 
1A223B0 	61 6D 65 8A 78 23 A2  1 
1A223B8 	20 40 A0  1 
   get-node-name  type
1A223BC 	78 23 A2  1 
1A223C0 	 4 6C A0  1 
   get-unit  0=  if                           ( unit-str )
1A223C4 	90 15 A2  1 
1A223C8 	24 47 A0  1 DC 41 A0  1 
1A223D0 	88  0  0  0 
      ." @"
1A223D4 	20 7C A0  1 
1A223D8 	 1 40  0  0 
      unit-str>phys                           ( phys.lo .. phys.hi )
1A223DC 	30 16 A2  1 
      " encode-unit"  parent-device           ( phys.lo .. phys.hi adr,len phandle )
1A223E0 	9C 53 A0  1  B 65 6E 63 
1A223E8 	6F 64 65 2D 75 6E 69 74 
1A223F0 	 0  0  0  0 EC FA A1  1 
      $package-execute?  if                   ( phys.lo .. phys.hi )
1A223F8 	94  D A2  1 DC 41 A0  1 
1A22400 	54  0  0  0 
         '#adr-cells @  if  .nh  then         ( phys.lo .. phys.next )
1A22404 	4C FA A1  1 
1A22408 	5C 4C A0  1 DC 41 A0  1 
1A22410 	 8  0  0  0 28 23 A2  1 
	 '#adr-cells @ 1-  0 max  0  ?do  ." ,"  .nh  loop  ( )
1A22418 	4C FA A1  1 5C 4C A0  1 
1A22420 	54 4B A0  1 70 6F A0  1 
1A22428 	9C 4A A0  1 70 6F A0  1 
1A22430 	50 42 A0  1 18  0  0  0 
1A22438 	20 7C A0  1  1 2C  0  0 
1A22440 	28 23 A2  1 F8 41 A0  1 
1A22448 	F0 FF FF FF 
      else
1A2244C 	C8 41 A0  1 
1A22450 	 8  0  0  0 
         type
1A22454 	 4 6C A0  1 
      then
   then
;
1A22458 	58 46 A0  1 

: u.h   ( u -- )   push-hex u. pop-base  ;
1A2245C 	75 2E 68 83 
1A22460 	B8 23 A2  1 20 40 A0  1 
1A22468 	5C F4 A0  1 C8 77 A0  1 
1A22470 	9C F4 A0  1 58 46 A0  1 

: .nodeid  ( -- )  current-device u.h  .node-name  cr  ;
1A22478 	2E 6E 6F 64 65 69 64 87 
1A22480 	64 24 A2  1 20 40 A0  1 
1A22488 	40 F9 A1  1 64 24 A2  1 
1A22490 	B8 23 A2  1 80 6D A0  1 
1A22498 	58 46 A0  1 

: 8.x  ( n -- )
1A2249C 	38 2E 78 83 
1A224A0 	84 24 A2  1 20 40 A0  1 
   push-hex
1A224A8 	5C F4 A0  1 
   (.8) type space
1A224AC 	28 79 A0  1 
1A224B0 	 4 6C A0  1 CC 71 A0  1 
   pop-base
1A224B8 	9C F4 A0  1 
;
1A224BC 	58 46 A0  1 

: to-display-column  ( -- )  d# 25 to-column  ;
1A224C0 	 0  0 74 6F 2D 64 69 73 
1A224C8 	70 6C 61 79 2D 63 6F 6C 
1A224D0 	75 6D 6E 91 A4 24 A2  1 
1A224D8 	20 40 A0  1 58 41 A0  1 
1A224E0 	19  0  0  0  8 14 A1  1 
1A224E8 	58 46 A0  1 

\ Displays the property value "adr,len" as a list of integer values,
\ showing '#ints/line' on each line.
: .ints  ( adr len #ints/line  -- )
1A224EC 	 0  0 2E 69 
1A224F0 	6E 74 73 85 D8 24 A2  1 
1A224F8 	20 40 A0  1 
   >r
1A224FC 	BC 45 A0  1 
   begin  dup 0>  while                  ( adr len )
1A22500 	40 49 A0  1 A4 47 A0  1 
1A22508 	DC 41 A0  1 58  0  0  0 
      to-display-column
1A22510 	D8 24 A2  1 
      r@  0  do  decode-int 8.x  loop    ( adr' len' )
1A22514 	E4 45 A0  1 
1A22518 	70 6F A0  1 88 42 A0  1 
1A22520 	14  0  0  0 68 F7 A1  1 
1A22528 	A4 24 A2  1 F8 41 A0  1 
1A22530 	F4 FF FF FF 
      cr
1A22534 	80 6D A0  1 
      \ Pause before additional lines
      dup 0>  if  exit?  if  1 throw  then  then  ( adr' len' flag )
1A22538 	40 49 A0  1 A4 47 A0  1 
1A22540 	DC 41 A0  1 18  0  0  0 
1A22548 	34  D A1  1 DC 41 A0  1 
1A22550 	 C  0  0  0 80 6F A0  1 
1A22558 	74 7F A0  1 
   repeat                                ( adr',len' )
1A2255C 	C8 41 A0  1 
1A22560 	A0 FF FF FF 
   r> 3drop
1A22564 	D0 45 A0  1 
1A22568 	90 52 A0  1 
;
1A2256C 	58 46 A0  1 

: parent-#size-cells  ( -- #size-cells )
1A22570 	 0 70 61 72 65 6E 74 2D 
1A22578 	23 73 69 7A 65 2D 63 65 
1A22580 	6C 6C 73 92 F8 24 A2  1 
1A22588 	20 40 A0  1 
   \ Root node has no parent, therefore the size of its parent's address
   \ space is meaningless
   root-device?  if  0  exit  then
1A2258C 	4C 11 A2  1 
1A22590 	DC 41 A0  1  C  0  0  0 
1A22598 	70 6F A0  1 40 46 A0  1 
   current-device >r  pop-device
1A225A0 	40 F9 A1  1 BC 45 A0  1 
1A225A8 	18 FC A1  1 
   " #size-cells" get-property  if  1  else  get-encoded-int  then
1A225AC 	9C 53 A0  1 
1A225B0 	 B 23 73 69 7A 65 2D 63 
1A225B8 	65 6C 6C 73  0  0  0  0 
1A225C0 	F4  D A2  1 DC 41 A0  1 
1A225C8 	10  0  0  0 80 6F A0  1 
1A225D0 	C8 41 A0  1  8  0  0  0 
1A225D8 	A0 F7 A1  1 
   r> push-device
1A225DC 	D0 45 A0  1 
1A225E0 	F8 FB A1  1 
;
1A225E4 	58 46 A0  1 
: my-#size-cells  ( -- #size-cells )
1A225E8 	 0 6D 79 2D 23 73 69 7A 
1A225F0 	65 2D 63 65 6C 6C 73 8E 
1A225F8 	88 25 A2  1 20 40 A0  1 
   " #size-cells" get-property  if  1  else  get-encoded-int  then
1A22600 	9C 53 A0  1  B 23 73 69 
1A22608 	7A 65 2D 63 65 6C 6C 73 
1A22610 	 0  0  0  0 F4  D A2  1 
1A22618 	DC 41 A0  1 10  0  0  0 
1A22620 	80 6F A0  1 C8 41 A0  1 
1A22628 	 8  0  0  0 A0 F7 A1  1 
;
1A22630 	58 46 A0  1 
: size+  ( #cells -- #cells+#size-cells )  parent-#size-cells +  ;
1A22634 	 0  0 73 69 
1A22638 	7A 65 2B 85 FC 25 A2  1 
1A22640 	20 40 A0  1 88 25 A2  1 
1A22648 	 4 45 A0  1 58 46 A0  1 

vocabulary known-int-properties
1A22650 	 0  0  0 6B 6E 6F 77 6E 
1A22658 	2D 69 6E 74 2D 70 72 6F 
1A22660 	70 65 72 74 69 65 73 94 
1A22668 	40 26 A2  1 E0 B6 A0  1 
1A22670 	90  6  0  0  0 18 A2  1 
1A22678 	 0  0  0  0 
also known-int-properties definitions

headers
: intr             ( -- n )  2  ;
1A2267C 	 0  0  0 69 
1A22680 	6E 74 72 84  0  0 A0  1 
1A22688 	20 40 A0  1 90 6F A0  1 
1A22690 	58 46 A0  1 
: available        ( -- n )  '#adr-cells @ size+  ;
1A22694 	 0  0 61 76 
1A22698 	61 69 6C 61 62 6C 65 89 
1A226A0 	88 26 A2  1 20 40 A0  1 
1A226A8 	4C FA A1  1 5C 4C A0  1 
1A226B0 	40 26 A2  1 58 46 A0  1 
: reg              ( -- n )  '#adr-cells @ size+  ;
1A226B8 	72 65 67 83 A4 26 A2  1 
1A226C0 	20 40 A0  1 4C FA A1  1 
1A226C8 	5C 4C A0  1 40 26 A2  1 
1A226D0 	58 46 A0  1 
: existing         ( -- n )  '#adr-cells @ size+  ;
1A226D4 	 0  0  0 65 
1A226D8 	78 69 73 74 69 6E 67 88 
1A226E0 	C0 26 A2  1 20 40 A0  1 
1A226E8 	4C FA A1  1 5C 4C A0  1 
1A226F0 	40 26 A2  1 58 46 A0  1 
: ranges           ( -- n )  '#adr-cells @  #adr-cells + my-#size-cells +  ;
1A226F8 	 0 72 61 6E 67 65 73 86 
1A22700 	E4 26 A2  1 20 40 A0  1 
1A22708 	4C FA A1  1 5C 4C A0  1 
1A22710 	40  E A2  1  4 45 A0  1 
1A22718 	FC 25 A2  1  4 45 A0  1 
1A22720 	58 46 A0  1 
: dma-ranges       ( -- n )  ranges  ;
1A22724 	 0 64 6D 61 
1A22728 	2D 72 61 6E 67 65 73 8A 
1A22730 	 4 27 A2  1 20 40 A0  1 
1A22738 	 4 27 A2  1 58 46 A0  1 
: address          ( -- n )  1  ;
1A22740 	61 64 64 72 65 73 73 87 
1A22748 	34 27 A2  1 20 40 A0  1 
1A22750 	80 6F A0  1 58 46 A0  1 
: interrupts       ( -- n )  1  ;
1A22758 	 0 69 6E 74 65 72 72 75 
1A22760 	70 74 73 8A 4C 27 A2  1 
1A22768 	20 40 A0  1 80 6F A0  1 
1A22770 	58 46 A0  1 
: clock-frequency  ( -- n )  1  ;
1A22774 	63 6C 6F 63 
1A22778 	6B 2D 66 72 65 71 75 65 
1A22780 	6E 63 79 8F 68 27 A2  1 
1A22788 	20 40 A0  1 80 6F A0  1 
1A22790 	58 46 A0  1 
: #size-cells      ( -- n )  1  ;
1A22794 	23 73 69 7A 
1A22798 	65 2D 63 65 6C 6C 73 8B 
1A227A0 	88 27 A2  1 20 40 A0  1 
1A227A8 	80 6F A0  1 58 46 A0  1 
: dma              ( -- n )  5  ;
1A227B0 	64 6D 61 83 A4 27 A2  1 
1A227B8 	20 40 A0  1 C0 6F A0  1 
1A227C0 	58 46 A0  1 

previous definitions

headerless
: show-strings  ( adr,len -- )
1A227C4 	 0  0  0 73 
1A227C8 	68 6F 77 2D 73 74 72 69 
1A227D0 	6E 67 73 8C 6C 26 A2  1 
1A227D8 	20 40 A0  1 
   begin  dup  while  decode-string  to-display-column type cr  repeat
1A227DC 	40 49 A0  1 
1A227E0 	DC 41 A0  1 1C  0  0  0 
1A227E8 	FC F6 A1  1 D8 24 A2  1 
1A227F0 	 4 6C A0  1 80 6D A0  1 
1A227F8 	C8 41 A0  1 E0 FF FF FF 
   2drop
1A22800 	AC 49 A0  1 
;
1A22804 	58 46 A0  1 
: display  ( anf adr len -- )
1A22808 	64 69 73 70 6C 61 79 87 
1A22810 	D8 27 A2  1 20 40 A0  1 
   rot  name>string   ( adr,len  name,len )
1A22818 	7C 49 A0  1 58 74 A0  1 

   2dup  " compatible"  $=  if  2drop show-strings  exit  then
1A22820 	C0 49 A0  1 9C 53 A0  1 
1A22828 	 A 63 6F 6D 70 61 74 69 
1A22830 	62 6C 65  0 88 8D A0  1 
1A22838 	DC 41 A0  1 10  0  0  0 
1A22840 	AC 49 A0  1 D8 27 A2  1 
1A22848 	40 46 A0  1 

   ['] known-int-properties (search-wordlist)  if
1A2284C 	60 53 A0  1 
1A22850 	6C 26 A2  1  0 BB A0  1 
1A22858 	DC 41 A0  1 10  0  0  0 
       execute .ints  exit
1A22860 	98 41 A0  1 F8 24 A2  1 
1A22868 	40 46 A0  1 
   then  ( adr,len )

   \ Test for unprintable characters
   2dup -null text?  if   
1A2286C 	C0 49 A0  1 
1A22870 	88 E9 A1  1 C8 E9 A1  1 
1A22878 	DC 41 A0  1 14  0  0  0 
      to-display-column  -null  type  exit  
1A22880 	D8 24 A2  1 88 E9 A1  1 
1A22888 	 4 6C A0  1 40 46 A0  1 
   then   ( adr,len )

   dup /n =  if  1 .ints   exit  then                              ( adr,len )
1A22890 	40 49 A0  1 40 51 A0  1 
1A22898 	24 48 A0  1 DC 41 A0  1 
1A228A0 	10  0  0  0 80 6F A0  1 
1A228A8 	F8 24 A2  1 40 46 A0  1 

   to-display-column  h# 10 min  cdump                             ( )
1A228B0 	D8 24 A2  1 58 41 A0  1 
1A228B8 	10  0  0  0 74 4A A0  1 
1A228C0 	4C E9 A1  1 
;
1A228C4 	58 46 A0  1 

: (.parents)  ( -- )  recursive
1A228C8 	 0 28 2E 70 61 72 65 6E 
1A228D0 	74 73 29 8A 14 28 A2  1 
1A228D8 	20 40 A0  1 
   root-device?  0=  if
1A228DC 	4C 11 A2  1 
1A228E0 	24 47 A0  1 DC 41 A0  1 
1A228E8 	20  0  0  0 
      current-device  pop-device  (.parents)  push-device
1A228EC 	40 F9 A1  1 
1A228F0 	18 FC A1  1 D8 28 A2  1 
1A228F8 	F8 FB A1  1 
      ." /"  .node-name
1A228FC 	20 7C A0  1 
1A22900 	 1 2F  0  0 B8 23 A2  1 
   then
;
1A22908 	58 46 A0  1 

: .not-devtree ( -- )
1A2290C 	 0  0  0 2E 
1A22910 	6E 6F 74 2D 64 65 76 74 
1A22918 	72 65 65 8C D8 28 A2  1 
1A22920 	20 40 A0  1 
   ." Not at a device tree node. Use 'dev <device-pathname>'."
1A22924 	20 7C A0  1 
1A22928 	37 4E 6F 74 20 61 74 20 
1A22930 	61 20 64 65 76 69 63 65 
1A22938 	20 74 72 65 65 20 6E 6F 
1A22940 	64 65 2E 20 55 73 65 20 
1A22948 	27 64 65 76 20 3C 64 65 
1A22950 	76 69 63 65 2D 70 61 74 
1A22958 	68 6E 61 6D 65 3E 27 2E 
1A22960 	 0  0  0  0 
;
1A22964 	58 46 A0  1 
: (.property)  ( anf xt -- )  dup .name >r r@ get r> decode display  ;
1A22968 	28 2E 70 72 6F 70 65 72 
1A22970 	74 79 29 8B 20 29 A2  1 
1A22978 	20 40 A0  1 40 49 A0  1 
1A22980 	C8 9A A0  1 BC 45 A0  1 
1A22988 	E4 45 A0  1 D4 E7 A1  1 
1A22990 	D0 45 A0  1  8 E8 A1  1 
1A22998 	14 28 A2  1 58 46 A0  1 
: options?  ( -- flag )  current-properties  ['] options  =  ;
1A229A0 	 0  0  0 6F 70 74 69 6F 
1A229A8 	6E 73 3F 88 78 29 A2  1 
1A229B0 	20 40 A0  1 98  C A2  1 
1A229B8 	60 53 A0  1 90 E7 A1  1 
1A229C0 	24 48 A0  1 58 46 A0  1 
headers
: .property  ( "name" -- )  ' (.property)  ;
1A229C8 	 0  0 2E 70 72 6F 70 65 
1A229D0 	72 74 79 89 B0 29 A2  1 
1A229D8 	20 40 A0  1 F8 95 A0  1 
1A229E0 	78 29 A2  1 58 46 A0  1 
: .properties  ( -- )
1A229E8 	2E 70 72 6F 70 65 72 74 
1A229F0 	69 65 73 8B D8 29 A2  1 
1A229F8 	20 40 A0  1 
   device-context?  if
1A229FC 	18 20 A2  1 
1A22A00 	DC 41 A0  1 C4  0  0  0 
      current-properties follow
1A22A08 	98  C A2  1 38 BC A0  1 
      begin
         ??cr
1A22A10 	 0 A1 A0  1 
	 another?
1A22A14 	68 BC A0  1 
      while
1A22A18 	DC 41 A0  1 44  0  0  0 
         exit?  if  drop exit  then
1A22A20 	34  D A1  1 DC 41 A0  1 
1A22A28 	 C  0  0  0 30 49 A0  1 
1A22A30 	40 46 A0  1 
	 dup name>  ['] (.property)  catch  if  2drop exit  then
1A22A34 	40 49 A0  1 
1A22A38 	 8 74 A0  1 60 53 A0  1 
1A22A40 	78 29 A2  1 14 7F A0  1 
1A22A48 	DC 41 A0  1  C  0  0  0 
1A22A50 	AC 49 A0  1 40 46 A0  1 
      repeat
1A22A58 	C8 41 A0  1 B4 FF FF FF 
      \ In the options node, also display user-created environment variables
      options?  if
1A22A60 	B0 29 A2  1 DC 41 A0  1 
1A22A68 	58  0  0  0 
         null$  begin                      ( adr len )
1A22A6C 	7C E1 A1  1 
            next-env-var  dup              ( adr' len' len' )
1A22A70 	4C ED A1  1 40 49 A0  1 
         while                             ( adr len )
1A22A78 	DC 41 A0  1 40  0  0  0 
            exit?  if  2drop exit  then    ( adr len )
1A22A80 	34  D A1  1 DC 41 A0  1 
1A22A88 	 C  0  0  0 AC 49 A0  1 
1A22A90 	40 46 A0  1 
            2dup type  to-display-column   ( adr len )
1A22A94 	C0 49 A0  1 
1A22A98 	 4 6C A0  1 D8 24 A2  1 
            2dup get-env-var drop type cr  ( adr len )
1A22AA0 	C0 49 A0  1 8C EE A1  1 
1A22AA8 	30 49 A0  1  4 6C A0  1 
1A22AB0 	80 6D A0  1 
         repeat                            ( adr len )
1A22AB4 	C8 41 A0  1 
1A22AB8 	B8 FF FF FF 
         2drop                             ( )
1A22ABC 	AC 49 A0  1 
      then
   else
1A22AC0 	C8 41 A0  1  8  0  0  0 
      .not-devtree
1A22AC8 	20 29 A2  1 
   then
;
1A22ACC 	58 46 A0  1 
: ls  ( -- )
1A22AD0 	 0 6C 73 82 F8 29 A2  1 
1A22AD8 	20 40 A0  1 
   device-context?  if
1A22ADC 	18 20 A2  1 
1A22AE0 	DC 41 A0  1 40  0  0  0 
      'child token@                   ( first-node-voc )
1A22AE8 	 8 FA A1  1  C 54 A0  1 
      begin  non-null?  while         ( node-voc )
1A22AF0 	34 59 A0  1 DC 41 A0  1 
1A22AF8 	24  0  0  0 
	 voc>phandle push-device      ( )
1A22AFC 	40 F8 A1  1 
1A22B00 	F8 FB A1  1 
	 .nodeid                      ( )
1A22B04 	84 24 A2  1 
	 'peer token@                 ( node-voc' )
1A22B08 	1C FA A1  1  C 54 A0  1 
	 pop-device                   ( )
1A22B10 	18 FC A1  1 
      repeat                          ( )
1A22B14 	C8 41 A0  1 
1A22B18 	D8 FF FF FF 
   else
1A22B1C 	C8 41 A0  1 
1A22B20 	 8  0  0  0 
      .not-devtree
1A22B24 	20 29 A2  1 
   then
;
1A22B28 	58 46 A0  1 
: delete-my-children  ( -- )
1A22B2C 	 0 64 65 6C 
1A22B30 	65 74 65 2D 6D 79 2D 63 
1A22B38 	68 69 6C 64 72 65 6E 92 
1A22B40 	D8 2A A2  1 20 40 A0  1 
   device-context?  if
1A22B48 	18 20 A2  1 DC 41 A0  1 
1A22B50 	40  0  0  0 
      'child token@                   ( first-node-voc )
1A22B54 	 8 FA A1  1 
1A22B58 	 C 54 A0  1 
      begin  non-null?  while         ( node-voc )
1A22B5C 	34 59 A0  1 
1A22B60 	DC 41 A0  1 2C  0  0  0 
	 voc>phandle dup push-device  ( node-phandle )
1A22B68 	40 F8 A1  1 40 49 A0  1 
1A22B70 	F8 FB A1  1 
	 'peer token@                 ( node-phandle peer-voc )
1A22B74 	1C FA A1  1 
1A22B78 	 C 54 A0  1 
	 pop-device                   ( node-phandle peer-voc )
1A22B7C 	18 FC A1  1 
         swap delete-package          ( peer-voc )
1A22B80 	68 49 A0  1 78 12 A2  1 
      repeat                          ( )
1A22B88 	C8 41 A0  1 D0 FF FF FF 
   then
;
1A22B90 	58 46 A0  1 

headers

: (pwd)  ( -- )
1A22B94 	 0  0 28 70 
1A22B98 	77 64 29 85 44 2B A2  1 
1A22BA0 	20 40 A0  1 
   root-device?  if  ." /"  else  (.parents)  then
1A22BA4 	4C 11 A2  1 
1A22BA8 	DC 41 A0  1 14  0  0  0 
1A22BB0 	20 7C A0  1  1 2F  0  0 
1A22BB8 	C8 41 A0  1  8  0  0  0 
1A22BC0 	D8 28 A2  1 
;
1A22BC4 	58 46 A0  1 
: pwd  ( -- )
1A22BC8 	70 77 64 83 A0 2B A2  1 
1A22BD0 	20 40 A0  1 
   device-context?  if  (pwd)  else  .not-devtree  then   cr  
1A22BD4 	18 20 A2  1 
1A22BD8 	DC 41 A0  1 10  0  0  0 
1A22BE0 	A0 2B A2  1 C8 41 A0  1 
1A22BE8 	 8  0  0  0 20 29 A2  1 
1A22BF0 	80 6D A0  1 
;
1A22BF4 	58 46 A0  1 
: .voc-name   ( a -- )
1A22BF8 	 0  0 2E 76 6F 63 2D 6E 
1A22C00 	61 6D 65 89 D0 2B A2  1 
1A22C08 	20 40 A0  1 
   dup device-node? if
1A22C0C 	40 49 A0  1 
1A22C10 	F8  C A2  1 DC 41 A0  1 
1A22C18 	30  0  0  0 
      current-device phandle>voc  swap context token! (pwd) space  
1A22C1C 	40 F9 A1  1 
1A22C20 	58 F8 A1  1 68 49 A0  1 
1A22C28 	DC A3 A0  1 20 54 A0  1 
1A22C30 	A0 2B A2  1 CC 71 A0  1 
      context token!
1A22C38 	DC A3 A0  1 20 54 A0  1 
   else
1A22C40 	C8 41 A0  1  8  0  0  0 
      .name
1A22C48 	C8 9A A0  1 
   then
;
1A22C4C 	58 46 A0  1 
: order   (s -- )
1A22C50 	 0  0 6F 72 64 65 72 85 
1A22C58 	 8 2C A2  1 20 40 A0  1 
   ." context: "
1A22C60 	20 7C A0  1  9 63 6F 6E 
1A22C68 	74 65 78 74 3A 20  0  0 
   get-order  0  ?do  .voc-name  loop
1A22C70 	AC C2 A0  1 70 6F A0  1 
1A22C78 	50 42 A0  1 10  0  0  0 
1A22C80 	 8 2C A2  1 F8 41 A0  1 
1A22C88 	F8 FF FF FF 
   cr  ." current: "  get-current .voc-name
1A22C8C 	80 6D A0  1 
1A22C90 	20 7C A0  1  9 63 75 72 
1A22C98 	72 65 6E 74 3A 20  0  0 
1A22CA0 	6C C2 A0  1  8 2C A2  1 
;
1A22CA8 	58 46 A0  1 

headerless
: shownode  ( -- false )  exit?  if  true  else  pwd false  then  ;
1A22CAC 	 0  0  0 73 
1A22CB0 	68 6F 77 6E 6F 64 65 88 
1A22CB8 	5C 2C A2  1 20 40 A0  1 
1A22CC0 	34  D A1  1 DC 41 A0  1 
1A22CC8 	10  0  0  0  4 70 A0  1 
1A22CD0 	C8 41 A0  1  C  0  0  0 
1A22CD8 	D0 2B A2  1 18 70 A0  1 
1A22CE0 	58 46 A0  1 
: optional-arg-or-/$ ( -- adr len )
1A22CE4 	 0 6F 70 74 
1A22CE8 	69 6F 6E 61 6C 2D 61 72 
1A22CF0 	67 2D 6F 72 2D 2F 24 92 
1A22CF8 	BC 2C A2  1 20 40 A0  1 
   parse-word dup 0=  if  2drop " /"  then  ( adr len )
1A22D00 	34 93 A0  1 40 49 A0  1 
1A22D08 	24 47 A0  1 DC 41 A0  1 
1A22D10 	10  0  0  0 AC 49 A0  1 
1A22D18 	9C 53 A0  1  1 2F  0  0 
;
1A22D20 	58 46 A0  1 
headers
: $show-devs  ( adr len -- )
1A22D24 	 0 24 73 68 
1A22D28 	6F 77 2D 64 65 76 73 8A 
1A22D30 	FC 2C A2  1 20 40 A0  1 
   locate-device  if  not-found throw  then
1A22D38 	EC 21 A2  1 DC 41 A0  1 
1A22D40 	 C  0  0  0 90 16 A2  1 
1A22D48 	74 7F A0  1 
   push-package
1A22D4C 	7C FB A1  1 
      ['] shownode  ['] (search-preorder) catch 2drop
1A22D50 	60 53 A0  1 BC 2C A2  1 
1A22D58 	60 53 A0  1 24 17 A2  1 
1A22D60 	14 7F A0  1 AC 49 A0  1 
   pop-package
1A22D68 	D8 FB A1  1 
;
1A22D6C 	58 46 A0  1 
: show-devs  ( ["path"] -- )  optional-arg-or-/$ $show-devs  ;
1A22D70 	 0  0 73 68 6F 77 2D 64 
1A22D78 	65 76 73 89 34 2D A2  1 
1A22D80 	20 40 A0  1 FC 2C A2  1 
1A22D88 	34 2D A2  1 58 46 A0  1 

: dev  ( -- )
1A22D90 	64 65 76 83 80 2D A2  1 
1A22D98 	20 40 A0  1 
   optional-arg-or-/$            ( adr,len )
1A22D9C 	FC 2C A2  1 
   ?expand-alias                 ( adr,len )
1A22DA0 	CC 1F A2  1 
   2dup " .." $=  if             ( adr,len )
1A22DA4 	C0 49 A0  1 
1A22DA8 	9C 53 A0  1  2 2E 2E  0 
1A22DB0 	88 8D A0  1 DC 41 A0  1 
1A22DB8 	2C  0  0  0 
      2drop device-context?  if  (  )
1A22DBC 	AC 49 A0  1 
1A22DC0 	18 20 A2  1 DC 41 A0  1 
1A22DC8 	10  0  0  0 
	 pop-device              (  )
1A22DCC 	18 FC A1  1 
      else                       (  )
1A22DD0 	C8 41 A0  1  8  0  0  0 
	 .not-devtree            (  )
1A22DD8 	20 29 A2  1 
      then                       (  )
   else                          ( adr,len )
1A22DDC 	C8 41 A0  1 
1A22DE0 	 8  0  0  0 
      find-device                (  )
1A22DE4 	BC 22 A2  1 
   then                          (  )
;
1A22DE8 	58 46 A0  1 

: show-props  ( -- )
1A22DEC 	 0 73 68 6F 
1A22DF0 	77 2D 70 72 6F 70 73 8A 
1A22DF8 	98 2D A2  1 20 40 A0  1 
   current-device >r
1A22E00 	40 F9 A1  1 BC 45 A0  1 
   optional-arg-or-/$           ( adr len )
1A22E08 	FC 2C A2  1 
   find-device  .properties  device-end
1A22E0C 	BC 22 A2  1 
1A22E10 	F8 29 A2  1 94  F A2  1 
   r> push-device
1A22E18 	D0 45 A0  1 F8 FB A1  1 
;
1A22E20 	58 46 A0  1 
headerless
: show-aliases  ( -- )
1A22E24 	 0  0  0 73 
1A22E28 	68 6F 77 2D 61 6C 69 61 
1A22E30 	73 65 73 8C FC 2D A2  1 
1A22E38 	20 40 A0  1 
   also  " /aliases" find-device  .properties  (  )
1A22E3C 	C8 C1 A0  1 
1A22E40 	9C 53 A0  1  8 2F 61 6C 
1A22E48 	69 61 73 65 73  0  0  0 
1A22E50 	BC 22 A2  1 F8 29 A2  1 
   previous definitions                        (  )
1A22E58 	E4 C3 A0  1 2C C4 A0  1 
;
1A22E60 	58 46 A0  1 
: show-alias  ( adr len -- )
1A22E64 	 0 73 68 6F 
1A22E68 	77 2D 61 6C 69 61 73 8A 
1A22E70 	38 2E A2  1 20 40 A0  1 
   2dup " name" $= 0=  if     ( adr,len )
1A22E78 	C0 49 A0  1 9C 53 A0  1 
1A22E80 	 4 6E 61 6D 65  0  0  0 
1A22E88 	88 8D A0  1 24 47 A0  1 
1A22E90 	DC 41 A0  1 30  0  0  0 
      ['] aliases $vfind  if  ( xt )
1A22E98 	60 53 A0  1  0 18 A2  1 
1A22EA0 	5C BB A0  1 DC 41 A0  1 
1A22EA8 	1C  0  0  0 
	 dup >name swap  (.property) cr exit
1A22EAC 	40 49 A0  1 
1A22EB0 	24 74 A0  1 68 49 A0  1 
1A22EB8 	78 29 A2  1 80 6D A0  1 
1A22EC0 	40 46 A0  1 
      then                    ( adr,len )
   then                       ( adr,len )
   type ."  : no such alias"  (  )
1A22EC4 	 4 6C A0  1 
1A22EC8 	20 7C A0  1 10 20 3A 20 
1A22ED0 	6E 6F 20 73 75 63 68 20 
1A22ED8 	61 6C 69 61 73  0  0  0 
;
1A22EE0 	58 46 A0  1 
headers
: devalias  \ name string  ( -- )
1A22EE4 	 0  0  0 64 
1A22EE8 	65 76 61 6C 69 61 73 88 
1A22EF0 	74 2E A2  1 20 40 A0  1 
   parse-word  parse-word
1A22EF8 	34 93 A0  1 34 93 A0  1 
   dup  if                        ( name$ path$ )
1A22F00 	40 49 A0  1 DC 41 A0  1 
1A22F08 	10  0  0  0 
      $devalias  (  )
1A22F0C 	7C 21 A2  1 
   else                           ( name$ path$ )
1A22F10 	C8 41 A0  1 28  0  0  0 
      2drop dup  if               ( name$ )
1A22F18 	AC 49 A0  1 40 49 A0  1 
1A22F20 	DC 41 A0  1 10  0  0  0 
	 show-alias               (  )
1A22F28 	74 2E A2  1 
      else                        ( name$ )
1A22F2C 	C8 41 A0  1 
1A22F30 	 C  0  0  0 
	 2drop show-aliases       (  )
1A22F34 	AC 49 A0  1 
1A22F38 	38 2E A2  1 
      then                        (  )
   then                           (  )
;
1A22F3C 	58 46 A0  1 

\ From instance.fth
purpose: Create, destroy, and call package instances

\ Creation and destruction of device instances.  Also package interface words.

headerless
create no-proc  ," Unimplemented package interface procedure"
1A22F40 	6E 6F 2D 70 72 6F 63 87 
1A22F48 	F4 2E A2  1 30 40 A0  1 
1A22F50 	29 55 6E 69 6D 70 6C 65 
1A22F58 	6D 65 6E 74 65 64 20 70 
1A22F60 	61 63 6B 61 67 65 20 69 
1A22F68 	6E 74 65 72 66 61 63 65 
1A22F70 	20 70 72 6F 63 65 64 75 
1A22F78 	72 65  0  0 

headers
defer fm-hook  ( adr len phandle -- adr len phandle )
1A22F7C 	66 6D 2D 68 
1A22F80 	6F 6F 6B 87 4C 2F A2  1 
1A22F88 	5C 40 A0  1 94  6  0  0 
' noop is fm-hook

: find-method  ( adr len phandle -- false | acf true )
1A22F90 	66 69 6E 64 2D 6D 65 74 
1A22F98 	68 6F 64 8B 88 2F A2  1 
1A22FA0 	20 40 A0  1 
   fm-hook  phandle>voc (search-wordlist)
1A22FA4 	88 2F A2  1 
1A22FA8 	58 F8 A1  1  0 BB A0  1 
;
1A22FB0 	58 46 A0  1 

headerless
2variable error-method
1A22FB4 	 0  0  0 65 
1A22FB8 	72 72 6F 72 2D 6D 65 74 
1A22FC0 	68 6F 64 8C A0 2F A2  1 
1A22FC8 	48 40 A0  1 98  6  0  0 
0 value error-instance
1A22FD0 	 0 65 72 72 6F 72 2D 69 
1A22FD8 	6E 73 74 61 6E 63 65 8E 
1A22FE0 	C8 2F A2  1 50 40 A0  1 
1A22FE8 	A0  6  0  0 
0 value error-package	\ Undefined if error-instance is 0
1A22FEC 	 0  0 65 72 
1A22FF0 	72 6F 72 2D 70 61 63 6B 
1A22FF8 	61 67 65 8D E4 2F A2  1 
1A23000 	50 40 A0  1 A4  6  0  0 
headers
: .method  ( -- )
1A23008 	2E 6D 65 74 68 6F 64 87 
1A23010 	 0 30 A2  1 20 40 A0  1 
   ." Method: " error-method 2@ type  ."  Instance: " error-instance u.
1A23018 	20 7C A0  1  8 4D 65 74 
1A23020 	68 6F 64 3A 20  0  0  0 
1A23028 	C8 2F A2  1 CC 4D A0  1 
1A23030 	 4 6C A0  1 20 7C A0  1 
1A23038 	 B 20 49 6E 73 74 61 6E 
1A23040 	63 65 3A 20  0  0  0  0 
1A23048 	E4 2F A2  1 C8 77 A0  1 
   error-instance  if
1A23050 	E4 2F A2  1 DC 41 A0  1 
1A23058 	24  0  0  0 
      ." Package: " error-package push-package (pwd) pop-package
1A2305C 	20 7C A0  1 
1A23060 	 9 50 61 63 6B 61 67 65 
1A23068 	3A 20  0  0  0 30 A2  1 
1A23070 	7C FB A1  1 A0 2B A2  1 
1A23078 	D8 FB A1  1 
   then
   cr
1A2307C 	80 6D A0  1 
;
1A23080 	58 46 A0  1 

headerless
: "open"  " open"  ;
1A23084 	 0 22 6F 70 
1A23088 	65 6E 22 86 14 30 A2  1 
1A23090 	20 40 A0  1 9C 53 A0  1 
1A23098 	 4 6F 70 65 6E  0  0  0 
1A230A0 	58 46 A0  1 

headers
: $call-self  ( adr len -- )
1A230A4 	 0 24 63 61 
1A230A8 	6C 6C 2D 73 65 6C 66 8A 
1A230B0 	90 30 A2  1 20 40 A0  1 
   my-self  if
1A230B8 	EC 7E A0  1 DC 41 A0  1 
1A230C0 	24  0  0  0 
      my-voc  fm-hook phandle>voc $find-word  if  execute  exit  then
1A230C4 	10  4 A2  1 
1A230C8 	88 2F A2  1 58 F8 A1  1 
1A230D0 	D4 BA A0  1 DC 41 A0  1 
1A230D8 	 C  0  0  0 98 41 A0  1 
1A230E0 	40 46 A0  1 
   then
   my-self to error-instance
1A230E4 	EC 7E A0  1 
1A230E8 	B8 40 A0  1 E4 2F A2  1 
   error-instance  if  my-voc  to error-package  then
1A230F0 	E4 2F A2  1 DC 41 A0  1 
1A230F8 	10  0  0  0 10  4 A2  1 
1A23100 	B8 40 A0  1  0 30 A2  1 
   error-method 2! no-proc throw
1A23108 	C8 2F A2  1 E4 4D A0  1 
1A23110 	4C 2F A2  1 74 7F A0  1 
;
1A23118 	58 46 A0  1 

[ifndef] package(
: package(  ( ihandle -- )  r> my-self >r >r  is my-self  ;
1A2311C 	 0  0  0 70 
1A23120 	61 63 6B 61 67 65 28 88 
1A23128 	B4 30 A2  1 20 40 A0  1 
1A23130 	D0 45 A0  1 EC 7E A0  1 
1A23138 	BC 45 A0  1 BC 45 A0  1 
1A23140 	B8 40 A0  1 EC 7E A0  1 
1A23148 	58 46 A0  1 
: )package  ( -- )  r> r> is my-self >r  ;
1A2314C 	 0  0  0 29 
1A23150 	70 61 63 6B 61 67 65 88 
1A23158 	2C 31 A2  1 20 40 A0  1 
1A23160 	D0 45 A0  1 D0 45 A0  1 
1A23168 	B8 40 A0  1 EC 7E A0  1 
1A23170 	BC 45 A0  1 58 46 A0  1 
[then]

: call-package  ( ??? acf ihandle -- ??? )      package( execute    )package  ;
1A23178 	 0  0  0 63 61 6C 6C 2D 
1A23180 	70 61 63 6B 61 67 65 8C 
1A23188 	5C 31 A2  1 20 40 A0  1 
1A23190 	2C 31 A2  1 98 41 A0  1 
1A23198 	5C 31 A2  1 58 46 A0  1 
: $call-method  ( ??? adr len ihandle -- ??? )  package( $call-self )package  ;
1A231A0 	 0  0  0 24 63 61 6C 6C 
1A231A8 	2D 6D 65 74 68 6F 64 8C 
1A231B0 	8C 31 A2  1 20 40 A0  1 
1A231B8 	2C 31 A2  1 B4 30 A2  1 
1A231C0 	5C 31 A2  1 58 46 A0  1 
: $call-parent  ( adr len -- )  my-parent $call-method  ;
1A231C8 	 0  0  0 24 63 61 6C 6C 
1A231D0 	2D 70 61 72 65 6E 74 8C 
1A231D8 	B4 31 A2  1 20 40 A0  1 
1A231E0 	28  4 A2  1 B4 31 A2  1 
1A231E8 	58 46 A0  1 
: ihandle>phandle  ( ihandle -- phandle )       package( my-voc     )package  ;
1A231EC 	69 68 61 6E 
1A231F0 	64 6C 65 3E 70 68 61 6E 
1A231F8 	64 6C 65 8F DC 31 A2  1 
1A23200 	20 40 A0  1 2C 31 A2  1 
1A23208 	10  4 A2  1 5C 31 A2  1 
1A23210 	58 46 A0  1 

headerless
: activate  ( -- )
1A23214 	 0  0  0 61 
1A23218 	63 74 69 76 61 74 65 88 
1A23220 	 0 32 A2  1 20 40 A0  1 
   my-self  if
1A23228 	EC 7E A0  1 DC 41 A0  1 
1A23230 	5C  0  0  0 
      my-self ihandle>phandle
1A23234 	EC 7E A0  1 
1A23238 	 0 32 A2  1 
      ?dup  if  push-package  else  ." Current instance " my-self . ." has 0 phandle!"  cr  then
1A2323C 	B4 70 A0  1 
1A23240 	DC 41 A0  1 10  0  0  0 
1A23248 	7C FB A1  1 C8 41 A0  1 
1A23250 	3C  0  0  0 20 7C A0  1 
1A23258 	11 43 75 72 72 65 6E 74 
1A23260 	20 69 6E 73 74 61 6E 63 
1A23268 	65 20  0  0 EC 7E A0  1 
1A23270 	94 7A A0  1 20 7C A0  1 
1A23278 	 E 68 61 73 20 30 20 70 
1A23280 	68 61 6E 64 6C 65 21  0 
1A23288 	80 6D A0  1 
   then
;
1A2328C 	58 46 A0  1 
: deactivate  ( -- )  my-self  if  pop-package  then  ;
1A23290 	 0 64 65 61 63 74 69 76 
1A23298 	61 74 65 8A 24 32 A2  1 
1A232A0 	20 40 A0  1 EC 7E A0  1 
1A232A8 	DC 41 A0  1  8  0  0  0 
1A232B0 	D8 FB A1  1 58 46 A0  1 

[ifdef] bug
also bug
'   activate to   set-package
' deactivate to unset-package
previous
[then]

headers
: $call-static-method  ( ??? adr len phandle -- ??? )
1A232B8 	24 63 61 6C 6C 2D 73 74 
1A232C0 	61 74 69 63 2D 6D 65 74 
1A232C8 	68 6F 64 93 A0 32 A2  1 
1A232D0 	20 40 A0  1 
   find-method  0=  if  no-proc throw  then  execute
1A232D4 	A0 2F A2  1 
1A232D8 	24 47 A0  1 DC 41 A0  1 
1A232E0 	 C  0  0  0 4C 2F A2  1 
1A232E8 	74 7F A0  1 98 41 A0  1 
;
1A232F0 	58 46 A0  1 

\ set-args is executed only during probing, at which time the active package
\ corresponds to the current instance, thus '#adr-cells can be executed
\ directly.

: set-args  ( arg-str reg-str -- )
1A232F4 	 0  0  0 73 
1A232F8 	65 74 2D 61 72 67 73 88 
1A23300 	D0 32 A2  1 20 40 A0  1 
   " decode-unit" $call-parent  '#adr-cells @  ( arg-str phys .. #cells )
1A23308 	9C 53 A0  1  B 64 65 63 
1A23310 	6F 64 65 2D 75 6E 69 74 
1A23318 	 0  0  0  0 DC 31 A2  1 
1A23320 	4C FA A1  1 5C 4C A0  1 
   dup  if  swap  to my-space  1-   then       ( arg-str phys .. #cells' )
1A23328 	40 49 A0  1 DC 41 A0  1 
1A23330 	14  0  0  0 68 49 A0  1 
1A23338 	48 B8 A1  1 AC  3 A2  1 
1A23340 	54 4B A0  1 
   addr my-adr0  swap /n* bounds  ?do  i !  /n +loop   ( arg-str )
1A23344 	5C B8 A1  1 
1A23348 	6C  3 A2  1 68 49 A0  1 
1A23350 	98 51 A0  1 F0 6D A0  1 
1A23358 	50 42 A0  1 18  0  0  0 
1A23360 	B4 42 A0  1 54 4D A0  1 
1A23368 	40 51 A0  1 1C 42 A0  1 
1A23370 	F0 FF FF FF 
   copy-args
1A23374 	10  8 A2  1 
;
1A23378 	58 46 A0  1 

: get-package-property  ( adr len phandle -- true | adr' len' false )
1A2337C 	 0  0  0 67 
1A23380 	65 74 2D 70 61 63 6B 61 
1A23388 	67 65 2D 70 72 6F 70 65 
1A23390 	72 74 79 94  4 33 A2  1 
1A23398 	20 40 A0  1 
   (push-package)  get-property  (pop-package)
1A2339C 	38 FB A1  1 
1A233A0 	F4  D A2  1 5C FB A1  1 
;
1A233A8 	58 46 A0  1 

\ XXX - I think this could be implemented by   (push-package) (property) (pop-package)
: set-package-property  ( value$ name$ phandle -- )
1A233AC 	 0  0  0 73 
1A233B0 	65 74 2D 70 61 63 6B 61 
1A233B8 	67 65 2D 70 72 6F 70 65 
1A233C0 	72 74 79 94 98 33 A2  1 
1A233C8 	20 40 A0  1 
   current token@ >r  context token@ >r   (select-package)  ( value$ name$ )
1A233CC 	F0 A3 A0  1 
1A233D0 	 C 54 A0  1 BC 45 A0  1 
1A233D8 	DC A3 A0  1  C 54 A0  1 
1A233E0 	BC 45 A0  1 14 FB A1  1 
   (property)
1A233E8 	24 14 A2  1 
   r> context token!  r> current token!
1A233EC 	D0 45 A0  1 
1A233F0 	DC A3 A0  1 20 54 A0  1 
1A233F8 	D0 45 A0  1 F0 A3 A0  1 
1A23400 	20 54 A0  1 
;
1A23404 	58 46 A0  1 

\ Used when executing from an open package instance.  Finds a property
\ associated with the current package.
: get-my-property  ( adr len -- true | adr' len' false )
1A23408 	67 65 74 2D 6D 79 2D 70 
1A23410 	72 6F 70 65 72 74 79 8F 
1A23418 	C8 33 A2  1 20 40 A0  1 
   my-voc get-package-property
1A23420 	10  4 A2  1 98 33 A2  1 
;
1A23428 	58 46 A0  1 

headerless
0 value interposer	\ phandle of interposing package, if any
1A2342C 	 0 69 6E 74 
1A23430 	65 72 70 6F 73 65 72 8A 
1A23438 	1C 34 A2  1 50 40 A0  1 
1A23440 	A8  6  0  0 
0 value ip-arg-adr	\ arguments for interposing package
1A23444 	 0 69 70 2D 
1A23448 	61 72 67 2D 61 64 72 8A 
1A23450 	3C 34 A2  1 50 40 A0  1 
1A23458 	AC  6  0  0 
0 value ip-arg-len
1A2345C 	 0 69 70 2D 
1A23460 	61 72 67 2D 6C 65 6E 8A 
1A23468 	54 34 A2  1 50 40 A0  1 
1A23470 	B0  6  0  0 

false value pkg-interpose?	\ phandle of interposing package, if any
1A23474 	 0 70 6B 67 
1A23478 	2D 69 6E 74 65 72 70 6F 
1A23480 	73 65 3F 8E 6C 34 A2  1 
1A23488 	50 40 A0  1 B4  6  0  0 

: interposed?  ( -- false | arg$ phandle true )
1A23490 	69 6E 74 65 72 70 6F 73 
1A23498 	65 64 3F 8B 88 34 A2  1 
1A234A0 	20 40 A0  1 
   interposer  if
1A234A4 	3C 34 A2  1 
1A234A8 	DC 41 A0  1 34  0  0  0 
      false to pkg-interpose?
1A234B0 	18 70 A0  1 B8 40 A0  1 
1A234B8 	88 34 A2  1 
      ip-arg-adr ip-arg-len  interposer  0 to interposer  true
1A234BC 	54 34 A2  1 
1A234C0 	6C 34 A2  1 3C 34 A2  1 
1A234C8 	70 6F A0  1 B8 40 A0  1 
1A234D0 	3C 34 A2  1  4 70 A0  1 
   else
1A234D8 	C8 41 A0  1  8  0  0  0 
      false
1A234E0 	18 70 A0  1 
   then
;
1A234E4 	58 46 A0  1 

\ 0 value pip-arg-adr	\ arguments for interposing package
\ 0 value pip-arg-len

: package-interposed?  ( -- false | arg$ phandle true )
1A234E8 	70 61 63 6B 61 67 65 2D 
1A234F0 	69 6E 74 65 72 70 6F 73 
1A234F8 	65 64 3F 93 A0 34 A2  1 
1A23500 	20 40 A0  1 
   pkg-interpose?  if  interposed?  else  false  then
1A23504 	88 34 A2  1 
1A23508 	DC 41 A0  1 10  0  0  0 
1A23510 	A0 34 A2  1 C8 41 A0  1 
1A23518 	 8  0  0  0 18 70 A0  1 
;
1A23520 	58 46 A0  1 

headers
: interpose  ( args$ phandle -- )
1A23524 	 0  0 69 6E 
1A23528 	74 65 72 70 6F 73 65 89 
1A23530 	 0 35 A2  1 20 40 A0  1 
   false to pkg-interpose?
1A23538 	18 70 A0  1 B8 40 A0  1 
1A23540 	88 34 A2  1 
   to interposer  to ip-arg-len  to ip-arg-adr
1A23544 	B8 40 A0  1 
1A23548 	3C 34 A2  1 B8 40 A0  1 
1A23550 	6C 34 A2  1 B8 40 A0  1 
1A23558 	54 34 A2  1 
;
1A2355C 	58 46 A0  1 
: package-interpose  ( args$ phandle -- )
1A23560 	 0  0 70 61 63 6B 61 67 
1A23568 	65 2D 69 6E 74 65 72 70 
1A23570 	6F 73 65 91 34 35 A2  1 
1A23578 	20 40 A0  1 
   interpose
1A2357C 	34 35 A2  1 
   true to pkg-interpose?
1A23580 	 4 70 A0  1 B8 40 A0  1 
1A23588 	88 34 A2  1 
;
1A2358C 	58 46 A0  1 

headerless
\ Internal factor of get-inherited-property.  This factoring is necessary
\ because we use "exit" to make the control flow easier.
: (get-any)   ( adr len -- true | adr' len' false )
1A23590 	 0  0 28 67 65 74 2D 61 
1A23598 	6E 79 29 89 78 35 A2  1 
1A235A0 	20 40 A0  1 
   begin  my-self   while            ( adr len )  \ Search up parent chain
1A235A4 	EC 7E A0  1 
1A235A8 	DC 41 A0  1 4C  0  0  0 
      my-voc phandle>voc current token!         ( adr len )
1A235B0 	10  4 A2  1 58 F8 A1  1 
1A235B8 	F0 A3 A0  1 20 54 A0  1 
      2dup get-my-property  0=  if   ( adr len adr' len' )
1A235C0 	C0 49 A0  1 1C 34 A2  1 
1A235C8 	24 47 A0  1 DC 41 A0  1 
1A235D0 	14  0  0  0 
         2swap 2drop false exit      ( adr' len' false )   \ Found
1A235D4 	F4 49 A0  1 
1A235D8 	AC 49 A0  1 18 70 A0  1 
1A235E0 	40 46 A0  1 
      then                           ( adr len )
      my-parent is my-self           ( adr len )
1A235E4 	28  4 A2  1 
1A235E8 	B8 40 A0  1 EC 7E A0  1 
   repeat                            ( adr len )
1A235F0 	C8 41 A0  1 B0 FF FF FF 
   2drop true                        ( true )              \ Not found
1A235F8 	AC 49 A0  1  4 70 A0  1 
;
1A23600 	58 46 A0  1 

headers
\ Finds a property associated with the current package or with one of
\ its parents.
: get-inherited-property  ( adr len -- true | adr' len' false )
1A23604 	 0 67 65 74 
1A23608 	2D 69 6E 68 65 72 69 74 
1A23610 	65 64 2D 70 72 6F 70 65 
1A23618 	72 74 79 96 A0 35 A2  1 
1A23620 	20 40 A0  1 
   current token@ >r   my-self >r
1A23624 	F0 A3 A0  1 
1A23628 	 C 54 A0  1 BC 45 A0  1 
1A23630 	EC 7E A0  1 BC 45 A0  1 
   (get-any)
1A23638 	A0 35 A2  1 
   r> is my-self  r> current token!
1A2363C 	D0 45 A0  1 
1A23640 	B8 40 A0  1 EC 7E A0  1 
1A23648 	D0 45 A0  1 F0 A3 A0  1 
1A23650 	20 54 A0  1 
;
1A23654 	58 46 A0  1 

headerless
: ?close  ( -- )  " close"  ['] $call-self  catch  if  2drop  then  ;
1A23658 	 0 3F 63 6C 6F 73 65 86 
1A23660 	20 36 A2  1 20 40 A0  1 
1A23668 	9C 53 A0  1  5 63 6C 6F 
1A23670 	73 65  0  0 60 53 A0  1 
1A23678 	B4 30 A2  1 14 7F A0  1 
1A23680 	DC 41 A0  1  8  0  0  0 
1A23688 	AC 49 A0  1 58 46 A0  1 
headers
\ Close all the instances up the chain from ihandle to my-self.
\ This assumes that close-package is called from the same instance
\ from which open-package was called.  The reason for closing a
\ chain, instead of just one instance, is because open-package
\ could have created a chain as a result of interposition.
: close-package  ( ihandle -- )
1A23690 	 0  0 63 6C 6F 73 65 2D 
1A23698 	70 61 63 6B 61 67 65 8D 
1A236A0 	64 36 A2  1 20 40 A0  1 
   my-self  swap to my-self             ( end-ihandle )
1A236A8 	EC 7E A0  1 68 49 A0  1 
1A236B0 	B8 40 A0  1 EC 7E A0  1 
   begin                                ( end-ihandle )
      dup my-self <>  my-self 0<>  and  ( end-ihandle more? )
1A236B8 	40 49 A0  1 EC 7E A0  1 
1A236C0 	44 48 A0  1 EC 7E A0  1 
1A236C8 	44 47 A0  1 5C 44 A0  1 
   while                                ( end-ihandle )
1A236D0 	DC 41 A0  1 14  0  0  0 
      ?close                            ( end-ihandle )
1A236D8 	64 36 A2  1 
      destroy-instance                  ( end-ihandle )
1A236DC 	38  9 A2  1 
      \ destroy-instance sets my-self to the parent ihandle
   repeat                               ( end-ihandle )
1A236E0 	C8 41 A0  1 D4 FF FF FF 
   to my-self                           ( ) \ In case we bailed on a 0 ihandle
1A236E8 	B8 40 A0  1 EC 7E A0  1 
;
1A236F0 	58 46 A0  1 
headerless
: close-parents  ( -- )
1A236F4 	 0  0 63 6C 
1A236F8 	6F 73 65 2D 70 61 72 65 
1A23700 	6E 74 73 8D A4 36 A2  1 
1A23708 	20 40 A0  1 
   begin  my-self  while  ?close destroy-instance  repeat
1A2370C 	EC 7E A0  1 
1A23710 	DC 41 A0  1 14  0  0  0 
1A23718 	64 36 A2  1 38  9 A2  1 
1A23720 	C8 41 A0  1 E8 FF FF FF 
;
1A23728 	58 46 A0  1 
: close-chain  ( -- )  destroy-instance  close-parents  ;
1A2372C 	63 6C 6F 73 
1A23730 	65 2D 63 68 61 69 6E 8B 
1A23738 	 8 37 A2  1 20 40 A0  1 
1A23740 	38  9 A2  1  8 37 A2  1 
1A23748 	58 46 A0  1 
headers
: close-dev  ( ihandle -- )  package(  close-parents  )package  ;
1A2374C 	 0  0 63 6C 
1A23750 	6F 73 65 2D 64 65 76 89 
1A23758 	3C 37 A2  1 20 40 A0  1 
1A23760 	2C 31 A2  1  8 37 A2  1 
1A23768 	5C 31 A2  1 58 46 A0  1 

: parse/  ( $ -- head$ tail$ )  ascii /  left-parse-string  ;
1A23770 	 0 70 61 72 73 65 2F 86 
1A23778 	5C 37 A2  1 20 40 A0  1 
1A23780 	58 41 A0  1 2F  0  0  0 
1A23788 	44 D7 A0  1 58 46 A0  1 
: parse:  ( $ -- head$ tail$ )  ascii :  left-parse-string  ;
1A23790 	 0 70 61 72 73 65 3A 86 
1A23798 	7C 37 A2  1 20 40 A0  1 
1A237A0 	58 41 A0  1 3A  0  0  0 
1A237A8 	44 D7 A0  1 58 46 A0  1 
\ Extract the next (leftmost) component from the path name, updating the
\ path variable to reflect the remainder of the path after the extracted
\ component.
: parse-component  ( path$ first? -- path$ args$ devname$ package? )
1A237B0 	70 61 72 73 65 2D 63 6F 
1A237B8 	6D 70 6F 6E 65 6E 74 8F 
1A237C0 	9C 37 A2  1 20 40 A0  1 
   >r                             ( path$' component$ r: first? )
1A237C8 	BC 45 A0  1 
   parse/                         ( path$' component$ r: first? )
1A237CC 	7C 37 A2  1 
   dup 0=  if                     ( path$' component$ r: first? )
1A237D0 	40 49 A0  1 24 47 A0  1 
1A237D8 	DC 41 A0  1 9C  0  0  0 
      \ The first character was a slash, so it's either the root node
      \ or a support package
      2drop                       ( path$' r: first? )
1A237E0 	AC 49 A0  1 
      r@  if                      ( path$' r: first? )
1A237E4 	E4 45 A0  1 
1A237E8 	DC 41 A0  1 78  0  0  0 
         \ This is the first path component, so it could be either
         \ the root node or a support package
         dup  if
1A237F0 	40 49 A0  1 DC 41 A0  1 
1A237F8 	50  0  0  0 
            \ The rest of the string is not empty, so it could be either ...
	    2dup parse/           ( path$' tail$ head$ r: first? )
1A237FC 	C0 49 A0  1 
1A23800 	7C 37 A2  1 
	    nip  if               ( path$' tail$ r: first? )
1A23804 	FC 46 A0  1 
1A23808 	DC 41 A0  1 24  0  0  0 
	       \ The next character was not a slash, so it must be the root.
	       \ Undo the last parse and return the root node specification.
	       2drop              ( path$' r: first? )
1A23810 	AC 49 A0  1 
	       " "  " /" false    ( path$' args$ devname$ package? r: first? )
1A23814 	9C 53 A0  1 
1A23818 	 0  0  0  0 9C 53 A0  1 
1A23820 	 1 2F  0  0 18 70 A0  1 
	    else                  ( path$' tail$ r: first? )
1A23828 	C8 41 A0  1 14  0  0  0 
	       \ The next character was a slash, so it's a support package.
	       \ tail$ is path$ minus that slash, i.e. the new path$
	       2nip               ( path$'' r: first? )
1A23830 	 8 6A A0  1 
	       parse/             ( path$' component$ r: first? )
1A23834 	7C 37 A2  1 
	       parse:  true       ( path$ args$ devname$ package? )
1A23838 	9C 37 A2  1  4 70 A0  1 
	    then
         else
1A23840 	C8 41 A0  1 18  0  0  0 
            \ The rest of the string was empty, so it must be the root.
            " "  " /" false       ( path$' args$ devname$ package? r: first? )
1A23848 	9C 53 A0  1  0  0  0  0 
1A23850 	9C 53 A0  1  1 2F  0  0 
1A23858 	18 70 A0  1 
         then
      else                        ( path$' r: first? )
1A2385C 	C8 41 A0  1 
1A23860 	10  0  0  0 
         \ This is not the first path component, so it
         \ must be a support package
         parse/                   ( path$' component$ r: first? )
1A23864 	7C 37 A2  1 
         parse:  true             ( path$ args$ devname$ package? )
1A23868 	9C 37 A2  1  4 70 A0  1 
      then
   else
1A23870 	C8 41 A0  1  C  0  0  0 
      \ The first character was not a slash, so the component is an
      \ ordinary device node
      parse:  false               ( path$ args$ devname$ package? )
1A23878 	9C 37 A2  1 18 70 A0  1 
   then
   r> drop
1A23880 	D0 45 A0  1 30 49 A0  1 
;
1A23888 	58 46 A0  1 

: apply-method  ( adr len -- no-such-method? )
1A2388C 	 0  0  0 61 
1A23890 	70 70 6C 79 2D 6D 65 74 
1A23898 	68 6F 64 8C C4 37 A2  1 
1A238A0 	20 40 A0  1 
   my-voc fm-hook  ['] $package-execute?  catch  ?dup  if  ( x x x errno )
1A238A4 	10  4 A2  1 
1A238A8 	88 2F A2  1 60 53 A0  1 
1A238B0 	94  D A2  1 14 7F A0  1 
1A238B8 	B4 70 A0  1 DC 41 A0  1 
1A238C0 	10  0  0  0 
      \ executing method caused an error
      nip nip nip                                   ( errno )
1A238C4 	FC 46 A0  1 
1A238C8 	FC 46 A0  1 FC 46 A0  1 
   then                                             ( ??? false | true | errno )
;
1A238D0 	58 46 A0  1 

headerless

d# 64 buffer: package-name-buf
1A238D4 	 0  0  0 70 
1A238D8 	61 63 6B 61 67 65 2D 6E 
1A238E0 	61 6D 65 2D 62 75 66 90 
1A238E8 	A0 38 A2  1 B4 A9 A0  1 
1A238F0 	B8  6  0  0 40  0  0  0 
1A238F8 	94 1D A2  1 

headers
: open-package  ( args$ phandle -- ihandle )  recursive
1A238FC 	 0  0  0 6F 
1A23900 	70 65 6E 2D 70 61 63 6B 
1A23908 	61 67 65 8C EC 38 A2  1 
1A23910 	20 40 A0  1 
   push-package                              ( args$ )
1A23914 	7C FB A1  1 
   new-instance                              ( )
1A23918 	9C  8 A2  1 
   "open" apply-method  if  false  then  if  ( )
1A2391C 	90 30 A2  1 
1A23920 	A0 38 A2  1 DC 41 A0  1 
1A23928 	 8  0  0  0 18 70 A0  1 
1A23930 	DC 41 A0  1 48  0  0  0 
      package-interposed?  if                ( arg$ phandle )
1A23938 	 0 35 A2  1 DC 41 A0  1 
1A23940 	24  0  0  0 
         open-package                        ( ihandle|0 )
1A23944 	10 39 A2  1 
         dup  0=  if  destroy-instance  then ( )
1A23948 	40 49 A0  1 24 47 A0  1 
1A23950 	DC 41 A0  1  8  0  0  0 
1A23958 	38  9 A2  1 
      else                                   ( )
1A2395C 	C8 41 A0  1 
1A23960 	14  0  0  0 
         my-self  my-parent is my-self       ( ihandle )
1A23964 	EC 7E A0  1 
1A23968 	28  4 A2  1 B8 40 A0  1 
1A23970 	EC 7E A0  1 
      then                                   ( )
   else                                      ( )
1A23974 	C8 41 A0  1 
1A23978 	 C  0  0  0 
      destroy-instance  0                    ( 0 )
1A2397C 	38  9 A2  1 
1A23980 	70 6F A0  1 
   then                                      ( ihandle )
   pop-package                               ( ihandle )
1A23984 	D8 FB A1  1 
;
1A23988 	58 46 A0  1 

defer load-package  ( name$ -- false  |  phandle true )
1A2398C 	 0  0  0 6C 
1A23990 	6F 61 64 2D 70 61 63 6B 
1A23998 	61 67 65 8C 10 39 A2  1 
1A239A0 	5C 40 A0  1 BC  6  0  0 
: no-load-package   ( name$ -- false )  2drop false  ;
1A239A8 	6E 6F 2D 6C 6F 61 64 2D 
1A239B0 	70 61 63 6B 61 67 65 8F 
1A239B8 	A0 39 A2  1 20 40 A0  1 
1A239C0 	AC 49 A0  1 18 70 A0  1 
1A239C8 	58 46 A0  1 
' no-load-package is load-package

: find-package  ( name$ -- false  |  phandle true )
1A239CC 	 0  0  0 66 
1A239D0 	69 6E 64 2D 70 61 63 6B 
1A239D8 	61 67 65 8C BC 39 A2  1 
1A239E0 	20 40 A0  1 
   dup 0=  if  true  else  over c@  ascii / <>  then  ( name$ relative? )
1A239E4 	40 49 A0  1 
1A239E8 	24 47 A0  1 DC 41 A0  1 
1A239F0 	10  0  0  0  4 70 A0  1 
1A239F8 	C8 41 A0  1 18  0  0  0 
1A23A00 	54 49 A0  1 C4 4C A0  1 
1A23A08 	58 41 A0  1 2F  0  0  0 
1A23A10 	44 48 A0  1 
   if                                                 ( name$ )
1A23A14 	DC 41 A0  1 
1A23A18 	28  0  0  0 
      " /packages/" package-name-buf pack  $cat       ( )
1A23A1C 	9C 53 A0  1 
1A23A20 	 A 2F 70 61 63 6B 61 67 
1A23A28 	65 73 2F  0 EC 38 A2  1 
1A23A30 	DC 52 A0  1 84 7E A0  1 
      package-name-buf count                          ( name$' )
1A23A38 	EC 38 A2  1 BC 53 A0  1 
   then                                               ( name$' )
   2dup locate-device  if                             ( name$ )
1A23A40 	C0 49 A0  1 EC 21 A2  1 
1A23A48 	DC 41 A0  1 10  0  0  0 
      load-package                                    ( false | phandle true )
1A23A50 	A0 39 A2  1 
   else                                               ( name$ phandle )
1A23A54 	C8 41 A0  1 
1A23A58 	10  0  0  0 
      nip nip true                                    ( phandle true )
1A23A5C 	FC 46 A0  1 
1A23A60 	FC 46 A0  1  4 70 A0  1 
   then                                               ( false | phandle true )
;
1A23A68 	58 46 A0  1 

: $open-package  ( arg$ name$ -- ihandle )
1A23A6C 	 0  0 24 6F 
1A23A70 	70 65 6E 2D 70 61 63 6B 
1A23A78 	61 67 65 8D E0 39 A2  1 
1A23A80 	20 40 A0  1 
   find-package  if  open-package  else  2drop 0  then
1A23A84 	E0 39 A2  1 
1A23A88 	DC 41 A0  1 10  0  0  0 
1A23A90 	10 39 A2  1 C8 41 A0  1 
1A23A98 	 C  0  0  0 AC 49 A0  1 
1A23AA0 	70 6F A0  1 
;
1A23AA4 	58 46 A0  1 

: $delete-package  ( adr len -- )
1A23AA8 	24 64 65 6C 65 74 65 2D 
1A23AB0 	70 61 63 6B 61 67 65 8F 
1A23AB8 	80 3A A2  1 20 40 A0  1 
   locate-device abort" Can't find package" delete-package
1A23AC0 	EC 21 A2  1  8 81 A0  1 
1A23AC8 	12 43 61 6E 27 74 20 66 
1A23AD0 	69 6E 64 20 70 61 63 6B 
1A23AD8 	61 67 65  0 78 12 A2  1 
;
1A23AE0 	58 46 A0  1 

headers

: my-unit-bounds  ( -- end-adr start-adr )
1A23AE4 	 0 6D 79 2D 
1A23AE8 	75 6E 69 74 2D 62 6F 75 
1A23AF0 	6E 64 73 8E BC 3A A2  1 
1A23AF8 	20 40 A0  1 
   addr my-unit-low  '#adr-cells @ /n*  bounds
1A23AFC 	5C B8 A1  1 
1A23B00 	B8  4 A2  1 4C FA A1  1 
1A23B08 	5C 4C A0  1 98 51 A0  1 
1A23B10 	F0 6D A0  1 
;
1A23B14 	58 46 A0  1 
: set-my-unit  ( phys.hi .. phys.lo -- )
1A23B18 	73 65 74 2D 6D 79 2D 75 
1A23B20 	6E 69 74 8B F8 3A A2  1 
1A23B28 	20 40 A0  1 
   my-unit-bounds  ?do  i !  /n +loop
1A23B2C 	F8 3A A2  1 
1A23B30 	50 42 A0  1 18  0  0  0 
1A23B38 	B4 42 A0  1 54 4D A0  1 
1A23B40 	40 51 A0  1 1C 42 A0  1 
1A23B48 	F0 FF FF FF 
;
1A23B4C 	58 46 A0  1 

: set-default-unit  ( -- )
1A23B50 	 0  0  0 73 65 74 2D 64 
1A23B58 	65 66 61 75 6C 74 2D 75 
1A23B60 	6E 69 74 90 28 3B A2  1 
1A23B68 	20 40 A0  1 
   get-unit  if                         ( )
1A23B6C 	90 15 A2  1 
1A23B70 	DC 41 A0  1 2C  0  0  0 
      '#adr-cells @  0  ?do  0  loop    ( phys.. )
1A23B78 	4C FA A1  1 5C 4C A0  1 
1A23B80 	70 6F A0  1 50 42 A0  1 
1A23B88 	10  0  0  0 70 6F A0  1 
1A23B90 	F8 41 A0  1 F8 FF FF FF 
   else                                 ( adr len )
1A23B98 	C8 41 A0  1  8  0  0  0 
      unit-str>phys-                    ( phys.. )
1A23BA0 	BC 15 A2  1 
   then                                 ( phys.. )
   set-my-unit                          ( )
1A23BA4 	28 3B A2  1 
;
1A23BA8 	58 46 A0  1 

\ Set the my-unit fields in the instance record:
\ If an address was given in path component, use it
\ If not, use address in "reg" property of package
\ Otherwise, use 0,0
: set-instance-address  ( -- )
1A23BAC 	 0  0  0 73 
1A23BB0 	65 74 2D 69 6E 73 74 61 
1A23BB8 	6E 63 65 2D 61 64 64 72 
1A23BC0 	65 73 73 94 68 3B A2  1 
1A23BC8 	20 40 A0  1 
   unit#-valid?  if
1A23BCC 	40 18 A2  1 
1A23BD0 	DC 41 A0  1 30  0  0  0 
      unit-bounds  ?do  i @  /n +loop  set-my-unit
1A23BD8 	58 18 A2  1 50 42 A0  1 
1A23BE0 	18  0  0  0 B4 42 A0  1 
1A23BE8 	5C 4C A0  1 40 51 A0  1 
1A23BF0 	1C 42 A0  1 F0 FF FF FF 
1A23BF8 	28 3B A2  1 
   else
1A23BFC 	C8 41 A0  1 
1A23C00 	 8  0  0  0 
      set-default-unit
1A23C04 	68 3B A2  1 
   then
;
1A23C08 	58 46 A0  1 

headerless
: (apply-method)  ( adr len -- ??? )
1A23C0C 	 0 28 61 70 
1A23C10 	70 6C 79 2D 6D 65 74 68 
1A23C18 	6F 64 29 8E C8 3B A2  1 
1A23C20 	20 40 A0  1 
   apply-method  if  close-chain no-proc throw  then    ( )
1A23C24 	A0 38 A2  1 
1A23C28 	DC 41 A0  1 10  0  0  0 
1A23C30 	3C 37 A2  1 4C 2F A2  1 
1A23C38 	74 7F A0  1 
;
1A23C3C 	58 46 A0  1 
: (open-node)  ( -- )
1A23C40 	28 6F 70 65 6E 2D 6E 6F 
1A23C48 	64 65 29 8B 20 3C A2  1 
1A23C50 	20 40 A0  1 
   "open"  (apply-method)  0=  if          ( okay? )
1A23C54 	90 30 A2  1 
1A23C58 	20 3C A2  1 24 47 A0  1 
1A23C60 	DC 41 A0  1 20  0  0  0 
      close-chain  true abort" open failed" ( )
1A23C68 	3C 37 A2  1  4 70 A0  1 
1A23C70 	 8 81 A0  1  B 6F 70 65 
1A23C78 	6E 20 66 61 69 6C 65 64 
1A23C80 	 0  0  0  0 
   then
;
1A23C84 	58 46 A0  1 
: open-node  ( -- ) recursive
1A23C88 	 0  0 6F 70 65 6E 2D 6E 
1A23C90 	6F 64 65 89 50 3C A2  1 
1A23C98 	20 40 A0  1 
   (open-node)
1A23C9C 	50 3C A2  1 
   interposed?  if                              ( arg$ phandle )
1A23CA0 	A0 34 A2  1 DC 41 A0  1 
1A23CA8 	20  0  0  0 
      push-package  new-instance  ['] open-node catch  pop-package  ( error? )
1A23CAC 	7C FB A1  1 
1A23CB0 	9C  8 A2  1 60 53 A0  1 
1A23CB8 	98 3C A2  1 14 7F A0  1 
1A23CC0 	D8 FB A1  1 
      throw
1A23CC4 	74 7F A0  1 
   then
;
1A23CC8 	58 46 A0  1 

: open-parents  ( parent-phandle end-phandle -- )   recursive
1A23CCC 	 0  0  0 6F 
1A23CD0 	70 65 6E 2D 70 61 72 65 
1A23CD8 	6E 74 73 8C 98 3C A2  1 
1A23CE0 	20 40 A0  1 
   \ Exit at null "parent" of root node
   2dup =  if  2drop exit  then
1A23CE4 	C0 49 A0  1 
1A23CE8 	24 48 A0  1 DC 41 A0  1 
1A23CF0 	 C  0  0  0 AC 49 A0  1 
1A23CF8 	40 46 A0  1 

   over >parent swap  open-parents  ( phandle )
1A23CFC 	54 49 A0  1 
1A23D00 	C0 FA A1  1 68 49 A0  1 
1A23D08 	E0 3C A2  1 

   push-device                      (  )
1A23D0C 	F8 FB A1  1 
   " "  new-instance                (  )
1A23D10 	9C 53 A0  1  0  0  0  0 
1A23D18 	9C  8 A2  1 
   set-default-unit                 (  )
1A23D1C 	68 3B A2  1 
   open-node                        (  )
1A23D20 	98 3C A2  1 
;
1A23D24 	58 46 A0  1 

\ Open packages between, but not including, "phandle" and the active package
: select-node  ( path$ first? -- path$' )
1A23D28 	73 65 6C 65 63 74 2D 6E 
1A23D30 	6F 64 65 8B E0 3C A2  1 
1A23D38 	20 40 A0  1 
   current-device >r                        ( path$ first? )
1A23D3C 	40 F9 A1  1 
1A23D40 	BC 45 A0  1 
   parse-component  if                      ( path$ args$ devname$ )
1A23D44 	C4 37 A2  1 
1A23D48 	DC 41 A0  1 28  0  0  0 
      \ The path component is a support package
      find-package 0= throw                 ( path$ args$ my-phandle )
1A23D50 	E0 39 A2  1 24 47 A0  1 
1A23D58 	74 7F A0  1 
      push-device                           ( path$ args$ )
1A23D5C 	F8 FB A1  1 
      new-instance                          ( path$ )
1A23D60 	9C  8 A2  1 
      r> push-device                        ( path$ )
1A23D64 	D0 45 A0  1 
1A23D68 	F8 FB A1  1 
   else                                     ( path$ args$ devname$ )
1A23D6C 	C8 41 A0  1 
1A23D70 	40  0  0  0 
      \ The path component is an ordinary device node or the root node
      ['] noa-find-device  catch  ?dup  if  ( path$ args$ x x throw-code )
1A23D74 	60 53 A0  1 
1A23D78 	40 22 A2  1 14 7F A0  1 
1A23D80 	B4 70 A0  1 DC 41 A0  1 
1A23D88 	 C  0  0  0 
         close-parents  throw
1A23D8C 	 8 37 A2  1 
1A23D90 	74 7F A0  1 
      then                                  ( path$ args$ )
      current-device  parent-device  r> open-parents ( path$ args$ my-phandle )
1A23D94 	40 F9 A1  1 
1A23D98 	EC FA A1  1 D0 45 A0  1 
1A23DA0 	E0 3C A2  1 
      push-device                           ( path$ args$ )
1A23DA4 	F8 FB A1  1 
      new-instance                          ( path$ )
1A23DA8 	9C  8 A2  1 
      set-instance-address                  ( path$ )
1A23DAC 	C8 3B A2  1 
   then
;
1A23DB0 	58 46 A0  1 

: (open-path)  ( path$ -- )
1A23DB4 	28 6F 70 65 
1A23DB8 	6E 2D 70 61 74 68 29 8B 
1A23DC0 	38 3D A2  1 20 40 A0  1 
   0 to interposer
1A23DC8 	70 6F A0  1 B8 40 A0  1 
1A23DD0 	3C 34 A2  1 
   ?expand-alias  true select-node                          ( path$ )
1A23DD4 	CC 1F A2  1 
1A23DD8 	 4 70 A0  1 38 3D A2  1 
   begin  dup  while  open-node false select-node  repeat   ( path$' )
1A23DE0 	40 49 A0  1 DC 41 A0  1 
1A23DE8 	18  0  0  0 98 3C A2  1 
1A23DF0 	18 70 A0  1 38 3D A2  1 
1A23DF8 	C8 41 A0  1 E4 FF FF FF 
   2drop                                                    ( )
1A23E00 	AC 49 A0  1 
;
1A23E04 	58 46 A0  1 
\ Open pathname components until the last one, and then apply the indicated
\ method to the last component.
: open-path  ( path$ -- )
1A23E08 	 0  0 6F 70 65 6E 2D 70 
1A23E10 	61 74 68 89 C4 3D A2  1 
1A23E18 	20 40 A0  1 
   ?dup  if                                              ( path$ )
1A23E1C 	B4 70 A0  1 
1A23E20 	DC 41 A0  1 48  0  0  0 
      \ Establish the initial parent
      also						 ( path$ )	
1A23E28 	C8 C1 A0  1 
      dt-null to current-device                          ( path$ )
1A23E2C 	6C F8 A1  1 
1A23E30 	48 B8 A1  1 40 F9 A1  1 
      ['] (open-path) catch  dup  if  nip nip  then      ( error? )
1A23E38 	60 53 A0  1 C4 3D A2  1 
1A23E40 	14 7F A0  1 40 49 A0  1 
1A23E48 	DC 41 A0  1  C  0  0  0 
1A23E50 	FC 46 A0  1 FC 46 A0  1 
      previous definitions                               ( error? )
1A23E58 	E4 C3 A0  1 2C C4 A0  1 
      throw                                              ( )
1A23E60 	74 7F A0  1 
   else                                                  ( adr )
1A23E64 	C8 41 A0  1 
1A23E68 	 C  0  0  0 
      not-found throw                                    (  )
1A23E6C 	90 16 A2  1 
1A23E70 	74 7F A0  1 
   then                                                  (  )
;
1A23E74 	58 46 A0  1 

headers

: begin-open-dev  ( path$ -- ihandle )
1A23E78 	 0 62 65 67 69 6E 2D 6F 
1A23E80 	70 65 6E 2D 64 65 76 8E 
1A23E88 	18 3E A2  1 20 40 A0  1 
   0 package(  current-device >r
1A23E90 	70 6F A0  1 2C 31 A2  1 
1A23E98 	40 F9 A1  1 BC 45 A0  1 

      \ Since "catch/throw" saves and restores my-self,
      \ my-self will be 0 if a throw occurred.

      ['] open-path catch  if  2drop  then
1A23EA0 	60 53 A0  1 18 3E A2  1 
1A23EA8 	14 7F A0  1 DC 41 A0  1 
1A23EB0 	 8  0  0  0 AC 49 A0  1 
      my-self                                   ( ihandle )
1A23EB8 	EC 7E A0  1 

   r> push-device  )package                     ( ihandle )
1A23EBC 	D0 45 A0  1 
1A23EC0 	F8 FB A1  1 5C 31 A2  1 
;
1A23EC8 	58 46 A0  1 

headerless

: (open-dev)  ( path$ -- )  open-path  open-node  ;
1A23ECC 	 0 28 6F 70 
1A23ED0 	65 6E 2D 64 65 76 29 8A 
1A23ED8 	8C 3E A2  1 20 40 A0  1 
1A23EE0 	18 3E A2  1 98 3C A2  1 
1A23EE8 	58 46 A0  1 

headers

: open-dev  ( adr len -- ihandle | 0 )
1A23EEC 	 0  0  0 6F 
1A23EF0 	70 65 6E 2D 64 65 76 88 
1A23EF8 	DC 3E A2  1 20 40 A0  1 
   0 package(  current-device >r
1A23F00 	70 6F A0  1 2C 31 A2  1 
1A23F08 	40 F9 A1  1 BC 45 A0  1 

      \ Since "catch/throw" saves and restores my-self,
      \ my-self will be 0 if a throw occurred.

      ['] (open-dev) catch  if  2drop  then
1A23F10 	60 53 A0  1 DC 3E A2  1 
1A23F18 	14 7F A0  1 DC 41 A0  1 
1A23F20 	 8  0  0  0 AC 49 A0  1 
      my-self                                   ( ihandle )
1A23F28 	EC 7E A0  1 

   r> push-device  )package                     ( ihandle )
1A23F2C 	D0 45 A0  1 
1A23F30 	F8 FB A1  1 5C 31 A2  1 
;
1A23F38 	58 46 A0  1 

headerless

: (execute-method)  ( path$ method$ -- false | ??? true )
1A23F3C 	 0  0  0 28 
1A23F40 	65 78 65 63 75 74 65 2D 
1A23F48 	6D 65 74 68 6F 64 29 90 
1A23F50 	FC 3E A2  1 20 40 A0  1 
   2swap  open-path  (apply-method)
1A23F58 	F4 49 A0  1 18 3E A2  1 
1A23F60 	20 3C A2  1 
;
1A23F64 	58 46 A0  1 

headers

: execute-device-method  ( path$ method$ -- false | ??? true )
1A23F68 	 0  0 65 78 65 63 75 74 
1A23F70 	65 2D 64 65 76 69 63 65 
1A23F78 	2D 6D 65 74 68 6F 64 95 
1A23F80 	54 3F A2  1 20 40 A0  1 
   0 package(  current-device >r       ( path$ method$ )
1A23F88 	70 6F A0  1 2C 31 A2  1 
1A23F90 	40 F9 A1  1 BC 45 A0  1 
      ['] (execute-method)  catch  if  ( x x x x )
1A23F98 	60 53 A0  1 54 3F A2  1 
1A23FA0 	14 7F A0  1 DC 41 A0  1 
1A23FA8 	18  0  0  0 
         2drop 2drop  false            ( false )
1A23FAC 	AC 49 A0  1 
1A23FB0 	AC 49 A0  1 18 70 A0  1 
      else                             ( ??? )
1A23FB8 	C8 41 A0  1  C  0  0  0 
         close-chain  true             ( ??? true )
1A23FC0 	3C 37 A2  1  4 70 A0  1 
      then                             ( false | ??? true )
   r> push-device  )package            ( false | ??? true )
1A23FC8 	D0 45 A0  1 F8 FB A1  1 
1A23FD0 	5C 31 A2  1 
;
1A23FD4 	58 46 A0  1 

\ Easier to use version of execute-device-method
\
\ ex:  apply  selftest  net
\
: apply ( -- ??? ) \ method { devpath | alias }
1A23FD8 	 0  0 61 70 70 6C 79 85 
1A23FE0 	84 3F A2  1 20 40 A0  1 
   safe-parse-word  safe-parse-word  ( method$ devpath$ )
1A23FE8 	88 93 A0  1 88 93 A0  1 
   2swap  execute-device-method      ( ??? success? )
1A23FF0 	F4 49 A0  1 84 3F A2  1 
   0= abort" apply failed."          ( ??? )
1A23FF8 	24 47 A0  1  8 81 A0  1 
1A24000 	 D 61 70 70 6C 79 20 66 
1A24008 	61 69 6C 65 64 2E  0  0 
;
1A24010 	58 46 A0  1 


h# 10 circular-stack: istack
1A24014 	 0 69 73 74 
1A24018 	61 63 6B 86 E4 3F A2  1 
1A24020 	30 40 A0  1 C0  6  0  0 
1A24028 	44  0  0  0 EC 38 A2  1 

\ select-dev opens a package, sets my-self to that ihandle, pushes the
\ old my-self on the instance stack, and pushes that package's vocabulary
\ on the search order.  unselect-dev undoes select-dev .

: iselect  ( ihandle -- )
1A24030 	69 73 65 6C 65 63 74 87 
1A24038 	20 40 A2  1 20 40 A0  1 
   dup 0= abort" Invalid ihandle"  ( ihandle )
1A24040 	40 49 A0  1 24 47 A0  1 
1A24048 	 8 81 A0  1  F 49 6E 76 
1A24050 	61 6C 69 64 20 69 68 61 
1A24058 	6E 64 6C 65  0  0  0  0 
   my-self istack push  is my-self
1A24060 	EC 7E A0  1 20 40 A2  1 
1A24068 	7C  6 A1  1 B8 40 A0  1 
1A24070 	EC 7E A0  1 
   also my-voc  push-device
1A24074 	C8 C1 A0  1 
1A24078 	10  4 A2  1 F8 FB A1  1 
;
1A24080 	58 46 A0  1 
: iunselect  ( -- )  previous definitions  istack pop is my-self  ;
1A24084 	 0  0 69 75 
1A24088 	6E 73 65 6C 65 63 74 89 
1A24090 	3C 40 A2  1 20 40 A0  1 
1A24098 	E4 C3 A0  1 2C C4 A0  1 
1A240A0 	20 40 A2  1 C4  6 A1  1 
1A240A8 	B8 40 A0  1 EC 7E A0  1 
1A240B0 	58 46 A0  1 
: select-dev  ( adr,len -- )  open-dev  iselect  ;
1A240B4 	 0 73 65 6C 
1A240B8 	65 63 74 2D 64 65 76 8A 
1A240C0 	94 40 A2  1 20 40 A0  1 
1A240C8 	FC 3E A2  1 3C 40 A2  1 
1A240D0 	58 46 A0  1 
: begin-select-dev  ( adr,len -- )   begin-open-dev  iselect  ;
1A240D4 	 0  0  0 62 
1A240D8 	65 67 69 6E 2D 73 65 6C 
1A240E0 	65 63 74 2D 64 65 76 90 
1A240E8 	C4 40 A2  1 20 40 A0  1 
1A240F0 	8C 3E A2  1 3C 40 A2  1 
1A240F8 	58 46 A0  1 

: select  ( "name" -- )  safe-parse-word select-dev  ;
1A240FC 	 0 73 65 6C 
1A24100 	65 63 74 86 EC 40 A2  1 
1A24108 	20 40 A0  1 88 93 A0  1 
1A24110 	C4 40 A2  1 58 46 A0  1 
: begin-select  ( "name" -- )  safe-parse-word begin-select-dev  ;
1A24118 	 0  0  0 62 65 67 69 6E 
1A24120 	2D 73 65 6C 65 63 74 8C 
1A24128 	 8 41 A2  1 20 40 A0  1 
1A24130 	88 93 A0  1 EC 40 A2  1 
1A24138 	58 46 A0  1 

: unselect-dev  ( -- )   my-self  iunselect  close-dev  ;
1A2413C 	 0  0  0 75 
1A24140 	6E 73 65 6C 65 63 74 2D 
1A24148 	64 65 76 8C 2C 41 A2  1 
1A24150 	20 40 A0  1 EC 7E A0  1 
1A24158 	94 40 A2  1 5C 37 A2  1 
1A24160 	58 46 A0  1 
: unselect  ( -- )  unselect-dev  ;
1A24164 	 0  0  0 75 
1A24168 	6E 73 65 6C 65 63 74 88 
1A24170 	50 41 A2  1 20 40 A0  1 
1A24178 	50 41 A2  1 58 46 A0  1 

: begin-package  ( arg-str reg-str parent-str -- )
1A24180 	 0  0 62 65 67 69 6E 2D 
1A24188 	70 61 63 6B 61 67 65 8D 
1A24190 	74 41 A2  1 20 40 A0  1 
   select-dev  new-device  set-args
1A24198 	C4 40 A2  1 74  F A2  1 
1A241A0 	 4 33 A2  1 
;
1A241A4 	58 46 A0  1 

: end-package  ( -- )  finish-device  unselect-dev  ;
1A241A8 	65 6E 64 2D 70 61 63 6B 
1A241B0 	61 67 65 8B 94 41 A2  1 
1A241B8 	20 40 A0  1 74 11 A2  1 
1A241C0 	50 41 A2  1 58 46 A0  1 

: support-package:  ( "name" -- )
1A241C8 	 0  0  0 73 75 70 70 6F 
1A241D0 	72 74 2D 70 61 63 6B 61 
1A241D8 	67 65 3A 90 B8 41 A2  1 
1A241E0 	20 40 A0  1 
   " /packages" find-device
1A241E4 	9C 53 A0  1 
1A241E8 	 9 2F 70 61 63 6B 61 67 
1A241F0 	65 73  0  0 BC 22 A2  1 
   new-device
1A241F8 	74  F A2  1 
   safe-parse-word encode-string " name" property
1A241FC 	88 93 A0  1 
1A24200 	A0 F6 A1  1 9C 53 A0  1 
1A24208 	 4 6E 61 6D 65  0  0  0 
1A24210 	BC 14 A2  1 
;
1A24214 	58 46 A0  1 

: end-support-package  ( -- )  finish-device device-end  ;
1A24218 	65 6E 64 2D 73 75 70 70 
1A24220 	6F 72 74 2D 70 61 63 6B 
1A24228 	61 67 65 93 E0 41 A2  1 
1A24230 	20 40 A0  1 74 11 A2  1 
1A24238 	94  F A2  1 58 46 A0  1 

defer skip-test?  ( phandle -- flag )
1A24240 	 0 73 6B 69 70 2D 74 65 
1A24248 	73 74 3F 8A 30 42 A2  1 
1A24250 	5C 40 A0  1 C4  6  0  0 
: no-skip  ( phandle -- false )  drop false  ;
1A24258 	6E 6F 2D 73 6B 69 70 87 
1A24260 	50 42 A2  1 20 40 A0  1 
1A24268 	30 49 A0  1 18 70 A0  1 
1A24270 	58 46 A0  1 
' no-skip  to skip-test?

: (test-dev)  ( name,len -- )
1A24274 	 0 28 74 65 
1A24278 	73 74 2D 64 65 76 29 8A 
1A24280 	64 42 A2  1 20 40 A0  1 
   2dup  locate-device  if  ( name,len )
1A24288 	C0 49 A0  1 EC 21 A2  1 
1A24290 	DC 41 A0  1 38  0  0  0 
      ??cr  ." Device " type  ."  not found." cr exit
1A24298 	 0 A1 A0  1 20 7C A0  1 
1A242A0 	 7 44 65 76 69 63 65 20 
1A242A8 	 0  0  0  0  4 6C A0  1 
1A242B0 	20 7C A0  1  B 20 6E 6F 
1A242B8 	74 20 66 6F 75 6E 64 2E 
1A242C0 	 0  0  0  0 80 6D A0  1 
1A242C8 	40 46 A0  1 
   then   ( name,len  phandle )

   dup  skip-test?  if
1A242CC 	40 49 A0  1 
1A242D0 	50 42 A2  1 DC 41 A0  1 
1A242D8 	78  0  0  0 
      ." This implementation does not support selftest for plug-in devices." cr
1A242DC 	20 7C A0  1 
1A242E0 	42 54 68 69 73 20 69 6D 
1A242E8 	70 6C 65 6D 65 6E 74 61 
1A242F0 	74 69 6F 6E 20 64 6F 65 
1A242F8 	73 20 6E 6F 74 20 73 75 
1A24300 	70 70 6F 72 74 20 73 65 
1A24308 	6C 66 74 65 73 74 20 66 
1A24310 	6F 72 20 70 6C 75 67 2D 
1A24318 	69 6E 20 64 65 76 69 63 
1A24320 	65 73 2E  0 80 6D A0  1 
      drop type ."  is a plug-in device." cr
1A24328 	30 49 A0  1  4 6C A0  1 
1A24330 	20 7C A0  1 15 20 69 73 
1A24338 	20 61 20 70 6C 75 67 2D 
1A24340 	69 6E 20 64 65 76 69 63 
1A24348 	65 2E  0  0 80 6D A0  1 
   then

   drop 2dup >r >r                        ( name,len )         ( r: len,name )
1A24350 	30 49 A0  1 C0 49 A0  1 
1A24358 	BC 45 A0  1 BC 45 A0  1 
   " selftest" execute-device-method  if  ( test-result-flag ) ( r: len,name )
1A24360 	9C 53 A0  1  8 73 65 6C 
1A24368 	66 74 65 73 74  0  0  0 
1A24370 	84 3F A2  1 DC 41 A0  1 
1A24378 	70  0  0  0 
      ?dup  if                            ( error-code )       ( r: len,name )
1A2437C 	B4 70 A0  1 
1A24380 	DC 41 A0  1 50  0  0  0 
	 cr  r> r> type space             ( error-code )
1A24388 	80 6D A0  1 D0 45 A0  1 
1A24390 	D0 45 A0  1  4 6C A0  1 
1A24398 	CC 71 A0  1 
	 ." selftest failed. Return code = " .d cr  ( )
1A2439C 	20 7C A0  1 
1A243A0 	1F 73 65 6C 66 74 65 73 
1A243A8 	74 20 66 61 69 6C 65 64 
1A243B0 	2E 20 52 65 74 75 72 6E 
1A243B8 	20 63 6F 64 65 20 3D 20 
1A243C0 	 0  0  0  0 48  E A1  1 
1A243C8 	80 6D A0  1 
       else                               (  ) ( r: len,name )
1A243CC 	C8 41 A0  1 
1A243D0 	10  0  0  0 
	  r> r> 2drop                     (  )
1A243D4 	D0 45 A0  1 
1A243D8 	D0 45 A0  1 AC 49 A0  1 
       then                               (  )
    else                                  (  ) ( r: len,name )
1A243E0 	C8 41 A0  1 3C  0  0  0 
       ??cr ." No selftest method for " r> r> type space cr
1A243E8 	 0 A1 A0  1 20 7C A0  1 
1A243F0 	17 4E 6F 20 73 65 6C 66 
1A243F8 	74 65 73 74 20 6D 65 74 
1A24400 	68 6F 64 20 66 6F 72 20 
1A24408 	 0  0  0  0 D0 45 A0  1 
1A24410 	D0 45 A0  1  4 6C A0  1 
1A24418 	CC 71 A0  1 80 6D A0  1 
    then  true throw
1A24420 	 4 70 A0  1 74 7F A0  1 
;
1A24428 	58 46 A0  1 
: test-dev ( name,len -- )  ['] (test-dev) catch  if  2drop  then  ;
1A2442C 	 0  0  0 74 
1A24430 	65 73 74 2D 64 65 76 88 
1A24438 	84 42 A2  1 20 40 A0  1 
1A24440 	60 53 A0  1 84 42 A2  1 
1A24448 	14 7F A0  1 DC 41 A0  1 
1A24450 	 8  0  0  0 AC 49 A0  1 
1A24458 	58 46 A0  1 

: test   \ device-specifier  ( -- )
1A2445C 	 0  0  0 74 
1A24460 	65 73 74 84 3C 44 A2  1 
1A24468 	20 40 A0  1 
   \ Get device specifier string
   parse-word  ( adr len )
1A2446C 	34 93 A0  1 
   dup 0=  if
1A24470 	40 49 A0  1 24 47 A0  1 
1A24478 	DC 41 A0  1 30  0  0  0 
      ??cr ." No device name specified."
1A24480 	 0 A1 A0  1 20 7C A0  1 
1A24488 	19 4E 6F 20 64 65 76 69 
1A24490 	63 65 20 6E 61 6D 65 20 
1A24498 	73 70 65 63 69 66 69 65 
1A244A0 	64 2E  0  0 
   else
1A244A4 	C8 41 A0  1 
1A244A8 	 8  0  0  0 
      test-dev
1A244AC 	3C 44 A2  1 
   then
;
1A244B0 	58 46 A0  1 

headerless
\ XXX This really needs to append the stuff to a given string buffer
: .instance-name  ( -- )
1A244B4 	 0 2E 69 6E 
1A244B8 	73 74 61 6E 63 65 2D 6E 
1A244C0 	61 6D 65 8E 68 44 A2  1 
1A244C8 	20 40 A0  1 
   " name" get-my-property  0=  if  get-encoded-string type  then
1A244CC 	9C 53 A0  1 
1A244D0 	 4 6E 61 6D 65  0  0  0 
1A244D8 	1C 34 A2  1 24 47 A0  1 
1A244E0 	DC 41 A0  1  C  0  0  0 
1A244E8 	24 F7 A1  1  4 6C A0  1 
   my-unit  ." @"  .nh  ." ,"  .nh
1A244F0 	70 10 A2  1 20 7C A0  1 
1A244F8 	 1 40  0  0 28 23 A2  1 
1A24500 	20 7C A0  1  1 2C  0  0 
1A24508 	28 23 A2  1 
   my-args  ?dup  if  ." :" type  else  drop  then
1A2450C 	10  7 A2  1 
1A24510 	B4 70 A0  1 DC 41 A0  1 
1A24518 	18  0  0  0 20 7C A0  1 
1A24520 	 1 3A  0  0  4 6C A0  1 
1A24528 	C8 41 A0  1  8  0  0  0 
1A24530 	30 49 A0  1 
;
1A24534 	58 46 A0  1 
headers
: .path  ( ihandle -- )  recursive
1A24538 	 0  0 2E 70 61 74 68 85 
1A24540 	C8 44 A2  1 20 40 A0  1 
   ?dup  if
1A24548 	B4 70 A0  1 DC 41 A0  1 
1A24550 	2C  0  0  0 
      package(
1A24554 	2C 31 A2  1 
         my-parent  ?dup  if   .path  ." /"  .instance-name  then
1A24558 	28  4 A2  1 B4 70 A0  1 
1A24560 	DC 41 A0  1 14  0  0  0 
1A24568 	44 45 A2  1 20 7C A0  1 
1A24570 	 1 2F  0  0 C8 44 A2  1 
      )package
1A24578 	5C 31 A2  1 
   then
;
1A2457C 	58 46 A0  1 

headerless

: (execute-phandle-method)  ( method-adr,len phandle -- ??? )
1A24580 	 0  0  0 28 65 78 65 63 
1A24588 	75 74 65 2D 70 68 61 6E 
1A24590 	64 6C 65 2D 6D 65 74 68 
1A24598 	6F 64 29 98 44 45 A2  1 
1A245A0 	20 40 A0  1 
   0 to unit#-valid?              ( method-adr,len phandle )
1A245A4 	70 6F A0  1 
1A245A8 	B8 40 A0  1 40 18 A2  1 
   dup >parent dt-null open-parents  ( method-adr,len phandle )
1A245B0 	40 49 A0  1 C0 FA A1  1 
1A245B8 	6C F8 A1  1 E0 3C A2  1 
   push-device                    ( method-adr,len )
1A245C0 	F8 FB A1  1 
   " "  new-instance              ( method-adr,len )
1A245C4 	9C 53 A0  1 
1A245C8 	 0  0  0  0 9C  8 A2  1 
   set-default-unit               ( method-adr,len )
1A245D0 	68 3B A2  1 
   (apply-method)                 ( ???? )
1A245D4 	20 3C A2  1 
;
1A245D8 	58 46 A0  1 

headers
: open-phandle  ( phandle -- ihandle | 0 )
1A245DC 	 0  0  0 6F 
1A245E0 	70 65 6E 2D 70 68 61 6E 
1A245E8 	64 6C 65 8C A0 45 A2  1 
1A245F0 	20 40 A0  1 
   0 package(                   ( phandle )
1A245F4 	70 6F A0  1 
1A245F8 	2C 31 A2  1 
      current-device >r         ( phandle )
1A245FC 	40 F9 A1  1 
1A24600 	BC 45 A0  1 
      0 to unit#-valid?         ( phandle )
1A24604 	70 6F A0  1 
1A24608 	B8 40 A0  1 40 18 A2  1 
      dt-null ['] open-parents catch  if  ( x x )
1A24610 	6C F8 A1  1 60 53 A0  1 
1A24618 	E0 3C A2  1 14 7F A0  1 
1A24620 	DC 41 A0  1 14  0  0  0 
         2drop  0               ( 0 )
1A24628 	AC 49 A0  1 70 6F A0  1 
      else                      (   )
1A24630 	C8 41 A0  1  8  0  0  0 
         my-self                ( ihandle )
1A24638 	EC 7E A0  1 
      then                      ( ihandle | 0 )
      r> push-device            ( ihandle | 0 )
1A2463C 	D0 45 A0  1 
1A24640 	F8 FB A1  1 
   )package                     ( ihandle | 0 )
1A24644 	5C 31 A2  1 
;
1A24648 	58 46 A0  1 

: execute-phandle-method  ( method-adr,len phandle -- false | ??? true )
1A2464C 	 0 65 78 65 
1A24650 	63 75 74 65 2D 70 68 61 
1A24658 	6E 64 6C 65 2D 6D 65 74 
1A24660 	68 6F 64 96 F0 45 A2  1 
1A24668 	20 40 A0  1 
   3dup find-method  if  drop  else  false exit  then
1A2466C 	A4 52 A0  1 
1A24670 	A0 2F A2  1 DC 41 A0  1 
1A24678 	10  0  0  0 30 49 A0  1 
1A24680 	C8 41 A0  1  C  0  0  0 
1A24688 	18 70 A0  1 40 46 A0  1 
   0 package(                                  ( method-adr,len phandle )
1A24690 	70 6F A0  1 2C 31 A2  1 
      current-device >r                        ( method-adr,len phandle )
1A24698 	40 F9 A1  1 BC 45 A0  1 
      ['] (execute-phandle-method)  catch  if  ( method-adr,len phandle err-code )
1A246A0 	60 53 A0  1 A0 45 A2  1 
1A246A8 	14 7F A0  1 DC 41 A0  1 
1A246B0 	14  0  0  0 
         3drop false                           ( false )
1A246B4 	90 52 A0  1 
1A246B8 	18 70 A0  1 
      else                                     ( ??? )
1A246BC 	C8 41 A0  1 
1A246C0 	 C  0  0  0 
         close-chain true                      ( ??? true )
1A246C4 	3C 37 A2  1 
1A246C8 	 4 70 A0  1 
      then                                     ( false | ??? true )
      r> push-device                           ( false | ??? true )
1A246CC 	D0 45 A0  1 
1A246D0 	F8 FB A1  1 
   )package                                    ( false | ??? true )
1A246D4 	5C 31 A2  1 
;
1A246D8 	58 46 A0  1 

\ Creates a copy of the named package, placing the new clone in the device
\ tree as a child of the package that was active when $clone-node was called,
\ and makes the new clone the current instance and the active package.
: $clone-node  ( name$ -- )
1A246DC 	24 63 6C 6F 
1A246E0 	6E 65 2D 6E 6F 64 65 8B 
1A246E8 	68 46 A2  1 20 40 A0  1 
   find-package 0= abort" No such node"  current-device  (clone)
1A246F0 	E0 39 A2  1 24 47 A0  1 
1A246F8 	 8 81 A0  1  C 4E 6F 20 
1A24700 	73 75 63 68 20 6E 6F 64 
1A24708 	65  0  0  0 40 F9 A1  1 
1A24710 	BC  E A2  1 
;
1A24714 	58 46 A0  1 
headers

\ From comprop.fth
purpose:

: encode-ints  ( nn .. n1 n -- adr len )
1A24718 	65 6E 63 6F 64 65 2D 69 
1A24720 	6E 74 73 8B EC 46 A2  1 
1A24728 	20 40 A0  1 
   0 0 encode-bytes   rot  0  ?do  rot encode-int encode+  loop
1A2472C 	70 6F A0  1 
1A24730 	70 6F A0  1 14 F6 A1  1 
1A24738 	7C 49 A0  1 70 6F A0  1 
1A24740 	50 42 A0  1 18  0  0  0 
1A24748 	7C 49 A0  1 40 F7 A1  1 
1A24750 	F0 F5 A1  1 F8 41 A0  1 
1A24758 	F0 FF FF FF 
;
1A2475C 	58 46 A0  1 
: decode-ints  ( adr len n -- nn .. n1 )
1A24760 	64 65 63 6F 64 65 2D 69 
1A24768 	6E 74 73 8B 28 47 A2  1 
1A24770 	20 40 A0  1 
   dup begin  ?dup  while              ( adr len n cnt )     ( r: phys.hi.. )
1A24774 	40 49 A0  1 
1A24778 	B4 70 A0  1 DC 41 A0  1 
1A24780 	2C  0  0  0 
      >r >r  decode-int r> r> rot >r   ( adr' len' n cnt )   ( r: phys.hi... )
1A24784 	BC 45 A0  1 
1A24788 	BC 45 A0  1 68 F7 A1  1 
1A24790 	D0 45 A0  1 D0 45 A0  1 
1A24798 	7C 49 A0  1 BC 45 A0  1 
      1-                               ( adr' len' n cnt-1 ) ( r: phys.hi... )
1A247A0 	54 4B A0  1 
   repeat                              ( adr' len' n )       ( r: phys.hi..lo )
1A247A4 	C8 41 A0  1 
1A247A8 	D0 FF FF FF 
   begin  ?dup  while                  ( adr' len' cnt )     ( r: phys.hi.. )
1A247AC 	B4 70 A0  1 
1A247B0 	DC 41 A0  1 18  0  0  0 
      r> swap 1-                       ( adr' len' phys.lo.. cnt-1 )
1A247B8 	D0 45 A0  1 68 49 A0  1 
1A247C0 	54 4B A0  1 
   repeat                              ( adr' len' phys.lo..hi )
1A247C4 	C8 41 A0  1 
1A247C8 	E4 FF FF FF 
;
1A247CC 	58 46 A0  1 
: encode-phys  ( phys.lo..hi -- addr len )  my-#adr-cells encode-ints  ;
1A247D0 	65 6E 63 6F 64 65 2D 70 
1A247D8 	68 79 73 8B 70 47 A2  1 
1A247E0 	20 40 A0  1 D8  F A2  1 
1A247E8 	28 47 A2  1 58 46 A0  1 

: decode-phys  ( adr len -- adr' len' phys.lo..hi )
1A247F0 	64 65 63 6F 64 65 2D 70 
1A247F8 	68 79 73 8B E0 47 A2  1 
1A24800 	20 40 A0  1 
   my-#adr-cells decode-ints
1A24804 	D8  F A2  1 
1A24808 	70 47 A2  1 
;
1A2480C 	58 46 A0  1 

: encode-reg  ( phys.lo..hi size -- adr len )
1A24810 	 0 65 6E 63 6F 64 65 2D 
1A24818 	72 65 67 8A  0 48 A2  1 
1A24820 	20 40 A0  1 
   >r  encode-phys  r> encode-int encode+
1A24824 	BC 45 A0  1 
1A24828 	E0 47 A2  1 D0 45 A0  1 
1A24830 	40 F7 A1  1 F0 F5 A1  1 
;
1A24838 	58 46 A0  1 

headerless
\ The IEEE standard restricts the use of encode-reg to buses
\ with #size-cells=1 .  Therefore, the generalized code that
\ immediately follows is not strictly necessary; the simplified
\ version above is sufficient for IEEE compliance.

: my-parent-#size-cells  ( -- #size-cells )
1A2483C 	 0  0 6D 79 
1A24840 	2D 70 61 72 65 6E 74 2D 
1A24848 	23 73 69 7A 65 2D 63 65 
1A24850 	6C 6C 73 95 20 48 A2  1 
1A24858 	20 40 A0  1 
   \ Root node has no parent, therefore the size of its parent's address
   \ space is meaningless
   my-voc  root-phandle =  if  0  exit  then
1A2485C 	10  4 A2  1 
1A24860 	F8 10 A2  1 24 48 A0  1 
1A24868 	DC 41 A0  1  C  0  0  0 
1A24870 	70 6F A0  1 40 46 A0  1 

   " #size-cells"    my-parent ihandle>phandle  ( adr len phandle )
1A24878 	9C 53 A0  1  B 23 73 69 
1A24880 	7A 65 2D 63 65 6C 6C 73 
1A24888 	 0  0  0  0 28  4 A2  1 
1A24890 	 0 32 A2  1 
   get-package-property  if  1  else  get-encoded-int  then
1A24894 	98 33 A2  1 
1A24898 	DC 41 A0  1 10  0  0  0 
1A248A0 	80 6F A0  1 C8 41 A0  1 
1A248A8 	 8  0  0  0 A0 F7 A1  1 
;
1A248B0 	58 46 A0  1 

headers
[ifdef] notdef
: n>r  ( nn .. n1 n -- )
   dup r>  swap  begin  ?dup  while   ( nn .. nm n retadr cnt )
      3 pick >r  1-                   ( nn .. nm+1 n retadr cnt-1 ) ( r: .. )
   repeat                             ( n retadr )
   swap >r >r                         ( )
;

: nr>  ( -- nn .. n1 )
   r> r> swap                                ( retadr n )
   begin  ?dup  while  r> -rot  1-  repeat   ( retadr )
   >r
;

: encode-reg  ( phys.lo..hi size.lo..hi -- adr len )
   my-parent-#size-cells n>r              ( phys.lo..hi )
   encode-phys                            ( adr len )
   nr>                                    ( adr len size.lo..hi n )
   my-parent-#size-cells  encode-ints     ( adr len adr1 len1 )
   encode+                                ( adr len )
;
[then]

: string-property   ( value-adr,len name-adr,len -- )
1A248B4 	73 74 72 69 
1A248B8 	6E 67 2D 70 72 6F 70 65 
1A248C0 	72 74 79 8F 58 48 A2  1 
1A248C8 	20 40 A0  1 
   2swap encode-string 2swap  property
1A248CC 	F4 49 A0  1 
1A248D0 	A0 F6 A1  1 F4 49 A0  1 
1A248D8 	BC 14 A2  1 
;
1A248DC 	58 46 A0  1 
: integer-property ( value  name-adr,len -- )
1A248E0 	 0  0  0 69 6E 74 65 67 
1A248E8 	65 72 2D 70 72 6F 70 65 
1A248F0 	72 74 79 90 C8 48 A2  1 
1A248F8 	20 40 A0  1 
   rot encode-int 2swap property
1A248FC 	7C 49 A0  1 
1A24900 	40 F7 A1  1 F4 49 A0  1 
1A24908 	BC 14 A2  1 
;
1A2490C 	58 46 A0  1 
: device-name  ( adr len -- )  " name" string-property  ;
1A24910 	64 65 76 69 63 65 2D 6E 
1A24918 	61 6D 65 8B F8 48 A2  1 
1A24920 	20 40 A0  1 9C 53 A0  1 
1A24928 	 4 6E 61 6D 65  0  0  0 
1A24930 	C8 48 A2  1 58 46 A0  1 
alias nameprop device-name
1A24938 	 0  0  0 6E 61 6D 65 70 
1A24940 	72 6F 70 A8 20 49 A2  1 
1A24948 	20 49 A2  1 

: driver  ( adr len -- )   \ string is of the form: manufacturer,name
1A2494C 	 0 64 72 69 
1A24950 	76 65 72 86 48 49 A2  1 
1A24958 	20 40 A0  1 
   ascii , left-parse-string                          ( after-, before-, )
1A2495C 	58 41 A0  1 
1A24960 	2C  0  0  0 44 D7 A0  1 
   2swap  dup  if                                     ( man.-str name-str )
1A24968 	F4 49 A0  1 40 49 A0  1 
1A24970 	DC 41 A0  1 28  0  0  0 
      device-name
1A24978 	20 49 A2  1 
      " manufacturer" string-property
1A2497C 	9C 53 A0  1 
1A24980 	 C 6D 61 6E 75 66 61 63 
1A24988 	74 75 72 65 72  0  0  0 
1A24990 	C8 48 A2  1 
   else                                               ( null-str name-str )
1A24994 	C8 41 A0  1 
1A24998 	 C  0  0  0 
      2drop  device-name
1A2499C 	AC 49 A0  1 
1A249A0 	20 49 A2  1 
   then
;
1A249A4 	58 46 A0  1 
: device-type  ( adr len -- )  " device_type" string-property  ;
1A249A8 	64 65 76 69 63 65 2D 74 
1A249B0 	79 70 65 8B 58 49 A2  1 
1A249B8 	20 40 A0  1 9C 53 A0  1 
1A249C0 	 B 64 65 76 69 63 65 5F 
1A249C8 	74 79 70 65  0  0  0  0 
1A249D0 	C8 48 A2  1 58 46 A0  1 

\ This is a handy tool for amending "compatible" properties.
\ It prepends the string on the stack to the beginning of the existing
\ "compatible" property, or creates the property if it doesn't exist.
: +compatible  ( compat$ -- )
1A249D8 	2B 63 6F 6D 70 61 74 69 
1A249E0 	62 6C 65 8B B8 49 A2  1 
1A249E8 	20 40 A0  1 
   encode-string                        ( prop$ )
1A249EC 	A0 F6 A1  1 
   " compatible" get-property  0=  if   ( prop$ old-prop$ )
1A249F0 	9C 53 A0  1  A 63 6F 6D 
1A249F8 	70 61 74 69 62 6C 65  0 
1A24A00 	F4  D A2  1 24 47 A0  1 
1A24A08 	DC 41 A0  1  C  0  0  0 
      encode-bytes encode+              ( prop$' )
1A24A10 	14 F6 A1  1 F0 F5 A1  1 
   then                                 ( prop$ )
   " compatible" property
1A24A18 	9C 53 A0  1  A 63 6F 6D 
1A24A20 	70 61 74 69 62 6C 65  0 
1A24A28 	BC 14 A2  1 
;
1A24A2C 	58 46 A0  1 

headerless

: modelprop        ( adr len -- )  " model"       string-property  ;
1A24A30 	 0  0 6D 6F 64 65 6C 70 
1A24A38 	72 6F 70 89 E8 49 A2  1 
1A24A40 	20 40 A0  1 9C 53 A0  1 
1A24A48 	 5 6D 6F 64 65 6C  0  0 
1A24A50 	C8 48 A2  1 58 46 A0  1 
: addrprop  ( a -- )  encode-int  " address" property  ;
1A24A58 	 0  0  0 61 64 64 72 70 
1A24A60 	72 6F 70 88 40 4A A2  1 
1A24A68 	20 40 A0  1 40 F7 A1  1 
1A24A70 	9C 53 A0  1  7 61 64 64 
1A24A78 	72 65 73 73  0  0  0  0 
1A24A80 	BC 14 A2  1 58 46 A0  1 
: regprop  ( address space size -- )
1A24A88 	72 65 67 70 72 6F 70 87 
1A24A90 	68 4A A2  1 20 40 A0  1 
   >r  encode-phys  r> encode-int encode+  " reg"  property
1A24A98 	BC 45 A0  1 E0 47 A2  1 
1A24AA0 	D0 45 A0  1 40 F7 A1  1 
1A24AA8 	F0 F5 A1  1 9C 53 A0  1 
1A24AB0 	 3 72 65 67  0  0  0  0 
1A24AB8 	BC 14 A2  1 
;
1A24ABC 	58 46 A0  1 

headers
: parse-int  ( adr len -- n )  dup  if  safe->number  else  2drop 0  then  ;
1A24AC0 	 0  0 70 61 72 73 65 2D 
1A24AC8 	69 6E 74 89 94 4A A2  1 
1A24AD0 	20 40 A0  1 40 49 A0  1 
1A24AD8 	DC 41 A0  1 10  0  0  0 
1A24AE0 	B8 19 A2  1 C8 41 A0  1 
1A24AE8 	 C  0  0  0 AC 49 A0  1 
1A24AF0 	70 6F A0  1 58 46 A0  1 

: parse-2int  ( adr len -- address space )
1A24AF8 	 0 70 61 72 73 65 2D 32 
1A24B00 	69 6E 74 8A D0 4A A2  1 
1A24B08 	20 40 A0  1 
   ascii , left-parse-string     ( after-str before-str )
1A24B0C 	58 41 A0  1 
1A24B10 	2C  0  0  0 44 D7 A0  1 
   parse-int  >r                ( after-str )
1A24B18 	D0 4A A2  1 BC 45 A0  1 
   parse-int  r>                ( address space )
1A24B20 	D0 4A A2  1 D0 45 A0  1 
;
1A24B28 	58 46 A0  1 
headerless
: encode-ranges ( offs bustype  phys offset size -- adr len )
1A24B2C 	 0  0 65 6E 
1A24B30 	63 6F 64 65 2D 72 61 6E 
1A24B38 	67 65 73 8D  8 4B A2  1 
1A24B40 	20 40 A0  1 
   >r >r >r  encode-phys  r> r> r> encode-reg  encode+
1A24B44 	BC 45 A0  1 
1A24B48 	BC 45 A0  1 BC 45 A0  1 
1A24B50 	E0 47 A2  1 D0 45 A0  1 
1A24B58 	D0 45 A0  1 D0 45 A0  1 
1A24B60 	20 48 A2  1 F0 F5 A1  1 
;
1A24B68 	58 46 A0  1 
headers
: encode-phandle  ( name$ -- adr len )
1A24B6C 	 0 65 6E 63 
1A24B70 	6F 64 65 2D 70 68 61 6E 
1A24B78 	64 6C 65 8E 40 4B A2  1 
1A24B80 	20 40 A0  1 
   locate-device abort" encode-phandle - Can't find package"  encode-int
1A24B84 	EC 21 A2  1 
1A24B88 	 8 81 A0  1 23 65 6E 63 
1A24B90 	6F 64 65 2D 70 68 61 6E 
1A24B98 	64 6C 65 20 2D 20 43 61 
1A24BA0 	6E 27 74 20 66 69 6E 64 
1A24BA8 	20 70 61 63 6B 61 67 65 
1A24BB0 	 0  0  0  0 40 F7 A1  1 
;
1A24BB8 	58 46 A0  1 

\ From finddisp.fth
purpose: 

\ Creates an alias for the full path of a given device.

headerless
variable 'fb-node  origin 'fb-node token!
1A24BBC 	 0  0  0 27 
1A24BC0 	66 62 2D 6E 6F 64 65 88 
1A24BC8 	80 4B A2  1 48 40 A0  1 
1A24BD0 	C8  6  0  0 
: encode-bytes+  ( adr1 len1  adr2 len2  --  adr1 len1+len2 )
1A24BD4 	 0  0 65 6E 
1A24BD8 	63 6F 64 65 2D 62 79 74 
1A24BE0 	65 73 2B 8D CC 4B A2  1 
1A24BE8 	20 40 A0  1 
   encode-bytes encode+
1A24BEC 	14 F6 A1  1 
1A24BF0 	F0 F5 A1  1 
;
1A24BF4 	58 46 A0  1 
: encode-number+  ( u adr,len -- adr,len' )
1A24BF8 	 0 65 6E 63 6F 64 65 2D 
1A24C00 	6E 75 6D 62 65 72 2B 8E 
1A24C08 	E8 4B A2  1 20 40 A0  1 
   push-hex
1A24C10 	5C F4 A0  1 
   rot  (u.)  encode-bytes+
1A24C14 	7C 49 A0  1 
1A24C18 	AC 77 A0  1 E8 4B A2  1 
   pop-base
1A24C20 	9C F4 A0  1 
;
1A24C24 	58 46 A0  1 

: encode-unit+  ( phys .. adr,len -- adr,len' )
1A24C28 	 0  0  0 65 6E 63 6F 64 
1A24C30 	65 2D 75 6E 69 74 2B 8C 
1A24C38 	 C 4C A2  1 20 40 A0  1 
   " decode-unit" parent-device find-method  if  drop  else
1A24C40 	9C 53 A0  1  B 64 65 63 
1A24C48 	6F 64 65 2D 75 6E 69 74 
1A24C50 	 0  0  0  0 EC FA A1  1 
1A24C58 	A0 2F A2  1 DC 41 A0  1 
1A24C60 	10  0  0  0 30 49 A0  1 
1A24C68 	C8 41 A0  1 30  0  0  0 
      \ Parent has no decode-unit--therefore we're done.
      2>r
1A24C70 	F8 45 A0  1 
      '#adr-cells @  0  ?do  drop  loop
1A24C74 	4C FA A1  1 
1A24C78 	5C 4C A0  1 70 6F A0  1 
1A24C80 	50 42 A0  1 10  0  0  0 
1A24C88 	30 49 A0  1 F8 41 A0  1 
1A24C90 	F8 FF FF FF 
      2r> exit
1A24C94 	10 46 A0  1 
1A24C98 	40 46 A0  1 
   then

   " @" encode-bytes+ 2>r	           ( phys .. )          ( R: $ )
1A24C9C 	9C 53 A0  1 
1A24CA0 	 1 40  0  0 E8 4B A2  1 
1A24CA8 	F8 45 A0  1 

   " encode-unit"  parent-device           ( phys .. adr,len phandle ) ( R: $ )
1A24CAC 	9C 53 A0  1 
1A24CB0 	 B 65 6E 63 6F 64 65 2D 
1A24CB8 	75 6E 69 74  0  0  0  0 
1A24CC0 	EC FA A1  1 
   $package-execute?  if                       ( phys .. )          ( R: $ )
1A24CC4 	94  D A2  1 
1A24CC8 	DC 41 A0  1 5C  0  0  0 

      2r>                                      ( phys .. adr,len )  ( R: )
1A24CD0 	10 46 A0  1 
      '#adr-cells @  if  encode-number+  then  ( phys .  adr,len' )
1A24CD4 	4C FA A1  1 
1A24CD8 	5C 4C A0  1 DC 41 A0  1 
1A24CE0 	 8  0  0  0  C 4C A2  1 
      '#adr-cells @ 1-  0 max  0  ?do          ( phys .. adr,len )
1A24CE8 	4C FA A1  1 5C 4C A0  1 
1A24CF0 	54 4B A0  1 70 6F A0  1 
1A24CF8 	9C 4A A0  1 70 6F A0  1 
1A24D00 	50 42 A0  1 1C  0  0  0 
         " ,"  encode-bytes+                   ( phys .. adr,len' )
1A24D08 	9C 53 A0  1  1 2C  0  0 
1A24D10 	E8 4B A2  1 
         encode-number+                        ( phys .  adr,len' )
1A24D14 	 C 4C A2  1 
      loop                                     ( adr,len )
1A24D18 	F8 41 A0  1 EC FF FF FF 
   else                                        ( unit-str )         ( R: $ )
1A24D20 	C8 41 A0  1 10  0  0  0 
      2r> 2swap encode-bytes+                  ( adr,len' )         ( R: )
1A24D28 	10 46 A0  1 F4 49 A0  1 
1A24D30 	E8 4B A2  1 
   then
;
1A24D34 	58 46 A0  1 

: (pwd$)  ( adr len -- adr len' )  recursive
1A24D38 	 0 28 70 77 64 24 29 86 
1A24D40 	3C 4C A2  1 20 40 A0  1 
   root-device? 0=  if
1A24D48 	4C 11 A2  1 24 47 A0  1 
1A24D50 	DC 41 A0  1 70  0  0  0 
      current-device >r  pop-device (pwd$)  r> push-device
1A24D58 	40 F9 A1  1 BC 45 A0  1 
1A24D60 	18 FC A1  1 44 4D A2  1 
1A24D68 	D0 45 A0  1 F8 FB A1  1 
      " /" encode-bytes+
1A24D70 	9C 53 A0  1  1 2F  0  0 
1A24D78 	E8 4B A2  1 
      " name" get-property  0=  if                 ( adr len name-adr1,len1 )
1A24D7C 	9C 53 A0  1 
1A24D80 	 4 6E 61 6D 65  0  0  0 
1A24D88 	F4  D A2  1 24 47 A0  1 
1A24D90 	DC 41 A0  1  C  0  0  0 
         get-encoded-string encode-bytes+          ( adr len' )
1A24D98 	24 F7 A1  1 E8 4B A2  1 
      then                                         ( adr len )
      get-unit  0=  if                             ( adr len unit-adr1,len1 )
1A24DA0 	90 15 A2  1 24 47 A0  1 
1A24DA8 	DC 41 A0  1 18  0  0  0 
         2swap 2>r  unit-str>phys                  ( phys.lo..hi )
1A24DB0 	F4 49 A0  1 F8 45 A0  1 
1A24DB8 	30 16 A2  1 
	 2r>  encode-unit+                         ( adr len' )
1A24DBC 	10 46 A0  1 
1A24DC0 	3C 4C A2  1 
      then                                         ( adr,len' )
   then
;
1A24DC4 	58 46 A0  1 

h# 100 buffer: pwd-buf
1A24DC8 	70 77 64 2D 62 75 66 87 
1A24DD0 	44 4D A2  1 B4 A9 A0  1 
1A24DD8 	CC  6  0  0  0  1  0  0 
1A24DE0 	20 40 A2  1 
\ adr len is the full path string.
: pwd$  ( -- adr len )
1A24DE4 	 0  0  0 70 
1A24DE8 	77 64 24 84 D4 4D A2  1 
1A24DF0 	20 40 A0  1 
   0 0  encode-bytes        ( adr,len )
1A24DF4 	70 6F A0  1 
1A24DF8 	70 6F A0  1 14 F6 A1  1 
   root-device?  if         ( adr,len )
1A24E00 	4C 11 A2  1 DC 41 A0  1 
1A24E08 	18  0  0  0 
      " /"  encode-bytes+   ( adr,len' )
1A24E0C 	9C 53 A0  1 
1A24E10 	 1 2F  0  0 E8 4B A2  1 
   else                     ( adr,len )
1A24E18 	C8 41 A0  1  8  0  0  0 
      (pwd$)                ( adr,len" )
1A24E20 	44 4D A2  1 
   then                     ( adr,len )

   \ Free the dictionary space
   \ used to collect the names
   over here -  allot    ( adr,len )
1A24E24 	54 49 A0  1 
1A24E28 	70 54 A0  1 18 45 A0  1 
1A24E30 	E4 54 A0  1 

   pwd-buf pack count    ( adr',len )
1A24E34 	D4 4D A2  1 
1A24E38 	DC 52 A0  1 BC 53 A0  1 
;
1A24E40 	58 46 A0  1 

: make-node-alias  ( voc name-str -- )
1A24E44 	6D 61 6B 65 
1A24E48 	2D 6E 6F 64 65 2D 61 6C 
1A24E50 	69 61 73 8F F0 4D A2  1 
1A24E58 	20 40 A0  1 
   current-device >r  ( nodeid name-str )
1A24E5C 	40 F9 A1  1 
1A24E60 	BC 45 A0  1 
   rot voc>phandle push-device    ( name-str )
1A24E64 	7C 49 A0  1 
1A24E68 	40 F8 A1  1 F8 FB A1  1 
   pwd$               ( name-str expansion-str )
1A24E70 	F0 4D A2  1 
   r> push-device     ( name-str expansion-str )
1A24E74 	D0 45 A0  1 
1A24E78 	F8 FB A1  1 
   $devalias          (  )
1A24E7C 	7C 21 A2  1 
;
1A24E80 	58 46 A0  1 

: (ihandle>devname) ( adr,len -- adr,len' ) recursive
1A24E84 	 0  0 28 69 
1A24E88 	68 61 6E 64 6C 65 3E 64 
1A24E90 	65 76 6E 61 6D 65 29 91 
1A24E98 	58 4E A2  1 20 40 A0  1 
   my-parent  if
1A24EA0 	28  4 A2  1 DC 41 A0  1 
1A24EA8 	1C  1  0  0 
      current-device >r
1A24EAC 	40 F9 A1  1 
1A24EB0 	BC 45 A0  1 
      my-voc push-device
1A24EB4 	10  4 A2  1 
1A24EB8 	F8 FB A1  1 
      my-parent  package( (ihandle>devname) )package
1A24EBC 	28  4 A2  1 
1A24EC0 	2C 31 A2  1 9C 4E A2  1 
1A24EC8 	5C 31 A2  1 
\     " support" get-my-property  0=  if  2drop  r> push-device  exit  then
      " /" encode-bytes+
1A24ECC 	9C 53 A0  1 
1A24ED0 	 1 2F  0  0 E8 4B A2  1 

      \ Display interposed package names with an extra leading /
      parent-device  my-parent ihandle>phandle <>  if  " /" encode-bytes+  then
1A24ED8 	EC FA A1  1 28  4 A2  1 
1A24EE0 	 0 32 A2  1 44 48 A0  1 
1A24EE8 	DC 41 A0  1 10  0  0  0 
1A24EF0 	9C 53 A0  1  1 2F  0  0 
1A24EF8 	E8 4B A2  1 

      " name" get-my-property  if  " "  else  1-  then  encode-bytes+   ( $ )
1A24EFC 	9C 53 A0  1 
1A24F00 	 4 6E 61 6D 65  0  0  0 
1A24F08 	1C 34 A2  1 DC 41 A0  1 
1A24F10 	14  0  0  0 9C 53 A0  1 
1A24F18 	 0  0  0  0 C8 41 A0  1 
1A24F20 	 8  0  0  0 54 4B A0  1 
1A24F28 	E8 4B A2  1 

      2>r                                                           ( R: $ )
1A24F2C 	F8 45 A0  1 

      'child get-token?  if
1A24F30 	 8 FA A1  1 6C 59 A0  1 
1A24F38 	DC 41 A0  1 30  0  0  0 
	 \ Has children so it is not a leaf node.
	 drop get-unit 	0= dup  if		 ( unit-str has-regs? )
1A24F40 	30 49 A0  1 90 15 A2  1 
1A24F48 	24 47 A0  1 40 49 A0  1 
1A24F50 	DC 41 A0  1 10  0  0  0 
            drop				 ( unit-str )
1A24F58 	30 49 A0  1 
            unit-str>phys			 ( phys.lo .. phys.hi )
1A24F5C 	30 16 A2  1 
	    true				 ( phys .. true )
1A24F60 	 4 70 A0  1 
	 then					 ( [ phys .. ] has-regs? )
      else					 ( )
1A24F64 	C8 41 A0  1 
1A24F68 	 C  0  0  0 
	 my-unit  true				 ( [ phys .. ] true )
1A24F6C 	70 10 A2  1 
1A24F70 	 4 70 A0  1 
      then					 ( [ phys .. ] has-regs? )

      2r> rot  if				 ( phys .. adr,len )  ( R: )
1A24F74 	10 46 A0  1 
1A24F78 	7C 49 A0  1 DC 41 A0  1 
1A24F80 	3C  0  0  0 
         encode-unit+                            ( adr,len' )
1A24F84 	3C 4C A2  1 

	 my-args dup  if                         ( adr,len args,len )
1A24F88 	10  7 A2  1 40 49 A0  1 
1A24F90 	DC 41 A0  1 24  0  0  0 
	    2swap  " :" encode-bytes+            ( args,len adr,len )
1A24F98 	F4 49 A0  1 9C 53 A0  1 
1A24FA0 	 1 3A  0  0 E8 4B A2  1 
	    2swap  encode-bytes+                 ( adr,len )
1A24FA8 	F4 49 A0  1 E8 4B A2  1 
	 else                                    ( adr,len args,0 )
1A24FB0 	C8 41 A0  1  8  0  0  0 
	    2drop                                ( adr,len )
1A24FB8 	AC 49 A0  1 
	 then                                    ( adr,len )
      then                                       ( adr,len )
      r> push-device
1A24FBC 	D0 45 A0  1 
1A24FC0 	F8 FB A1  1 
   then
;
1A24FC4 	58 46 A0  1 

headers
: ihandle>devname ( ihandle -- adr,len )
1A24FC8 	69 68 61 6E 64 6C 65 3E 
1A24FD0 	64 65 76 6E 61 6D 65 8F 
1A24FD8 	9C 4E A2  1 20 40 A0  1 
   0 0 encode-bytes
1A24FE0 	70 6F A0  1 70 6F A0  1 
1A24FE8 	14 F6 A1  1 
   rot package( (ihandle>devname) )package
1A24FEC 	7C 49 A0  1 
1A24FF0 	2C 31 A2  1 9C 4E A2  1 
1A24FF8 	5C 31 A2  1 
   over here - allot
1A24FFC 	54 49 A0  1 
1A25000 	70 54 A0  1 18 45 A0  1 
1A25008 	E4 54 A0  1 
   pwd-buf pack count    ( adr',len )
1A2500C 	D4 4D A2  1 
1A25010 	DC 52 A0  1 BC 53 A0  1 
;
1A25018 	58 46 A0  1 

: phandle>devname ( phandle -- adr,len )
1A2501C 	70 68 61 6E 
1A25020 	64 6C 65 3E 64 65 76 6E 
1A25028 	61 6D 65 8F DC 4F A2  1 
1A25030 	20 40 A0  1 
   current-device >r  ( phandle )  ( r: phandle' )
1A25034 	40 F9 A1  1 
1A25038 	BC 45 A0  1 
   push-device  pwd$  ( adr,len )  ( r: phandle' )
1A2503C 	F8 FB A1  1 
1A25040 	F0 4D A2  1 
   r> push-device     ( adr,len )
1A25044 	D0 45 A0  1 
1A25048 	F8 FB A1  1 
;
1A2504C 	58 46 A0  1 
: .ichain  ( -- )  my-self ihandle>devname type  ;
1A25050 	2E 69 63 68 61 69 6E 87 
1A25058 	30 50 A2  1 20 40 A0  1 
1A25060 	EC 7E A0  1 DC 4F A2  1 
1A25068 	 4 6C A0  1 58 46 A0  1 

also magic-device-types definitions
: display  ( -- )
1A25070 	64 69 73 70 6C 61 79 87 
1A25078 	 0  0 A0  1 20 40 A0  1 
   'fb-node token@ origin =  if  current-device phandle>voc  'fb-node token!  then
1A25080 	CC 4B A2  1  C 54 A0  1 
1A25088 	50 55 A0  1 24 48 A0  1 
1A25090 	DC 41 A0  1 14  0  0  0 
1A25098 	40 F9 A1  1 58 F8 A1  1 
1A250A0 	CC 4B A2  1 20 54 A0  1 
;
1A250A8 	58 46 A0  1 
previous definitions

\ From sysnodes.fth
purpose: 

defer client-services
1A250AC 	63 6C 69 65 
1A250B0 	6E 74 2D 73 65 72 76 69 
1A250B8 	63 65 73 8F 5C 50 A2  1 
1A250C0 	5C 40 A0  1 D0  6  0  0 

\ Create the standard system nodes

hex
\ debug devc
root-device  HERE TO packages-device \ mmo
   new-device				\ Node for software "library" packages
1A250C8 	E0 B6 A0  1 D4  6  0  0 
1A250D0 	B8 10 A2  1 E0 B6 A0  1 
1A250D8 	F4  6  0  0 
      " packages" device-name
1A250DC 	70 61 63 6B 
1A250E0 	61 67 65 73  0  0  0 6E 
1A250E8 	61 6D 65 84  0  0 A0  1 
1A250F0 	BC 13 A2  1 18  0  0  0 
1A250F8 	 9  0  0  0 

      new-device     current-device-t phandle>voc  to client-services \ mmo
1A250FC 	E0 B6 A0  1 
1A25100 	F8  6  0  0 C8 50 A2  1 
1A25108 	E0 B6 A0  1 18  7  0  0 
         " client-services" device-name
1A25110 	63 6C 69 65 6E 74 2D 73 
1A25118 	65 72 76 69 63 65 73  0 
1A25120 	 0  0  0 6E 61 6D 65 84 
1A25128 	 0  0 A0  1 BC 13 A2  1 
1A25130 	20  0  0  0 10  0  0  0 
      finish-device
1A25138 	 0  0  0  0  0  0  0  0 
1A25140 	 0  0  0  0  0  0  0  0 
1A25148 	 0  0  0  0  0  0  0  0 

   finish-device  here to chosen-device \ mmo
1A25150 	 0  0  0  0  0  0  0  0 
1A25158 	 0  0  0  0  0  0  0  0 
1A25160 	 0  0  0  0  0  0  0  0 
   new-device				\ Reports firmware run-time choices
1A25168 	E0 B6 A0  1 1C  7  0  0 
1A25170 	B8 10 A2  1 E0 B6 A0  1 
1A25178 	3C  7  0  0 
      " chosen" device-name
1A2517C 	63 68 6F 73 
1A25180 	65 6E  0 6E 61 6D 65 84 
1A25188 	 0  0 A0  1 BC 13 A2  1 
1A25190 	14  0  0  0  7  0  0  0 
   finish-device
1A25198 	 0  0  0  0  0  0  0  0 
1A251A0 	 0  0  0  0  0  0  0  0 
1A251A8 	 0  0  0  0  0  0  0  0 

   new-device				\ Node describing the firmware
1A251B0 	E0 B6 A0  1 40  7  0  0 
1A251B8 	B8 10 A2  1 E0 B6 A0  1 
1A251C0 	60  7  0  0 
      " openprom" device-name
1A251C4 	6F 70 65 6E 
1A251C8 	70 72 6F 6D  0  0  0 6E 
1A251D0 	61 6D 65 84  0  0 A0  1 
1A251D8 	BC 13 A2  1 18  0  0  0 
1A251E0 	 9  0  0  0 
      0 0 " relative-addressing" property
1A251E4 	72 65 6C 61 
1A251E8 	74 69 76 65 2D 61 64 64 
1A251F0 	72 65 73 73 69 6E 67 93 
1A251F8 	D8 51 A2  1 BC 13 A2  1 
1A25200 	 0 52 A2  1  0  0  0  0 
      0 0 " aligned-allocator"	 property
1A25208 	 0  0 61 6C 69 67 6E 65 
1A25210 	64 2D 61 6C 6C 6F 63 61 
1A25218 	74 6F 72 91 FC 51 A2  1 
1A25220 	BC 13 A2  1 24 52 A2  1 
1A25228 	 0  0  0  0 
   finish-device
1A2522C 	 0  0  0  0 
1A25230 	 0  0  0  0  0  0  0  0 
1A25238 	 0  0  0  0  0  0  0  0 
1A25240 	 0  0  0  0 

   new-device				\ Node for configuration options
1A25244 	E0 B6 A0  1 
1A25248 	64  7  0  0 B8 10 A2  1 
1A25250 	E0 B6 A0  1 84  7  0  0 
      ' options 'properties token!	\ "options" voc is node's property list
      " options" device-name
1A25258 	6F 70 74 69 6F 6E 73  0 
1A25260 	 0  0  0 6E 61 6D 65 84 
1A25268 	 0  0 A0  1 BC 13 A2  1 
1A25270 	18  0  0  0  8  0  0  0 
\ only forth \eof   zzzzzzzzzzzzzz
   finish-device
1A25278 	 0  0  0  0  0  0  0  0 
1A25280 	 0  0  0  0  0  0  0  0 
1A25288 	 0  0  0  0  0  0  0  0 

   new-device				\ Node for configuration options
1A25290 	E0 B6 A0  1 88  7  0  0 
1A25298 	B8 10 A2  1 E0 B6 A0  1 
1A252A0 	A8  7  0  0 
      ' aliases 'properties token!	\ "options" voc is node's property list
      " aliases" device-name
1A252A4 	61 6C 69 61 
1A252A8 	73 65 73  0  0  0  0 6E 
1A252B0 	61 6D 65 84  0  0 A0  1 
1A252B8 	BC 13 A2  1 18  0  0  0 
1A252C0 	 8  0  0  0 
   finish-device
1A252C4 	 0  0  0  0 
1A252C8 	 0  0  0  0  0  0  0  0 
1A252D0 	 0  0  0  0  0  0  0  0 
1A252D8 	 0  0  0  0 
device-end

headerless
\ "chosen-variable" is a convenient way to report the contents of a
\ variable in a "/chosen" property.  Example: stdout " stdout" chosen-variable
5 actions
1A252DC 	58 53 A2  1 
1A252E0 	4C 53 A2  1 3C 53 A2  1 
1A252E8 	1C 53 A2  1  5  0  0  0 
action:  token@ execute @ encode-cell over here - allot  ;   \ get
1A252F0 	90 90 90 E8 84 ED FD FF 
1A252F8 	 C 54 A0  1 98 41 A0  1 
1A25300 	5C 4C A0  1 C0 F7 A1  1 
1A25308 	54 49 A0  1 70 54 A0  1 
1A25310 	18 45 A0  1 E4 54 A0  1 
1A25318 	58 46 A0  1 
action:  token@ execute >r get-encoded-cell r> !   ;         \ set
1A2531C 	20 40 A0  1 
1A25320 	 C 54 A0  1 98 41 A0  1 
1A25328 	BC 45 A0  1 20 F8 A1  1 
1A25330 	D0 45 A0  1 54 4D A0  1 
1A25338 	58 46 A0  1 
action:  token@ execute  ;                                   \ addr
1A2533C 	20 40 A0  1 
1A25340 	 C 54 A0  1 98 41 A0  1 
1A25348 	58 46 A0  1 
action:  drop  ;
1A2534C 	20 40 A0  1 
1A25350 	30 49 A0  1 58 46 A0  1 
action:  drop  ;
1A25358 	20 40 A0  1 30 49 A0  1 
1A25360 	58 46 A0  1 

: chosen-variable  ( acf adr len -- )
1A25364 	63 68 6F 73 
1A25368 	65 6E 2D 76 61 72 69 61 
1A25370 	62 6C 65 8F C0 50 A2  1 
1A25378 	20 40 A0  1 
   " /chosen" find-device
1A2537C 	9C 53 A0  1 
1A25380 	 7 2F 63 68 6F 73 65 6E 
1A25388 	 0  0  0  0 BC 22 A2  1 
      make-property-name token, use-actions
1A25390 	18 13 A2  1 2C 55 A0  1 
1A25398 	60 53 A0  1 F0 52 A2  1 
1A253A0 	E0 57 A0  1 
   device-end
1A253A4 	94  F A2  1 
;
1A253A8 	58 46 A0  1 
action-adr-t to dochosen-variable

\ "chosen-value" is like chosen-variable, but with value semantics
\ variable in a "/chosen" property.  Example: stdout " stdout" chosen-variable
5 actions
1A253AC 	28 54 A2  1 
1A253B0 	1C 54 A2  1  8 54 A2  1 
1A253B8 	E8 53 A2  1  5  0  0  0 
action:  token@ execute encode-cell over here - allot  ;     \ get
1A253C0 	90 90 90 E8 B4 EC FD FF 
1A253C8 	 C 54 A0  1 98 41 A0  1 
1A253D0 	C0 F7 A1  1 54 49 A0  1 
1A253D8 	70 54 A0  1 18 45 A0  1 
1A253E0 	E4 54 A0  1 58 46 A0  1 
action:  token@ >r get-encoded-cell r> 1 perform-action  ;   \ set
1A253E8 	20 40 A0  1  C 54 A0  1 
1A253F0 	BC 45 A0  1 20 F8 A1  1 
1A253F8 	D0 45 A0  1 80 6F A0  1 
1A25400 	10 B8 A1  1 58 46 A0  1 
action:  token@ 2 perform-action  ;                          \ addr
1A25408 	20 40 A0  1  C 54 A0  1 
1A25410 	90 6F A0  1 10 B8 A1  1 
1A25418 	58 46 A0  1 
action:  drop  ;
1A2541C 	20 40 A0  1 
1A25420 	30 49 A0  1 58 46 A0  1 
action:  drop  ;
1A25428 	20 40 A0  1 30 49 A0  1 
1A25430 	58 46 A0  1 

: chosen-value  ( acf adr len -- )
1A25434 	 0  0  0 63 
1A25438 	68 6F 73 65 6E 2D 76 61 
1A25440 	6C 75 65 8C 78 53 A2  1 
1A25448 	20 40 A0  1 
   " /chosen" find-device
1A2544C 	9C 53 A0  1 
1A25450 	 7 2F 63 68 6F 73 65 6E 
1A25458 	 0  0  0  0 BC 22 A2  1 
      make-property-name token, use-actions
1A25460 	18 13 A2  1 2C 55 A0  1 
1A25468 	60 53 A0  1 C0 53 A2  1 
1A25470 	E0 57 A0  1 
   device-end
1A25474 	94  F A2  1 
;
1A25478 	58 46 A0  1 
action-adr-t to dochosen-value

5 actions
1A2547C 	EC 54 A2  1 
1A25480 	E0 54 A2  1 D0 54 A2  1 
1A25488 	AC 54 A2  1  5  0  0  0 
\ Add NULL at the end of the string to the length
action:  token@ execute cscount 1+ ( adr len )  ;          \ get
1A25490 	90 90 90 E8 E4 EB FD FF 
1A25498 	 C 54 A0  1 98 41 A0  1 
1A254A0 	AC DF A0  1 30 4B A0  1 
1A254A8 	58 46 A0  1 
action:  token@ execute >r cscount r> place-cstr drop  ;   \ set
1A254AC 	20 40 A0  1 
1A254B0 	 C 54 A0  1 98 41 A0  1 
1A254B8 	BC 45 A0  1 AC DF A0  1 
1A254C0 	D0 45 A0  1 B4 8A A0  1 
1A254C8 	30 49 A0  1 58 46 A0  1 
action:  token@ execute  ;                                 \ addr
1A254D0 	20 40 A0  1  C 54 A0  1 
1A254D8 	98 41 A0  1 58 46 A0  1 
action:  drop  ;
1A254E0 	20 40 A0  1 30 49 A0  1 
1A254E8 	58 46 A0  1 
action:  drop  ;
1A254EC 	20 40 A0  1 
1A254F0 	30 49 A0  1 58 46 A0  1 

: chosen-string  ( acf adr len -- )
1A254F8 	 0  0 63 68 6F 73 65 6E 
1A25500 	2D 73 74 72 69 6E 67 8D 
1A25508 	48 54 A2  1 20 40 A0  1 
   " /chosen" find-package drop  push-package
1A25510 	9C 53 A0  1  7 2F 63 68 
1A25518 	6F 73 65 6E  0  0  0  0 
1A25520 	E0 39 A2  1 30 49 A0  1 
1A25528 	7C FB A1  1 
      make-property-name token, use-actions
1A2552C 	18 13 A2  1 
1A25530 	2C 55 A0  1 60 53 A0  1 
1A25538 	90 54 A2  1 E0 57 A0  1 
   pop-package
1A25540 	D8 FB A1  1 
;
1A25544 	58 46 A0  1 
action-adr-t to dochosen-string

headers

\ From console.fth
purpose: Implements console character I/O

\ Input and output selection mechanism

headers
nuser stdin   0 stdin !
1A25548 	 0  0 73 74 64 69 6E 85 
1A25550 	 C 55 A2  1 48 40 A0  1 
1A25558 	AC  7  0  0 
nuser stdout  0 stdout !
1A2555C 	 0 73 74 64 
1A25560 	6F 75 74 86 54 55 A2  1 
1A25568 	48 40 A0  1 B0  7  0  0 

headerless
nuser pending-char
1A25570 	 0  0  0 70 65 6E 64 69 
1A25578 	6E 67 2D 63 68 61 72 8C 
1A25580 	68 55 A2  1 48 40 A0  1 
1A25588 	B4  7  0  0 
nuser char-pending?
1A2558C 	 0  0 63 68 
1A25590 	61 72 2D 70 65 6E 64 69 
1A25598 	6E 67 3F 8D 84 55 A2  1 
1A255A0 	48 40 A0  1 B8  7  0  0 

\ mmo defer stdin-idle  ' noop is stdin-idle  \ Hook for power savings

: "read"   ( -- adr len )  " read"   ;	\ Space savings
1A255A8 	 0 22 72 65 61 64 22 86 
1A255B0 	A0 55 A2  1 20 40 A0  1 
1A255B8 	9C 53 A0  1  4 72 65 61 
1A255C0 	64  0  0  0 58 46 A0  1 
: "write"  ( -- adr len )  " write"  ;	\ Space savings
1A255C8 	22 77 72 69 74 65 22 87 
1A255D0 	B4 55 A2  1 20 40 A0  1 
1A255D8 	9C 53 A0  1  5 77 72 69 
1A255E0 	74 65  0  0 58 46 A0  1 
: stdin-getchar  ( -- okay? )
1A255E8 	 0  0 73 74 64 69 6E 2D 
1A255F0 	67 65 74 63 68 61 72 8D 
1A255F8 	D4 55 A2  1 20 40 A0  1 
   pending-char 1  "read" stdin @ $call-method  1 =
1A25600 	84 55 A2  1 80 6F A0  1 
1A25608 	B4 55 A2  1 54 55 A2  1 
1A25610 	5C 4C A0  1 B4 31 A2  1 
1A25618 	80 6F A0  1 24 48 A0  1 
;
1A25620 	58 46 A0  1 
: console-key?  ( -- flag )
1A25624 	 0  0  0 63 
1A25628 	6F 6E 73 6F 6C 65 2D 6B 
1A25630 	65 79 3F 8C FC 55 A2  1 
1A25638 	20 40 A0  1 
   char-pending? @  if
1A2563C 	A0 55 A2  1 
1A25640 	5C 4C A0  1 DC 41 A0  1 
1A25648 	10  0  0  0 
      true
1A2564C 	 4 70 A0  1 
   else
1A25650 	C8 41 A0  1 1C  0  0  0 
      stdin-getchar dup  if  char-pending? on  then  ( flag )
1A25658 	FC 55 A2  1 40 49 A0  1 
1A25660 	DC 41 A0  1  C  0  0  0 
1A25668 	A0 55 A2  1 E0 4B A0  1 
   then
;
1A25670 	58 46 A0  1 
: console-key  ( -- char )
1A25674 	63 6F 6E 73 
1A25678 	6F 6C 65 2D 6B 65 79 8B 
1A25680 	38 56 A2  1 20 40 A0  1 
   char-pending? @  if
1A25688 	A0 55 A2  1 5C 4C A0  1 
1A25690 	DC 41 A0  1 1C  0  0  0 
      pending-char c@  char-pending? off
1A25698 	84 55 A2  1 C4 4C A0  1 
1A256A0 	A0 55 A2  1 F8 4B A0  1 
   else
1A256A8 	C8 41 A0  1 18  0  0  0 
      begin
         stdin-getchar
1A256B0 	FC 55 A2  1 
\ mmo         dup 0=  if  stdin-idle  then
      until
1A256B4 	DC 41 A0  1 
1A256B8 	F8 FF FF FF 
      pending-char c@
1A256BC 	84 55 A2  1 
1A256C0 	C4 4C A0  1 
   then
;
1A256C4 	58 46 A0  1 
nuser temp-char
1A256C8 	 0  0 74 65 6D 70 2D 63 
1A256D0 	68 61 72 89 84 56 A2  1 
1A256D8 	48 40 A0  1 BC  7  0  0 
: console-type  ( adr len -- )  "write" stdout @ $call-method  drop  ;
1A256E0 	 0  0  0 63 6F 6E 73 6F 
1A256E8 	6C 65 2D 74 79 70 65 8C 
1A256F0 	D8 56 A2  1 20 40 A0  1 
1A256F8 	D4 55 A2  1 68 55 A2  1 
1A25700 	5C 4C A0  1 B4 31 A2  1 
1A25708 	30 49 A0  1 58 46 A0  1 
: console-emit  ( char -- )  temp-char c!  temp-char 1 console-type  ;
1A25710 	 0  0  0 63 6F 6E 73 6F 
1A25718 	6C 65 2D 65 6D 69 74 8C 
1A25720 	F4 56 A2  1 20 40 A0  1 
1A25728 	D8 56 A2  1 B8 4D A0  1 
1A25730 	D8 56 A2  1 80 6F A0  1 
1A25738 	F4 56 A2  1 58 46 A0  1 

\ close the device if it is not the stdout device.
: ?close  ( ihandle|0 -- )
1A25740 	 0 3F 63 6C 6F 73 65 86 
1A25748 	24 57 A2  1 20 40 A0  1 
   ?dup  if
1A25750 	B4 70 A0  1 DC 41 A0  1 
1A25758 	2C  0  0  0 
      stdout @  over  <>  if  close-dev  else  drop  then
1A2575C 	68 55 A2  1 
1A25760 	5C 4C A0  1 54 49 A0  1 
1A25768 	44 48 A0  1 DC 41 A0  1 
1A25770 	10  0  0  0 5C 37 A2  1 
1A25778 	C8 41 A0  1  8  0  0  0 
1A25780 	30 49 A0  1 
   then
;
1A25784 	58 46 A0  1 
: has-method?  ( method-adr,len phandle -- flag )
1A25788 	68 61 73 2D 6D 65 74 68 
1A25790 	6F 64 3F 8B 4C 57 A2  1 
1A25798 	20 40 A0  1 
   find-method  dup  if  nip  then  ( flag )
1A2579C 	A0 2F A2  1 
1A257A0 	40 49 A0  1 DC 41 A0  1 
1A257A8 	 8  0  0  0 FC 46 A0  1 
;
1A257B0 	58 46 A0  1 
: .missing  ( routine-adr,len type-adr,len -- )
1A257B4 	 0  0  0 2E 
1A257B8 	6D 69 73 73 69 6E 67 88 
1A257C0 	98 57 A2  1 20 40 A0  1 
   ." The selected " type ."  device has no " type  ."  routine" cr
1A257C8 	20 7C A0  1  D 54 68 65 
1A257D0 	20 73 65 6C 65 63 74 65 
1A257D8 	64 20  0  0  4 6C A0  1 
1A257E0 	20 7C A0  1  F 20 64 65 
1A257E8 	76 69 63 65 20 68 61 73 
1A257F0 	20 6E 6F 20  0  0  0  0 
1A257F8 	 4 6C A0  1 20 7C A0  1 
1A25800 	 8 20 72 6F 75 74 69 6E 
1A25808 	65  0  0  0 80 6D A0  1 
;
1A25810 	58 46 A0  1 

: pihandle=  ( phandle ihandle -- flag )
1A25814 	 0  0 70 69 
1A25818 	68 61 6E 64 6C 65 3D 89 
1A25820 	C4 57 A2  1 20 40 A0  1 
   dup  if  ihandle>phandle =  else  2drop false  then
1A25828 	40 49 A0  1 DC 41 A0  1 
1A25830 	14  0  0  0  0 32 A2  1 
1A25838 	24 48 A0  1 C8 41 A0  1 
1A25840 	 C  0  0  0 AC 49 A0  1 
1A25848 	18 70 A0  1 
;
1A2584C 	58 46 A0  1 

: chosen-cell-property  ( n name-str -- )
1A25850 	 0  0  0 63 68 6F 73 65 
1A25858 	6E 2D 63 65 6C 6C 2D 70 
1A25860 	72 6F 70 65 72 74 79 94 
1A25868 	24 58 A2  1 20 40 A0  1 
   " /chosen" find-device
1A25870 	9C 53 A0  1  7 2F 63 68 
1A25878 	6F 73 65 6E  0  0  0  0 
1A25880 	BC 22 A2  1 
   \ XXX this eats up some space every time it's called ...
   \ We really want "set-encoded-cell"
      rot encode-cell  2swap (property)
1A25884 	7C 49 A0  1 
1A25888 	C0 F7 A1  1 F4 49 A0  1 
1A25890 	24 14 A2  1 
   device-end
1A25894 	94  F A2  1 
;
1A25898 	58 46 A0  1 
: set-stdin  ( ihandle -- )
1A2589C 	 0  0 73 65 
1A258A0 	74 2D 73 74 64 69 6E 89 
1A258A8 	6C 58 A2  1 20 40 A0  1 
   stdin @  swap stdin !			( old-ihandle )
1A258B0 	54 55 A2  1 5C 4C A0  1 
1A258B8 	68 49 A0  1 54 55 A2  1 
1A258C0 	54 4D A0  1 
   stdin @  " stdin" chosen-cell-property
1A258C4 	54 55 A2  1 
1A258C8 	5C 4C A0  1 9C 53 A0  1 
1A258D0 	 5 73 74 64 69 6E  0  0 
1A258D8 	6C 58 A2  1 

   " install-abort" stdin @ $call-method	( old-ihandle )
1A258DC 	9C 53 A0  1 
1A258E0 	 D 69 6E 73 74 61 6C 6C 
1A258E8 	2D 61 62 6F 72 74  0  0 
1A258F0 	54 55 A2  1 5C 4C A0  1 
1A258F8 	B4 31 A2  1 
   ?dup  if 					( old-ihandle )
1A258FC 	B4 70 A0  1 
1A25900 	DC 41 A0  1 28  0  0  0 
      " remove-abort" 2 pick $call-method	( old-ihandle )
1A25908 	9C 53 A0  1  C 72 65 6D 
1A25910 	6F 76 65 2D 61 62 6F 72 
1A25918 	74  0  0  0 90 6F A0  1 
1A25920 	 C 4A A0  1 B4 31 A2  1 
      close-dev
1A25928 	5C 37 A2  1 
   then
;
1A2592C 	58 46 A0  1 
headers
: input  ( pathname-adr,len -- )
1A25930 	 0  0 69 6E 70 75 74 85 
1A25938 	AC 58 A2  1 20 40 A0  1 
   2dup locate-device  if
1A25940 	C0 49 A0  1 EC 21 A2  1 
1A25948 	DC 41 A0  1 2C  0  0  0 
      type ."  not found." cr  exit
1A25950 	 4 6C A0  1 20 7C A0  1 
1A25958 	 B 20 6E 6F 74 20 66 6F 
1A25960 	75 6E 64 2E  0  0  0  0 
1A25968 	80 6D A0  1 40 46 A0  1 
   else				      ( pathname-adr,len phandle )
1A25970 	C8 41 A0  1 A0  0  0  0 
      dup stdin @ pihandle=  if  3drop exit  then  \ Same device?
1A25978 	40 49 A0  1 54 55 A2  1 
1A25980 	5C 4C A0  1 24 58 A2  1 
1A25988 	DC 41 A0  1  C  0  0  0 
1A25990 	90 52 A0  1 40 46 A0  1 
      "read" rot has-method?  if      ( pathname-adr,len )
1A25998 	B4 55 A2  1 7C 49 A0  1 
1A259A0 	98 57 A2  1 DC 41 A0  1 
1A259A8 	50  0  0  0 
	 open-dev ?dup  if				( ihandle )
1A259AC 	FC 3E A2  1 
1A259B0 	B4 70 A0  1 DC 41 A0  1 
1A259B8 	10  0  0  0 
            set-stdin
1A259BC 	AC 58 A2  1 
	 else
1A259C0 	C8 41 A0  1 2C  0  0  0 
	    ." Can't open input device." cr  exit
1A259C8 	20 7C A0  1 18 43 61 6E 
1A259D0 	27 74 20 6F 70 65 6E 20 
1A259D8 	69 6E 70 75 74 20 64 65 
1A259E0 	76 69 63 65 2E  0  0  0 
1A259E8 	80 6D A0  1 40 46 A0  1 
	 then
      else			      ( pathname-adr,len )
1A259F0 	C8 41 A0  1 20  0  0  0 
	 2drop  "read" " input" .missing  exit
1A259F8 	AC 49 A0  1 B4 55 A2  1 
1A25A00 	9C 53 A0  1  5 69 6E 70 
1A25A08 	75 74  0  0 C4 57 A2  1 
1A25A10 	40 46 A0  1 
      then
   then
;
1A25A14 	58 46 A0  1 

variable stdout-#lines		\ For communication with client program
1A25A18 	 0  0 73 74 64 6F 75 74 
1A25A20 	2D 23 6C 69 6E 65 73 8D 
1A25A28 	3C 59 A2  1 48 40 A0  1 
1A25A30 	C0  7  0  0 

' stdout-#lines  " stdout-#lines" mmochosen-variable
1A25A34 	 0  0 73 74 
1A25A38 	64 6F 75 74 2D 23 6C 69 
1A25A40 	6E 65 73 8D 8C 51 A2  1 
1A25A48 	F0 52 A2  1 2C 5A A2  1 

variable termemu-#lines		\ For communication with terminal emulator
1A25A50 	 0 74 65 72 6D 65 6D 75 
1A25A58 	2D 23 6C 69 6E 65 73 8E 
1A25A60 	2C 5A A2  1 48 40 A0  1 
1A25A68 	C4  7  0  0 

\ Set #lines in /chosen node for client programs to read
: report-#lines  ( -- )
1A25A6C 	 0  0 72 65 
1A25A70 	70 6F 72 74 2D 23 6C 69 
1A25A78 	6E 65 73 8D 64 5A A2  1 
1A25A80 	20 40 A0  1 
   termemu-#lines @ -1 <>  if   ( #lines )
1A25A84 	64 5A A2  1 
1A25A88 	5C 4C A0  1 58 41 A0  1 
1A25A90 	FF FF FF FF 44 48 A0  1 
1A25A98 	DC 41 A0  1 14  0  0  0 
      \ The terminal emulator package set termemu-#lines
      termemu-#lines @		( #lines )
1A25AA0 	64 5A A2  1 5C 4C A0  1 
   else                         ( #lines )
1A25AA8 	C8 41 A0  1 3C  0  0  0 

      \ termemu-#lines was not set, so check for a "#lines" property
      \ in the output device's package.

      " #lines"  stdout @ ihandle>phandle  get-package-property  if  ( )
1A25AB0 	9C 53 A0  1  6 23 6C 69 
1A25AB8 	6E 65 73  0 68 55 A2  1 
1A25AC0 	5C 4C A0  1  0 32 A2  1 
1A25AC8 	98 33 A2  1 DC 41 A0  1 
1A25AD0 	14  0  0  0 
         \ No "#lines" property; report "unknown"
         -1			( unknown-#lines )
1A25AD4 	58 41 A0  1 
1A25AD8 	FF FF FF FF 
      else			( adr len )
1A25ADC 	C8 41 A0  1 
1A25AE0 	 8  0  0  0 
         \ Report the value of the "#lines" property
         get-encoded-cell	( #lines )
1A25AE4 	20 F8 A1  1 
      then                      ( #lines )
   then                         ( #lines )
   stdout-#lines  !
1A25AE8 	2C 5A A2  1 54 4D A0  1 
;
1A25AF0 	58 46 A0  1 
: set-stdout  ( ihandle -- )
1A25AF4 	 0 73 65 74 
1A25AF8 	2D 73 74 64 6F 75 74 8A 
1A25B00 	80 5A A2  1 20 40 A0  1 
   stdout @  swap stdout !	( old-ihandle )
1A25B08 	68 55 A2  1 5C 4C A0  1 
1A25B10 	68 49 A0  1 68 55 A2  1 
1A25B18 	54 4D A0  1 
   ?close
1A25B1C 	4C 57 A2  1 
   stdout @  " stdout" chosen-cell-property
1A25B20 	68 55 A2  1 5C 4C A0  1 
1A25B28 	9C 53 A0  1  6 73 74 64 
1A25B30 	6F 75 74  0 6C 58 A2  1 
   report-#lines
1A25B38 	80 5A A2  1 
;
1A25B3C 	58 46 A0  1 
: output  ( pathname-adr,len -- )
1A25B40 	 0 6F 75 74 70 75 74 86 
1A25B48 	 4 5B A2  1 20 40 A0  1 
   2dup locate-device  if               ( pathname-adr,len )
1A25B50 	C0 49 A0  1 EC 21 A2  1 
1A25B58 	DC 41 A0  1 2C  0  0  0 
      type ."  not found." cr  exit
1A25B60 	 4 6C A0  1 20 7C A0  1 
1A25B68 	 B 20 6E 6F 74 20 66 6F 
1A25B70 	75 6E 64 2E  0  0  0  0 
1A25B78 	80 6D A0  1 40 46 A0  1 
   else					( pathname-adr,len phandle )
1A25B80 	C8 41 A0  1 DC  0  0  0 
      dup stdout @ pihandle=  if  3drop exit  then   \ Same device?
1A25B88 	40 49 A0  1 68 55 A2  1 
1A25B90 	5C 4C A0  1 24 58 A2  1 
1A25B98 	DC 41 A0  1  C  0  0  0 
1A25BA0 	90 52 A0  1 40 46 A0  1 
      "write" rot has-method?  if	( pathname-adr,len )
1A25BA8 	D4 55 A2  1 7C 49 A0  1 
1A25BB0 	98 57 A2  1 DC 41 A0  1 
1A25BB8 	8C  0  0  0 
         -1 termemu-#lines !	\ Set value for terminal emulator to change
1A25BBC 	58 41 A0  1 
1A25BC0 	FF FF FF FF 64 5A A2  1 
1A25BC8 	54 4D A0  1 
         \ Set behavior of "light" to default value, remembering the old
         \ value so we can restore it if the open fails.
         ['] light behavior -rot        ( xt pathname-adr,len )
1A25BCC 	60 53 A0  1 
1A25BD0 	18 F8 A0  1 10 C7 A0  1 
1A25BD8 	94 49 A0  1 
         ['] cancel to light            ( xt pathname-adr,len )
1A25BDC 	60 53 A0  1 
1A25BE0 	BC F7 A0  1 98 40 A0  1 
1A25BE8 	18 F8 A0  1 
	 open-dev ?dup  if		( xt ihandle )
1A25BEC 	FC 3E A2  1 
1A25BF0 	B4 70 A0  1 DC 41 A0  1 
1A25BF8 	14  0  0  0 
            \ If a different behavior for "light" is appropriate, it will
            \ have been established during "open-dev" (e.g. by fb8-install)
            nip                         ( ihandle )
1A25BFC 	FC 46 A0  1 
	    set-stdout
1A25C00 	 4 5B A2  1 
	 else                           ( xt )
1A25C04 	C8 41 A0  1 
1A25C08 	34  0  0  0 
            to light                    ( )
1A25C0C 	98 40 A0  1 
1A25C10 	18 F8 A0  1 
	    ." Can't open output device." cr  exit
1A25C14 	20 7C A0  1 
1A25C18 	19 43 61 6E 27 74 20 6F 
1A25C20 	70 65 6E 20 6F 75 74 70 
1A25C28 	75 74 20 64 65 76 69 63 
1A25C30 	65 2E  0  0 80 6D A0  1 
1A25C38 	40 46 A0  1 
	 then
      else                             ( pathname-adr,len )
1A25C3C 	C8 41 A0  1 
1A25C40 	20  0  0  0 
	 2drop  "write" " output" .missing  exit
1A25C44 	AC 49 A0  1 
1A25C48 	D4 55 A2  1 9C 53 A0  1 
1A25C50 	 6 6F 75 74 70 75 74  0 
1A25C58 	C4 57 A2  1 40 46 A0  1 
      then
   then
;
1A25C60 	58 46 A0  1 

: io  ( pathname-adr,len -- )
1A25C64 	 0 69 6F 82 
1A25C68 	4C 5B A2  1 20 40 A0  1 
   2dup input
1A25C70 	C0 49 A0  1 3C 59 A2  1 
   output
1A25C78 	4C 5B A2  1 
; 
1A25C7C 	58 46 A0  1 

\ For compatibility with Campus PROMs; allows you to type, for instance,
\ "keyboard input"
: keyboard   ( -- adr len )  " keyboard"  ;
1A25C80 	 0  0  0 6B 65 79 62 6F 
1A25C88 	61 72 64 88 6C 5C A2  1 
1A25C90 	20 40 A0  1 9C 53 A0  1 
1A25C98 	 8 6B 65 79 62 6F 61 72 
1A25CA0 	64  0  0  0 58 46 A0  1 
: screen     ( -- adr len )  " screen"  ;
1A25CA8 	 0 73 63 72 65 65 6E 86 
1A25CB0 	90 5C A2  1 20 40 A0  1 
1A25CB8 	9C 53 A0  1  6 73 63 72 
1A25CC0 	65 65 6E  0 58 46 A0  1 
: ttya       ( -- adr len )  " ttya"  ;
1A25CC8 	 0  0  0 74 74 79 61 84 
1A25CD0 	B4 5C A2  1 20 40 A0  1 
1A25CD8 	9C 53 A0  1  4 74 74 79 
1A25CE0 	61  0  0  0 58 46 A0  1 
: ttyb       ( -- adr len )  " ttyb"  ;
1A25CE8 	 0  0  0 74 74 79 62 84 
1A25CF0 	D4 5C A2  1 20 40 A0  1 
1A25CF8 	9C 53 A0  1  4 74 74 79 
1A25D00 	62  0  0  0 58 46 A0  1 

: console-io  ( -- )
1A25D08 	 0 63 6F 6E 73 6F 6C 65 
1A25D10 	2D 69 6F 8A F4 5C A2  1 
1A25D18 	20 40 A0  1 
   stdin  @ 0<>
1A25D1C 	54 55 A2  1 
1A25D20 	5C 4C A0  1 44 47 A0  1 
   stdout @ 0<>  and  if
1A25D28 	68 55 A2  1 5C 4C A0  1 
1A25D30 	44 47 A0  1 5C 44 A0  1 
1A25D38 	DC 41 A0  1 4C  0  0  0 
      char-pending? off
1A25D40 	A0 55 A2  1 F8 4B A0  1 
      ['] console-key?  is key?
1A25D48 	60 53 A0  1 38 56 A2  1 
1A25D50 	98 40 A0  1 64 6C A0  1 
      ['] console-key   is (key
1A25D58 	60 53 A0  1 84 56 A2  1 
1A25D60 	98 40 A0  1 40 6C A0  1 
      ['] console-emit  is (emit
1A25D68 	60 53 A0  1 24 57 A2  1 
1A25D70 	98 40 A0  1 18 6C A0  1 
      ['] console-type  is (type
1A25D78 	60 53 A0  1 F4 56 A2  1 
1A25D80 	98 40 A0  1 F0 6B A0  1 
   then
;
1A25D88 	58 46 A0  1 
: ks-io  ( -- )  keyboard input  screen output  ;
1A25D8C 	 0  0 6B 73 
1A25D90 	2D 69 6F 85 18 5D A2  1 
1A25D98 	20 40 A0  1 90 5C A2  1 
1A25DA0 	3C 59 A2  1 B4 5C A2  1 
1A25DA8 	4C 5B A2  1 58 46 A0  1 
: use-ks  ( -- )
1A25DB0 	 0 75 73 65 2D 6B 73 86 
1A25DB8 	98 5D A2  1 20 40 A0  1 
   " keyboard" " input-device" $setenv
1A25DC0 	9C 53 A0  1  8 6B 65 79 
1A25DC8 	62 6F 61 72 64  0  0  0 
1A25DD0 	9C 53 A0  1  C 69 6E 70 
1A25DD8 	75 74 2D 64 65 76 69 63 
1A25DE0 	65  0  0  0 C4 F1 A1  1 
   " screen" " output-device" $setenv
1A25DE8 	9C 53 A0  1  6 73 63 72 
1A25DF0 	65 65 6E  0 9C 53 A0  1 
1A25DF8 	 D 6F 75 74 70 75 74 2D 
1A25E00 	64 65 76 69 63 65  0  0 
1A25E08 	C4 F1 A1  1 
;
1A25E0C 	58 46 A0  1 

\ From execall.fth
purpose: 

headerless

defer the-action    ( phandle -- )
1A25E10 	 0 74 68 65 2D 61 63 74 
1A25E18 	69 6F 6E 8A BC 5D A2  1 
1A25E20 	5C 40 A0  1 C8  7  0  0 
: execute-action  ( -- false )
1A25E28 	 0 65 78 65 63 75 74 65 
1A25E30 	2D 61 63 74 69 6F 6E 8E 
1A25E38 	20 5E A2  1 20 40 A0  1 
   current-device >r  the-action  false  r> push-device
1A25E40 	40 F9 A1  1 BC 45 A0  1 
1A25E48 	20 5E A2  1 18 70 A0  1 
1A25E50 	D0 45 A0  1 F8 FB A1  1 
;
1A25E58 	58 46 A0  1 

\ "action-acf" is executed for each device node in the subtree
\ rooted at dev-addr,len , with current-device set to the
\ node in question.  "action-acf" can perform arbitrary tests
\ on the node to determine if that node is appropriate for
\ the action that it wished to undertake.

: scan-subtree  ( dev-addr,len action-acf -- )
1A25E5C 	 0  0  0 73 
1A25E60 	63 61 6E 2D 73 75 62 74 
1A25E68 	72 65 65 8C 3C 5E A2  1 
1A25E70 	20 40 A0  1 
   current-device >r                ( dev-addr,len action-acf r: phandle )
1A25E74 	40 F9 A1  1 
1A25E78 	BC 45 A0  1 
   ['] the-action behavior >r       ( dev-addr,len action-acf r: phandle xt )
1A25E7C 	60 53 A0  1 
1A25E80 	20 5E A2  1 10 C7 A0  1 
1A25E88 	BC 45 A0  1 
   is the-action                    ( dev-addr,len r: phandle xt )
1A25E8C 	98 40 A0  1 
1A25E90 	20 5E A2  1 
   find-device                      ( r: phandle xt )
1A25E94 	BC 22 A2  1 
   ['] execute-action  ['] (search-preorder)  catch  2drop  ( r: phandle xt )
1A25E98 	60 53 A0  1 3C 5E A2  1 
1A25EA0 	60 53 A0  1 24 17 A2  1 
1A25EA8 	14 7F A0  1 AC 49 A0  1 
   r> is the-action r> push-device  ( )
1A25EB0 	D0 45 A0  1 98 40 A0  1 
1A25EB8 	20 5E A2  1 D0 45 A0  1 
1A25EC0 	F8 FB A1  1 
;
1A25EC4 	58 46 A0  1 

headerless

2variable method-name
1A25EC8 	6D 65 74 68 6F 64 2D 6E 
1A25ED0 	61 6D 65 8B 70 5E A2  1 
1A25ED8 	48 40 A0  1 CC  7  0  0 

\ do-method? is an action routine for "scan-subtree" that is used
\ by execute-all-methods.  For each device node, excluding the current
\ output device, that has a method whose name is given by method-name ,
\ that method is executed.

false value verbose-do-method?
1A25EE0 	 0 76 65 72 62 6F 73 65 
1A25EE8 	2D 64 6F 2D 6D 65 74 68 
1A25EF0 	6F 64 3F 92 D8 5E A2  1 
1A25EF8 	50 40 A0  1 D4  7  0  0 

: do-method?  ( -- )
1A25F00 	 0 64 6F 2D 6D 65 74 68 
1A25F08 	6F 64 3F 8A F8 5E A2  1 
1A25F10 	20 40 A0  1 
   method-name 2@  current-device phandle>voc (search-wordlist)  if  ( xt )
1A25F14 	D8 5E A2  1 
1A25F18 	CC 4D A0  1 40 F9 A1  1 
1A25F20 	58 F8 A1  1  0 BB A0  1 
1A25F28 	DC 41 A0  1 38  0  0  0 
      drop  pwd$                               ( path-adr,len )
1A25F30 	30 49 A0  1 F0 4D A2  1 
      verbose-do-method?  if  2dup type cr  then
1A25F38 	F8 5E A2  1 DC 41 A0  1 
1A25F40 	10  0  0  0 C0 49 A0  1 
1A25F48 	 4 6C A0  1 80 6D A0  1 
      method-name 2@  execute-device-method drop cr  (  )
1A25F50 	D8 5E A2  1 CC 4D A0  1 
1A25F58 	84 3F A2  1 30 49 A0  1 
1A25F60 	80 6D A0  1 
   then                                              (  )
;   
1A25F64 	58 46 A0  1 

headers

: execute-all-methods  ( dev-addr,len method-adr,len -- )
1A25F68 	65 78 65 63 75 74 65 2D 
1A25F70 	61 6C 6C 2D 6D 65 74 68 
1A25F78 	6F 64 73 93 10 5F A2  1 
1A25F80 	20 40 A0  1 
   method-name 2!
1A25F84 	D8 5E A2  1 
1A25F88 	E4 4D A0  1 
   ['] do-method?  scan-subtree
1A25F8C 	60 53 A0  1 
1A25F90 	10 5F A2  1 70 5E A2  1 
;
1A25F98 	58 46 A0  1 

: flush-keyboard  ( -- )  begin  key?  while  key drop  repeat  ;
1A25F9C 	 0 66 6C 75 
1A25FA0 	73 68 2D 6B 65 79 62 6F 
1A25FA8 	61 72 64 8E 80 5F A2  1 
1A25FB0 	20 40 A0  1 64 6C A0  1 
1A25FB8 	DC 41 A0  1 14  0  0  0 
1A25FC0 	50 6C A0  1 30 49 A0  1 
1A25FC8 	C8 41 A0  1 E8 FF FF FF 
1A25FD0 	58 46 A0  1 
defer pause-message ( decisecs -- decisecs' )  ' noop to pause-message
1A25FD4 	 0  0 70 61 
1A25FD8 	75 73 65 2D 6D 65 73 73 
1A25FE0 	61 67 65 8D B0 5F A2  1 
1A25FE8 	5C 40 A0  1 D8  7  0  0 
defer hold-message
1A25FF0 	 0  0  0 68 6F 6C 64 2D 
1A25FF8 	6D 65 73 73 61 67 65 8C 
1A26000 	E8 5F A2  1 5C 40 A0  1 
1A26008 	DC  7  0  0 
: (hold-message)  ( ms -- exit? )
1A2600C 	 0 28 68 6F 
1A26010 	6C 64 2D 6D 65 73 73 61 
1A26018 	67 65 29 8E  4 60 A2  1 
1A26020 	20 40 A0  1 
   flush-keyboard
1A26024 	B0 5F A2  1 
   d# 100 /                                              ( decisecs )
1A26028 	58 41 A0  1 64  0  0  0 
1A26030 	98 5F A0  1 
   begin  dup  while                                     ( decisecs )
1A26034 	40 49 A0  1 
1A26038 	DC 41 A0  1 AC  0  0  0 
      dup d# 10 /mod  swap  if  drop  else  (cr .d  then ( decisecs )
1A26040 	40 49 A0  1 58 41 A0  1 
1A26048 	 A  0  0  0 50 5F A0  1 
1A26050 	68 49 A0  1 DC 41 A0  1 
1A26058 	10  0  0  0 30 49 A0  1 
1A26060 	C8 41 A0  1  C  0  0  0 
1A26068 	9C 72 A0  1 48  E A1  1 
      d# 100 ms   1-                                     ( decisecs' )
1A26070 	58 41 A0  1 64  0  0  0 
1A26078 	60 E0 A1  1 54 4B A0  1 
      pause-message                                      ( decisecs )
1A26080 	E8 5F A2  1 
      key?  if                                           ( decisecs )
1A26084 	64 6C A0  1 
1A26088 	DC 41 A0  1 54  0  0  0 
         key h# 1b =  if                                 ( decisecs )
1A26090 	50 6C A0  1 58 41 A0  1 
1A26098 	1B  0  0  0 24 48 A0  1 
1A260A0 	DC 41 A0  1 3C  0  0  0 
	    cr ." Selftest stopped from keyboard" cr     ( decisecs )
1A260A8 	80 6D A0  1 20 7C A0  1 
1A260B0 	1E 53 65 6C 66 74 65 73 
1A260B8 	74 20 73 74 6F 70 70 65 
1A260C0 	64 20 66 72 6F 6D 20 6B 
1A260C8 	65 79 62 6F 61 72 64  0 
1A260D0 	80 6D A0  1 
	    drop true  exit                              ( -- true )
1A260D4 	30 49 A0  1 
1A260D8 	 4 70 A0  1 40 46 A0  1 
	 then                                            ( decisecs )
      then                                               ( decisecs )
   repeat                                                ( decisecs )
1A260E0 	C8 41 A0  1 50 FF FF FF 
   drop  false                                           ( false )
1A260E8 	30 49 A0  1 18 70 A0  1 
;
1A260F0 	58 46 A0  1 
' (hold-message) to hold-message

: most-tests  ( -- exit? )
1A260F4 	 0 6D 6F 73 
1A260F8 	74 2D 74 65 73 74 73 8A 
1A26100 	20 60 A2  1 20 40 A0  1 
   " selftest"  current-device phandle>voc (search-wordlist)  if   ( xt )
1A26108 	9C 53 A0  1  8 73 65 6C 
1A26110 	66 74 65 73 74  0  0  0 
1A26118 	40 F9 A1  1 58 F8 A1  1 
1A26120 	 0 BB A0  1 DC 41 A0  1 
1A26128 	40  1  0  0 

      drop                                              ( )
1A2612C 	30 49 A0  1 

      \ We only want to execute the selftest routine if the device has
      \ a "reg" property.  This eliminates the execution of selftest
      \ routines for "wildcard" devices like st and sd.

      " reg"  get-property  if  false exit  then 2drop  ( )
1A26130 	9C 53 A0  1  3 72 65 67 
1A26138 	 0  0  0  0 F4  D A2  1 
1A26140 	DC 41 A0  1  C  0  0  0 
1A26148 	18 70 A0  1 40 46 A0  1 
1A26150 	AC 49 A0  1 

      \ We sometimes want to skip the testing of certain devices.
      current-device skip-test?  if  false exit  then   ( )
1A26154 	40 F9 A1  1 
1A26158 	50 42 A2  1 DC 41 A0  1 
1A26160 	 C  0  0  0 18 70 A0  1 
1A26168 	40 46 A0  1 

      ??cr ." Testing "  pwd
1A2616C 	 0 A1 A0  1 
1A26170 	20 7C A0  1  8 54 65 73 
1A26178 	74 69 6E 67 20  0  0  0 
1A26180 	D0 2B A2  1 
      " selftest"  current-device                 ( method-adr,len phandle )
1A26184 	9C 53 A0  1 
1A26188 	 8 73 65 6C 66 74 65 73 
1A26190 	74  0  0  0 40 F9 A1  1 
      execute-phandle-method  if                  ( result )
1A26198 	68 46 A2  1 DC 41 A0  1 
1A261A0 	84  0  0  0 
         ?dup  if
1A261A4 	B4 70 A0  1 
1A261A8 	DC 41 A0  1 50  0  0  0 
            red-letters
1A261B0 	A4 F9 A0  1 
            ??cr ." Selftest failed. Return code = " .d cr
1A261B4 	 0 A1 A0  1 
1A261B8 	20 7C A0  1 1F 53 65 6C 
1A261C0 	66 74 65 73 74 20 66 61 
1A261C8 	69 6C 65 64 2E 20 52 65 
1A261D0 	74 75 72 6E 20 63 6F 64 
1A261D8 	65 20 3D 20  0  0  0  0 
1A261E0 	48  E A1  1 80 6D A0  1 
            cancel
1A261E8 	BC F7 A0  1 
            d# 10000                              ( delay-ms )
1A261EC 	58 41 A0  1 
1A261F0 	10 27  0  0 
         else
1A261F4 	C8 41 A0  1 
1A261F8 	24  0  0  0 
            green-letters
1A261FC 	C0 F9 A0  1 
            ." Okay" cr
1A26200 	20 7C A0  1  4 4F 6B 61 
1A26208 	79  0  0  0 80 6D A0  1 
            cancel
1A26210 	BC F7 A0  1 
            d# 2000                               ( delay-ms )
1A26214 	58 41 A0  1 
1A26218 	D0  7  0  0 
         then                                     ( delay-ms )
      else
1A2621C 	C8 41 A0  1 
1A26220 	3C  0  0  0 
         red-letters
1A26224 	A4 F9 A0  1 
         ." Selftest failed due to abort"  cr
1A26228 	20 7C A0  1 1C 53 65 6C 
1A26230 	66 74 65 73 74 20 66 61 
1A26238 	69 6C 65 64 20 64 75 65 
1A26240 	20 74 6F 20 61 62 6F 72 
1A26248 	74  0  0  0 80 6D A0  1 
         cancel
1A26250 	BC F7 A0  1 
         d# 10000                                 ( delay-ms )
1A26254 	58 41 A0  1 
1A26258 	10 27  0  0 
      then                                        ( delay-ms )
      hold-message                                ( exit? )
1A2625C 	 4 60 A2  1 
   else
1A26260 	C8 41 A0  1  8  0  0  0 
      false                                       ( exit? )
1A26268 	18 70 A0  1 
   then                                           ( exit? )
;
1A2626C 	58 46 A0  1 

: test-subtree  ( dev-addr,len -- )
1A26270 	 0  0  0 74 65 73 74 2D 
1A26278 	73 75 62 74 72 65 65 8C 
1A26280 	 4 61 A2  1 20 40 A0  1 
   current-device >r                ( dev-addr,len r: phandle )
1A26288 	40 F9 A1  1 BC 45 A0  1 
   find-device                      ( r: phandle )
1A26290 	BC 22 A2  1 
   ['] most-tests  ['] (search-preorder)  catch  2drop  ( r: phandle )
1A26294 	60 53 A0  1 
1A26298 	 4 61 A2  1 60 53 A0  1 
1A262A0 	24 17 A2  1 14 7F A0  1 
1A262A8 	AC 49 A0  1 
   r> push-device                   ( )
1A262AC 	D0 45 A0  1 
1A262B0 	F8 FB A1  1 
;
1A262B4 	58 46 A0  1 

: test-all  ( -- )
1A262B8 	 0  0  0 74 65 73 74 2D 
1A262C0 	61 6C 6C 88 84 62 A2  1 
1A262C8 	20 40 A0  1 
   optional-arg-or-/$
1A262CC 	FC 2C A2  1 
   test-subtree
1A262D0 	84 62 A2  1 
;
1A262D4 	58 46 A0  1 

\ From siftdevs.fth
purpose: Sift through the device-tree, using the enhanced display format.

only forth also hidden also definitions

only forth also definitions

\ From malloc.fth
purpose: Heap memory allocator

\ Forth dynamic storage managment.
\
\ By Don Hopkins, University of Maryland
\ Modified by Mitch Bradley, Bradley Forthware
\ Public Domain
\
\ First fit storage allocation of blocks of varying size.
\ Blocks are prefixed with a usage flag and a length count.
\ Free blocks are collapsed downwards during free-memory and while
\ searching during allocate-memory.  Based on the algorithm described
\ in Knuth's _An_Introduction_To_Data_Structures_With_Applications_,
\ sections 5-6.2 and 5-6.3, pp. 501-511.
\
\ init-allocator  ( -- )
\     Initializes the allocator, with no memory.  Should be executed once,
\     before any other allocation operations are attempted.
\
\ add-memory  ( adr len -- )
\     Adds a region of memory to the allocation pool.  That memory will
\     be available for subsequent use by allocate-memory.  This may
\     be executed any number of times.
\
\ allocate-memory  ( size -- adr false  |  error true )
\     Tries to allocate a chunk of memory at least size bytes long.
\     Returns error code and true on failure, or the address of the
\     first byte of usable data and false on success.
\
\ free-memory  ( adr -- )
\     Frees a chunk of memory allocated by malloc.  adr should be an
\     address returned by allocate-memory.  Error if adr is not a
\     valid address.
\
\ memory-available  ( -- size )
\     Returns the size in bytes of the largest contiguous chunk of memory
\     that can be allocated by allocate-memory .

vocabulary allocator
1A262D8 	 0  0 61 6C 6C 6F 63 61 
1A262E0 	74 6F 72 89 C8 62 A2  1 
1A262E8 	E0 B6 A0  1 E0  7  0  0 
1A262F0 	6C 26 A2  1  0  0  0  0 
also allocator also definitions

headerless
8 constant #dalign	\ Machine-dependent worst-case alignment boundary
1A262F8 	23 64 61 6C 69 67 6E 87 
1A26300 	 0  0 A0  1 68 40 A0  1 
1A26308 	 8  0  0  0 

2 base !
1110000000000111 constant *dbuf-free*
1A2630C 	2A 64 62 75 
1A26310 	66 2D 66 72 65 65 2A 8B 
1A26318 	 4 63 A2  1 68 40 A0  1 
1A26320 	 7 E0  0  0 
1111010101011111 constant *dbuf-used*
1A26324 	2A 64 62 75 
1A26328 	66 2D 75 73 65 64 2A 8B 
1A26330 	1C 63 A2  1 68 40 A0  1 
1A26338 	5F F5  0  0 
decimal

\ : field  \ name  ( offset size -- offset' )
\    create over , +  does> @ +
\ ;

struct
   /n field >dbuf-flag
1A2633C 	 0 3E 64 62 
1A26340 	75 66 2D 66 6C 61 67 8A 
1A26348 	34 63 A2  1 50 EE A0  1 
1A26350 	 0  0  0  0 
   /n field >dbuf-size
1A26354 	 0 3E 64 62 
1A26358 	75 66 2D 73 69 7A 65 8A 
1A26360 	4C 63 A2  1 50 EE A0  1 
1A26368 	 4  0  0  0 
aligned
   0  field >dbuf-data
1A2636C 	 0 3E 64 62 
1A26370 	75 66 2D 64 61 74 61 8A 
1A26378 	64 63 A2  1 50 EE A0  1 
1A26380 	 8  0  0  0 
   /n field >dbuf-suc
1A26384 	 0  0 3E 64 
1A26388 	62 75 66 2D 73 75 63 89 
1A26390 	7C 63 A2  1 50 EE A0  1 
1A26398 	 8  0  0  0 
   /n field >dbuf-pred
1A2639C 	 0 3E 64 62 
1A263A0 	75 66 2D 70 72 65 64 8A 
1A263A8 	94 63 A2  1 50 EE A0  1 
1A263B0 	 C  0  0  0 
constant dbuf-min
1A263B4 	 0  0  0 64 
1A263B8 	62 75 66 2D 6D 69 6E 88 
1A263C0 	AC 63 A2  1 68 40 A0  1 
1A263C8 	10  0  0  0 

\ In a multitasking system, the memory allocator head node should
\ be located in a global area, instead in the per-task user area.

dbuf-min ualloc user dbuf-head
1A263CC 	 0  0 64 62 
1A263D0 	75 66 2D 68 65 61 64 89 
1A263D8 	C4 63 A2  1 48 40 A0  1 
1A263E0 	E4  7  0  0 

: dbuf-data>  ( adr -- 'dbuf )  0 >dbuf-data -  ;
1A263E4 	 0 64 62 75 
1A263E8 	66 2D 64 61 74 61 3E 8A 
1A263F0 	DC 63 A2  1 20 40 A0  1 
1A263F8 	70 6F A0  1 7C 63 A2  1 
1A26400 	18 45 A0  1 58 46 A0  1 

: dbuf-flag!  ( flag 'dbuf -- )   >dbuf-flag !   ;
1A26408 	 0 64 62 75 66 2D 66 6C 
1A26410 	61 67 21 8A F4 63 A2  1 
1A26418 	20 40 A0  1 4C 63 A2  1 
1A26420 	54 4D A0  1 58 46 A0  1 
: dbuf-flag@  ( 'dbuf -- flag )   >dbuf-flag @   ;
1A26428 	 0 64 62 75 66 2D 66 6C 
1A26430 	61 67 40 8A 18 64 A2  1 
1A26438 	20 40 A0  1 4C 63 A2  1 
1A26440 	5C 4C A0  1 58 46 A0  1 
: dbuf-size!  ( size 'dbuf -- )   >dbuf-size !   ;
1A26448 	 0 64 62 75 66 2D 73 69 
1A26450 	7A 65 21 8A 38 64 A2  1 
1A26458 	20 40 A0  1 64 63 A2  1 
1A26460 	54 4D A0  1 58 46 A0  1 
: dbuf-size@  ( 'dbuf -- size )   >dbuf-size @   ;
1A26468 	 0 64 62 75 66 2D 73 69 
1A26470 	7A 65 40 8A 58 64 A2  1 
1A26478 	20 40 A0  1 64 63 A2  1 
1A26480 	5C 4C A0  1 58 46 A0  1 
: dbuf-suc!   ( suc 'dbuf -- )    >dbuf-suc  !   ;
1A26488 	 0  0 64 62 75 66 2D 73 
1A26490 	75 63 21 89 78 64 A2  1 
1A26498 	20 40 A0  1 94 63 A2  1 
1A264A0 	54 4D A0  1 58 46 A0  1 
: dbuf-suc@   ( 'dbuf -- 'dbuf )  >dbuf-suc  @   ;
1A264A8 	 0  0 64 62 75 66 2D 73 
1A264B0 	75 63 40 89 98 64 A2  1 
1A264B8 	20 40 A0  1 94 63 A2  1 
1A264C0 	5C 4C A0  1 58 46 A0  1 
: dbuf-pred!  ( pred 'dbuf -- )   >dbuf-pred !   ;
1A264C8 	 0 64 62 75 66 2D 70 72 
1A264D0 	65 64 21 8A B8 64 A2  1 
1A264D8 	20 40 A0  1 AC 63 A2  1 
1A264E0 	54 4D A0  1 58 46 A0  1 
: dbuf-pred@  ( 'dbuf -- 'dbuf )  >dbuf-pred @   ;
1A264E8 	 0 64 62 75 66 2D 70 72 
1A264F0 	65 64 40 8A D8 64 A2  1 
1A264F8 	20 40 A0  1 AC 63 A2  1 
1A26500 	5C 4C A0  1 58 46 A0  1 

: next-dbuf   ( 'dbuf -- 'next-dbuf )  dup dbuf-size@ +  ;
1A26508 	 0  0 6E 65 78 74 2D 64 
1A26510 	62 75 66 89 F8 64 A2  1 
1A26518 	20 40 A0  1 40 49 A0  1 
1A26520 	78 64 A2  1  4 45 A0  1 
1A26528 	58 46 A0  1 

\ Insert new-node into doubly-linked list after old-node
: insert-after  ( new-node old-node -- )
1A2652C 	 0  0  0 69 
1A26530 	6E 73 65 72 74 2D 61 66 
1A26538 	74 65 72 8C 18 65 A2  1 
1A26540 	20 40 A0  1 
   >r  r@ dbuf-suc@  over  dbuf-suc!	\ old's suc is now new's suc
1A26544 	BC 45 A0  1 
1A26548 	E4 45 A0  1 B8 64 A2  1 
1A26550 	54 49 A0  1 98 64 A2  1 
   dup r@ dbuf-suc!			\ new is now old's suc
1A26558 	40 49 A0  1 E4 45 A0  1 
1A26560 	98 64 A2  1 
   r> over dbuf-pred!			\ old is now new's pred
1A26564 	D0 45 A0  1 
1A26568 	54 49 A0  1 D8 64 A2  1 
   dup dbuf-suc@ dbuf-pred!		\ new is now new's suc's pred
1A26570 	40 49 A0  1 B8 64 A2  1 
1A26578 	D8 64 A2  1 
;
1A2657C 	58 46 A0  1 
: link-with-free  ( 'dbuf -- )
1A26580 	 0 6C 69 6E 6B 2D 77 69 
1A26588 	74 68 2D 66 72 65 65 8E 
1A26590 	40 65 A2  1 20 40 A0  1 
   *dbuf-free*  over  dbuf-flag!	\ Set node status to "free"
1A26598 	1C 63 A2  1 54 49 A0  1 
1A265A0 	18 64 A2  1 
   dbuf-head insert-after		\ Insert in list after head node
1A265A4 	DC 63 A2  1 
1A265A8 	40 65 A2  1 
;
1A265AC 	58 46 A0  1 

\ Remove node from doubly-linked list

: remove-node  ( node -- )
1A265B0 	72 65 6D 6F 76 65 2D 6E 
1A265B8 	6F 64 65 8B 94 65 A2  1 
1A265C0 	20 40 A0  1 
   dup dbuf-pred@  over dbuf-suc@ dbuf-pred!
1A265C4 	40 49 A0  1 
1A265C8 	F8 64 A2  1 54 49 A0  1 
1A265D0 	B8 64 A2  1 D8 64 A2  1 
   dup dbuf-suc@   swap dbuf-pred@ dbuf-suc!
1A265D8 	40 49 A0  1 B8 64 A2  1 
1A265E0 	68 49 A0  1 F8 64 A2  1 
1A265E8 	98 64 A2  1 
;
1A265EC 	58 46 A0  1 

\ Collapse the next node into the current node

: merge-with-next  ( 'dbuf -- )
1A265F0 	6D 65 72 67 65 2D 77 69 
1A265F8 	74 68 2D 6E 65 78 74 8F 
1A26600 	C0 65 A2  1 20 40 A0  1 
   dup next-dbuf dup remove-node  ( 'dbuf >next-dbuf )   \ Off of free list
1A26608 	40 49 A0  1 18 65 A2  1 
1A26610 	40 49 A0  1 C0 65 A2  1 

   over dbuf-size@ swap dbuf-size@ +  rot dbuf-size!     \ Increase size
1A26618 	54 49 A0  1 78 64 A2  1 
1A26620 	68 49 A0  1 78 64 A2  1 
1A26628 	 4 45 A0  1 7C 49 A0  1 
1A26630 	58 64 A2  1 
;
1A26634 	58 46 A0  1 

\ 'dbuf is a free node.  Merge all free nodes immediately following
\ into the node.

: merge-down  ( 'dbuf -- 'dbuf )
1A26638 	 0 6D 65 72 67 65 2D 64 
1A26640 	6F 77 6E 8A  4 66 A2  1 
1A26648 	20 40 A0  1 
   begin
      dup next-dbuf dbuf-flag@  *dbuf-free*  =
1A2664C 	40 49 A0  1 
1A26650 	18 65 A2  1 38 64 A2  1 
1A26658 	1C 63 A2  1 24 48 A0  1 
   while
1A26660 	DC 41 A0  1 14  0  0  0 
      dup merge-with-next
1A26668 	40 49 A0  1  4 66 A2  1 
   repeat
1A26670 	C8 41 A0  1 D8 FF FF FF 
;
1A26678 	58 46 A0  1 

forth definitions

: msize  ( adr -- count )  dbuf-data>  dbuf-size@  dbuf-data>  ;
1A2667C 	 0  0 6D 73 
1A26680 	69 7A 65 85 E8 62 A2  1 
1A26688 	20 40 A0  1 F4 63 A2  1 
1A26690 	78 64 A2  1 F4 63 A2  1 
1A26698 	58 46 A0  1 

: >dbuf-header  ( adr -- 'dbuf )
1A2669C 	 0  0  0 3E 
1A266A0 	64 62 75 66 2D 68 65 61 
1A266A8 	64 65 72 8C 88 66 A2  1 
1A266B0 	20 40 A0  1 
   dbuf-data>                ( 'dbuf )
1A266B4 	F4 63 A2  1 
   dup dbuf-flag@ case       ( 'dbuf )
1A266B8 	40 49 A0  1 38 64 A2  1 
      *dbuf-used* of  endof  ( 'dbuf )
1A266C0 	34 63 A2  1 48 43 A0  1 
1A266C8 	 C  0  0  0 6C 43 A0  1 
1A266D0 	6C  0  0  0 
      *dbuf-free* of
1A266D4 	1C 63 A2  1 
1A266D8 	48 43 A0  1 40  0  0  0 
         true abort" Freeing or resizing already-free memory"
1A266E0 	 4 70 A0  1  8 81 A0  1 
1A266E8 	27 46 72 65 65 69 6E 67 
1A266F0 	20 6F 72 20 72 65 73 69 
1A266F8 	7A 69 6E 67 20 61 6C 72 
1A26700 	65 61 64 79 2D 66 72 65 
1A26708 	65 20 6D 65 6D 6F 72 79 
1A26710 	 0  0  0  0 
      endof
1A26714 	6C 43 A0  1 
1A26718 	24  0  0  0 
      true abort" bad heap address."
1A2671C 	 4 70 A0  1 
1A26720 	 8 81 A0  1 11 62 61 64 
1A26728 	20 68 65 61 70 20 61 64 
1A26730 	64 72 65 73 73 2E  0  0 
   endcase                   ( 'dbuf )
1A26738 	84 43 A0  1 
;
1A2673C 	58 46 A0  1 
: free-memory  ( adr -- )
1A26740 	66 72 65 65 2D 6D 65 6D 
1A26748 	6F 72 79 8B B0 66 A2  1 
1A26750 	20 40 A0  1 
   >dbuf-header  merge-down link-with-free
1A26754 	B0 66 A2  1 
1A26758 	48 66 A2  1 94 65 A2  1 
;
1A26760 	58 46 A0  1 

: add-memory  ( adr len -- )
1A26764 	 0 61 64 64 
1A26768 	2D 6D 65 6D 6F 72 79 8A 
1A26770 	50 67 A2  1 20 40 A0  1 
   \ Align the starting address to a "worst-case" boundary.  This helps
   \ guarantee that allocated data areas will be on a "worst-case"
   \ alignment boundary.

   swap dup  #dalign round-up      ( len adr adr' )
1A26778 	68 49 A0  1 40 49 A0  1 
1A26780 	 4 63 A2  1 A4 91 A0  1 
   dup rot -                       ( len adr' diff )
1A26788 	40 49 A0  1 7C 49 A0  1 
1A26790 	18 45 A0  1 
   rot swap -                      ( adr' len' )
1A26794 	7C 49 A0  1 
1A26798 	68 49 A0  1 18 45 A0  1 
   #dalign round-down              ( adr' len'' )
1A267A0 	 4 63 A2  1 80 91 A0  1 

   \ Set size and flags fields for first piece

   \ Subtract off the size of one node header, because we carve out
   \ a node header from the end of the piece to use as a "stopper".
   \ That "stopper" is marked "used", and prevents merge-down from
   \ trying to merge past the end of the piece.

   dbuf-data>                      ( 'dbuf-first #dbuf-first )
1A267A8 	F4 63 A2  1 

   \ Ensure that the piece is big enough to be useable.
   \ A piece of size dbuf-min (after having subtracted off the "stopper"
   \ header) is barely useable, because the space used by the free list
   \ links can be used as the data space.  If it's too small, we just
   \ exit, wasting the (miniscule amount of) memory.

   dup dbuf-min <  if  2drop exit  then
1A267AC 	40 49 A0  1 
1A267B0 	C4 63 A2  1 E4 47 A0  1 
1A267B8 	DC 41 A0  1  C  0  0  0 
1A267C0 	AC 49 A0  1 40 46 A0  1 

   \ Set the size and flag for the new free piece

   *dbuf-free* 2 pick dbuf-flag!   ( 'dbuf-first #dbuf-first )
1A267C8 	1C 63 A2  1 90 6F A0  1 
1A267D0 	 C 4A A0  1 18 64 A2  1 
   2dup swap dbuf-size!            ( 'dbuf-first #dbuf-first )
1A267D8 	C0 49 A0  1 68 49 A0  1 
1A267E0 	58 64 A2  1 

   \ Create the "stopper" header

   \ XXX The stopper piece should be linked into a piece list,
   \ and the flags should be set to a different value.  The size
   \ field should indicate the total size for this piece.
   \ The piece list should be consulted when adding memory, and
   \ if there is a piece immediately following the new piece, they
   \ should be merged.

   over +                          ( 'dbuf-first 'dbuf-limit )
1A267E4 	54 49 A0  1 
1A267E8 	 4 45 A0  1 
   *dbuf-used* swap dbuf-flag!     ( 'dbuf-first )
1A267EC 	34 63 A2  1 
1A267F0 	68 49 A0  1 18 64 A2  1 

   link-with-free
1A267F8 	94 65 A2  1 
;
1A267FC 	58 46 A0  1 

: allocate-memory  ( size -- adr false  |  error-code true )
1A26800 	61 6C 6C 6F 63 61 74 65 
1A26808 	2D 6D 65 6D 6F 72 79 8F 
1A26810 	74 67 A2  1 20 40 A0  1 
   \ Keep pieces aligned on "worst-case" hardware boundaries
   #dalign round-up                 ( size' )
1A26818 	 4 63 A2  1 A4 91 A0  1 

   >dbuf-data dbuf-min max          ( size )
1A26820 	7C 63 A2  1 C4 63 A2  1 
1A26828 	9C 4A A0  1 

   \ Search for a sufficiently-large free piece
   dbuf-head                        ( size 'dbuf )
1A2682C 	DC 63 A2  1 
   begin                            ( size 'dbuf )
      dbuf-suc@                     ( size 'dbuf )
1A26830 	B8 64 A2  1 
      dup dbuf-head =  if           \ Bail out if we've already been around
1A26834 	40 49 A0  1 
1A26838 	DC 63 A2  1 24 48 A0  1 
1A26840 	DC 41 A0  1 14  0  0  0 
         2drop 1 true exit          ( error-code true )
1A26848 	AC 49 A0  1 80 6F A0  1 
1A26850 	 4 70 A0  1 40 46 A0  1 
      then                          ( size 'dbuf-suc )
      merge-down                    ( size 'dbuf )
1A26858 	48 66 A2  1 
      dup dbuf-size@                ( size 'dbuf dbuf-size )
1A2685C 	40 49 A0  1 
1A26860 	78 64 A2  1 
      2 pick >=                     ( size 'dbuf big-enough? )
1A26864 	90 6F A0  1 
1A26868 	 C 4A A0  1 EC 48 A0  1 
   until                            ( size 'dbuf )
1A26870 	DC 41 A0  1 BC FF FF FF 

   dup dbuf-size@ 2 pick -          ( size 'dbuf left-over )
1A26878 	40 49 A0  1 78 64 A2  1 
1A26880 	90 6F A0  1  C 4A A0  1 
1A26888 	18 45 A0  1 
   dup dbuf-min <=  if              \ Too small to fragment?
1A2688C 	40 49 A0  1 
1A26890 	C4 63 A2  1  C 49 A0  1 
1A26898 	DC 41 A0  1 1C  0  0  0 

      \ The piece is too small to split, so we just remove the whole
      \ thing from the free list.

      drop nip                      ( 'dbuf )
1A268A0 	30 49 A0  1 FC 46 A0  1 
      dup remove-node               ( 'dbuf )
1A268A8 	40 49 A0  1 C0 65 A2  1 
   else                             ( size 'dbuf left-over )
1A268B0 	C8 41 A0  1 1C  0  0  0 

      \ The piece is big enough to split up, so we make the free piece
      \ smaller and take the stuff after it as the allocated piece.

      2dup swap dbuf-size!          ( size 'dbuf left-over) \ Set frag size
1A268B8 	C0 49 A0  1 68 49 A0  1 
1A268C0 	58 64 A2  1 
      +                             ( size 'dbuf' )
1A268C4 	 4 45 A0  1 
      tuck dbuf-size!               ( 'dbuf' )
1A268C8 	E8 46 A0  1 58 64 A2  1 
   then
   *dbuf-used* over dbuf-flag!      \ Mark as used
1A268D0 	34 63 A2  1 54 49 A0  1 
1A268D8 	18 64 A2  1 
   >dbuf-data false                 ( adr false )
1A268DC 	7C 63 A2  1 
1A268E0 	18 70 A0  1 
;
1A268E4 	58 46 A0  1 

: memory-available  ( -- size )
1A268E8 	 0  0  0 6D 65 6D 6F 72 
1A268F0 	79 2D 61 76 61 69 6C 61 
1A268F8 	62 6C 65 90 14 68 A2  1 
1A26900 	20 40 A0  1 
   0 >dbuf-data                     ( current-largest-size )
1A26904 	70 6F A0  1 
1A26908 	7C 63 A2  1 

   dbuf-head                        ( size 'dbuf )
1A2690C 	DC 63 A2  1 
   begin                            ( size 'dbuf )
      dbuf-suc@  dup dbuf-head <>   ( size 'dbuf more? )
1A26910 	B8 64 A2  1 40 49 A0  1 
1A26918 	DC 63 A2  1 44 48 A0  1 
   while                            \ Go once around the free list
1A26920 	DC 41 A0  1 24  0  0  0 
      merge-down                    ( size 'dbuf )
1A26928 	48 66 A2  1 
      dup dbuf-size@                ( size 'dbuf dbuf-size )
1A2692C 	40 49 A0  1 
1A26930 	78 64 A2  1 
      rot max swap                  ( size' 'dbuf )
1A26934 	7C 49 A0  1 
1A26938 	9C 4A A0  1 68 49 A0  1 
   repeat
1A26940 	C8 41 A0  1 CC FF FF FF 
   drop  dbuf-data>                 ( largest-data-size )
1A26948 	30 49 A0  1 F4 63 A2  1 
;
1A26950 	58 46 A0  1 

\ Head node has 0 size, is not free, and is initially linked to itself

: init-allocator  ( -- )
1A26954 	 0 69 6E 69 
1A26958 	74 2D 61 6C 6C 6F 63 61 
1A26960 	74 6F 72 8E  0 69 A2  1 
1A26968 	20 40 A0  1 
   *dbuf-used* dbuf-head dbuf-flag!
1A2696C 	34 63 A2  1 
1A26970 	DC 63 A2  1 18 64 A2  1 
   0 dbuf-head dbuf-size!	\ Must be 0 so the allocator won't find it.
1A26978 	70 6F A0  1 DC 63 A2  1 
1A26980 	58 64 A2  1 
   dbuf-head  dup  dbuf-suc!	\ Link to self
1A26984 	DC 63 A2  1 
1A26988 	40 49 A0  1 98 64 A2  1 
   dbuf-head  dup  dbuf-pred!
1A26990 	DC 63 A2  1 40 49 A0  1 
1A26998 	D8 64 A2  1 
;
1A2699C 	58 46 A0  1 

previous previous definitions

\ Tries to allocate, and if that fails, requests more memory from the system

also allocator also

defer more-memory  ( request-size -- adr actual-size false | error-code true )
1A269A0 	6D 6F 72 65 2D 6D 65 6D 
1A269A8 	6F 72 79 8B 68 69 A2  1 
1A269B0 	5C 40 A0  1 F4  7  0  0 

headerless
: allocate-memory  ( size -- adr false  |  error-code true )
1A269B8 	61 6C 6C 6F 63 61 74 65 
1A269C0 	2D 6D 65 6D 6F 72 79 8F 
1A269C8 	B0 69 A2  1 20 40 A0  1 
   dup allocate-memory  if	      ( size error-code )
1A269D0 	40 49 A0  1 14 68 A2  1 
1A269D8 	DC 41 A0  1 48  0  0  0 
      \ No more memory in the heap; try to get some more from the system
      drop                            ( size )
1A269E0 	30 49 A0  1 
      dup #dalign + >dbuf-data >dbuf-data
1A269E4 	40 49 A0  1 
1A269E8 	 4 63 A2  1  4 45 A0  1 
1A269F0 	7C 63 A2  1 7C 63 A2  1 
      more-memory  if                 ( size error-code )
1A269F8 	B0 69 A2  1 DC 41 A0  1 
1A26A00 	14  0  0  0 
         nip true                     ( error-code true )
1A26A04 	FC 46 A0  1 
1A26A08 	 4 70 A0  1 
      else                            ( size adr actual )
1A26A0C 	C8 41 A0  1 
1A26A10 	 C  0  0  0 
         add-memory                   ( size )
1A26A14 	74 67 A2  1 
	 allocate-memory              ( adr false  |  error-code true )
1A26A18 	14 68 A2  1 
      then                            ( adr false  |  error-code true )
   else                               ( size adr )
1A26A1C 	C8 41 A0  1 
1A26A20 	 C  0  0  0 
      nip false                       ( adr false )
1A26A24 	FC 46 A0  1 
1A26A28 	18 70 A0  1 
   then                               ( adr false  |  error-code true )
;
1A26A2C 	58 46 A0  1 

: adjust-piece  ( size 'dbuf -- actual-size )
1A26A30 	 0  0  0 61 64 6A 75 73 
1A26A38 	74 2D 70 69 65 63 65 8C 
1A26A40 	CC 69 A2  1 20 40 A0  1 
   dup dbuf-size@ 2 pick -          ( size 'dbuf left-over )
1A26A48 	40 49 A0  1 78 64 A2  1 
1A26A50 	90 6F A0  1  C 4A A0  1 
1A26A58 	18 45 A0  1 
   dup dbuf-min <=  if              ( size 'dbuf left-over )
1A26A5C 	40 49 A0  1 
1A26A60 	C4 63 A2  1  C 49 A0  1 
1A26A68 	DC 41 A0  1 20  0  0  0 
      \ The piece is too small to split, so we just remove the whole
      \ thing from the free list.

      drop nip                      ( 'dbuf )
1A26A70 	30 49 A0  1 FC 46 A0  1 
      dup remove-node               ( 'dbuf )
1A26A78 	40 49 A0  1 C0 65 A2  1 
      dbuf-size@                    ( actual-size )
1A26A80 	78 64 A2  1 
   else                             ( size 'dbuf left-over )
1A26A84 	C8 41 A0  1 
1A26A88 	64  0  0  0 

      \ The piece is big enough to split up, so we shrink the
      \ free part by moving the header up.

      \ Compute address of new header
      3dup drop +  >r               ( size 'dbuf left-over r: 'dbuf1 )
1A26A8C 	A4 52 A0  1 
1A26A90 	30 49 A0  1  4 45 A0  1 
1A26A98 	BC 45 A0  1 

      \ Prepare the new header
      *dbuf-free*  r@ dbuf-flag!    ( size 'dbuf left-over 'dbuf1 )
1A26A9C 	1C 63 A2  1 
1A26AA0 	E4 45 A0  1 18 64 A2  1 
      r@ dbuf-size!                 ( size 'dbuf )
1A26AA8 	E4 45 A0  1 58 64 A2  1 
      dup dbuf-suc@  r@ dbuf-suc!   ( size 'dbuf )
1A26AB0 	40 49 A0  1 B8 64 A2  1 
1A26AB8 	E4 45 A0  1 98 64 A2  1 
      dbuf-pred@  r@ dbuf-pred!     ( size )
1A26AC0 	F8 64 A2  1 E4 45 A0  1 
1A26AC8 	D8 64 A2  1 

      \ Fix the free list to point to the new header instead of the old one
      r@  dup dbuf-suc@  dbuf-pred! ( size 'dbuf1 )
1A26ACC 	E4 45 A0  1 
1A26AD0 	40 49 A0  1 B8 64 A2  1 
1A26AD8 	D8 64 A2  1 
      r>  dup dbuf-pred@ dbuf-suc!  ( size )
1A26ADC 	D0 45 A0  1 
1A26AE0 	40 49 A0  1 F8 64 A2  1 
1A26AE8 	98 64 A2  1 
   then
;
1A26AEC 	58 46 A0  1 

\ Returns true if adr is the address of a free buffer header.
\ It is tempting to just look for a *dbuf-free* signature at adr, but
\ that could fail if adr is at the end of the heap area and is not mapped.
: dbuf-free?  ( adr -- free? )
1A26AF0 	 0 64 62 75 66 2D 66 72 
1A26AF8 	65 65 3F 8A 44 6A A2  1 
1A26B00 	20 40 A0  1 
   \ Search for a sufficiently-large free piece
   dbuf-head                        ( adr 'dbuf )
1A26B04 	DC 63 A2  1 
   begin                            ( adr 'dbuf )
      dbuf-suc@                     ( adr 'dbuf )
1A26B08 	B8 64 A2  1 
      dup dbuf-head =  if           \ Bail out if we've already been around
1A26B0C 	40 49 A0  1 
1A26B10 	DC 63 A2  1 24 48 A0  1 
1A26B18 	DC 41 A0  1 10  0  0  0 
         2drop false exit           ( false )
1A26B20 	AC 49 A0  1 18 70 A0  1 
1A26B28 	40 46 A0  1 
      then                          ( adr 'dbuf-suc )
      merge-down                    ( adr 'dbuf )
1A26B2C 	48 66 A2  1 
      2dup =                        ( adr 'dbuf match? )
1A26B30 	C0 49 A0  1 24 48 A0  1 
   until                            ( adr 'dbuf )
1A26B38 	DC 41 A0  1 CC FF FF FF 
   2drop true                       ( true )
1A26B40 	AC 49 A0  1  4 70 A0  1 
;
1A26B48 	58 46 A0  1 

: resize-memory  ( adr newlen -- adr' ior )
1A26B4C 	 0  0 72 65 
1A26B50 	73 69 7A 65 2D 6D 65 6D 
1A26B58 	6F 72 79 8D  0 6B A2  1 
1A26B60 	20 40 A0  1 
   \ Keep pieces aligned on "worst-case" hardware boundaries
   #dalign round-up  dbuf-min max  ( adr newlen' )
1A26B64 	 4 63 A2  1 
1A26B68 	A4 91 A0  1 C4 63 A2  1 
1A26B70 	9C 4A A0  1 

   swap >dbuf-header  >r           ( newlen r: 'dbuf )
1A26B74 	68 49 A0  1 
1A26B78 	B0 66 A2  1 BC 45 A0  1 
   r@ dbuf-size@                   ( newlen old-size r: 'dbuf )
1A26B80 	E4 45 A0  1 78 64 A2  1 

   \ If the new size is smaller than the old, just return success.
   \ It might be nice to give back the unused piece, but we can
   \ implement that later if it turns out to be needed.
   dbuf-data> 2dup <=  if          ( newlen old-dsize r: 'dbuf )
1A26B88 	F4 63 A2  1 C0 49 A0  1 
1A26B90 	 C 49 A0  1 DC 41 A0  1 
1A26B98 	18  0  0  0 
      2drop r> >dbuf-data 0        ( adr ior )
1A26B9C 	AC 49 A0  1 
1A26BA0 	D0 45 A0  1 7C 63 A2  1 
1A26BA8 	70 6F A0  1 
      exit
1A26BAC 	40 46 A0  1 
   then                            ( newlen old-dsize r: 'dbuf )

   \ If there is a sufficiently-large free piece following the old
   \ piece, then we can just extend the old piece "in place".
   dup >dbuf-data  r@ +            ( newlen old-dsize 'dbuf1 r: 'dbuf )
1A26BB0 	40 49 A0  1 7C 63 A2  1 
1A26BB8 	E4 45 A0  1  4 45 A0  1 
   dup dbuf-free?  if              ( newlen old-dsize 'dbuf1 r: 'dbuf )
1A26BC0 	40 49 A0  1  0 6B A2  1 
1A26BC8 	DC 41 A0  1 58  0  0  0 
      >r                           ( newlen old-dsize r: 'dbuf 'dbuf1 )
1A26BD0 	BC 45 A0  1 
      2dup -                       ( newlen old-dsize need-size r: .. )
1A26BD4 	C0 49 A0  1 
1A26BD8 	18 45 A0  1 
      r@ dbuf-size@                ( newlen old-dsize need-size size1 r: .. )
1A26BDC 	E4 45 A0  1 
1A26BE0 	78 64 A2  1 
      <=  if                       ( newlen old-dsize r: .. )
1A26BE4 	 C 49 A0  1 
1A26BE8 	DC 41 A0  1 34  0  0  0 
         \ The piece is large enough
         tuck -                    ( old-dsize need-size r: .. )
1A26BF0 	E8 46 A0  1 18 45 A0  1 
         r> adjust-piece           ( old-dsize got-size  r: 'dbuf )
1A26BF8 	D0 45 A0  1 44 6A A2  1 
         + >dbuf-data  r@ dbuf-size!  ( r: 'dbuf )
1A26C00 	 4 45 A0  1 7C 63 A2  1 
1A26C08 	E4 45 A0  1 58 64 A2  1 
         r> >dbuf-data 0              ( adr ior )
1A26C10 	D0 45 A0  1 7C 63 A2  1 
1A26C18 	70 6F A0  1 
         exit
1A26C1C 	40 46 A0  1 
      then                         ( newlen old-dsize r: 'dbuf 'dbuf1 )
      r>                           ( newlen old-dsize 'dbuf1 r: 'dbuf )
1A26C20 	D0 45 A0  1 
   then                            ( newlen old-dsize 'dbuf1 r: 'dbuf )

   drop                            ( newlen old-dsize r: 'dbuf )
1A26C24 	30 49 A0  1 

   \ We can't extend the existing piece, so we must get a new one
   \ and copy in the old data
   swap allocate-memory  if        ( old-dsize error-code r: 'dbuf )
1A26C28 	68 49 A0  1 CC 69 A2  1 
1A26C30 	DC 41 A0  1 1C  0  0  0 
      2drop  r> >dbuf-data -1      ( adr ior )
1A26C38 	AC 49 A0  1 D0 45 A0  1 
1A26C40 	7C 63 A2  1 58 41 A0  1 
1A26C48 	FF FF FF FF 
      exit
1A26C4C 	40 46 A0  1 
   then                               ( old-dsize adr1 r: 'dbuf )

   dup rot  r@ >dbuf-data -rot move   ( adr1 r: 'dbuf )
1A26C50 	40 49 A0  1 7C 49 A0  1 
1A26C58 	E4 45 A0  1 7C 63 A2  1 
1A26C60 	94 49 A0  1 F4 4A A0  1 
   r> >dbuf-data free-memory          ( adr1 )
1A26C68 	D0 45 A0  1 7C 63 A2  1 
1A26C70 	50 67 A2  1 
   0
1A26C74 	70 6F A0  1 
;
1A26C78 	58 46 A0  1 

\ [ifdef] debug-mallocator
\ .( Memory allocator debug words are included) cr
: .previous  ( adr -- )
1A26C7C 	 0  0 2E 70 
1A26C80 	72 65 76 69 6F 75 73 89 
1A26C88 	60 6B A2  1 20 40 A0  1 
   begin  /n -  dup @  *dbuf-used* =  until
1A26C90 	40 51 A0  1 18 45 A0  1 
1A26C98 	40 49 A0  1 5C 4C A0  1 
1A26CA0 	34 63 A2  1 24 48 A0  1 
1A26CA8 	DC 41 A0  1 E4 FF FF FF 
   ." Preceding used heap node at " .x cr
1A26CB0 	20 7C A0  1 1C 50 72 65 
1A26CB8 	63 65 64 69 6E 67 20 75 
1A26CC0 	73 65 64 20 68 65 61 70 
1A26CC8 	20 6E 6F 64 65 20 61 74 
1A26CD0 	20  0  0  0 2C  E A1  1 
1A26CD8 	80 6D A0  1 
;
1A26CDC 	58 46 A0  1 
: check-node  ( 'dbuf -- )
1A26CE0 	 0 63 68 65 63 6B 2D 6E 
1A26CE8 	6F 64 65 8A 8C 6C A2  1 
1A26CF0 	20 40 A0  1 
   dup dbuf-flag@ *dbuf-free* <>  if
1A26CF4 	40 49 A0  1 
1A26CF8 	38 64 A2  1 1C 63 A2  1 
1A26D00 	44 48 A0  1 DC 41 A0  1 
1A26D08 	34  0  0  0 
      ." Bad heap node at " dup .x
1A26D0C 	20 7C A0  1 
1A26D10 	11 42 61 64 20 68 65 61 
1A26D18 	70 20 6E 6F 64 65 20 61 
1A26D20 	74 20  0  0 40 49 A0  1 
1A26D28 	2C  E A1  1 
      .previous
1A26D2C 	8C 6C A2  1 
      abort
1A26D30 	28 91 A0  1 
   else
1A26D34 	C8 41 A0  1 
1A26D38 	 8  0  0  0 
      drop
1A26D3C 	30 49 A0  1 
   then
;
1A26D40 	58 46 A0  1 
: check-heap  ( -- )
1A26D44 	 0 63 68 65 
1A26D48 	63 6B 2D 68 65 61 70 8A 
1A26D50 	F0 6C A2  1 20 40 A0  1 
   dbuf-head
1A26D58 	DC 63 A2  1 
   begin  dbuf-suc@ dup  dbuf-head <>  while  dup check-node  repeat
1A26D5C 	B8 64 A2  1 
1A26D60 	40 49 A0  1 DC 63 A2  1 
1A26D68 	44 48 A0  1 DC 41 A0  1 
1A26D70 	14  0  0  0 40 49 A0  1 
1A26D78 	F0 6C A2  1 C8 41 A0  1 
1A26D80 	DC FF FF FF 
   drop
1A26D84 	30 49 A0  1 
;
1A26D88 	58 46 A0  1 

: .node  ( 'dbuf -- )
1A26D8C 	 0  0 2E 6E 
1A26D90 	6F 64 65 85 54 6D A2  1 
1A26D98 	20 40 A0  1 
   push-hex
1A26D9C 	5C F4 A0  1 
   dup 8 u.r  3 spaces
1A26DA0 	40 49 A0  1 F0 6F A0  1 
1A26DA8 	E4 77 A0  1 A0 6F A0  1 
1A26DB0 	E8 71 A0  1 
   dup dbuf-flag@  5 u.r
1A26DB4 	40 49 A0  1 
1A26DB8 	38 64 A2  1 C0 6F A0  1 
1A26DC0 	E4 77 A0  1 
   dup dbuf-size@  9 u.r
1A26DC4 	40 49 A0  1 
1A26DC8 	78 64 A2  1 58 41 A0  1 
1A26DD0 	 9  0  0  0 E4 77 A0  1 
   dup dbuf-suc@   9 u.r
1A26DD8 	40 49 A0  1 B8 64 A2  1 
1A26DE0 	58 41 A0  1  9  0  0  0 
1A26DE8 	E4 77 A0  1 
   dbuf-pred@      9 u.r
1A26DEC 	F8 64 A2  1 
1A26DF0 	58 41 A0  1  9  0  0  0 
1A26DF8 	E4 77 A0  1 
   cr
1A26DFC 	80 6D A0  1 
   pop-base
1A26E00 	9C F4 A0  1 
;
1A26E04 	58 46 A0  1 

: .heap  ( -- )
1A26E08 	 0  0 2E 68 65 61 70 85 
1A26E10 	98 6D A2  1 20 40 A0  1 
   dbuf-head
1A26E18 	DC 63 A2  1 
   begin  dbuf-suc@ dup  dbuf-head <>  while  dup check-node  dup .node  repeat
1A26E1C 	B8 64 A2  1 
1A26E20 	40 49 A0  1 DC 63 A2  1 
1A26E28 	44 48 A0  1 DC 41 A0  1 
1A26E30 	1C  0  0  0 40 49 A0  1 
1A26E38 	F0 6C A2  1 40 49 A0  1 
1A26E40 	98 6D A2  1 C8 41 A0  1 
1A26E48 	D4 FF FF FF 
   drop
1A26E4C 	30 49 A0  1 
;
1A26E50 	58 46 A0  1 
\ [then] \  debug-mallocator

previous  previous

: heap-alloc-mem  ( bytes -- adr )
1A26E54 	 0 68 65 61 
1A26E58 	70 2D 61 6C 6C 6F 63 2D 
1A26E60 	6D 65 6D 8E 14 6E A2  1 
1A26E68 	20 40 A0  1 
   allocate-memory abort" Out of memory"
1A26E6C 	CC 69 A2  1 
1A26E70 	 8 81 A0  1  D 4F 75 74 
1A26E78 	20 6F 66 20 6D 65 6D 6F 
1A26E80 	72 79  0  0 
;
1A26E84 	58 46 A0  1 

: heap-free-mem  ( adr size -- )  drop free-memory  ;
1A26E88 	 0  0 68 65 61 70 2D 66 
1A26E90 	72 65 65 2D 6D 65 6D 8D 
1A26E98 	68 6E A2  1 20 40 A0  1 
1A26EA0 	30 49 A0  1 50 67 A2  1 
1A26EA8 	58 46 A0  1 

init-allocator

headers
h# 100000 constant 1meg
1A26EAC 	 0  0  0 31 
1A26EB0 	6D 65 67 84 9C 6E A2  1 
1A26EB8 	68 40 A0  1  0  0 10  0 

\ From instmall.fth
purpose: 

\ Install heap memory allocator.

defer initial-heap  ' no-memory is initial-heap
1A26EC0 	 0  0  0 69 6E 69 74 69 
1A26EC8 	61 6C 2D 68 65 61 70 8C 
1A26ED0 	B8 6E A2  1 5C 40 A0  1 
1A26ED8 	F8  7  0  0 

headerless
: no-more-memory  ( request-size -- adr actual-size false | error true )
1A26EDC 	 0 6E 6F 2D 
1A26EE0 	6D 6F 72 65 2D 6D 65 6D 
1A26EE8 	6F 72 79 8E D4 6E A2  1 
1A26EF0 	20 40 A0  1 
   drop 0 true
1A26EF4 	30 49 A0  1 
1A26EF8 	70 6F A0  1  4 70 A0  1 
;
1A26F00 	58 46 A0  1 

: stand-init-io  ( -- )
1A26F04 	 0  0 73 74 
1A26F08 	61 6E 64 2D 69 6E 69 74 
1A26F10 	2D 69 6F 8D F0 6E A2  1 
1A26F18 	20 40 A0  1 
   stand-init-io
1A26F1C 	E8 DF A1  1 
   init-allocator
1A26F20 	68 69 A2  1 
   initial-heap add-memory
1A26F24 	D4 6E A2  1 
1A26F28 	74 67 A2  1 
   ['] no-more-memory is more-memory
1A26F2C 	60 53 A0  1 
1A26F30 	F0 6E A2  1 98 40 A0  1 
1A26F38 	B0 69 A2  1 
   ['] heap-alloc-mem is alloc-mem
1A26F3C 	60 53 A0  1 
1A26F40 	68 6E A2  1 98 40 A0  1 
1A26F48 	F0 6C A0  1 
   ['] heap-free-mem  is free-mem
1A26F4C 	60 53 A0  1 
1A26F50 	9C 6E A2  1 98 40 A0  1 
1A26F58 	 8 6D A0  1 
   ['] resize-memory  is resize
1A26F5C 	60 53 A0  1 
1A26F60 	60 6B A2  1 98 40 A0  1 
1A26F68 	1C 6D A0  1 
   ['] ofw-$getenv    is $getenv
1A26F6C 	60 53 A0  1 
1A26F70 	18 F1 A1  1 98 40 A0  1 
1A26F78 	48 6D A0  1 
;
1A26F7C 	58 46 A0  1 
\ From alarm.fth
purpose: Alarm dispatcher
\ alarm function.
\ To install an alarm:  ['] forth-function #msecs alarm
\ To uninstall alarm:   ['] forth-function 0      alarm
\
headerless
list: alarm-list
1A26F80 	 0 61 6C 61 72 6D 2D 6C 
1A26F88 	69 73 74 8A 18 6F A2  1 
1A26F90 	48 40 A0  1 FC  7  0  0 
listnode
   /n  field  >time-out
1A26F98 	 0  0 3E 74 69 6D 65 2D 
1A26FA0 	6F 75 74 89 90 6F A2  1 
1A26FA8 	50 EE A0  1  4  0  0  0 
   /n  field  >time-remain
1A26FB0 	 0  0  0 3E 74 69 6D 65 
1A26FB8 	2D 72 65 6D 61 69 6E 8C 
1A26FC0 	A8 6F A2  1 50 EE A0  1 
1A26FC8 	 8  0  0  0 
   /n  field  >acf
1A26FCC 	 0  0  0 3E 
1A26FD0 	61 63 66 84 C4 6F A2  1 
1A26FD8 	50 EE A0  1  C  0  0  0 
   /n  field  >ihandle
1A26FE0 	 0  0  0 3E 69 68 61 6E 
1A26FE8 	64 6C 65 88 D8 6F A2  1 
1A26FF0 	50 EE A0  1 10  0  0  0 
nodetype: alarm-node
1A26FF8 	 0 61 6C 61 72 6D 2D 6E 
1A27000 	6F 64 65 8A F0 6F A2  1 
1A27008 	AC 71 A1  1  0  8  0  0 

0 alarm-node !          \ Initialize to empty at compile time
0 alarm-list !          \ Initialize to empty at compile time

: show-alarm  ( node -- flag )
1A27010 	 0 73 68 6F 77 2D 61 6C 
1A27018 	61 72 6D 8A  8 70 A2  1 
1A27020 	20 40 A0  1 
   dup >acf @ .name  d# 20 to-column  dup >ihandle @ 9 u.r
1A27024 	40 49 A0  1 
1A27028 	D8 6F A2  1 5C 4C A0  1 
1A27030 	C8 9A A0  1 58 41 A0  1 
1A27038 	14  0  0  0  8 14 A1  1 
1A27040 	40 49 A0  1 F0 6F A2  1 
1A27048 	5C 4C A0  1 58 41 A0  1 
1A27050 	 9  0  0  0 E4 77 A0  1 
   dup >time-out @ d# 7 u.r  >time-remain @ d# 10 u.r  cr
1A27058 	40 49 A0  1 A8 6F A2  1 
1A27060 	5C 4C A0  1 58 41 A0  1 
1A27068 	 7  0  0  0 E4 77 A0  1 
1A27070 	C4 6F A2  1 5C 4C A0  1 
1A27078 	58 41 A0  1  A  0  0  0 
1A27080 	E4 77 A0  1 80 6D A0  1 
   false
1A27088 	18 70 A0  1 
;
1A2708C 	58 46 A0  1 
headers
: .alarms  ( -- )
1A27090 	2E 61 6C 61 72 6D 73 87 
1A27098 	20 70 A2  1 20 40 A0  1 
   ." Action                Ihandle  Interval  Remaining" cr
1A270A0 	20 7C A0  1 32 41 63 74 
1A270A8 	69 6F 6E 20 20 20 20 20 
1A270B0 	20 20 20 20 20 20 20 20 
1A270B8 	20 20 20 49 68 61 6E 64 
1A270C0 	6C 65 20 20 49 6E 74 65 
1A270C8 	72 76 61 6C 20 20 52 65 
1A270D0 	6D 61 69 6E 69 6E 67  0 
1A270D8 	80 6D A0  1 
   alarm-list  ['] show-alarm  find-node  2drop
1A270DC 	90 6F A2  1 
1A270E0 	60 53 A0  1 20 70 A2  1 
1A270E8 	88 72 A1  1 AC 49 A0  1 
;
1A270F0 	58 46 A0  1 
headerless

\ Return flag will be true if the acf of the give node is equal to
\ the given acf.
: target-node?  ( ihandle acf node -- ihandle acf flag )
1A270F4 	 0  0  0 74 
1A270F8 	61 72 67 65 74 2D 6E 6F 
1A27100 	64 65 3F 8C 9C 70 A2  1 
1A27108 	20 40 A0  1 
   2dup >acf @  =                 ( ihandle acf node flag )
1A2710C 	C0 49 A0  1 
1A27110 	D8 6F A2  1 5C 4C A0  1 
1A27118 	24 48 A0  1 
   3 pick rot >ihandle @  = and   ( ihandle acf flag )
1A2711C 	A0 6F A0  1 
1A27120 	 C 4A A0  1 7C 49 A0  1 
1A27128 	F0 6F A2  1 5C 4C A0  1 
1A27130 	24 48 A0  1 5C 44 A0  1 
;
1A27138 	58 46 A0  1 


\ If a node with "acf" is already in the alarm-list, then just set the
\ time-out and time-remain with the new value "n"; else allocate a
\ new node and set up all fields with the given info.
: set-alarm-node	( ihandle acf n -- )
1A2713C 	 0 73 65 74 
1A27140 	2D 61 6C 61 72 6D 2D 6E 
1A27148 	6F 64 65 8E  8 71 A2  1 
1A27150 	20 40 A0  1 
   \ convert n miliseconds to #clock-ticks.
   ms/tick /mod  swap 0<>  if  1+  then		( ihandle acf #clock-ticks )
1A27154 	38 E0 A1  1 
1A27158 	50 5F A0  1 68 49 A0  1 
1A27160 	44 47 A0  1 DC 41 A0  1 
1A27168 	 8  0  0  0 30 4B A0  1 

   >r alarm-list ['] target-node? find-node	( ihandle acf prev next|0 )
1A27170 	BC 45 A0  1 90 6F A2  1 
1A27178 	60 53 A0  1  8 71 A2  1 
1A27180 	88 72 A1  1 
   ?dup if					( ihandle acf prev next )
1A27184 	B4 70 A0  1 
1A27188 	DC 41 A0  1 10  0  0  0 
      nip					( ihandle acf next )
1A27190 	FC 46 A0  1 
   else						( ihandle acf last-node )
1A27194 	C8 41 A0  1 
1A27198 	18  0  0  0 
      alarm-node allocate-node  		( ihandle acf last-node node )
1A2719C 	 8 70 A2  1 
1A271A0 	34 74 A1  1 
      tuck swap insert-after			( ihandle acf node )
1A271A4 	E8 46 A0  1 
1A271A8 	68 49 A0  1 28 72 A1  1 
   then						( ihandle acf node )
   tuck >acf !					( ihandle node )
1A271B0 	E8 46 A0  1 D8 6F A2  1 
1A271B8 	54 4D A0  1 
   r@ over >time-out !				( ihandle node )
1A271BC 	E4 45 A0  1 
1A271C0 	54 49 A0  1 A8 6F A2  1 
1A271C8 	54 4D A0  1 
   r> over >time-remain !			( ihandle node )
1A271CC 	D0 45 A0  1 
1A271D0 	54 49 A0  1 C4 6F A2  1 
1A271D8 	54 4D A0  1 
   >ihandle !                                   ( )
1A271DC 	F0 6F A2  1 
1A271E0 	54 4D A0  1 
;
1A271E4 	58 46 A0  1 


\ Search thru alarm-list, if node is found, then zero out the time-out
\ and time-remain field; else print out error message.
: turn-off-alarm 	( ihandle acf -- )
1A271E8 	 0 74 75 72 6E 2D 6F 66 
1A271F0 	66 2D 61 6C 61 72 6D 8E 
1A271F8 	50 71 A2  1 20 40 A0  1 
   lock[	\ Lock out the alarm handler while modifying the list.
1A27200 	84 E0 A1  1 
   alarm-list ['] target-node? find-node  if	    ( ihandle acf prev )
1A27204 	90 6F A2  1 
1A27208 	60 53 A0  1  8 71 A2  1 
1A27210 	88 72 A1  1 DC 41 A0  1 
1A27218 	1C  0  0  0 
      delete-after alarm-node free-node             ( ihandle acf )
1A2721C 	58 72 A1  1 
1A27220 	 8 70 A2  1 88 74 A1  1 
      2drop                                         ( )
1A27228 	AC 49 A0  1 
   else                                             ( ihandle acf prev )
1A2722C 	C8 41 A0  1 
1A27230 	38  0  0  0 
      drop  ." No alarm was installed for " .h  cr  ( ihandle )
1A27234 	30 49 A0  1 
1A27238 	20 7C A0  1 1B 4E 6F 20 
1A27240 	61 6C 61 72 6D 20 77 61 
1A27248 	73 20 69 6E 73 74 61 6C 
1A27250 	6C 65 64 20 66 6F 72 20 
1A27258 	 0  0  0  0 10  E A1  1 
1A27260 	80 6D A0  1 
      drop                                          ( )
1A27264 	30 49 A0  1 
   then
   ]unlock
1A27268 	98 E0 A1  1 
;
1A2726C 	58 46 A0  1 


\ First check to see if the alarm is on (time-out >0).  If it is,
\ then check to see if the time is expired (time-remain = 0).
\ If time is not expired, decrement the time-remain.

: run-alarm 	( node -- )
1A27270 	 0  0 72 75 6E 2D 61 6C 
1A27278 	61 72 6D 89 FC 71 A2  1 
1A27280 	20 40 A0  1 
   dup  >time-remain @  1- dup 0<=  if  ( node time-remain )
1A27284 	40 49 A0  1 
1A27288 	C4 6F A2  1 5C 4C A0  1 
1A27290 	54 4B A0  1 40 49 A0  1 
1A27298 	84 47 A0  1 DC 41 A0  1 
1A272A0 	48  0  0  0 
      drop  dup >time-out @  over       ( node time-out node )
1A272A4 	30 49 A0  1 
1A272A8 	40 49 A0  1 A8 6F A2  1 
1A272B0 	5C 4C A0  1 54 49 A0  1 
      dup >acf @  swap >ihandle @       ( node time-out acf ihandle )
1A272B8 	40 49 A0  1 D8 6F A2  1 
1A272C0 	5C 4C A0  1 68 49 A0  1 
1A272C8 	F0 6F A2  1 5C 4C A0  1 
      ['] call-package  catch  if       ( node time-out acf ihandle )
1A272D0 	60 53 A0  1 8C 31 A2  1 
1A272D8 	14 7F A0  1 DC 41 A0  1 
1A272E0 	 8  0  0  0 
	 2drop                          ( node time-out )
1A272E4 	AC 49 A0  1 
      then                              ( node time-out )
   then  swap >time-remain !            ( )
1A272E8 	68 49 A0  1 C4 6F A2  1 
1A272F0 	54 4D A0  1 
;
1A272F4 	58 46 A0  1 

headers
\ We do this manually instead of using find-node because we need
\ to do >next-node before calling time-expired? in case the alarm
\ routine uninstalls itself, which could cause a crash if the
\ pointer to the next node were overwritten while being freed.
: check-alarm  ( -- )
1A272F8 	63 68 65 63 6B 2D 61 6C 
1A27300 	61 72 6D 8B 80 72 A2  1 
1A27308 	20 40 A0  1 
   alarm-list  >next-node      ( node )
1A2730C 	90 6F A2  1 
1A27310 	5C 4C A0  1 
   begin  ?dup  while          ( node )
1A27314 	B4 70 A0  1 
1A27318 	DC 41 A0  1 1C  0  0  0 
      dup >next-node  swap     ( next node )
1A27320 	40 49 A0  1 5C 4C A0  1 
1A27328 	68 49 A0  1 
      run-alarm                ( next )
1A2732C 	80 72 A2  1 
   repeat                      ( )
1A27330 	C8 41 A0  1 E0 FF FF FF 
;
1A27338 	58 46 A0  1 

: alarm 	( acf n -- )
1A2733C 	 0  0 61 6C 
1A27340 	61 72 6D 85  8 73 A2  1 
1A27348 	20 40 A0  1 
   my-self -rot                 ( ihandle acf n )
1A2734C 	EC 7E A0  1 
1A27350 	94 49 A0  1 
   ?dup if  set-alarm-node  else  turn-off-alarm  then
1A27354 	B4 70 A0  1 
1A27358 	DC 41 A0  1 10  0  0  0 
1A27360 	50 71 A2  1 C8 41 A0  1 
1A27368 	 8  0  0  0 FC 71 A2  1 
;
1A27370 	58 46 A0  1 

\ From clientif.fth
purpose: Client interface handler

headerless
only forth also definitions
\
\  Client Interface Handler
\

headers
forth also definitions

: setnode  ( nodeid | 0 -- )
1A27374 	73 65 74 6E 
1A27378 	6F 64 65 87 48 73 A2  1 
1A27380 	20 40 A0  1 
   dup 0=  if  drop root-phandle then  (push-package)
1A27384 	40 49 A0  1 
1A27388 	24 47 A0  1 DC 41 A0  1 
1A27390 	 C  0  0  0 30 49 A0  1 
1A27398 	F8 10 A2  1 38 FB A1  1 
;
1A273A0 	58 46 A0  1 

false value canonical-properties?
1A273A4 	 0  0 63 61 
1A273A8 	6E 6F 6E 69 63 61 6C 2D 
1A273B0 	70 72 6F 70 65 72 74 69 
1A273B8 	65 73 3F 95 80 73 A2  1 
1A273C0 	50 40 A0  1  8  8  0  0 
d# 32 buffer: canon-prop
1A273C8 	 0 63 61 6E 6F 6E 2D 70 
1A273D0 	72 6F 70 8A C0 73 A2  1 
1A273D8 	B4 A9 A0  1  C  8  0  0 
1A273E0 	20  0  0  0 D4 4D A2  1 
: $find-property  ( adr len -- adr len false | acf true )
1A273E8 	 0 24 66 69 6E 64 2D 70 
1A273F0 	72 6F 70 65 72 74 79 8E 
1A273F8 	D8 73 A2  1 20 40 A0  1 
   canonical-properties?  if  d# 31 min canon-prop $save 2dup lower  then
1A27400 	C0 73 A2  1 DC 41 A0  1 
1A27408 	20  0  0  0 58 41 A0  1 
1A27410 	1F  0  0  0 74 4A A0  1 
1A27418 	D8 73 A2  1 68 7E A0  1 
1A27420 	C0 49 A0  1 A4 85 A0  1 
   2dup current-properties (search-wordlist)  dup  if  2swap 2drop  then
1A27428 	C0 49 A0  1 98  C A2  1 
1A27430 	 0 BB A0  1 40 49 A0  1 
1A27438 	DC 41 A0  1  C  0  0  0 
1A27440 	F4 49 A0  1 AC 49 A0  1 
;
1A27448 	58 46 A0  1 
\
\ Generic Client Interface Services
\

only forth  ( also hidden  also forth )  also
  definitions
headers
caps @ caps off

: child  ( phandle -- phandle' )
1A2744C 	 0  0 63 68 
1A27450 	69 6C 64 85 FC 73 A2  1 
1A27458 	20 40 A0  1 
   setnode                           ( )
1A2745C 	80 73 A2  1 
   0  'child                         ( last-nodeid &next-nodeid )
1A27460 	70 6F A0  1  8 FA A1  1 
   begin  get-token?  while          ( last-nodeid next-nodeid )
1A27468 	6C 59 A0  1 DC 41 A0  1 
1A27470 	20  0  0  0 
      nip  dup voc>phandle (select-package)      ( next-nodeid )
1A27474 	FC 46 A0  1 
1A27478 	40 49 A0  1 40 F8 A1  1 
1A27480 	14 FB A1  1 
      'peer                          ( last-nodeid' &next-nodeid )
1A27484 	1C FA A1  1 
   repeat                            ( last-nodeid' )
1A27488 	C8 41 A0  1 DC FF FF FF 
   (pop-package)                     ( nodeid )
1A27490 	5C FB A1  1 
   dup  if  voc>phandle  then
1A27494 	40 49 A0  1 
1A27498 	DC 41 A0  1  8  0  0  0 
1A274A0 	40 F8 A1  1 
;
1A274A4 	58 46 A0  1 

: peer  ( phandle -- phandle' )
1A274A8 	 0  0  0 70 65 65 72 84 
1A274B0 	58 74 A2  1 20 40 A0  1 
   dup 0=  if
1A274B8 	40 49 A0  1 24 47 A0  1 
1A274C0 	DC 41 A0  1 10  0  0  0 
      drop root-phandle exit
1A274C8 	30 49 A0  1 F8 10 A2  1 
1A274D0 	40 46 A0  1 
   then                              ( nodeid )

   dup  root-phandle  =  if
1A274D4 	40 49 A0  1 
1A274D8 	F8 10 A2  1 24 48 A0  1 
1A274E0 	DC 41 A0  1 10  0  0  0 
      drop 0  exit
1A274E8 	30 49 A0  1 70 6F A0  1 
1A274F0 	40 46 A0  1 
   then                              ( nodeid )

   \ Select the first child of our parent
   dup >parent (push-package)        ( nodeid )
1A274F4 	40 49 A0  1 
1A274F8 	C0 FA A1  1 38 FB A1  1 
   'child token@ voc>phandle (select-package)    ( nodeid )
1A27500 	 8 FA A1  1  C 54 A0  1 
1A27508 	40 F8 A1  1 14 FB A1  1 

   dup current-device  =  if         ( nodeid )
1A27510 	40 49 A0  1 40 F9 A1  1 
1A27518 	24 48 A0  1 DC 41 A0  1 
1A27520 	14  0  0  0 
      \ Argument node is first child of parent; return "no more nodes"
      drop 0                         ( 0 )
1A27524 	30 49 A0  1 
1A27528 	70 6F A0  1 
   else                              ( nodeid )
1A2752C 	C8 41 A0  1 
1A27530 	34  0  0  0 
      \ Search for the node preceding the argument node
      begin                          ( nodeid )
         'peer token@ voc>phandle 2dup  <>       ( nodeid next-nodeid flag )
1A27534 	1C FA A1  1 
1A27538 	 C 54 A0  1 40 F8 A1  1 
1A27540 	C0 49 A0  1 44 48 A0  1 
      while                          ( nodeid next-nodeid )
1A27548 	DC 41 A0  1 10  0  0  0 
         push-device                 ( nodeid )
1A27550 	F8 FB A1  1 
      repeat                         ( nodeid )
1A27554 	C8 41 A0  1 
1A27558 	DC FF FF FF 
      2drop current-device           ( nodeid' )
1A2755C 	AC 49 A0  1 
1A27560 	40 F9 A1  1 
   then                              ( nodeid | 0 )
   (pop-package)                     ( nodeid | 0 )
1A27564 	5C FB A1  1 
;
1A27568 	58 46 A0  1 

: instance-to-package  ( ihandle -- phandle )  ihandle>phandle  ;
1A2756C 	69 6E 73 74 
1A27570 	61 6E 63 65 2D 74 6F 2D 
1A27578 	70 61 63 6B 61 67 65 93 
1A27580 	B4 74 A2  1 20 40 A0  1 
1A27588 	 0 32 A2  1 58 46 A0  1 

: milliseconds ( -- )  get-msecs   ;
1A27590 	 0  0  0 6D 69 6C 6C 69 
1A27598 	73 65 63 6F 6E 64 73 8C 
1A275A0 	84 75 A2  1 20 40 A0  1 
1A275A8 	50 E0 A1  1 58 46 A0  1 

: execute-buffer ( adr len -- )  'execute-buffer execute  ;
1A275B0 	 0 65 78 65 63 75 74 65 
1A275B8 	2D 62 75 66 66 65 72 8E 
1A275C0 	A4 75 A2  1 20 40 A0  1 
1A275C8 	50 E6 A1  1 98 41 A0  1 
1A275D0 	58 46 A0  1 
caps !

also forth definitions
alias child child	\ Make visible outside the client-services package
1A275D4 	 0  0 63 68 
1A275D8 	69 6C 64 A5 C4 75 A2  1 
1A275E0 	58 74 A2  1 
alias peer peer		\ Make visible outside the client-services package
1A275E4 	 0  0  0 70 
1A275E8 	65 65 72 A4 E0 75 A2  1 
1A275F0 	B4 74 A2  1 

only forth also definitions


previous definitions

\ From deladdr.fth
purpose: Delete stale address properties for virtual addresses
copyright: Copyright 1990-1994 Sun Microsystems, Inc.  All Rights Reserved

\ When freeing virtual memory, if the address property of the current
\ device refers to that virtual memory, delete the address property.

headerless
: ?delete-address  ( adr len -- adr len )
1A275F4 	3F 64 65 6C 
1A275F8 	65 74 65 2D 61 64 64 72 
1A27600 	65 73 73 8F F0 75 A2  1 
1A27608 	20 40 A0  1 
   my-self  if                                       ( adr len )
1A2760C 	EC 7E A0  1 
1A27610 	DC 41 A0  1 5C  0  0  0 
      my-voc (push-package)                          ( adr len )
1A27618 	10  4 A2  1 38 FB A1  1 
      " address" get-property  0=  if                ( adr len value-adr,len )
1A27620 	9C 53 A0  1  7 61 64 64 
1A27628 	72 65 73 73  0  0  0  0 
1A27630 	F4  D A2  1 24 47 A0  1 
1A27638 	DC 41 A0  1 30  0  0  0 
         get-encoded-cell  2 pick  =  if             ( adr len )
1A27640 	20 F8 A1  1 90 6F A0  1 
1A27648 	 C 4A A0  1 24 48 A0  1 
1A27650 	DC 41 A0  1 18  0  0  0 
            " address" delete-property               ( adr len )
1A27658 	9C 53 A0  1  7 61 64 64 
1A27660 	72 65 73 73  0  0  0  0 
1A27668 	14 15 A2  1 
         then                                        ( adr len )
      then                                           ( adr len )
      (pop-package)                                  ( adr len )
1A2766C 	5C FB A1  1 
   then                                              ( adr len )
;
1A27670 	58 46 A0  1 
headers
: free-virtual  ( adr len -- )  ?delete-address  " map-out" $call-parent  ;
1A27674 	 0  0  0 66 
1A27678 	72 65 65 2D 76 69 72 74 
1A27680 	75 61 6C 8C  8 76 A2  1 
1A27688 	20 40 A0  1  8 76 A2  1 
1A27690 	9C 53 A0  1  7 6D 61 70 
1A27698 	2D 6F 75 74  0  0  0  0 
1A276A0 	DC 31 A2  1 58 46 A0  1 

also hidden
: method-call?  ( xt -- flag )
1A276A8 	 0  0  0 6D 65 74 68 6F 
1A276B0 	64 2D 63 61 6C 6C 3F 8C 
1A276B8 	88 76 A2  1 20 40 A0  1 
   dup (indirect-call?)  if  drop true exit  then  ( xt )
1A276C0 	40 49 A0  1 60 C5 A1  1 
1A276C8 	DC 41 A0  1 10  0  0  0 
1A276D0 	30 49 A0  1  4 70 A0  1 
1A276D8 	40 46 A0  1 
   dup ['] $call-self =  if  drop true exit  then  ( xt )
1A276DC 	40 49 A0  1 
1A276E0 	60 53 A0  1 B4 30 A2  1 
1A276E8 	24 48 A0  1 DC 41 A0  1 
1A276F0 	10  0  0  0 30 49 A0  1 
1A276F8 	 4 70 A0  1 40 46 A0  1 
   dup ['] $call-method =  if  drop true exit  then  ( xt )
1A27700 	40 49 A0  1 60 53 A0  1 
1A27708 	B4 31 A2  1 24 48 A0  1 
1A27710 	DC 41 A0  1 10  0  0  0 
1A27718 	30 49 A0  1  4 70 A0  1 
1A27720 	40 46 A0  1 
   dup ['] $call-parent =  if  drop true exit  then  ( xt )
1A27724 	40 49 A0  1 
1A27728 	60 53 A0  1 DC 31 A2  1 
1A27730 	24 48 A0  1 DC 41 A0  1 
1A27738 	10  0  0  0 30 49 A0  1 
1A27740 	 4 70 A0  1 40 46 A0  1 
   dup ['] call-package =  if  drop true exit  then  ( xt )
1A27748 	40 49 A0  1 60 53 A0  1 
1A27750 	8C 31 A2  1 24 48 A0  1 
1A27758 	DC 41 A0  1 10  0  0  0 
1A27760 	30 49 A0  1  4 70 A0  1 
1A27768 	40 46 A0  1 
   dup ['] $vexecute    =  if  drop true exit  then  ( xt )
1A2776C 	40 49 A0  1 
1A27770 	60 53 A0  1 D0  D A2  1 
1A27778 	24 48 A0  1 DC 41 A0  1 
1A27780 	10  0  0  0 30 49 A0  1 
1A27788 	 4 70 A0  1 40 46 A0  1 
   dup ['] $vexecute?   =  if  drop true exit  then  ( xt )
1A27790 	40 49 A0  1 60 53 A0  1 
1A27798 	54  D A2  1 24 48 A0  1 
1A277A0 	DC 41 A0  1 10  0  0  0 
1A277A8 	30 49 A0  1  4 70 A0  1 
1A277B0 	40 46 A0  1 
   dup ['] $package-execute? =  if  drop true exit  then  ( xt )
1A277B4 	40 49 A0  1 
1A277B8 	60 53 A0  1 94  D A2  1 
1A277C0 	24 48 A0  1 DC 41 A0  1 
1A277C8 	10  0  0  0 30 49 A0  1 
1A277D0 	 4 70 A0  1 40 46 A0  1 
   dup ['] package-execute   =  if  drop true exit  then  ( xt )
1A277D8 	40 49 A0  1 60 53 A0  1 
1A277E0 	E8 19 A2  1 24 48 A0  1 
1A277E8 	DC 41 A0  1 10  0  0  0 
1A277F0 	30 49 A0  1  4 70 A0  1 
1A277F8 	40 46 A0  1 
   dup ['] apply-method      =  if  drop true exit  then  ( xt )
1A277FC 	40 49 A0  1 
1A27800 	60 53 A0  1 A0 38 A2  1 
1A27808 	24 48 A0  1 DC 41 A0  1 
1A27810 	10  0  0  0 30 49 A0  1 
1A27818 	 4 70 A0  1 40 46 A0  1 
   dup ['] (apply-method)    =  if  drop true exit  then  ( xt )
1A27820 	40 49 A0  1 60 53 A0  1 
1A27828 	20 3C A2  1 24 48 A0  1 
1A27830 	DC 41 A0  1 10  0  0  0 
1A27838 	30 49 A0  1  4 70 A0  1 
1A27840 	40 46 A0  1 
   dup ['] (execute-method)  =  if  drop true exit  then  ( xt )
1A27844 	40 49 A0  1 
1A27848 	60 53 A0  1 54 3F A2  1 
1A27850 	24 48 A0  1 DC 41 A0  1 
1A27858 	10  0  0  0 30 49 A0  1 
1A27860 	 4 70 A0  1 40 46 A0  1 
   dup ['] execute-device-method  =  if  drop true exit  then  ( xt )
1A27868 	40 49 A0  1 60 53 A0  1 
1A27870 	84 3F A2  1 24 48 A0  1 
1A27878 	DC 41 A0  1 10  0  0  0 
1A27880 	30 49 A0  1  4 70 A0  1 
1A27888 	40 46 A0  1 
   drop false
1A2788C 	30 49 A0  1 
1A27890 	18 70 A0  1 
;
1A27894 	58 46 A0  1 
' method-call? to indirect-call?
previous

purpose: Calibrate Time Stamp Counter against ISA timer - without interrupts

\ This code works only for processors that have a Time Stamp Counter register

code calibrate-loop  ( -- tscdelta )
1A3E6B0 	 0 63 61 6C 69 62 72 61 
1A3E6B8 	74 65 2D 6C 6F 6F 70 8E 
1A3E6C0 	10 BB A3  1 C8 E6 A3  1 
   \ setup timer 0 to interrupt when the count goes to 0

   \ TTRR.MMMB Timer 0, r/w=lsb,msb, mode 0, binary
   h# 30 #  al  mov   al  h# 43 #  out	\ Start setting timer
1A3E6C8 	B0 30 E6 43 

   d# 11932 wbsplit swap     ( tick-cnt-high tick-cnt-low )
   #  al  mov   al  h# 40 #  out	\ Set tick limit low  ( tick-cnt-high )
1A3E6CC 	B0 9C E6 40 
					\ The timer should now be stopped

   h# f c,  h# 31 c,	\ Get time-stamp counter value into DX,AX
1A3E6D0 	 F 31 
   ax cx mov		\ Save the low part in CX; the high part is not needed
1A3E6D2 	8B C8 

   #  al  mov   al  h# 40 #  out	\ Set tick limit high to start timer
1A3E6D4 	B0 2E E6 40 

   begin
      ax ax xor  al  h# 43 #  out	\ Latch timer
1A3E6D8 	31 C0 E6 43 
      h# 40 # al in
1A3E6DC 	E4 40 
      al ah mov
1A3E6DE 	8A E0 
      h# 40 # al in
1A3E6E0 	E4 40 
      al ah xchg
1A3E6E2 	86 E0 
      \ The number 10 below gives a sufficient window to ensure that a count
      \ value in the range from 0 to 9 is seen.  The process of latching the
      \ timer and reading the value is time-consuming because I/O port access
      \ is slow, comparable to the clock that drives the ticker.  For many
      \ systems, a value of 5 is enough, but I have seen systems that need 8.
      d# 10 #  ax  cmp
1A3E6E4 	3D  A  0  0 
1A3E6E8 	 0 
   < until
1A3E6E9 	7D ED 
   
   h# f c,  h# 31 c,	\ Get time-stamp counter value into DX,AX
1A3E6EB 	 F 31 
   cx ax sub		\ Subtract the low parts
1A3E6ED 	29 C8 
   
   ax push
1A3E6EF 	50 
c;
1A3E6F0 	FF E7 


\needs ms-factor -1 value ms-factor
\needs us-factor -1 value us-factor
: calibrate-ms  ( -- )
1A3E6F2 	 0 63 61 6C 69 62 
1A3E6F8 	72 61 74 65 2D 6D 73 8C 
1A3E700 	C4 E6 A3  1 20 40 A0  1 
\ mmo   disable-interrupts
   calibrate-loop   dup d# 10 / to ms-factor  ( count-value )
1A3E708 	C4 E6 A3  1 40 49 A0  1 
1A3E710 	58 41 A0  1  A  0  0  0 
1A3E718 	98 5F A0  1 B8 40 A0  1 
1A3E720 	80 85 A3  1 
   d# 10000 / to us-factor   \ Divide by 1000 with rounding
1A3E724 	58 41 A0  1 
1A3E728 	10 27  0  0 98 5F A0  1 
1A3E730 	B8 40 A0  1 98 85 A3  1 
;
1A3E738 	58 46 A0  1 
stand-init: Calibrating millisecond timer
1A3E73C 	 0 73 74 61 
1A3E740 	6E 64 2D 69 6E 69 74 8A 
1A3E748 	 4 E7 A3  1 20 40 A0  1 
1A3E750 	3C 9D A3  1 9C 53 A0  1 
1A3E758 	1D 43 61 6C 69 62 72 61 
1A3E760 	74 69 6E 67 20 6D 69 6C 
1A3E768 	6C 69 73 65 63 6F 6E 64 
1A3E770 	20 74 69 6D 65 72  0  0 
1A3E778 	80 6D A0  1  4 6C A0  1 
   calibrate-ms
1A3E780 	 4 E7 A3  1 
;
1A3E784 	58 46 A0  1 

